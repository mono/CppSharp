// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------

using System;
using System.Collections.Generic;

namespace CppSharp.AST
{
    public enum CastKind
    {
        Dependent = 0,
        BitCast = 1,
        LValueBitCast = 2,
        LValueToRValue = 3,
        NoOp = 4,
        BaseToDerived = 5,
        DerivedToBase = 6,
        UncheckedDerivedToBase = 7,
        Dynamic = 8,
        ToUnion = 9,
        ArrayToPointerDecay = 10,
        FunctionToPointerDecay = 11,
        NullToPointer = 12,
        NullToMemberPointer = 13,
        BaseToDerivedMemberPointer = 14,
        DerivedToBaseMemberPointer = 15,
        MemberPointerToBoolean = 16,
        ReinterpretMemberPointer = 17,
        UserDefinedConversion = 18,
        ConstructorConversion = 19,
        IntegralToPointer = 20,
        PointerToIntegral = 21,
        PointerToBoolean = 22,
        ToVoid = 23,
        VectorSplat = 24,
        IntegralCast = 25,
        IntegralToBoolean = 26,
        IntegralToFloating = 27,
        FixedPointCast = 28,
        FixedPointToBoolean = 29,
        FloatingToIntegral = 30,
        FloatingToBoolean = 31,
        BooleanToSignedIntegral = 32,
        FloatingCast = 33,
        CPointerToObjCPointerCast = 34,
        BlockPointerToObjCPointerCast = 35,
        AnyPointerToBlockPointerCast = 36,
        ObjCObjectLValueCast = 37,
        FloatingRealToComplex = 38,
        FloatingComplexToReal = 39,
        FloatingComplexToBoolean = 40,
        FloatingComplexCast = 41,
        FloatingComplexToIntegralComplex = 42,
        IntegralRealToComplex = 43,
        IntegralComplexToReal = 44,
        IntegralComplexToBoolean = 45,
        IntegralComplexCast = 46,
        IntegralComplexToFloatingComplex = 47,
        ARCProduceObject = 48,
        ARCConsumeObject = 49,
        ARCReclaimReturnedObject = 50,
        ARCExtendBlockObject = 51,
        AtomicToNonAtomic = 52,
        NonAtomicToAtomic = 53,
        CopyAndAutoreleaseBlockObject = 54,
        BuiltinFnToFnPtr = 55,
        ZeroToOCLOpaqueType = 56,
        AddressSpaceConversion = 57,
        IntToOCLSampler = 58
    }

    public enum BinaryOperatorKind
    {
        PtrMemD = 0,
        PtrMemI = 1,
        Mul = 2,
        Div = 3,
        Rem = 4,
        Add = 5,
        Sub = 6,
        Shl = 7,
        Shr = 8,
        Cmp = 9,
        LT = 10,
        GT = 11,
        LE = 12,
        GE = 13,
        EQ = 14,
        NE = 15,
        And = 16,
        Xor = 17,
        Or = 18,
        LAnd = 19,
        LOr = 20,
        Assign = 21,
        MulAssign = 22,
        DivAssign = 23,
        RemAssign = 24,
        AddAssign = 25,
        SubAssign = 26,
        ShlAssign = 27,
        ShrAssign = 28,
        AndAssign = 29,
        XorAssign = 30,
        OrAssign = 31,
        Comma = 32
    }

    public enum UnaryOperatorKind
    {
        PostInc = 0,
        PostDec = 1,
        PreInc = 2,
        PreDec = 3,
        AddrOf = 4,
        Deref = 5,
        Plus = 6,
        Minus = 7,
        Not = 8,
        LNot = 9,
        Real = 10,
        Imag = 11,
        Extension = 12,
        Coawait = 13
    }

    public enum ObjCBridgeCastKind
    {
        /// <summary>
/// <para>Bridging via __bridge, which does nothing but reinterpret</para>
/// <para>the bits.</para>
/// </summary>
        Bridge = 0,
        /// <summary>
/// <para>Bridging via __bridge_transfer, which transfers ownership of an</para>
/// <para>Objective-C pointer into ARC.</para>
/// </summary>
        BridgeTransfer = 1,
        /// <summary>
/// <para>Bridging via __bridge_retain, which makes an ARC object available</para>
/// <para>as a +1 C pointer.</para>
/// </summary>
        BridgeRetained = 2
    }

    public enum OverloadedOperatorKind
    {
        /// <summary>Not an overloaded operator</summary>
        None = 0,
        New = 1,
        Delete = 2,
        ArrayNew = 3,
        ArrayDelete = 4,
        Plus = 5,
        Minus = 6,
        Star = 7,
        Slash = 8,
        Percent = 9,
        Caret = 10,
        Amp = 11,
        Pipe = 12,
        Tilde = 13,
        Exclaim = 14,
        Equal = 15,
        Less = 16,
        Greater = 17,
        PlusEqual = 18,
        MinusEqual = 19,
        StarEqual = 20,
        SlashEqual = 21,
        PercentEqual = 22,
        CaretEqual = 23,
        AmpEqual = 24,
        PipeEqual = 25,
        LessLess = 26,
        GreaterGreater = 27,
        LessLessEqual = 28,
        GreaterGreaterEqual = 29,
        EqualEqual = 30,
        ExclaimEqual = 31,
        LessEqual = 32,
        GreaterEqual = 33,
        Spaceship = 34,
        AmpAmp = 35,
        PipePipe = 36,
        PlusPlus = 37,
        MinusMinus = 38,
        Comma = 39,
        ArrowStar = 40,
        Arrow = 41,
        Call = 42,
        Subscript = 43,
        Conditional = 44,
        Coawait = 45,
    }

    public enum UnaryExprOrTypeTrait
    {
        SizeOf = 0,
        /// <summary>
/// <para>Used for C's _Alignof and C++'s alignof.</para>
/// <para>_Alignof and alignof return the required ABI alignment.</para>
/// </summary>
        AlignOf = 1,
        /// <summary>
/// <para>Used for C's _Alignof and C++'s alignof.</para>
/// <para>_Alignof and alignof return the required ABI alignment.</para>
/// </summary>
        VecStep = 2,
        /// <summary>
/// <para>Used for C's _Alignof and C++'s alignof.</para>
/// <para>_Alignof and alignof return the required ABI alignment.</para>
/// </summary>
        OpenMPRequiredSimdAlign = 3,
        /// <summary>
/// <para>Used for GCC's __alignof.</para>
/// <para>__alignof returns the preferred alignment of a type, the alignment</para>
/// <para>clang will attempt to give an object of the type if allowed by ABI.</para>
/// </summary>
        PreferredAlignOf = 4
    }

    public partial class Expr : Stmt
    {
        public enum LValueClassification
        {
            Valid = 0,
            NotObjectType = 1,
            IncompleteVoidType = 2,
            DuplicateVectorComponents = 3,
            InvalidExpression = 4,
            InvalidMessageExpression = 5,
            MemberFunction = 6,
            SubObjCPropertySetting = 7,
            ClassTemporary = 8,
            ArrayTemporary = 9
        }

        public enum isModifiableLvalueResult
        {
            Valid = 0,
            NotObjectType = 1,
            IncompleteVoidType = 2,
            DuplicateVectorComponents = 3,
            InvalidExpression = 4,
            LValueCast = 5,
            IncompleteType = 6,
            ConstQualified = 7,
            ConstQualifiedField = 8,
            ConstAddrSpace = 9,
            ArrayType = 10,
            NoSetterProperty = 11,
            MemberFunction = 12,
            SubObjCPropertySetting = 13,
            InvalidMessageExpression = 14,
            ClassTemporary = 15,
            ArrayTemporary = 16
        }

        public enum SideEffectsKind
        {
            /// <summary>Strictly evaluate the expression.</summary>
            NoSideEffects = 0,
            /// <summary>
/// <para>Allow UB that we can give a value, but not</para>
/// <para>arbitrary unmodeled side effects.</para>
/// </summary>
            AllowUndefinedBehavior = 1,
            /// <summary>Allow any unmodeled side effect.</summary>
            AllowSideEffects = 2
        }

        public enum ConstExprUsage
        {
            EvaluateForCodeGen = 0,
            EvaluateForMangling = 1
        }

        public enum NullPointerConstantKind
        {
            /// <summary>Expression is not a Null pointer constant.</summary>
            NotNull = 0,
            /// <summary>
/// <para>Expression is a Null pointer constant built from a zero integer</para>
/// <para>expression that is not a simple, possibly parenthesized, zero literal.</para>
/// <para>C++ Core Issue 903 will classify these expressions as &quot;not pointers&quot;</para>
/// <para>once it is adopted.</para>
/// <para>http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#903</para>
/// </summary>
            ZeroExpression = 1,
            /// <summary>Expression is a Null pointer constant built from a literal zero.</summary>
            ZeroLiteral = 2,
            /// <summary>Expression is a C++11 nullptr.</summary>
            CXX11_nullptr = 3,
            /// <summary>Expression is a GNU-style __null constant.</summary>
            GNUNull = 4
        }

        public enum NullPointerConstantValueDependence
        {
            /// <summary>Specifies that the expression should never be value-dependent.</summary>
            NeverValueDependent = 0,
            /// <summary>
/// <para>Specifies that a value-dependent expression of integral or</para>
/// <para>dependent type should be considered a null pointer constant.</para>
/// </summary>
            ValueDependentIsNull = 1,
            /// <summary>
/// <para>Specifies that a value-dependent expression should be considered</para>
/// <para>to never be a null pointer constant.</para>
/// </summary>
            ValueDependentIsNotNull = 2
        }

        public partial class Classification
        {
            public enum Kinds
            {
                LValue = 0,
                XValue = 1,
                Function = 2,
                Void = 3,
                AddressableVoid = 4,
                DuplicateVectorComponents = 5,
                MemberFunction = 6,
                SubObjCPropertySetting = 7,
                ClassTemporary = 8,
                ArrayTemporary = 9,
                ObjCMessageRValue = 10,
                PRValue = 11
            }

            public enum ModifiableType
            {
                Untested = 0,
                Modifiable = 1,
                RValue = 2,
                Function = 3,
                LValueCast = 4,
                NoSetterProperty = 5,
                ConstQualified = 6,
                ConstQualifiedField = 7,
                ConstAddrSpace = 8,
                ArrayType = 9,
                IncompleteType = 10
            }

            public Classification()
            {
            }

            public Expr.Classification.Kinds Kind;
            public Expr.Classification.ModifiableType Modifiable;
            public bool IsLValue;
            public bool IsXValue;
            public bool IsGLValue;
            public bool IsPRValue;
            public bool IsRValue;
            public bool IsModifiable;
        }

        public Expr()
        {
        }

        public QualifiedType Type;
        public bool ValueDependent;
        public bool TypeDependent;
        public bool InstantiationDependent;
        public bool ContainsUnexpandedParameterPack;
        public SourceLocation ExprLoc;
        public bool IsLValue;
        public bool IsRValue;
        public bool IsXValue;
        public bool IsGLValue;
        public bool IsOrdinaryOrBitFieldObject;
    }

    public partial class FullExpr : Expr
    {
        public FullExpr()
        {
        }

        public Expr SubExpr;
    }

    public partial class ConstantExpr : FullExpr
    {
        public ConstantExpr()
        {
        }

    }

    public partial class OpaqueValueExpr : Expr
    {
        public OpaqueValueExpr()
        {
        }

        public bool IsUnique;
        public SourceLocation Location;
        public Expr SourceExpr;
    }

    public partial class DeclRefExpr : Expr
    {
        public DeclRefExpr()
        {
        }

        public SourceLocation Location;
        public bool HadMultipleCandidates;
        public bool HasQualifier;
        public bool HasTemplateKWAndArgsInfo;
        public SourceLocation TemplateKeywordLoc;
        public SourceLocation LAngleLoc;
        public SourceLocation RAngleLoc;
        public bool HasTemplateKeyword;
        public bool HasExplicitTemplateArgs;
        public uint NumTemplateArgs;
        public bool RefersToEnclosingVariableOrCapture;
    }

    public partial class IntegerLiteral : Expr
    {
        public IntegerLiteral()
        {
        }

        public SourceLocation Location;
        public ulong Value;
    }

    public partial class FixedPointLiteral : Expr
    {
        public FixedPointLiteral()
        {
        }

        public SourceLocation Location;
        public ulong Value;
    }

    public partial class CharacterLiteral : Expr
    {
        public enum CharacterKind
        {
            Ascii = 0,
            Wide = 1,
            UTF8 = 2,
            UTF16 = 3,
            UTF32 = 4
        }

        public CharacterLiteral()
        {
        }

        public SourceLocation Location;
        public CharacterLiteral.CharacterKind Kind;
        public uint Value;
    }

    public partial class FloatingLiteral : Expr
    {
        public FloatingLiteral()
        {
        }

        public bool Exact;
        public SourceLocation Location;
        public double ValueAsApproximateDouble;
    }

    public partial class ImaginaryLiteral : Expr
    {
        public ImaginaryLiteral()
        {
        }

        public Expr SubExpr;
    }

    public partial class StringLiteral : Expr
    {
        public enum StringKind
        {
            Ascii = 0,
            Wide = 1,
            UTF8 = 2,
            UTF16 = 3,
            UTF32 = 4
        }

        public StringLiteral()
        {
        }

        public string String;
        public string Bytes;
        public uint ByteLength;
        public uint Length;
        public uint CharByteWidth;
        public StringLiteral.StringKind Kind;
        public bool IsAscii;
        public bool IsWide;
        public bool IsUTF8;
        public bool IsUTF16;
        public bool IsUTF32;
        public bool IsPascal;
        public bool ContainsNonAscii;
        public bool ContainsNonAsciiOrNull;
        public uint NumConcatenated;
    }

    public partial class PredefinedExpr : Expr
    {
        public enum IdentKind
        {
            Func = 0,
            Function = 1,
            LFunction = 2,
            FuncDName = 3,
            FuncSig = 4,
            LFuncSig = 5,
            PrettyFunction = 6,
            /// <summary>
/// <para>The same as PrettyFunction, except that the</para>
/// <para>'virtual' keyword is omitted for virtual member functions.</para>
/// </summary>
            PrettyFunctionNoVirtual = 7
        }

        public PredefinedExpr()
        {
        }

        public SourceLocation Location;
        public PredefinedExpr.IdentKind identKind;
    }

    public partial class ParenExpr : Expr
    {
        public ParenExpr()
        {
        }

        public Expr SubExpr;
        public SourceLocation LParen;
        public SourceLocation RParen;
    }

    public partial class UnaryOperator : Expr
    {
        public UnaryOperator()
        {
        }

        public UnaryOperatorKind Opcode;
        public Expr SubExpr;
        public SourceLocation OperatorLoc;
        public bool CanOverflow;
    }

    public partial class OffsetOfExpr : Expr
    {
        public OffsetOfExpr()
        {
        }

        public SourceLocation OperatorLoc;
        public SourceLocation RParenLoc;
        public uint NumComponents;
        public uint NumExpressions;
    }

    public partial class UnaryExprOrTypeTraitExpr : Expr
    {
        public UnaryExprOrTypeTraitExpr()
        {
        }

        public UnaryExprOrTypeTrait Kind;
        public SourceLocation OperatorLoc;
        public SourceLocation RParenLoc;
        public bool IsArgumentType;
        public QualifiedType ArgumentType;
        public QualifiedType TypeOfArgument;
    }

    public partial class ArraySubscriptExpr : Expr
    {
        public ArraySubscriptExpr()
        {
        }

        public Expr LHS;
        public Expr RHS;
        public SourceLocation RBracketLoc;
    }

    public partial class CallExpr : Expr
    {
        public CallExpr()
        {
        }

        public List<Expr> Arguments = new List<Expr>();
        public Expr Callee;
        public SourceLocation RParenLoc;
        public uint NumArgs;
        public uint NumCommas;
        public uint BuiltinCallee;
        public bool IsCallToStdMove;
    }

    public partial class MemberExpr : Expr
    {
        public MemberExpr()
        {
        }

        public Expr Base;
        public bool Arrow;
        public SourceLocation MemberLoc;
        public bool HadMultipleCandidates;
        public bool HasQualifier;
        public SourceLocation TemplateKeywordLoc;
        public SourceLocation LAngleLoc;
        public SourceLocation RAngleLoc;
        public bool HasTemplateKeyword;
        public bool HasExplicitTemplateArgs;
        public uint NumTemplateArgs;
        public SourceLocation OperatorLoc;
        public bool IsImplicitAccess;
    }

    public partial class CompoundLiteralExpr : Expr
    {
        public CompoundLiteralExpr()
        {
        }

        public Expr Initializer;
        public bool FileScope;
        public SourceLocation LParenLoc;
    }

    public partial class CastExpr : Expr
    {
        public CastExpr()
        {
        }

        public CastKind CastKind;
        public Expr SubExpr;
        public Declaration ConversionFunction;
        public bool PathEmpty;
        public uint PathSize;
    }

    public partial class ImplicitCastExpr : CastExpr
    {
        public enum OnStack_t
        {
            OnStack = 0
        }

        public ImplicitCastExpr()
        {
        }

        public bool IsPartOfExplicitCast;
    }

    public partial class ExplicitCastExpr : CastExpr
    {
        public ExplicitCastExpr()
        {
        }

        public QualifiedType TypeAsWritten;
    }

    public partial class CStyleCastExpr : ExplicitCastExpr
    {
        public CStyleCastExpr()
        {
        }

        public SourceLocation LParenLoc;
        public SourceLocation RParenLoc;
    }

    public partial class BinaryOperator : Expr
    {
        public BinaryOperator()
        {
        }

        public SourceLocation OperatorLoc;
        public BinaryOperatorKind Opcode;
        public Expr LHS;
        public Expr RHS;
        public bool IsFPContractableWithinStatement;
        public bool IsFEnvAccessOn;
    }

    public partial class CompoundAssignOperator : BinaryOperator
    {
        public CompoundAssignOperator()
        {
        }

        public QualifiedType ComputationLHSType;
        public QualifiedType ComputationResultType;
    }

    public partial class AbstractConditionalOperator : Expr
    {
        public AbstractConditionalOperator()
        {
        }

        public Expr Cond;
        public Expr TrueExpr;
        public Expr FalseExpr;
        public SourceLocation QuestionLoc;
        public SourceLocation ColonLoc;
    }

    public partial class ConditionalOperator : AbstractConditionalOperator
    {
        public ConditionalOperator()
        {
        }

        public Expr LHS;
        public Expr RHS;
    }

    public partial class BinaryConditionalOperator : AbstractConditionalOperator
    {
        public BinaryConditionalOperator()
        {
        }

        public Expr Common;
        public OpaqueValueExpr OpaqueValue;
    }

    public partial class AddrLabelExpr : Expr
    {
        public AddrLabelExpr()
        {
        }

        public SourceLocation AmpAmpLoc;
        public SourceLocation LabelLoc;
    }

    public partial class StmtExpr : Expr
    {
        public StmtExpr()
        {
        }

        public CompoundStmt SubStmt;
        public SourceLocation LParenLoc;
        public SourceLocation RParenLoc;
    }

    public partial class ShuffleVectorExpr : Expr
    {
        public ShuffleVectorExpr()
        {
        }

        public SourceLocation BuiltinLoc;
        public SourceLocation RParenLoc;
        public uint NumSubExprs;
    }

    public partial class ConvertVectorExpr : Expr
    {
        public ConvertVectorExpr()
        {
        }

        public Expr SrcExpr;
        public SourceLocation BuiltinLoc;
        public SourceLocation RParenLoc;
    }

    public partial class ChooseExpr : Expr
    {
        public ChooseExpr()
        {
        }

        public bool IsConditionTrue;
        public Expr Cond;
        public Expr LHS;
        public Expr RHS;
        public SourceLocation BuiltinLoc;
        public SourceLocation RParenLoc;
        public bool IsConditionDependent;
        public Expr ChosenSubExpr;
    }

    public partial class GNUNullExpr : Expr
    {
        public GNUNullExpr()
        {
        }

        public SourceLocation TokenLocation;
    }

    public partial class VAArgExpr : Expr
    {
        public VAArgExpr()
        {
        }

        public Expr SubExpr;
        public bool IsMicrosoftABI;
        public SourceLocation BuiltinLoc;
        public SourceLocation RParenLoc;
    }

    public partial class InitListExpr : Expr
    {
        public InitListExpr()
        {
        }

        public Expr ArrayFiller;
        public SourceLocation LBraceLoc;
        public SourceLocation RBraceLoc;
        public InitListExpr SyntacticForm;
        public uint NumInits;
        public bool HasArrayFiller;
        public bool IsExplicit;
        public bool IsStringLiteralInit;
        public bool IsTransparent;
        public bool IsSemanticForm;
        public InitListExpr SemanticForm;
        public bool IsSyntacticForm;
    }

    public partial class DesignatedInitExpr : Expr
    {
        public partial class Designator
        {
            public Designator()
            {
            }

            public Field Field;
            public bool IsFieldDesignator;
            public bool IsArrayDesignator;
            public bool IsArrayRangeDesignator;
            public SourceLocation DotLoc;
            public SourceLocation FieldLoc;
            public SourceLocation LBracketLoc;
            public SourceLocation RBracketLoc;
            public SourceLocation EllipsisLoc;
            public uint FirstExprIndex;
            public SourceRange SourceRange;
        }
        public partial class FieldDesignator
        {
            public FieldDesignator()
            {
            }

        }
        public partial class ArrayOrRangeDesignator
        {
            public ArrayOrRangeDesignator()
            {
            }

        }

        public DesignatedInitExpr()
        {
        }

        public SourceLocation EqualOrColonLoc;
        public Expr Init;
        public uint Size;
        public bool UsesGNUSyntax;
        public uint NumSubExprs;
        public SourceRange DesignatorsSourceRange;
    }

    public partial class NoInitExpr : Expr
    {
        public NoInitExpr()
        {
        }

    }

    public partial class DesignatedInitUpdateExpr : Expr
    {
        public DesignatedInitUpdateExpr()
        {
        }

        public Expr Base;
        public InitListExpr Updater;
    }

    public partial class ArrayInitLoopExpr : Expr
    {
        public ArrayInitLoopExpr()
        {
        }

        public OpaqueValueExpr CommonExpr;
        public Expr SubExpr;
    }

    public partial class ArrayInitIndexExpr : Expr
    {
        public ArrayInitIndexExpr()
        {
        }

    }

    public partial class ImplicitValueInitExpr : Expr
    {
        public ImplicitValueInitExpr()
        {
        }

    }

    public partial class ParenListExpr : Expr
    {
        public ParenListExpr()
        {
        }

        public uint NumExprs;
        public SourceLocation LParenLoc;
        public SourceLocation RParenLoc;
    }

    public partial class GenericSelectionExpr : Expr
    {
        public GenericSelectionExpr()
        {
        }

        public uint NumAssocs;
        public SourceLocation GenericLoc;
        public SourceLocation DefaultLoc;
        public SourceLocation RParenLoc;
        public bool IsResultDependent;
        public uint ResultIndex;
    }

    public partial class ExtVectorElementExpr : Expr
    {
        public ExtVectorElementExpr()
        {
        }

        public Expr Base;
        public SourceLocation AccessorLoc;
        public uint NumElements;
        public bool ContainsDuplicateElements;
        public bool IsArrow;
    }

    public partial class BlockExpr : Expr
    {
        public BlockExpr()
        {
        }

        public SourceLocation CaretLocation;
    }

    public partial class AsTypeExpr : Expr
    {
        public AsTypeExpr()
        {
        }

        public Expr SrcExpr;
        public SourceLocation BuiltinLoc;
        public SourceLocation RParenLoc;
    }

    public partial class PseudoObjectExpr : Expr
    {
        public PseudoObjectExpr()
        {
        }

        public uint ResultExprIndex;
        public uint NumSemanticExprs;
    }

    public partial class AtomicExpr : Expr
    {
        public enum AtomicOp
        {
            C11AtomicInit = 0,
            C11AtomicLoad = 1,
            C11AtomicStore = 2,
            C11AtomicExchange = 3,
            C11AtomicCompareExchangeStrong = 4,
            C11AtomicCompareExchangeWeak = 5,
            C11AtomicFetchAdd = 6,
            C11AtomicFetchSub = 7,
            C11AtomicFetchAnd = 8,
            C11AtomicFetchOr = 9,
            C11AtomicFetchXor = 10,
            AtomicLoad = 11,
            AtomicLoadN = 12,
            AtomicStore = 13,
            AtomicStoreN = 14,
            AtomicExchange = 15,
            AtomicExchangeN = 16,
            AtomicCompareExchange = 17,
            AtomicCompareExchangeN = 18,
            AtomicFetchAdd = 19,
            AtomicFetchSub = 20,
            AtomicFetchAnd = 21,
            AtomicFetchOr = 22,
            AtomicFetchXor = 23,
            AtomicFetchNand = 24,
            AtomicAddFetch = 25,
            AtomicSubFetch = 26,
            AtomicAndFetch = 27,
            AtomicOrFetch = 28,
            AtomicXorFetch = 29,
            AtomicNandFetch = 30,
            OpenclAtomicInit = 31,
            OpenclAtomicLoad = 32,
            OpenclAtomicStore = 33,
            OpenclAtomicExchange = 34,
            OpenclAtomicCompareExchangeStrong = 35,
            OpenclAtomicCompareExchangeWeak = 36,
            OpenclAtomicFetchAdd = 37,
            OpenclAtomicFetchSub = 38,
            OpenclAtomicFetchAnd = 39,
            OpenclAtomicFetchOr = 40,
            OpenclAtomicFetchXor = 41,
            OpenclAtomicFetchMin = 42,
            OpenclAtomicFetchMax = 43,
            AtomicFetchMin = 44,
            AtomicFetchMax = 45,
        }

        public AtomicExpr()
        {
        }

        public Expr Ptr;
        public Expr Order;
        public Expr Scope;
        public Expr Val1;
        public Expr OrderFail;
        public Expr Val2;
        public Expr Weak;
        public QualifiedType ValueType;
        public AtomicExpr.AtomicOp Op;
        public bool IsVolatile;
        public bool IsCmpXChg;
        public bool IsOpenCL;
        public SourceLocation BuiltinLoc;
        public SourceLocation RParenLoc;
    }

    public partial class TypoExpr : Expr
    {
        public TypoExpr()
        {
        }

    }

    public partial class CXXOperatorCallExpr : CallExpr
    {
        public CXXOperatorCallExpr()
        {
        }

        public OverloadedOperatorKind Operator;
        public bool IsInfixBinaryOp;
        public SourceLocation OperatorLoc;
        public bool IsFPContractableWithinStatement;
    }

    public partial class CXXMemberCallExpr : CallExpr
    {
        public CXXMemberCallExpr()
        {
        }

        public Expr ImplicitObjectArgument;
        public Method MethodDecl;
    }

    public partial class CUDAKernelCallExpr : CallExpr
    {
        public CUDAKernelCallExpr()
        {
        }

        public CallExpr Config;
    }

    public partial class CXXNamedCastExpr : ExplicitCastExpr
    {
        public CXXNamedCastExpr()
        {
        }

        public string CastName;
        public SourceLocation OperatorLoc;
        public SourceLocation RParenLoc;
        public SourceRange AngleBrackets;
    }

    public partial class CXXStaticCastExpr : CXXNamedCastExpr
    {
        public CXXStaticCastExpr()
        {
        }

    }

    public partial class CXXDynamicCastExpr : CXXNamedCastExpr
    {
        public CXXDynamicCastExpr()
        {
        }

        public bool IsAlwaysNull;
    }

    public partial class CXXReinterpretCastExpr : CXXNamedCastExpr
    {
        public CXXReinterpretCastExpr()
        {
        }

    }

    public partial class CXXConstCastExpr : CXXNamedCastExpr
    {
        public CXXConstCastExpr()
        {
        }

    }

    public partial class UserDefinedLiteral : CallExpr
    {
        public enum LiteralOperatorKind
        {
            /// <summary>Raw form: operator &quot;&quot; X (const char *)</summary>
            Raw = 0,
            /// <summary>Raw form: operator &quot;&quot; X...&gt; ()</summary>
            Template = 1,
            /// <summary>operator &quot;&quot; X (unsigned long long)</summary>
            Integer = 2,
            /// <summary>operator &quot;&quot; X (long double)</summary>
            Floating = 3,
            /// <summary>operator &quot;&quot; X (const CharT *, size_t)</summary>
            String = 4,
            /// <summary>operator &quot;&quot; X (CharT)</summary>
            Character = 5
        }

        public UserDefinedLiteral()
        {
        }

        public UserDefinedLiteral.LiteralOperatorKind literalOperatorKind;
        public SourceLocation UDSuffixLoc;
    }

    public partial class CXXBoolLiteralExpr : Expr
    {
        public CXXBoolLiteralExpr()
        {
        }

        public bool Value;
        public SourceLocation Location;
    }

    public partial class CXXNullPtrLiteralExpr : Expr
    {
        public CXXNullPtrLiteralExpr()
        {
        }

        public SourceLocation Location;
    }

    public partial class CXXStdInitializerListExpr : Expr
    {
        public CXXStdInitializerListExpr()
        {
        }

    }

    public partial class CXXTypeidExpr : Expr
    {
        public CXXTypeidExpr()
        {
        }

        public Expr ExprOperand;
        public bool IsPotentiallyEvaluated;
        public bool IsTypeOperand;
    }

    public partial class MSPropertyRefExpr : Expr
    {
        public MSPropertyRefExpr()
        {
        }

        public bool IsImplicitAccess;
        public Expr BaseExpr;
        public bool IsArrow;
        public SourceLocation MemberLoc;
    }

    public partial class MSPropertySubscriptExpr : Expr
    {
        public MSPropertySubscriptExpr()
        {
        }

        public SourceLocation RBracketLoc;
    }

    public partial class CXXUuidofExpr : Expr
    {
        public CXXUuidofExpr()
        {
        }

        public Expr ExprOperand;
        public string UuidStr;
        public bool IsTypeOperand;
    }

    public partial class CXXThisExpr : Expr
    {
        public CXXThisExpr()
        {
        }

        public SourceLocation Location;
        public bool Implicit;
    }

    public partial class CXXThrowExpr : Expr
    {
        public CXXThrowExpr()
        {
        }

        public SourceLocation ThrowLoc;
        public bool IsThrownVariableInScope;
    }

    public partial class CXXDefaultArgExpr : Expr
    {
        public CXXDefaultArgExpr()
        {
        }

        public SourceLocation UsedLocation;
    }

    public partial class CXXDefaultInitExpr : Expr
    {
        public CXXDefaultInitExpr()
        {
        }

    }

    public partial class CXXBindTemporaryExpr : Expr
    {
        public CXXBindTemporaryExpr()
        {
        }

        public Expr SubExpr;
    }

    public partial class CXXConstructExpr : Expr
    {
        public enum ConstructionKind
        {
            Complete = 0,
            NonVirtualBase = 1,
            VirtualBase = 2,
            Delegating = 3
        }

        public CXXConstructExpr()
        {
        }

        public List<Expr> Arguments = new List<Expr>();
        public SourceLocation Location;
        public bool Elidable;
        public bool HadMultipleCandidates;
        public bool ListInitialization;
        public bool StdInitListInitialization;
        public bool RequiresZeroInitialization;
        public SourceRange ParenOrBraceRange;
        public uint NumArgs;
    }

    public partial class CXXInheritedCtorInitExpr : Expr
    {
        public CXXInheritedCtorInitExpr()
        {
        }

        public bool ConstructsVBase;
        public bool InheritedFromVBase;
        public SourceLocation Location;
    }

    public partial class CXXFunctionalCastExpr : ExplicitCastExpr
    {
        public CXXFunctionalCastExpr()
        {
        }

        public SourceLocation LParenLoc;
        public SourceLocation RParenLoc;
        public bool IsListInitialization;
    }

    public partial class CXXTemporaryObjectExpr : CXXConstructExpr
    {
        public CXXTemporaryObjectExpr()
        {
        }

    }

    public partial class LambdaExpr : Expr
    {
        public LambdaExpr()
        {
        }

        public List<Expr> CaptureInits = new List<Expr>();
        public SourceLocation CaptureDefaultLoc;
        public uint CaptureSize;
        public SourceRange IntroducerRange;
        public Method CallOperator;
        public bool IsGenericLambda;
        public CompoundStmt Body;
        public bool IsMutable;
        public bool HasExplicitParameters;
        public bool HasExplicitResultType;
    }

    public partial class CXXScalarValueInitExpr : Expr
    {
        public CXXScalarValueInitExpr()
        {
        }

        public SourceLocation RParenLoc;
    }

    public partial class CXXNewExpr : Expr
    {
        public enum InitializationStyle
        {
            /// <summary>New-expression has no initializer as written.</summary>
            NoInit = 0,
            /// <summary>New-expression has a C++98 paren-delimited initializer.</summary>
            CallInit = 1,
            /// <summary>New-expression has a C++11 list-initializer.</summary>
            ListInit = 2
        }

        public CXXNewExpr()
        {
        }

        public List<Expr> PlacementArguments = new List<Expr>();
        public Function OperatorNew;
        public Function OperatorDelete;
        public QualifiedType AllocatedType;
        public bool IsArray;
        public uint NumPlacementArgs;
        public bool IsParenTypeId;
        public SourceRange TypeIdParens;
        public bool IsGlobalNew;
        public bool HasInitializer;
        public CXXNewExpr.InitializationStyle initializationStyle;
        public CXXConstructExpr ConstructExpr;
        public SourceRange DirectInitRange;
    }

    public partial class CXXDeleteExpr : Expr
    {
        public CXXDeleteExpr()
        {
        }

        public bool IsGlobalDelete;
        public bool IsArrayForm;
        public bool IsArrayFormAsWritten;
        public Function OperatorDelete;
        public QualifiedType DestroyedType;
    }

    public partial class CXXPseudoDestructorExpr : Expr
    {
        public CXXPseudoDestructorExpr()
        {
        }

        public Expr Base;
        public bool HasQualifier;
        public bool IsArrow;
        public SourceLocation OperatorLoc;
        public SourceLocation ColonColonLoc;
        public SourceLocation TildeLoc;
        public QualifiedType DestroyedType;
        public SourceLocation DestroyedTypeLoc;
    }

    public partial class TypeTraitExpr : Expr
    {
        public TypeTraitExpr()
        {
        }

        public bool Value;
        public uint NumArgs;
    }

    public partial class ArrayTypeTraitExpr : Expr
    {
        public ArrayTypeTraitExpr()
        {
        }

        public QualifiedType QueriedType;
        public ulong Value;
        public Expr DimensionExpression;
    }

    public partial class ExpressionTraitExpr : Expr
    {
        public ExpressionTraitExpr()
        {
        }

        public Expr QueriedExpression;
        public bool Value;
    }

    public partial class OverloadExpr : Expr
    {
        public partial class FindResult
        {
            public FindResult()
            {
            }

        }

        public OverloadExpr()
        {
        }

        public uint NumDecls;
        public SourceLocation NameLoc;
        public SourceLocation TemplateKeywordLoc;
        public SourceLocation LAngleLoc;
        public SourceLocation RAngleLoc;
        public bool HasTemplateKeyword;
        public bool HasExplicitTemplateArgs;
        public uint NumTemplateArgs;
    }

    public partial class UnresolvedLookupExpr : OverloadExpr
    {
        public UnresolvedLookupExpr()
        {
        }

        public bool RequiresADL;
        public bool IsOverloaded;
    }

    public partial class DependentScopeDeclRefExpr : Expr
    {
        public DependentScopeDeclRefExpr()
        {
        }

        public SourceLocation Location;
        public SourceLocation TemplateKeywordLoc;
        public SourceLocation LAngleLoc;
        public SourceLocation RAngleLoc;
        public bool HasTemplateKeyword;
        public bool HasExplicitTemplateArgs;
        public uint NumTemplateArgs;
    }

    public partial class ExprWithCleanups : FullExpr
    {
        public ExprWithCleanups()
        {
        }

        public uint NumObjects;
        public bool CleanupsHaveSideEffects;
    }

    public partial class CXXUnresolvedConstructExpr : Expr
    {
        public CXXUnresolvedConstructExpr()
        {
        }

        public List<Expr> Arguments = new List<Expr>();
        public SourceLocation LParenLoc;
        public SourceLocation RParenLoc;
        public QualifiedType TypeAsWritten;
        public bool IsListInitialization;
        public uint ArgSize;
    }

    public partial class CXXDependentScopeMemberExpr : Expr
    {
        public CXXDependentScopeMemberExpr()
        {
        }

        public bool IsImplicitAccess;
        public Expr Base;
        public QualifiedType BaseType;
        public bool IsArrow;
        public SourceLocation OperatorLoc;
        public Declaration FirstQualifierFoundInScope;
        public SourceLocation MemberLoc;
        public SourceLocation TemplateKeywordLoc;
        public SourceLocation LAngleLoc;
        public SourceLocation RAngleLoc;
        public bool HasTemplateKeyword;
        public bool HasExplicitTemplateArgs;
        public uint NumTemplateArgs;
    }

    public partial class UnresolvedMemberExpr : OverloadExpr
    {
        public UnresolvedMemberExpr()
        {
        }

        public bool IsImplicitAccess;
        public QualifiedType BaseType;
        public bool HasUnresolvedUsing;
        public bool IsArrow;
        public SourceLocation OperatorLoc;
        public SourceLocation MemberLoc;
    }

    public partial class CXXNoexceptExpr : Expr
    {
        public CXXNoexceptExpr()
        {
        }

        public Expr Operand;
        public bool Value;
    }

    public partial class PackExpansionExpr : Expr
    {
        public PackExpansionExpr()
        {
        }

        public SourceLocation EllipsisLoc;
    }

    public partial class SizeOfPackExpr : Expr
    {
        public SizeOfPackExpr()
        {
        }

        public SourceLocation OperatorLoc;
        public SourceLocation PackLoc;
        public SourceLocation RParenLoc;
        public Declaration Pack;
        public uint PackLength;
        public bool IsPartiallySubstituted;
    }

    public partial class SubstNonTypeTemplateParmExpr : Expr
    {
        public SubstNonTypeTemplateParmExpr()
        {
        }

        public SourceLocation NameLoc;
        public Expr Replacement;
    }

    public partial class SubstNonTypeTemplateParmPackExpr : Expr
    {
        public SubstNonTypeTemplateParmPackExpr()
        {
        }

        public SourceLocation ParameterPackLocation;
        public TemplateArgument ArgumentPack;
    }

    public partial class FunctionParmPackExpr : Expr
    {
        public FunctionParmPackExpr()
        {
        }

        public SourceLocation ParameterPackLocation;
        public uint NumExpansions;
    }

    public partial class MaterializeTemporaryExpr : Expr
    {
        public partial class ExtraState
        {
            public ExtraState()
            {
            }

        }

        public MaterializeTemporaryExpr()
        {
        }

        public Stmt Temporary;
        public Expr TemporaryExpr;
        public uint ManglingNumber;
        public bool IsBoundToLvalueReference;
    }

    public partial class CXXFoldExpr : Expr
    {
        public CXXFoldExpr()
        {
        }

        public Expr LHS;
        public Expr RHS;
        public bool IsRightFold;
        public bool IsLeftFold;
        public Expr Pattern;
        public Expr Init;
        public SourceLocation EllipsisLoc;
        public BinaryOperatorKind Operator;
    }

    public partial class CoroutineSuspendExpr : Expr
    {
        internal enum SubExpr
        {
            Common = 0,
            Ready = 1,
            Suspend = 2,
            Resume = 3,
            Count = 4
        }

        public CoroutineSuspendExpr()
        {
        }

        public SourceLocation KeywordLoc;
        public Expr CommonExpr;
        public OpaqueValueExpr OpaqueValue;
        public Expr ReadyExpr;
        public Expr SuspendExpr;
        public Expr ResumeExpr;
    }

    public partial class CoawaitExpr : CoroutineSuspendExpr
    {
        public CoawaitExpr()
        {
        }

        public bool IsImplicit;
        public Expr Operand;
    }

    public partial class DependentCoawaitExpr : Expr
    {
        public DependentCoawaitExpr()
        {
        }

        public Expr Operand;
        public UnresolvedLookupExpr OperatorCoawaitLookup;
        public SourceLocation KeywordLoc;
    }

    public partial class CoyieldExpr : CoroutineSuspendExpr
    {
        public CoyieldExpr()
        {
        }

        public Expr Operand;
    }
}
