// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------

using System;
using System.Collections.Generic;

namespace CppSharp.AST
{
    public enum CastKind
    {
        Dependent = 0,
        BitCast = 1,
        LValueBitCast = 2,
        LValueToRValue = 3,
        NoOp = 4,
        BaseToDerived = 5,
        DerivedToBase = 6,
        UncheckedDerivedToBase = 7,
        Dynamic = 8,
        ToUnion = 9,
        ArrayToPointerDecay = 10,
        FunctionToPointerDecay = 11,
        NullToPointer = 12,
        NullToMemberPointer = 13,
        BaseToDerivedMemberPointer = 14,
        DerivedToBaseMemberPointer = 15,
        MemberPointerToBoolean = 16,
        ReinterpretMemberPointer = 17,
        UserDefinedConversion = 18,
        ConstructorConversion = 19,
        IntegralToPointer = 20,
        PointerToIntegral = 21,
        PointerToBoolean = 22,
        ToVoid = 23,
        VectorSplat = 24,
        IntegralCast = 25,
        IntegralToBoolean = 26,
        IntegralToFloating = 27,
        FixedPointCast = 28,
        FixedPointToBoolean = 29,
        FloatingToIntegral = 30,
        FloatingToBoolean = 31,
        BooleanToSignedIntegral = 32,
        FloatingCast = 33,
        CPointerToObjCPointerCast = 34,
        BlockPointerToObjCPointerCast = 35,
        AnyPointerToBlockPointerCast = 36,
        ObjCObjectLValueCast = 37,
        FloatingRealToComplex = 38,
        FloatingComplexToReal = 39,
        FloatingComplexToBoolean = 40,
        FloatingComplexCast = 41,
        FloatingComplexToIntegralComplex = 42,
        IntegralRealToComplex = 43,
        IntegralComplexToReal = 44,
        IntegralComplexToBoolean = 45,
        IntegralComplexCast = 46,
        IntegralComplexToFloatingComplex = 47,
        ARCProduceObject = 48,
        ARCConsumeObject = 49,
        ARCReclaimReturnedObject = 50,
        ARCExtendBlockObject = 51,
        AtomicToNonAtomic = 52,
        NonAtomicToAtomic = 53,
        CopyAndAutoreleaseBlockObject = 54,
        BuiltinFnToFnPtr = 55,
        ZeroToOCLOpaqueType = 56,
        AddressSpaceConversion = 57,
        IntToOCLSampler = 58
    }

    public enum BinaryOperatorKind
    {
        PtrMemD = 0,
        PtrMemI = 1,
        Mul = 2,
        Div = 3,
        Rem = 4,
        Add = 5,
        Sub = 6,
        Shl = 7,
        Shr = 8,
        Cmp = 9,
        LT = 10,
        GT = 11,
        LE = 12,
        GE = 13,
        EQ = 14,
        NE = 15,
        And = 16,
        Xor = 17,
        Or = 18,
        LAnd = 19,
        LOr = 20,
        Assign = 21,
        MulAssign = 22,
        DivAssign = 23,
        RemAssign = 24,
        AddAssign = 25,
        SubAssign = 26,
        ShlAssign = 27,
        ShrAssign = 28,
        AndAssign = 29,
        XorAssign = 30,
        OrAssign = 31,
        Comma = 32
    }

    public enum UnaryOperatorKind
    {
        PostInc = 0,
        PostDec = 1,
        PreInc = 2,
        PreDec = 3,
        AddrOf = 4,
        Deref = 5,
        Plus = 6,
        Minus = 7,
        Not = 8,
        LNot = 9,
        Real = 10,
        Imag = 11,
        Extension = 12,
        Coawait = 13
    }

    public enum ObjCBridgeCastKind
    {
        /// <summary>
/// <para>Bridging via __bridge, which does nothing but reinterpret</para>
/// <para>the bits.</para>
/// </summary>
        Bridge = 0,
        /// <summary>
/// <para>Bridging via __bridge_transfer, which transfers ownership of an</para>
/// <para>Objective-C pointer into ARC.</para>
/// </summary>
        BridgeTransfer = 1,
        /// <summary>
/// <para>Bridging via __bridge_retain, which makes an ARC object available</para>
/// <para>as a +1 C pointer.</para>
/// </summary>
        BridgeRetained = 2
    }

    public enum OverloadedOperatorKind
    {
        /// <summary>Not an overloaded operator</summary>
        None = 0,
        New = 1,
        Delete = 2,
        ArrayNew = 3,
        ArrayDelete = 4,
        Plus = 5,
        Minus = 6,
        Star = 7,
        Slash = 8,
        Percent = 9,
        Caret = 10,
        Amp = 11,
        Pipe = 12,
        Tilde = 13,
        Exclaim = 14,
        Equal = 15,
        Less = 16,
        Greater = 17,
        PlusEqual = 18,
        MinusEqual = 19,
        StarEqual = 20,
        SlashEqual = 21,
        PercentEqual = 22,
        CaretEqual = 23,
        AmpEqual = 24,
        PipeEqual = 25,
        LessLess = 26,
        GreaterGreater = 27,
        LessLessEqual = 28,
        GreaterGreaterEqual = 29,
        EqualEqual = 30,
        ExclaimEqual = 31,
        LessEqual = 32,
        GreaterEqual = 33,
        Spaceship = 34,
        AmpAmp = 35,
        PipePipe = 36,
        PlusPlus = 37,
        MinusMinus = 38,
        Comma = 39,
        ArrowStar = 40,
        Arrow = 41,
        Call = 42,
        Subscript = 43,
        Conditional = 44,
        Coawait = 45,
    }

    public enum UnaryExprOrTypeTrait
    {
        SizeOf = 0,
        /// <summary>
/// <para>Used for C's _Alignof and C++'s alignof.</para>
/// <para>_Alignof and alignof return the required ABI alignment.</para>
/// </summary>
        AlignOf = 1,
        /// <summary>
/// <para>Used for C's _Alignof and C++'s alignof.</para>
/// <para>_Alignof and alignof return the required ABI alignment.</para>
/// </summary>
        VecStep = 2,
        /// <summary>
/// <para>Used for C's _Alignof and C++'s alignof.</para>
/// <para>_Alignof and alignof return the required ABI alignment.</para>
/// </summary>
        OpenMPRequiredSimdAlign = 3,
        /// <summary>
/// <para>Used for GCC's __alignof.</para>
/// <para>__alignof returns the preferred alignment of a type, the alignment</para>
/// <para>clang will attempt to give an object of the type if allowed by ABI.</para>
/// </summary>
        PreferredAlignOf = 4
    }

    public abstract partial class Expr : Stmt
    {
        public enum LValueClassification
        {
            Valid = 0,
            NotObjectType = 1,
            IncompleteVoidType = 2,
            DuplicateVectorComponents = 3,
            InvalidExpression = 4,
            InvalidMessageExpression = 5,
            MemberFunction = 6,
            SubObjCPropertySetting = 7,
            ClassTemporary = 8,
            ArrayTemporary = 9
        }

        public enum isModifiableLvalueResult
        {
            Valid = 0,
            NotObjectType = 1,
            IncompleteVoidType = 2,
            DuplicateVectorComponents = 3,
            InvalidExpression = 4,
            LValueCast = 5,
            IncompleteType = 6,
            ConstQualified = 7,
            ConstQualifiedField = 8,
            ConstAddrSpace = 9,
            ArrayType = 10,
            NoSetterProperty = 11,
            MemberFunction = 12,
            SubObjCPropertySetting = 13,
            InvalidMessageExpression = 14,
            ClassTemporary = 15,
            ArrayTemporary = 16
        }

        public enum SideEffectsKind
        {
            /// <summary>Strictly evaluate the expression.</summary>
            NoSideEffects = 0,
            /// <summary>
/// <para>Allow UB that we can give a value, but not</para>
/// <para>arbitrary unmodeled side effects.</para>
/// </summary>
            AllowUndefinedBehavior = 1,
            /// <summary>Allow any unmodeled side effect.</summary>
            AllowSideEffects = 2
        }

        public enum ConstExprUsage
        {
            EvaluateForCodeGen = 0,
            EvaluateForMangling = 1
        }

        public enum NullPointerConstantKind
        {
            /// <summary>Expression is not a Null pointer constant.</summary>
            NotNull = 0,
            /// <summary>
/// <para>Expression is a Null pointer constant built from a zero integer</para>
/// <para>expression that is not a simple, possibly parenthesized, zero literal.</para>
/// <para>C++ Core Issue 903 will classify these expressions as &quot;not pointers&quot;</para>
/// <para>once it is adopted.</para>
/// <para>http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#903</para>
/// </summary>
            ZeroExpression = 1,
            /// <summary>Expression is a Null pointer constant built from a literal zero.</summary>
            ZeroLiteral = 2,
            /// <summary>Expression is a C++11 nullptr.</summary>
            CXX11_nullptr = 3,
            /// <summary>Expression is a GNU-style __null constant.</summary>
            GNUNull = 4
        }

        public enum NullPointerConstantValueDependence
        {
            /// <summary>Specifies that the expression should never be value-dependent.</summary>
            NeverValueDependent = 0,
            /// <summary>
/// <para>Specifies that a value-dependent expression of integral or</para>
/// <para>dependent type should be considered a null pointer constant.</para>
/// </summary>
            ValueDependentIsNull = 1,
            /// <summary>
/// <para>Specifies that a value-dependent expression should be considered</para>
/// <para>to never be a null pointer constant.</para>
/// </summary>
            ValueDependentIsNotNull = 2
        }

        public partial class Classification
        {
            public enum Kinds
            {
                LValue = 0,
                XValue = 1,
                Function = 2,
                Void = 3,
                AddressableVoid = 4,
                DuplicateVectorComponents = 5,
                MemberFunction = 6,
                SubObjCPropertySetting = 7,
                ClassTemporary = 8,
                ArrayTemporary = 9,
                ObjCMessageRValue = 10,
                PRValue = 11
            }

            public enum ModifiableType
            {
                Untested = 0,
                Modifiable = 1,
                RValue = 2,
                Function = 3,
                LValueCast = 4,
                NoSetterProperty = 5,
                ConstQualified = 6,
                ConstQualifiedField = 7,
                ConstAddrSpace = 8,
                ArrayType = 9,
                IncompleteType = 10
            }

            public Classification()
            {
            }

            public Expr.Classification.Kinds Kind { get; set; }
            public Expr.Classification.ModifiableType Modifiable { get; set; }
            public bool IsLValue { get; set; }
            public bool IsXValue { get; set; }
            public bool IsGLValue { get; set; }
            public bool IsPRValue { get; set; }
            public bool IsRValue { get; set; }
            public bool IsModifiable { get; set; }
        }

        public Expr()
        {
        }

        public QualifiedType Type { get; set; }
        public bool ValueDependent { get; set; }
        public bool TypeDependent { get; set; }
        public bool InstantiationDependent { get; set; }
        public bool ContainsUnexpandedParameterPack { get; set; }
        public SourceLocation ExprLoc { get; set; }
        public bool IsLValue { get; set; }
        public bool IsRValue { get; set; }
        public bool IsXValue { get; set; }
        public bool IsGLValue { get; set; }
        public bool IsOrdinaryOrBitFieldObject { get; set; }
        public Field SourceBitField { get; set; }
        public Declaration ReferencedDeclOfCallee { get; set; }
        public bool HasPlaceholderType { get; set; }
    }

    public abstract partial class FullExpr : Expr
    {
        public FullExpr()
        {
        }

        public Expr SubExpr { get; set; }
    }

    public partial class ConstantExpr : FullExpr
    {
        public ConstantExpr()
        {
        }


        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitConstantExpr(this);
    }

    public partial class OpaqueValueExpr : Expr
    {
        public OpaqueValueExpr()
        {
        }

        public bool IsUnique { get; set; }
        public SourceLocation Location { get; set; }
        public Expr SourceExpr { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitOpaqueValueExpr(this);
    }

    public partial class DeclRefExpr : Expr
    {
        public DeclRefExpr()
        {
        }

        public SourceLocation Location { get; set; }
        public bool HadMultipleCandidates { get; set; }
        public bool HasQualifier { get; set; }
        public Declaration FoundDecl { get; set; }
        public bool HasTemplateKWAndArgsInfo { get; set; }
        public SourceLocation TemplateKeywordLoc { get; set; }
        public SourceLocation LAngleLoc { get; set; }
        public SourceLocation RAngleLoc { get; set; }
        public bool HasTemplateKeyword { get; set; }
        public bool HasExplicitTemplateArgs { get; set; }
        public uint NumTemplateArgs { get; set; }
        public bool RefersToEnclosingVariableOrCapture { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitDeclRefExpr(this);
    }

    public partial class IntegerLiteral : Expr
    {
        public IntegerLiteral()
        {
        }

        public SourceLocation Location { get; set; }
        public ulong Value { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitIntegerLiteral(this);
    }

    public partial class FixedPointLiteral : Expr
    {
        public FixedPointLiteral()
        {
        }

        public SourceLocation Location { get; set; }
        public ulong Value { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitFixedPointLiteral(this);
    }

    public partial class CharacterLiteral : Expr
    {
        public enum CharacterKind
        {
            Ascii = 0,
            Wide = 1,
            UTF8 = 2,
            UTF16 = 3,
            UTF32 = 4
        }

        public CharacterLiteral()
        {
        }

        public SourceLocation Location { get; set; }
        public CharacterLiteral.CharacterKind Kind { get; set; }
        public uint Value { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitCharacterLiteral(this);
    }

    public partial class FloatingLiteral : Expr
    {
        public FloatingLiteral()
        {
        }

        public bool Exact { get; set; }
        public SourceLocation Location { get; set; }
        public double ValueAsApproximateDouble { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitFloatingLiteral(this);
    }

    public partial class ImaginaryLiteral : Expr
    {
        public ImaginaryLiteral()
        {
        }

        public Expr SubExpr { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitImaginaryLiteral(this);
    }

    public partial class StringLiteral : Expr
    {
        public enum StringKind
        {
            Ascii = 0,
            Wide = 1,
            UTF8 = 2,
            UTF16 = 3,
            UTF32 = 4
        }

        public StringLiteral()
        {
        }

        public string String { get; set; }
        public string Bytes { get; set; }
        public uint ByteLength { get; set; }
        public uint Length { get; set; }
        public uint CharByteWidth { get; set; }
        public StringLiteral.StringKind Kind { get; set; }
        public bool IsAscii { get; set; }
        public bool IsWide { get; set; }
        public bool IsUTF8 { get; set; }
        public bool IsUTF16 { get; set; }
        public bool IsUTF32 { get; set; }
        public bool IsPascal { get; set; }
        public bool ContainsNonAscii { get; set; }
        public bool ContainsNonAsciiOrNull { get; set; }
        public uint NumConcatenated { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitStringLiteral(this);
    }

    public partial class PredefinedExpr : Expr
    {
        public enum IdentKind
        {
            Func = 0,
            Function = 1,
            LFunction = 2,
            FuncDName = 3,
            FuncSig = 4,
            LFuncSig = 5,
            PrettyFunction = 6,
            /// <summary>
/// <para>The same as PrettyFunction, except that the</para>
/// <para>'virtual' keyword is omitted for virtual member functions.</para>
/// </summary>
            PrettyFunctionNoVirtual = 7
        }

        public PredefinedExpr()
        {
        }

        public SourceLocation Location { get; set; }
        public PredefinedExpr.IdentKind identKind { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitPredefinedExpr(this);
    }

    public partial class ParenExpr : Expr
    {
        public ParenExpr()
        {
        }

        public Expr SubExpr { get; set; }
        public SourceLocation LParen { get; set; }
        public SourceLocation RParen { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitParenExpr(this);
    }

    public partial class UnaryOperator : Expr
    {
        public UnaryOperator()
        {
        }

        public UnaryOperatorKind Opcode { get; set; }
        public Expr SubExpr { get; set; }
        public SourceLocation OperatorLoc { get; set; }
        public bool CanOverflow { get; set; }
        public bool IsPrefix { get; set; }
        public bool IsPostfix { get; set; }
        public bool IsIncrementOp { get; set; }
        public bool IsDecrementOp { get; set; }
        public bool IsIncrementDecrementOp { get; set; }
        public bool IsArithmeticOp { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitUnaryOperator(this);
    }

    public partial class OffsetOfExpr : Expr
    {
        public OffsetOfExpr()
        {
        }

        public SourceLocation OperatorLoc { get; set; }
        public SourceLocation RParenLoc { get; set; }
        public uint NumComponents { get; set; }
        public uint NumExpressions { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitOffsetOfExpr(this);
    }

    public partial class UnaryExprOrTypeTraitExpr : Expr
    {
        public UnaryExprOrTypeTraitExpr()
        {
        }

        public UnaryExprOrTypeTrait Kind { get; set; }
        public SourceLocation OperatorLoc { get; set; }
        public SourceLocation RParenLoc { get; set; }
        public bool IsArgumentType { get; set; }
        public QualifiedType ArgumentType { get; set; }
        public Expr ArgumentExpr { get; set; }
        public QualifiedType TypeOfArgument { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitUnaryExprOrTypeTraitExpr(this);
    }

    public partial class ArraySubscriptExpr : Expr
    {
        public ArraySubscriptExpr()
        {
        }

        public Expr LHS { get; set; }
        public Expr RHS { get; set; }
        public SourceLocation RBracketLoc { get; set; }
        public Expr Base { get; set; }
        public Expr Idx { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitArraySubscriptExpr(this);
    }

    public partial class CallExpr : Expr
    {
        public CallExpr()
        {
        }

        public List<Expr> Arguments { get; private set; } = new List<Expr>();
        public Expr Callee { get; set; }
        public SourceLocation RParenLoc { get; set; }
        public Declaration CalleeDecl { get; set; }
        public Function DirectCallee { get; set; }
        public uint NumArgs { get; set; }
        public uint NumCommas { get; set; }
        public uint BuiltinCallee { get; set; }
        public bool IsCallToStdMove { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitCallExpr(this);
    }

    public partial class MemberExpr : Expr
    {
        public MemberExpr()
        {
        }

        public Expr Base { get; set; }
        public bool Arrow { get; set; }
        public SourceLocation MemberLoc { get; set; }
        public bool HadMultipleCandidates { get; set; }
        public bool HasQualifier { get; set; }
        public SourceLocation TemplateKeywordLoc { get; set; }
        public SourceLocation LAngleLoc { get; set; }
        public SourceLocation RAngleLoc { get; set; }
        public bool HasTemplateKeyword { get; set; }
        public bool HasExplicitTemplateArgs { get; set; }
        public uint NumTemplateArgs { get; set; }
        public SourceLocation OperatorLoc { get; set; }
        public bool IsImplicitAccess { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitMemberExpr(this);
    }

    public partial class CompoundLiteralExpr : Expr
    {
        public CompoundLiteralExpr()
        {
        }

        public Expr Initializer { get; set; }
        public bool FileScope { get; set; }
        public SourceLocation LParenLoc { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitCompoundLiteralExpr(this);
    }

    public abstract partial class CastExpr : Expr
    {
        public CastExpr()
        {
        }

        public CastKind CastKind { get; set; }
        public Expr SubExpr { get; set; }
        public string CastKindName { get; set; }
        public Expr SubExprAsWritten { get; set; }
        public Declaration ConversionFunction { get; set; }
        public bool PathEmpty { get; set; }
        public uint PathSize { get; set; }
    }

    public partial class ImplicitCastExpr : CastExpr
    {
        public enum OnStack_t
        {
            OnStack = 0
        }

        public ImplicitCastExpr()
        {
        }

        public bool IsPartOfExplicitCast { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitImplicitCastExpr(this);
    }

    public abstract partial class ExplicitCastExpr : CastExpr
    {
        public ExplicitCastExpr()
        {
        }

        public QualifiedType TypeAsWritten { get; set; }
    }

    public partial class CStyleCastExpr : ExplicitCastExpr
    {
        public CStyleCastExpr()
        {
        }

        public SourceLocation LParenLoc { get; set; }
        public SourceLocation RParenLoc { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitCStyleCastExpr(this);
    }

    public partial class BinaryOperator : Expr
    {
        public BinaryOperator()
        {
        }

        public SourceLocation OperatorLoc { get; set; }
        public BinaryOperatorKind Opcode { get; set; }
        public Expr LHS { get; set; }
        public Expr RHS { get; set; }
        public string OpcodeStr { get; set; }
        public bool IsPtrMemOp { get; set; }
        public bool IsMultiplicativeOp { get; set; }
        public bool IsAdditiveOp { get; set; }
        public bool IsShiftOp { get; set; }
        public bool IsBitwiseOp { get; set; }
        public bool IsRelationalOp { get; set; }
        public bool IsEqualityOp { get; set; }
        public bool IsComparisonOp { get; set; }
        public bool IsLogicalOp { get; set; }
        public bool IsAssignmentOp { get; set; }
        public bool IsCompoundAssignmentOp { get; set; }
        public bool IsShiftAssignOp { get; set; }
        public bool IsFPContractableWithinStatement { get; set; }
        public bool IsFEnvAccessOn { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitBinaryOperator(this);
    }

    public partial class CompoundAssignOperator : BinaryOperator
    {
        public CompoundAssignOperator()
        {
        }

        public QualifiedType ComputationLHSType { get; set; }
        public QualifiedType ComputationResultType { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitCompoundAssignOperator(this);
    }

    public abstract partial class AbstractConditionalOperator : Expr
    {
        public AbstractConditionalOperator()
        {
        }

        public Expr Cond { get; set; }
        public Expr TrueExpr { get; set; }
        public Expr FalseExpr { get; set; }
        public SourceLocation QuestionLoc { get; set; }
        public SourceLocation ColonLoc { get; set; }
    }

    public partial class ConditionalOperator : AbstractConditionalOperator
    {
        public ConditionalOperator()
        {
        }

        public Expr LHS { get; set; }
        public Expr RHS { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitConditionalOperator(this);
    }

    public partial class BinaryConditionalOperator : AbstractConditionalOperator
    {
        public BinaryConditionalOperator()
        {
        }

        public Expr Common { get; set; }
        public OpaqueValueExpr OpaqueValue { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitBinaryConditionalOperator(this);
    }

    public partial class AddrLabelExpr : Expr
    {
        public AddrLabelExpr()
        {
        }

        public SourceLocation AmpAmpLoc { get; set; }
        public SourceLocation LabelLoc { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitAddrLabelExpr(this);
    }

    public partial class StmtExpr : Expr
    {
        public StmtExpr()
        {
        }

        public CompoundStmt SubStmt { get; set; }
        public SourceLocation LParenLoc { get; set; }
        public SourceLocation RParenLoc { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitStmtExpr(this);
    }

    public partial class ShuffleVectorExpr : Expr
    {
        public ShuffleVectorExpr()
        {
        }

        public SourceLocation BuiltinLoc { get; set; }
        public SourceLocation RParenLoc { get; set; }
        public uint NumSubExprs { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitShuffleVectorExpr(this);
    }

    public partial class ConvertVectorExpr : Expr
    {
        public ConvertVectorExpr()
        {
        }

        public Expr SrcExpr { get; set; }
        public SourceLocation BuiltinLoc { get; set; }
        public SourceLocation RParenLoc { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitConvertVectorExpr(this);
    }

    public partial class ChooseExpr : Expr
    {
        public ChooseExpr()
        {
        }

        public bool IsConditionTrue { get; set; }
        public Expr Cond { get; set; }
        public Expr LHS { get; set; }
        public Expr RHS { get; set; }
        public SourceLocation BuiltinLoc { get; set; }
        public SourceLocation RParenLoc { get; set; }
        public bool IsConditionDependent { get; set; }
        public Expr ChosenSubExpr { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitChooseExpr(this);
    }

    public partial class GNUNullExpr : Expr
    {
        public GNUNullExpr()
        {
        }

        public SourceLocation TokenLocation { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitGNUNullExpr(this);
    }

    public partial class VAArgExpr : Expr
    {
        public VAArgExpr()
        {
        }

        public Expr SubExpr { get; set; }
        public bool IsMicrosoftABI { get; set; }
        public SourceLocation BuiltinLoc { get; set; }
        public SourceLocation RParenLoc { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitVAArgExpr(this);
    }

    public partial class InitListExpr : Expr
    {
        public InitListExpr()
        {
        }

        public Expr ArrayFiller { get; set; }
        public SourceLocation LBraceLoc { get; set; }
        public SourceLocation RBraceLoc { get; set; }
        public InitListExpr SyntacticForm { get; set; }
        public uint NumInits { get; set; }
        public bool HasArrayFiller { get; set; }
        public bool IsExplicit { get; set; }
        public bool IsStringLiteralInit { get; set; }
        public bool IsTransparent { get; set; }
        public bool IsSemanticForm { get; set; }
        public InitListExpr SemanticForm { get; set; }
        public bool IsSyntacticForm { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitInitListExpr(this);
    }

    public partial class DesignatedInitExpr : Expr
    {
        public partial class Designator
        {
            public Designator()
            {
            }

            public Field Field { get; set; }
            public bool IsFieldDesignator { get; set; }
            public bool IsArrayDesignator { get; set; }
            public bool IsArrayRangeDesignator { get; set; }
            public SourceLocation DotLoc { get; set; }
            public SourceLocation FieldLoc { get; set; }
            public SourceLocation LBracketLoc { get; set; }
            public SourceLocation RBracketLoc { get; set; }
            public SourceLocation EllipsisLoc { get; set; }
            public uint FirstExprIndex { get; set; }
            public SourceRange SourceRange { get; set; }
        }
        public partial class FieldDesignator
        {
            public FieldDesignator()
            {
            }

        }
        public partial class ArrayOrRangeDesignator
        {
            public ArrayOrRangeDesignator()
            {
            }

        }

        public DesignatedInitExpr()
        {
        }

        public SourceLocation EqualOrColonLoc { get; set; }
        public Expr Init { get; set; }
        public uint Size { get; set; }
        public bool UsesGNUSyntax { get; set; }
        public uint NumSubExprs { get; set; }
        public SourceRange DesignatorsSourceRange { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitDesignatedInitExpr(this);
    }

    public partial class NoInitExpr : Expr
    {
        public NoInitExpr()
        {
        }


        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitNoInitExpr(this);
    }

    public partial class DesignatedInitUpdateExpr : Expr
    {
        public DesignatedInitUpdateExpr()
        {
        }

        public Expr Base { get; set; }
        public InitListExpr Updater { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitDesignatedInitUpdateExpr(this);
    }

    public partial class ArrayInitLoopExpr : Expr
    {
        public ArrayInitLoopExpr()
        {
        }

        public OpaqueValueExpr CommonExpr { get; set; }
        public Expr SubExpr { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitArrayInitLoopExpr(this);
    }

    public partial class ArrayInitIndexExpr : Expr
    {
        public ArrayInitIndexExpr()
        {
        }


        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitArrayInitIndexExpr(this);
    }

    public partial class ImplicitValueInitExpr : Expr
    {
        public ImplicitValueInitExpr()
        {
        }


        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitImplicitValueInitExpr(this);
    }

    public partial class ParenListExpr : Expr
    {
        public ParenListExpr()
        {
        }

        public uint NumExprs { get; set; }
        public SourceLocation LParenLoc { get; set; }
        public SourceLocation RParenLoc { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitParenListExpr(this);
    }

    public partial class GenericSelectionExpr : Expr
    {
        public GenericSelectionExpr()
        {
        }

        public uint NumAssocs { get; set; }
        public SourceLocation GenericLoc { get; set; }
        public SourceLocation DefaultLoc { get; set; }
        public SourceLocation RParenLoc { get; set; }
        public Expr ControllingExpr { get; set; }
        public bool IsResultDependent { get; set; }
        public uint ResultIndex { get; set; }
        public Expr ResultExpr { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitGenericSelectionExpr(this);
    }

    public partial class ExtVectorElementExpr : Expr
    {
        public ExtVectorElementExpr()
        {
        }

        public Expr Base { get; set; }
        public SourceLocation AccessorLoc { get; set; }
        public uint NumElements { get; set; }
        public bool ContainsDuplicateElements { get; set; }
        public bool IsArrow { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitExtVectorElementExpr(this);
    }

    public partial class BlockExpr : Expr
    {
        public BlockExpr()
        {
        }

        public SourceLocation CaretLocation { get; set; }
        public Stmt Body { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitBlockExpr(this);
    }

    public partial class AsTypeExpr : Expr
    {
        public AsTypeExpr()
        {
        }

        public Expr SrcExpr { get; set; }
        public SourceLocation BuiltinLoc { get; set; }
        public SourceLocation RParenLoc { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitAsTypeExpr(this);
    }

    public partial class PseudoObjectExpr : Expr
    {
        public PseudoObjectExpr()
        {
        }

        public Expr SyntacticForm { get; set; }
        public uint ResultExprIndex { get; set; }
        public Expr ResultExpr { get; set; }
        public uint NumSemanticExprs { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitPseudoObjectExpr(this);
    }

    public partial class AtomicExpr : Expr
    {
        public enum AtomicOp
        {
            C11AtomicInit = 0,
            C11AtomicLoad = 1,
            C11AtomicStore = 2,
            C11AtomicExchange = 3,
            C11AtomicCompareExchangeStrong = 4,
            C11AtomicCompareExchangeWeak = 5,
            C11AtomicFetchAdd = 6,
            C11AtomicFetchSub = 7,
            C11AtomicFetchAnd = 8,
            C11AtomicFetchOr = 9,
            C11AtomicFetchXor = 10,
            AtomicLoad = 11,
            AtomicLoadN = 12,
            AtomicStore = 13,
            AtomicStoreN = 14,
            AtomicExchange = 15,
            AtomicExchangeN = 16,
            AtomicCompareExchange = 17,
            AtomicCompareExchangeN = 18,
            AtomicFetchAdd = 19,
            AtomicFetchSub = 20,
            AtomicFetchAnd = 21,
            AtomicFetchOr = 22,
            AtomicFetchXor = 23,
            AtomicFetchNand = 24,
            AtomicAddFetch = 25,
            AtomicSubFetch = 26,
            AtomicAndFetch = 27,
            AtomicOrFetch = 28,
            AtomicXorFetch = 29,
            AtomicNandFetch = 30,
            OpenclAtomicInit = 31,
            OpenclAtomicLoad = 32,
            OpenclAtomicStore = 33,
            OpenclAtomicExchange = 34,
            OpenclAtomicCompareExchangeStrong = 35,
            OpenclAtomicCompareExchangeWeak = 36,
            OpenclAtomicFetchAdd = 37,
            OpenclAtomicFetchSub = 38,
            OpenclAtomicFetchAnd = 39,
            OpenclAtomicFetchOr = 40,
            OpenclAtomicFetchXor = 41,
            OpenclAtomicFetchMin = 42,
            OpenclAtomicFetchMax = 43,
            AtomicFetchMin = 44,
            AtomicFetchMax = 45,
        }

        public AtomicExpr()
        {
        }

        public Expr Ptr { get; set; }
        public Expr Order { get; set; }
        public Expr Scope { get; set; }
        public Expr Val1 { get; set; }
        public Expr OrderFail { get; set; }
        public Expr Val2 { get; set; }
        public Expr Weak { get; set; }
        public QualifiedType ValueType { get; set; }
        public AtomicExpr.AtomicOp Op { get; set; }
        public uint NumSubExprs { get; set; }
        public bool IsVolatile { get; set; }
        public bool IsCmpXChg { get; set; }
        public bool IsOpenCL { get; set; }
        public SourceLocation BuiltinLoc { get; set; }
        public SourceLocation RParenLoc { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitAtomicExpr(this);
    }

    public partial class TypoExpr : Expr
    {
        public TypoExpr()
        {
        }


        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitTypoExpr(this);
    }

    public partial class CXXOperatorCallExpr : CallExpr
    {
        public CXXOperatorCallExpr()
        {
        }

        public OverloadedOperatorKind Operator { get; set; }
        public bool IsAssignmentOp { get; set; }
        public bool IsInfixBinaryOp { get; set; }
        public SourceLocation OperatorLoc { get; set; }
        public bool IsFPContractableWithinStatement { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitCXXOperatorCallExpr(this);
    }

    public partial class CXXMemberCallExpr : CallExpr
    {
        public CXXMemberCallExpr()
        {
        }

        public Expr ImplicitObjectArgument { get; set; }
        public Method MethodDecl { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitCXXMemberCallExpr(this);
    }

    public partial class CUDAKernelCallExpr : CallExpr
    {
        public CUDAKernelCallExpr()
        {
        }

        public CallExpr Config { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitCUDAKernelCallExpr(this);
    }

    public abstract partial class CXXNamedCastExpr : ExplicitCastExpr
    {
        public CXXNamedCastExpr()
        {
        }

        public string CastName { get; set; }
        public SourceLocation OperatorLoc { get; set; }
        public SourceLocation RParenLoc { get; set; }
        public SourceRange AngleBrackets { get; set; }
    }

    public partial class CXXStaticCastExpr : CXXNamedCastExpr
    {
        public CXXStaticCastExpr()
        {
        }


        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitCXXStaticCastExpr(this);
    }

    public partial class CXXDynamicCastExpr : CXXNamedCastExpr
    {
        public CXXDynamicCastExpr()
        {
        }

        public bool IsAlwaysNull { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitCXXDynamicCastExpr(this);
    }

    public partial class CXXReinterpretCastExpr : CXXNamedCastExpr
    {
        public CXXReinterpretCastExpr()
        {
        }


        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitCXXReinterpretCastExpr(this);
    }

    public partial class CXXConstCastExpr : CXXNamedCastExpr
    {
        public CXXConstCastExpr()
        {
        }


        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitCXXConstCastExpr(this);
    }

    public partial class UserDefinedLiteral : CallExpr
    {
        public enum LiteralOperatorKind
        {
            /// <summary>Raw form: operator &quot;&quot; X (const char *)</summary>
            Raw = 0,
            /// <summary>Raw form: operator &quot;&quot; X...&gt; ()</summary>
            Template = 1,
            /// <summary>operator &quot;&quot; X (unsigned long long)</summary>
            Integer = 2,
            /// <summary>operator &quot;&quot; X (long double)</summary>
            Floating = 3,
            /// <summary>operator &quot;&quot; X (const CharT *, size_t)</summary>
            String = 4,
            /// <summary>operator &quot;&quot; X (CharT)</summary>
            Character = 5
        }

        public UserDefinedLiteral()
        {
        }

        public UserDefinedLiteral.LiteralOperatorKind literalOperatorKind { get; set; }
        public Expr CookedLiteral { get; set; }
        public SourceLocation UDSuffixLoc { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitUserDefinedLiteral(this);
    }

    public partial class CXXBoolLiteralExpr : Expr
    {
        public CXXBoolLiteralExpr()
        {
        }

        public bool Value { get; set; }
        public SourceLocation Location { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitCXXBoolLiteralExpr(this);
    }

    public partial class CXXNullPtrLiteralExpr : Expr
    {
        public CXXNullPtrLiteralExpr()
        {
        }

        public SourceLocation Location { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitCXXNullPtrLiteralExpr(this);
    }

    public partial class CXXStdInitializerListExpr : Expr
    {
        public CXXStdInitializerListExpr()
        {
        }

        public Expr SubExpr { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitCXXStdInitializerListExpr(this);
    }

    public partial class CXXTypeidExpr : Expr
    {
        public CXXTypeidExpr()
        {
        }

        public Expr ExprOperand { get; set; }
        public bool IsPotentiallyEvaluated { get; set; }
        public bool IsTypeOperand { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitCXXTypeidExpr(this);
    }

    public partial class MSPropertyRefExpr : Expr
    {
        public MSPropertyRefExpr()
        {
        }

        public bool IsImplicitAccess { get; set; }
        public Expr BaseExpr { get; set; }
        public bool IsArrow { get; set; }
        public SourceLocation MemberLoc { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitMSPropertyRefExpr(this);
    }

    public partial class MSPropertySubscriptExpr : Expr
    {
        public MSPropertySubscriptExpr()
        {
        }

        public SourceLocation RBracketLoc { get; set; }
        public Expr Base { get; set; }
        public Expr Idx { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitMSPropertySubscriptExpr(this);
    }

    public partial class CXXUuidofExpr : Expr
    {
        public CXXUuidofExpr()
        {
        }

        public Expr ExprOperand { get; set; }
        public string UuidStr { get; set; }
        public bool IsTypeOperand { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitCXXUuidofExpr(this);
    }

    public partial class CXXThisExpr : Expr
    {
        public CXXThisExpr()
        {
        }

        public SourceLocation Location { get; set; }
        public bool Implicit { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitCXXThisExpr(this);
    }

    public partial class CXXThrowExpr : Expr
    {
        public CXXThrowExpr()
        {
        }

        public Expr SubExpr { get; set; }
        public SourceLocation ThrowLoc { get; set; }
        public bool IsThrownVariableInScope { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitCXXThrowExpr(this);
    }

    public partial class CXXDefaultArgExpr : Expr
    {
        public CXXDefaultArgExpr()
        {
        }

        public Expr Expr { get; set; }
        public SourceLocation UsedLocation { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitCXXDefaultArgExpr(this);
    }

    public partial class CXXDefaultInitExpr : Expr
    {
        public CXXDefaultInitExpr()
        {
        }

        public Field Field { get; set; }
        public Expr Expr { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitCXXDefaultInitExpr(this);
    }

    public partial class CXXBindTemporaryExpr : Expr
    {
        public CXXBindTemporaryExpr()
        {
        }

        public Expr SubExpr { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitCXXBindTemporaryExpr(this);
    }

    public partial class CXXConstructExpr : Expr
    {
        public enum ConstructionKind
        {
            Complete = 0,
            NonVirtualBase = 1,
            VirtualBase = 2,
            Delegating = 3
        }

        public CXXConstructExpr()
        {
        }

        public List<Expr> Arguments { get; private set; } = new List<Expr>();
        public SourceLocation Location { get; set; }
        public bool Elidable { get; set; }
        public bool HadMultipleCandidates { get; set; }
        public bool ListInitialization { get; set; }
        public bool StdInitListInitialization { get; set; }
        public bool RequiresZeroInitialization { get; set; }
        public SourceRange ParenOrBraceRange { get; set; }
        public uint NumArgs { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitCXXConstructExpr(this);
    }

    public partial class CXXInheritedCtorInitExpr : Expr
    {
        public CXXInheritedCtorInitExpr()
        {
        }

        public bool ConstructsVBase { get; set; }
        public bool InheritedFromVBase { get; set; }
        public SourceLocation Location { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitCXXInheritedCtorInitExpr(this);
    }

    public partial class CXXFunctionalCastExpr : ExplicitCastExpr
    {
        public CXXFunctionalCastExpr()
        {
        }

        public SourceLocation LParenLoc { get; set; }
        public SourceLocation RParenLoc { get; set; }
        public bool IsListInitialization { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitCXXFunctionalCastExpr(this);
    }

    public partial class CXXTemporaryObjectExpr : CXXConstructExpr
    {
        public CXXTemporaryObjectExpr()
        {
        }


        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitCXXTemporaryObjectExpr(this);
    }

    public partial class LambdaExpr : Expr
    {
        public LambdaExpr()
        {
        }

        public List<Expr> CaptureInits { get; private set; } = new List<Expr>();
        public SourceLocation CaptureDefaultLoc { get; set; }
        public uint CaptureSize { get; set; }
        public SourceRange IntroducerRange { get; set; }
        public Method CallOperator { get; set; }
        public bool IsGenericLambda { get; set; }
        public CompoundStmt Body { get; set; }
        public bool IsMutable { get; set; }
        public bool HasExplicitParameters { get; set; }
        public bool HasExplicitResultType { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitLambdaExpr(this);
    }

    public partial class CXXScalarValueInitExpr : Expr
    {
        public CXXScalarValueInitExpr()
        {
        }

        public SourceLocation RParenLoc { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitCXXScalarValueInitExpr(this);
    }

    public partial class CXXNewExpr : Expr
    {
        public enum InitializationStyle
        {
            /// <summary>New-expression has no initializer as written.</summary>
            NoInit = 0,
            /// <summary>New-expression has a C++98 paren-delimited initializer.</summary>
            CallInit = 1,
            /// <summary>New-expression has a C++11 list-initializer.</summary>
            ListInit = 2
        }

        public CXXNewExpr()
        {
        }

        public List<Expr> PlacementArguments { get; private set; } = new List<Expr>();
        public Function OperatorNew { get; set; }
        public Function OperatorDelete { get; set; }
        public QualifiedType AllocatedType { get; set; }
        public bool IsArray { get; set; }
        public Expr ArraySize { get; set; }
        public uint NumPlacementArgs { get; set; }
        public bool IsParenTypeId { get; set; }
        public SourceRange TypeIdParens { get; set; }
        public bool IsGlobalNew { get; set; }
        public bool HasInitializer { get; set; }
        public CXXNewExpr.InitializationStyle initializationStyle { get; set; }
        public Expr Initializer { get; set; }
        public CXXConstructExpr ConstructExpr { get; set; }
        public SourceRange DirectInitRange { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitCXXNewExpr(this);
    }

    public partial class CXXDeleteExpr : Expr
    {
        public CXXDeleteExpr()
        {
        }

        public bool IsGlobalDelete { get; set; }
        public bool IsArrayForm { get; set; }
        public bool IsArrayFormAsWritten { get; set; }
        public Function OperatorDelete { get; set; }
        public Expr Argument { get; set; }
        public QualifiedType DestroyedType { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitCXXDeleteExpr(this);
    }

    public partial class CXXPseudoDestructorExpr : Expr
    {
        public CXXPseudoDestructorExpr()
        {
        }

        public Expr Base { get; set; }
        public bool HasQualifier { get; set; }
        public bool IsArrow { get; set; }
        public SourceLocation OperatorLoc { get; set; }
        public SourceLocation ColonColonLoc { get; set; }
        public SourceLocation TildeLoc { get; set; }
        public QualifiedType DestroyedType { get; set; }
        public SourceLocation DestroyedTypeLoc { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitCXXPseudoDestructorExpr(this);
    }

    public partial class TypeTraitExpr : Expr
    {
        public TypeTraitExpr()
        {
        }

        public bool Value { get; set; }
        public uint NumArgs { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitTypeTraitExpr(this);
    }

    public partial class ArrayTypeTraitExpr : Expr
    {
        public ArrayTypeTraitExpr()
        {
        }

        public QualifiedType QueriedType { get; set; }
        public ulong Value { get; set; }
        public Expr DimensionExpression { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitArrayTypeTraitExpr(this);
    }

    public partial class ExpressionTraitExpr : Expr
    {
        public ExpressionTraitExpr()
        {
        }

        public Expr QueriedExpression { get; set; }
        public bool Value { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitExpressionTraitExpr(this);
    }

    public abstract partial class OverloadExpr : Expr
    {
        public partial class FindResult
        {
            public FindResult()
            {
            }

        }

        public OverloadExpr()
        {
        }

        public uint NumDecls { get; set; }
        public SourceLocation NameLoc { get; set; }
        public SourceLocation TemplateKeywordLoc { get; set; }
        public SourceLocation LAngleLoc { get; set; }
        public SourceLocation RAngleLoc { get; set; }
        public bool HasTemplateKeyword { get; set; }
        public bool HasExplicitTemplateArgs { get; set; }
        public uint NumTemplateArgs { get; set; }
    }

    public partial class UnresolvedLookupExpr : OverloadExpr
    {
        public UnresolvedLookupExpr()
        {
        }

        public bool RequiresADL { get; set; }
        public bool IsOverloaded { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitUnresolvedLookupExpr(this);
    }

    public partial class DependentScopeDeclRefExpr : Expr
    {
        public DependentScopeDeclRefExpr()
        {
        }

        public SourceLocation Location { get; set; }
        public SourceLocation TemplateKeywordLoc { get; set; }
        public SourceLocation LAngleLoc { get; set; }
        public SourceLocation RAngleLoc { get; set; }
        public bool HasTemplateKeyword { get; set; }
        public bool HasExplicitTemplateArgs { get; set; }
        public uint NumTemplateArgs { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitDependentScopeDeclRefExpr(this);
    }

    public partial class ExprWithCleanups : FullExpr
    {
        public ExprWithCleanups()
        {
        }

        public uint NumObjects { get; set; }
        public bool CleanupsHaveSideEffects { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitExprWithCleanups(this);
    }

    public partial class CXXUnresolvedConstructExpr : Expr
    {
        public CXXUnresolvedConstructExpr()
        {
        }

        public List<Expr> Arguments { get; private set; } = new List<Expr>();
        public SourceLocation LParenLoc { get; set; }
        public SourceLocation RParenLoc { get; set; }
        public QualifiedType TypeAsWritten { get; set; }
        public bool IsListInitialization { get; set; }
        public uint ArgSize { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitCXXUnresolvedConstructExpr(this);
    }

    public partial class CXXDependentScopeMemberExpr : Expr
    {
        public CXXDependentScopeMemberExpr()
        {
        }

        public bool IsImplicitAccess { get; set; }
        public Expr Base { get; set; }
        public QualifiedType BaseType { get; set; }
        public bool IsArrow { get; set; }
        public SourceLocation OperatorLoc { get; set; }
        public Declaration FirstQualifierFoundInScope { get; set; }
        public SourceLocation MemberLoc { get; set; }
        public SourceLocation TemplateKeywordLoc { get; set; }
        public SourceLocation LAngleLoc { get; set; }
        public SourceLocation RAngleLoc { get; set; }
        public bool HasTemplateKeyword { get; set; }
        public bool HasExplicitTemplateArgs { get; set; }
        public uint NumTemplateArgs { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitCXXDependentScopeMemberExpr(this);
    }

    public partial class UnresolvedMemberExpr : OverloadExpr
    {
        public UnresolvedMemberExpr()
        {
        }

        public bool IsImplicitAccess { get; set; }
        public Expr Base { get; set; }
        public QualifiedType BaseType { get; set; }
        public bool HasUnresolvedUsing { get; set; }
        public bool IsArrow { get; set; }
        public SourceLocation OperatorLoc { get; set; }
        public SourceLocation MemberLoc { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitUnresolvedMemberExpr(this);
    }

    public partial class CXXNoexceptExpr : Expr
    {
        public CXXNoexceptExpr()
        {
        }

        public Expr Operand { get; set; }
        public bool Value { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitCXXNoexceptExpr(this);
    }

    public partial class PackExpansionExpr : Expr
    {
        public PackExpansionExpr()
        {
        }

        public Expr Pattern { get; set; }
        public SourceLocation EllipsisLoc { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitPackExpansionExpr(this);
    }

    public partial class SizeOfPackExpr : Expr
    {
        public SizeOfPackExpr()
        {
        }

        public SourceLocation OperatorLoc { get; set; }
        public SourceLocation PackLoc { get; set; }
        public SourceLocation RParenLoc { get; set; }
        public Declaration Pack { get; set; }
        public uint PackLength { get; set; }
        public bool IsPartiallySubstituted { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitSizeOfPackExpr(this);
    }

    public partial class SubstNonTypeTemplateParmExpr : Expr
    {
        public SubstNonTypeTemplateParmExpr()
        {
        }

        public SourceLocation NameLoc { get; set; }
        public Expr Replacement { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitSubstNonTypeTemplateParmExpr(this);
    }

    public partial class SubstNonTypeTemplateParmPackExpr : Expr
    {
        public SubstNonTypeTemplateParmPackExpr()
        {
        }

        public SourceLocation ParameterPackLocation { get; set; }
        public TemplateArgument ArgumentPack { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitSubstNonTypeTemplateParmPackExpr(this);
    }

    public partial class FunctionParmPackExpr : Expr
    {
        public FunctionParmPackExpr()
        {
        }

        public SourceLocation ParameterPackLocation { get; set; }
        public uint NumExpansions { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitFunctionParmPackExpr(this);
    }

    public partial class MaterializeTemporaryExpr : Expr
    {
        public partial class ExtraState
        {
            public ExtraState()
            {
            }

        }

        public MaterializeTemporaryExpr()
        {
        }

        public Stmt Temporary { get; set; }
        public Expr TemporaryExpr { get; set; }
        public uint ManglingNumber { get; set; }
        public bool IsBoundToLvalueReference { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitMaterializeTemporaryExpr(this);
    }

    public partial class CXXFoldExpr : Expr
    {
        public CXXFoldExpr()
        {
        }

        public Expr LHS { get; set; }
        public Expr RHS { get; set; }
        public bool IsRightFold { get; set; }
        public bool IsLeftFold { get; set; }
        public Expr Pattern { get; set; }
        public Expr Init { get; set; }
        public SourceLocation EllipsisLoc { get; set; }
        public BinaryOperatorKind Operator { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitCXXFoldExpr(this);
    }

    public abstract partial class CoroutineSuspendExpr : Expr
    {
        internal enum SubExpr
        {
            Common = 0,
            Ready = 1,
            Suspend = 2,
            Resume = 3,
            Count = 4
        }

        public CoroutineSuspendExpr()
        {
        }

        public SourceLocation KeywordLoc { get; set; }
        public Expr CommonExpr { get; set; }
        public OpaqueValueExpr OpaqueValue { get; set; }
        public Expr ReadyExpr { get; set; }
        public Expr SuspendExpr { get; set; }
        public Expr ResumeExpr { get; set; }
    }

    public partial class CoawaitExpr : CoroutineSuspendExpr
    {
        public CoawaitExpr()
        {
        }

        public bool IsImplicit { get; set; }
        public Expr Operand { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitCoawaitExpr(this);
    }

    public partial class DependentCoawaitExpr : Expr
    {
        public DependentCoawaitExpr()
        {
        }

        public Expr Operand { get; set; }
        public UnresolvedLookupExpr OperatorCoawaitLookup { get; set; }
        public SourceLocation KeywordLoc { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitDependentCoawaitExpr(this);
    }

    public partial class CoyieldExpr : CoroutineSuspendExpr
    {
        public CoyieldExpr()
        {
        }

        public Expr Operand { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitCoyieldExpr(this);
    }
}
