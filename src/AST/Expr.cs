// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------

using System;
using System.Collections.Generic;

namespace CppSharp.AST
{
    public enum CastKind
    {
        Dependent = 0,
        BitCast = 1,
        LValueBitCast = 2,
        LValueToRValueBitCast = 3,
        LValueToRValue = 4,
        NoOp = 5,
        BaseToDerived = 6,
        DerivedToBase = 7,
        UncheckedDerivedToBase = 8,
        Dynamic = 9,
        ToUnion = 10,
        ArrayToPointerDecay = 11,
        FunctionToPointerDecay = 12,
        NullToPointer = 13,
        NullToMemberPointer = 14,
        BaseToDerivedMemberPointer = 15,
        DerivedToBaseMemberPointer = 16,
        MemberPointerToBoolean = 17,
        ReinterpretMemberPointer = 18,
        UserDefinedConversion = 19,
        ConstructorConversion = 20,
        IntegralToPointer = 21,
        PointerToIntegral = 22,
        PointerToBoolean = 23,
        ToVoid = 24,
        MatrixCast = 25,
        VectorSplat = 26,
        IntegralCast = 27,
        IntegralToBoolean = 28,
        IntegralToFloating = 29,
        FloatingToFixedPoint = 30,
        FixedPointToFloating = 31,
        FixedPointCast = 32,
        FixedPointToIntegral = 33,
        IntegralToFixedPoint = 34,
        FixedPointToBoolean = 35,
        FloatingToIntegral = 36,
        FloatingToBoolean = 37,
        BooleanToSignedIntegral = 38,
        FloatingCast = 39,
        CPointerToObjCPointerCast = 40,
        BlockPointerToObjCPointerCast = 41,
        AnyPointerToBlockPointerCast = 42,
        ObjCObjectLValueCast = 43,
        FloatingRealToComplex = 44,
        FloatingComplexToReal = 45,
        FloatingComplexToBoolean = 46,
        FloatingComplexCast = 47,
        FloatingComplexToIntegralComplex = 48,
        IntegralRealToComplex = 49,
        IntegralComplexToReal = 50,
        IntegralComplexToBoolean = 51,
        IntegralComplexCast = 52,
        IntegralComplexToFloatingComplex = 53,
        ARCProduceObject = 54,
        ARCConsumeObject = 55,
        ARCReclaimReturnedObject = 56,
        ARCExtendBlockObject = 57,
        AtomicToNonAtomic = 58,
        NonAtomicToAtomic = 59,
        CopyAndAutoreleaseBlockObject = 60,
        BuiltinFnToFnPtr = 61,
        ZeroToOCLOpaqueType = 62,
        AddressSpaceConversion = 63,
        IntToOCLSampler = 64
    }

    public enum UnaryOperatorKind
    {
        PostInc = 0,
        PostDec = 1,
        PreInc = 2,
        PreDec = 3,
        AddrOf = 4,
        Deref = 5,
        Plus = 6,
        Minus = 7,
        Not = 8,
        LNot = 9,
        Real = 10,
        Imag = 11,
        Extension = 12,
        Coawait = 13
    }

    public enum BinaryOperatorKind
    {
        PtrMemD = 0,
        PtrMemI = 1,
        Mul = 2,
        Div = 3,
        Rem = 4,
        Add = 5,
        Sub = 6,
        Shl = 7,
        Shr = 8,
        Cmp = 9,
        LT = 10,
        GT = 11,
        LE = 12,
        GE = 13,
        EQ = 14,
        NE = 15,
        And = 16,
        Xor = 17,
        Or = 18,
        LAnd = 19,
        LOr = 20,
        Assign = 21,
        MulAssign = 22,
        DivAssign = 23,
        RemAssign = 24,
        AddAssign = 25,
        SubAssign = 26,
        ShlAssign = 27,
        ShrAssign = 28,
        AndAssign = 29,
        XorAssign = 30,
        OrAssign = 31,
        Comma = 32
    }

    public enum ObjCBridgeCastKind
    {
        /// <summary>
        /// <para>Bridging via __bridge, which does nothing but reinterpret</para>
        /// <para>the bits.</para>
        /// </summary>
        Bridge = 0,
        /// <summary>
        /// <para>Bridging via __bridge_transfer, which transfers ownership of an</para>
        /// <para>Objective-C pointer into ARC.</para>
        /// </summary>
        BridgeTransfer = 1,
        /// <summary>
        /// <para>Bridging via __bridge_retain, which makes an ARC object available</para>
        /// <para>as a +1 C pointer.</para>
        /// </summary>
        BridgeRetained = 2
    }

    public enum OverloadedOperatorKind
    {
        /// <summary>Not an overloaded operator</summary>
        None = 0,
        New = 1,
        Delete = 2,
        ArrayNew = 3,
        ArrayDelete = 4,
        Plus = 5,
        Minus = 6,
        Star = 7,
        Slash = 8,
        Percent = 9,
        Caret = 10,
        Amp = 11,
        Pipe = 12,
        Tilde = 13,
        Exclaim = 14,
        Equal = 15,
        Less = 16,
        Greater = 17,
        PlusEqual = 18,
        MinusEqual = 19,
        StarEqual = 20,
        SlashEqual = 21,
        PercentEqual = 22,
        CaretEqual = 23,
        AmpEqual = 24,
        PipeEqual = 25,
        LessLess = 26,
        GreaterGreater = 27,
        LessLessEqual = 28,
        GreaterGreaterEqual = 29,
        EqualEqual = 30,
        ExclaimEqual = 31,
        LessEqual = 32,
        GreaterEqual = 33,
        Spaceship = 34,
        AmpAmp = 35,
        PipePipe = 36,
        PlusPlus = 37,
        MinusMinus = 38,
        Comma = 39,
        ArrowStar = 40,
        Arrow = 41,
        Call = 42,
        Subscript = 43,
        Conditional = 44,
        Coawait = 45,
    }

    public enum UnaryExprOrTypeTrait
    {
        SizeOf = 0,
        AlignOf = 1,
        PreferredAlignOf = 2,
        VecStep = 3,
        OpenMPRequiredSimdAlign = 4,
        Last = 4
    }

    public enum NonOdrUseReason
    {
        /// <summary>This is an odr-use.</summary>
        None = 0,
        /// <summary>This name appears in an unevaluated operand.</summary>
        Unevaluated = 1,
        /// <summary>
        /// <para>This name appears as a potential result of an lvalue-to-rvalue</para>
        /// <para>conversion that is a constant expression.</para>
        /// </summary>
        Constant = 2,
        /// <summary>
        /// <para>This name appears as a potential result of a discarded value</para>
        /// <para>expression.</para>
        /// </summary>
        Discarded = 3
    }

    public enum ExprDependence : byte
    {
        UnexpandedPack = 1,
        Instantiation = 2,
        Type = 4,
        Value = 8,
        Error = 16,
        None = 0,
        All = 31,
        TypeValue = 12,
        TypeInstantiation = 6,
        ValueInstantiation = 10,
        TypeValueInstantiation = 14,
        ErrorDependent = 26,
        LLVM_BITMASK_LARGEST_ENUMERATOR = 16
    }

    public enum FloatSemantics
    {
        IEEEhalf = 0,
        BFloat = 1,
        IEEEsingle = 2,
        IEEEdouble = 3,
        IEEEquad = 4,
        PPCDoubleDouble = 5,
        Float8E5M2 = 6,
        Float8E5M2FNUZ = 7,
        Float8E4M3FN = 8,
        Float8E4M3FNUZ = 9,
        Float8E4M3B11FNUZ = 10,
        FloatTF32 = 11,
        X87DoubleExtended = 12,
        MaxSemantics = 12
    }

    public abstract partial class Expr : ValueStmt
    {
        public enum LValueClassification
        {
            Valid = 0,
            NotObjectType = 1,
            IncompleteVoidType = 2,
            DuplicateVectorComponents = 3,
            InvalidExpression = 4,
            InvalidMessageExpression = 5,
            MemberFunction = 6,
            SubObjCPropertySetting = 7,
            ClassTemporary = 8,
            ArrayTemporary = 9
        }

        public enum isModifiableLvalueResult
        {
            Valid = 0,
            NotObjectType = 1,
            IncompleteVoidType = 2,
            DuplicateVectorComponents = 3,
            InvalidExpression = 4,
            LValueCast = 5,
            IncompleteType = 6,
            ConstQualified = 7,
            ConstQualifiedField = 8,
            ConstAddrSpace = 9,
            ArrayType = 10,
            NoSetterProperty = 11,
            MemberFunction = 12,
            SubObjCPropertySetting = 13,
            InvalidMessageExpression = 14,
            ClassTemporary = 15,
            ArrayTemporary = 16
        }

        public enum SideEffectsKind
        {
            /// <summary>Strictly evaluate the expression.</summary>
            NoSideEffects = 0,
            /// <summary>
            /// <para>Allow UB that we can give a value, but not</para>
            /// <para>arbitrary unmodeled side effects.</para>
            /// </summary>
            AllowUndefinedBehavior = 1,
            /// <summary>Allow any unmodeled side effect.</summary>
            AllowSideEffects = 2
        }

        public enum ConstantExprKind
        {
            /// <summary>
            /// <para>An integer constant expression (an array bound, enumerator, case value,</para>
            /// <para>bit-field width, or similar) or similar.</para>
            /// </summary>
            Normal = 0,
            /// <summary>
            /// <para>A non-class template argument. Such a value is only used for mangling,</para>
            /// <para>not for code generation, so can refer to dllimported functions.</para>
            /// </summary>
            NonClassTemplateArgument = 1,
            /// <summary>A class template argument. Such a value is used for code generation.</summary>
            ClassTemplateArgument = 2,
            /// <summary>
            /// <para>An immediate invocation. The destruction of the end result of this</para>
            /// <para>evaluation is not part of the evaluation, but all other temporaries</para>
            /// <para>are destroyed.</para>
            /// </summary>
            ImmediateInvocation = 3
        }

        public enum NullPointerConstantKind
        {
            /// <summary>Expression is not a Null pointer constant.</summary>
            NotNull = 0,
            /// <summary>
            /// <para>Expression is a Null pointer constant built from a zero integer</para>
            /// <para>expression that is not a simple, possibly parenthesized, zero literal.</para>
            /// <para>C++ Core Issue 903 will classify these expressions as &quot;not pointers&quot;</para>
            /// <para>once it is adopted.</para>
            /// <para>http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#903</para>
            /// </summary>
            ZeroExpression = 1,
            /// <summary>Expression is a Null pointer constant built from a literal zero.</summary>
            ZeroLiteral = 2,
            /// <summary>Expression is a C++11 nullptr.</summary>
            CXX11_nullptr = 3,
            /// <summary>Expression is a GNU-style __null constant.</summary>
            GNUNull = 4
        }

        public enum NullPointerConstantValueDependence
        {
            /// <summary>Specifies that the expression should never be value-dependent.</summary>
            NeverValueDependent = 0,
            /// <summary>
            /// <para>Specifies that a value-dependent expression of integral or</para>
            /// <para>dependent type should be considered a null pointer constant.</para>
            /// </summary>
            ValueDependentIsNull = 1,
            /// <summary>
            /// <para>Specifies that a value-dependent expression should be considered</para>
            /// <para>to never be a null pointer constant.</para>
            /// </summary>
            ValueDependentIsNotNull = 2
        }

        public partial class Classification
        {
            public enum Kinds
            {
                LValue = 0,
                XValue = 1,
                Function = 2,
                Void = 3,
                AddressableVoid = 4,
                DuplicateVectorComponents = 5,
                MemberFunction = 6,
                SubObjCPropertySetting = 7,
                ClassTemporary = 8,
                ArrayTemporary = 9,
                ObjCMessageRValue = 10,
                PRValue = 11
            }

            public enum ModifiableType
            {
                Untested = 0,
                Modifiable = 1,
                RValue = 2,
                Function = 3,
                LValueCast = 4,
                NoSetterProperty = 5,
                ConstQualified = 6,
                ConstQualifiedField = 7,
                ConstAddrSpace = 8,
                ArrayType = 9,
                IncompleteType = 10
            }

            public Classification()
            {
            }

            public Expr.Classification.Kinds Kind { get; set; }
            public Expr.Classification.ModifiableType Modifiable { get; set; }
            public bool IsLValue { get; set; }
            public bool IsXValue { get; set; }
            public bool IsGLValue { get; set; }
            public bool IsPRValue { get; set; }
            public bool IsRValue { get; set; }
            public bool IsModifiable { get; set; }
        }

        public Expr()
        {
        }

        public ExprDependence Dependence { get; set; }
        public QualifiedType Type { get; set; }
        public bool IsValueDependent { get; set; }
        public bool IsTypeDependent { get; set; }
        public bool IsInstantiationDependent { get; set; }
        public bool ContainsUnexpandedParameterPack { get; set; }
        public bool ContainsErrors { get; set; }
        public SourceLocation ExprLoc { get; set; }
        public bool IsReadIfDiscardedInCPlusPlus11 { get; set; }
        public bool IsLValue { get; set; }
        public bool IsPRValue { get; set; }
        public bool IsXValue { get; set; }
        public bool IsGLValue { get; set; }
        public bool IsOrdinaryOrBitFieldObject { get; set; }
        public bool RefersToMatrixElement { get; set; }
        public bool HasPlaceholderType { get; set; }
    }

    public abstract partial class FullExpr : Expr
    {
        public FullExpr()
        {
        }

        public Expr SubExpr { get; set; }
    }

    public partial class ConstantExpr : FullExpr
    {
        public enum ResultStorageKind
        {
            None = 0,
            Int64 = 1,
            APValue = 2
        }

        public ConstantExpr()
        {
        }

        public ConstantExpr.ResultStorageKind resultStorageKind { get; set; }
        public bool IsImmediateInvocation { get; set; }
        public bool HasAPValueResult { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitConstantExpr(this);
    }

    public partial class OpaqueValueExpr : Expr
    {
        public OpaqueValueExpr()
        {
        }

        public SourceLocation Location { get; set; }
        public SourceLocation ExprLoc { get; set; }
        public Expr SourceExpr { get; set; }
        public bool IsUnique { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitOpaqueValueExpr(this);
    }

    public partial class DeclRefExpr : Expr
    {
        public DeclRefExpr()
        {
        }

        public SourceLocation Location { get; set; }
        public bool HasQualifier { get; set; }
        public bool HasTemplateKWAndArgsInfo { get; set; }
        public SourceLocation TemplateKeywordLoc { get; set; }
        public SourceLocation LAngleLoc { get; set; }
        public SourceLocation RAngleLoc { get; set; }
        public bool HasTemplateKeyword { get; set; }
        public bool HasExplicitTemplateArgs { get; set; }
        public uint NumTemplateArgs { get; set; }
        public bool HadMultipleCandidates { get; set; }
        public NonOdrUseReason IsNonOdrUse { get; set; }
        public bool RefersToEnclosingVariableOrCapture { get; set; }
        public bool IsImmediateEscalating { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitDeclRefExpr(this);
    }

    public partial class IntegerLiteral : Expr
    {
        public IntegerLiteral()
        {
        }

        public SourceLocation Location { get; set; }
        public ulong Value { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitIntegerLiteral(this);
    }

    public partial class FixedPointLiteral : Expr
    {
        public FixedPointLiteral()
        {
        }

        public SourceLocation Location { get; set; }
        public uint Scale { get; set; }
        public ulong Value { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitFixedPointLiteral(this);
    }

    public partial class CharacterLiteral : Expr
    {
        public enum CharacterKind
        {
            Ascii = 0,
            Wide = 1,
            UTF8 = 2,
            UTF16 = 3,
            UTF32 = 4
        }

        public CharacterLiteral()
        {
        }

        public SourceLocation Location { get; set; }
        public CharacterLiteral.CharacterKind Kind { get; set; }
        public uint Value { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitCharacterLiteral(this);
    }

    public partial class FloatingLiteral : Expr
    {
        public FloatingLiteral()
        {
        }

        public FloatSemantics RawSemantics { get; set; }
        public bool Exact { get; set; }
        public double ValueAsApproximateDouble { get; set; }
        public SourceLocation Location { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitFloatingLiteral(this);
    }

    public partial class ImaginaryLiteral : Expr
    {
        public ImaginaryLiteral()
        {
        }

        public Expr SubExpr { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitImaginaryLiteral(this);
    }

    public partial class StringLiteral : Expr
    {
        public enum StringKind
        {
            Ordinary = 0,
            Wide = 1,
            UTF8 = 2,
            UTF16 = 3,
            UTF32 = 4,
            Unevaluated = 5
        }

        public StringLiteral()
        {
        }

        public string String { get; set; }
        public string Bytes { get; set; }
        public uint ByteLength { get; set; }
        public uint Length { get; set; }
        public uint CharByteWidth { get; set; }
        public StringLiteral.StringKind Kind { get; set; }
        public bool IsOrdinary { get; set; }
        public bool IsWide { get; set; }
        public bool IsUTF8 { get; set; }
        public bool IsUTF16 { get; set; }
        public bool IsUTF32 { get; set; }
        public bool IsUnevaluated { get; set; }
        public bool IsPascal { get; set; }
        public bool ContainsNonAscii { get; set; }
        public bool ContainsNonAsciiOrNull { get; set; }
        public uint NumConcatenated { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitStringLiteral(this);
    }

    public partial class PredefinedExpr : Expr
    {
        public enum IdentKind
        {
            Func = 0,
            Function = 1,
            LFunction = 2,
            FuncDName = 3,
            FuncSig = 4,
            LFuncSig = 5,
            PrettyFunction = 6,
            /// <summary>
            /// <para>The same as PrettyFunction, except that the</para>
            /// <para>'virtual' keyword is omitted for virtual member functions.</para>
            /// </summary>
            PrettyFunctionNoVirtual = 7
        }

        public PredefinedExpr()
        {
        }

        public PredefinedExpr.IdentKind identKind { get; set; }
        public bool IsTransparent { get; set; }
        public SourceLocation Location { get; set; }
        public string IdentKindName { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitPredefinedExpr(this);
    }

    public partial class SYCLUniqueStableNameExpr : Expr
    {
        public SYCLUniqueStableNameExpr()
        {
        }

        public SourceLocation Location { get; set; }
        public SourceLocation LParenLocation { get; set; }
        public SourceLocation RParenLocation { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitSYCLUniqueStableNameExpr(this);
    }

    public partial class ParenExpr : Expr
    {
        public ParenExpr()
        {
        }

        public Expr SubExpr { get; set; }
        public SourceLocation LParen { get; set; }
        public SourceLocation RParen { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitParenExpr(this);
    }

    public partial class UnaryOperator : Expr
    {
        public UnaryOperator()
        {
        }

        public UnaryOperatorKind Opcode { get; set; }
        public Expr SubExpr { get; set; }
        public SourceLocation OperatorLoc { get; set; }
        public bool CanOverflow { get; set; }
        public bool IsPrefix { get; set; }
        public bool IsPostfix { get; set; }
        public bool IsIncrementOp { get; set; }
        public bool IsDecrementOp { get; set; }
        public bool IsIncrementDecrementOp { get; set; }
        public bool IsArithmeticOp { get; set; }
        public SourceLocation ExprLoc { get; set; }
        public bool HasStoredFPFeatures { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitUnaryOperator(this);
    }

    public partial class OffsetOfExpr : Expr
    {
        public OffsetOfExpr()
        {
        }

        public SourceLocation OperatorLoc { get; set; }
        public SourceLocation RParenLoc { get; set; }
        public uint NumComponents { get; set; }
        public uint NumExpressions { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitOffsetOfExpr(this);
    }

    public partial class UnaryExprOrTypeTraitExpr : Expr
    {
        public UnaryExprOrTypeTraitExpr()
        {
        }

        public UnaryExprOrTypeTrait Kind { get; set; }
        public bool IsArgumentType { get; set; }
        public QualifiedType ArgumentType { get; set; }
        public QualifiedType TypeOfArgument { get; set; }
        public SourceLocation OperatorLoc { get; set; }
        public SourceLocation RParenLoc { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitUnaryExprOrTypeTraitExpr(this);
    }

    public partial class ArraySubscriptExpr : Expr
    {
        public ArraySubscriptExpr()
        {
        }

        public Expr LHS { get; set; }
        public Expr RHS { get; set; }
        public SourceLocation RBracketLoc { get; set; }
        public SourceLocation ExprLoc { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitArraySubscriptExpr(this);
    }

    public partial class MatrixSubscriptExpr : Expr
    {
        public MatrixSubscriptExpr()
        {
        }

        public bool IsIncomplete { get; set; }
        public Expr Base { get; set; }
        public Expr RowIdx { get; set; }
        public Expr ColumnIdx { get; set; }
        public SourceLocation ExprLoc { get; set; }
        public SourceLocation RBracketLoc { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitMatrixSubscriptExpr(this);
    }

    public partial class CallExpr : Expr
    {
        public enum ADLCallKind : byte
        {
            NotADL = 0,
            UsesADL = 1
        }

        public CallExpr()
        {
        }

        public List<Expr> Arguments { get; private set; } = new List<Expr>();
        public Expr Callee { get; set; }
        public CallExpr.ADLCallKind aDLCallKind { get; set; }
        public bool UsesADL { get; set; }
        public bool HasStoredFPFeatures { get; set; }
        public uint NumArgs { get; set; }
        public uint BuiltinCallee { get; set; }
        public SourceLocation RParenLoc { get; set; }
        public bool IsCallToStdMove { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitCallExpr(this);
    }

    public partial class MemberExpr : Expr
    {
        public MemberExpr()
        {
        }

        public Expr Base { get; set; }
        public bool HasQualifier { get; set; }
        public SourceLocation TemplateKeywordLoc { get; set; }
        public SourceLocation LAngleLoc { get; set; }
        public SourceLocation RAngleLoc { get; set; }
        public bool HasTemplateKeyword { get; set; }
        public bool HasExplicitTemplateArgs { get; set; }
        public uint NumTemplateArgs { get; set; }
        public SourceLocation OperatorLoc { get; set; }
        public bool Arrow { get; set; }
        public SourceLocation MemberLoc { get; set; }
        public SourceLocation ExprLoc { get; set; }
        public bool IsImplicitAccess { get; set; }
        public bool HadMultipleCandidates { get; set; }
        public NonOdrUseReason IsNonOdrUse { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitMemberExpr(this);
    }

    public partial class CompoundLiteralExpr : Expr
    {
        public CompoundLiteralExpr()
        {
        }

        public Expr Initializer { get; set; }
        public bool FileScope { get; set; }
        public SourceLocation LParenLoc { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitCompoundLiteralExpr(this);
    }

    public abstract partial class CastExpr : Expr
    {
        public CastExpr()
        {
        }

        public CastKind CastKind { get; set; }
        public string CastKindName { get; set; }
        public Expr SubExpr { get; set; }
        public Declaration ConversionFunction { get; set; }
        public bool PathEmpty { get; set; }
        public uint PathSize { get; set; }
        public bool HasStoredFPFeatures { get; set; }
    }

    public partial class ImplicitCastExpr : CastExpr
    {
        public enum OnStack_t
        {
            OnStack = 0
        }

        public ImplicitCastExpr()
        {
        }

        public bool IsPartOfExplicitCast { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitImplicitCastExpr(this);
    }

    public abstract partial class ExplicitCastExpr : CastExpr
    {
        public ExplicitCastExpr()
        {
        }

        public QualifiedType TypeAsWritten { get; set; }
    }

    public partial class CStyleCastExpr : ExplicitCastExpr
    {
        public CStyleCastExpr()
        {
        }

        public SourceLocation LParenLoc { get; set; }
        public SourceLocation RParenLoc { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitCStyleCastExpr(this);
    }

    public partial class BinaryOperator : Expr
    {
        public BinaryOperator()
        {
        }

        public SourceLocation ExprLoc { get; set; }
        public SourceLocation OperatorLoc { get; set; }
        public BinaryOperatorKind Opcode { get; set; }
        public Expr LHS { get; set; }
        public Expr RHS { get; set; }
        public string OpcodeStr { get; set; }
        public bool IsPtrMemOp { get; set; }
        public bool IsMultiplicativeOp { get; set; }
        public bool IsAdditiveOp { get; set; }
        public bool IsShiftOp { get; set; }
        public bool IsBitwiseOp { get; set; }
        public bool IsRelationalOp { get; set; }
        public bool IsEqualityOp { get; set; }
        public bool IsComparisonOp { get; set; }
        public bool IsCommaOp { get; set; }
        public bool IsLogicalOp { get; set; }
        public bool IsAssignmentOp { get; set; }
        public bool IsCompoundAssignmentOp { get; set; }
        public bool IsShiftAssignOp { get; set; }
        public bool HasStoredFPFeatures { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitBinaryOperator(this);
    }

    public partial class CompoundAssignOperator : BinaryOperator
    {
        public CompoundAssignOperator()
        {
        }

        public QualifiedType ComputationLHSType { get; set; }
        public QualifiedType ComputationResultType { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitCompoundAssignOperator(this);
    }

    public abstract partial class AbstractConditionalOperator : Expr
    {
        public AbstractConditionalOperator()
        {
        }

        public Expr Cond { get; set; }
        public Expr TrueExpr { get; set; }
        public Expr FalseExpr { get; set; }
        public SourceLocation QuestionLoc { get; set; }
        public SourceLocation ColonLoc { get; set; }
    }

    public partial class ConditionalOperator : AbstractConditionalOperator
    {
        public ConditionalOperator()
        {
        }

        public Expr Cond { get; set; }
        public Expr TrueExpr { get; set; }
        public Expr FalseExpr { get; set; }
        public Expr LHS { get; set; }
        public Expr RHS { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitConditionalOperator(this);
    }

    public partial class BinaryConditionalOperator : AbstractConditionalOperator
    {
        public BinaryConditionalOperator()
        {
        }

        public Expr Common { get; set; }
        public OpaqueValueExpr OpaqueValue { get; set; }
        public Expr Cond { get; set; }
        public Expr TrueExpr { get; set; }
        public Expr FalseExpr { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitBinaryConditionalOperator(this);
    }

    public partial class AddrLabelExpr : Expr
    {
        public AddrLabelExpr()
        {
        }

        public SourceLocation AmpAmpLoc { get; set; }
        public SourceLocation LabelLoc { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitAddrLabelExpr(this);
    }

    public partial class StmtExpr : Expr
    {
        public StmtExpr()
        {
        }

        public CompoundStmt SubStmt { get; set; }
        public SourceLocation LParenLoc { get; set; }
        public SourceLocation RParenLoc { get; set; }
        public uint TemplateDepth { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitStmtExpr(this);
    }

    public partial class ShuffleVectorExpr : Expr
    {
        public ShuffleVectorExpr()
        {
        }

        public SourceLocation BuiltinLoc { get; set; }
        public SourceLocation RParenLoc { get; set; }
        public uint NumSubExprs { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitShuffleVectorExpr(this);
    }

    public partial class ConvertVectorExpr : Expr
    {
        public ConvertVectorExpr()
        {
        }

        public Expr SrcExpr { get; set; }
        public SourceLocation BuiltinLoc { get; set; }
        public SourceLocation RParenLoc { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitConvertVectorExpr(this);
    }

    public partial class ChooseExpr : Expr
    {
        public ChooseExpr()
        {
        }

        public bool IsConditionTrue { get; set; }
        public bool IsConditionDependent { get; set; }
        public Expr ChosenSubExpr { get; set; }
        public Expr Cond { get; set; }
        public Expr LHS { get; set; }
        public Expr RHS { get; set; }
        public SourceLocation BuiltinLoc { get; set; }
        public SourceLocation RParenLoc { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitChooseExpr(this);
    }

    public partial class GNUNullExpr : Expr
    {
        public GNUNullExpr()
        {
        }

        public SourceLocation TokenLocation { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitGNUNullExpr(this);
    }

    public partial class VAArgExpr : Expr
    {
        public VAArgExpr()
        {
        }

        public Expr SubExpr { get; set; }
        public bool IsMicrosoftABI { get; set; }
        public SourceLocation BuiltinLoc { get; set; }
        public SourceLocation RParenLoc { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitVAArgExpr(this);
    }

    public partial class SourceLocExpr : Expr
    {
        public enum IdentKind
        {
            Function = 0,
            FuncSig = 1,
            File = 2,
            FileName = 3,
            Line = 4,
            Column = 5,
            SourceLocStruct = 6
        }

        public SourceLocExpr()
        {
        }

        public string BuiltinStr { get; set; }
        public SourceLocExpr.IdentKind identKind { get; set; }
        public bool IsIntType { get; set; }
        public SourceLocation Location { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitSourceLocExpr(this);
    }

    public partial class InitListExpr : Expr
    {
        public InitListExpr()
        {
        }

        public uint NumInits { get; set; }
        public Expr ArrayFiller { get; set; }
        public bool HasArrayFiller { get; set; }
        public bool HasDesignatedInit { get; set; }
        public bool IsExplicit { get; set; }
        public bool IsStringLiteralInit { get; set; }
        public bool IsTransparent { get; set; }
        public SourceLocation LBraceLoc { get; set; }
        public SourceLocation RBraceLoc { get; set; }
        public bool IsSemanticForm { get; set; }
        public InitListExpr SemanticForm { get; set; }
        public bool IsSyntacticForm { get; set; }
        public InitListExpr SyntacticForm { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitInitListExpr(this);
    }

    public partial class DesignatedInitExpr : Expr
    {
        public partial class Designator
        {
            internal enum DesignatorKind
            {
                FieldDesignator = 0,
                ArrayDesignator = 1,
                ArrayRangeDesignator = 2
            }

            public partial class FieldDesignatorInfo
            {
                public FieldDesignatorInfo()
                {
                }

            }
            public partial class ArrayOrRangeDesignatorInfo
            {
                public ArrayOrRangeDesignatorInfo()
                {
                }

            }

            public Designator()
            {
            }

            public bool IsFieldDesignator { get; set; }
            public bool IsArrayDesignator { get; set; }
            public bool IsArrayRangeDesignator { get; set; }
            public Field FieldDecl { get; set; }
            public SourceLocation DotLoc { get; set; }
            public SourceLocation FieldLoc { get; set; }
            public uint ArrayIndex { get; set; }
            public SourceLocation LBracketLoc { get; set; }
            public SourceLocation EllipsisLoc { get; set; }
            public SourceLocation RBracketLoc { get; set; }
            public SourceRange SourceRange { get; set; }
        }

        public DesignatedInitExpr()
        {
        }

        public uint Size { get; set; }
        public SourceLocation EqualOrColonLoc { get; set; }
        public bool IsDirectInit { get; set; }
        public bool UsesGNUSyntax { get; set; }
        public Expr Init { get; set; }
        public uint NumSubExprs { get; set; }
        public SourceRange DesignatorsSourceRange { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitDesignatedInitExpr(this);
    }

    public partial class NoInitExpr : Expr
    {
        public NoInitExpr()
        {
        }


        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitNoInitExpr(this);
    }

    public partial class DesignatedInitUpdateExpr : Expr
    {
        public DesignatedInitUpdateExpr()
        {
        }

        public Expr Base { get; set; }
        public InitListExpr Updater { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitDesignatedInitUpdateExpr(this);
    }

    public partial class ArrayInitLoopExpr : Expr
    {
        public ArrayInitLoopExpr()
        {
        }

        public OpaqueValueExpr CommonExpr { get; set; }
        public Expr SubExpr { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitArrayInitLoopExpr(this);
    }

    public partial class ArrayInitIndexExpr : Expr
    {
        public ArrayInitIndexExpr()
        {
        }


        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitArrayInitIndexExpr(this);
    }

    public partial class ImplicitValueInitExpr : Expr
    {
        public ImplicitValueInitExpr()
        {
        }


        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitImplicitValueInitExpr(this);
    }

    public partial class ParenListExpr : Expr
    {
        public ParenListExpr()
        {
        }

        public uint NumExprs { get; set; }
        public SourceLocation LParenLoc { get; set; }
        public SourceLocation RParenLoc { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitParenListExpr(this);
    }

    public partial class GenericSelectionExpr : Expr
    {
        public GenericSelectionExpr()
        {
        }

        public uint NumAssocs { get; set; }
        public uint ResultIndex { get; set; }
        public bool IsResultDependent { get; set; }
        public bool IsExprPredicate { get; set; }
        public bool IsTypePredicate { get; set; }
        public SourceLocation GenericLoc { get; set; }
        public SourceLocation DefaultLoc { get; set; }
        public SourceLocation RParenLoc { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitGenericSelectionExpr(this);
    }

    public partial class ExtVectorElementExpr : Expr
    {
        public ExtVectorElementExpr()
        {
        }

        public Expr Base { get; set; }
        public SourceLocation AccessorLoc { get; set; }
        public uint NumElements { get; set; }
        public bool ContainsDuplicateElements { get; set; }
        public bool IsArrow { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitExtVectorElementExpr(this);
    }

    public partial class BlockExpr : Expr
    {
        public BlockExpr()
        {
        }

        public SourceLocation CaretLocation { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitBlockExpr(this);
    }

    public partial class AsTypeExpr : Expr
    {
        public AsTypeExpr()
        {
        }

        public Expr SrcExpr { get; set; }
        public SourceLocation BuiltinLoc { get; set; }
        public SourceLocation RParenLoc { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitAsTypeExpr(this);
    }

    public partial class PseudoObjectExpr : Expr
    {
        public PseudoObjectExpr()
        {
        }

        public uint ResultExprIndex { get; set; }
        public uint NumSemanticExprs { get; set; }
        public SourceLocation ExprLoc { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitPseudoObjectExpr(this);
    }

    public partial class AtomicExpr : Expr
    {
        public enum AtomicOp
        {
            C11AtomicInit = 0,
            C11AtomicLoad = 1,
            C11AtomicStore = 2,
            C11AtomicExchange = 3,
            C11AtomicCompareExchangeStrong = 4,
            C11AtomicCompareExchangeWeak = 5,
            C11AtomicFetchAdd = 6,
            C11AtomicFetchSub = 7,
            C11AtomicFetchAnd = 8,
            C11AtomicFetchOr = 9,
            C11AtomicFetchXor = 10,
            C11AtomicFetchNand = 11,
            C11AtomicFetchMax = 12,
            C11AtomicFetchMin = 13,
            AtomicLoad = 14,
            AtomicLoadN = 15,
            AtomicStore = 16,
            AtomicStoreN = 17,
            AtomicExchange = 18,
            AtomicExchangeN = 19,
            AtomicCompareExchange = 20,
            AtomicCompareExchangeN = 21,
            AtomicFetchAdd = 22,
            AtomicFetchSub = 23,
            AtomicFetchAnd = 24,
            AtomicFetchOr = 25,
            AtomicFetchXor = 26,
            AtomicFetchNand = 27,
            AtomicAddFetch = 28,
            AtomicSubFetch = 29,
            AtomicAndFetch = 30,
            AtomicOrFetch = 31,
            AtomicXorFetch = 32,
            AtomicMaxFetch = 33,
            AtomicMinFetch = 34,
            AtomicNandFetch = 35,
            OpenclAtomicInit = 36,
            OpenclAtomicLoad = 37,
            OpenclAtomicStore = 38,
            OpenclAtomicExchange = 39,
            OpenclAtomicCompareExchangeStrong = 40,
            OpenclAtomicCompareExchangeWeak = 41,
            OpenclAtomicFetchAdd = 42,
            OpenclAtomicFetchSub = 43,
            OpenclAtomicFetchAnd = 44,
            OpenclAtomicFetchOr = 45,
            OpenclAtomicFetchXor = 46,
            OpenclAtomicFetchMin = 47,
            OpenclAtomicFetchMax = 48,
            AtomicFetchMin = 49,
            AtomicFetchMax = 50,
            HipAtomicLoad = 51,
            HipAtomicStore = 52,
            HipAtomicCompareExchangeWeak = 53,
            HipAtomicCompareExchangeStrong = 54,
            HipAtomicExchange = 55,
            HipAtomicFetchAdd = 56,
            HipAtomicFetchSub = 57,
            HipAtomicFetchAnd = 58,
            HipAtomicFetchOr = 59,
            HipAtomicFetchXor = 60,
            HipAtomicFetchMin = 61,
            HipAtomicFetchMax = 62,
        }

        public AtomicExpr()
        {
        }

        public Expr Ptr { get; set; }
        public Expr Order { get; set; }
        public Expr Scope { get; set; }
        public Expr Val1 { get; set; }
        public Expr OrderFail { get; set; }
        public Expr Val2 { get; set; }
        public Expr Weak { get; set; }
        public QualifiedType ValueType { get; set; }
        public AtomicExpr.AtomicOp Op { get; set; }
        public uint NumSubExprs { get; set; }
        public bool IsVolatile { get; set; }
        public bool IsCmpXChg { get; set; }
        public bool IsOpenCL { get; set; }
        public SourceLocation BuiltinLoc { get; set; }
        public SourceLocation RParenLoc { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitAtomicExpr(this);
    }

    public partial class TypoExpr : Expr
    {
        public TypoExpr()
        {
        }


        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitTypoExpr(this);
    }

    public partial class RecoveryExpr : Expr
    {
        public RecoveryExpr()
        {
        }


        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitRecoveryExpr(this);
    }

    public partial class CXXOperatorCallExpr : CallExpr
    {
        public CXXOperatorCallExpr()
        {
        }

        public OverloadedOperatorKind Operator { get; set; }
        public bool IsAssignmentOp { get; set; }
        public bool IsComparisonOp { get; set; }
        public bool IsInfixBinaryOp { get; set; }
        public SourceLocation OperatorLoc { get; set; }
        public SourceLocation ExprLoc { get; set; }
        public SourceRange SourceRange { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitCXXOperatorCallExpr(this);
    }

    public partial class CXXMemberCallExpr : CallExpr
    {
        public CXXMemberCallExpr()
        {
        }

        public Expr ImplicitObjectArgument { get; set; }
        public QualifiedType ObjectType { get; set; }
        public Method MethodDecl { get; set; }
        public SourceLocation ExprLoc { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitCXXMemberCallExpr(this);
    }

    public partial class CUDAKernelCallExpr : CallExpr
    {
        public CUDAKernelCallExpr()
        {
        }


        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitCUDAKernelCallExpr(this);
    }

    public partial class CXXRewrittenBinaryOperator : Expr
    {
        public CXXRewrittenBinaryOperator()
        {
        }

        public bool IsReversed { get; set; }
        public BinaryOperatorKind Operator { get; set; }
        public BinaryOperatorKind Opcode { get; set; }
        public string OpcodeStr { get; set; }
        public bool IsComparisonOp { get; set; }
        public bool IsAssignmentOp { get; set; }
        public Expr LHS { get; set; }
        public Expr RHS { get; set; }
        public SourceLocation OperatorLoc { get; set; }
        public SourceLocation ExprLoc { get; set; }
        public SourceRange SourceRange { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitCXXRewrittenBinaryOperator(this);
    }

    public abstract partial class CXXNamedCastExpr : ExplicitCastExpr
    {
        public CXXNamedCastExpr()
        {
        }

        public string CastName { get; set; }
        public SourceLocation OperatorLoc { get; set; }
        public SourceLocation RParenLoc { get; set; }
        public SourceRange AngleBrackets { get; set; }
    }

    public partial class CXXStaticCastExpr : CXXNamedCastExpr
    {
        public CXXStaticCastExpr()
        {
        }


        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitCXXStaticCastExpr(this);
    }

    public partial class CXXDynamicCastExpr : CXXNamedCastExpr
    {
        public CXXDynamicCastExpr()
        {
        }

        public bool IsAlwaysNull { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitCXXDynamicCastExpr(this);
    }

    public partial class CXXReinterpretCastExpr : CXXNamedCastExpr
    {
        public CXXReinterpretCastExpr()
        {
        }


        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitCXXReinterpretCastExpr(this);
    }

    public partial class CXXConstCastExpr : CXXNamedCastExpr
    {
        public CXXConstCastExpr()
        {
        }


        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitCXXConstCastExpr(this);
    }

    public partial class CXXAddrspaceCastExpr : CXXNamedCastExpr
    {
        public CXXAddrspaceCastExpr()
        {
        }


        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitCXXAddrspaceCastExpr(this);
    }

    public partial class UserDefinedLiteral : CallExpr
    {
        public enum LiteralOperatorKind
        {
            /// <summary>Raw form: operator &quot;&quot; X (const char *)</summary>
            Raw = 0,
            /// <summary>Raw form: operator &quot;&quot; X...&gt; ()</summary>
            Template = 1,
            /// <summary>operator &quot;&quot; X (unsigned long long)</summary>
            Integer = 2,
            /// <summary>operator &quot;&quot; X (long double)</summary>
            Floating = 3,
            /// <summary>operator &quot;&quot; X (const CharT *, size_t)</summary>
            String = 4,
            /// <summary>operator &quot;&quot; X (CharT)</summary>
            Character = 5
        }

        public UserDefinedLiteral()
        {
        }

        public UserDefinedLiteral.LiteralOperatorKind literalOperatorKind { get; set; }
        public SourceLocation UDSuffixLoc { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitUserDefinedLiteral(this);
    }

    public partial class CXXBoolLiteralExpr : Expr
    {
        public CXXBoolLiteralExpr()
        {
        }

        public bool Value { get; set; }
        public SourceLocation Location { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitCXXBoolLiteralExpr(this);
    }

    public partial class CXXNullPtrLiteralExpr : Expr
    {
        public CXXNullPtrLiteralExpr()
        {
        }

        public SourceLocation Location { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitCXXNullPtrLiteralExpr(this);
    }

    public partial class CXXStdInitializerListExpr : Expr
    {
        public CXXStdInitializerListExpr()
        {
        }

        public SourceRange SourceRange { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitCXXStdInitializerListExpr(this);
    }

    public partial class CXXTypeidExpr : Expr
    {
        public CXXTypeidExpr()
        {
        }

        public bool IsPotentiallyEvaluated { get; set; }
        public bool IsTypeOperand { get; set; }
        public Expr ExprOperand { get; set; }
        public SourceRange SourceRange { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitCXXTypeidExpr(this);
    }

    public partial class MSPropertyRefExpr : Expr
    {
        public MSPropertyRefExpr()
        {
        }

        public SourceRange SourceRange { get; set; }
        public bool IsImplicitAccess { get; set; }
        public Expr BaseExpr { get; set; }
        public bool IsArrow { get; set; }
        public SourceLocation MemberLoc { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitMSPropertyRefExpr(this);
    }

    public partial class MSPropertySubscriptExpr : Expr
    {
        public MSPropertySubscriptExpr()
        {
        }

        public SourceLocation RBracketLoc { get; set; }
        public SourceLocation ExprLoc { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitMSPropertySubscriptExpr(this);
    }

    public partial class CXXUuidofExpr : Expr
    {
        public CXXUuidofExpr()
        {
        }

        public bool IsTypeOperand { get; set; }
        public Expr ExprOperand { get; set; }
        public string GuidDecl { get; set; }
        public SourceRange SourceRange { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitCXXUuidofExpr(this);
    }

    public partial class CXXThisExpr : Expr
    {
        public CXXThisExpr()
        {
        }

        public SourceLocation Location { get; set; }
        public bool Implicit { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitCXXThisExpr(this);
    }

    public partial class CXXThrowExpr : Expr
    {
        public CXXThrowExpr()
        {
        }

        public SourceLocation ThrowLoc { get; set; }
        public bool IsThrownVariableInScope { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitCXXThrowExpr(this);
    }

    public partial class CXXDefaultArgExpr : Expr
    {
        public CXXDefaultArgExpr()
        {
        }

        public bool HasRewrittenInit { get; set; }
        public SourceLocation UsedLocation { get; set; }
        public SourceLocation ExprLoc { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitCXXDefaultArgExpr(this);
    }

    public partial class CXXDefaultInitExpr : Expr
    {
        public CXXDefaultInitExpr()
        {
        }

        public bool HasRewrittenInit { get; set; }
        public SourceLocation UsedLocation { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitCXXDefaultInitExpr(this);
    }

    public partial class CXXBindTemporaryExpr : Expr
    {
        public CXXBindTemporaryExpr()
        {
        }

        public Expr SubExpr { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitCXXBindTemporaryExpr(this);
    }

    public partial class CXXConstructExpr : Expr
    {
        public enum ConstructionKind
        {
            Complete = 0,
            NonVirtualBase = 1,
            VirtualBase = 2,
            Delegating = 3
        }

        public CXXConstructExpr()
        {
        }

        public List<Expr> Arguments { get; private set; } = new List<Expr>();
        public SourceLocation Location { get; set; }
        public bool Elidable { get; set; }
        public bool HadMultipleCandidates { get; set; }
        public bool ListInitialization { get; set; }
        public bool StdInitListInitialization { get; set; }
        public bool RequiresZeroInitialization { get; set; }
        public uint NumArgs { get; set; }
        public bool IsImmediateEscalating { get; set; }
        public SourceRange ParenOrBraceRange { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitCXXConstructExpr(this);
    }

    public partial class CXXInheritedCtorInitExpr : Expr
    {
        public CXXInheritedCtorInitExpr()
        {
        }

        public bool ConstructsVBase { get; set; }
        public bool InheritedFromVBase { get; set; }
        public SourceLocation Location { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitCXXInheritedCtorInitExpr(this);
    }

    public partial class CXXFunctionalCastExpr : ExplicitCastExpr
    {
        public CXXFunctionalCastExpr()
        {
        }

        public SourceLocation LParenLoc { get; set; }
        public SourceLocation RParenLoc { get; set; }
        public bool IsListInitialization { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitCXXFunctionalCastExpr(this);
    }

    public partial class CXXTemporaryObjectExpr : CXXConstructExpr
    {
        public CXXTemporaryObjectExpr()
        {
        }


        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitCXXTemporaryObjectExpr(this);
    }

    public partial class LambdaExpr : Expr
    {
        public LambdaExpr()
        {
        }

        public List<Expr> CaptureInits { get; private set; } = new List<Expr>();
        public SourceLocation CaptureDefaultLoc { get; set; }
        public uint CaptureSize { get; set; }
        public SourceRange IntroducerRange { get; set; }
        public Method CallOperator { get; set; }
        public FunctionTemplate DependentCallOperator { get; set; }
        public Expr TrailingRequiresClause { get; set; }
        public bool IsGenericLambda { get; set; }
        public Stmt Body { get; set; }
        public bool IsMutable { get; set; }
        public bool HasExplicitParameters { get; set; }
        public bool HasExplicitResultType { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitLambdaExpr(this);
    }

    public partial class CXXScalarValueInitExpr : Expr
    {
        public CXXScalarValueInitExpr()
        {
        }

        public SourceLocation RParenLoc { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitCXXScalarValueInitExpr(this);
    }

    public partial class CXXNewExpr : Expr
    {
        public enum InitializationStyle
        {
            /// <summary>New-expression has no initializer as written.</summary>
            NoInit = 0,
            /// <summary>New-expression has a C++98 paren-delimited initializer.</summary>
            CallInit = 1,
            /// <summary>New-expression has a C++11 list-initializer.</summary>
            ListInit = 2
        }

        public CXXNewExpr()
        {
        }

        public List<Expr> PlacementArguments { get; private set; } = new List<Expr>();
        public QualifiedType AllocatedType { get; set; }
        public Function OperatorNew { get; set; }
        public Function OperatorDelete { get; set; }
        public bool IsArray { get; set; }
        public uint NumPlacementArgs { get; set; }
        public bool IsParenTypeId { get; set; }
        public SourceRange TypeIdParens { get; set; }
        public bool IsGlobalNew { get; set; }
        public bool HasInitializer { get; set; }
        public CXXNewExpr.InitializationStyle initializationStyle { get; set; }
        public CXXConstructExpr ConstructExpr { get; set; }
        public SourceRange DirectInitRange { get; set; }
        public SourceRange SourceRange { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitCXXNewExpr(this);
    }

    public partial class CXXDeleteExpr : Expr
    {
        public CXXDeleteExpr()
        {
        }

        public bool IsGlobalDelete { get; set; }
        public bool IsArrayForm { get; set; }
        public bool IsArrayFormAsWritten { get; set; }
        public Function OperatorDelete { get; set; }
        public QualifiedType DestroyedType { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitCXXDeleteExpr(this);
    }

    public partial class CXXPseudoDestructorExpr : Expr
    {
        public CXXPseudoDestructorExpr()
        {
        }

        public Expr Base { get; set; }
        public bool HasQualifier { get; set; }
        public bool IsArrow { get; set; }
        public SourceLocation OperatorLoc { get; set; }
        public SourceLocation ColonColonLoc { get; set; }
        public SourceLocation TildeLoc { get; set; }
        public QualifiedType DestroyedType { get; set; }
        public SourceLocation DestroyedTypeLoc { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitCXXPseudoDestructorExpr(this);
    }

    public partial class TypeTraitExpr : Expr
    {
        public TypeTraitExpr()
        {
        }

        public bool Value { get; set; }
        public uint NumArgs { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitTypeTraitExpr(this);
    }

    public partial class ArrayTypeTraitExpr : Expr
    {
        public ArrayTypeTraitExpr()
        {
        }

        public QualifiedType QueriedType { get; set; }
        public ulong Value { get; set; }
        public Expr DimensionExpression { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitArrayTypeTraitExpr(this);
    }

    public partial class ExpressionTraitExpr : Expr
    {
        public ExpressionTraitExpr()
        {
        }

        public Expr QueriedExpression { get; set; }
        public bool Value { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitExpressionTraitExpr(this);
    }

    public abstract partial class OverloadExpr : Expr
    {
        public partial class FindResult
        {
            public FindResult()
            {
            }

        }

        public OverloadExpr()
        {
        }

        public uint NumDecls { get; set; }
        public SourceLocation NameLoc { get; set; }
        public SourceLocation TemplateKeywordLoc { get; set; }
        public SourceLocation LAngleLoc { get; set; }
        public SourceLocation RAngleLoc { get; set; }
        public bool HasTemplateKeyword { get; set; }
        public bool HasExplicitTemplateArgs { get; set; }
        public uint NumTemplateArgs { get; set; }
    }

    public partial class UnresolvedLookupExpr : OverloadExpr
    {
        public UnresolvedLookupExpr()
        {
        }

        public bool RequiresADL { get; set; }
        public bool IsOverloaded { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitUnresolvedLookupExpr(this);
    }

    public partial class DependentScopeDeclRefExpr : Expr
    {
        public DependentScopeDeclRefExpr()
        {
        }

        public SourceLocation Location { get; set; }
        public SourceLocation TemplateKeywordLoc { get; set; }
        public SourceLocation LAngleLoc { get; set; }
        public SourceLocation RAngleLoc { get; set; }
        public bool HasTemplateKeyword { get; set; }
        public bool HasExplicitTemplateArgs { get; set; }
        public uint NumTemplateArgs { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitDependentScopeDeclRefExpr(this);
    }

    public partial class ExprWithCleanups : FullExpr
    {
        public ExprWithCleanups()
        {
        }

        public uint NumObjects { get; set; }
        public bool CleanupsHaveSideEffects { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitExprWithCleanups(this);
    }

    public partial class CXXUnresolvedConstructExpr : Expr
    {
        public CXXUnresolvedConstructExpr()
        {
        }

        public List<Expr> Arguments { get; private set; } = new List<Expr>();
        public QualifiedType TypeAsWritten { get; set; }
        public SourceLocation LParenLoc { get; set; }
        public SourceLocation RParenLoc { get; set; }
        public bool IsListInitialization { get; set; }
        public uint NumArgs { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitCXXUnresolvedConstructExpr(this);
    }

    public partial class CXXDependentScopeMemberExpr : Expr
    {
        public CXXDependentScopeMemberExpr()
        {
        }

        public bool IsImplicitAccess { get; set; }
        public Expr Base { get; set; }
        public QualifiedType BaseType { get; set; }
        public bool IsArrow { get; set; }
        public SourceLocation OperatorLoc { get; set; }
        public Declaration FirstQualifierFoundInScope { get; set; }
        public SourceLocation MemberLoc { get; set; }
        public SourceLocation TemplateKeywordLoc { get; set; }
        public SourceLocation LAngleLoc { get; set; }
        public SourceLocation RAngleLoc { get; set; }
        public bool HasTemplateKeyword { get; set; }
        public bool HasExplicitTemplateArgs { get; set; }
        public uint NumTemplateArgs { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitCXXDependentScopeMemberExpr(this);
    }

    public partial class UnresolvedMemberExpr : OverloadExpr
    {
        public UnresolvedMemberExpr()
        {
        }

        public bool IsImplicitAccess { get; set; }
        public QualifiedType BaseType { get; set; }
        public bool HasUnresolvedUsing { get; set; }
        public bool IsArrow { get; set; }
        public SourceLocation OperatorLoc { get; set; }
        public SourceLocation MemberLoc { get; set; }
        public SourceLocation ExprLoc { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitUnresolvedMemberExpr(this);
    }

    public partial class CXXNoexceptExpr : Expr
    {
        public CXXNoexceptExpr()
        {
        }

        public Expr Operand { get; set; }
        public SourceRange SourceRange { get; set; }
        public bool Value { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitCXXNoexceptExpr(this);
    }

    public partial class PackExpansionExpr : Expr
    {
        public PackExpansionExpr()
        {
        }

        public SourceLocation EllipsisLoc { get; set; }
        public uint? NumExpansions { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitPackExpansionExpr(this);
    }

    public partial class SizeOfPackExpr : Expr
    {
        public SizeOfPackExpr()
        {
        }

        public SourceLocation OperatorLoc { get; set; }
        public SourceLocation PackLoc { get; set; }
        public SourceLocation RParenLoc { get; set; }
        public Declaration Pack { get; set; }
        public uint PackLength { get; set; }
        public bool IsPartiallySubstituted { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitSizeOfPackExpr(this);
    }

    public partial class SubstNonTypeTemplateParmExpr : Expr
    {
        public SubstNonTypeTemplateParmExpr()
        {
        }

        public SourceLocation NameLoc { get; set; }
        public Expr Replacement { get; set; }
        public Declaration AssociatedDecl { get; set; }
        public uint Index { get; set; }
        public uint? PackIndex { get; set; }
        public bool IsReferenceParameter { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitSubstNonTypeTemplateParmExpr(this);
    }

    public partial class SubstNonTypeTemplateParmPackExpr : Expr
    {
        public SubstNonTypeTemplateParmPackExpr()
        {
        }

        public Declaration AssociatedDecl { get; set; }
        public uint Index { get; set; }
        public SourceLocation ParameterPackLocation { get; set; }
        public TemplateArgument ArgumentPack { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitSubstNonTypeTemplateParmPackExpr(this);
    }

    public partial class FunctionParmPackExpr : Expr
    {
        public FunctionParmPackExpr()
        {
        }

        public SourceLocation ParameterPackLocation { get; set; }
        public uint NumExpansions { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitFunctionParmPackExpr(this);
    }

    public partial class MaterializeTemporaryExpr : Expr
    {
        public MaterializeTemporaryExpr()
        {
        }

        public Expr SubExpr { get; set; }
        public uint ManglingNumber { get; set; }
        public bool IsBoundToLvalueReference { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitMaterializeTemporaryExpr(this);
    }

    public partial class CXXFoldExpr : Expr
    {
        internal enum SubExpr
        {
            Callee = 0,
            LHS = 1,
            RHS = 2,
            Count = 3
        }

        public CXXFoldExpr()
        {
        }

        public UnresolvedLookupExpr Callee { get; set; }
        public Expr LHS { get; set; }
        public Expr RHS { get; set; }
        public bool IsRightFold { get; set; }
        public bool IsLeftFold { get; set; }
        public Expr Pattern { get; set; }
        public Expr Init { get; set; }
        public SourceLocation LParenLoc { get; set; }
        public SourceLocation RParenLoc { get; set; }
        public SourceLocation EllipsisLoc { get; set; }
        public BinaryOperatorKind Operator { get; set; }
        public uint? NumExpansions { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitCXXFoldExpr(this);
    }

    public partial class CXXParenListInitExpr : Expr
    {
        public CXXParenListInitExpr()
        {
        }

        public SourceLocation InitLoc { get; set; }
        public SourceRange SourceRange { get; set; }
        public Expr ArrayFiller { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitCXXParenListInitExpr(this);
    }

    public abstract partial class CoroutineSuspendExpr : Expr
    {
        internal enum SubExpr
        {
            Operand = 0,
            Common = 1,
            Ready = 2,
            Suspend = 3,
            Resume = 4,
            Count = 5
        }

        public CoroutineSuspendExpr()
        {
        }

        public Expr CommonExpr { get; set; }
        public OpaqueValueExpr OpaqueValue { get; set; }
        public Expr ReadyExpr { get; set; }
        public Expr SuspendExpr { get; set; }
        public Expr ResumeExpr { get; set; }
        public Expr Operand { get; set; }
        public SourceLocation KeywordLoc { get; set; }
    }

    public partial class CoawaitExpr : CoroutineSuspendExpr
    {
        public CoawaitExpr()
        {
        }

        public bool IsImplicit { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitCoawaitExpr(this);
    }

    public partial class DependentCoawaitExpr : Expr
    {
        public DependentCoawaitExpr()
        {
        }

        public Expr Operand { get; set; }
        public UnresolvedLookupExpr OperatorCoawaitLookup { get; set; }
        public SourceLocation KeywordLoc { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitDependentCoawaitExpr(this);
    }

    public partial class CoyieldExpr : CoroutineSuspendExpr
    {
        public CoyieldExpr()
        {
        }


        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitCoyieldExpr(this);
    }

    public partial class BuiltinBitCastExpr : ExplicitCastExpr
    {
        public BuiltinBitCastExpr()
        {
        }


        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitBuiltinBitCastExpr(this);
    }
}
