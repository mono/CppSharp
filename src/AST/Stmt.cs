// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------

using System;
using System.Collections.Generic;

namespace CppSharp.AST
{
    public enum StmtClass
    {
        NoStmt = 0,
        GCCAsmStmt = 1,
        MSAsmStmt = 2,
        AttributedStmt = 3,
        BreakStmt = 4,
        CXXCatchStmt = 5,
        CXXForRangeStmt = 6,
        CXXTryStmt = 7,
        CapturedStmt = 8,
        CompoundStmt = 9,
        ContinueStmt = 10,
        CoreturnStmt = 11,
        CoroutineBodyStmt = 12,
        DeclStmt = 13,
        DoStmt = 14,
        BinaryConditionalOperator = 15,
        ConditionalOperator = 16,
        AddrLabelExpr = 17,
        ArrayInitIndexExpr = 18,
        ArrayInitLoopExpr = 19,
        ArraySubscriptExpr = 20,
        ArrayTypeTraitExpr = 21,
        AsTypeExpr = 22,
        AtomicExpr = 23,
        BinaryOperator = 24,
        CompoundAssignOperator = 25,
        BlockExpr = 26,
        CXXBindTemporaryExpr = 27,
        CXXBoolLiteralExpr = 28,
        CXXConstructExpr = 29,
        CXXTemporaryObjectExpr = 30,
        CXXDefaultArgExpr = 31,
        CXXDefaultInitExpr = 32,
        CXXDeleteExpr = 33,
        CXXDependentScopeMemberExpr = 34,
        CXXFoldExpr = 35,
        CXXInheritedCtorInitExpr = 36,
        CXXNewExpr = 37,
        CXXNoexceptExpr = 38,
        CXXNullPtrLiteralExpr = 39,
        CXXPseudoDestructorExpr = 40,
        CXXScalarValueInitExpr = 41,
        CXXStdInitializerListExpr = 42,
        CXXThisExpr = 43,
        CXXThrowExpr = 44,
        CXXTypeidExpr = 45,
        CXXUnresolvedConstructExpr = 46,
        CXXUuidofExpr = 47,
        CallExpr = 48,
        CUDAKernelCallExpr = 49,
        CXXMemberCallExpr = 50,
        CXXOperatorCallExpr = 51,
        UserDefinedLiteral = 52,
        CStyleCastExpr = 53,
        CXXFunctionalCastExpr = 54,
        CXXConstCastExpr = 55,
        CXXDynamicCastExpr = 56,
        CXXReinterpretCastExpr = 57,
        CXXStaticCastExpr = 58,
        ImplicitCastExpr = 60,
        CharacterLiteral = 61,
        ChooseExpr = 62,
        CompoundLiteralExpr = 63,
        ConvertVectorExpr = 64,
        CoawaitExpr = 65,
        CoyieldExpr = 66,
        DeclRefExpr = 67,
        DependentCoawaitExpr = 68,
        DependentScopeDeclRefExpr = 69,
        DesignatedInitExpr = 70,
        DesignatedInitUpdateExpr = 71,
        ExpressionTraitExpr = 72,
        ExtVectorElementExpr = 73,
        FixedPointLiteral = 74,
        FloatingLiteral = 75,
        ConstantExpr = 76,
        ExprWithCleanups = 77,
        FunctionParmPackExpr = 78,
        GNUNullExpr = 79,
        GenericSelectionExpr = 80,
        ImaginaryLiteral = 81,
        ImplicitValueInitExpr = 82,
        InitListExpr = 83,
        IntegerLiteral = 84,
        LambdaExpr = 85,
        MSPropertyRefExpr = 86,
        MSPropertySubscriptExpr = 87,
        MaterializeTemporaryExpr = 88,
        MemberExpr = 89,
        NoInitExpr = 90,
        OffsetOfExpr = 107,
        OpaqueValueExpr = 108,
        UnresolvedLookupExpr = 109,
        UnresolvedMemberExpr = 110,
        PackExpansionExpr = 111,
        ParenExpr = 112,
        ParenListExpr = 113,
        PredefinedExpr = 114,
        PseudoObjectExpr = 115,
        ShuffleVectorExpr = 116,
        SizeOfPackExpr = 117,
        StmtExpr = 118,
        StringLiteral = 119,
        SubstNonTypeTemplateParmExpr = 120,
        SubstNonTypeTemplateParmPackExpr = 121,
        TypeTraitExpr = 122,
        TypoExpr = 123,
        UnaryExprOrTypeTraitExpr = 124,
        UnaryOperator = 125,
        VAArgExpr = 126,
        ForStmt = 127,
        GotoStmt = 128,
        IfStmt = 129,
        IndirectGotoStmt = 130,
        LabelStmt = 131,
        MSDependentExistsStmt = 132,
        NullStmt = 133,
        ReturnStmt = 188,
        SEHExceptStmt = 189,
        SEHFinallyStmt = 190,
        SEHLeaveStmt = 191,
        SEHTryStmt = 192,
        CaseStmt = 193,
        DefaultStmt = 194,
        SwitchStmt = 195,
        WhileStmt = 196,
    }

    public abstract partial class Stmt
    {
        public Stmt()
        {
        }

        public SourceRange SourceRange { get; set; }
        public SourceLocation BeginLoc { get; set; }
        public SourceLocation EndLoc { get; set; }

        public abstract T Visit<T>(IStmtVisitor<T> visitor);
    }

    public partial class DeclStmt : Stmt
    {
        public DeclStmt()
        {
        }

        public List<Declaration> Decls { get; private set; } = new List<Declaration>();
        public bool IsSingleDecl { get; set; }
        public Declaration SingleDecl { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitDeclStmt(this);
    }

    public partial class NullStmt : Stmt
    {
        public NullStmt()
        {
        }

        public SourceLocation SemiLoc { get; set; }
        public bool HasLeadingEmptyMacro { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitNullStmt(this);
    }

    public partial class CompoundStmt : Stmt
    {
        public CompoundStmt()
        {
        }

        public List<Stmt> Body { get; private set; } = new List<Stmt>();
        public bool BodyEmpty { get; set; }
        public uint Size { get; set; }
        public Stmt BodyFront { get; set; }
        public Stmt BodyBack { get; set; }
        public SourceLocation LBracLoc { get; set; }
        public SourceLocation RBracLoc { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitCompoundStmt(this);
    }

    public abstract partial class SwitchCase : Stmt
    {
        public SwitchCase()
        {
        }

        public SourceLocation KeywordLoc { get; set; }
        public SourceLocation ColonLoc { get; set; }
        public Stmt SubStmt { get; set; }
    }

    public partial class CaseStmt : SwitchCase
    {
        public CaseStmt()
        {
        }

        public SourceLocation CaseLoc { get; set; }
        public SourceLocation EllipsisLoc { get; set; }
        public Expr LHS { get; set; }
        public Expr RHS { get; set; }
        public bool CaseStmtIsGNURange { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitCaseStmt(this);
    }

    public partial class DefaultStmt : SwitchCase
    {
        public DefaultStmt()
        {
        }

        public SourceLocation DefaultLoc { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitDefaultStmt(this);
    }

    public partial class LabelStmt : Stmt
    {
        public LabelStmt()
        {
        }

        public SourceLocation IdentLoc { get; set; }
        public Stmt SubStmt { get; set; }
        public string Name { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitLabelStmt(this);
    }

    public partial class AttributedStmt : Stmt
    {
        public AttributedStmt()
        {
        }

        public SourceLocation AttrLoc { get; set; }
        public Stmt SubStmt { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitAttributedStmt(this);
    }

    public partial class IfStmt : Stmt
    {
        public IfStmt()
        {
        }

        public Expr Cond { get; set; }
        public Stmt Then { get; set; }
        public Stmt Else { get; set; }
        public Stmt Init { get; set; }
        public SourceLocation IfLoc { get; set; }
        public SourceLocation ElseLoc { get; set; }
        public bool Constexpr { get; set; }
        public bool HasInitStorage { get; set; }
        public bool HasVarStorage { get; set; }
        public bool HasElseStorage { get; set; }
        public DeclStmt ConditionVariableDeclStmt { get; set; }
        public bool IsObjCAvailabilityCheck { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitIfStmt(this);
    }

    public partial class SwitchStmt : Stmt
    {
        public SwitchStmt()
        {
        }

        public Expr Cond { get; set; }
        public Stmt Body { get; set; }
        public Stmt Init { get; set; }
        public SourceLocation SwitchLoc { get; set; }
        public bool HasInitStorage { get; set; }
        public bool HasVarStorage { get; set; }
        public DeclStmt ConditionVariableDeclStmt { get; set; }
        public bool IsAllEnumCasesCovered { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitSwitchStmt(this);
    }

    public partial class WhileStmt : Stmt
    {
        public WhileStmt()
        {
        }

        public Expr Cond { get; set; }
        public Stmt Body { get; set; }
        public SourceLocation WhileLoc { get; set; }
        public bool HasVarStorage { get; set; }
        public DeclStmt ConditionVariableDeclStmt { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitWhileStmt(this);
    }

    public partial class DoStmt : Stmt
    {
        public DoStmt()
        {
        }

        public Expr Cond { get; set; }
        public Stmt Body { get; set; }
        public SourceLocation DoLoc { get; set; }
        public SourceLocation WhileLoc { get; set; }
        public SourceLocation RParenLoc { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitDoStmt(this);
    }

    public partial class ForStmt : Stmt
    {
        public ForStmt()
        {
        }

        public Stmt Init { get; set; }
        public Expr Cond { get; set; }
        public Expr Inc { get; set; }
        public Stmt Body { get; set; }
        public SourceLocation ForLoc { get; set; }
        public SourceLocation LParenLoc { get; set; }
        public SourceLocation RParenLoc { get; set; }
        public DeclStmt ConditionVariableDeclStmt { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitForStmt(this);
    }

    public partial class GotoStmt : Stmt
    {
        public GotoStmt()
        {
        }

        public SourceLocation GotoLoc { get; set; }
        public SourceLocation LabelLoc { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitGotoStmt(this);
    }

    public partial class IndirectGotoStmt : Stmt
    {
        public IndirectGotoStmt()
        {
        }

        public SourceLocation GotoLoc { get; set; }
        public SourceLocation StarLoc { get; set; }
        public Expr Target { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitIndirectGotoStmt(this);
    }

    public partial class ContinueStmt : Stmt
    {
        public ContinueStmt()
        {
        }

        public SourceLocation ContinueLoc { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitContinueStmt(this);
    }

    public partial class BreakStmt : Stmt
    {
        public BreakStmt()
        {
        }

        public SourceLocation BreakLoc { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitBreakStmt(this);
    }

    public partial class ReturnStmt : Stmt
    {
        public ReturnStmt()
        {
        }

        public Expr RetValue { get; set; }
        public SourceLocation ReturnLoc { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitReturnStmt(this);
    }

    public abstract partial class AsmStmt : Stmt
    {
        public AsmStmt()
        {
        }

        public List<Expr> Inputs { get; private set; } = new List<Expr>();
        public List<Expr> Outputs { get; private set; } = new List<Expr>();
        public SourceLocation AsmLoc { get; set; }
        public bool Simple { get; set; }
        public bool Volatile { get; set; }
        public uint NumOutputs { get; set; }
        public uint NumPlusOperands { get; set; }
        public uint NumInputs { get; set; }
        public uint NumClobbers { get; set; }
    }

    public partial class GCCAsmStmt : AsmStmt
    {
        public partial class AsmStringPiece
        {
            public enum Kind
            {
                String = 0,
                Operand = 1
            }

            public AsmStringPiece()
            {
            }

            public bool IsString { get; set; }
            public bool IsOperand { get; set; }
            public string String { get; set; }
            public uint OperandNo { get; set; }
            public sbyte Modifier { get; set; }
        }

        public GCCAsmStmt()
        {
        }

        public SourceLocation RParenLoc { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitGCCAsmStmt(this);
    }

    public partial class MSAsmStmt : AsmStmt
    {
        public MSAsmStmt()
        {
        }

        public SourceLocation LBraceLoc { get; set; }
        public bool HasBraces { get; set; }
        public uint NumAsmToks { get; set; }
        public string AsmString { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitMSAsmStmt(this);
    }

    public partial class SEHExceptStmt : Stmt
    {
        public SEHExceptStmt()
        {
        }

        public SourceLocation ExceptLoc { get; set; }
        public Expr FilterExpr { get; set; }
        public CompoundStmt Block { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitSEHExceptStmt(this);
    }

    public partial class SEHFinallyStmt : Stmt
    {
        public SEHFinallyStmt()
        {
        }

        public SourceLocation FinallyLoc { get; set; }
        public CompoundStmt Block { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitSEHFinallyStmt(this);
    }

    public partial class SEHTryStmt : Stmt
    {
        public SEHTryStmt()
        {
        }

        public SourceLocation TryLoc { get; set; }
        public bool IsCXXTry { get; set; }
        public CompoundStmt TryBlock { get; set; }
        public Stmt Handler { get; set; }
        public SEHExceptStmt ExceptHandler { get; set; }
        public SEHFinallyStmt FinallyHandler { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitSEHTryStmt(this);
    }

    public partial class SEHLeaveStmt : Stmt
    {
        public SEHLeaveStmt()
        {
        }

        public SourceLocation LeaveLoc { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitSEHLeaveStmt(this);
    }

    public partial class CapturedStmt : Stmt
    {
        public enum VariableCaptureKind
        {
            This = 0,
            ByRef = 1,
            ByCopy = 2,
            VLAType = 3
        }

        public partial class Capture
        {
            public Capture()
            {
            }

            public CapturedStmt.VariableCaptureKind CaptureKind { get; set; }
            public SourceLocation Location { get; set; }
            public bool CapturesThis { get; set; }
            public bool CapturesVariable { get; set; }
            public bool CapturesVariableByCopy { get; set; }
            public bool CapturesVariableArrayType { get; set; }
        }

        public CapturedStmt()
        {
        }

        public List<Expr> CaptureInits { get; private set; } = new List<Expr>();
        public Stmt capturedStmt { get; set; }
        public uint CaptureSize { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitCapturedStmt(this);
    }

    public partial class CXXCatchStmt : Stmt
    {
        public CXXCatchStmt()
        {
        }

        public SourceLocation CatchLoc { get; set; }
        public QualifiedType CaughtType { get; set; }
        public Stmt HandlerBlock { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitCXXCatchStmt(this);
    }

    public partial class CXXTryStmt : Stmt
    {
        public CXXTryStmt()
        {
        }

        public SourceLocation TryLoc { get; set; }
        public CompoundStmt TryBlock { get; set; }
        public uint NumHandlers { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitCXXTryStmt(this);
    }

    public partial class CXXForRangeStmt : Stmt
    {
        public CXXForRangeStmt()
        {
        }

        public Stmt Init { get; set; }
        public Expr RangeInit { get; set; }
        public Expr Cond { get; set; }
        public Expr Inc { get; set; }
        public Stmt Body { get; set; }
        public DeclStmt RangeStmt { get; set; }
        public DeclStmt BeginStmt { get; set; }
        public DeclStmt EndStmt { get; set; }
        public DeclStmt LoopVarStmt { get; set; }
        public SourceLocation ForLoc { get; set; }
        public SourceLocation CoawaitLoc { get; set; }
        public SourceLocation ColonLoc { get; set; }
        public SourceLocation RParenLoc { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitCXXForRangeStmt(this);
    }

    public partial class MSDependentExistsStmt : Stmt
    {
        public MSDependentExistsStmt()
        {
        }

        public SourceLocation KeywordLoc { get; set; }
        public bool IsIfExists { get; set; }
        public bool IsIfNotExists { get; set; }
        public CompoundStmt SubStmt { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitMSDependentExistsStmt(this);
    }

    public partial class CoroutineBodyStmt : Stmt
    {
        internal enum SubStmt
        {
            /// <summary>The body of the coroutine.</summary>
            Body = 0,
            /// <summary>The promise statement.</summary>
            Promise = 1,
            /// <summary>The initial suspend statement, run before the body.</summary>
            InitSuspend = 2,
            /// <summary>The final suspend statement, run after the body.</summary>
            FinalSuspend = 3,
            /// <summary>Handler for exceptions thrown in the body.</summary>
            OnException = 4,
            /// <summary>Handler for control flow falling off the body.</summary>
            OnFallthrough = 5,
            /// <summary>Coroutine frame memory allocation.</summary>
            Allocate = 6,
            /// <summary>Coroutine frame memory deallocation.</summary>
            Deallocate = 7,
            /// <summary>Return value for thunk function: p.get_return_object().</summary>
            ReturnValue = 8,
            /// <summary>Declaration holding the result of get_return_object.</summary>
            ResultDecl = 9,
            /// <summary>Return statement for the thunk function.</summary>
            ReturnStmt = 10,
            /// <summary>Return statement if allocation failed.</summary>
            ReturnStmtOnAllocFailure = 11,
            /// <summary>First offset for move construction of parameter copies.</summary>
            FirstParamMove = 12
        }

        public partial class CtorArgs
        {
            public CtorArgs()
            {
            }

        }

        public CoroutineBodyStmt()
        {
        }

        public bool HasDependentPromiseType { get; set; }
        public Stmt Body { get; set; }
        public Stmt PromiseDeclStmt { get; set; }
        public Stmt InitSuspendStmt { get; set; }
        public Stmt FinalSuspendStmt { get; set; }
        public Stmt ExceptionHandler { get; set; }
        public Stmt FallthroughHandler { get; set; }
        public Expr Allocate { get; set; }
        public Expr Deallocate { get; set; }
        public Expr ReturnValueInit { get; set; }
        public Stmt ResultDecl { get; set; }
        public Stmt ReturnStmt { get; set; }
        public Stmt ReturnStmtOnAllocFailure { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitCoroutineBodyStmt(this);
    }

    public partial class CoreturnStmt : Stmt
    {
        internal enum SubStmt
        {
            Operand = 0,
            PromiseCall = 1,
            Count = 2
        }

        public CoreturnStmt()
        {
        }

        public bool IsImplicit { get; set; }
        public SourceLocation KeywordLoc { get; set; }
        public Expr Operand { get; set; }
        public Expr PromiseCall { get; set; }

        public override T Visit<T>(IStmtVisitor<T> visitor) =>
            visitor.VisitCoreturnStmt(this);
    }
}
