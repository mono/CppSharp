using System;
using System.Collections.Generic;
using System.Linq;
using CppSharp.AST;

namespace CppSharp.Generators
{
    /// <summary>
    /// Output generated by each backend generator.
    /// </summary>
    public class GeneratorOutput
    {
        /// <summary>
        /// Translation unit associated with output.
        /// </summary>
        public TranslationUnit TranslationUnit;

        /// <summary>
        /// Code generators with generated output.
        /// </summary>
        public List<CodeGenerator> Outputs;
    }

    /// <summary>
    /// Generators are the base class for each language backend.
    /// </summary>
    public abstract class Generator : IDisposable
    {
        public BindingContext Context { get; }

        protected readonly TypePrinter typePrinter;

        protected Generator(BindingContext context)
        {
            Context = context;
            typePrinter = Context.Options.GeneratorKind.CreateTypePrinter(context);
            CppSharp.AST.Type.TypePrinterDelegate += TypePrinterDelegate;
        }

        /// <summary>
        /// Called when a translation unit is generated.
        /// </summary>
        public Action<GeneratorOutput> OnUnitGenerated = delegate { };

        /// <summary>
        /// Setup any generator-specific passes here.
        /// </summary>
        public abstract bool SetupPasses();

        /// <summary>
        /// Setup any generator-specific processing here.
        /// </summary>
        public virtual void Process()
        {

        }

        /// <summary>
        /// Generates the outputs for the given translation units.
        /// </summary>
        /// <param name="units">The units to generate outputs for.</param>
        public abstract List<CodeGenerator> Generate(IEnumerable<TranslationUnit> units);

        /// <summary>
        /// Generates the outputs.
        /// </summary>
        public virtual List<GeneratorOutput> Generate()
        {
            var outputMode = Context.Options.GenerationOutputMode;

            // TODO: Remove this once file per module works for C++ backend
            if (!Context.Options.IsCSharpGenerator)
                outputMode = GenerationOutputMode.FilePerUnit;

            var outputs = new List<GeneratorOutput>();

            if (outputMode == GenerationOutputMode.FilePerModule)
            {
                foreach (var module in Context.Options.Modules)
                {
                    var output = GenerateModule(module);
                    if (output != null)
                    {
                        OnUnitGenerated(output);
                        outputs.Add(output);
                    }
                }
            }
            else
            {
                var units = Context.ASTContext.TranslationUnits.GetGenerated()
                    .Where(u => !u.IsSystemHeader).ToList();

                foreach (var unit in units)
                {
                    var output = GenerateUnit(unit);
                    if (output != null)
                    {
                        outputs.Add(output);
                        OnUnitGenerated(output);
                    }
                }

                var generateSystemModule = Context.Options.SystemModule != null &&
                    Context.Options.GeneratorKind == GeneratorKind.CSharp;
                if (generateSystemModule)
                {
                    var output = GenerateModule(Context.Options.SystemModule);
                    if (output != null)
                    {
                        OnUnitGenerated(output);
                        outputs.Add(output);
                    }
                }
            }

            return outputs;
        }

        public virtual GeneratorOutput GenerateUnit(TranslationUnit unit)
        {
            var codeGenerators = Generate(new[] { unit });
            if (codeGenerators.Count == 0)
                return null;

            foreach (var codeGen in codeGenerators)
            {
                codeGen.Process();
            }

            var output = new GeneratorOutput
            {
                TranslationUnit = unit,
                Outputs = codeGenerators
            };

            return output;
        }

        public virtual GeneratorOutput GenerateModule(Module module)
        {
            var generatedUnits = module.Units.GetGenerated().ToList();
            if (generatedUnits.Count == 0)
                return null;

            var output = new GeneratorOutput
            {
                TranslationUnit = new TranslationUnit
                {
                    FilePath = $"{module.LibraryName}.h",
                    Module = module
                },
                Outputs = Generate(generatedUnits)
            };

            output.Outputs[0].Process();

            return output;
        }

        protected virtual string TypePrinterDelegate(CppSharp.AST.Type type)
        {
            return type.Visit(typePrinter);
        }

        public static string GeneratedIdentifier(string id) =>
            $"__{(id.StartsWith("@") ? id.Substring(1) : id)}";

        public void Dispose()
        {
            CppSharp.AST.Type.TypePrinterDelegate -= TypePrinterDelegate;
        }
    }
}