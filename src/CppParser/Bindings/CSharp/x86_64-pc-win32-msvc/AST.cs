//----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
//----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace CppSharp
{
    namespace Parser
    {
        namespace AST
        {
            public enum TypeKind
            {
                Tag = 0,
                Array = 1,
                Function = 2,
                Pointer = 3,
                MemberPointer = 4,
                Typedef = 5,
                Attributed = 6,
                Decayed = 7,
                TemplateSpecialization = 8,
                TemplateParameter = 9,
                TemplateParameterSubstitution = 10,
                InjectedClassName = 11,
                DependentName = 12,
                PackExpansion = 13,
                Builtin = 14
            }

            public enum DeclarationKind
            {
                DeclarationContext = 0,
                Typedef = 1,
                TypeAlias = 2,
                Parameter = 3,
                Function = 4,
                Method = 5,
                Enumeration = 6,
                EnumerationItem = 7,
                Variable = 8,
                Field = 9,
                AccessSpecifier = 10,
                Class = 11,
                Template = 12,
                TypeAliasTemplate = 13,
                ClassTemplate = 14,
                ClassTemplateSpecialization = 15,
                ClassTemplatePartialSpecialization = 16,
                FunctionTemplate = 17,
                Namespace = 18,
                PreprocessedEntity = 19,
                MacroDefinition = 20,
                MacroExpansion = 21,
                TranslationUnit = 22,
                Friend = 23,
                TemplateTemplateParm = 24,
                TemplateTypeParm = 25,
                NonTypeTemplateParm = 26
            }

            public enum AccessSpecifier
            {
                Private = 0,
                Protected = 1,
                Public = 2
            }

            public enum RawCommentKind
            {
                Invalid = 0,
                OrdinaryBCPL = 1,
                OrdinaryC = 2,
                BCPLSlash = 3,
                BCPLExcl = 4,
                JavaDoc = 5,
                Qt = 6,
                Merged = 7
            }

            public enum CommentKind
            {
                FullComment = 0,
                BlockContentComment = 1,
                BlockCommandComment = 2,
                ParamCommandComment = 3,
                TParamCommandComment = 4,
                VerbatimBlockComment = 5,
                VerbatimLineComment = 6,
                ParagraphComment = 7,
                HTMLTagComment = 8,
                HTMLStartTagComment = 9,
                HTMLEndTagComment = 10,
                TextComment = 11,
                InlineContentComment = 12,
                InlineCommandComment = 13,
                VerbatimBlockLineComment = 14
            }

            public enum CppAbi
            {
                Itanium = 0,
                Microsoft = 1,
                ARM = 2,
                iOS = 3,
                iOS64 = 4
            }

            public enum VTableComponentKind
            {
                VCallOffset = 0,
                VBaseOffset = 1,
                OffsetToTop = 2,
                RTTI = 3,
                FunctionPointer = 4,
                CompleteDtorPointer = 5,
                DeletingDtorPointer = 6,
                UnusedFunctionPointer = 7
            }

            public enum CXXOperatorKind
            {
                None = 0,
                New = 1,
                Delete = 2,
                Array_New = 3,
                Array_Delete = 4,
                Plus = 5,
                Minus = 6,
                Star = 7,
                Slash = 8,
                Percent = 9,
                Caret = 10,
                Amp = 11,
                Pipe = 12,
                Tilde = 13,
                Exclaim = 14,
                Equal = 15,
                Less = 16,
                Greater = 17,
                PlusEqual = 18,
                MinusEqual = 19,
                StarEqual = 20,
                SlashEqual = 21,
                PercentEqual = 22,
                CaretEqual = 23,
                AmpEqual = 24,
                PipeEqual = 25,
                LessLess = 26,
                GreaterGreater = 27,
                LessLessEqual = 28,
                GreaterGreaterEqual = 29,
                EqualEqual = 30,
                ExclaimEqual = 31,
                LessEqual = 32,
                GreaterEqual = 33,
                AmpAmp = 34,
                PipePipe = 35,
                PlusPlus = 36,
                MinusMinus = 37,
                Comma = 38,
                ArrowStar = 39,
                Arrow = 40,
                Call = 41,
                Subscript = 42,
                Conditional = 43,
                Coawait = 44
            }

            public enum CallingConvention
            {
                Default = 0,
                C = 1,
                StdCall = 2,
                ThisCall = 3,
                FastCall = 4,
                Unknown = 5
            }

            public enum TemplateSpecializationKind
            {
                Undeclared = 0,
                ImplicitInstantiation = 1,
                ExplicitSpecialization = 2,
                ExplicitInstantiationDeclaration = 3,
                ExplicitInstantiationDefinition = 4
            }

            public enum StatementClass
            {
                Any = 0,
                BinaryOperator = 1,
                CallExprClass = 2,
                DeclRefExprClass = 3,
                CXXConstructExprClass = 4,
                CXXOperatorCallExpr = 5,
                ImplicitCastExpr = 6,
                ExplicitCastExpr = 7
            }

            public enum CXXMethodKind
            {
                Normal = 0,
                Constructor = 1,
                Destructor = 2,
                Conversion = 3,
                Operator = 4,
                UsingDirective = 5
            }

            public enum PrimitiveType
            {
                Null = 0,
                Void = 1,
                Bool = 2,
                WideChar = 3,
                Char = 4,
                UChar = 5,
                Short = 6,
                UShort = 7,
                Int = 8,
                UInt = 9,
                Long = 10,
                ULong = 11,
                LongLong = 12,
                ULongLong = 13,
                Float = 14,
                Double = 15,
                LongDouble = 16,
                IntPtr = 17
            }

            public enum MacroLocation
            {
                Unknown = 0,
                ClassHead = 1,
                ClassBody = 2,
                FunctionHead = 3,
                FunctionParameters = 4,
                FunctionBody = 5
            }

            public enum ArchType
            {
                UnknownArch = 0,
                x86 = 1,
                x86_64 = 2
            }

            public unsafe partial class Type : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 8)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public CppSharp.Parser.AST.TypeKind Kind;

                    [FieldOffset(4)]
                    public byte IsDependent;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0Type@AST@CppParser@CppSharp@@QEAA@W4TypeKind@123@@Z")]
                    internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance, CppSharp.Parser.AST.TypeKind kind);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0Type@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                protected int __PointerAdjustment;
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, Type> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, Type>();
                protected void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                public static Type __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new Type(native.ToPointer(), skipVTables);
                }

                public static Type __CreateInstance(Type.Internal native, bool skipVTables = false)
                {
                    return new Type(native, skipVTables);
                }

                private static void* __CopyValue(Type.Internal native)
                {
                    var ret = Marshal.AllocHGlobal(8);
                    CppSharp.Parser.AST.Type.Internal.cctor_1(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private Type(Type.Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected Type(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public Type(CppSharp.Parser.AST.TypeKind kind)
                {
                    __Instance = Marshal.AllocHGlobal(8);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    var __arg0 = kind;
                    Internal.ctor_0((__Instance + __PointerAdjustment), __arg0);
                }

                public Type(CppSharp.Parser.AST.Type _0)
                {
                    __Instance = Marshal.AllocHGlobal(8);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    CppSharp.Parser.AST.Type __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public CppSharp.Parser.AST.TypeKind Kind
                {
                    get
                    {
                        return ((Internal*) __Instance)->Kind;
                    }

                    set
                    {
                        ((Internal*) __Instance)->Kind = value;
                    }
                }

                public bool IsDependent
                {
                    get
                    {
                        return ((Internal*) __Instance)->IsDependent != 0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->IsDependent = (byte) (value ? 1 : 0);
                    }
                }
            }

            public unsafe partial class TypeQualifiers : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 3)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public byte IsConst;

                    [FieldOffset(1)]
                    public byte IsVolatile;

                    [FieldOffset(2)]
                    public byte IsRestrict;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0TypeQualifiers@AST@CppParser@CppSharp@@QEAA@AEBU0123@@Z")]
                    internal static extern global::System.IntPtr cctor_0(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                protected int __PointerAdjustment;
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, TypeQualifiers> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, TypeQualifiers>();
                protected void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                public static TypeQualifiers __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new TypeQualifiers(native.ToPointer(), skipVTables);
                }

                public static TypeQualifiers __CreateInstance(TypeQualifiers.Internal native, bool skipVTables = false)
                {
                    return new TypeQualifiers(native, skipVTables);
                }

                private static void* __CopyValue(TypeQualifiers.Internal native)
                {
                    var ret = Marshal.AllocHGlobal(3);
                    *(TypeQualifiers.Internal*) ret = native;
                    return ret.ToPointer();
                }

                private TypeQualifiers(TypeQualifiers.Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected TypeQualifiers(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public TypeQualifiers(CppSharp.Parser.AST.TypeQualifiers _0)
                {
                    __Instance = Marshal.AllocHGlobal(3);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((TypeQualifiers.Internal*) __Instance) = *((TypeQualifiers.Internal*) _0.__Instance);
                }

                public TypeQualifiers()
                {
                    __Instance = Marshal.AllocHGlobal(3);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    CppSharp.Parser.AST.TypeQualifiers __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public bool IsConst
                {
                    get
                    {
                        return ((Internal*) __Instance)->IsConst != 0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->IsConst = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsVolatile
                {
                    get
                    {
                        return ((Internal*) __Instance)->IsVolatile != 0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->IsVolatile = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsRestrict
                {
                    get
                    {
                        return ((Internal*) __Instance)->IsRestrict != 0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->IsRestrict = (byte) (value ? 1 : 0);
                    }
                }
            }

            public unsafe partial class QualifiedType : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 16)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public global::System.IntPtr Type;

                    [FieldOffset(8)]
                    public CppSharp.Parser.AST.TypeQualifiers.Internal Qualifiers;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0QualifiedType@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0QualifiedType@AST@CppParser@CppSharp@@QEAA@AEBU0123@@Z")]
                    internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                protected int __PointerAdjustment;
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, QualifiedType> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, QualifiedType>();
                protected void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                public static QualifiedType __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new QualifiedType(native.ToPointer(), skipVTables);
                }

                public static QualifiedType __CreateInstance(QualifiedType.Internal native, bool skipVTables = false)
                {
                    return new QualifiedType(native, skipVTables);
                }

                private static void* __CopyValue(QualifiedType.Internal native)
                {
                    var ret = Marshal.AllocHGlobal(16);
                    *(QualifiedType.Internal*) ret = native;
                    return ret.ToPointer();
                }

                private QualifiedType(QualifiedType.Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected QualifiedType(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public QualifiedType()
                {
                    __Instance = Marshal.AllocHGlobal(16);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_0((__Instance + __PointerAdjustment));
                }

                public QualifiedType(CppSharp.Parser.AST.QualifiedType _0)
                {
                    __Instance = Marshal.AllocHGlobal(16);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((QualifiedType.Internal*) __Instance) = *((QualifiedType.Internal*) _0.__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    CppSharp.Parser.AST.QualifiedType __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public CppSharp.Parser.AST.Type Type
                {
                    get
                    {
                        CppSharp.Parser.AST.Type __result0;
                        if (((Internal*) __Instance)->Type == IntPtr.Zero) __result0 = null;
                        else if (CppSharp.Parser.AST.Type.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->Type))
                            __result0 = (CppSharp.Parser.AST.Type) CppSharp.Parser.AST.Type.NativeToManagedMap[((Internal*) __Instance)->Type];
                        else __result0 = CppSharp.Parser.AST.Type.__CreateInstance(((Internal*) __Instance)->Type);
                        return __result0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->Type = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public CppSharp.Parser.AST.TypeQualifiers Qualifiers
                {
                    get
                    {
                        return CppSharp.Parser.AST.TypeQualifiers.__CreateInstance(((Internal*) __Instance)->Qualifiers);
                    }

                    set
                    {
                        ((Internal*) __Instance)->Qualifiers = ReferenceEquals(value, null) ? new CppSharp.Parser.AST.TypeQualifiers.Internal() : *(CppSharp.Parser.AST.TypeQualifiers.Internal*) (value.__Instance);
                    }
                }
            }

            public unsafe partial class TagType : CppSharp.Parser.AST.Type, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 16)]
                public new partial struct Internal
                {
                    [FieldOffset(0)]
                    public CppSharp.Parser.AST.TypeKind Kind;

                    [FieldOffset(4)]
                    public byte IsDependent;

                    [FieldOffset(8)]
                    public global::System.IntPtr Declaration;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0TagType@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0TagType@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public static new TagType __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new TagType(native.ToPointer(), skipVTables);
                }

                public static TagType __CreateInstance(TagType.Internal native, bool skipVTables = false)
                {
                    return new TagType(native, skipVTables);
                }

                private static void* __CopyValue(TagType.Internal native)
                {
                    var ret = Marshal.AllocHGlobal(16);
                    CppSharp.Parser.AST.TagType.Internal.cctor_2(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private TagType(TagType.Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected TagType(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public TagType()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(16);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_0((__Instance + __PointerAdjustment));
                }

                public TagType(CppSharp.Parser.AST.TagType _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(16);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    Internal.cctor_2((__Instance + __PointerAdjustment), __arg0);
                }

                public CppSharp.Parser.AST.Declaration Declaration
                {
                    get
                    {
                        CppSharp.Parser.AST.Declaration __result0;
                        if (((Internal*) __Instance)->Declaration == IntPtr.Zero) __result0 = null;
                        else if (CppSharp.Parser.AST.Declaration.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->Declaration))
                            __result0 = (CppSharp.Parser.AST.Declaration) CppSharp.Parser.AST.Declaration.NativeToManagedMap[((Internal*) __Instance)->Declaration];
                        else __result0 = CppSharp.Parser.AST.Declaration.__CreateInstance(((Internal*) __Instance)->Declaration);
                        return __result0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->Declaration = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }
            }

            public unsafe partial class ArrayType : CppSharp.Parser.AST.Type, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 40)]
                public new partial struct Internal
                {
                    [FieldOffset(0)]
                    public CppSharp.Parser.AST.TypeKind Kind;

                    [FieldOffset(4)]
                    public byte IsDependent;

                    [FieldOffset(8)]
                    public CppSharp.Parser.AST.QualifiedType.Internal QualifiedType;

                    [FieldOffset(24)]
                    public CppSharp.Parser.AST.ArrayType.ArraySize SizeType;

                    [FieldOffset(28)]
                    public int Size;

                    [FieldOffset(32)]
                    public int ElementSize;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0ArrayType@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0ArrayType@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public enum ArraySize
                {
                    Constant = 0,
                    Variable = 1,
                    Dependent = 2,
                    Incomplete = 3
                }

                public static new ArrayType __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new ArrayType(native.ToPointer(), skipVTables);
                }

                public static ArrayType __CreateInstance(ArrayType.Internal native, bool skipVTables = false)
                {
                    return new ArrayType(native, skipVTables);
                }

                private static void* __CopyValue(ArrayType.Internal native)
                {
                    var ret = Marshal.AllocHGlobal(40);
                    CppSharp.Parser.AST.ArrayType.Internal.cctor_2(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private ArrayType(ArrayType.Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected ArrayType(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public ArrayType()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(40);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_0((__Instance + __PointerAdjustment));
                }

                public ArrayType(CppSharp.Parser.AST.ArrayType _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(40);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    Internal.cctor_2((__Instance + __PointerAdjustment), __arg0);
                }

                public CppSharp.Parser.AST.QualifiedType QualifiedType
                {
                    get
                    {
                        return CppSharp.Parser.AST.QualifiedType.__CreateInstance(((Internal*) __Instance)->QualifiedType);
                    }

                    set
                    {
                        ((Internal*) __Instance)->QualifiedType = ReferenceEquals(value, null) ? new CppSharp.Parser.AST.QualifiedType.Internal() : *(CppSharp.Parser.AST.QualifiedType.Internal*) (value.__Instance);
                    }
                }

                public CppSharp.Parser.AST.ArrayType.ArraySize SizeType
                {
                    get
                    {
                        return ((Internal*) __Instance)->SizeType;
                    }

                    set
                    {
                        ((Internal*) __Instance)->SizeType = value;
                    }
                }

                public int Size
                {
                    get
                    {
                        return ((Internal*) __Instance)->Size;
                    }

                    set
                    {
                        ((Internal*) __Instance)->Size = value;
                    }
                }

                public int ElementSize
                {
                    get
                    {
                        return ((Internal*) __Instance)->ElementSize;
                    }

                    set
                    {
                        ((Internal*) __Instance)->ElementSize = value;
                    }
                }
            }

            public unsafe partial class FunctionType : CppSharp.Parser.AST.Type, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 56)]
                public new partial struct Internal
                {
                    [FieldOffset(0)]
                    public CppSharp.Parser.AST.TypeKind Kind;

                    [FieldOffset(4)]
                    public byte IsDependent;

                    [FieldOffset(8)]
                    public CppSharp.Parser.AST.QualifiedType.Internal ReturnType;

                    [FieldOffset(24)]
                    public CppSharp.Parser.AST.CallingConvention CallingConvention;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0FunctionType@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0FunctionType@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1FunctionType@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor_0(global::System.IntPtr instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getParameters@FunctionType@AST@CppParser@CppSharp@@QEAAPEAVParameter@234@I@Z")]
                    internal static extern global::System.IntPtr getParameters_0(global::System.IntPtr instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?addParameters@FunctionType@AST@CppParser@CppSharp@@QEAAXAEAPEAVParameter@234@@Z")]
                    internal static extern void addParameters_0(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?clearParameters@FunctionType@AST@CppParser@CppSharp@@QEAAXXZ")]
                    internal static extern void clearParameters_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getParametersCount@FunctionType@AST@CppParser@CppSharp@@QEAAIXZ")]
                    internal static extern uint getParametersCount_0(global::System.IntPtr instance);
                }

                public static new FunctionType __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new FunctionType(native.ToPointer(), skipVTables);
                }

                public static FunctionType __CreateInstance(FunctionType.Internal native, bool skipVTables = false)
                {
                    return new FunctionType(native, skipVTables);
                }

                private static void* __CopyValue(FunctionType.Internal native)
                {
                    var ret = Marshal.AllocHGlobal(56);
                    CppSharp.Parser.AST.FunctionType.Internal.cctor_1(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private FunctionType(FunctionType.Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected FunctionType(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public FunctionType()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(56);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_0((__Instance + __PointerAdjustment));
                }

                public FunctionType(CppSharp.Parser.AST.FunctionType _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(56);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
                }

                protected override void Dispose(bool disposing)
                {
                    CppSharp.Parser.AST.Type __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    Internal.dtor_0((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public CppSharp.Parser.AST.Parameter getParameters(uint i)
                {
                    var __ret = Internal.getParameters_0((__Instance + __PointerAdjustment), i);
                    CppSharp.Parser.AST.Parameter __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (CppSharp.Parser.AST.Parameter.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (CppSharp.Parser.AST.Parameter) CppSharp.Parser.AST.Parameter.NativeToManagedMap[__ret];
                    else __result0 = CppSharp.Parser.AST.Parameter.__CreateInstance(__ret);
                    return __result0;
                }

                public void addParameters(CppSharp.Parser.AST.Parameter s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    Internal.addParameters_0((__Instance + __PointerAdjustment), __arg0);
                }

                public void clearParameters()
                {
                    Internal.clearParameters_0((__Instance + __PointerAdjustment));
                }

                public uint ParametersCount
                {
                    get
                    {
                        var __ret = Internal.getParametersCount_0((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                public CppSharp.Parser.AST.QualifiedType ReturnType
                {
                    get
                    {
                        return CppSharp.Parser.AST.QualifiedType.__CreateInstance(((Internal*) __Instance)->ReturnType);
                    }

                    set
                    {
                        ((Internal*) __Instance)->ReturnType = ReferenceEquals(value, null) ? new CppSharp.Parser.AST.QualifiedType.Internal() : *(CppSharp.Parser.AST.QualifiedType.Internal*) (value.__Instance);
                    }
                }

                public CppSharp.Parser.AST.CallingConvention CallingConvention
                {
                    get
                    {
                        return ((Internal*) __Instance)->CallingConvention;
                    }

                    set
                    {
                        ((Internal*) __Instance)->CallingConvention = value;
                    }
                }
            }

            public unsafe partial class PointerType : CppSharp.Parser.AST.Type, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 32)]
                public new partial struct Internal
                {
                    [FieldOffset(0)]
                    public CppSharp.Parser.AST.TypeKind Kind;

                    [FieldOffset(4)]
                    public byte IsDependent;

                    [FieldOffset(8)]
                    public CppSharp.Parser.AST.QualifiedType.Internal QualifiedPointee;

                    [FieldOffset(24)]
                    public CppSharp.Parser.AST.PointerType.TypeModifier Modifier;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0PointerType@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0PointerType@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public enum TypeModifier
                {
                    Value = 0,
                    Pointer = 1,
                    LVReference = 2,
                    RVReference = 3
                }

                public static new PointerType __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new PointerType(native.ToPointer(), skipVTables);
                }

                public static PointerType __CreateInstance(PointerType.Internal native, bool skipVTables = false)
                {
                    return new PointerType(native, skipVTables);
                }

                private static void* __CopyValue(PointerType.Internal native)
                {
                    var ret = Marshal.AllocHGlobal(32);
                    CppSharp.Parser.AST.PointerType.Internal.cctor_2(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private PointerType(PointerType.Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected PointerType(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public PointerType()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(32);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_0((__Instance + __PointerAdjustment));
                }

                public PointerType(CppSharp.Parser.AST.PointerType _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(32);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    Internal.cctor_2((__Instance + __PointerAdjustment), __arg0);
                }

                public CppSharp.Parser.AST.QualifiedType QualifiedPointee
                {
                    get
                    {
                        return CppSharp.Parser.AST.QualifiedType.__CreateInstance(((Internal*) __Instance)->QualifiedPointee);
                    }

                    set
                    {
                        ((Internal*) __Instance)->QualifiedPointee = ReferenceEquals(value, null) ? new CppSharp.Parser.AST.QualifiedType.Internal() : *(CppSharp.Parser.AST.QualifiedType.Internal*) (value.__Instance);
                    }
                }

                public CppSharp.Parser.AST.PointerType.TypeModifier Modifier
                {
                    get
                    {
                        return ((Internal*) __Instance)->Modifier;
                    }

                    set
                    {
                        ((Internal*) __Instance)->Modifier = value;
                    }
                }
            }

            public unsafe partial class MemberPointerType : CppSharp.Parser.AST.Type, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 24)]
                public new partial struct Internal
                {
                    [FieldOffset(0)]
                    public CppSharp.Parser.AST.TypeKind Kind;

                    [FieldOffset(4)]
                    public byte IsDependent;

                    [FieldOffset(8)]
                    public CppSharp.Parser.AST.QualifiedType.Internal Pointee;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0MemberPointerType@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0MemberPointerType@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public static new MemberPointerType __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new MemberPointerType(native.ToPointer(), skipVTables);
                }

                public static MemberPointerType __CreateInstance(MemberPointerType.Internal native, bool skipVTables = false)
                {
                    return new MemberPointerType(native, skipVTables);
                }

                private static void* __CopyValue(MemberPointerType.Internal native)
                {
                    var ret = Marshal.AllocHGlobal(24);
                    CppSharp.Parser.AST.MemberPointerType.Internal.cctor_2(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private MemberPointerType(MemberPointerType.Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected MemberPointerType(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public MemberPointerType()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(24);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_0((__Instance + __PointerAdjustment));
                }

                public MemberPointerType(CppSharp.Parser.AST.MemberPointerType _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(24);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    Internal.cctor_2((__Instance + __PointerAdjustment), __arg0);
                }

                public CppSharp.Parser.AST.QualifiedType Pointee
                {
                    get
                    {
                        return CppSharp.Parser.AST.QualifiedType.__CreateInstance(((Internal*) __Instance)->Pointee);
                    }

                    set
                    {
                        ((Internal*) __Instance)->Pointee = ReferenceEquals(value, null) ? new CppSharp.Parser.AST.QualifiedType.Internal() : *(CppSharp.Parser.AST.QualifiedType.Internal*) (value.__Instance);
                    }
                }
            }

            public unsafe partial class TypedefType : CppSharp.Parser.AST.Type, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 16)]
                public new partial struct Internal
                {
                    [FieldOffset(0)]
                    public CppSharp.Parser.AST.TypeKind Kind;

                    [FieldOffset(4)]
                    public byte IsDependent;

                    [FieldOffset(8)]
                    public global::System.IntPtr Declaration;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0TypedefType@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0TypedefType@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public static new TypedefType __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new TypedefType(native.ToPointer(), skipVTables);
                }

                public static TypedefType __CreateInstance(TypedefType.Internal native, bool skipVTables = false)
                {
                    return new TypedefType(native, skipVTables);
                }

                private static void* __CopyValue(TypedefType.Internal native)
                {
                    var ret = Marshal.AllocHGlobal(16);
                    CppSharp.Parser.AST.TypedefType.Internal.cctor_2(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private TypedefType(TypedefType.Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected TypedefType(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public TypedefType()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(16);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_0((__Instance + __PointerAdjustment));
                }

                public TypedefType(CppSharp.Parser.AST.TypedefType _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(16);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    Internal.cctor_2((__Instance + __PointerAdjustment), __arg0);
                }

                public CppSharp.Parser.AST.TypedefNameDecl Declaration
                {
                    get
                    {
                        CppSharp.Parser.AST.TypedefNameDecl __result0;
                        if (((Internal*) __Instance)->Declaration == IntPtr.Zero) __result0 = null;
                        else if (CppSharp.Parser.AST.TypedefNameDecl.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->Declaration))
                            __result0 = (CppSharp.Parser.AST.TypedefNameDecl) CppSharp.Parser.AST.TypedefNameDecl.NativeToManagedMap[((Internal*) __Instance)->Declaration];
                        else __result0 = CppSharp.Parser.AST.TypedefNameDecl.__CreateInstance(((Internal*) __Instance)->Declaration);
                        return __result0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->Declaration = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }
            }

            public unsafe partial class AttributedType : CppSharp.Parser.AST.Type, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 40)]
                public new partial struct Internal
                {
                    [FieldOffset(0)]
                    public CppSharp.Parser.AST.TypeKind Kind;

                    [FieldOffset(4)]
                    public byte IsDependent;

                    [FieldOffset(8)]
                    public CppSharp.Parser.AST.QualifiedType.Internal Modified;

                    [FieldOffset(24)]
                    public CppSharp.Parser.AST.QualifiedType.Internal Equivalent;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0AttributedType@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0AttributedType@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public static new AttributedType __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new AttributedType(native.ToPointer(), skipVTables);
                }

                public static AttributedType __CreateInstance(AttributedType.Internal native, bool skipVTables = false)
                {
                    return new AttributedType(native, skipVTables);
                }

                private static void* __CopyValue(AttributedType.Internal native)
                {
                    var ret = Marshal.AllocHGlobal(40);
                    CppSharp.Parser.AST.AttributedType.Internal.cctor_2(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private AttributedType(AttributedType.Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected AttributedType(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public AttributedType()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(40);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_0((__Instance + __PointerAdjustment));
                }

                public AttributedType(CppSharp.Parser.AST.AttributedType _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(40);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    Internal.cctor_2((__Instance + __PointerAdjustment), __arg0);
                }

                public CppSharp.Parser.AST.QualifiedType Modified
                {
                    get
                    {
                        return CppSharp.Parser.AST.QualifiedType.__CreateInstance(((Internal*) __Instance)->Modified);
                    }

                    set
                    {
                        ((Internal*) __Instance)->Modified = ReferenceEquals(value, null) ? new CppSharp.Parser.AST.QualifiedType.Internal() : *(CppSharp.Parser.AST.QualifiedType.Internal*) (value.__Instance);
                    }
                }

                public CppSharp.Parser.AST.QualifiedType Equivalent
                {
                    get
                    {
                        return CppSharp.Parser.AST.QualifiedType.__CreateInstance(((Internal*) __Instance)->Equivalent);
                    }

                    set
                    {
                        ((Internal*) __Instance)->Equivalent = ReferenceEquals(value, null) ? new CppSharp.Parser.AST.QualifiedType.Internal() : *(CppSharp.Parser.AST.QualifiedType.Internal*) (value.__Instance);
                    }
                }
            }

            public unsafe partial class DecayedType : CppSharp.Parser.AST.Type, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 56)]
                public new partial struct Internal
                {
                    [FieldOffset(0)]
                    public CppSharp.Parser.AST.TypeKind Kind;

                    [FieldOffset(4)]
                    public byte IsDependent;

                    [FieldOffset(8)]
                    public CppSharp.Parser.AST.QualifiedType.Internal Decayed;

                    [FieldOffset(24)]
                    public CppSharp.Parser.AST.QualifiedType.Internal Original;

                    [FieldOffset(40)]
                    public CppSharp.Parser.AST.QualifiedType.Internal Pointee;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0DecayedType@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0DecayedType@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public static new DecayedType __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new DecayedType(native.ToPointer(), skipVTables);
                }

                public static DecayedType __CreateInstance(DecayedType.Internal native, bool skipVTables = false)
                {
                    return new DecayedType(native, skipVTables);
                }

                private static void* __CopyValue(DecayedType.Internal native)
                {
                    var ret = Marshal.AllocHGlobal(56);
                    CppSharp.Parser.AST.DecayedType.Internal.cctor_2(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private DecayedType(DecayedType.Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected DecayedType(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public DecayedType()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(56);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_0((__Instance + __PointerAdjustment));
                }

                public DecayedType(CppSharp.Parser.AST.DecayedType _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(56);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    Internal.cctor_2((__Instance + __PointerAdjustment), __arg0);
                }

                public CppSharp.Parser.AST.QualifiedType Decayed
                {
                    get
                    {
                        return CppSharp.Parser.AST.QualifiedType.__CreateInstance(((Internal*) __Instance)->Decayed);
                    }

                    set
                    {
                        ((Internal*) __Instance)->Decayed = ReferenceEquals(value, null) ? new CppSharp.Parser.AST.QualifiedType.Internal() : *(CppSharp.Parser.AST.QualifiedType.Internal*) (value.__Instance);
                    }
                }

                public CppSharp.Parser.AST.QualifiedType Original
                {
                    get
                    {
                        return CppSharp.Parser.AST.QualifiedType.__CreateInstance(((Internal*) __Instance)->Original);
                    }

                    set
                    {
                        ((Internal*) __Instance)->Original = ReferenceEquals(value, null) ? new CppSharp.Parser.AST.QualifiedType.Internal() : *(CppSharp.Parser.AST.QualifiedType.Internal*) (value.__Instance);
                    }
                }

                public CppSharp.Parser.AST.QualifiedType Pointee
                {
                    get
                    {
                        return CppSharp.Parser.AST.QualifiedType.__CreateInstance(((Internal*) __Instance)->Pointee);
                    }

                    set
                    {
                        ((Internal*) __Instance)->Pointee = ReferenceEquals(value, null) ? new CppSharp.Parser.AST.QualifiedType.Internal() : *(CppSharp.Parser.AST.QualifiedType.Internal*) (value.__Instance);
                    }
                }
            }

            public unsafe partial class TemplateArgument : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 40)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public CppSharp.Parser.AST.TemplateArgument.ArgumentKind Kind;

                    [FieldOffset(8)]
                    public CppSharp.Parser.AST.QualifiedType.Internal Type;

                    [FieldOffset(24)]
                    public global::System.IntPtr Declaration;

                    [FieldOffset(32)]
                    public int Integral;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0TemplateArgument@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0TemplateArgument@AST@CppParser@CppSharp@@QEAA@AEBU0123@@Z")]
                    internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public enum ArgumentKind
                {
                    Type = 0,
                    Declaration = 1,
                    NullPtr = 2,
                    Integral = 3,
                    Template = 4,
                    TemplateExpansion = 5,
                    Expression = 6,
                    Pack = 7
                }

                public global::System.IntPtr __Instance { get; protected set; }

                protected int __PointerAdjustment;
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, TemplateArgument> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, TemplateArgument>();
                protected void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                public static TemplateArgument __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new TemplateArgument(native.ToPointer(), skipVTables);
                }

                public static TemplateArgument __CreateInstance(TemplateArgument.Internal native, bool skipVTables = false)
                {
                    return new TemplateArgument(native, skipVTables);
                }

                private static void* __CopyValue(TemplateArgument.Internal native)
                {
                    var ret = Marshal.AllocHGlobal(40);
                    *(TemplateArgument.Internal*) ret = native;
                    return ret.ToPointer();
                }

                private TemplateArgument(TemplateArgument.Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected TemplateArgument(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public TemplateArgument()
                {
                    __Instance = Marshal.AllocHGlobal(40);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_0((__Instance + __PointerAdjustment));
                }

                public TemplateArgument(CppSharp.Parser.AST.TemplateArgument _0)
                {
                    __Instance = Marshal.AllocHGlobal(40);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((TemplateArgument.Internal*) __Instance) = *((TemplateArgument.Internal*) _0.__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    CppSharp.Parser.AST.TemplateArgument __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public CppSharp.Parser.AST.TemplateArgument.ArgumentKind Kind
                {
                    get
                    {
                        return ((Internal*) __Instance)->Kind;
                    }

                    set
                    {
                        ((Internal*) __Instance)->Kind = value;
                    }
                }

                public CppSharp.Parser.AST.QualifiedType Type
                {
                    get
                    {
                        return CppSharp.Parser.AST.QualifiedType.__CreateInstance(((Internal*) __Instance)->Type);
                    }

                    set
                    {
                        ((Internal*) __Instance)->Type = ReferenceEquals(value, null) ? new CppSharp.Parser.AST.QualifiedType.Internal() : *(CppSharp.Parser.AST.QualifiedType.Internal*) (value.__Instance);
                    }
                }

                public CppSharp.Parser.AST.Declaration Declaration
                {
                    get
                    {
                        CppSharp.Parser.AST.Declaration __result0;
                        if (((Internal*) __Instance)->Declaration == IntPtr.Zero) __result0 = null;
                        else if (CppSharp.Parser.AST.Declaration.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->Declaration))
                            __result0 = (CppSharp.Parser.AST.Declaration) CppSharp.Parser.AST.Declaration.NativeToManagedMap[((Internal*) __Instance)->Declaration];
                        else __result0 = CppSharp.Parser.AST.Declaration.__CreateInstance(((Internal*) __Instance)->Declaration);
                        return __result0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->Declaration = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public int Integral
                {
                    get
                    {
                        return ((Internal*) __Instance)->Integral;
                    }

                    set
                    {
                        ((Internal*) __Instance)->Integral = value;
                    }
                }
            }

            public unsafe partial class TemplateSpecializationType : CppSharp.Parser.AST.Type, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 48)]
                public new partial struct Internal
                {
                    [FieldOffset(0)]
                    public CppSharp.Parser.AST.TypeKind Kind;

                    [FieldOffset(4)]
                    public byte IsDependent;

                    [FieldOffset(32)]
                    public global::System.IntPtr Template;

                    [FieldOffset(40)]
                    public global::System.IntPtr Desugared;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0TemplateSpecializationType@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0TemplateSpecializationType@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1TemplateSpecializationType@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor_0(global::System.IntPtr instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getArguments@TemplateSpecializationType@AST@CppParser@CppSharp@@QEAA?AUTemplateArgument@234@I@Z")]
                    internal static extern void getArguments_0(global::System.IntPtr instance, global::System.IntPtr @return, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?addArguments@TemplateSpecializationType@AST@CppParser@CppSharp@@QEAAXAEAUTemplateArgument@234@@Z")]
                    internal static extern void addArguments_0(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?clearArguments@TemplateSpecializationType@AST@CppParser@CppSharp@@QEAAXXZ")]
                    internal static extern void clearArguments_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getArgumentsCount@TemplateSpecializationType@AST@CppParser@CppSharp@@QEAAIXZ")]
                    internal static extern uint getArgumentsCount_0(global::System.IntPtr instance);
                }

                public static new TemplateSpecializationType __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new TemplateSpecializationType(native.ToPointer(), skipVTables);
                }

                public static TemplateSpecializationType __CreateInstance(TemplateSpecializationType.Internal native, bool skipVTables = false)
                {
                    return new TemplateSpecializationType(native, skipVTables);
                }

                private static void* __CopyValue(TemplateSpecializationType.Internal native)
                {
                    var ret = Marshal.AllocHGlobal(48);
                    CppSharp.Parser.AST.TemplateSpecializationType.Internal.cctor_1(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private TemplateSpecializationType(TemplateSpecializationType.Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected TemplateSpecializationType(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public TemplateSpecializationType()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(48);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_0((__Instance + __PointerAdjustment));
                }

                public TemplateSpecializationType(CppSharp.Parser.AST.TemplateSpecializationType _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(48);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
                }

                protected override void Dispose(bool disposing)
                {
                    CppSharp.Parser.AST.Type __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    Internal.dtor_0((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public CppSharp.Parser.AST.TemplateArgument getArguments(uint i)
                {
                    var __ret = new CppSharp.Parser.AST.TemplateArgument.Internal();
                    Internal.getArguments_0((__Instance + __PointerAdjustment), new IntPtr(&__ret), i);
                    return CppSharp.Parser.AST.TemplateArgument.__CreateInstance(__ret);
                }

                public void addArguments(CppSharp.Parser.AST.TemplateArgument s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    Internal.addArguments_0((__Instance + __PointerAdjustment), __arg0);
                }

                public void clearArguments()
                {
                    Internal.clearArguments_0((__Instance + __PointerAdjustment));
                }

                public uint ArgumentsCount
                {
                    get
                    {
                        var __ret = Internal.getArgumentsCount_0((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                public CppSharp.Parser.AST.Template Template
                {
                    get
                    {
                        CppSharp.Parser.AST.Template __result0;
                        if (((Internal*) __Instance)->Template == IntPtr.Zero) __result0 = null;
                        else if (CppSharp.Parser.AST.Template.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->Template))
                            __result0 = (CppSharp.Parser.AST.Template) CppSharp.Parser.AST.Template.NativeToManagedMap[((Internal*) __Instance)->Template];
                        else __result0 = CppSharp.Parser.AST.Template.__CreateInstance(((Internal*) __Instance)->Template);
                        return __result0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->Template = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public CppSharp.Parser.AST.Type Desugared
                {
                    get
                    {
                        CppSharp.Parser.AST.Type __result0;
                        if (((Internal*) __Instance)->Desugared == IntPtr.Zero) __result0 = null;
                        else if (CppSharp.Parser.AST.Type.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->Desugared))
                            __result0 = (CppSharp.Parser.AST.Type) CppSharp.Parser.AST.Type.NativeToManagedMap[((Internal*) __Instance)->Desugared];
                        else __result0 = CppSharp.Parser.AST.Type.__CreateInstance(((Internal*) __Instance)->Desugared);
                        return __result0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->Desugared = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }
            }

            public unsafe partial class TemplateParameterType : CppSharp.Parser.AST.Type, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 32)]
                public new partial struct Internal
                {
                    [FieldOffset(0)]
                    public CppSharp.Parser.AST.TypeKind Kind;

                    [FieldOffset(4)]
                    public byte IsDependent;

                    [FieldOffset(8)]
                    public global::System.IntPtr Parameter;

                    [FieldOffset(16)]
                    public uint Depth;

                    [FieldOffset(20)]
                    public uint Index;

                    [FieldOffset(24)]
                    public byte IsParameterPack;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0TemplateParameterType@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0TemplateParameterType@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1TemplateParameterType@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor_0(global::System.IntPtr instance, int delete);
                }

                public static new TemplateParameterType __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new TemplateParameterType(native.ToPointer(), skipVTables);
                }

                public static TemplateParameterType __CreateInstance(TemplateParameterType.Internal native, bool skipVTables = false)
                {
                    return new TemplateParameterType(native, skipVTables);
                }

                private static void* __CopyValue(TemplateParameterType.Internal native)
                {
                    var ret = Marshal.AllocHGlobal(32);
                    CppSharp.Parser.AST.TemplateParameterType.Internal.cctor_1(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private TemplateParameterType(TemplateParameterType.Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected TemplateParameterType(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public TemplateParameterType()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(32);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_0((__Instance + __PointerAdjustment));
                }

                public TemplateParameterType(CppSharp.Parser.AST.TemplateParameterType _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(32);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
                }

                protected override void Dispose(bool disposing)
                {
                    CppSharp.Parser.AST.Type __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    Internal.dtor_0((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public CppSharp.Parser.AST.TypeTemplateParameter Parameter
                {
                    get
                    {
                        CppSharp.Parser.AST.TypeTemplateParameter __result0;
                        if (((Internal*) __Instance)->Parameter == IntPtr.Zero) __result0 = null;
                        else if (CppSharp.Parser.AST.TypeTemplateParameter.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->Parameter))
                            __result0 = (CppSharp.Parser.AST.TypeTemplateParameter) CppSharp.Parser.AST.TypeTemplateParameter.NativeToManagedMap[((Internal*) __Instance)->Parameter];
                        else __result0 = CppSharp.Parser.AST.TypeTemplateParameter.__CreateInstance(((Internal*) __Instance)->Parameter);
                        return __result0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->Parameter = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public uint Depth
                {
                    get
                    {
                        return ((Internal*) __Instance)->Depth;
                    }

                    set
                    {
                        ((Internal*) __Instance)->Depth = value;
                    }
                }

                public uint Index
                {
                    get
                    {
                        return ((Internal*) __Instance)->Index;
                    }

                    set
                    {
                        ((Internal*) __Instance)->Index = value;
                    }
                }

                public bool IsParameterPack
                {
                    get
                    {
                        return ((Internal*) __Instance)->IsParameterPack != 0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->IsParameterPack = (byte) (value ? 1 : 0);
                    }
                }
            }

            public unsafe partial class TemplateParameterSubstitutionType : CppSharp.Parser.AST.Type, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 24)]
                public new partial struct Internal
                {
                    [FieldOffset(0)]
                    public CppSharp.Parser.AST.TypeKind Kind;

                    [FieldOffset(4)]
                    public byte IsDependent;

                    [FieldOffset(8)]
                    public CppSharp.Parser.AST.QualifiedType.Internal Replacement;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0TemplateParameterSubstitutionType@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0TemplateParameterSubstitutionType@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public static new TemplateParameterSubstitutionType __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new TemplateParameterSubstitutionType(native.ToPointer(), skipVTables);
                }

                public static TemplateParameterSubstitutionType __CreateInstance(TemplateParameterSubstitutionType.Internal native, bool skipVTables = false)
                {
                    return new TemplateParameterSubstitutionType(native, skipVTables);
                }

                private static void* __CopyValue(TemplateParameterSubstitutionType.Internal native)
                {
                    var ret = Marshal.AllocHGlobal(24);
                    CppSharp.Parser.AST.TemplateParameterSubstitutionType.Internal.cctor_2(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private TemplateParameterSubstitutionType(TemplateParameterSubstitutionType.Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected TemplateParameterSubstitutionType(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public TemplateParameterSubstitutionType()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(24);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_0((__Instance + __PointerAdjustment));
                }

                public TemplateParameterSubstitutionType(CppSharp.Parser.AST.TemplateParameterSubstitutionType _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(24);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    Internal.cctor_2((__Instance + __PointerAdjustment), __arg0);
                }

                public CppSharp.Parser.AST.QualifiedType Replacement
                {
                    get
                    {
                        return CppSharp.Parser.AST.QualifiedType.__CreateInstance(((Internal*) __Instance)->Replacement);
                    }

                    set
                    {
                        ((Internal*) __Instance)->Replacement = ReferenceEquals(value, null) ? new CppSharp.Parser.AST.QualifiedType.Internal() : *(CppSharp.Parser.AST.QualifiedType.Internal*) (value.__Instance);
                    }
                }
            }

            public unsafe partial class InjectedClassNameType : CppSharp.Parser.AST.Type, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 32)]
                public new partial struct Internal
                {
                    [FieldOffset(0)]
                    public CppSharp.Parser.AST.TypeKind Kind;

                    [FieldOffset(4)]
                    public byte IsDependent;

                    [FieldOffset(8)]
                    public CppSharp.Parser.AST.QualifiedType.Internal InjectedSpecializationType;

                    [FieldOffset(24)]
                    public global::System.IntPtr Class;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0InjectedClassNameType@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0InjectedClassNameType@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public static new InjectedClassNameType __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new InjectedClassNameType(native.ToPointer(), skipVTables);
                }

                public static InjectedClassNameType __CreateInstance(InjectedClassNameType.Internal native, bool skipVTables = false)
                {
                    return new InjectedClassNameType(native, skipVTables);
                }

                private static void* __CopyValue(InjectedClassNameType.Internal native)
                {
                    var ret = Marshal.AllocHGlobal(32);
                    CppSharp.Parser.AST.InjectedClassNameType.Internal.cctor_2(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private InjectedClassNameType(InjectedClassNameType.Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected InjectedClassNameType(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public InjectedClassNameType()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(32);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_0((__Instance + __PointerAdjustment));
                }

                public InjectedClassNameType(CppSharp.Parser.AST.InjectedClassNameType _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(32);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    Internal.cctor_2((__Instance + __PointerAdjustment), __arg0);
                }

                public CppSharp.Parser.AST.QualifiedType InjectedSpecializationType
                {
                    get
                    {
                        return CppSharp.Parser.AST.QualifiedType.__CreateInstance(((Internal*) __Instance)->InjectedSpecializationType);
                    }

                    set
                    {
                        ((Internal*) __Instance)->InjectedSpecializationType = ReferenceEquals(value, null) ? new CppSharp.Parser.AST.QualifiedType.Internal() : *(CppSharp.Parser.AST.QualifiedType.Internal*) (value.__Instance);
                    }
                }

                public CppSharp.Parser.AST.Class Class
                {
                    get
                    {
                        CppSharp.Parser.AST.Class __result0;
                        if (((Internal*) __Instance)->Class == IntPtr.Zero) __result0 = null;
                        else if (CppSharp.Parser.AST.Class.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->Class))
                            __result0 = (CppSharp.Parser.AST.Class) CppSharp.Parser.AST.Class.NativeToManagedMap[((Internal*) __Instance)->Class];
                        else __result0 = CppSharp.Parser.AST.Class.__CreateInstance(((Internal*) __Instance)->Class);
                        return __result0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->Class = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }
            }

            public unsafe partial class DependentNameType : CppSharp.Parser.AST.Type, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 8)]
                public new partial struct Internal
                {
                    [FieldOffset(0)]
                    public CppSharp.Parser.AST.TypeKind Kind;

                    [FieldOffset(4)]
                    public byte IsDependent;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0DependentNameType@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0DependentNameType@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public static new DependentNameType __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new DependentNameType(native.ToPointer(), skipVTables);
                }

                public static DependentNameType __CreateInstance(DependentNameType.Internal native, bool skipVTables = false)
                {
                    return new DependentNameType(native, skipVTables);
                }

                private static void* __CopyValue(DependentNameType.Internal native)
                {
                    var ret = Marshal.AllocHGlobal(8);
                    CppSharp.Parser.AST.DependentNameType.Internal.cctor_2(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private DependentNameType(DependentNameType.Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected DependentNameType(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public DependentNameType()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(8);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_0((__Instance + __PointerAdjustment));
                }

                public DependentNameType(CppSharp.Parser.AST.DependentNameType _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(8);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    Internal.cctor_2((__Instance + __PointerAdjustment), __arg0);
                }
            }

            public unsafe partial class PackExpansionType : CppSharp.Parser.AST.Type, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 8)]
                public new partial struct Internal
                {
                    [FieldOffset(0)]
                    public CppSharp.Parser.AST.TypeKind Kind;

                    [FieldOffset(4)]
                    public byte IsDependent;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0PackExpansionType@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0PackExpansionType@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public static new PackExpansionType __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new PackExpansionType(native.ToPointer(), skipVTables);
                }

                public static PackExpansionType __CreateInstance(PackExpansionType.Internal native, bool skipVTables = false)
                {
                    return new PackExpansionType(native, skipVTables);
                }

                private static void* __CopyValue(PackExpansionType.Internal native)
                {
                    var ret = Marshal.AllocHGlobal(8);
                    CppSharp.Parser.AST.PackExpansionType.Internal.cctor_2(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private PackExpansionType(PackExpansionType.Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected PackExpansionType(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public PackExpansionType()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(8);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_0((__Instance + __PointerAdjustment));
                }

                public PackExpansionType(CppSharp.Parser.AST.PackExpansionType _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(8);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    Internal.cctor_2((__Instance + __PointerAdjustment), __arg0);
                }
            }

            public unsafe partial class BuiltinType : CppSharp.Parser.AST.Type, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 12)]
                public new partial struct Internal
                {
                    [FieldOffset(0)]
                    public CppSharp.Parser.AST.TypeKind Kind;

                    [FieldOffset(4)]
                    public byte IsDependent;

                    [FieldOffset(8)]
                    public CppSharp.Parser.AST.PrimitiveType Type;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0BuiltinType@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0BuiltinType@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public static new BuiltinType __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new BuiltinType(native.ToPointer(), skipVTables);
                }

                public static BuiltinType __CreateInstance(BuiltinType.Internal native, bool skipVTables = false)
                {
                    return new BuiltinType(native, skipVTables);
                }

                private static void* __CopyValue(BuiltinType.Internal native)
                {
                    var ret = Marshal.AllocHGlobal(12);
                    CppSharp.Parser.AST.BuiltinType.Internal.cctor_2(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private BuiltinType(BuiltinType.Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected BuiltinType(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public BuiltinType()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(12);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_0((__Instance + __PointerAdjustment));
                }

                public BuiltinType(CppSharp.Parser.AST.BuiltinType _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(12);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    Internal.cctor_2((__Instance + __PointerAdjustment), __arg0);
                }

                public CppSharp.Parser.AST.PrimitiveType Type
                {
                    get
                    {
                        return ((Internal*) __Instance)->Type;
                    }

                    set
                    {
                        ((Internal*) __Instance)->Type = value;
                    }
                }
            }

            public unsafe partial class VTableComponent : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 16)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public CppSharp.Parser.AST.VTableComponentKind Kind;

                    [FieldOffset(4)]
                    public uint Offset;

                    [FieldOffset(8)]
                    public global::System.IntPtr Declaration;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0VTableComponent@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0VTableComponent@AST@CppParser@CppSharp@@QEAA@AEBU0123@@Z")]
                    internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                protected int __PointerAdjustment;
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, VTableComponent> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, VTableComponent>();
                protected void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                public static VTableComponent __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new VTableComponent(native.ToPointer(), skipVTables);
                }

                public static VTableComponent __CreateInstance(VTableComponent.Internal native, bool skipVTables = false)
                {
                    return new VTableComponent(native, skipVTables);
                }

                private static void* __CopyValue(VTableComponent.Internal native)
                {
                    var ret = Marshal.AllocHGlobal(16);
                    *(VTableComponent.Internal*) ret = native;
                    return ret.ToPointer();
                }

                private VTableComponent(VTableComponent.Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected VTableComponent(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public VTableComponent()
                {
                    __Instance = Marshal.AllocHGlobal(16);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_0((__Instance + __PointerAdjustment));
                }

                public VTableComponent(CppSharp.Parser.AST.VTableComponent _0)
                {
                    __Instance = Marshal.AllocHGlobal(16);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((VTableComponent.Internal*) __Instance) = *((VTableComponent.Internal*) _0.__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    CppSharp.Parser.AST.VTableComponent __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public CppSharp.Parser.AST.VTableComponentKind Kind
                {
                    get
                    {
                        return ((Internal*) __Instance)->Kind;
                    }

                    set
                    {
                        ((Internal*) __Instance)->Kind = value;
                    }
                }

                public uint Offset
                {
                    get
                    {
                        return ((Internal*) __Instance)->Offset;
                    }

                    set
                    {
                        ((Internal*) __Instance)->Offset = value;
                    }
                }

                public CppSharp.Parser.AST.Declaration Declaration
                {
                    get
                    {
                        CppSharp.Parser.AST.Declaration __result0;
                        if (((Internal*) __Instance)->Declaration == IntPtr.Zero) __result0 = null;
                        else if (CppSharp.Parser.AST.Declaration.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->Declaration))
                            __result0 = (CppSharp.Parser.AST.Declaration) CppSharp.Parser.AST.Declaration.NativeToManagedMap[((Internal*) __Instance)->Declaration];
                        else __result0 = CppSharp.Parser.AST.Declaration.__CreateInstance(((Internal*) __Instance)->Declaration);
                        return __result0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->Declaration = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }
            }

            public unsafe partial class VTableLayout : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 24)]
                public partial struct Internal
                {
                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0VTableLayout@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0VTableLayout@AST@CppParser@CppSharp@@QEAA@AEBU0123@@Z")]
                    internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1VTableLayout@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor_0(global::System.IntPtr instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getComponents@VTableLayout@AST@CppParser@CppSharp@@QEAA?AUVTableComponent@234@I@Z")]
                    internal static extern void getComponents_0(global::System.IntPtr instance, global::System.IntPtr @return, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?addComponents@VTableLayout@AST@CppParser@CppSharp@@QEAAXAEAUVTableComponent@234@@Z")]
                    internal static extern void addComponents_0(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?clearComponents@VTableLayout@AST@CppParser@CppSharp@@QEAAXXZ")]
                    internal static extern void clearComponents_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getComponentsCount@VTableLayout@AST@CppParser@CppSharp@@QEAAIXZ")]
                    internal static extern uint getComponentsCount_0(global::System.IntPtr instance);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                protected int __PointerAdjustment;
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, VTableLayout> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, VTableLayout>();
                protected void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                public static VTableLayout __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new VTableLayout(native.ToPointer(), skipVTables);
                }

                public static VTableLayout __CreateInstance(VTableLayout.Internal native, bool skipVTables = false)
                {
                    return new VTableLayout(native, skipVTables);
                }

                private static void* __CopyValue(VTableLayout.Internal native)
                {
                    var ret = Marshal.AllocHGlobal(24);
                    CppSharp.Parser.AST.VTableLayout.Internal.cctor_1(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private VTableLayout(VTableLayout.Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected VTableLayout(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public VTableLayout()
                {
                    __Instance = Marshal.AllocHGlobal(24);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_0((__Instance + __PointerAdjustment));
                }

                public VTableLayout(CppSharp.Parser.AST.VTableLayout _0)
                {
                    __Instance = Marshal.AllocHGlobal(24);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    CppSharp.Parser.AST.VTableLayout __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    Internal.dtor_0((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public CppSharp.Parser.AST.VTableComponent getComponents(uint i)
                {
                    var __ret = new CppSharp.Parser.AST.VTableComponent.Internal();
                    Internal.getComponents_0((__Instance + __PointerAdjustment), new IntPtr(&__ret), i);
                    return CppSharp.Parser.AST.VTableComponent.__CreateInstance(__ret);
                }

                public void addComponents(CppSharp.Parser.AST.VTableComponent s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    Internal.addComponents_0((__Instance + __PointerAdjustment), __arg0);
                }

                public void clearComponents()
                {
                    Internal.clearComponents_0((__Instance + __PointerAdjustment));
                }

                public uint ComponentsCount
                {
                    get
                    {
                        var __ret = Internal.getComponentsCount_0((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }
            }

            public unsafe partial class VFTableInfo : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 40)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public ulong VBTableIndex;

                    [FieldOffset(8)]
                    public uint VFPtrOffset;

                    [FieldOffset(12)]
                    public uint VFPtrFullOffset;

                    [FieldOffset(16)]
                    public CppSharp.Parser.AST.VTableLayout.Internal Layout;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0VFTableInfo@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0VFTableInfo@AST@CppParser@CppSharp@@QEAA@AEBU0123@@Z")]
                    internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1VFTableInfo@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor_0(global::System.IntPtr instance, int delete);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                protected int __PointerAdjustment;
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, VFTableInfo> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, VFTableInfo>();
                protected void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                public static VFTableInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new VFTableInfo(native.ToPointer(), skipVTables);
                }

                public static VFTableInfo __CreateInstance(VFTableInfo.Internal native, bool skipVTables = false)
                {
                    return new VFTableInfo(native, skipVTables);
                }

                private static void* __CopyValue(VFTableInfo.Internal native)
                {
                    var ret = Marshal.AllocHGlobal(40);
                    CppSharp.Parser.AST.VFTableInfo.Internal.cctor_1(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private VFTableInfo(VFTableInfo.Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected VFTableInfo(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public VFTableInfo()
                {
                    __Instance = Marshal.AllocHGlobal(40);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_0((__Instance + __PointerAdjustment));
                }

                public VFTableInfo(CppSharp.Parser.AST.VFTableInfo _0)
                {
                    __Instance = Marshal.AllocHGlobal(40);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    CppSharp.Parser.AST.VFTableInfo __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    Internal.dtor_0((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public ulong VBTableIndex
                {
                    get
                    {
                        return ((Internal*) __Instance)->VBTableIndex;
                    }

                    set
                    {
                        ((Internal*) __Instance)->VBTableIndex = value;
                    }
                }

                public uint VFPtrOffset
                {
                    get
                    {
                        return ((Internal*) __Instance)->VFPtrOffset;
                    }

                    set
                    {
                        ((Internal*) __Instance)->VFPtrOffset = value;
                    }
                }

                public uint VFPtrFullOffset
                {
                    get
                    {
                        return ((Internal*) __Instance)->VFPtrFullOffset;
                    }

                    set
                    {
                        ((Internal*) __Instance)->VFPtrFullOffset = value;
                    }
                }

                public CppSharp.Parser.AST.VTableLayout Layout
                {
                    get
                    {
                        return CppSharp.Parser.AST.VTableLayout.__CreateInstance(((Internal*) __Instance)->Layout);
                    }

                    set
                    {
                        ((Internal*) __Instance)->Layout = ReferenceEquals(value, null) ? new CppSharp.Parser.AST.VTableLayout.Internal() : *(CppSharp.Parser.AST.VTableLayout.Internal*) (value.__Instance);
                    }
                }
            }

            public unsafe partial class LayoutField : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 64)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public uint Offset;

                    [FieldOffset(40)]
                    public CppSharp.Parser.AST.QualifiedType.Internal QualifiedType;

                    [FieldOffset(56)]
                    public global::System.IntPtr FieldPtr;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0LayoutField@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0LayoutField@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr other);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1LayoutField@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor_0(global::System.IntPtr instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getName@LayoutField@AST@CppParser@CppSharp@@QEAAPEBDXZ")]
                    internal static extern global::System.IntPtr getName_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?setName@LayoutField@AST@CppParser@CppSharp@@QEAAXPEBD@Z")]
                    internal static extern void setName_0(global::System.IntPtr instance, global::System.IntPtr s);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                protected int __PointerAdjustment;
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, LayoutField> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, LayoutField>();
                protected void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                public static LayoutField __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new LayoutField(native.ToPointer(), skipVTables);
                }

                public static LayoutField __CreateInstance(LayoutField.Internal native, bool skipVTables = false)
                {
                    return new LayoutField(native, skipVTables);
                }

                private static void* __CopyValue(LayoutField.Internal native)
                {
                    var ret = Marshal.AllocHGlobal(64);
                    CppSharp.Parser.AST.LayoutField.Internal.cctor_1(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private LayoutField(LayoutField.Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected LayoutField(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public LayoutField()
                {
                    __Instance = Marshal.AllocHGlobal(64);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_0((__Instance + __PointerAdjustment));
                }

                public LayoutField(CppSharp.Parser.AST.LayoutField other)
                {
                    __Instance = Marshal.AllocHGlobal(64);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(other, null))
                        throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = other.__Instance;
                    Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    CppSharp.Parser.AST.LayoutField __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    Internal.dtor_0((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public string Name
                {
                    get
                    {
                        var __ret = Internal.getName_0((__Instance + __PointerAdjustment));
                        return Marshal.PtrToStringAnsi(__ret);
                    }

                    set
                    {
                        var __arg0 = Marshal.StringToHGlobalAnsi(value);
                        Internal.setName_0((__Instance + __PointerAdjustment), __arg0);
                        Marshal.FreeHGlobal(__arg0);
                    }
                }

                public uint Offset
                {
                    get
                    {
                        return ((Internal*) __Instance)->Offset;
                    }

                    set
                    {
                        ((Internal*) __Instance)->Offset = value;
                    }
                }

                public CppSharp.Parser.AST.QualifiedType QualifiedType
                {
                    get
                    {
                        return CppSharp.Parser.AST.QualifiedType.__CreateInstance(((Internal*) __Instance)->QualifiedType);
                    }

                    set
                    {
                        ((Internal*) __Instance)->QualifiedType = ReferenceEquals(value, null) ? new CppSharp.Parser.AST.QualifiedType.Internal() : *(CppSharp.Parser.AST.QualifiedType.Internal*) (value.__Instance);
                    }
                }

                public global::System.IntPtr FieldPtr
                {
                    get
                    {
                        return ((Internal*) __Instance)->FieldPtr;
                    }

                    set
                    {
                        ((Internal*) __Instance)->FieldPtr = (global::System.IntPtr) value;
                    }
                }
            }

            public unsafe partial class LayoutBase : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 16)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public uint Offset;

                    [FieldOffset(8)]
                    public global::System.IntPtr Class;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0LayoutBase@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0LayoutBase@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr other);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1LayoutBase@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor_0(global::System.IntPtr instance, int delete);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                protected int __PointerAdjustment;
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, LayoutBase> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, LayoutBase>();
                protected void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                public static LayoutBase __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new LayoutBase(native.ToPointer(), skipVTables);
                }

                public static LayoutBase __CreateInstance(LayoutBase.Internal native, bool skipVTables = false)
                {
                    return new LayoutBase(native, skipVTables);
                }

                private static void* __CopyValue(LayoutBase.Internal native)
                {
                    var ret = Marshal.AllocHGlobal(16);
                    CppSharp.Parser.AST.LayoutBase.Internal.cctor_1(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private LayoutBase(LayoutBase.Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected LayoutBase(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public LayoutBase()
                {
                    __Instance = Marshal.AllocHGlobal(16);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_0((__Instance + __PointerAdjustment));
                }

                public LayoutBase(CppSharp.Parser.AST.LayoutBase other)
                {
                    __Instance = Marshal.AllocHGlobal(16);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(other, null))
                        throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = other.__Instance;
                    Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    CppSharp.Parser.AST.LayoutBase __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    Internal.dtor_0((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public uint Offset
                {
                    get
                    {
                        return ((Internal*) __Instance)->Offset;
                    }

                    set
                    {
                        ((Internal*) __Instance)->Offset = value;
                    }
                }

                public CppSharp.Parser.AST.Class Class
                {
                    get
                    {
                        CppSharp.Parser.AST.Class __result0;
                        if (((Internal*) __Instance)->Class == IntPtr.Zero) __result0 = null;
                        else if (CppSharp.Parser.AST.Class.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->Class))
                            __result0 = (CppSharp.Parser.AST.Class) CppSharp.Parser.AST.Class.NativeToManagedMap[((Internal*) __Instance)->Class];
                        else __result0 = CppSharp.Parser.AST.Class.__CreateInstance(((Internal*) __Instance)->Class);
                        return __result0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->Class = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }
            }

            public unsafe partial class ClassLayout : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 128)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public CppSharp.Parser.AST.CppAbi ABI;

                    [FieldOffset(32)]
                    public CppSharp.Parser.AST.VTableLayout.Internal Layout;

                    [FieldOffset(56)]
                    public byte HasOwnVFPtr;

                    [FieldOffset(60)]
                    public int VBPtrOffset;

                    [FieldOffset(64)]
                    public int Alignment;

                    [FieldOffset(68)]
                    public int Size;

                    [FieldOffset(72)]
                    public int DataSize;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0ClassLayout@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0ClassLayout@AST@CppParser@CppSharp@@QEAA@AEBU0123@@Z")]
                    internal static extern global::System.IntPtr cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1ClassLayout@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor_0(global::System.IntPtr instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getVFTables@ClassLayout@AST@CppParser@CppSharp@@QEAA?AUVFTableInfo@234@I@Z")]
                    internal static extern void getVFTables_0(global::System.IntPtr instance, global::System.IntPtr @return, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?addVFTables@ClassLayout@AST@CppParser@CppSharp@@QEAAXAEAUVFTableInfo@234@@Z")]
                    internal static extern void addVFTables_0(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?clearVFTables@ClassLayout@AST@CppParser@CppSharp@@QEAAXXZ")]
                    internal static extern void clearVFTables_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getFields@ClassLayout@AST@CppParser@CppSharp@@QEAA?AVLayoutField@234@I@Z")]
                    internal static extern void getFields_0(global::System.IntPtr instance, global::System.IntPtr @return, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?addFields@ClassLayout@AST@CppParser@CppSharp@@QEAAXAEAVLayoutField@234@@Z")]
                    internal static extern void addFields_0(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?clearFields@ClassLayout@AST@CppParser@CppSharp@@QEAAXXZ")]
                    internal static extern void clearFields_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getBases@ClassLayout@AST@CppParser@CppSharp@@QEAA?AVLayoutBase@234@I@Z")]
                    internal static extern void getBases_0(global::System.IntPtr instance, global::System.IntPtr @return, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?addBases@ClassLayout@AST@CppParser@CppSharp@@QEAAXAEAVLayoutBase@234@@Z")]
                    internal static extern void addBases_0(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?clearBases@ClassLayout@AST@CppParser@CppSharp@@QEAAXXZ")]
                    internal static extern void clearBases_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getVFTablesCount@ClassLayout@AST@CppParser@CppSharp@@QEAAIXZ")]
                    internal static extern uint getVFTablesCount_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getFieldsCount@ClassLayout@AST@CppParser@CppSharp@@QEAAIXZ")]
                    internal static extern uint getFieldsCount_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getBasesCount@ClassLayout@AST@CppParser@CppSharp@@QEAAIXZ")]
                    internal static extern uint getBasesCount_0(global::System.IntPtr instance);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                protected int __PointerAdjustment;
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ClassLayout> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ClassLayout>();
                protected void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                public static ClassLayout __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new ClassLayout(native.ToPointer(), skipVTables);
                }

                public static ClassLayout __CreateInstance(ClassLayout.Internal native, bool skipVTables = false)
                {
                    return new ClassLayout(native, skipVTables);
                }

                private static void* __CopyValue(ClassLayout.Internal native)
                {
                    var ret = Marshal.AllocHGlobal(128);
                    CppSharp.Parser.AST.ClassLayout.Internal.cctor_2(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private ClassLayout(ClassLayout.Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected ClassLayout(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public ClassLayout()
                {
                    __Instance = Marshal.AllocHGlobal(128);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_0((__Instance + __PointerAdjustment));
                }

                public ClassLayout(CppSharp.Parser.AST.ClassLayout _0)
                {
                    __Instance = Marshal.AllocHGlobal(128);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    Internal.cctor_2((__Instance + __PointerAdjustment), __arg0);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    CppSharp.Parser.AST.ClassLayout __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    Internal.dtor_0((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public CppSharp.Parser.AST.VFTableInfo getVFTables(uint i)
                {
                    var __ret = new CppSharp.Parser.AST.VFTableInfo.Internal();
                    Internal.getVFTables_0((__Instance + __PointerAdjustment), new IntPtr(&__ret), i);
                    return CppSharp.Parser.AST.VFTableInfo.__CreateInstance(__ret);
                }

                public void addVFTables(CppSharp.Parser.AST.VFTableInfo s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    Internal.addVFTables_0((__Instance + __PointerAdjustment), __arg0);
                }

                public void clearVFTables()
                {
                    Internal.clearVFTables_0((__Instance + __PointerAdjustment));
                }

                public CppSharp.Parser.AST.LayoutField getFields(uint i)
                {
                    var __ret = new CppSharp.Parser.AST.LayoutField.Internal();
                    Internal.getFields_0((__Instance + __PointerAdjustment), new IntPtr(&__ret), i);
                    return CppSharp.Parser.AST.LayoutField.__CreateInstance(__ret);
                }

                public void addFields(CppSharp.Parser.AST.LayoutField s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    Internal.addFields_0((__Instance + __PointerAdjustment), __arg0);
                }

                public void clearFields()
                {
                    Internal.clearFields_0((__Instance + __PointerAdjustment));
                }

                public CppSharp.Parser.AST.LayoutBase getBases(uint i)
                {
                    var __ret = new CppSharp.Parser.AST.LayoutBase.Internal();
                    Internal.getBases_0((__Instance + __PointerAdjustment), new IntPtr(&__ret), i);
                    return CppSharp.Parser.AST.LayoutBase.__CreateInstance(__ret);
                }

                public void addBases(CppSharp.Parser.AST.LayoutBase s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    Internal.addBases_0((__Instance + __PointerAdjustment), __arg0);
                }

                public void clearBases()
                {
                    Internal.clearBases_0((__Instance + __PointerAdjustment));
                }

                public uint VFTablesCount
                {
                    get
                    {
                        var __ret = Internal.getVFTablesCount_0((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                public uint FieldsCount
                {
                    get
                    {
                        var __ret = Internal.getFieldsCount_0((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                public uint BasesCount
                {
                    get
                    {
                        var __ret = Internal.getBasesCount_0((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                public CppSharp.Parser.AST.CppAbi ABI
                {
                    get
                    {
                        return ((Internal*) __Instance)->ABI;
                    }

                    set
                    {
                        ((Internal*) __Instance)->ABI = value;
                    }
                }

                public CppSharp.Parser.AST.VTableLayout Layout
                {
                    get
                    {
                        return CppSharp.Parser.AST.VTableLayout.__CreateInstance(((Internal*) __Instance)->Layout);
                    }

                    set
                    {
                        ((Internal*) __Instance)->Layout = ReferenceEquals(value, null) ? new CppSharp.Parser.AST.VTableLayout.Internal() : *(CppSharp.Parser.AST.VTableLayout.Internal*) (value.__Instance);
                    }
                }

                public bool HasOwnVFPtr
                {
                    get
                    {
                        return ((Internal*) __Instance)->HasOwnVFPtr != 0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->HasOwnVFPtr = (byte) (value ? 1 : 0);
                    }
                }

                public int VBPtrOffset
                {
                    get
                    {
                        return ((Internal*) __Instance)->VBPtrOffset;
                    }

                    set
                    {
                        ((Internal*) __Instance)->VBPtrOffset = value;
                    }
                }

                public int Alignment
                {
                    get
                    {
                        return ((Internal*) __Instance)->Alignment;
                    }

                    set
                    {
                        ((Internal*) __Instance)->Alignment = value;
                    }
                }

                public int Size
                {
                    get
                    {
                        return ((Internal*) __Instance)->Size;
                    }

                    set
                    {
                        ((Internal*) __Instance)->Size = value;
                    }
                }

                public int DataSize
                {
                    get
                    {
                        return ((Internal*) __Instance)->DataSize;
                    }

                    set
                    {
                        ((Internal*) __Instance)->DataSize = value;
                    }
                }
            }

            public unsafe partial class Declaration : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 192)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public CppSharp.Parser.AST.DeclarationKind Kind;

                    [FieldOffset(4)]
                    public CppSharp.Parser.AST.AccessSpecifier Access;

                    [FieldOffset(8)]
                    public global::System.IntPtr _Namespace;

                    [FieldOffset(16)]
                    public CppSharp.Parser.SourceLocation.Internal Location;

                    [FieldOffset(20)]
                    public int LineNumberStart;

                    [FieldOffset(24)]
                    public int LineNumberEnd;

                    [FieldOffset(128)]
                    public byte IsIncomplete;

                    [FieldOffset(129)]
                    public byte IsDependent;

                    [FieldOffset(130)]
                    public byte IsImplicit;

                    [FieldOffset(136)]
                    public global::System.IntPtr CompleteDeclaration;

                    [FieldOffset(144)]
                    public uint DefinitionOrder;

                    [FieldOffset(176)]
                    public global::System.IntPtr OriginalPtr;

                    [FieldOffset(184)]
                    public global::System.IntPtr Comment;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0Declaration@AST@CppParser@CppSharp@@QEAA@W4DeclarationKind@123@@Z")]
                    internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance, CppSharp.Parser.AST.DeclarationKind kind);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0Declaration@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1Declaration@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor_0(global::System.IntPtr instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getPreprocessedEntities@Declaration@AST@CppParser@CppSharp@@QEAAPEAVPreprocessedEntity@234@I@Z")]
                    internal static extern global::System.IntPtr getPreprocessedEntities_0(global::System.IntPtr instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?addPreprocessedEntities@Declaration@AST@CppParser@CppSharp@@QEAAXAEAPEAVPreprocessedEntity@234@@Z")]
                    internal static extern void addPreprocessedEntities_0(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?clearPreprocessedEntities@Declaration@AST@CppParser@CppSharp@@QEAAXXZ")]
                    internal static extern void clearPreprocessedEntities_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getName@Declaration@AST@CppParser@CppSharp@@QEAAPEBDXZ")]
                    internal static extern global::System.IntPtr getName_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?setName@Declaration@AST@CppParser@CppSharp@@QEAAXPEBD@Z")]
                    internal static extern void setName_0(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getUSR@Declaration@AST@CppParser@CppSharp@@QEAAPEBDXZ")]
                    internal static extern global::System.IntPtr getUSR_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?setUSR@Declaration@AST@CppParser@CppSharp@@QEAAXPEBD@Z")]
                    internal static extern void setUSR_0(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getDebugText@Declaration@AST@CppParser@CppSharp@@QEAAPEBDXZ")]
                    internal static extern global::System.IntPtr getDebugText_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?setDebugText@Declaration@AST@CppParser@CppSharp@@QEAAXPEBD@Z")]
                    internal static extern void setDebugText_0(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getPreprocessedEntitiesCount@Declaration@AST@CppParser@CppSharp@@QEAAIXZ")]
                    internal static extern uint getPreprocessedEntitiesCount_0(global::System.IntPtr instance);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                protected int __PointerAdjustment;
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, Declaration> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, Declaration>();
                protected void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                public static Declaration __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new Declaration(native.ToPointer(), skipVTables);
                }

                public static Declaration __CreateInstance(Declaration.Internal native, bool skipVTables = false)
                {
                    return new Declaration(native, skipVTables);
                }

                private static void* __CopyValue(Declaration.Internal native)
                {
                    var ret = Marshal.AllocHGlobal(192);
                    CppSharp.Parser.AST.Declaration.Internal.cctor_1(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private Declaration(Declaration.Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected Declaration(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public Declaration(CppSharp.Parser.AST.DeclarationKind kind)
                {
                    __Instance = Marshal.AllocHGlobal(192);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    var __arg0 = kind;
                    Internal.ctor_0((__Instance + __PointerAdjustment), __arg0);
                }

                public Declaration(CppSharp.Parser.AST.Declaration _0)
                {
                    __Instance = Marshal.AllocHGlobal(192);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    CppSharp.Parser.AST.Declaration __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    Internal.dtor_0((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public CppSharp.Parser.AST.PreprocessedEntity getPreprocessedEntities(uint i)
                {
                    var __ret = Internal.getPreprocessedEntities_0((__Instance + __PointerAdjustment), i);
                    CppSharp.Parser.AST.PreprocessedEntity __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (CppSharp.Parser.AST.PreprocessedEntity.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (CppSharp.Parser.AST.PreprocessedEntity) CppSharp.Parser.AST.PreprocessedEntity.NativeToManagedMap[__ret];
                    else __result0 = CppSharp.Parser.AST.PreprocessedEntity.__CreateInstance(__ret);
                    return __result0;
                }

                public void addPreprocessedEntities(CppSharp.Parser.AST.PreprocessedEntity s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    Internal.addPreprocessedEntities_0((__Instance + __PointerAdjustment), __arg0);
                }

                public void clearPreprocessedEntities()
                {
                    Internal.clearPreprocessedEntities_0((__Instance + __PointerAdjustment));
                }

                public string Name
                {
                    get
                    {
                        var __ret = Internal.getName_0((__Instance + __PointerAdjustment));
                        return Marshal.PtrToStringAnsi(__ret);
                    }

                    set
                    {
                        var __arg0 = Marshal.StringToHGlobalAnsi(value);
                        Internal.setName_0((__Instance + __PointerAdjustment), __arg0);
                        Marshal.FreeHGlobal(__arg0);
                    }
                }

                public string USR
                {
                    get
                    {
                        var __ret = Internal.getUSR_0((__Instance + __PointerAdjustment));
                        return Marshal.PtrToStringAnsi(__ret);
                    }

                    set
                    {
                        var __arg0 = Marshal.StringToHGlobalAnsi(value);
                        Internal.setUSR_0((__Instance + __PointerAdjustment), __arg0);
                        Marshal.FreeHGlobal(__arg0);
                    }
                }

                public string DebugText
                {
                    get
                    {
                        var __ret = Internal.getDebugText_0((__Instance + __PointerAdjustment));
                        return Marshal.PtrToStringAnsi(__ret);
                    }

                    set
                    {
                        var __arg0 = Marshal.StringToHGlobalAnsi(value);
                        Internal.setDebugText_0((__Instance + __PointerAdjustment), __arg0);
                        Marshal.FreeHGlobal(__arg0);
                    }
                }

                public uint PreprocessedEntitiesCount
                {
                    get
                    {
                        var __ret = Internal.getPreprocessedEntitiesCount_0((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                public CppSharp.Parser.AST.DeclarationKind Kind
                {
                    get
                    {
                        return ((Internal*) __Instance)->Kind;
                    }

                    set
                    {
                        ((Internal*) __Instance)->Kind = value;
                    }
                }

                public CppSharp.Parser.AST.AccessSpecifier Access
                {
                    get
                    {
                        return ((Internal*) __Instance)->Access;
                    }

                    set
                    {
                        ((Internal*) __Instance)->Access = value;
                    }
                }

                public CppSharp.Parser.AST.DeclarationContext _Namespace
                {
                    get
                    {
                        CppSharp.Parser.AST.DeclarationContext __result0;
                        if (((Internal*) __Instance)->_Namespace == IntPtr.Zero) __result0 = null;
                        else if (CppSharp.Parser.AST.DeclarationContext.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->_Namespace))
                            __result0 = (CppSharp.Parser.AST.DeclarationContext) CppSharp.Parser.AST.DeclarationContext.NativeToManagedMap[((Internal*) __Instance)->_Namespace];
                        else __result0 = CppSharp.Parser.AST.DeclarationContext.__CreateInstance(((Internal*) __Instance)->_Namespace);
                        return __result0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->_Namespace = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public CppSharp.Parser.SourceLocation Location
                {
                    get
                    {
                        return CppSharp.Parser.SourceLocation.__CreateInstance(((Internal*) __Instance)->Location);
                    }

                    set
                    {
                        ((Internal*) __Instance)->Location = value.__Instance;
                    }
                }

                public int LineNumberStart
                {
                    get
                    {
                        return ((Internal*) __Instance)->LineNumberStart;
                    }

                    set
                    {
                        ((Internal*) __Instance)->LineNumberStart = value;
                    }
                }

                public int LineNumberEnd
                {
                    get
                    {
                        return ((Internal*) __Instance)->LineNumberEnd;
                    }

                    set
                    {
                        ((Internal*) __Instance)->LineNumberEnd = value;
                    }
                }

                public bool IsIncomplete
                {
                    get
                    {
                        return ((Internal*) __Instance)->IsIncomplete != 0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->IsIncomplete = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsDependent
                {
                    get
                    {
                        return ((Internal*) __Instance)->IsDependent != 0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->IsDependent = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsImplicit
                {
                    get
                    {
                        return ((Internal*) __Instance)->IsImplicit != 0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->IsImplicit = (byte) (value ? 1 : 0);
                    }
                }

                public CppSharp.Parser.AST.Declaration CompleteDeclaration
                {
                    get
                    {
                        CppSharp.Parser.AST.Declaration __result0;
                        if (((Internal*) __Instance)->CompleteDeclaration == IntPtr.Zero) __result0 = null;
                        else if (CppSharp.Parser.AST.Declaration.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->CompleteDeclaration))
                            __result0 = (CppSharp.Parser.AST.Declaration) CppSharp.Parser.AST.Declaration.NativeToManagedMap[((Internal*) __Instance)->CompleteDeclaration];
                        else __result0 = CppSharp.Parser.AST.Declaration.__CreateInstance(((Internal*) __Instance)->CompleteDeclaration);
                        return __result0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->CompleteDeclaration = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public uint DefinitionOrder
                {
                    get
                    {
                        return ((Internal*) __Instance)->DefinitionOrder;
                    }

                    set
                    {
                        ((Internal*) __Instance)->DefinitionOrder = value;
                    }
                }

                public global::System.IntPtr OriginalPtr
                {
                    get
                    {
                        return ((Internal*) __Instance)->OriginalPtr;
                    }

                    set
                    {
                        ((Internal*) __Instance)->OriginalPtr = (global::System.IntPtr) value;
                    }
                }

                public CppSharp.Parser.AST.RawComment Comment
                {
                    get
                    {
                        CppSharp.Parser.AST.RawComment __result0;
                        if (((Internal*) __Instance)->Comment == IntPtr.Zero) __result0 = null;
                        else if (CppSharp.Parser.AST.RawComment.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->Comment))
                            __result0 = (CppSharp.Parser.AST.RawComment) CppSharp.Parser.AST.RawComment.NativeToManagedMap[((Internal*) __Instance)->Comment];
                        else __result0 = CppSharp.Parser.AST.RawComment.__CreateInstance(((Internal*) __Instance)->Comment);
                        return __result0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->Comment = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }
            }

            public unsafe partial class DeclarationContext : CppSharp.Parser.AST.Declaration, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 432)]
                public new partial struct Internal
                {
                    [FieldOffset(0)]
                    public CppSharp.Parser.AST.DeclarationKind Kind;

                    [FieldOffset(4)]
                    public CppSharp.Parser.AST.AccessSpecifier Access;

                    [FieldOffset(8)]
                    public global::System.IntPtr _Namespace;

                    [FieldOffset(16)]
                    public CppSharp.Parser.SourceLocation.Internal Location;

                    [FieldOffset(20)]
                    public int LineNumberStart;

                    [FieldOffset(24)]
                    public int LineNumberEnd;

                    [FieldOffset(128)]
                    public byte IsIncomplete;

                    [FieldOffset(129)]
                    public byte IsDependent;

                    [FieldOffset(130)]
                    public byte IsImplicit;

                    [FieldOffset(136)]
                    public global::System.IntPtr CompleteDeclaration;

                    [FieldOffset(144)]
                    public uint DefinitionOrder;

                    [FieldOffset(176)]
                    public global::System.IntPtr OriginalPtr;

                    [FieldOffset(184)]
                    public global::System.IntPtr Comment;

                    [FieldOffset(424)]
                    public byte IsAnonymous;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0DeclarationContext@AST@CppParser@CppSharp@@QEAA@W4DeclarationKind@123@@Z")]
                    internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance, CppSharp.Parser.AST.DeclarationKind kind);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0DeclarationContext@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1DeclarationContext@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor_0(global::System.IntPtr instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getNamespaces@DeclarationContext@AST@CppParser@CppSharp@@QEAAPEAVNamespace@234@I@Z")]
                    internal static extern global::System.IntPtr getNamespaces_0(global::System.IntPtr instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?addNamespaces@DeclarationContext@AST@CppParser@CppSharp@@QEAAXAEAPEAVNamespace@234@@Z")]
                    internal static extern void addNamespaces_0(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?clearNamespaces@DeclarationContext@AST@CppParser@CppSharp@@QEAAXXZ")]
                    internal static extern void clearNamespaces_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getEnums@DeclarationContext@AST@CppParser@CppSharp@@QEAAPEAVEnumeration@234@I@Z")]
                    internal static extern global::System.IntPtr getEnums_0(global::System.IntPtr instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?addEnums@DeclarationContext@AST@CppParser@CppSharp@@QEAAXAEAPEAVEnumeration@234@@Z")]
                    internal static extern void addEnums_0(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?clearEnums@DeclarationContext@AST@CppParser@CppSharp@@QEAAXXZ")]
                    internal static extern void clearEnums_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getFunctions@DeclarationContext@AST@CppParser@CppSharp@@QEAAPEAVFunction@234@I@Z")]
                    internal static extern global::System.IntPtr getFunctions_0(global::System.IntPtr instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?addFunctions@DeclarationContext@AST@CppParser@CppSharp@@QEAAXAEAPEAVFunction@234@@Z")]
                    internal static extern void addFunctions_0(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?clearFunctions@DeclarationContext@AST@CppParser@CppSharp@@QEAAXXZ")]
                    internal static extern void clearFunctions_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getClasses@DeclarationContext@AST@CppParser@CppSharp@@QEAAPEAVClass@234@I@Z")]
                    internal static extern global::System.IntPtr getClasses_0(global::System.IntPtr instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?addClasses@DeclarationContext@AST@CppParser@CppSharp@@QEAAXAEAPEAVClass@234@@Z")]
                    internal static extern void addClasses_0(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?clearClasses@DeclarationContext@AST@CppParser@CppSharp@@QEAAXXZ")]
                    internal static extern void clearClasses_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getTemplates@DeclarationContext@AST@CppParser@CppSharp@@QEAAPEAVTemplate@234@I@Z")]
                    internal static extern global::System.IntPtr getTemplates_0(global::System.IntPtr instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?addTemplates@DeclarationContext@AST@CppParser@CppSharp@@QEAAXAEAPEAVTemplate@234@@Z")]
                    internal static extern void addTemplates_0(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?clearTemplates@DeclarationContext@AST@CppParser@CppSharp@@QEAAXXZ")]
                    internal static extern void clearTemplates_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getTypedefs@DeclarationContext@AST@CppParser@CppSharp@@QEAAPEAVTypedefDecl@234@I@Z")]
                    internal static extern global::System.IntPtr getTypedefs_0(global::System.IntPtr instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?addTypedefs@DeclarationContext@AST@CppParser@CppSharp@@QEAAXAEAPEAVTypedefDecl@234@@Z")]
                    internal static extern void addTypedefs_0(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?clearTypedefs@DeclarationContext@AST@CppParser@CppSharp@@QEAAXXZ")]
                    internal static extern void clearTypedefs_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getTypeAliases@DeclarationContext@AST@CppParser@CppSharp@@QEAAPEAVTypeAlias@234@I@Z")]
                    internal static extern global::System.IntPtr getTypeAliases_0(global::System.IntPtr instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?addTypeAliases@DeclarationContext@AST@CppParser@CppSharp@@QEAAXAEAPEAVTypeAlias@234@@Z")]
                    internal static extern void addTypeAliases_0(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?clearTypeAliases@DeclarationContext@AST@CppParser@CppSharp@@QEAAXXZ")]
                    internal static extern void clearTypeAliases_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getVariables@DeclarationContext@AST@CppParser@CppSharp@@QEAAPEAVVariable@234@I@Z")]
                    internal static extern global::System.IntPtr getVariables_0(global::System.IntPtr instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?addVariables@DeclarationContext@AST@CppParser@CppSharp@@QEAAXAEAPEAVVariable@234@@Z")]
                    internal static extern void addVariables_0(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?clearVariables@DeclarationContext@AST@CppParser@CppSharp@@QEAAXXZ")]
                    internal static extern void clearVariables_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getFriends@DeclarationContext@AST@CppParser@CppSharp@@QEAAPEAVFriend@234@I@Z")]
                    internal static extern global::System.IntPtr getFriends_0(global::System.IntPtr instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?addFriends@DeclarationContext@AST@CppParser@CppSharp@@QEAAXAEAPEAVFriend@234@@Z")]
                    internal static extern void addFriends_0(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?clearFriends@DeclarationContext@AST@CppParser@CppSharp@@QEAAXXZ")]
                    internal static extern void clearFriends_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getNamespacesCount@DeclarationContext@AST@CppParser@CppSharp@@QEAAIXZ")]
                    internal static extern uint getNamespacesCount_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getEnumsCount@DeclarationContext@AST@CppParser@CppSharp@@QEAAIXZ")]
                    internal static extern uint getEnumsCount_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getFunctionsCount@DeclarationContext@AST@CppParser@CppSharp@@QEAAIXZ")]
                    internal static extern uint getFunctionsCount_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getClassesCount@DeclarationContext@AST@CppParser@CppSharp@@QEAAIXZ")]
                    internal static extern uint getClassesCount_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getTemplatesCount@DeclarationContext@AST@CppParser@CppSharp@@QEAAIXZ")]
                    internal static extern uint getTemplatesCount_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getTypedefsCount@DeclarationContext@AST@CppParser@CppSharp@@QEAAIXZ")]
                    internal static extern uint getTypedefsCount_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getTypeAliasesCount@DeclarationContext@AST@CppParser@CppSharp@@QEAAIXZ")]
                    internal static extern uint getTypeAliasesCount_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getVariablesCount@DeclarationContext@AST@CppParser@CppSharp@@QEAAIXZ")]
                    internal static extern uint getVariablesCount_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getFriendsCount@DeclarationContext@AST@CppParser@CppSharp@@QEAAIXZ")]
                    internal static extern uint getFriendsCount_0(global::System.IntPtr instance);
                }

                public static new DeclarationContext __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new DeclarationContext(native.ToPointer(), skipVTables);
                }

                public static DeclarationContext __CreateInstance(DeclarationContext.Internal native, bool skipVTables = false)
                {
                    return new DeclarationContext(native, skipVTables);
                }

                private static void* __CopyValue(DeclarationContext.Internal native)
                {
                    var ret = Marshal.AllocHGlobal(432);
                    CppSharp.Parser.AST.DeclarationContext.Internal.cctor_2(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private DeclarationContext(DeclarationContext.Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected DeclarationContext(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public DeclarationContext(CppSharp.Parser.AST.DeclarationKind kind)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(432);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    var __arg0 = kind;
                    Internal.ctor_0((__Instance + __PointerAdjustment), __arg0);
                }

                public DeclarationContext(CppSharp.Parser.AST.DeclarationContext _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(432);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    Internal.cctor_2((__Instance + __PointerAdjustment), __arg0);
                }

                protected override void Dispose(bool disposing)
                {
                    CppSharp.Parser.AST.Declaration __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    Internal.dtor_0((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public CppSharp.Parser.AST.Namespace getNamespaces(uint i)
                {
                    var __ret = Internal.getNamespaces_0((__Instance + __PointerAdjustment), i);
                    CppSharp.Parser.AST.Namespace __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (CppSharp.Parser.AST.Namespace.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (CppSharp.Parser.AST.Namespace) CppSharp.Parser.AST.Namespace.NativeToManagedMap[__ret];
                    else __result0 = CppSharp.Parser.AST.Namespace.__CreateInstance(__ret);
                    return __result0;
                }

                public void addNamespaces(CppSharp.Parser.AST.Namespace s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    Internal.addNamespaces_0((__Instance + __PointerAdjustment), __arg0);
                }

                public void clearNamespaces()
                {
                    Internal.clearNamespaces_0((__Instance + __PointerAdjustment));
                }

                public CppSharp.Parser.AST.Enumeration getEnums(uint i)
                {
                    var __ret = Internal.getEnums_0((__Instance + __PointerAdjustment), i);
                    CppSharp.Parser.AST.Enumeration __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (CppSharp.Parser.AST.Enumeration.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (CppSharp.Parser.AST.Enumeration) CppSharp.Parser.AST.Enumeration.NativeToManagedMap[__ret];
                    else __result0 = CppSharp.Parser.AST.Enumeration.__CreateInstance(__ret);
                    return __result0;
                }

                public void addEnums(CppSharp.Parser.AST.Enumeration s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    Internal.addEnums_0((__Instance + __PointerAdjustment), __arg0);
                }

                public void clearEnums()
                {
                    Internal.clearEnums_0((__Instance + __PointerAdjustment));
                }

                public CppSharp.Parser.AST.Function getFunctions(uint i)
                {
                    var __ret = Internal.getFunctions_0((__Instance + __PointerAdjustment), i);
                    CppSharp.Parser.AST.Function __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (CppSharp.Parser.AST.Function.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (CppSharp.Parser.AST.Function) CppSharp.Parser.AST.Function.NativeToManagedMap[__ret];
                    else __result0 = CppSharp.Parser.AST.Function.__CreateInstance(__ret);
                    return __result0;
                }

                public void addFunctions(CppSharp.Parser.AST.Function s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    Internal.addFunctions_0((__Instance + __PointerAdjustment), __arg0);
                }

                public void clearFunctions()
                {
                    Internal.clearFunctions_0((__Instance + __PointerAdjustment));
                }

                public CppSharp.Parser.AST.Class getClasses(uint i)
                {
                    var __ret = Internal.getClasses_0((__Instance + __PointerAdjustment), i);
                    CppSharp.Parser.AST.Class __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (CppSharp.Parser.AST.Class.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (CppSharp.Parser.AST.Class) CppSharp.Parser.AST.Class.NativeToManagedMap[__ret];
                    else __result0 = CppSharp.Parser.AST.Class.__CreateInstance(__ret);
                    return __result0;
                }

                public void addClasses(CppSharp.Parser.AST.Class s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    Internal.addClasses_0((__Instance + __PointerAdjustment), __arg0);
                }

                public void clearClasses()
                {
                    Internal.clearClasses_0((__Instance + __PointerAdjustment));
                }

                public CppSharp.Parser.AST.Template getTemplates(uint i)
                {
                    var __ret = Internal.getTemplates_0((__Instance + __PointerAdjustment), i);
                    CppSharp.Parser.AST.Template __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (CppSharp.Parser.AST.Template.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (CppSharp.Parser.AST.Template) CppSharp.Parser.AST.Template.NativeToManagedMap[__ret];
                    else __result0 = CppSharp.Parser.AST.Template.__CreateInstance(__ret);
                    return __result0;
                }

                public void addTemplates(CppSharp.Parser.AST.Template s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    Internal.addTemplates_0((__Instance + __PointerAdjustment), __arg0);
                }

                public void clearTemplates()
                {
                    Internal.clearTemplates_0((__Instance + __PointerAdjustment));
                }

                public CppSharp.Parser.AST.TypedefDecl getTypedefs(uint i)
                {
                    var __ret = Internal.getTypedefs_0((__Instance + __PointerAdjustment), i);
                    CppSharp.Parser.AST.TypedefDecl __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (CppSharp.Parser.AST.TypedefDecl.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (CppSharp.Parser.AST.TypedefDecl) CppSharp.Parser.AST.TypedefDecl.NativeToManagedMap[__ret];
                    else __result0 = CppSharp.Parser.AST.TypedefDecl.__CreateInstance(__ret);
                    return __result0;
                }

                public void addTypedefs(CppSharp.Parser.AST.TypedefDecl s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    Internal.addTypedefs_0((__Instance + __PointerAdjustment), __arg0);
                }

                public void clearTypedefs()
                {
                    Internal.clearTypedefs_0((__Instance + __PointerAdjustment));
                }

                public CppSharp.Parser.AST.TypeAlias getTypeAliases(uint i)
                {
                    var __ret = Internal.getTypeAliases_0((__Instance + __PointerAdjustment), i);
                    CppSharp.Parser.AST.TypeAlias __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (CppSharp.Parser.AST.TypeAlias.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (CppSharp.Parser.AST.TypeAlias) CppSharp.Parser.AST.TypeAlias.NativeToManagedMap[__ret];
                    else __result0 = CppSharp.Parser.AST.TypeAlias.__CreateInstance(__ret);
                    return __result0;
                }

                public void addTypeAliases(CppSharp.Parser.AST.TypeAlias s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    Internal.addTypeAliases_0((__Instance + __PointerAdjustment), __arg0);
                }

                public void clearTypeAliases()
                {
                    Internal.clearTypeAliases_0((__Instance + __PointerAdjustment));
                }

                public CppSharp.Parser.AST.Variable getVariables(uint i)
                {
                    var __ret = Internal.getVariables_0((__Instance + __PointerAdjustment), i);
                    CppSharp.Parser.AST.Variable __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (CppSharp.Parser.AST.Variable.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (CppSharp.Parser.AST.Variable) CppSharp.Parser.AST.Variable.NativeToManagedMap[__ret];
                    else __result0 = CppSharp.Parser.AST.Variable.__CreateInstance(__ret);
                    return __result0;
                }

                public void addVariables(CppSharp.Parser.AST.Variable s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    Internal.addVariables_0((__Instance + __PointerAdjustment), __arg0);
                }

                public void clearVariables()
                {
                    Internal.clearVariables_0((__Instance + __PointerAdjustment));
                }

                public CppSharp.Parser.AST.Friend getFriends(uint i)
                {
                    var __ret = Internal.getFriends_0((__Instance + __PointerAdjustment), i);
                    CppSharp.Parser.AST.Friend __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (CppSharp.Parser.AST.Friend.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (CppSharp.Parser.AST.Friend) CppSharp.Parser.AST.Friend.NativeToManagedMap[__ret];
                    else __result0 = CppSharp.Parser.AST.Friend.__CreateInstance(__ret);
                    return __result0;
                }

                public void addFriends(CppSharp.Parser.AST.Friend s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    Internal.addFriends_0((__Instance + __PointerAdjustment), __arg0);
                }

                public void clearFriends()
                {
                    Internal.clearFriends_0((__Instance + __PointerAdjustment));
                }

                public uint NamespacesCount
                {
                    get
                    {
                        var __ret = Internal.getNamespacesCount_0((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                public uint EnumsCount
                {
                    get
                    {
                        var __ret = Internal.getEnumsCount_0((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                public uint FunctionsCount
                {
                    get
                    {
                        var __ret = Internal.getFunctionsCount_0((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                public uint ClassesCount
                {
                    get
                    {
                        var __ret = Internal.getClassesCount_0((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                public uint TemplatesCount
                {
                    get
                    {
                        var __ret = Internal.getTemplatesCount_0((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                public uint TypedefsCount
                {
                    get
                    {
                        var __ret = Internal.getTypedefsCount_0((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                public uint TypeAliasesCount
                {
                    get
                    {
                        var __ret = Internal.getTypeAliasesCount_0((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                public uint VariablesCount
                {
                    get
                    {
                        var __ret = Internal.getVariablesCount_0((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                public uint FriendsCount
                {
                    get
                    {
                        var __ret = Internal.getFriendsCount_0((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                public bool IsAnonymous
                {
                    get
                    {
                        return ((Internal*) __Instance)->IsAnonymous != 0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->IsAnonymous = (byte) (value ? 1 : 0);
                    }
                }
            }

            public unsafe partial class TypedefNameDecl : CppSharp.Parser.AST.Declaration, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 208)]
                public new partial struct Internal
                {
                    [FieldOffset(0)]
                    public CppSharp.Parser.AST.DeclarationKind Kind;

                    [FieldOffset(4)]
                    public CppSharp.Parser.AST.AccessSpecifier Access;

                    [FieldOffset(8)]
                    public global::System.IntPtr _Namespace;

                    [FieldOffset(16)]
                    public CppSharp.Parser.SourceLocation.Internal Location;

                    [FieldOffset(20)]
                    public int LineNumberStart;

                    [FieldOffset(24)]
                    public int LineNumberEnd;

                    [FieldOffset(128)]
                    public byte IsIncomplete;

                    [FieldOffset(129)]
                    public byte IsDependent;

                    [FieldOffset(130)]
                    public byte IsImplicit;

                    [FieldOffset(136)]
                    public global::System.IntPtr CompleteDeclaration;

                    [FieldOffset(144)]
                    public uint DefinitionOrder;

                    [FieldOffset(176)]
                    public global::System.IntPtr OriginalPtr;

                    [FieldOffset(184)]
                    public global::System.IntPtr Comment;

                    [FieldOffset(192)]
                    public CppSharp.Parser.AST.QualifiedType.Internal QualifiedType;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0TypedefNameDecl@AST@CppParser@CppSharp@@QEAA@W4DeclarationKind@123@@Z")]
                    internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance, CppSharp.Parser.AST.DeclarationKind kind);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0TypedefNameDecl@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1TypedefNameDecl@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor_0(global::System.IntPtr instance, int delete);
                }

                public static new TypedefNameDecl __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new TypedefNameDecl(native.ToPointer(), skipVTables);
                }

                public static TypedefNameDecl __CreateInstance(TypedefNameDecl.Internal native, bool skipVTables = false)
                {
                    return new TypedefNameDecl(native, skipVTables);
                }

                private static void* __CopyValue(TypedefNameDecl.Internal native)
                {
                    var ret = Marshal.AllocHGlobal(208);
                    CppSharp.Parser.AST.TypedefNameDecl.Internal.cctor_1(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private TypedefNameDecl(TypedefNameDecl.Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected TypedefNameDecl(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public TypedefNameDecl(CppSharp.Parser.AST.DeclarationKind kind)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(208);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    var __arg0 = kind;
                    Internal.ctor_0((__Instance + __PointerAdjustment), __arg0);
                }

                public TypedefNameDecl(CppSharp.Parser.AST.TypedefNameDecl _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(208);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
                }

                protected override void Dispose(bool disposing)
                {
                    CppSharp.Parser.AST.Declaration __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    Internal.dtor_0((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public CppSharp.Parser.AST.QualifiedType QualifiedType
                {
                    get
                    {
                        return CppSharp.Parser.AST.QualifiedType.__CreateInstance(((Internal*) __Instance)->QualifiedType);
                    }

                    set
                    {
                        ((Internal*) __Instance)->QualifiedType = ReferenceEquals(value, null) ? new CppSharp.Parser.AST.QualifiedType.Internal() : *(CppSharp.Parser.AST.QualifiedType.Internal*) (value.__Instance);
                    }
                }
            }

            public unsafe partial class TypedefDecl : CppSharp.Parser.AST.TypedefNameDecl, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 208)]
                public new partial struct Internal
                {
                    [FieldOffset(0)]
                    public CppSharp.Parser.AST.DeclarationKind Kind;

                    [FieldOffset(4)]
                    public CppSharp.Parser.AST.AccessSpecifier Access;

                    [FieldOffset(8)]
                    public global::System.IntPtr _Namespace;

                    [FieldOffset(16)]
                    public CppSharp.Parser.SourceLocation.Internal Location;

                    [FieldOffset(20)]
                    public int LineNumberStart;

                    [FieldOffset(24)]
                    public int LineNumberEnd;

                    [FieldOffset(128)]
                    public byte IsIncomplete;

                    [FieldOffset(129)]
                    public byte IsDependent;

                    [FieldOffset(130)]
                    public byte IsImplicit;

                    [FieldOffset(136)]
                    public global::System.IntPtr CompleteDeclaration;

                    [FieldOffset(144)]
                    public uint DefinitionOrder;

                    [FieldOffset(176)]
                    public global::System.IntPtr OriginalPtr;

                    [FieldOffset(184)]
                    public global::System.IntPtr Comment;

                    [FieldOffset(192)]
                    public CppSharp.Parser.AST.QualifiedType.Internal QualifiedType;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0TypedefDecl@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0TypedefDecl@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1TypedefDecl@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor_0(global::System.IntPtr instance, int delete);
                }

                public static new TypedefDecl __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new TypedefDecl(native.ToPointer(), skipVTables);
                }

                public static TypedefDecl __CreateInstance(TypedefDecl.Internal native, bool skipVTables = false)
                {
                    return new TypedefDecl(native, skipVTables);
                }

                private static void* __CopyValue(TypedefDecl.Internal native)
                {
                    var ret = Marshal.AllocHGlobal(208);
                    CppSharp.Parser.AST.TypedefDecl.Internal.cctor_1(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private TypedefDecl(TypedefDecl.Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected TypedefDecl(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public TypedefDecl()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(208);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_0((__Instance + __PointerAdjustment));
                }

                public TypedefDecl(CppSharp.Parser.AST.TypedefDecl _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(208);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
                }

                protected override void Dispose(bool disposing)
                {
                    CppSharp.Parser.AST.Declaration __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    Internal.dtor_0((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }
            }

            public unsafe partial class TypeAlias : CppSharp.Parser.AST.TypedefNameDecl, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 216)]
                public new partial struct Internal
                {
                    [FieldOffset(0)]
                    public CppSharp.Parser.AST.DeclarationKind Kind;

                    [FieldOffset(4)]
                    public CppSharp.Parser.AST.AccessSpecifier Access;

                    [FieldOffset(8)]
                    public global::System.IntPtr _Namespace;

                    [FieldOffset(16)]
                    public CppSharp.Parser.SourceLocation.Internal Location;

                    [FieldOffset(20)]
                    public int LineNumberStart;

                    [FieldOffset(24)]
                    public int LineNumberEnd;

                    [FieldOffset(128)]
                    public byte IsIncomplete;

                    [FieldOffset(129)]
                    public byte IsDependent;

                    [FieldOffset(130)]
                    public byte IsImplicit;

                    [FieldOffset(136)]
                    public global::System.IntPtr CompleteDeclaration;

                    [FieldOffset(144)]
                    public uint DefinitionOrder;

                    [FieldOffset(176)]
                    public global::System.IntPtr OriginalPtr;

                    [FieldOffset(184)]
                    public global::System.IntPtr Comment;

                    [FieldOffset(192)]
                    public CppSharp.Parser.AST.QualifiedType.Internal QualifiedType;

                    [FieldOffset(208)]
                    public global::System.IntPtr DescribedAliasTemplate;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0TypeAlias@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0TypeAlias@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1TypeAlias@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor_0(global::System.IntPtr instance, int delete);
                }

                public static new TypeAlias __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new TypeAlias(native.ToPointer(), skipVTables);
                }

                public static TypeAlias __CreateInstance(TypeAlias.Internal native, bool skipVTables = false)
                {
                    return new TypeAlias(native, skipVTables);
                }

                private static void* __CopyValue(TypeAlias.Internal native)
                {
                    var ret = Marshal.AllocHGlobal(216);
                    CppSharp.Parser.AST.TypeAlias.Internal.cctor_1(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private TypeAlias(TypeAlias.Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected TypeAlias(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public TypeAlias()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(216);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_0((__Instance + __PointerAdjustment));
                }

                public TypeAlias(CppSharp.Parser.AST.TypeAlias _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(216);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
                }

                protected override void Dispose(bool disposing)
                {
                    CppSharp.Parser.AST.Declaration __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    Internal.dtor_0((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public CppSharp.Parser.AST.TypeAliasTemplate DescribedAliasTemplate
                {
                    get
                    {
                        CppSharp.Parser.AST.TypeAliasTemplate __result0;
                        if (((Internal*) __Instance)->DescribedAliasTemplate == IntPtr.Zero) __result0 = null;
                        else if (CppSharp.Parser.AST.TypeAliasTemplate.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->DescribedAliasTemplate))
                            __result0 = (CppSharp.Parser.AST.TypeAliasTemplate) CppSharp.Parser.AST.TypeAliasTemplate.NativeToManagedMap[((Internal*) __Instance)->DescribedAliasTemplate];
                        else __result0 = CppSharp.Parser.AST.TypeAliasTemplate.__CreateInstance(((Internal*) __Instance)->DescribedAliasTemplate);
                        return __result0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->DescribedAliasTemplate = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }
            }

            public unsafe partial class Friend : CppSharp.Parser.AST.Declaration, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 200)]
                public new partial struct Internal
                {
                    [FieldOffset(0)]
                    public CppSharp.Parser.AST.DeclarationKind Kind;

                    [FieldOffset(4)]
                    public CppSharp.Parser.AST.AccessSpecifier Access;

                    [FieldOffset(8)]
                    public global::System.IntPtr _Namespace;

                    [FieldOffset(16)]
                    public CppSharp.Parser.SourceLocation.Internal Location;

                    [FieldOffset(20)]
                    public int LineNumberStart;

                    [FieldOffset(24)]
                    public int LineNumberEnd;

                    [FieldOffset(128)]
                    public byte IsIncomplete;

                    [FieldOffset(129)]
                    public byte IsDependent;

                    [FieldOffset(130)]
                    public byte IsImplicit;

                    [FieldOffset(136)]
                    public global::System.IntPtr CompleteDeclaration;

                    [FieldOffset(144)]
                    public uint DefinitionOrder;

                    [FieldOffset(176)]
                    public global::System.IntPtr OriginalPtr;

                    [FieldOffset(184)]
                    public global::System.IntPtr Comment;

                    [FieldOffset(192)]
                    public global::System.IntPtr Declaration;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0Friend@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0Friend@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1Friend@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor_0(global::System.IntPtr instance, int delete);
                }

                public static new Friend __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new Friend(native.ToPointer(), skipVTables);
                }

                public static Friend __CreateInstance(Friend.Internal native, bool skipVTables = false)
                {
                    return new Friend(native, skipVTables);
                }

                private static void* __CopyValue(Friend.Internal native)
                {
                    var ret = Marshal.AllocHGlobal(200);
                    CppSharp.Parser.AST.Friend.Internal.cctor_1(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private Friend(Friend.Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected Friend(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public Friend()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(200);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_0((__Instance + __PointerAdjustment));
                }

                public Friend(CppSharp.Parser.AST.Friend _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(200);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
                }

                protected override void Dispose(bool disposing)
                {
                    CppSharp.Parser.AST.Declaration __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    Internal.dtor_0((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public CppSharp.Parser.AST.Declaration Declaration
                {
                    get
                    {
                        CppSharp.Parser.AST.Declaration __result0;
                        if (((Internal*) __Instance)->Declaration == IntPtr.Zero) __result0 = null;
                        else if (CppSharp.Parser.AST.Declaration.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->Declaration))
                            __result0 = (CppSharp.Parser.AST.Declaration) CppSharp.Parser.AST.Declaration.NativeToManagedMap[((Internal*) __Instance)->Declaration];
                        else __result0 = CppSharp.Parser.AST.Declaration.__CreateInstance(((Internal*) __Instance)->Declaration);
                        return __result0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->Declaration = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }
            }

            public unsafe partial class Statement : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 48)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public CppSharp.Parser.AST.StatementClass Class;

                    [FieldOffset(8)]
                    public global::System.IntPtr Decl;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0Statement@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1Statement@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor_0(global::System.IntPtr instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getString@Statement@AST@CppParser@CppSharp@@QEAAPEBDXZ")]
                    internal static extern global::System.IntPtr getString_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?setString@Statement@AST@CppParser@CppSharp@@QEAAXPEBD@Z")]
                    internal static extern void setString_0(global::System.IntPtr instance, global::System.IntPtr s);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                protected int __PointerAdjustment;
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, Statement> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, Statement>();
                protected void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                public static Statement __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new Statement(native.ToPointer(), skipVTables);
                }

                public static Statement __CreateInstance(Statement.Internal native, bool skipVTables = false)
                {
                    return new Statement(native, skipVTables);
                }

                private static void* __CopyValue(Statement.Internal native)
                {
                    var ret = Marshal.AllocHGlobal(48);
                    CppSharp.Parser.AST.Statement.Internal.cctor_2(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private Statement(Statement.Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected Statement(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public Statement(CppSharp.Parser.AST.Statement _0)
                {
                    __Instance = Marshal.AllocHGlobal(48);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    Internal.cctor_2((__Instance + __PointerAdjustment), __arg0);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    CppSharp.Parser.AST.Statement __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    Internal.dtor_0((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public string String
                {
                    get
                    {
                        var __ret = Internal.getString_0((__Instance + __PointerAdjustment));
                        return Marshal.PtrToStringAnsi(__ret);
                    }

                    set
                    {
                        var __arg0 = Marshal.StringToHGlobalAnsi(value);
                        Internal.setString_0((__Instance + __PointerAdjustment), __arg0);
                        Marshal.FreeHGlobal(__arg0);
                    }
                }

                public CppSharp.Parser.AST.StatementClass Class
                {
                    get
                    {
                        return ((Internal*) __Instance)->Class;
                    }

                    set
                    {
                        ((Internal*) __Instance)->Class = value;
                    }
                }

                public CppSharp.Parser.AST.Declaration Decl
                {
                    get
                    {
                        CppSharp.Parser.AST.Declaration __result0;
                        if (((Internal*) __Instance)->Decl == IntPtr.Zero) __result0 = null;
                        else if (CppSharp.Parser.AST.Declaration.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->Decl))
                            __result0 = (CppSharp.Parser.AST.Declaration) CppSharp.Parser.AST.Declaration.NativeToManagedMap[((Internal*) __Instance)->Decl];
                        else __result0 = CppSharp.Parser.AST.Declaration.__CreateInstance(((Internal*) __Instance)->Decl);
                        return __result0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->Decl = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }
            }

            public unsafe partial class Expression : CppSharp.Parser.AST.Statement, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 48)]
                public new partial struct Internal
                {
                    [FieldOffset(0)]
                    public CppSharp.Parser.AST.StatementClass Class;

                    [FieldOffset(8)]
                    public global::System.IntPtr Decl;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0Expression@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1Expression@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor_0(global::System.IntPtr instance, int delete);
                }

                public static new Expression __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new Expression(native.ToPointer(), skipVTables);
                }

                public static Expression __CreateInstance(Expression.Internal native, bool skipVTables = false)
                {
                    return new Expression(native, skipVTables);
                }

                private static void* __CopyValue(Expression.Internal native)
                {
                    var ret = Marshal.AllocHGlobal(48);
                    CppSharp.Parser.AST.Expression.Internal.cctor_1(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private Expression(Expression.Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected Expression(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public Expression(CppSharp.Parser.AST.Expression _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(48);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
                }

                protected override void Dispose(bool disposing)
                {
                    CppSharp.Parser.AST.Statement __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    Internal.dtor_0((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }
            }

            public unsafe partial class BinaryOperator : CppSharp.Parser.AST.Expression, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 96)]
                public new partial struct Internal
                {
                    [FieldOffset(0)]
                    public CppSharp.Parser.AST.StatementClass Class;

                    [FieldOffset(8)]
                    public global::System.IntPtr Decl;

                    [FieldOffset(48)]
                    public global::System.IntPtr LHS;

                    [FieldOffset(56)]
                    public global::System.IntPtr RHS;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0BinaryOperator@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1BinaryOperator@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor_0(global::System.IntPtr instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getOpcodeStr@BinaryOperator@AST@CppParser@CppSharp@@QEAAPEBDXZ")]
                    internal static extern global::System.IntPtr getOpcodeStr_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?setOpcodeStr@BinaryOperator@AST@CppParser@CppSharp@@QEAAXPEBD@Z")]
                    internal static extern void setOpcodeStr_0(global::System.IntPtr instance, global::System.IntPtr s);
                }

                public static new BinaryOperator __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new BinaryOperator(native.ToPointer(), skipVTables);
                }

                public static BinaryOperator __CreateInstance(BinaryOperator.Internal native, bool skipVTables = false)
                {
                    return new BinaryOperator(native, skipVTables);
                }

                private static void* __CopyValue(BinaryOperator.Internal native)
                {
                    var ret = Marshal.AllocHGlobal(96);
                    CppSharp.Parser.AST.BinaryOperator.Internal.cctor_1(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private BinaryOperator(BinaryOperator.Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected BinaryOperator(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public BinaryOperator(CppSharp.Parser.AST.BinaryOperator _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(96);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
                }

                protected override void Dispose(bool disposing)
                {
                    CppSharp.Parser.AST.Statement __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    Internal.dtor_0((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public string OpcodeStr
                {
                    get
                    {
                        var __ret = Internal.getOpcodeStr_0((__Instance + __PointerAdjustment));
                        return Marshal.PtrToStringAnsi(__ret);
                    }

                    set
                    {
                        var __arg0 = Marshal.StringToHGlobalAnsi(value);
                        Internal.setOpcodeStr_0((__Instance + __PointerAdjustment), __arg0);
                        Marshal.FreeHGlobal(__arg0);
                    }
                }

                public CppSharp.Parser.AST.Expression LHS
                {
                    get
                    {
                        CppSharp.Parser.AST.Expression __result0;
                        if (((Internal*) __Instance)->LHS == IntPtr.Zero) __result0 = null;
                        else if (CppSharp.Parser.AST.Expression.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->LHS))
                            __result0 = (CppSharp.Parser.AST.Expression) CppSharp.Parser.AST.Expression.NativeToManagedMap[((Internal*) __Instance)->LHS];
                        else __result0 = CppSharp.Parser.AST.Expression.__CreateInstance(((Internal*) __Instance)->LHS);
                        return __result0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->LHS = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public CppSharp.Parser.AST.Expression RHS
                {
                    get
                    {
                        CppSharp.Parser.AST.Expression __result0;
                        if (((Internal*) __Instance)->RHS == IntPtr.Zero) __result0 = null;
                        else if (CppSharp.Parser.AST.Expression.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->RHS))
                            __result0 = (CppSharp.Parser.AST.Expression) CppSharp.Parser.AST.Expression.NativeToManagedMap[((Internal*) __Instance)->RHS];
                        else __result0 = CppSharp.Parser.AST.Expression.__CreateInstance(((Internal*) __Instance)->RHS);
                        return __result0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->RHS = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }
            }

            public unsafe partial class CallExpr : CppSharp.Parser.AST.Expression, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 72)]
                public new partial struct Internal
                {
                    [FieldOffset(0)]
                    public CppSharp.Parser.AST.StatementClass Class;

                    [FieldOffset(8)]
                    public global::System.IntPtr Decl;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0CallExpr@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1CallExpr@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor_0(global::System.IntPtr instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getArguments@CallExpr@AST@CppParser@CppSharp@@QEAAPEAVExpression@234@I@Z")]
                    internal static extern global::System.IntPtr getArguments_0(global::System.IntPtr instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?addArguments@CallExpr@AST@CppParser@CppSharp@@QEAAXAEAPEAVExpression@234@@Z")]
                    internal static extern void addArguments_0(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?clearArguments@CallExpr@AST@CppParser@CppSharp@@QEAAXXZ")]
                    internal static extern void clearArguments_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getArgumentsCount@CallExpr@AST@CppParser@CppSharp@@QEAAIXZ")]
                    internal static extern uint getArgumentsCount_0(global::System.IntPtr instance);
                }

                public static new CallExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new CallExpr(native.ToPointer(), skipVTables);
                }

                public static CallExpr __CreateInstance(CallExpr.Internal native, bool skipVTables = false)
                {
                    return new CallExpr(native, skipVTables);
                }

                private static void* __CopyValue(CallExpr.Internal native)
                {
                    var ret = Marshal.AllocHGlobal(72);
                    CppSharp.Parser.AST.CallExpr.Internal.cctor_1(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private CallExpr(CallExpr.Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected CallExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public CallExpr(CppSharp.Parser.AST.CallExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(72);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
                }

                protected override void Dispose(bool disposing)
                {
                    CppSharp.Parser.AST.Statement __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    Internal.dtor_0((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public CppSharp.Parser.AST.Expression getArguments(uint i)
                {
                    var __ret = Internal.getArguments_0((__Instance + __PointerAdjustment), i);
                    CppSharp.Parser.AST.Expression __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (CppSharp.Parser.AST.Expression.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (CppSharp.Parser.AST.Expression) CppSharp.Parser.AST.Expression.NativeToManagedMap[__ret];
                    else __result0 = CppSharp.Parser.AST.Expression.__CreateInstance(__ret);
                    return __result0;
                }

                public void addArguments(CppSharp.Parser.AST.Expression s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    Internal.addArguments_0((__Instance + __PointerAdjustment), __arg0);
                }

                public void clearArguments()
                {
                    Internal.clearArguments_0((__Instance + __PointerAdjustment));
                }

                public uint ArgumentsCount
                {
                    get
                    {
                        var __ret = Internal.getArgumentsCount_0((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }
            }

            public unsafe partial class CXXConstructExpr : CppSharp.Parser.AST.Expression, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 72)]
                public new partial struct Internal
                {
                    [FieldOffset(0)]
                    public CppSharp.Parser.AST.StatementClass Class;

                    [FieldOffset(8)]
                    public global::System.IntPtr Decl;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0CXXConstructExpr@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1CXXConstructExpr@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor_0(global::System.IntPtr instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getArguments@CXXConstructExpr@AST@CppParser@CppSharp@@QEAAPEAVExpression@234@I@Z")]
                    internal static extern global::System.IntPtr getArguments_0(global::System.IntPtr instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?addArguments@CXXConstructExpr@AST@CppParser@CppSharp@@QEAAXAEAPEAVExpression@234@@Z")]
                    internal static extern void addArguments_0(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?clearArguments@CXXConstructExpr@AST@CppParser@CppSharp@@QEAAXXZ")]
                    internal static extern void clearArguments_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getArgumentsCount@CXXConstructExpr@AST@CppParser@CppSharp@@QEAAIXZ")]
                    internal static extern uint getArgumentsCount_0(global::System.IntPtr instance);
                }

                public static new CXXConstructExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new CXXConstructExpr(native.ToPointer(), skipVTables);
                }

                public static CXXConstructExpr __CreateInstance(CXXConstructExpr.Internal native, bool skipVTables = false)
                {
                    return new CXXConstructExpr(native, skipVTables);
                }

                private static void* __CopyValue(CXXConstructExpr.Internal native)
                {
                    var ret = Marshal.AllocHGlobal(72);
                    CppSharp.Parser.AST.CXXConstructExpr.Internal.cctor_1(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private CXXConstructExpr(CXXConstructExpr.Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected CXXConstructExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public CXXConstructExpr(CppSharp.Parser.AST.CXXConstructExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(72);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
                }

                protected override void Dispose(bool disposing)
                {
                    CppSharp.Parser.AST.Statement __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    Internal.dtor_0((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public CppSharp.Parser.AST.Expression getArguments(uint i)
                {
                    var __ret = Internal.getArguments_0((__Instance + __PointerAdjustment), i);
                    CppSharp.Parser.AST.Expression __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (CppSharp.Parser.AST.Expression.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (CppSharp.Parser.AST.Expression) CppSharp.Parser.AST.Expression.NativeToManagedMap[__ret];
                    else __result0 = CppSharp.Parser.AST.Expression.__CreateInstance(__ret);
                    return __result0;
                }

                public void addArguments(CppSharp.Parser.AST.Expression s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    Internal.addArguments_0((__Instance + __PointerAdjustment), __arg0);
                }

                public void clearArguments()
                {
                    Internal.clearArguments_0((__Instance + __PointerAdjustment));
                }

                public uint ArgumentsCount
                {
                    get
                    {
                        var __ret = Internal.getArgumentsCount_0((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }
            }

            public unsafe partial class Parameter : CppSharp.Parser.AST.Declaration, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 224)]
                public new partial struct Internal
                {
                    [FieldOffset(0)]
                    public CppSharp.Parser.AST.DeclarationKind Kind;

                    [FieldOffset(4)]
                    public CppSharp.Parser.AST.AccessSpecifier Access;

                    [FieldOffset(8)]
                    public global::System.IntPtr _Namespace;

                    [FieldOffset(16)]
                    public CppSharp.Parser.SourceLocation.Internal Location;

                    [FieldOffset(20)]
                    public int LineNumberStart;

                    [FieldOffset(24)]
                    public int LineNumberEnd;

                    [FieldOffset(128)]
                    public byte IsIncomplete;

                    [FieldOffset(129)]
                    public byte IsDependent;

                    [FieldOffset(130)]
                    public byte IsImplicit;

                    [FieldOffset(136)]
                    public global::System.IntPtr CompleteDeclaration;

                    [FieldOffset(144)]
                    public uint DefinitionOrder;

                    [FieldOffset(176)]
                    public global::System.IntPtr OriginalPtr;

                    [FieldOffset(184)]
                    public global::System.IntPtr Comment;

                    [FieldOffset(192)]
                    public CppSharp.Parser.AST.QualifiedType.Internal QualifiedType;

                    [FieldOffset(208)]
                    public byte IsIndirect;

                    [FieldOffset(209)]
                    public byte HasDefaultValue;

                    [FieldOffset(212)]
                    public uint Index;

                    [FieldOffset(216)]
                    public global::System.IntPtr DefaultArgument;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0Parameter@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0Parameter@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1Parameter@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor_0(global::System.IntPtr instance, int delete);
                }

                public static new Parameter __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new Parameter(native.ToPointer(), skipVTables);
                }

                public static Parameter __CreateInstance(Parameter.Internal native, bool skipVTables = false)
                {
                    return new Parameter(native, skipVTables);
                }

                private static void* __CopyValue(Parameter.Internal native)
                {
                    var ret = Marshal.AllocHGlobal(224);
                    CppSharp.Parser.AST.Parameter.Internal.cctor_1(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private Parameter(Parameter.Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected Parameter(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public Parameter()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(224);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_0((__Instance + __PointerAdjustment));
                }

                public Parameter(CppSharp.Parser.AST.Parameter _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(224);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
                }

                protected override void Dispose(bool disposing)
                {
                    CppSharp.Parser.AST.Declaration __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    Internal.dtor_0((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public CppSharp.Parser.AST.QualifiedType QualifiedType
                {
                    get
                    {
                        return CppSharp.Parser.AST.QualifiedType.__CreateInstance(((Internal*) __Instance)->QualifiedType);
                    }

                    set
                    {
                        ((Internal*) __Instance)->QualifiedType = ReferenceEquals(value, null) ? new CppSharp.Parser.AST.QualifiedType.Internal() : *(CppSharp.Parser.AST.QualifiedType.Internal*) (value.__Instance);
                    }
                }

                public bool IsIndirect
                {
                    get
                    {
                        return ((Internal*) __Instance)->IsIndirect != 0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->IsIndirect = (byte) (value ? 1 : 0);
                    }
                }

                public bool HasDefaultValue
                {
                    get
                    {
                        return ((Internal*) __Instance)->HasDefaultValue != 0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->HasDefaultValue = (byte) (value ? 1 : 0);
                    }
                }

                public uint Index
                {
                    get
                    {
                        return ((Internal*) __Instance)->Index;
                    }

                    set
                    {
                        ((Internal*) __Instance)->Index = value;
                    }
                }

                public CppSharp.Parser.AST.Expression DefaultArgument
                {
                    get
                    {
                        CppSharp.Parser.AST.Expression __result0;
                        if (((Internal*) __Instance)->DefaultArgument == IntPtr.Zero) __result0 = null;
                        else if (CppSharp.Parser.AST.Expression.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->DefaultArgument))
                            __result0 = (CppSharp.Parser.AST.Expression) CppSharp.Parser.AST.Expression.NativeToManagedMap[((Internal*) __Instance)->DefaultArgument];
                        else __result0 = CppSharp.Parser.AST.Expression.__CreateInstance(((Internal*) __Instance)->DefaultArgument);
                        return __result0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->DefaultArgument = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }
            }

            public unsafe partial class Function : CppSharp.Parser.AST.Declaration, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 336)]
                public new partial struct Internal
                {
                    [FieldOffset(0)]
                    public CppSharp.Parser.AST.DeclarationKind Kind;

                    [FieldOffset(4)]
                    public CppSharp.Parser.AST.AccessSpecifier Access;

                    [FieldOffset(8)]
                    public global::System.IntPtr _Namespace;

                    [FieldOffset(16)]
                    public CppSharp.Parser.SourceLocation.Internal Location;

                    [FieldOffset(20)]
                    public int LineNumberStart;

                    [FieldOffset(24)]
                    public int LineNumberEnd;

                    [FieldOffset(128)]
                    public byte IsIncomplete;

                    [FieldOffset(129)]
                    public byte IsDependent;

                    [FieldOffset(130)]
                    public byte IsImplicit;

                    [FieldOffset(136)]
                    public global::System.IntPtr CompleteDeclaration;

                    [FieldOffset(144)]
                    public uint DefinitionOrder;

                    [FieldOffset(176)]
                    public global::System.IntPtr OriginalPtr;

                    [FieldOffset(184)]
                    public global::System.IntPtr Comment;

                    [FieldOffset(192)]
                    public CppSharp.Parser.AST.QualifiedType.Internal ReturnType;

                    [FieldOffset(208)]
                    public byte IsReturnIndirect;

                    [FieldOffset(209)]
                    public byte HasThisReturn;

                    [FieldOffset(210)]
                    public byte IsVariadic;

                    [FieldOffset(211)]
                    public byte IsInline;

                    [FieldOffset(212)]
                    public byte IsPure;

                    [FieldOffset(213)]
                    public byte IsDeleted;

                    [FieldOffset(216)]
                    public CppSharp.Parser.AST.CXXOperatorKind OperatorKind;

                    [FieldOffset(288)]
                    public CppSharp.Parser.AST.CallingConvention CallingConvention;

                    [FieldOffset(320)]
                    public global::System.IntPtr SpecializationInfo;

                    [FieldOffset(328)]
                    public global::System.IntPtr InstantiatedFrom;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0Function@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0Function@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1Function@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor_0(global::System.IntPtr instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getParameters@Function@AST@CppParser@CppSharp@@QEAAPEAVParameter@234@I@Z")]
                    internal static extern global::System.IntPtr getParameters_0(global::System.IntPtr instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?addParameters@Function@AST@CppParser@CppSharp@@QEAAXAEAPEAVParameter@234@@Z")]
                    internal static extern void addParameters_0(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?clearParameters@Function@AST@CppParser@CppSharp@@QEAAXXZ")]
                    internal static extern void clearParameters_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getMangled@Function@AST@CppParser@CppSharp@@QEAAPEBDXZ")]
                    internal static extern global::System.IntPtr getMangled_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?setMangled@Function@AST@CppParser@CppSharp@@QEAAXPEBD@Z")]
                    internal static extern void setMangled_0(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getSignature@Function@AST@CppParser@CppSharp@@QEAAPEBDXZ")]
                    internal static extern global::System.IntPtr getSignature_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?setSignature@Function@AST@CppParser@CppSharp@@QEAAXPEBD@Z")]
                    internal static extern void setSignature_0(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getParametersCount@Function@AST@CppParser@CppSharp@@QEAAIXZ")]
                    internal static extern uint getParametersCount_0(global::System.IntPtr instance);
                }

                public static new Function __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new Function(native.ToPointer(), skipVTables);
                }

                public static Function __CreateInstance(Function.Internal native, bool skipVTables = false)
                {
                    return new Function(native, skipVTables);
                }

                private static void* __CopyValue(Function.Internal native)
                {
                    var ret = Marshal.AllocHGlobal(336);
                    CppSharp.Parser.AST.Function.Internal.cctor_1(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private Function(Function.Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected Function(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public Function()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(336);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_0((__Instance + __PointerAdjustment));
                }

                public Function(CppSharp.Parser.AST.Function _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(336);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
                }

                protected override void Dispose(bool disposing)
                {
                    CppSharp.Parser.AST.Declaration __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    Internal.dtor_0((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public CppSharp.Parser.AST.Parameter getParameters(uint i)
                {
                    var __ret = Internal.getParameters_0((__Instance + __PointerAdjustment), i);
                    CppSharp.Parser.AST.Parameter __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (CppSharp.Parser.AST.Parameter.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (CppSharp.Parser.AST.Parameter) CppSharp.Parser.AST.Parameter.NativeToManagedMap[__ret];
                    else __result0 = CppSharp.Parser.AST.Parameter.__CreateInstance(__ret);
                    return __result0;
                }

                public void addParameters(CppSharp.Parser.AST.Parameter s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    Internal.addParameters_0((__Instance + __PointerAdjustment), __arg0);
                }

                public void clearParameters()
                {
                    Internal.clearParameters_0((__Instance + __PointerAdjustment));
                }

                public string Mangled
                {
                    get
                    {
                        var __ret = Internal.getMangled_0((__Instance + __PointerAdjustment));
                        return Marshal.PtrToStringAnsi(__ret);
                    }

                    set
                    {
                        var __arg0 = Marshal.StringToHGlobalAnsi(value);
                        Internal.setMangled_0((__Instance + __PointerAdjustment), __arg0);
                        Marshal.FreeHGlobal(__arg0);
                    }
                }

                public string Signature
                {
                    get
                    {
                        var __ret = Internal.getSignature_0((__Instance + __PointerAdjustment));
                        return Marshal.PtrToStringAnsi(__ret);
                    }

                    set
                    {
                        var __arg0 = Marshal.StringToHGlobalAnsi(value);
                        Internal.setSignature_0((__Instance + __PointerAdjustment), __arg0);
                        Marshal.FreeHGlobal(__arg0);
                    }
                }

                public uint ParametersCount
                {
                    get
                    {
                        var __ret = Internal.getParametersCount_0((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                public CppSharp.Parser.AST.QualifiedType ReturnType
                {
                    get
                    {
                        return CppSharp.Parser.AST.QualifiedType.__CreateInstance(((Internal*) __Instance)->ReturnType);
                    }

                    set
                    {
                        ((Internal*) __Instance)->ReturnType = ReferenceEquals(value, null) ? new CppSharp.Parser.AST.QualifiedType.Internal() : *(CppSharp.Parser.AST.QualifiedType.Internal*) (value.__Instance);
                    }
                }

                public bool IsReturnIndirect
                {
                    get
                    {
                        return ((Internal*) __Instance)->IsReturnIndirect != 0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->IsReturnIndirect = (byte) (value ? 1 : 0);
                    }
                }

                public bool HasThisReturn
                {
                    get
                    {
                        return ((Internal*) __Instance)->HasThisReturn != 0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->HasThisReturn = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsVariadic
                {
                    get
                    {
                        return ((Internal*) __Instance)->IsVariadic != 0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->IsVariadic = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsInline
                {
                    get
                    {
                        return ((Internal*) __Instance)->IsInline != 0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->IsInline = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsPure
                {
                    get
                    {
                        return ((Internal*) __Instance)->IsPure != 0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->IsPure = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsDeleted
                {
                    get
                    {
                        return ((Internal*) __Instance)->IsDeleted != 0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->IsDeleted = (byte) (value ? 1 : 0);
                    }
                }

                public CppSharp.Parser.AST.CXXOperatorKind OperatorKind
                {
                    get
                    {
                        return ((Internal*) __Instance)->OperatorKind;
                    }

                    set
                    {
                        ((Internal*) __Instance)->OperatorKind = value;
                    }
                }

                public CppSharp.Parser.AST.CallingConvention CallingConvention
                {
                    get
                    {
                        return ((Internal*) __Instance)->CallingConvention;
                    }

                    set
                    {
                        ((Internal*) __Instance)->CallingConvention = value;
                    }
                }

                public CppSharp.Parser.AST.FunctionTemplateSpecialization SpecializationInfo
                {
                    get
                    {
                        CppSharp.Parser.AST.FunctionTemplateSpecialization __result0;
                        if (((Internal*) __Instance)->SpecializationInfo == IntPtr.Zero) __result0 = null;
                        else if (CppSharp.Parser.AST.FunctionTemplateSpecialization.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->SpecializationInfo))
                            __result0 = (CppSharp.Parser.AST.FunctionTemplateSpecialization) CppSharp.Parser.AST.FunctionTemplateSpecialization.NativeToManagedMap[((Internal*) __Instance)->SpecializationInfo];
                        else __result0 = CppSharp.Parser.AST.FunctionTemplateSpecialization.__CreateInstance(((Internal*) __Instance)->SpecializationInfo);
                        return __result0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->SpecializationInfo = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public CppSharp.Parser.AST.Function InstantiatedFrom
                {
                    get
                    {
                        CppSharp.Parser.AST.Function __result0;
                        if (((Internal*) __Instance)->InstantiatedFrom == IntPtr.Zero) __result0 = null;
                        else if (CppSharp.Parser.AST.Function.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->InstantiatedFrom))
                            __result0 = (CppSharp.Parser.AST.Function) CppSharp.Parser.AST.Function.NativeToManagedMap[((Internal*) __Instance)->InstantiatedFrom];
                        else __result0 = CppSharp.Parser.AST.Function.__CreateInstance(((Internal*) __Instance)->InstantiatedFrom);
                        return __result0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->InstantiatedFrom = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }
            }

            public unsafe partial class Method : CppSharp.Parser.AST.Function, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 368)]
                public new partial struct Internal
                {
                    [FieldOffset(0)]
                    public CppSharp.Parser.AST.DeclarationKind Kind;

                    [FieldOffset(4)]
                    public CppSharp.Parser.AST.AccessSpecifier Access;

                    [FieldOffset(8)]
                    public global::System.IntPtr _Namespace;

                    [FieldOffset(16)]
                    public CppSharp.Parser.SourceLocation.Internal Location;

                    [FieldOffset(20)]
                    public int LineNumberStart;

                    [FieldOffset(24)]
                    public int LineNumberEnd;

                    [FieldOffset(128)]
                    public byte IsIncomplete;

                    [FieldOffset(129)]
                    public byte IsDependent;

                    [FieldOffset(130)]
                    public byte IsImplicit;

                    [FieldOffset(136)]
                    public global::System.IntPtr CompleteDeclaration;

                    [FieldOffset(144)]
                    public uint DefinitionOrder;

                    [FieldOffset(176)]
                    public global::System.IntPtr OriginalPtr;

                    [FieldOffset(184)]
                    public global::System.IntPtr Comment;

                    [FieldOffset(192)]
                    public CppSharp.Parser.AST.QualifiedType.Internal ReturnType;

                    [FieldOffset(208)]
                    public byte IsReturnIndirect;

                    [FieldOffset(209)]
                    public byte HasThisReturn;

                    [FieldOffset(210)]
                    public byte IsVariadic;

                    [FieldOffset(211)]
                    public byte IsInline;

                    [FieldOffset(212)]
                    public byte IsPure;

                    [FieldOffset(213)]
                    public byte IsDeleted;

                    [FieldOffset(216)]
                    public CppSharp.Parser.AST.CXXOperatorKind OperatorKind;

                    [FieldOffset(288)]
                    public CppSharp.Parser.AST.CallingConvention CallingConvention;

                    [FieldOffset(320)]
                    public global::System.IntPtr SpecializationInfo;

                    [FieldOffset(328)]
                    public global::System.IntPtr InstantiatedFrom;

                    [FieldOffset(336)]
                    public byte IsVirtual;

                    [FieldOffset(337)]
                    public byte IsStatic;

                    [FieldOffset(338)]
                    public byte IsConst;

                    [FieldOffset(339)]
                    public byte IsExplicit;

                    [FieldOffset(340)]
                    public byte IsOverride;

                    [FieldOffset(344)]
                    public CppSharp.Parser.AST.CXXMethodKind MethodKind;

                    [FieldOffset(348)]
                    public byte IsDefaultConstructor;

                    [FieldOffset(349)]
                    public byte IsCopyConstructor;

                    [FieldOffset(350)]
                    public byte IsMoveConstructor;

                    [FieldOffset(352)]
                    public CppSharp.Parser.AST.QualifiedType.Internal ConversionType;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0Method@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0Method@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1Method@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor_0(global::System.IntPtr instance, int delete);
                }

                public static new Method __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new Method(native.ToPointer(), skipVTables);
                }

                public static Method __CreateInstance(Method.Internal native, bool skipVTables = false)
                {
                    return new Method(native, skipVTables);
                }

                private static void* __CopyValue(Method.Internal native)
                {
                    var ret = Marshal.AllocHGlobal(368);
                    CppSharp.Parser.AST.Method.Internal.cctor_1(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private Method(Method.Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected Method(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public Method()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(368);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_0((__Instance + __PointerAdjustment));
                }

                public Method(CppSharp.Parser.AST.Method _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(368);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
                }

                protected override void Dispose(bool disposing)
                {
                    CppSharp.Parser.AST.Declaration __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    Internal.dtor_0((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public bool IsVirtual
                {
                    get
                    {
                        return ((Internal*) __Instance)->IsVirtual != 0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->IsVirtual = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsStatic
                {
                    get
                    {
                        return ((Internal*) __Instance)->IsStatic != 0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->IsStatic = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsConst
                {
                    get
                    {
                        return ((Internal*) __Instance)->IsConst != 0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->IsConst = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsExplicit
                {
                    get
                    {
                        return ((Internal*) __Instance)->IsExplicit != 0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->IsExplicit = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsOverride
                {
                    get
                    {
                        return ((Internal*) __Instance)->IsOverride != 0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->IsOverride = (byte) (value ? 1 : 0);
                    }
                }

                public CppSharp.Parser.AST.CXXMethodKind MethodKind
                {
                    get
                    {
                        return ((Internal*) __Instance)->MethodKind;
                    }

                    set
                    {
                        ((Internal*) __Instance)->MethodKind = value;
                    }
                }

                public bool IsDefaultConstructor
                {
                    get
                    {
                        return ((Internal*) __Instance)->IsDefaultConstructor != 0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->IsDefaultConstructor = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsCopyConstructor
                {
                    get
                    {
                        return ((Internal*) __Instance)->IsCopyConstructor != 0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->IsCopyConstructor = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsMoveConstructor
                {
                    get
                    {
                        return ((Internal*) __Instance)->IsMoveConstructor != 0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->IsMoveConstructor = (byte) (value ? 1 : 0);
                    }
                }

                public CppSharp.Parser.AST.QualifiedType ConversionType
                {
                    get
                    {
                        return CppSharp.Parser.AST.QualifiedType.__CreateInstance(((Internal*) __Instance)->ConversionType);
                    }

                    set
                    {
                        ((Internal*) __Instance)->ConversionType = ReferenceEquals(value, null) ? new CppSharp.Parser.AST.QualifiedType.Internal() : *(CppSharp.Parser.AST.QualifiedType.Internal*) (value.__Instance);
                    }
                }
            }

            public unsafe partial class Enumeration : CppSharp.Parser.AST.DeclarationContext, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 480)]
                public new partial struct Internal
                {
                    [FieldOffset(0)]
                    public CppSharp.Parser.AST.DeclarationKind Kind;

                    [FieldOffset(4)]
                    public CppSharp.Parser.AST.AccessSpecifier Access;

                    [FieldOffset(8)]
                    public global::System.IntPtr _Namespace;

                    [FieldOffset(16)]
                    public CppSharp.Parser.SourceLocation.Internal Location;

                    [FieldOffset(20)]
                    public int LineNumberStart;

                    [FieldOffset(24)]
                    public int LineNumberEnd;

                    [FieldOffset(128)]
                    public byte IsIncomplete;

                    [FieldOffset(129)]
                    public byte IsDependent;

                    [FieldOffset(130)]
                    public byte IsImplicit;

                    [FieldOffset(136)]
                    public global::System.IntPtr CompleteDeclaration;

                    [FieldOffset(144)]
                    public uint DefinitionOrder;

                    [FieldOffset(176)]
                    public global::System.IntPtr OriginalPtr;

                    [FieldOffset(184)]
                    public global::System.IntPtr Comment;

                    [FieldOffset(424)]
                    public byte IsAnonymous;

                    [FieldOffset(432)]
                    public CppSharp.Parser.AST.Enumeration.EnumModifiers Modifiers;

                    [FieldOffset(440)]
                    public global::System.IntPtr Type;

                    [FieldOffset(448)]
                    public global::System.IntPtr BuiltinType;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0Enumeration@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0Enumeration@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1Enumeration@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor_0(global::System.IntPtr instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getItems@Enumeration@AST@CppParser@CppSharp@@QEAAPEAVItem@1234@I@Z")]
                    internal static extern global::System.IntPtr getItems_0(global::System.IntPtr instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?addItems@Enumeration@AST@CppParser@CppSharp@@QEAAXAEAPEAVItem@1234@@Z")]
                    internal static extern void addItems_0(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?clearItems@Enumeration@AST@CppParser@CppSharp@@QEAAXXZ")]
                    internal static extern void clearItems_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getItemsCount@Enumeration@AST@CppParser@CppSharp@@QEAAIXZ")]
                    internal static extern uint getItemsCount_0(global::System.IntPtr instance);
                }

                [Flags]
                public enum EnumModifiers
                {
                    Anonymous = 1,
                    Scoped = 2,
                    Flags = 4
                }

                public unsafe partial class Item : CppSharp.Parser.AST.Declaration, IDisposable
                {
                    [StructLayout(LayoutKind.Explicit, Size = 232)]
                    public new partial struct Internal
                    {
                        [FieldOffset(0)]
                        public CppSharp.Parser.AST.DeclarationKind Kind;

                        [FieldOffset(4)]
                        public CppSharp.Parser.AST.AccessSpecifier Access;

                        [FieldOffset(8)]
                        public global::System.IntPtr _Namespace;

                        [FieldOffset(16)]
                        public CppSharp.Parser.SourceLocation.Internal Location;

                        [FieldOffset(20)]
                        public int LineNumberStart;

                        [FieldOffset(24)]
                        public int LineNumberEnd;

                        [FieldOffset(128)]
                        public byte IsIncomplete;

                        [FieldOffset(129)]
                        public byte IsDependent;

                        [FieldOffset(130)]
                        public byte IsImplicit;

                        [FieldOffset(136)]
                        public global::System.IntPtr CompleteDeclaration;

                        [FieldOffset(144)]
                        public uint DefinitionOrder;

                        [FieldOffset(176)]
                        public global::System.IntPtr OriginalPtr;

                        [FieldOffset(184)]
                        public global::System.IntPtr Comment;

                        [FieldOffset(224)]
                        public ulong Value;

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="??0Item@Enumeration@AST@CppParser@CppSharp@@QEAA@XZ")]
                        internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="??0Item@Enumeration@AST@CppParser@CppSharp@@QEAA@AEBV01234@@Z")]
                        internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="??1Item@Enumeration@AST@CppParser@CppSharp@@QEAA@XZ")]
                        internal static extern void dtor_0(global::System.IntPtr instance, int delete);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="?getExpression@Item@Enumeration@AST@CppParser@CppSharp@@QEAAPEBDXZ")]
                        internal static extern global::System.IntPtr getExpression_0(global::System.IntPtr instance);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="?setExpression@Item@Enumeration@AST@CppParser@CppSharp@@QEAAXPEBD@Z")]
                        internal static extern void setExpression_0(global::System.IntPtr instance, global::System.IntPtr s);
                    }

                    public static new Item __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                    {
                        return new Item(native.ToPointer(), skipVTables);
                    }

                    public static Item __CreateInstance(Item.Internal native, bool skipVTables = false)
                    {
                        return new Item(native, skipVTables);
                    }

                    private static void* __CopyValue(Item.Internal native)
                    {
                        var ret = Marshal.AllocHGlobal(232);
                        CppSharp.Parser.AST.Enumeration.Item.Internal.cctor_1(ret, new global::System.IntPtr(&native));
                        return ret.ToPointer();
                    }

                    private Item(Item.Internal native, bool skipVTables = false)
                        : this(__CopyValue(native), skipVTables)
                    {
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                    }

                    protected Item(void* native, bool skipVTables = false)
                        : base((void*) null)
                    {
                        __PointerAdjustment = 0;
                        if (native == null)
                            return;
                        __Instance = new global::System.IntPtr(native);
                    }

                    public Item()
                        : this((void*) null)
                    {
                        __Instance = Marshal.AllocHGlobal(232);
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                        Internal.ctor_0((__Instance + __PointerAdjustment));
                    }

                    public Item(CppSharp.Parser.AST.Enumeration.Item _0)
                        : this((void*) null)
                    {
                        __Instance = Marshal.AllocHGlobal(232);
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                        if (ReferenceEquals(_0, null))
                            throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                        var __arg0 = _0.__Instance;
                        Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
                    }

                    protected override void Dispose(bool disposing)
                    {
                        CppSharp.Parser.AST.Declaration __dummy;
                        NativeToManagedMap.TryRemove(__Instance, out __dummy);
                        Internal.dtor_0((__Instance + __PointerAdjustment), 0);
                        if (__ownsNativeInstance)
                            Marshal.FreeHGlobal(__Instance);
                    }

                    public string Expression
                    {
                        get
                        {
                            var __ret = Internal.getExpression_0((__Instance + __PointerAdjustment));
                            return Marshal.PtrToStringAnsi(__ret);
                        }

                        set
                        {
                            var __arg0 = Marshal.StringToHGlobalAnsi(value);
                            Internal.setExpression_0((__Instance + __PointerAdjustment), __arg0);
                            Marshal.FreeHGlobal(__arg0);
                        }
                    }

                    public ulong Value
                    {
                        get
                        {
                            return ((Internal*) __Instance)->Value;
                        }

                        set
                        {
                            ((Internal*) __Instance)->Value = value;
                        }
                    }
                }

                public static new Enumeration __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new Enumeration(native.ToPointer(), skipVTables);
                }

                public static Enumeration __CreateInstance(Enumeration.Internal native, bool skipVTables = false)
                {
                    return new Enumeration(native, skipVTables);
                }

                private static void* __CopyValue(Enumeration.Internal native)
                {
                    var ret = Marshal.AllocHGlobal(480);
                    CppSharp.Parser.AST.Enumeration.Internal.cctor_1(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private Enumeration(Enumeration.Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected Enumeration(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public Enumeration()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(480);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_0((__Instance + __PointerAdjustment));
                }

                public Enumeration(CppSharp.Parser.AST.Enumeration _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(480);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
                }

                protected override void Dispose(bool disposing)
                {
                    CppSharp.Parser.AST.Declaration __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    Internal.dtor_0((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public CppSharp.Parser.AST.Enumeration.Item getItems(uint i)
                {
                    var __ret = Internal.getItems_0((__Instance + __PointerAdjustment), i);
                    CppSharp.Parser.AST.Enumeration.Item __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (CppSharp.Parser.AST.Enumeration.Item.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (CppSharp.Parser.AST.Enumeration.Item) CppSharp.Parser.AST.Enumeration.Item.NativeToManagedMap[__ret];
                    else __result0 = CppSharp.Parser.AST.Enumeration.Item.__CreateInstance(__ret);
                    return __result0;
                }

                public void addItems(CppSharp.Parser.AST.Enumeration.Item s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    Internal.addItems_0((__Instance + __PointerAdjustment), __arg0);
                }

                public void clearItems()
                {
                    Internal.clearItems_0((__Instance + __PointerAdjustment));
                }

                public uint ItemsCount
                {
                    get
                    {
                        var __ret = Internal.getItemsCount_0((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                public CppSharp.Parser.AST.Enumeration.EnumModifiers Modifiers
                {
                    get
                    {
                        return ((Internal*) __Instance)->Modifiers;
                    }

                    set
                    {
                        ((Internal*) __Instance)->Modifiers = value;
                    }
                }

                public CppSharp.Parser.AST.Type Type
                {
                    get
                    {
                        CppSharp.Parser.AST.Type __result0;
                        if (((Internal*) __Instance)->Type == IntPtr.Zero) __result0 = null;
                        else if (CppSharp.Parser.AST.Type.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->Type))
                            __result0 = (CppSharp.Parser.AST.Type) CppSharp.Parser.AST.Type.NativeToManagedMap[((Internal*) __Instance)->Type];
                        else __result0 = CppSharp.Parser.AST.Type.__CreateInstance(((Internal*) __Instance)->Type);
                        return __result0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->Type = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public CppSharp.Parser.AST.BuiltinType BuiltinType
                {
                    get
                    {
                        CppSharp.Parser.AST.BuiltinType __result0;
                        if (((Internal*) __Instance)->BuiltinType == IntPtr.Zero) __result0 = null;
                        else if (CppSharp.Parser.AST.BuiltinType.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->BuiltinType))
                            __result0 = (CppSharp.Parser.AST.BuiltinType) CppSharp.Parser.AST.BuiltinType.NativeToManagedMap[((Internal*) __Instance)->BuiltinType];
                        else __result0 = CppSharp.Parser.AST.BuiltinType.__CreateInstance(((Internal*) __Instance)->BuiltinType);
                        return __result0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->BuiltinType = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }
            }

            public unsafe partial class Variable : CppSharp.Parser.AST.Declaration, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 240)]
                public new partial struct Internal
                {
                    [FieldOffset(0)]
                    public CppSharp.Parser.AST.DeclarationKind Kind;

                    [FieldOffset(4)]
                    public CppSharp.Parser.AST.AccessSpecifier Access;

                    [FieldOffset(8)]
                    public global::System.IntPtr _Namespace;

                    [FieldOffset(16)]
                    public CppSharp.Parser.SourceLocation.Internal Location;

                    [FieldOffset(20)]
                    public int LineNumberStart;

                    [FieldOffset(24)]
                    public int LineNumberEnd;

                    [FieldOffset(128)]
                    public byte IsIncomplete;

                    [FieldOffset(129)]
                    public byte IsDependent;

                    [FieldOffset(130)]
                    public byte IsImplicit;

                    [FieldOffset(136)]
                    public global::System.IntPtr CompleteDeclaration;

                    [FieldOffset(144)]
                    public uint DefinitionOrder;

                    [FieldOffset(176)]
                    public global::System.IntPtr OriginalPtr;

                    [FieldOffset(184)]
                    public global::System.IntPtr Comment;

                    [FieldOffset(224)]
                    public CppSharp.Parser.AST.QualifiedType.Internal QualifiedType;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0Variable@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0Variable@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1Variable@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor_0(global::System.IntPtr instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getMangled@Variable@AST@CppParser@CppSharp@@QEAAPEBDXZ")]
                    internal static extern global::System.IntPtr getMangled_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?setMangled@Variable@AST@CppParser@CppSharp@@QEAAXPEBD@Z")]
                    internal static extern void setMangled_0(global::System.IntPtr instance, global::System.IntPtr s);
                }

                public static new Variable __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new Variable(native.ToPointer(), skipVTables);
                }

                public static Variable __CreateInstance(Variable.Internal native, bool skipVTables = false)
                {
                    return new Variable(native, skipVTables);
                }

                private static void* __CopyValue(Variable.Internal native)
                {
                    var ret = Marshal.AllocHGlobal(240);
                    CppSharp.Parser.AST.Variable.Internal.cctor_1(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private Variable(Variable.Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected Variable(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public Variable()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(240);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_0((__Instance + __PointerAdjustment));
                }

                public Variable(CppSharp.Parser.AST.Variable _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(240);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
                }

                protected override void Dispose(bool disposing)
                {
                    CppSharp.Parser.AST.Declaration __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    Internal.dtor_0((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public string Mangled
                {
                    get
                    {
                        var __ret = Internal.getMangled_0((__Instance + __PointerAdjustment));
                        return Marshal.PtrToStringAnsi(__ret);
                    }

                    set
                    {
                        var __arg0 = Marshal.StringToHGlobalAnsi(value);
                        Internal.setMangled_0((__Instance + __PointerAdjustment), __arg0);
                        Marshal.FreeHGlobal(__arg0);
                    }
                }

                public CppSharp.Parser.AST.QualifiedType QualifiedType
                {
                    get
                    {
                        return CppSharp.Parser.AST.QualifiedType.__CreateInstance(((Internal*) __Instance)->QualifiedType);
                    }

                    set
                    {
                        ((Internal*) __Instance)->QualifiedType = ReferenceEquals(value, null) ? new CppSharp.Parser.AST.QualifiedType.Internal() : *(CppSharp.Parser.AST.QualifiedType.Internal*) (value.__Instance);
                    }
                }
            }

            public unsafe partial class BaseClassSpecifier : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 24)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public CppSharp.Parser.AST.AccessSpecifier Access;

                    [FieldOffset(4)]
                    public byte IsVirtual;

                    [FieldOffset(8)]
                    public global::System.IntPtr Type;

                    [FieldOffset(16)]
                    public int Offset;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0BaseClassSpecifier@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0BaseClassSpecifier@AST@CppParser@CppSharp@@QEAA@AEBU0123@@Z")]
                    internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                protected int __PointerAdjustment;
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, BaseClassSpecifier> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, BaseClassSpecifier>();
                protected void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                public static BaseClassSpecifier __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new BaseClassSpecifier(native.ToPointer(), skipVTables);
                }

                public static BaseClassSpecifier __CreateInstance(BaseClassSpecifier.Internal native, bool skipVTables = false)
                {
                    return new BaseClassSpecifier(native, skipVTables);
                }

                private static void* __CopyValue(BaseClassSpecifier.Internal native)
                {
                    var ret = Marshal.AllocHGlobal(24);
                    *(BaseClassSpecifier.Internal*) ret = native;
                    return ret.ToPointer();
                }

                private BaseClassSpecifier(BaseClassSpecifier.Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected BaseClassSpecifier(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public BaseClassSpecifier()
                {
                    __Instance = Marshal.AllocHGlobal(24);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_0((__Instance + __PointerAdjustment));
                }

                public BaseClassSpecifier(CppSharp.Parser.AST.BaseClassSpecifier _0)
                {
                    __Instance = Marshal.AllocHGlobal(24);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((BaseClassSpecifier.Internal*) __Instance) = *((BaseClassSpecifier.Internal*) _0.__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    CppSharp.Parser.AST.BaseClassSpecifier __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public CppSharp.Parser.AST.AccessSpecifier Access
                {
                    get
                    {
                        return ((Internal*) __Instance)->Access;
                    }

                    set
                    {
                        ((Internal*) __Instance)->Access = value;
                    }
                }

                public bool IsVirtual
                {
                    get
                    {
                        return ((Internal*) __Instance)->IsVirtual != 0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->IsVirtual = (byte) (value ? 1 : 0);
                    }
                }

                public CppSharp.Parser.AST.Type Type
                {
                    get
                    {
                        CppSharp.Parser.AST.Type __result0;
                        if (((Internal*) __Instance)->Type == IntPtr.Zero) __result0 = null;
                        else if (CppSharp.Parser.AST.Type.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->Type))
                            __result0 = (CppSharp.Parser.AST.Type) CppSharp.Parser.AST.Type.NativeToManagedMap[((Internal*) __Instance)->Type];
                        else __result0 = CppSharp.Parser.AST.Type.__CreateInstance(((Internal*) __Instance)->Type);
                        return __result0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->Type = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public int Offset
                {
                    get
                    {
                        return ((Internal*) __Instance)->Offset;
                    }

                    set
                    {
                        ((Internal*) __Instance)->Offset = value;
                    }
                }
            }

            public unsafe partial class Field : CppSharp.Parser.AST.Declaration, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 224)]
                public new partial struct Internal
                {
                    [FieldOffset(0)]
                    public CppSharp.Parser.AST.DeclarationKind Kind;

                    [FieldOffset(4)]
                    public CppSharp.Parser.AST.AccessSpecifier Access;

                    [FieldOffset(8)]
                    public global::System.IntPtr _Namespace;

                    [FieldOffset(16)]
                    public CppSharp.Parser.SourceLocation.Internal Location;

                    [FieldOffset(20)]
                    public int LineNumberStart;

                    [FieldOffset(24)]
                    public int LineNumberEnd;

                    [FieldOffset(128)]
                    public byte IsIncomplete;

                    [FieldOffset(129)]
                    public byte IsDependent;

                    [FieldOffset(130)]
                    public byte IsImplicit;

                    [FieldOffset(136)]
                    public global::System.IntPtr CompleteDeclaration;

                    [FieldOffset(144)]
                    public uint DefinitionOrder;

                    [FieldOffset(176)]
                    public global::System.IntPtr OriginalPtr;

                    [FieldOffset(184)]
                    public global::System.IntPtr Comment;

                    [FieldOffset(192)]
                    public CppSharp.Parser.AST.QualifiedType.Internal QualifiedType;

                    [FieldOffset(208)]
                    public global::System.IntPtr Class;

                    [FieldOffset(216)]
                    public byte IsBitField;

                    [FieldOffset(220)]
                    public uint BitWidth;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0Field@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0Field@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1Field@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor_0(global::System.IntPtr instance, int delete);
                }

                public static new Field __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new Field(native.ToPointer(), skipVTables);
                }

                public static Field __CreateInstance(Field.Internal native, bool skipVTables = false)
                {
                    return new Field(native, skipVTables);
                }

                private static void* __CopyValue(Field.Internal native)
                {
                    var ret = Marshal.AllocHGlobal(224);
                    CppSharp.Parser.AST.Field.Internal.cctor_1(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private Field(Field.Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected Field(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public Field()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(224);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_0((__Instance + __PointerAdjustment));
                }

                public Field(CppSharp.Parser.AST.Field _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(224);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
                }

                protected override void Dispose(bool disposing)
                {
                    CppSharp.Parser.AST.Declaration __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    Internal.dtor_0((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public CppSharp.Parser.AST.QualifiedType QualifiedType
                {
                    get
                    {
                        return CppSharp.Parser.AST.QualifiedType.__CreateInstance(((Internal*) __Instance)->QualifiedType);
                    }

                    set
                    {
                        ((Internal*) __Instance)->QualifiedType = ReferenceEquals(value, null) ? new CppSharp.Parser.AST.QualifiedType.Internal() : *(CppSharp.Parser.AST.QualifiedType.Internal*) (value.__Instance);
                    }
                }

                public CppSharp.Parser.AST.Class Class
                {
                    get
                    {
                        CppSharp.Parser.AST.Class __result0;
                        if (((Internal*) __Instance)->Class == IntPtr.Zero) __result0 = null;
                        else if (CppSharp.Parser.AST.Class.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->Class))
                            __result0 = (CppSharp.Parser.AST.Class) CppSharp.Parser.AST.Class.NativeToManagedMap[((Internal*) __Instance)->Class];
                        else __result0 = CppSharp.Parser.AST.Class.__CreateInstance(((Internal*) __Instance)->Class);
                        return __result0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->Class = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public bool IsBitField
                {
                    get
                    {
                        return ((Internal*) __Instance)->IsBitField != 0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->IsBitField = (byte) (value ? 1 : 0);
                    }
                }

                public uint BitWidth
                {
                    get
                    {
                        return ((Internal*) __Instance)->BitWidth;
                    }

                    set
                    {
                        ((Internal*) __Instance)->BitWidth = value;
                    }
                }
            }

            public unsafe partial class AccessSpecifierDecl : CppSharp.Parser.AST.Declaration, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 192)]
                public new partial struct Internal
                {
                    [FieldOffset(0)]
                    public CppSharp.Parser.AST.DeclarationKind Kind;

                    [FieldOffset(4)]
                    public CppSharp.Parser.AST.AccessSpecifier Access;

                    [FieldOffset(8)]
                    public global::System.IntPtr _Namespace;

                    [FieldOffset(16)]
                    public CppSharp.Parser.SourceLocation.Internal Location;

                    [FieldOffset(20)]
                    public int LineNumberStart;

                    [FieldOffset(24)]
                    public int LineNumberEnd;

                    [FieldOffset(128)]
                    public byte IsIncomplete;

                    [FieldOffset(129)]
                    public byte IsDependent;

                    [FieldOffset(130)]
                    public byte IsImplicit;

                    [FieldOffset(136)]
                    public global::System.IntPtr CompleteDeclaration;

                    [FieldOffset(144)]
                    public uint DefinitionOrder;

                    [FieldOffset(176)]
                    public global::System.IntPtr OriginalPtr;

                    [FieldOffset(184)]
                    public global::System.IntPtr Comment;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0AccessSpecifierDecl@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0AccessSpecifierDecl@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1AccessSpecifierDecl@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor_0(global::System.IntPtr instance, int delete);
                }

                public static new AccessSpecifierDecl __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new AccessSpecifierDecl(native.ToPointer(), skipVTables);
                }

                public static AccessSpecifierDecl __CreateInstance(AccessSpecifierDecl.Internal native, bool skipVTables = false)
                {
                    return new AccessSpecifierDecl(native, skipVTables);
                }

                private static void* __CopyValue(AccessSpecifierDecl.Internal native)
                {
                    var ret = Marshal.AllocHGlobal(192);
                    CppSharp.Parser.AST.AccessSpecifierDecl.Internal.cctor_1(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private AccessSpecifierDecl(AccessSpecifierDecl.Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected AccessSpecifierDecl(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public AccessSpecifierDecl()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(192);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_0((__Instance + __PointerAdjustment));
                }

                public AccessSpecifierDecl(CppSharp.Parser.AST.AccessSpecifierDecl _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(192);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
                }

                protected override void Dispose(bool disposing)
                {
                    CppSharp.Parser.AST.Declaration __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    Internal.dtor_0((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }
            }

            public unsafe partial class Class : CppSharp.Parser.AST.DeclarationContext, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 552)]
                public new partial struct Internal
                {
                    [FieldOffset(0)]
                    public CppSharp.Parser.AST.DeclarationKind Kind;

                    [FieldOffset(4)]
                    public CppSharp.Parser.AST.AccessSpecifier Access;

                    [FieldOffset(8)]
                    public global::System.IntPtr _Namespace;

                    [FieldOffset(16)]
                    public CppSharp.Parser.SourceLocation.Internal Location;

                    [FieldOffset(20)]
                    public int LineNumberStart;

                    [FieldOffset(24)]
                    public int LineNumberEnd;

                    [FieldOffset(128)]
                    public byte IsIncomplete;

                    [FieldOffset(129)]
                    public byte IsDependent;

                    [FieldOffset(130)]
                    public byte IsImplicit;

                    [FieldOffset(136)]
                    public global::System.IntPtr CompleteDeclaration;

                    [FieldOffset(144)]
                    public uint DefinitionOrder;

                    [FieldOffset(176)]
                    public global::System.IntPtr OriginalPtr;

                    [FieldOffset(184)]
                    public global::System.IntPtr Comment;

                    [FieldOffset(424)]
                    public byte IsAnonymous;

                    [FieldOffset(528)]
                    public byte IsPOD;

                    [FieldOffset(529)]
                    public byte IsAbstract;

                    [FieldOffset(530)]
                    public byte IsUnion;

                    [FieldOffset(531)]
                    public byte IsDynamic;

                    [FieldOffset(532)]
                    public byte IsPolymorphic;

                    [FieldOffset(533)]
                    public byte HasNonTrivialDefaultConstructor;

                    [FieldOffset(534)]
                    public byte HasNonTrivialCopyConstructor;

                    [FieldOffset(535)]
                    public byte HasNonTrivialDestructor;

                    [FieldOffset(536)]
                    public byte IsExternCContext;

                    [FieldOffset(544)]
                    public global::System.IntPtr Layout;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0Class@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0Class@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1Class@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor_0(global::System.IntPtr instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getBases@Class@AST@CppParser@CppSharp@@QEAAPEAUBaseClassSpecifier@234@I@Z")]
                    internal static extern global::System.IntPtr getBases_0(global::System.IntPtr instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?addBases@Class@AST@CppParser@CppSharp@@QEAAXAEAPEAUBaseClassSpecifier@234@@Z")]
                    internal static extern void addBases_0(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?clearBases@Class@AST@CppParser@CppSharp@@QEAAXXZ")]
                    internal static extern void clearBases_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getFields@Class@AST@CppParser@CppSharp@@QEAAPEAVField@234@I@Z")]
                    internal static extern global::System.IntPtr getFields_0(global::System.IntPtr instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?addFields@Class@AST@CppParser@CppSharp@@QEAAXAEAPEAVField@234@@Z")]
                    internal static extern void addFields_0(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?clearFields@Class@AST@CppParser@CppSharp@@QEAAXXZ")]
                    internal static extern void clearFields_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getMethods@Class@AST@CppParser@CppSharp@@QEAAPEAVMethod@234@I@Z")]
                    internal static extern global::System.IntPtr getMethods_0(global::System.IntPtr instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?addMethods@Class@AST@CppParser@CppSharp@@QEAAXAEAPEAVMethod@234@@Z")]
                    internal static extern void addMethods_0(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?clearMethods@Class@AST@CppParser@CppSharp@@QEAAXXZ")]
                    internal static extern void clearMethods_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getSpecifiers@Class@AST@CppParser@CppSharp@@QEAAPEAVAccessSpecifierDecl@234@I@Z")]
                    internal static extern global::System.IntPtr getSpecifiers_0(global::System.IntPtr instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?addSpecifiers@Class@AST@CppParser@CppSharp@@QEAAXAEAPEAVAccessSpecifierDecl@234@@Z")]
                    internal static extern void addSpecifiers_0(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?clearSpecifiers@Class@AST@CppParser@CppSharp@@QEAAXXZ")]
                    internal static extern void clearSpecifiers_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getBasesCount@Class@AST@CppParser@CppSharp@@QEAAIXZ")]
                    internal static extern uint getBasesCount_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getFieldsCount@Class@AST@CppParser@CppSharp@@QEAAIXZ")]
                    internal static extern uint getFieldsCount_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getMethodsCount@Class@AST@CppParser@CppSharp@@QEAAIXZ")]
                    internal static extern uint getMethodsCount_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getSpecifiersCount@Class@AST@CppParser@CppSharp@@QEAAIXZ")]
                    internal static extern uint getSpecifiersCount_0(global::System.IntPtr instance);
                }

                public static new Class __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new Class(native.ToPointer(), skipVTables);
                }

                public static Class __CreateInstance(Class.Internal native, bool skipVTables = false)
                {
                    return new Class(native, skipVTables);
                }

                private static void* __CopyValue(Class.Internal native)
                {
                    var ret = Marshal.AllocHGlobal(552);
                    CppSharp.Parser.AST.Class.Internal.cctor_1(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private Class(Class.Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected Class(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public Class()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(552);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_0((__Instance + __PointerAdjustment));
                }

                public Class(CppSharp.Parser.AST.Class _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(552);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
                }

                protected override void Dispose(bool disposing)
                {
                    CppSharp.Parser.AST.Declaration __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    Internal.dtor_0((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public CppSharp.Parser.AST.BaseClassSpecifier getBases(uint i)
                {
                    var __ret = Internal.getBases_0((__Instance + __PointerAdjustment), i);
                    CppSharp.Parser.AST.BaseClassSpecifier __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (CppSharp.Parser.AST.BaseClassSpecifier.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (CppSharp.Parser.AST.BaseClassSpecifier) CppSharp.Parser.AST.BaseClassSpecifier.NativeToManagedMap[__ret];
                    else __result0 = CppSharp.Parser.AST.BaseClassSpecifier.__CreateInstance(__ret);
                    return __result0;
                }

                public void addBases(CppSharp.Parser.AST.BaseClassSpecifier s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    Internal.addBases_0((__Instance + __PointerAdjustment), __arg0);
                }

                public void clearBases()
                {
                    Internal.clearBases_0((__Instance + __PointerAdjustment));
                }

                public CppSharp.Parser.AST.Field getFields(uint i)
                {
                    var __ret = Internal.getFields_0((__Instance + __PointerAdjustment), i);
                    CppSharp.Parser.AST.Field __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (CppSharp.Parser.AST.Field.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (CppSharp.Parser.AST.Field) CppSharp.Parser.AST.Field.NativeToManagedMap[__ret];
                    else __result0 = CppSharp.Parser.AST.Field.__CreateInstance(__ret);
                    return __result0;
                }

                public void addFields(CppSharp.Parser.AST.Field s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    Internal.addFields_0((__Instance + __PointerAdjustment), __arg0);
                }

                public void clearFields()
                {
                    Internal.clearFields_0((__Instance + __PointerAdjustment));
                }

                public CppSharp.Parser.AST.Method getMethods(uint i)
                {
                    var __ret = Internal.getMethods_0((__Instance + __PointerAdjustment), i);
                    CppSharp.Parser.AST.Method __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (CppSharp.Parser.AST.Method.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (CppSharp.Parser.AST.Method) CppSharp.Parser.AST.Method.NativeToManagedMap[__ret];
                    else __result0 = CppSharp.Parser.AST.Method.__CreateInstance(__ret);
                    return __result0;
                }

                public void addMethods(CppSharp.Parser.AST.Method s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    Internal.addMethods_0((__Instance + __PointerAdjustment), __arg0);
                }

                public void clearMethods()
                {
                    Internal.clearMethods_0((__Instance + __PointerAdjustment));
                }

                public CppSharp.Parser.AST.AccessSpecifierDecl getSpecifiers(uint i)
                {
                    var __ret = Internal.getSpecifiers_0((__Instance + __PointerAdjustment), i);
                    CppSharp.Parser.AST.AccessSpecifierDecl __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (CppSharp.Parser.AST.AccessSpecifierDecl.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (CppSharp.Parser.AST.AccessSpecifierDecl) CppSharp.Parser.AST.AccessSpecifierDecl.NativeToManagedMap[__ret];
                    else __result0 = CppSharp.Parser.AST.AccessSpecifierDecl.__CreateInstance(__ret);
                    return __result0;
                }

                public void addSpecifiers(CppSharp.Parser.AST.AccessSpecifierDecl s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    Internal.addSpecifiers_0((__Instance + __PointerAdjustment), __arg0);
                }

                public void clearSpecifiers()
                {
                    Internal.clearSpecifiers_0((__Instance + __PointerAdjustment));
                }

                public uint BasesCount
                {
                    get
                    {
                        var __ret = Internal.getBasesCount_0((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                public uint FieldsCount
                {
                    get
                    {
                        var __ret = Internal.getFieldsCount_0((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                public uint MethodsCount
                {
                    get
                    {
                        var __ret = Internal.getMethodsCount_0((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                public uint SpecifiersCount
                {
                    get
                    {
                        var __ret = Internal.getSpecifiersCount_0((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                public bool IsPOD
                {
                    get
                    {
                        return ((Internal*) __Instance)->IsPOD != 0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->IsPOD = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsAbstract
                {
                    get
                    {
                        return ((Internal*) __Instance)->IsAbstract != 0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->IsAbstract = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsUnion
                {
                    get
                    {
                        return ((Internal*) __Instance)->IsUnion != 0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->IsUnion = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsDynamic
                {
                    get
                    {
                        return ((Internal*) __Instance)->IsDynamic != 0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->IsDynamic = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsPolymorphic
                {
                    get
                    {
                        return ((Internal*) __Instance)->IsPolymorphic != 0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->IsPolymorphic = (byte) (value ? 1 : 0);
                    }
                }

                public bool HasNonTrivialDefaultConstructor
                {
                    get
                    {
                        return ((Internal*) __Instance)->HasNonTrivialDefaultConstructor != 0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->HasNonTrivialDefaultConstructor = (byte) (value ? 1 : 0);
                    }
                }

                public bool HasNonTrivialCopyConstructor
                {
                    get
                    {
                        return ((Internal*) __Instance)->HasNonTrivialCopyConstructor != 0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->HasNonTrivialCopyConstructor = (byte) (value ? 1 : 0);
                    }
                }

                public bool HasNonTrivialDestructor
                {
                    get
                    {
                        return ((Internal*) __Instance)->HasNonTrivialDestructor != 0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->HasNonTrivialDestructor = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsExternCContext
                {
                    get
                    {
                        return ((Internal*) __Instance)->IsExternCContext != 0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->IsExternCContext = (byte) (value ? 1 : 0);
                    }
                }

                public CppSharp.Parser.AST.ClassLayout Layout
                {
                    get
                    {
                        CppSharp.Parser.AST.ClassLayout __result0;
                        if (((Internal*) __Instance)->Layout == IntPtr.Zero) __result0 = null;
                        else if (CppSharp.Parser.AST.ClassLayout.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->Layout))
                            __result0 = (CppSharp.Parser.AST.ClassLayout) CppSharp.Parser.AST.ClassLayout.NativeToManagedMap[((Internal*) __Instance)->Layout];
                        else __result0 = CppSharp.Parser.AST.ClassLayout.__CreateInstance(((Internal*) __Instance)->Layout);
                        return __result0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->Layout = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }
            }

            public unsafe partial class Template : CppSharp.Parser.AST.Declaration, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 224)]
                public new partial struct Internal
                {
                    [FieldOffset(0)]
                    public CppSharp.Parser.AST.DeclarationKind Kind;

                    [FieldOffset(4)]
                    public CppSharp.Parser.AST.AccessSpecifier Access;

                    [FieldOffset(8)]
                    public global::System.IntPtr _Namespace;

                    [FieldOffset(16)]
                    public CppSharp.Parser.SourceLocation.Internal Location;

                    [FieldOffset(20)]
                    public int LineNumberStart;

                    [FieldOffset(24)]
                    public int LineNumberEnd;

                    [FieldOffset(128)]
                    public byte IsIncomplete;

                    [FieldOffset(129)]
                    public byte IsDependent;

                    [FieldOffset(130)]
                    public byte IsImplicit;

                    [FieldOffset(136)]
                    public global::System.IntPtr CompleteDeclaration;

                    [FieldOffset(144)]
                    public uint DefinitionOrder;

                    [FieldOffset(176)]
                    public global::System.IntPtr OriginalPtr;

                    [FieldOffset(184)]
                    public global::System.IntPtr Comment;

                    [FieldOffset(192)]
                    public global::System.IntPtr TemplatedDecl;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0Template@AST@CppParser@CppSharp@@QEAA@W4DeclarationKind@123@@Z")]
                    internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance, CppSharp.Parser.AST.DeclarationKind kind);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0Template@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor_1(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0Template@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor_3(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1Template@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor_0(global::System.IntPtr instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getParameters@Template@AST@CppParser@CppSharp@@QEAAPEAVDeclaration@234@I@Z")]
                    internal static extern global::System.IntPtr getParameters_0(global::System.IntPtr instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?addParameters@Template@AST@CppParser@CppSharp@@QEAAXAEAPEAVDeclaration@234@@Z")]
                    internal static extern void addParameters_0(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?clearParameters@Template@AST@CppParser@CppSharp@@QEAAXXZ")]
                    internal static extern void clearParameters_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getParametersCount@Template@AST@CppParser@CppSharp@@QEAAIXZ")]
                    internal static extern uint getParametersCount_0(global::System.IntPtr instance);
                }

                public static new Template __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new Template(native.ToPointer(), skipVTables);
                }

                public static Template __CreateInstance(Template.Internal native, bool skipVTables = false)
                {
                    return new Template(native, skipVTables);
                }

                private static void* __CopyValue(Template.Internal native)
                {
                    var ret = Marshal.AllocHGlobal(224);
                    CppSharp.Parser.AST.Template.Internal.cctor_3(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private Template(Template.Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected Template(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public Template(CppSharp.Parser.AST.DeclarationKind kind)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(224);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    var __arg0 = kind;
                    Internal.ctor_0((__Instance + __PointerAdjustment), __arg0);
                }

                public Template()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(224);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_1((__Instance + __PointerAdjustment));
                }

                public Template(CppSharp.Parser.AST.Template _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(224);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    Internal.cctor_3((__Instance + __PointerAdjustment), __arg0);
                }

                protected override void Dispose(bool disposing)
                {
                    CppSharp.Parser.AST.Declaration __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    Internal.dtor_0((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public CppSharp.Parser.AST.Declaration getParameters(uint i)
                {
                    var __ret = Internal.getParameters_0((__Instance + __PointerAdjustment), i);
                    CppSharp.Parser.AST.Declaration __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (CppSharp.Parser.AST.Declaration.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (CppSharp.Parser.AST.Declaration) CppSharp.Parser.AST.Declaration.NativeToManagedMap[__ret];
                    else __result0 = CppSharp.Parser.AST.Declaration.__CreateInstance(__ret);
                    return __result0;
                }

                public void addParameters(CppSharp.Parser.AST.Declaration s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    Internal.addParameters_0((__Instance + __PointerAdjustment), __arg0);
                }

                public void clearParameters()
                {
                    Internal.clearParameters_0((__Instance + __PointerAdjustment));
                }

                public uint ParametersCount
                {
                    get
                    {
                        var __ret = Internal.getParametersCount_0((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                public CppSharp.Parser.AST.Declaration TemplatedDecl
                {
                    get
                    {
                        CppSharp.Parser.AST.Declaration __result0;
                        if (((Internal*) __Instance)->TemplatedDecl == IntPtr.Zero) __result0 = null;
                        else if (CppSharp.Parser.AST.Declaration.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->TemplatedDecl))
                            __result0 = (CppSharp.Parser.AST.Declaration) CppSharp.Parser.AST.Declaration.NativeToManagedMap[((Internal*) __Instance)->TemplatedDecl];
                        else __result0 = CppSharp.Parser.AST.Declaration.__CreateInstance(((Internal*) __Instance)->TemplatedDecl);
                        return __result0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->TemplatedDecl = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }
            }

            public unsafe partial class TypeAliasTemplate : CppSharp.Parser.AST.Template, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 224)]
                public new partial struct Internal
                {
                    [FieldOffset(0)]
                    public CppSharp.Parser.AST.DeclarationKind Kind;

                    [FieldOffset(4)]
                    public CppSharp.Parser.AST.AccessSpecifier Access;

                    [FieldOffset(8)]
                    public global::System.IntPtr _Namespace;

                    [FieldOffset(16)]
                    public CppSharp.Parser.SourceLocation.Internal Location;

                    [FieldOffset(20)]
                    public int LineNumberStart;

                    [FieldOffset(24)]
                    public int LineNumberEnd;

                    [FieldOffset(128)]
                    public byte IsIncomplete;

                    [FieldOffset(129)]
                    public byte IsDependent;

                    [FieldOffset(130)]
                    public byte IsImplicit;

                    [FieldOffset(136)]
                    public global::System.IntPtr CompleteDeclaration;

                    [FieldOffset(144)]
                    public uint DefinitionOrder;

                    [FieldOffset(176)]
                    public global::System.IntPtr OriginalPtr;

                    [FieldOffset(184)]
                    public global::System.IntPtr Comment;

                    [FieldOffset(192)]
                    public global::System.IntPtr TemplatedDecl;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0TypeAliasTemplate@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0TypeAliasTemplate@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1TypeAliasTemplate@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor_0(global::System.IntPtr instance, int delete);
                }

                public static new TypeAliasTemplate __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new TypeAliasTemplate(native.ToPointer(), skipVTables);
                }

                public static TypeAliasTemplate __CreateInstance(TypeAliasTemplate.Internal native, bool skipVTables = false)
                {
                    return new TypeAliasTemplate(native, skipVTables);
                }

                private static void* __CopyValue(TypeAliasTemplate.Internal native)
                {
                    var ret = Marshal.AllocHGlobal(224);
                    CppSharp.Parser.AST.TypeAliasTemplate.Internal.cctor_1(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private TypeAliasTemplate(TypeAliasTemplate.Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected TypeAliasTemplate(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public TypeAliasTemplate()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(224);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_0((__Instance + __PointerAdjustment));
                }

                public TypeAliasTemplate(CppSharp.Parser.AST.TypeAliasTemplate _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(224);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
                }

                protected override void Dispose(bool disposing)
                {
                    CppSharp.Parser.AST.Declaration __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    Internal.dtor_0((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }
            }

            public unsafe partial class TemplateParameter : CppSharp.Parser.AST.Declaration, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 208)]
                public new partial struct Internal
                {
                    [FieldOffset(0)]
                    public CppSharp.Parser.AST.DeclarationKind Kind;

                    [FieldOffset(4)]
                    public CppSharp.Parser.AST.AccessSpecifier Access;

                    [FieldOffset(8)]
                    public global::System.IntPtr _Namespace;

                    [FieldOffset(16)]
                    public CppSharp.Parser.SourceLocation.Internal Location;

                    [FieldOffset(20)]
                    public int LineNumberStart;

                    [FieldOffset(24)]
                    public int LineNumberEnd;

                    [FieldOffset(128)]
                    public byte IsIncomplete;

                    [FieldOffset(129)]
                    public byte IsDependent;

                    [FieldOffset(130)]
                    public byte IsImplicit;

                    [FieldOffset(136)]
                    public global::System.IntPtr CompleteDeclaration;

                    [FieldOffset(144)]
                    public uint DefinitionOrder;

                    [FieldOffset(176)]
                    public global::System.IntPtr OriginalPtr;

                    [FieldOffset(184)]
                    public global::System.IntPtr Comment;

                    [FieldOffset(192)]
                    public uint Depth;

                    [FieldOffset(196)]
                    public uint Index;

                    [FieldOffset(200)]
                    public byte IsParameterPack;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0TemplateParameter@AST@CppParser@CppSharp@@QEAA@W4DeclarationKind@123@@Z")]
                    internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance, CppSharp.Parser.AST.DeclarationKind kind);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0TemplateParameter@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1TemplateParameter@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor_0(global::System.IntPtr instance, int delete);
                }

                public static new TemplateParameter __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new TemplateParameter(native.ToPointer(), skipVTables);
                }

                public static TemplateParameter __CreateInstance(TemplateParameter.Internal native, bool skipVTables = false)
                {
                    return new TemplateParameter(native, skipVTables);
                }

                private static void* __CopyValue(TemplateParameter.Internal native)
                {
                    var ret = Marshal.AllocHGlobal(208);
                    CppSharp.Parser.AST.TemplateParameter.Internal.cctor_1(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private TemplateParameter(TemplateParameter.Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected TemplateParameter(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public TemplateParameter(CppSharp.Parser.AST.DeclarationKind kind)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(208);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    var __arg0 = kind;
                    Internal.ctor_0((__Instance + __PointerAdjustment), __arg0);
                }

                public TemplateParameter(CppSharp.Parser.AST.TemplateParameter _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(208);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
                }

                protected override void Dispose(bool disposing)
                {
                    CppSharp.Parser.AST.Declaration __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    Internal.dtor_0((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public uint Depth
                {
                    get
                    {
                        return ((Internal*) __Instance)->Depth;
                    }

                    set
                    {
                        ((Internal*) __Instance)->Depth = value;
                    }
                }

                public uint Index
                {
                    get
                    {
                        return ((Internal*) __Instance)->Index;
                    }

                    set
                    {
                        ((Internal*) __Instance)->Index = value;
                    }
                }

                public bool IsParameterPack
                {
                    get
                    {
                        return ((Internal*) __Instance)->IsParameterPack != 0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->IsParameterPack = (byte) (value ? 1 : 0);
                    }
                }
            }

            public unsafe partial class TemplateTemplateParameter : CppSharp.Parser.AST.Template, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 232)]
                public new partial struct Internal
                {
                    [FieldOffset(0)]
                    public CppSharp.Parser.AST.DeclarationKind Kind;

                    [FieldOffset(4)]
                    public CppSharp.Parser.AST.AccessSpecifier Access;

                    [FieldOffset(8)]
                    public global::System.IntPtr _Namespace;

                    [FieldOffset(16)]
                    public CppSharp.Parser.SourceLocation.Internal Location;

                    [FieldOffset(20)]
                    public int LineNumberStart;

                    [FieldOffset(24)]
                    public int LineNumberEnd;

                    [FieldOffset(128)]
                    public byte IsIncomplete;

                    [FieldOffset(129)]
                    public byte IsDependent;

                    [FieldOffset(130)]
                    public byte IsImplicit;

                    [FieldOffset(136)]
                    public global::System.IntPtr CompleteDeclaration;

                    [FieldOffset(144)]
                    public uint DefinitionOrder;

                    [FieldOffset(176)]
                    public global::System.IntPtr OriginalPtr;

                    [FieldOffset(184)]
                    public global::System.IntPtr Comment;

                    [FieldOffset(192)]
                    public global::System.IntPtr TemplatedDecl;

                    [FieldOffset(224)]
                    public byte IsParameterPack;

                    [FieldOffset(225)]
                    public byte IsPackExpansion;

                    [FieldOffset(226)]
                    public byte IsExpandedParameterPack;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0TemplateTemplateParameter@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0TemplateTemplateParameter@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1TemplateTemplateParameter@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor_0(global::System.IntPtr instance, int delete);
                }

                public static new TemplateTemplateParameter __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new TemplateTemplateParameter(native.ToPointer(), skipVTables);
                }

                public static TemplateTemplateParameter __CreateInstance(TemplateTemplateParameter.Internal native, bool skipVTables = false)
                {
                    return new TemplateTemplateParameter(native, skipVTables);
                }

                private static void* __CopyValue(TemplateTemplateParameter.Internal native)
                {
                    var ret = Marshal.AllocHGlobal(232);
                    CppSharp.Parser.AST.TemplateTemplateParameter.Internal.cctor_1(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private TemplateTemplateParameter(TemplateTemplateParameter.Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected TemplateTemplateParameter(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public TemplateTemplateParameter()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(232);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_0((__Instance + __PointerAdjustment));
                }

                public TemplateTemplateParameter(CppSharp.Parser.AST.TemplateTemplateParameter _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(232);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
                }

                protected override void Dispose(bool disposing)
                {
                    CppSharp.Parser.AST.Declaration __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    Internal.dtor_0((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public bool IsParameterPack
                {
                    get
                    {
                        return ((Internal*) __Instance)->IsParameterPack != 0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->IsParameterPack = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsPackExpansion
                {
                    get
                    {
                        return ((Internal*) __Instance)->IsPackExpansion != 0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->IsPackExpansion = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsExpandedParameterPack
                {
                    get
                    {
                        return ((Internal*) __Instance)->IsExpandedParameterPack != 0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->IsExpandedParameterPack = (byte) (value ? 1 : 0);
                    }
                }
            }

            public unsafe partial class TypeTemplateParameter : CppSharp.Parser.AST.TemplateParameter, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 224)]
                public new partial struct Internal
                {
                    [FieldOffset(0)]
                    public CppSharp.Parser.AST.DeclarationKind Kind;

                    [FieldOffset(4)]
                    public CppSharp.Parser.AST.AccessSpecifier Access;

                    [FieldOffset(8)]
                    public global::System.IntPtr _Namespace;

                    [FieldOffset(16)]
                    public CppSharp.Parser.SourceLocation.Internal Location;

                    [FieldOffset(20)]
                    public int LineNumberStart;

                    [FieldOffset(24)]
                    public int LineNumberEnd;

                    [FieldOffset(128)]
                    public byte IsIncomplete;

                    [FieldOffset(129)]
                    public byte IsDependent;

                    [FieldOffset(130)]
                    public byte IsImplicit;

                    [FieldOffset(136)]
                    public global::System.IntPtr CompleteDeclaration;

                    [FieldOffset(144)]
                    public uint DefinitionOrder;

                    [FieldOffset(176)]
                    public global::System.IntPtr OriginalPtr;

                    [FieldOffset(184)]
                    public global::System.IntPtr Comment;

                    [FieldOffset(192)]
                    public uint Depth;

                    [FieldOffset(196)]
                    public uint Index;

                    [FieldOffset(200)]
                    public byte IsParameterPack;

                    [FieldOffset(208)]
                    public CppSharp.Parser.AST.QualifiedType.Internal DefaultArgument;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0TypeTemplateParameter@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0TypeTemplateParameter@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1TypeTemplateParameter@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor_0(global::System.IntPtr instance, int delete);
                }

                public static new TypeTemplateParameter __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new TypeTemplateParameter(native.ToPointer(), skipVTables);
                }

                public static TypeTemplateParameter __CreateInstance(TypeTemplateParameter.Internal native, bool skipVTables = false)
                {
                    return new TypeTemplateParameter(native, skipVTables);
                }

                private static void* __CopyValue(TypeTemplateParameter.Internal native)
                {
                    var ret = Marshal.AllocHGlobal(224);
                    CppSharp.Parser.AST.TypeTemplateParameter.Internal.cctor_1(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private TypeTemplateParameter(TypeTemplateParameter.Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected TypeTemplateParameter(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public TypeTemplateParameter()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(224);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_0((__Instance + __PointerAdjustment));
                }

                public TypeTemplateParameter(CppSharp.Parser.AST.TypeTemplateParameter _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(224);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
                }

                protected override void Dispose(bool disposing)
                {
                    CppSharp.Parser.AST.Declaration __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    Internal.dtor_0((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public CppSharp.Parser.AST.QualifiedType DefaultArgument
                {
                    get
                    {
                        return CppSharp.Parser.AST.QualifiedType.__CreateInstance(((Internal*) __Instance)->DefaultArgument);
                    }

                    set
                    {
                        ((Internal*) __Instance)->DefaultArgument = ReferenceEquals(value, null) ? new CppSharp.Parser.AST.QualifiedType.Internal() : *(CppSharp.Parser.AST.QualifiedType.Internal*) (value.__Instance);
                    }
                }
            }

            public unsafe partial class NonTypeTemplateParameter : CppSharp.Parser.AST.TemplateParameter, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 224)]
                public new partial struct Internal
                {
                    [FieldOffset(0)]
                    public CppSharp.Parser.AST.DeclarationKind Kind;

                    [FieldOffset(4)]
                    public CppSharp.Parser.AST.AccessSpecifier Access;

                    [FieldOffset(8)]
                    public global::System.IntPtr _Namespace;

                    [FieldOffset(16)]
                    public CppSharp.Parser.SourceLocation.Internal Location;

                    [FieldOffset(20)]
                    public int LineNumberStart;

                    [FieldOffset(24)]
                    public int LineNumberEnd;

                    [FieldOffset(128)]
                    public byte IsIncomplete;

                    [FieldOffset(129)]
                    public byte IsDependent;

                    [FieldOffset(130)]
                    public byte IsImplicit;

                    [FieldOffset(136)]
                    public global::System.IntPtr CompleteDeclaration;

                    [FieldOffset(144)]
                    public uint DefinitionOrder;

                    [FieldOffset(176)]
                    public global::System.IntPtr OriginalPtr;

                    [FieldOffset(184)]
                    public global::System.IntPtr Comment;

                    [FieldOffset(192)]
                    public uint Depth;

                    [FieldOffset(196)]
                    public uint Index;

                    [FieldOffset(200)]
                    public byte IsParameterPack;

                    [FieldOffset(208)]
                    public global::System.IntPtr DefaultArgument;

                    [FieldOffset(216)]
                    public uint Position;

                    [FieldOffset(220)]
                    public byte IsPackExpansion;

                    [FieldOffset(221)]
                    public byte IsExpandedParameterPack;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0NonTypeTemplateParameter@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0NonTypeTemplateParameter@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1NonTypeTemplateParameter@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor_0(global::System.IntPtr instance, int delete);
                }

                public static new NonTypeTemplateParameter __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new NonTypeTemplateParameter(native.ToPointer(), skipVTables);
                }

                public static NonTypeTemplateParameter __CreateInstance(NonTypeTemplateParameter.Internal native, bool skipVTables = false)
                {
                    return new NonTypeTemplateParameter(native, skipVTables);
                }

                private static void* __CopyValue(NonTypeTemplateParameter.Internal native)
                {
                    var ret = Marshal.AllocHGlobal(224);
                    CppSharp.Parser.AST.NonTypeTemplateParameter.Internal.cctor_1(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private NonTypeTemplateParameter(NonTypeTemplateParameter.Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected NonTypeTemplateParameter(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public NonTypeTemplateParameter()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(224);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_0((__Instance + __PointerAdjustment));
                }

                public NonTypeTemplateParameter(CppSharp.Parser.AST.NonTypeTemplateParameter _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(224);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
                }

                protected override void Dispose(bool disposing)
                {
                    CppSharp.Parser.AST.Declaration __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    Internal.dtor_0((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public CppSharp.Parser.AST.Expression DefaultArgument
                {
                    get
                    {
                        CppSharp.Parser.AST.Expression __result0;
                        if (((Internal*) __Instance)->DefaultArgument == IntPtr.Zero) __result0 = null;
                        else if (CppSharp.Parser.AST.Expression.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->DefaultArgument))
                            __result0 = (CppSharp.Parser.AST.Expression) CppSharp.Parser.AST.Expression.NativeToManagedMap[((Internal*) __Instance)->DefaultArgument];
                        else __result0 = CppSharp.Parser.AST.Expression.__CreateInstance(((Internal*) __Instance)->DefaultArgument);
                        return __result0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->DefaultArgument = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public uint Position
                {
                    get
                    {
                        return ((Internal*) __Instance)->Position;
                    }

                    set
                    {
                        ((Internal*) __Instance)->Position = value;
                    }
                }

                public bool IsPackExpansion
                {
                    get
                    {
                        return ((Internal*) __Instance)->IsPackExpansion != 0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->IsPackExpansion = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsExpandedParameterPack
                {
                    get
                    {
                        return ((Internal*) __Instance)->IsExpandedParameterPack != 0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->IsExpandedParameterPack = (byte) (value ? 1 : 0);
                    }
                }
            }

            public unsafe partial class ClassTemplate : CppSharp.Parser.AST.Template, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 248)]
                public new partial struct Internal
                {
                    [FieldOffset(0)]
                    public CppSharp.Parser.AST.DeclarationKind Kind;

                    [FieldOffset(4)]
                    public CppSharp.Parser.AST.AccessSpecifier Access;

                    [FieldOffset(8)]
                    public global::System.IntPtr _Namespace;

                    [FieldOffset(16)]
                    public CppSharp.Parser.SourceLocation.Internal Location;

                    [FieldOffset(20)]
                    public int LineNumberStart;

                    [FieldOffset(24)]
                    public int LineNumberEnd;

                    [FieldOffset(128)]
                    public byte IsIncomplete;

                    [FieldOffset(129)]
                    public byte IsDependent;

                    [FieldOffset(130)]
                    public byte IsImplicit;

                    [FieldOffset(136)]
                    public global::System.IntPtr CompleteDeclaration;

                    [FieldOffset(144)]
                    public uint DefinitionOrder;

                    [FieldOffset(176)]
                    public global::System.IntPtr OriginalPtr;

                    [FieldOffset(184)]
                    public global::System.IntPtr Comment;

                    [FieldOffset(192)]
                    public global::System.IntPtr TemplatedDecl;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0ClassTemplate@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0ClassTemplate@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1ClassTemplate@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor_0(global::System.IntPtr instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getSpecializations@ClassTemplate@AST@CppParser@CppSharp@@QEAAPEAVClassTemplateSpecialization@234@I@Z")]
                    internal static extern global::System.IntPtr getSpecializations_0(global::System.IntPtr instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?addSpecializations@ClassTemplate@AST@CppParser@CppSharp@@QEAAXAEAPEAVClassTemplateSpecialization@234@@Z")]
                    internal static extern void addSpecializations_0(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?clearSpecializations@ClassTemplate@AST@CppParser@CppSharp@@QEAAXXZ")]
                    internal static extern void clearSpecializations_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getSpecializationsCount@ClassTemplate@AST@CppParser@CppSharp@@QEAAIXZ")]
                    internal static extern uint getSpecializationsCount_0(global::System.IntPtr instance);
                }

                public static new ClassTemplate __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new ClassTemplate(native.ToPointer(), skipVTables);
                }

                public static ClassTemplate __CreateInstance(ClassTemplate.Internal native, bool skipVTables = false)
                {
                    return new ClassTemplate(native, skipVTables);
                }

                private static void* __CopyValue(ClassTemplate.Internal native)
                {
                    var ret = Marshal.AllocHGlobal(248);
                    CppSharp.Parser.AST.ClassTemplate.Internal.cctor_1(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private ClassTemplate(ClassTemplate.Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected ClassTemplate(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public ClassTemplate()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(248);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_0((__Instance + __PointerAdjustment));
                }

                public ClassTemplate(CppSharp.Parser.AST.ClassTemplate _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(248);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
                }

                protected override void Dispose(bool disposing)
                {
                    CppSharp.Parser.AST.Declaration __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    Internal.dtor_0((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public CppSharp.Parser.AST.ClassTemplateSpecialization getSpecializations(uint i)
                {
                    var __ret = Internal.getSpecializations_0((__Instance + __PointerAdjustment), i);
                    CppSharp.Parser.AST.ClassTemplateSpecialization __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (CppSharp.Parser.AST.ClassTemplateSpecialization.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (CppSharp.Parser.AST.ClassTemplateSpecialization) CppSharp.Parser.AST.ClassTemplateSpecialization.NativeToManagedMap[__ret];
                    else __result0 = CppSharp.Parser.AST.ClassTemplateSpecialization.__CreateInstance(__ret);
                    return __result0;
                }

                public void addSpecializations(CppSharp.Parser.AST.ClassTemplateSpecialization s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    Internal.addSpecializations_0((__Instance + __PointerAdjustment), __arg0);
                }

                public void clearSpecializations()
                {
                    Internal.clearSpecializations_0((__Instance + __PointerAdjustment));
                }

                public uint SpecializationsCount
                {
                    get
                    {
                        var __ret = Internal.getSpecializationsCount_0((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }
            }

            public unsafe partial class ClassTemplateSpecialization : CppSharp.Parser.AST.Class, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 592)]
                public new partial struct Internal
                {
                    [FieldOffset(0)]
                    public CppSharp.Parser.AST.DeclarationKind Kind;

                    [FieldOffset(4)]
                    public CppSharp.Parser.AST.AccessSpecifier Access;

                    [FieldOffset(8)]
                    public global::System.IntPtr _Namespace;

                    [FieldOffset(16)]
                    public CppSharp.Parser.SourceLocation.Internal Location;

                    [FieldOffset(20)]
                    public int LineNumberStart;

                    [FieldOffset(24)]
                    public int LineNumberEnd;

                    [FieldOffset(128)]
                    public byte IsIncomplete;

                    [FieldOffset(129)]
                    public byte IsDependent;

                    [FieldOffset(130)]
                    public byte IsImplicit;

                    [FieldOffset(136)]
                    public global::System.IntPtr CompleteDeclaration;

                    [FieldOffset(144)]
                    public uint DefinitionOrder;

                    [FieldOffset(176)]
                    public global::System.IntPtr OriginalPtr;

                    [FieldOffset(184)]
                    public global::System.IntPtr Comment;

                    [FieldOffset(424)]
                    public byte IsAnonymous;

                    [FieldOffset(528)]
                    public byte IsPOD;

                    [FieldOffset(529)]
                    public byte IsAbstract;

                    [FieldOffset(530)]
                    public byte IsUnion;

                    [FieldOffset(531)]
                    public byte IsDynamic;

                    [FieldOffset(532)]
                    public byte IsPolymorphic;

                    [FieldOffset(533)]
                    public byte HasNonTrivialDefaultConstructor;

                    [FieldOffset(534)]
                    public byte HasNonTrivialCopyConstructor;

                    [FieldOffset(535)]
                    public byte HasNonTrivialDestructor;

                    [FieldOffset(536)]
                    public byte IsExternCContext;

                    [FieldOffset(544)]
                    public global::System.IntPtr Layout;

                    [FieldOffset(552)]
                    public global::System.IntPtr TemplatedDecl;

                    [FieldOffset(584)]
                    public CppSharp.Parser.AST.TemplateSpecializationKind SpecializationKind;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0ClassTemplateSpecialization@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0ClassTemplateSpecialization@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1ClassTemplateSpecialization@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor_0(global::System.IntPtr instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getArguments@ClassTemplateSpecialization@AST@CppParser@CppSharp@@QEAA?AUTemplateArgument@234@I@Z")]
                    internal static extern void getArguments_0(global::System.IntPtr instance, global::System.IntPtr @return, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?addArguments@ClassTemplateSpecialization@AST@CppParser@CppSharp@@QEAAXAEAUTemplateArgument@234@@Z")]
                    internal static extern void addArguments_0(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?clearArguments@ClassTemplateSpecialization@AST@CppParser@CppSharp@@QEAAXXZ")]
                    internal static extern void clearArguments_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getArgumentsCount@ClassTemplateSpecialization@AST@CppParser@CppSharp@@QEAAIXZ")]
                    internal static extern uint getArgumentsCount_0(global::System.IntPtr instance);
                }

                public static new ClassTemplateSpecialization __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new ClassTemplateSpecialization(native.ToPointer(), skipVTables);
                }

                public static ClassTemplateSpecialization __CreateInstance(ClassTemplateSpecialization.Internal native, bool skipVTables = false)
                {
                    return new ClassTemplateSpecialization(native, skipVTables);
                }

                private static void* __CopyValue(ClassTemplateSpecialization.Internal native)
                {
                    var ret = Marshal.AllocHGlobal(592);
                    CppSharp.Parser.AST.ClassTemplateSpecialization.Internal.cctor_1(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private ClassTemplateSpecialization(ClassTemplateSpecialization.Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected ClassTemplateSpecialization(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public ClassTemplateSpecialization()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(592);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_0((__Instance + __PointerAdjustment));
                }

                public ClassTemplateSpecialization(CppSharp.Parser.AST.ClassTemplateSpecialization _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(592);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
                }

                protected override void Dispose(bool disposing)
                {
                    CppSharp.Parser.AST.Declaration __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    Internal.dtor_0((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public CppSharp.Parser.AST.TemplateArgument getArguments(uint i)
                {
                    var __ret = new CppSharp.Parser.AST.TemplateArgument.Internal();
                    Internal.getArguments_0((__Instance + __PointerAdjustment), new IntPtr(&__ret), i);
                    return CppSharp.Parser.AST.TemplateArgument.__CreateInstance(__ret);
                }

                public void addArguments(CppSharp.Parser.AST.TemplateArgument s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    Internal.addArguments_0((__Instance + __PointerAdjustment), __arg0);
                }

                public void clearArguments()
                {
                    Internal.clearArguments_0((__Instance + __PointerAdjustment));
                }

                public uint ArgumentsCount
                {
                    get
                    {
                        var __ret = Internal.getArgumentsCount_0((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                public CppSharp.Parser.AST.ClassTemplate TemplatedDecl
                {
                    get
                    {
                        CppSharp.Parser.AST.ClassTemplate __result0;
                        if (((Internal*) __Instance)->TemplatedDecl == IntPtr.Zero) __result0 = null;
                        else if (CppSharp.Parser.AST.ClassTemplate.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->TemplatedDecl))
                            __result0 = (CppSharp.Parser.AST.ClassTemplate) CppSharp.Parser.AST.ClassTemplate.NativeToManagedMap[((Internal*) __Instance)->TemplatedDecl];
                        else __result0 = CppSharp.Parser.AST.ClassTemplate.__CreateInstance(((Internal*) __Instance)->TemplatedDecl);
                        return __result0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->TemplatedDecl = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public CppSharp.Parser.AST.TemplateSpecializationKind SpecializationKind
                {
                    get
                    {
                        return ((Internal*) __Instance)->SpecializationKind;
                    }

                    set
                    {
                        ((Internal*) __Instance)->SpecializationKind = value;
                    }
                }
            }

            public unsafe partial class ClassTemplatePartialSpecialization : CppSharp.Parser.AST.ClassTemplateSpecialization, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 592)]
                public new partial struct Internal
                {
                    [FieldOffset(0)]
                    public CppSharp.Parser.AST.DeclarationKind Kind;

                    [FieldOffset(4)]
                    public CppSharp.Parser.AST.AccessSpecifier Access;

                    [FieldOffset(8)]
                    public global::System.IntPtr _Namespace;

                    [FieldOffset(16)]
                    public CppSharp.Parser.SourceLocation.Internal Location;

                    [FieldOffset(20)]
                    public int LineNumberStart;

                    [FieldOffset(24)]
                    public int LineNumberEnd;

                    [FieldOffset(128)]
                    public byte IsIncomplete;

                    [FieldOffset(129)]
                    public byte IsDependent;

                    [FieldOffset(130)]
                    public byte IsImplicit;

                    [FieldOffset(136)]
                    public global::System.IntPtr CompleteDeclaration;

                    [FieldOffset(144)]
                    public uint DefinitionOrder;

                    [FieldOffset(176)]
                    public global::System.IntPtr OriginalPtr;

                    [FieldOffset(184)]
                    public global::System.IntPtr Comment;

                    [FieldOffset(424)]
                    public byte IsAnonymous;

                    [FieldOffset(528)]
                    public byte IsPOD;

                    [FieldOffset(529)]
                    public byte IsAbstract;

                    [FieldOffset(530)]
                    public byte IsUnion;

                    [FieldOffset(531)]
                    public byte IsDynamic;

                    [FieldOffset(532)]
                    public byte IsPolymorphic;

                    [FieldOffset(533)]
                    public byte HasNonTrivialDefaultConstructor;

                    [FieldOffset(534)]
                    public byte HasNonTrivialCopyConstructor;

                    [FieldOffset(535)]
                    public byte HasNonTrivialDestructor;

                    [FieldOffset(536)]
                    public byte IsExternCContext;

                    [FieldOffset(544)]
                    public global::System.IntPtr Layout;

                    [FieldOffset(552)]
                    public global::System.IntPtr TemplatedDecl;

                    [FieldOffset(584)]
                    public CppSharp.Parser.AST.TemplateSpecializationKind SpecializationKind;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0ClassTemplatePartialSpecialization@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0ClassTemplatePartialSpecialization@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1ClassTemplatePartialSpecialization@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor_0(global::System.IntPtr instance, int delete);
                }

                public static new ClassTemplatePartialSpecialization __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new ClassTemplatePartialSpecialization(native.ToPointer(), skipVTables);
                }

                public static ClassTemplatePartialSpecialization __CreateInstance(ClassTemplatePartialSpecialization.Internal native, bool skipVTables = false)
                {
                    return new ClassTemplatePartialSpecialization(native, skipVTables);
                }

                private static void* __CopyValue(ClassTemplatePartialSpecialization.Internal native)
                {
                    var ret = Marshal.AllocHGlobal(592);
                    CppSharp.Parser.AST.ClassTemplatePartialSpecialization.Internal.cctor_1(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private ClassTemplatePartialSpecialization(ClassTemplatePartialSpecialization.Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected ClassTemplatePartialSpecialization(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public ClassTemplatePartialSpecialization()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(592);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_0((__Instance + __PointerAdjustment));
                }

                public ClassTemplatePartialSpecialization(CppSharp.Parser.AST.ClassTemplatePartialSpecialization _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(592);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
                }

                protected override void Dispose(bool disposing)
                {
                    CppSharp.Parser.AST.Declaration __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    Internal.dtor_0((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }
            }

            public unsafe partial class FunctionTemplate : CppSharp.Parser.AST.Template, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 248)]
                public new partial struct Internal
                {
                    [FieldOffset(0)]
                    public CppSharp.Parser.AST.DeclarationKind Kind;

                    [FieldOffset(4)]
                    public CppSharp.Parser.AST.AccessSpecifier Access;

                    [FieldOffset(8)]
                    public global::System.IntPtr _Namespace;

                    [FieldOffset(16)]
                    public CppSharp.Parser.SourceLocation.Internal Location;

                    [FieldOffset(20)]
                    public int LineNumberStart;

                    [FieldOffset(24)]
                    public int LineNumberEnd;

                    [FieldOffset(128)]
                    public byte IsIncomplete;

                    [FieldOffset(129)]
                    public byte IsDependent;

                    [FieldOffset(130)]
                    public byte IsImplicit;

                    [FieldOffset(136)]
                    public global::System.IntPtr CompleteDeclaration;

                    [FieldOffset(144)]
                    public uint DefinitionOrder;

                    [FieldOffset(176)]
                    public global::System.IntPtr OriginalPtr;

                    [FieldOffset(184)]
                    public global::System.IntPtr Comment;

                    [FieldOffset(192)]
                    public global::System.IntPtr TemplatedDecl;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0FunctionTemplate@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0FunctionTemplate@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1FunctionTemplate@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor_0(global::System.IntPtr instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getSpecializations@FunctionTemplate@AST@CppParser@CppSharp@@QEAAPEAVFunctionTemplateSpecialization@234@I@Z")]
                    internal static extern global::System.IntPtr getSpecializations_0(global::System.IntPtr instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?addSpecializations@FunctionTemplate@AST@CppParser@CppSharp@@QEAAXAEAPEAVFunctionTemplateSpecialization@234@@Z")]
                    internal static extern void addSpecializations_0(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?clearSpecializations@FunctionTemplate@AST@CppParser@CppSharp@@QEAAXXZ")]
                    internal static extern void clearSpecializations_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getSpecializationsCount@FunctionTemplate@AST@CppParser@CppSharp@@QEAAIXZ")]
                    internal static extern uint getSpecializationsCount_0(global::System.IntPtr instance);
                }

                public static new FunctionTemplate __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new FunctionTemplate(native.ToPointer(), skipVTables);
                }

                public static FunctionTemplate __CreateInstance(FunctionTemplate.Internal native, bool skipVTables = false)
                {
                    return new FunctionTemplate(native, skipVTables);
                }

                private static void* __CopyValue(FunctionTemplate.Internal native)
                {
                    var ret = Marshal.AllocHGlobal(248);
                    CppSharp.Parser.AST.FunctionTemplate.Internal.cctor_1(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private FunctionTemplate(FunctionTemplate.Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected FunctionTemplate(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public FunctionTemplate()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(248);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_0((__Instance + __PointerAdjustment));
                }

                public FunctionTemplate(CppSharp.Parser.AST.FunctionTemplate _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(248);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
                }

                protected override void Dispose(bool disposing)
                {
                    CppSharp.Parser.AST.Declaration __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    Internal.dtor_0((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public CppSharp.Parser.AST.FunctionTemplateSpecialization getSpecializations(uint i)
                {
                    var __ret = Internal.getSpecializations_0((__Instance + __PointerAdjustment), i);
                    CppSharp.Parser.AST.FunctionTemplateSpecialization __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (CppSharp.Parser.AST.FunctionTemplateSpecialization.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (CppSharp.Parser.AST.FunctionTemplateSpecialization) CppSharp.Parser.AST.FunctionTemplateSpecialization.NativeToManagedMap[__ret];
                    else __result0 = CppSharp.Parser.AST.FunctionTemplateSpecialization.__CreateInstance(__ret);
                    return __result0;
                }

                public void addSpecializations(CppSharp.Parser.AST.FunctionTemplateSpecialization s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    Internal.addSpecializations_0((__Instance + __PointerAdjustment), __arg0);
                }

                public void clearSpecializations()
                {
                    Internal.clearSpecializations_0((__Instance + __PointerAdjustment));
                }

                public uint SpecializationsCount
                {
                    get
                    {
                        var __ret = Internal.getSpecializationsCount_0((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }
            }

            public unsafe partial class FunctionTemplateSpecialization : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 48)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public global::System.IntPtr Template;

                    [FieldOffset(32)]
                    public global::System.IntPtr SpecializedFunction;

                    [FieldOffset(40)]
                    public CppSharp.Parser.AST.TemplateSpecializationKind SpecializationKind;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0FunctionTemplateSpecialization@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0FunctionTemplateSpecialization@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1FunctionTemplateSpecialization@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor_0(global::System.IntPtr instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getArguments@FunctionTemplateSpecialization@AST@CppParser@CppSharp@@QEAA?AUTemplateArgument@234@I@Z")]
                    internal static extern void getArguments_0(global::System.IntPtr instance, global::System.IntPtr @return, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?addArguments@FunctionTemplateSpecialization@AST@CppParser@CppSharp@@QEAAXAEAUTemplateArgument@234@@Z")]
                    internal static extern void addArguments_0(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?clearArguments@FunctionTemplateSpecialization@AST@CppParser@CppSharp@@QEAAXXZ")]
                    internal static extern void clearArguments_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getArgumentsCount@FunctionTemplateSpecialization@AST@CppParser@CppSharp@@QEAAIXZ")]
                    internal static extern uint getArgumentsCount_0(global::System.IntPtr instance);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                protected int __PointerAdjustment;
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, FunctionTemplateSpecialization> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, FunctionTemplateSpecialization>();
                protected void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                public static FunctionTemplateSpecialization __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new FunctionTemplateSpecialization(native.ToPointer(), skipVTables);
                }

                public static FunctionTemplateSpecialization __CreateInstance(FunctionTemplateSpecialization.Internal native, bool skipVTables = false)
                {
                    return new FunctionTemplateSpecialization(native, skipVTables);
                }

                private static void* __CopyValue(FunctionTemplateSpecialization.Internal native)
                {
                    var ret = Marshal.AllocHGlobal(48);
                    CppSharp.Parser.AST.FunctionTemplateSpecialization.Internal.cctor_1(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private FunctionTemplateSpecialization(FunctionTemplateSpecialization.Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected FunctionTemplateSpecialization(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public FunctionTemplateSpecialization()
                {
                    __Instance = Marshal.AllocHGlobal(48);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_0((__Instance + __PointerAdjustment));
                }

                public FunctionTemplateSpecialization(CppSharp.Parser.AST.FunctionTemplateSpecialization _0)
                {
                    __Instance = Marshal.AllocHGlobal(48);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    CppSharp.Parser.AST.FunctionTemplateSpecialization __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    Internal.dtor_0((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public CppSharp.Parser.AST.TemplateArgument getArguments(uint i)
                {
                    var __ret = new CppSharp.Parser.AST.TemplateArgument.Internal();
                    Internal.getArguments_0((__Instance + __PointerAdjustment), new IntPtr(&__ret), i);
                    return CppSharp.Parser.AST.TemplateArgument.__CreateInstance(__ret);
                }

                public void addArguments(CppSharp.Parser.AST.TemplateArgument s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    Internal.addArguments_0((__Instance + __PointerAdjustment), __arg0);
                }

                public void clearArguments()
                {
                    Internal.clearArguments_0((__Instance + __PointerAdjustment));
                }

                public uint ArgumentsCount
                {
                    get
                    {
                        var __ret = Internal.getArgumentsCount_0((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                public CppSharp.Parser.AST.FunctionTemplate Template
                {
                    get
                    {
                        CppSharp.Parser.AST.FunctionTemplate __result0;
                        if (((Internal*) __Instance)->Template == IntPtr.Zero) __result0 = null;
                        else if (CppSharp.Parser.AST.FunctionTemplate.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->Template))
                            __result0 = (CppSharp.Parser.AST.FunctionTemplate) CppSharp.Parser.AST.FunctionTemplate.NativeToManagedMap[((Internal*) __Instance)->Template];
                        else __result0 = CppSharp.Parser.AST.FunctionTemplate.__CreateInstance(((Internal*) __Instance)->Template);
                        return __result0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->Template = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public CppSharp.Parser.AST.Function SpecializedFunction
                {
                    get
                    {
                        CppSharp.Parser.AST.Function __result0;
                        if (((Internal*) __Instance)->SpecializedFunction == IntPtr.Zero) __result0 = null;
                        else if (CppSharp.Parser.AST.Function.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->SpecializedFunction))
                            __result0 = (CppSharp.Parser.AST.Function) CppSharp.Parser.AST.Function.NativeToManagedMap[((Internal*) __Instance)->SpecializedFunction];
                        else __result0 = CppSharp.Parser.AST.Function.__CreateInstance(((Internal*) __Instance)->SpecializedFunction);
                        return __result0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->SpecializedFunction = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public CppSharp.Parser.AST.TemplateSpecializationKind SpecializationKind
                {
                    get
                    {
                        return ((Internal*) __Instance)->SpecializationKind;
                    }

                    set
                    {
                        ((Internal*) __Instance)->SpecializationKind = value;
                    }
                }
            }

            public unsafe partial class Namespace : CppSharp.Parser.AST.DeclarationContext, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 440)]
                public new partial struct Internal
                {
                    [FieldOffset(0)]
                    public CppSharp.Parser.AST.DeclarationKind Kind;

                    [FieldOffset(4)]
                    public CppSharp.Parser.AST.AccessSpecifier Access;

                    [FieldOffset(8)]
                    public global::System.IntPtr _Namespace;

                    [FieldOffset(16)]
                    public CppSharp.Parser.SourceLocation.Internal Location;

                    [FieldOffset(20)]
                    public int LineNumberStart;

                    [FieldOffset(24)]
                    public int LineNumberEnd;

                    [FieldOffset(128)]
                    public byte IsIncomplete;

                    [FieldOffset(129)]
                    public byte IsDependent;

                    [FieldOffset(130)]
                    public byte IsImplicit;

                    [FieldOffset(136)]
                    public global::System.IntPtr CompleteDeclaration;

                    [FieldOffset(144)]
                    public uint DefinitionOrder;

                    [FieldOffset(176)]
                    public global::System.IntPtr OriginalPtr;

                    [FieldOffset(184)]
                    public global::System.IntPtr Comment;

                    [FieldOffset(424)]
                    public byte IsAnonymous;

                    [FieldOffset(432)]
                    public byte IsInline;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0Namespace@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0Namespace@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1Namespace@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor_0(global::System.IntPtr instance, int delete);
                }

                public static new Namespace __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new Namespace(native.ToPointer(), skipVTables);
                }

                public static Namespace __CreateInstance(Namespace.Internal native, bool skipVTables = false)
                {
                    return new Namespace(native, skipVTables);
                }

                private static void* __CopyValue(Namespace.Internal native)
                {
                    var ret = Marshal.AllocHGlobal(440);
                    CppSharp.Parser.AST.Namespace.Internal.cctor_1(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private Namespace(Namespace.Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected Namespace(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public Namespace()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(440);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_0((__Instance + __PointerAdjustment));
                }

                public Namespace(CppSharp.Parser.AST.Namespace _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(440);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
                }

                protected override void Dispose(bool disposing)
                {
                    CppSharp.Parser.AST.Declaration __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    Internal.dtor_0((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public bool IsInline
                {
                    get
                    {
                        return ((Internal*) __Instance)->IsInline != 0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->IsInline = (byte) (value ? 1 : 0);
                    }
                }
            }

            public unsafe partial class PreprocessedEntity : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 24)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public CppSharp.Parser.AST.MacroLocation MacroLocation;

                    [FieldOffset(8)]
                    public global::System.IntPtr OriginalPtr;

                    [FieldOffset(16)]
                    public CppSharp.Parser.AST.DeclarationKind Kind;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0PreprocessedEntity@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0PreprocessedEntity@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                protected int __PointerAdjustment;
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, PreprocessedEntity> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, PreprocessedEntity>();
                protected void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                public static PreprocessedEntity __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new PreprocessedEntity(native.ToPointer(), skipVTables);
                }

                public static PreprocessedEntity __CreateInstance(PreprocessedEntity.Internal native, bool skipVTables = false)
                {
                    return new PreprocessedEntity(native, skipVTables);
                }

                private static void* __CopyValue(PreprocessedEntity.Internal native)
                {
                    var ret = Marshal.AllocHGlobal(24);
                    *(PreprocessedEntity.Internal*) ret = native;
                    return ret.ToPointer();
                }

                private PreprocessedEntity(PreprocessedEntity.Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected PreprocessedEntity(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public PreprocessedEntity()
                {
                    __Instance = Marshal.AllocHGlobal(24);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_0((__Instance + __PointerAdjustment));
                }

                public PreprocessedEntity(CppSharp.Parser.AST.PreprocessedEntity _0)
                {
                    __Instance = Marshal.AllocHGlobal(24);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((PreprocessedEntity.Internal*) __Instance) = *((PreprocessedEntity.Internal*) _0.__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    CppSharp.Parser.AST.PreprocessedEntity __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public CppSharp.Parser.AST.MacroLocation MacroLocation
                {
                    get
                    {
                        return ((Internal*) __Instance)->MacroLocation;
                    }

                    set
                    {
                        ((Internal*) __Instance)->MacroLocation = value;
                    }
                }

                public global::System.IntPtr OriginalPtr
                {
                    get
                    {
                        return ((Internal*) __Instance)->OriginalPtr;
                    }

                    set
                    {
                        ((Internal*) __Instance)->OriginalPtr = (global::System.IntPtr) value;
                    }
                }

                public CppSharp.Parser.AST.DeclarationKind Kind
                {
                    get
                    {
                        return ((Internal*) __Instance)->Kind;
                    }

                    set
                    {
                        ((Internal*) __Instance)->Kind = value;
                    }
                }
            }

            public unsafe partial class MacroDefinition : CppSharp.Parser.AST.PreprocessedEntity, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 96)]
                public new partial struct Internal
                {
                    [FieldOffset(0)]
                    public CppSharp.Parser.AST.MacroLocation MacroLocation;

                    [FieldOffset(8)]
                    public global::System.IntPtr OriginalPtr;

                    [FieldOffset(16)]
                    public CppSharp.Parser.AST.DeclarationKind Kind;

                    [FieldOffset(88)]
                    public int LineNumberStart;

                    [FieldOffset(92)]
                    public int LineNumberEnd;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0MacroDefinition@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0MacroDefinition@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1MacroDefinition@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor_0(global::System.IntPtr instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getName@MacroDefinition@AST@CppParser@CppSharp@@QEAAPEBDXZ")]
                    internal static extern global::System.IntPtr getName_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?setName@MacroDefinition@AST@CppParser@CppSharp@@QEAAXPEBD@Z")]
                    internal static extern void setName_0(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getExpression@MacroDefinition@AST@CppParser@CppSharp@@QEAAPEBDXZ")]
                    internal static extern global::System.IntPtr getExpression_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?setExpression@MacroDefinition@AST@CppParser@CppSharp@@QEAAXPEBD@Z")]
                    internal static extern void setExpression_0(global::System.IntPtr instance, global::System.IntPtr s);
                }

                public static new MacroDefinition __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new MacroDefinition(native.ToPointer(), skipVTables);
                }

                public static MacroDefinition __CreateInstance(MacroDefinition.Internal native, bool skipVTables = false)
                {
                    return new MacroDefinition(native, skipVTables);
                }

                private static void* __CopyValue(MacroDefinition.Internal native)
                {
                    var ret = Marshal.AllocHGlobal(96);
                    CppSharp.Parser.AST.MacroDefinition.Internal.cctor_1(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private MacroDefinition(MacroDefinition.Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected MacroDefinition(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public MacroDefinition()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(96);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_0((__Instance + __PointerAdjustment));
                }

                public MacroDefinition(CppSharp.Parser.AST.MacroDefinition _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(96);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
                }

                protected override void Dispose(bool disposing)
                {
                    CppSharp.Parser.AST.PreprocessedEntity __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    Internal.dtor_0((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public string Name
                {
                    get
                    {
                        var __ret = Internal.getName_0((__Instance + __PointerAdjustment));
                        return Marshal.PtrToStringAnsi(__ret);
                    }

                    set
                    {
                        var __arg0 = Marshal.StringToHGlobalAnsi(value);
                        Internal.setName_0((__Instance + __PointerAdjustment), __arg0);
                        Marshal.FreeHGlobal(__arg0);
                    }
                }

                public string Expression
                {
                    get
                    {
                        var __ret = Internal.getExpression_0((__Instance + __PointerAdjustment));
                        return Marshal.PtrToStringAnsi(__ret);
                    }

                    set
                    {
                        var __arg0 = Marshal.StringToHGlobalAnsi(value);
                        Internal.setExpression_0((__Instance + __PointerAdjustment), __arg0);
                        Marshal.FreeHGlobal(__arg0);
                    }
                }

                public int LineNumberStart
                {
                    get
                    {
                        return ((Internal*) __Instance)->LineNumberStart;
                    }

                    set
                    {
                        ((Internal*) __Instance)->LineNumberStart = value;
                    }
                }

                public int LineNumberEnd
                {
                    get
                    {
                        return ((Internal*) __Instance)->LineNumberEnd;
                    }

                    set
                    {
                        ((Internal*) __Instance)->LineNumberEnd = value;
                    }
                }
            }

            public unsafe partial class MacroExpansion : CppSharp.Parser.AST.PreprocessedEntity, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 96)]
                public new partial struct Internal
                {
                    [FieldOffset(0)]
                    public CppSharp.Parser.AST.MacroLocation MacroLocation;

                    [FieldOffset(8)]
                    public global::System.IntPtr OriginalPtr;

                    [FieldOffset(16)]
                    public CppSharp.Parser.AST.DeclarationKind Kind;

                    [FieldOffset(88)]
                    public global::System.IntPtr Definition;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0MacroExpansion@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0MacroExpansion@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1MacroExpansion@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor_0(global::System.IntPtr instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getName@MacroExpansion@AST@CppParser@CppSharp@@QEAAPEBDXZ")]
                    internal static extern global::System.IntPtr getName_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?setName@MacroExpansion@AST@CppParser@CppSharp@@QEAAXPEBD@Z")]
                    internal static extern void setName_0(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getText@MacroExpansion@AST@CppParser@CppSharp@@QEAAPEBDXZ")]
                    internal static extern global::System.IntPtr getText_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?setText@MacroExpansion@AST@CppParser@CppSharp@@QEAAXPEBD@Z")]
                    internal static extern void setText_0(global::System.IntPtr instance, global::System.IntPtr s);
                }

                public static new MacroExpansion __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new MacroExpansion(native.ToPointer(), skipVTables);
                }

                public static MacroExpansion __CreateInstance(MacroExpansion.Internal native, bool skipVTables = false)
                {
                    return new MacroExpansion(native, skipVTables);
                }

                private static void* __CopyValue(MacroExpansion.Internal native)
                {
                    var ret = Marshal.AllocHGlobal(96);
                    CppSharp.Parser.AST.MacroExpansion.Internal.cctor_1(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private MacroExpansion(MacroExpansion.Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected MacroExpansion(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public MacroExpansion()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(96);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_0((__Instance + __PointerAdjustment));
                }

                public MacroExpansion(CppSharp.Parser.AST.MacroExpansion _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(96);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
                }

                protected override void Dispose(bool disposing)
                {
                    CppSharp.Parser.AST.PreprocessedEntity __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    Internal.dtor_0((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public string Name
                {
                    get
                    {
                        var __ret = Internal.getName_0((__Instance + __PointerAdjustment));
                        return Marshal.PtrToStringAnsi(__ret);
                    }

                    set
                    {
                        var __arg0 = Marshal.StringToHGlobalAnsi(value);
                        Internal.setName_0((__Instance + __PointerAdjustment), __arg0);
                        Marshal.FreeHGlobal(__arg0);
                    }
                }

                public string Text
                {
                    get
                    {
                        var __ret = Internal.getText_0((__Instance + __PointerAdjustment));
                        return Marshal.PtrToStringAnsi(__ret);
                    }

                    set
                    {
                        var __arg0 = Marshal.StringToHGlobalAnsi(value);
                        Internal.setText_0((__Instance + __PointerAdjustment), __arg0);
                        Marshal.FreeHGlobal(__arg0);
                    }
                }

                public CppSharp.Parser.AST.MacroDefinition Definition
                {
                    get
                    {
                        CppSharp.Parser.AST.MacroDefinition __result0;
                        if (((Internal*) __Instance)->Definition == IntPtr.Zero) __result0 = null;
                        else if (CppSharp.Parser.AST.MacroDefinition.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->Definition))
                            __result0 = (CppSharp.Parser.AST.MacroDefinition) CppSharp.Parser.AST.MacroDefinition.NativeToManagedMap[((Internal*) __Instance)->Definition];
                        else __result0 = CppSharp.Parser.AST.MacroDefinition.__CreateInstance(((Internal*) __Instance)->Definition);
                        return __result0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->Definition = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }
            }

            public unsafe partial class TranslationUnit : CppSharp.Parser.AST.Namespace, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 504)]
                public new partial struct Internal
                {
                    [FieldOffset(0)]
                    public CppSharp.Parser.AST.DeclarationKind Kind;

                    [FieldOffset(4)]
                    public CppSharp.Parser.AST.AccessSpecifier Access;

                    [FieldOffset(8)]
                    public global::System.IntPtr _Namespace;

                    [FieldOffset(16)]
                    public CppSharp.Parser.SourceLocation.Internal Location;

                    [FieldOffset(20)]
                    public int LineNumberStart;

                    [FieldOffset(24)]
                    public int LineNumberEnd;

                    [FieldOffset(128)]
                    public byte IsIncomplete;

                    [FieldOffset(129)]
                    public byte IsDependent;

                    [FieldOffset(130)]
                    public byte IsImplicit;

                    [FieldOffset(136)]
                    public global::System.IntPtr CompleteDeclaration;

                    [FieldOffset(144)]
                    public uint DefinitionOrder;

                    [FieldOffset(176)]
                    public global::System.IntPtr OriginalPtr;

                    [FieldOffset(184)]
                    public global::System.IntPtr Comment;

                    [FieldOffset(424)]
                    public byte IsAnonymous;

                    [FieldOffset(432)]
                    public byte IsInline;

                    [FieldOffset(472)]
                    public byte IsSystemHeader;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0TranslationUnit@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0TranslationUnit@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1TranslationUnit@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor_0(global::System.IntPtr instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getMacros@TranslationUnit@AST@CppParser@CppSharp@@QEAAPEAVMacroDefinition@234@I@Z")]
                    internal static extern global::System.IntPtr getMacros_0(global::System.IntPtr instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?addMacros@TranslationUnit@AST@CppParser@CppSharp@@QEAAXAEAPEAVMacroDefinition@234@@Z")]
                    internal static extern void addMacros_0(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?clearMacros@TranslationUnit@AST@CppParser@CppSharp@@QEAAXXZ")]
                    internal static extern void clearMacros_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getFileName@TranslationUnit@AST@CppParser@CppSharp@@QEAAPEBDXZ")]
                    internal static extern global::System.IntPtr getFileName_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?setFileName@TranslationUnit@AST@CppParser@CppSharp@@QEAAXPEBD@Z")]
                    internal static extern void setFileName_0(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getMacrosCount@TranslationUnit@AST@CppParser@CppSharp@@QEAAIXZ")]
                    internal static extern uint getMacrosCount_0(global::System.IntPtr instance);
                }

                public static new TranslationUnit __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new TranslationUnit(native.ToPointer(), skipVTables);
                }

                public static TranslationUnit __CreateInstance(TranslationUnit.Internal native, bool skipVTables = false)
                {
                    return new TranslationUnit(native, skipVTables);
                }

                private static void* __CopyValue(TranslationUnit.Internal native)
                {
                    var ret = Marshal.AllocHGlobal(504);
                    CppSharp.Parser.AST.TranslationUnit.Internal.cctor_1(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private TranslationUnit(TranslationUnit.Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected TranslationUnit(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public TranslationUnit()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(504);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_0((__Instance + __PointerAdjustment));
                }

                public TranslationUnit(CppSharp.Parser.AST.TranslationUnit _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(504);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
                }

                protected override void Dispose(bool disposing)
                {
                    CppSharp.Parser.AST.Declaration __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    Internal.dtor_0((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public CppSharp.Parser.AST.MacroDefinition getMacros(uint i)
                {
                    var __ret = Internal.getMacros_0((__Instance + __PointerAdjustment), i);
                    CppSharp.Parser.AST.MacroDefinition __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (CppSharp.Parser.AST.MacroDefinition.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (CppSharp.Parser.AST.MacroDefinition) CppSharp.Parser.AST.MacroDefinition.NativeToManagedMap[__ret];
                    else __result0 = CppSharp.Parser.AST.MacroDefinition.__CreateInstance(__ret);
                    return __result0;
                }

                public void addMacros(CppSharp.Parser.AST.MacroDefinition s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    Internal.addMacros_0((__Instance + __PointerAdjustment), __arg0);
                }

                public void clearMacros()
                {
                    Internal.clearMacros_0((__Instance + __PointerAdjustment));
                }

                public string FileName
                {
                    get
                    {
                        var __ret = Internal.getFileName_0((__Instance + __PointerAdjustment));
                        return Marshal.PtrToStringAnsi(__ret);
                    }

                    set
                    {
                        var __arg0 = Marshal.StringToHGlobalAnsi(value);
                        Internal.setFileName_0((__Instance + __PointerAdjustment), __arg0);
                        Marshal.FreeHGlobal(__arg0);
                    }
                }

                public uint MacrosCount
                {
                    get
                    {
                        var __ret = Internal.getMacrosCount_0((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                public bool IsSystemHeader
                {
                    get
                    {
                        return ((Internal*) __Instance)->IsSystemHeader != 0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->IsSystemHeader = (byte) (value ? 1 : 0);
                    }
                }
            }

            public unsafe partial class NativeLibrary : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 88)]
                public partial struct Internal
                {
                    [FieldOffset(32)]
                    public CppSharp.Parser.AST.ArchType ArchType;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0NativeLibrary@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0NativeLibrary@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1NativeLibrary@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor_0(global::System.IntPtr instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getSymbols@NativeLibrary@AST@CppParser@CppSharp@@QEAAPEBDI@Z")]
                    internal static extern global::System.IntPtr getSymbols_0(global::System.IntPtr instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?addSymbols@NativeLibrary@AST@CppParser@CppSharp@@QEAAXPEBD@Z")]
                    internal static extern void addSymbols_0(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?clearSymbols@NativeLibrary@AST@CppParser@CppSharp@@QEAAXXZ")]
                    internal static extern void clearSymbols_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getDependencies@NativeLibrary@AST@CppParser@CppSharp@@QEAAPEBDI@Z")]
                    internal static extern global::System.IntPtr getDependencies_0(global::System.IntPtr instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?addDependencies@NativeLibrary@AST@CppParser@CppSharp@@QEAAXPEBD@Z")]
                    internal static extern void addDependencies_0(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?clearDependencies@NativeLibrary@AST@CppParser@CppSharp@@QEAAXXZ")]
                    internal static extern void clearDependencies_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getFileName@NativeLibrary@AST@CppParser@CppSharp@@QEAAPEBDXZ")]
                    internal static extern global::System.IntPtr getFileName_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?setFileName@NativeLibrary@AST@CppParser@CppSharp@@QEAAXPEBD@Z")]
                    internal static extern void setFileName_0(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getSymbolsCount@NativeLibrary@AST@CppParser@CppSharp@@QEAAIXZ")]
                    internal static extern uint getSymbolsCount_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getDependenciesCount@NativeLibrary@AST@CppParser@CppSharp@@QEAAIXZ")]
                    internal static extern uint getDependenciesCount_0(global::System.IntPtr instance);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                protected int __PointerAdjustment;
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, NativeLibrary> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, NativeLibrary>();
                protected void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                public static NativeLibrary __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new NativeLibrary(native.ToPointer(), skipVTables);
                }

                public static NativeLibrary __CreateInstance(NativeLibrary.Internal native, bool skipVTables = false)
                {
                    return new NativeLibrary(native, skipVTables);
                }

                private static void* __CopyValue(NativeLibrary.Internal native)
                {
                    var ret = Marshal.AllocHGlobal(88);
                    CppSharp.Parser.AST.NativeLibrary.Internal.cctor_1(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private NativeLibrary(NativeLibrary.Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected NativeLibrary(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public NativeLibrary()
                {
                    __Instance = Marshal.AllocHGlobal(88);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_0((__Instance + __PointerAdjustment));
                }

                public NativeLibrary(CppSharp.Parser.AST.NativeLibrary _0)
                {
                    __Instance = Marshal.AllocHGlobal(88);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    CppSharp.Parser.AST.NativeLibrary __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    Internal.dtor_0((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public string getSymbols(uint i)
                {
                    var __ret = Internal.getSymbols_0((__Instance + __PointerAdjustment), i);
                    return Marshal.PtrToStringAnsi(__ret);
                }

                public void addSymbols(string s)
                {
                    var __arg0 = Marshal.StringToHGlobalAnsi(s);
                    Internal.addSymbols_0((__Instance + __PointerAdjustment), __arg0);
                    Marshal.FreeHGlobal(__arg0);
                }

                public void clearSymbols()
                {
                    Internal.clearSymbols_0((__Instance + __PointerAdjustment));
                }

                public string getDependencies(uint i)
                {
                    var __ret = Internal.getDependencies_0((__Instance + __PointerAdjustment), i);
                    return Marshal.PtrToStringAnsi(__ret);
                }

                public void addDependencies(string s)
                {
                    var __arg0 = Marshal.StringToHGlobalAnsi(s);
                    Internal.addDependencies_0((__Instance + __PointerAdjustment), __arg0);
                    Marshal.FreeHGlobal(__arg0);
                }

                public void clearDependencies()
                {
                    Internal.clearDependencies_0((__Instance + __PointerAdjustment));
                }

                public string FileName
                {
                    get
                    {
                        var __ret = Internal.getFileName_0((__Instance + __PointerAdjustment));
                        return Marshal.PtrToStringAnsi(__ret);
                    }

                    set
                    {
                        var __arg0 = Marshal.StringToHGlobalAnsi(value);
                        Internal.setFileName_0((__Instance + __PointerAdjustment), __arg0);
                        Marshal.FreeHGlobal(__arg0);
                    }
                }

                public uint SymbolsCount
                {
                    get
                    {
                        var __ret = Internal.getSymbolsCount_0((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                public uint DependenciesCount
                {
                    get
                    {
                        var __ret = Internal.getDependenciesCount_0((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                public CppSharp.Parser.AST.ArchType ArchType
                {
                    get
                    {
                        return ((Internal*) __Instance)->ArchType;
                    }

                    set
                    {
                        ((Internal*) __Instance)->ArchType = value;
                    }
                }
            }

            public unsafe partial class ASTContext : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 24)]
                public partial struct Internal
                {
                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0ASTContext@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0ASTContext@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1ASTContext@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor_0(global::System.IntPtr instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getTranslationUnits@ASTContext@AST@CppParser@CppSharp@@QEAAPEAVTranslationUnit@234@I@Z")]
                    internal static extern global::System.IntPtr getTranslationUnits_0(global::System.IntPtr instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?addTranslationUnits@ASTContext@AST@CppParser@CppSharp@@QEAAXAEAPEAVTranslationUnit@234@@Z")]
                    internal static extern void addTranslationUnits_0(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?clearTranslationUnits@ASTContext@AST@CppParser@CppSharp@@QEAAXXZ")]
                    internal static extern void clearTranslationUnits_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getTranslationUnitsCount@ASTContext@AST@CppParser@CppSharp@@QEAAIXZ")]
                    internal static extern uint getTranslationUnitsCount_0(global::System.IntPtr instance);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                protected int __PointerAdjustment;
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ASTContext> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ASTContext>();
                protected void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                public static ASTContext __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new ASTContext(native.ToPointer(), skipVTables);
                }

                public static ASTContext __CreateInstance(ASTContext.Internal native, bool skipVTables = false)
                {
                    return new ASTContext(native, skipVTables);
                }

                private static void* __CopyValue(ASTContext.Internal native)
                {
                    var ret = Marshal.AllocHGlobal(24);
                    CppSharp.Parser.AST.ASTContext.Internal.cctor_1(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private ASTContext(ASTContext.Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected ASTContext(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public ASTContext()
                {
                    __Instance = Marshal.AllocHGlobal(24);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_0((__Instance + __PointerAdjustment));
                }

                public ASTContext(CppSharp.Parser.AST.ASTContext _0)
                {
                    __Instance = Marshal.AllocHGlobal(24);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    CppSharp.Parser.AST.ASTContext __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    Internal.dtor_0((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public CppSharp.Parser.AST.TranslationUnit getTranslationUnits(uint i)
                {
                    var __ret = Internal.getTranslationUnits_0((__Instance + __PointerAdjustment), i);
                    CppSharp.Parser.AST.TranslationUnit __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (CppSharp.Parser.AST.TranslationUnit.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (CppSharp.Parser.AST.TranslationUnit) CppSharp.Parser.AST.TranslationUnit.NativeToManagedMap[__ret];
                    else __result0 = CppSharp.Parser.AST.TranslationUnit.__CreateInstance(__ret);
                    return __result0;
                }

                public void addTranslationUnits(CppSharp.Parser.AST.TranslationUnit s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    Internal.addTranslationUnits_0((__Instance + __PointerAdjustment), __arg0);
                }

                public void clearTranslationUnits()
                {
                    Internal.clearTranslationUnits_0((__Instance + __PointerAdjustment));
                }

                public uint TranslationUnitsCount
                {
                    get
                    {
                        var __ret = Internal.getTranslationUnitsCount_0((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }
            }

            public unsafe partial class Comment : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 4)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public CppSharp.Parser.AST.CommentKind Kind;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0Comment@AST@CppParser@CppSharp@@QEAA@W4CommentKind@123@@Z")]
                    internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance, CppSharp.Parser.AST.CommentKind kind);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0Comment@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                protected int __PointerAdjustment;
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, Comment> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, Comment>();
                protected void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                public static Comment __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new Comment(native.ToPointer(), skipVTables);
                }

                public static Comment __CreateInstance(Comment.Internal native, bool skipVTables = false)
                {
                    return new Comment(native, skipVTables);
                }

                private static void* __CopyValue(Comment.Internal native)
                {
                    var ret = Marshal.AllocHGlobal(4);
                    *(Comment.Internal*) ret = native;
                    return ret.ToPointer();
                }

                private Comment(Comment.Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected Comment(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public Comment(CppSharp.Parser.AST.CommentKind kind)
                {
                    __Instance = Marshal.AllocHGlobal(4);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    var __arg0 = kind;
                    Internal.ctor_0((__Instance + __PointerAdjustment), __arg0);
                }

                public Comment(CppSharp.Parser.AST.Comment _0)
                {
                    __Instance = Marshal.AllocHGlobal(4);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((Comment.Internal*) __Instance) = *((Comment.Internal*) _0.__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    CppSharp.Parser.AST.Comment __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public CppSharp.Parser.AST.CommentKind Kind
                {
                    get
                    {
                        return ((Internal*) __Instance)->Kind;
                    }

                    set
                    {
                        ((Internal*) __Instance)->Kind = value;
                    }
                }
            }

            public unsafe partial class BlockContentComment : CppSharp.Parser.AST.Comment, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 4)]
                public new partial struct Internal
                {
                    [FieldOffset(0)]
                    public CppSharp.Parser.AST.CommentKind Kind;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0BlockContentComment@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0BlockContentComment@AST@CppParser@CppSharp@@QEAA@W4CommentKind@123@@Z")]
                    internal static extern global::System.IntPtr ctor_1(global::System.IntPtr instance, CppSharp.Parser.AST.CommentKind Kind);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0BlockContentComment@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public static new BlockContentComment __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new BlockContentComment(native.ToPointer(), skipVTables);
                }

                public static BlockContentComment __CreateInstance(BlockContentComment.Internal native, bool skipVTables = false)
                {
                    return new BlockContentComment(native, skipVTables);
                }

                private static void* __CopyValue(BlockContentComment.Internal native)
                {
                    var ret = Marshal.AllocHGlobal(4);
                    *(BlockContentComment.Internal*) ret = native;
                    return ret.ToPointer();
                }

                private BlockContentComment(BlockContentComment.Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected BlockContentComment(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public BlockContentComment()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(4);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_0((__Instance + __PointerAdjustment));
                }

                public BlockContentComment(CppSharp.Parser.AST.CommentKind Kind)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(4);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    var __arg0 = Kind;
                    Internal.ctor_1((__Instance + __PointerAdjustment), __arg0);
                }

                public BlockContentComment(CppSharp.Parser.AST.BlockContentComment _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(4);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((BlockContentComment.Internal*) __Instance) = *((BlockContentComment.Internal*) _0.__Instance);
                }
            }

            public unsafe partial class FullComment : CppSharp.Parser.AST.Comment, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 32)]
                public new partial struct Internal
                {
                    [FieldOffset(0)]
                    public CppSharp.Parser.AST.CommentKind Kind;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0FullComment@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0FullComment@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1FullComment@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor_0(global::System.IntPtr instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getBlocks@FullComment@AST@CppParser@CppSharp@@QEAAPEAVBlockContentComment@234@I@Z")]
                    internal static extern global::System.IntPtr getBlocks_0(global::System.IntPtr instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?addBlocks@FullComment@AST@CppParser@CppSharp@@QEAAXAEAPEAVBlockContentComment@234@@Z")]
                    internal static extern void addBlocks_0(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?clearBlocks@FullComment@AST@CppParser@CppSharp@@QEAAXXZ")]
                    internal static extern void clearBlocks_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getBlocksCount@FullComment@AST@CppParser@CppSharp@@QEAAIXZ")]
                    internal static extern uint getBlocksCount_0(global::System.IntPtr instance);
                }

                public static new FullComment __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new FullComment(native.ToPointer(), skipVTables);
                }

                public static FullComment __CreateInstance(FullComment.Internal native, bool skipVTables = false)
                {
                    return new FullComment(native, skipVTables);
                }

                private static void* __CopyValue(FullComment.Internal native)
                {
                    var ret = Marshal.AllocHGlobal(32);
                    CppSharp.Parser.AST.FullComment.Internal.cctor_1(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private FullComment(FullComment.Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected FullComment(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public FullComment()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(32);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_0((__Instance + __PointerAdjustment));
                }

                public FullComment(CppSharp.Parser.AST.FullComment _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(32);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
                }

                protected override void Dispose(bool disposing)
                {
                    CppSharp.Parser.AST.Comment __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    Internal.dtor_0((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public CppSharp.Parser.AST.BlockContentComment getBlocks(uint i)
                {
                    var __ret = Internal.getBlocks_0((__Instance + __PointerAdjustment), i);
                    CppSharp.Parser.AST.BlockContentComment __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (CppSharp.Parser.AST.BlockContentComment.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (CppSharp.Parser.AST.BlockContentComment) CppSharp.Parser.AST.BlockContentComment.NativeToManagedMap[__ret];
                    else __result0 = CppSharp.Parser.AST.BlockContentComment.__CreateInstance(__ret);
                    return __result0;
                }

                public void addBlocks(CppSharp.Parser.AST.BlockContentComment s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    Internal.addBlocks_0((__Instance + __PointerAdjustment), __arg0);
                }

                public void clearBlocks()
                {
                    Internal.clearBlocks_0((__Instance + __PointerAdjustment));
                }

                public uint BlocksCount
                {
                    get
                    {
                        var __ret = Internal.getBlocksCount_0((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }
            }

            public unsafe partial class InlineContentComment : CppSharp.Parser.AST.Comment, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 8)]
                public new partial struct Internal
                {
                    [FieldOffset(0)]
                    public CppSharp.Parser.AST.CommentKind Kind;

                    [FieldOffset(4)]
                    public byte HasTrailingNewline;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0InlineContentComment@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0InlineContentComment@AST@CppParser@CppSharp@@QEAA@W4CommentKind@123@@Z")]
                    internal static extern global::System.IntPtr ctor_1(global::System.IntPtr instance, CppSharp.Parser.AST.CommentKind Kind);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0InlineContentComment@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public static new InlineContentComment __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new InlineContentComment(native.ToPointer(), skipVTables);
                }

                public static InlineContentComment __CreateInstance(InlineContentComment.Internal native, bool skipVTables = false)
                {
                    return new InlineContentComment(native, skipVTables);
                }

                private static void* __CopyValue(InlineContentComment.Internal native)
                {
                    var ret = Marshal.AllocHGlobal(8);
                    *(InlineContentComment.Internal*) ret = native;
                    return ret.ToPointer();
                }

                private InlineContentComment(InlineContentComment.Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected InlineContentComment(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public InlineContentComment()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(8);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_0((__Instance + __PointerAdjustment));
                }

                public InlineContentComment(CppSharp.Parser.AST.CommentKind Kind)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(8);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    var __arg0 = Kind;
                    Internal.ctor_1((__Instance + __PointerAdjustment), __arg0);
                }

                public InlineContentComment(CppSharp.Parser.AST.InlineContentComment _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(8);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((InlineContentComment.Internal*) __Instance) = *((InlineContentComment.Internal*) _0.__Instance);
                }

                public bool HasTrailingNewline
                {
                    get
                    {
                        return ((Internal*) __Instance)->HasTrailingNewline != 0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->HasTrailingNewline = (byte) (value ? 1 : 0);
                    }
                }
            }

            public unsafe partial class ParagraphComment : CppSharp.Parser.AST.BlockContentComment, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 32)]
                public new partial struct Internal
                {
                    [FieldOffset(0)]
                    public CppSharp.Parser.AST.CommentKind Kind;

                    [FieldOffset(4)]
                    public byte IsWhitespace;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0ParagraphComment@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0ParagraphComment@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1ParagraphComment@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor_0(global::System.IntPtr instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getContent@ParagraphComment@AST@CppParser@CppSharp@@QEAAPEAVInlineContentComment@234@I@Z")]
                    internal static extern global::System.IntPtr getContent_0(global::System.IntPtr instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?addContent@ParagraphComment@AST@CppParser@CppSharp@@QEAAXAEAPEAVInlineContentComment@234@@Z")]
                    internal static extern void addContent_0(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?clearContent@ParagraphComment@AST@CppParser@CppSharp@@QEAAXXZ")]
                    internal static extern void clearContent_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getContentCount@ParagraphComment@AST@CppParser@CppSharp@@QEAAIXZ")]
                    internal static extern uint getContentCount_0(global::System.IntPtr instance);
                }

                public static new ParagraphComment __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new ParagraphComment(native.ToPointer(), skipVTables);
                }

                public static ParagraphComment __CreateInstance(ParagraphComment.Internal native, bool skipVTables = false)
                {
                    return new ParagraphComment(native, skipVTables);
                }

                private static void* __CopyValue(ParagraphComment.Internal native)
                {
                    var ret = Marshal.AllocHGlobal(32);
                    CppSharp.Parser.AST.ParagraphComment.Internal.cctor_1(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private ParagraphComment(ParagraphComment.Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected ParagraphComment(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public ParagraphComment()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(32);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_0((__Instance + __PointerAdjustment));
                }

                public ParagraphComment(CppSharp.Parser.AST.ParagraphComment _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(32);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
                }

                protected override void Dispose(bool disposing)
                {
                    CppSharp.Parser.AST.Comment __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    Internal.dtor_0((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public CppSharp.Parser.AST.InlineContentComment getContent(uint i)
                {
                    var __ret = Internal.getContent_0((__Instance + __PointerAdjustment), i);
                    CppSharp.Parser.AST.InlineContentComment __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (CppSharp.Parser.AST.InlineContentComment.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (CppSharp.Parser.AST.InlineContentComment) CppSharp.Parser.AST.InlineContentComment.NativeToManagedMap[__ret];
                    else __result0 = CppSharp.Parser.AST.InlineContentComment.__CreateInstance(__ret);
                    return __result0;
                }

                public void addContent(CppSharp.Parser.AST.InlineContentComment s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    Internal.addContent_0((__Instance + __PointerAdjustment), __arg0);
                }

                public void clearContent()
                {
                    Internal.clearContent_0((__Instance + __PointerAdjustment));
                }

                public uint ContentCount
                {
                    get
                    {
                        var __ret = Internal.getContentCount_0((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                public bool IsWhitespace
                {
                    get
                    {
                        return ((Internal*) __Instance)->IsWhitespace != 0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->IsWhitespace = (byte) (value ? 1 : 0);
                    }
                }
            }

            public unsafe partial class BlockCommandComment : CppSharp.Parser.AST.BlockContentComment, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 40)]
                public new partial struct Internal
                {
                    [FieldOffset(0)]
                    public CppSharp.Parser.AST.CommentKind Kind;

                    [FieldOffset(4)]
                    public uint CommandId;

                    [FieldOffset(8)]
                    public global::System.IntPtr ParagraphComment;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0BlockCommandComment@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0BlockCommandComment@AST@CppParser@CppSharp@@QEAA@W4CommentKind@123@@Z")]
                    internal static extern global::System.IntPtr ctor_1(global::System.IntPtr instance, CppSharp.Parser.AST.CommentKind Kind);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0BlockCommandComment@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1BlockCommandComment@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor_0(global::System.IntPtr instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getArguments@BlockCommandComment@AST@CppParser@CppSharp@@QEAA?AVArgument@1234@I@Z")]
                    internal static extern void getArguments_0(global::System.IntPtr instance, global::System.IntPtr @return, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?addArguments@BlockCommandComment@AST@CppParser@CppSharp@@QEAAXAEAVArgument@1234@@Z")]
                    internal static extern void addArguments_0(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?clearArguments@BlockCommandComment@AST@CppParser@CppSharp@@QEAAXXZ")]
                    internal static extern void clearArguments_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getArgumentsCount@BlockCommandComment@AST@CppParser@CppSharp@@QEAAIXZ")]
                    internal static extern uint getArgumentsCount_0(global::System.IntPtr instance);
                }

                public unsafe partial class Argument : IDisposable
                {
                    [StructLayout(LayoutKind.Explicit, Size = 32)]
                    public partial struct Internal
                    {
                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="??0Argument@BlockCommandComment@AST@CppParser@CppSharp@@QEAA@XZ")]
                        internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="??0Argument@BlockCommandComment@AST@CppParser@CppSharp@@QEAA@AEBV01234@@Z")]
                        internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="??1Argument@BlockCommandComment@AST@CppParser@CppSharp@@QEAA@XZ")]
                        internal static extern void dtor_0(global::System.IntPtr instance, int delete);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="?getText@Argument@BlockCommandComment@AST@CppParser@CppSharp@@QEAAPEBDXZ")]
                        internal static extern global::System.IntPtr getText_0(global::System.IntPtr instance);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="?setText@Argument@BlockCommandComment@AST@CppParser@CppSharp@@QEAAXPEBD@Z")]
                        internal static extern void setText_0(global::System.IntPtr instance, global::System.IntPtr s);
                    }

                    public global::System.IntPtr __Instance { get; protected set; }

                    protected int __PointerAdjustment;
                    public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, Argument> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, Argument>();
                    protected void*[] __OriginalVTables;

                    protected bool __ownsNativeInstance;

                    public static Argument __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                    {
                        return new Argument(native.ToPointer(), skipVTables);
                    }

                    public static Argument __CreateInstance(Argument.Internal native, bool skipVTables = false)
                    {
                        return new Argument(native, skipVTables);
                    }

                    private static void* __CopyValue(Argument.Internal native)
                    {
                        var ret = Marshal.AllocHGlobal(32);
                        CppSharp.Parser.AST.BlockCommandComment.Argument.Internal.cctor_1(ret, new global::System.IntPtr(&native));
                        return ret.ToPointer();
                    }

                    private Argument(Argument.Internal native, bool skipVTables = false)
                        : this(__CopyValue(native), skipVTables)
                    {
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                    }

                    protected Argument(void* native, bool skipVTables = false)
                    {
                        if (native == null)
                            return;
                        __Instance = new global::System.IntPtr(native);
                    }

                    public Argument()
                    {
                        __Instance = Marshal.AllocHGlobal(32);
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                        Internal.ctor_0((__Instance + __PointerAdjustment));
                    }

                    public Argument(CppSharp.Parser.AST.BlockCommandComment.Argument _0)
                    {
                        __Instance = Marshal.AllocHGlobal(32);
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                        if (ReferenceEquals(_0, null))
                            throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                        var __arg0 = _0.__Instance;
                        Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
                    }

                    public void Dispose()
                    {
                        Dispose(disposing: true);
                    }

                    protected virtual void Dispose(bool disposing)
                    {
                        CppSharp.Parser.AST.BlockCommandComment.Argument __dummy;
                        NativeToManagedMap.TryRemove(__Instance, out __dummy);
                        Internal.dtor_0((__Instance + __PointerAdjustment), 0);
                        if (__ownsNativeInstance)
                            Marshal.FreeHGlobal(__Instance);
                    }

                    public string Text
                    {
                        get
                        {
                            var __ret = Internal.getText_0((__Instance + __PointerAdjustment));
                            return Marshal.PtrToStringAnsi(__ret);
                        }

                        set
                        {
                            var __arg0 = Marshal.StringToHGlobalAnsi(value);
                            Internal.setText_0((__Instance + __PointerAdjustment), __arg0);
                            Marshal.FreeHGlobal(__arg0);
                        }
                    }
                }

                public static new BlockCommandComment __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new BlockCommandComment(native.ToPointer(), skipVTables);
                }

                public static BlockCommandComment __CreateInstance(BlockCommandComment.Internal native, bool skipVTables = false)
                {
                    return new BlockCommandComment(native, skipVTables);
                }

                private static void* __CopyValue(BlockCommandComment.Internal native)
                {
                    var ret = Marshal.AllocHGlobal(40);
                    CppSharp.Parser.AST.BlockCommandComment.Internal.cctor_2(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private BlockCommandComment(BlockCommandComment.Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected BlockCommandComment(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public BlockCommandComment()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(40);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_0((__Instance + __PointerAdjustment));
                }

                public BlockCommandComment(CppSharp.Parser.AST.CommentKind Kind)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(40);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    var __arg0 = Kind;
                    Internal.ctor_1((__Instance + __PointerAdjustment), __arg0);
                }

                public BlockCommandComment(CppSharp.Parser.AST.BlockCommandComment _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(40);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    Internal.cctor_2((__Instance + __PointerAdjustment), __arg0);
                }

                protected override void Dispose(bool disposing)
                {
                    CppSharp.Parser.AST.Comment __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    Internal.dtor_0((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public CppSharp.Parser.AST.BlockCommandComment.Argument getArguments(uint i)
                {
                    var __ret = new CppSharp.Parser.AST.BlockCommandComment.Argument.Internal();
                    Internal.getArguments_0((__Instance + __PointerAdjustment), new IntPtr(&__ret), i);
                    return CppSharp.Parser.AST.BlockCommandComment.Argument.__CreateInstance(__ret);
                }

                public void addArguments(CppSharp.Parser.AST.BlockCommandComment.Argument s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    Internal.addArguments_0((__Instance + __PointerAdjustment), __arg0);
                }

                public void clearArguments()
                {
                    Internal.clearArguments_0((__Instance + __PointerAdjustment));
                }

                public uint ArgumentsCount
                {
                    get
                    {
                        var __ret = Internal.getArgumentsCount_0((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                public uint CommandId
                {
                    get
                    {
                        return ((Internal*) __Instance)->CommandId;
                    }

                    set
                    {
                        ((Internal*) __Instance)->CommandId = value;
                    }
                }

                public CppSharp.Parser.AST.ParagraphComment ParagraphComment
                {
                    get
                    {
                        CppSharp.Parser.AST.ParagraphComment __result0;
                        if (((Internal*) __Instance)->ParagraphComment == IntPtr.Zero) __result0 = null;
                        else if (CppSharp.Parser.AST.ParagraphComment.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->ParagraphComment))
                            __result0 = (CppSharp.Parser.AST.ParagraphComment) CppSharp.Parser.AST.ParagraphComment.NativeToManagedMap[((Internal*) __Instance)->ParagraphComment];
                        else __result0 = CppSharp.Parser.AST.ParagraphComment.__CreateInstance(((Internal*) __Instance)->ParagraphComment);
                        return __result0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->ParagraphComment = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }
            }

            public unsafe partial class ParamCommandComment : CppSharp.Parser.AST.BlockCommandComment, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 48)]
                public new partial struct Internal
                {
                    [FieldOffset(0)]
                    public CppSharp.Parser.AST.CommentKind Kind;

                    [FieldOffset(4)]
                    public uint CommandId;

                    [FieldOffset(8)]
                    public global::System.IntPtr ParagraphComment;

                    [FieldOffset(40)]
                    public CppSharp.Parser.AST.ParamCommandComment.PassDirection Direction;

                    [FieldOffset(44)]
                    public uint ParamIndex;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0ParamCommandComment@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0ParamCommandComment@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1ParamCommandComment@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor_0(global::System.IntPtr instance, int delete);
                }

                public enum PassDirection
                {
                    In = 0,
                    Out = 1,
                    InOut = 2
                }

                public static new ParamCommandComment __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new ParamCommandComment(native.ToPointer(), skipVTables);
                }

                public static ParamCommandComment __CreateInstance(ParamCommandComment.Internal native, bool skipVTables = false)
                {
                    return new ParamCommandComment(native, skipVTables);
                }

                private static void* __CopyValue(ParamCommandComment.Internal native)
                {
                    var ret = Marshal.AllocHGlobal(48);
                    CppSharp.Parser.AST.ParamCommandComment.Internal.cctor_2(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private ParamCommandComment(ParamCommandComment.Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected ParamCommandComment(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public ParamCommandComment()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(48);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_0((__Instance + __PointerAdjustment));
                }

                public ParamCommandComment(CppSharp.Parser.AST.ParamCommandComment _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(48);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    Internal.cctor_2((__Instance + __PointerAdjustment), __arg0);
                }

                protected override void Dispose(bool disposing)
                {
                    CppSharp.Parser.AST.Comment __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    Internal.dtor_0((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public CppSharp.Parser.AST.ParamCommandComment.PassDirection Direction
                {
                    get
                    {
                        return ((Internal*) __Instance)->Direction;
                    }

                    set
                    {
                        ((Internal*) __Instance)->Direction = value;
                    }
                }

                public uint ParamIndex
                {
                    get
                    {
                        return ((Internal*) __Instance)->ParamIndex;
                    }

                    set
                    {
                        ((Internal*) __Instance)->ParamIndex = value;
                    }
                }
            }

            public unsafe partial class TParamCommandComment : CppSharp.Parser.AST.BlockCommandComment, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 64)]
                public new partial struct Internal
                {
                    [FieldOffset(0)]
                    public CppSharp.Parser.AST.CommentKind Kind;

                    [FieldOffset(4)]
                    public uint CommandId;

                    [FieldOffset(8)]
                    public global::System.IntPtr ParagraphComment;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0TParamCommandComment@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0TParamCommandComment@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1TParamCommandComment@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor_0(global::System.IntPtr instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getPosition@TParamCommandComment@AST@CppParser@CppSharp@@QEAAII@Z")]
                    internal static extern uint getPosition_0(global::System.IntPtr instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?addPosition@TParamCommandComment@AST@CppParser@CppSharp@@QEAAXAEAI@Z")]
                    internal static extern void addPosition_0(global::System.IntPtr instance, uint* s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?clearPosition@TParamCommandComment@AST@CppParser@CppSharp@@QEAAXXZ")]
                    internal static extern void clearPosition_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getPositionCount@TParamCommandComment@AST@CppParser@CppSharp@@QEAAIXZ")]
                    internal static extern uint getPositionCount_0(global::System.IntPtr instance);
                }

                public static new TParamCommandComment __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new TParamCommandComment(native.ToPointer(), skipVTables);
                }

                public static TParamCommandComment __CreateInstance(TParamCommandComment.Internal native, bool skipVTables = false)
                {
                    return new TParamCommandComment(native, skipVTables);
                }

                private static void* __CopyValue(TParamCommandComment.Internal native)
                {
                    var ret = Marshal.AllocHGlobal(64);
                    CppSharp.Parser.AST.TParamCommandComment.Internal.cctor_2(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private TParamCommandComment(TParamCommandComment.Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected TParamCommandComment(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public TParamCommandComment()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(64);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_0((__Instance + __PointerAdjustment));
                }

                public TParamCommandComment(CppSharp.Parser.AST.TParamCommandComment _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(64);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    Internal.cctor_2((__Instance + __PointerAdjustment), __arg0);
                }

                protected override void Dispose(bool disposing)
                {
                    CppSharp.Parser.AST.Comment __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    Internal.dtor_0((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public uint getPosition(uint i)
                {
                    var __ret = Internal.getPosition_0((__Instance + __PointerAdjustment), i);
                    return __ret;
                }

                public void addPosition(ref uint s)
                {
                    fixed (uint* __refParamPtr0 = &s)
                    {
                        var __arg0 = __refParamPtr0;
                        Internal.addPosition_0((__Instance + __PointerAdjustment), __arg0);
                    }
                }

                public void clearPosition()
                {
                    Internal.clearPosition_0((__Instance + __PointerAdjustment));
                }

                public uint PositionCount
                {
                    get
                    {
                        var __ret = Internal.getPositionCount_0((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }
            }

            public unsafe partial class VerbatimBlockLineComment : CppSharp.Parser.AST.Comment, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 40)]
                public new partial struct Internal
                {
                    [FieldOffset(0)]
                    public CppSharp.Parser.AST.CommentKind Kind;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0VerbatimBlockLineComment@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0VerbatimBlockLineComment@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1VerbatimBlockLineComment@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor_0(global::System.IntPtr instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getText@VerbatimBlockLineComment@AST@CppParser@CppSharp@@QEAAPEBDXZ")]
                    internal static extern global::System.IntPtr getText_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?setText@VerbatimBlockLineComment@AST@CppParser@CppSharp@@QEAAXPEBD@Z")]
                    internal static extern void setText_0(global::System.IntPtr instance, global::System.IntPtr s);
                }

                public static new VerbatimBlockLineComment __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new VerbatimBlockLineComment(native.ToPointer(), skipVTables);
                }

                public static VerbatimBlockLineComment __CreateInstance(VerbatimBlockLineComment.Internal native, bool skipVTables = false)
                {
                    return new VerbatimBlockLineComment(native, skipVTables);
                }

                private static void* __CopyValue(VerbatimBlockLineComment.Internal native)
                {
                    var ret = Marshal.AllocHGlobal(40);
                    CppSharp.Parser.AST.VerbatimBlockLineComment.Internal.cctor_2(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private VerbatimBlockLineComment(VerbatimBlockLineComment.Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected VerbatimBlockLineComment(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public VerbatimBlockLineComment()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(40);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_0((__Instance + __PointerAdjustment));
                }

                public VerbatimBlockLineComment(CppSharp.Parser.AST.VerbatimBlockLineComment _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(40);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    Internal.cctor_2((__Instance + __PointerAdjustment), __arg0);
                }

                protected override void Dispose(bool disposing)
                {
                    CppSharp.Parser.AST.Comment __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    Internal.dtor_0((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public string Text
                {
                    get
                    {
                        var __ret = Internal.getText_0((__Instance + __PointerAdjustment));
                        return Marshal.PtrToStringAnsi(__ret);
                    }

                    set
                    {
                        var __arg0 = Marshal.StringToHGlobalAnsi(value);
                        Internal.setText_0((__Instance + __PointerAdjustment), __arg0);
                        Marshal.FreeHGlobal(__arg0);
                    }
                }
            }

            public unsafe partial class VerbatimBlockComment : CppSharp.Parser.AST.BlockCommandComment, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 64)]
                public new partial struct Internal
                {
                    [FieldOffset(0)]
                    public CppSharp.Parser.AST.CommentKind Kind;

                    [FieldOffset(4)]
                    public uint CommandId;

                    [FieldOffset(8)]
                    public global::System.IntPtr ParagraphComment;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0VerbatimBlockComment@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0VerbatimBlockComment@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1VerbatimBlockComment@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor_0(global::System.IntPtr instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getLines@VerbatimBlockComment@AST@CppParser@CppSharp@@QEAAPEAVVerbatimBlockLineComment@234@I@Z")]
                    internal static extern global::System.IntPtr getLines_0(global::System.IntPtr instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?addLines@VerbatimBlockComment@AST@CppParser@CppSharp@@QEAAXAEAPEAVVerbatimBlockLineComment@234@@Z")]
                    internal static extern void addLines_0(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?clearLines@VerbatimBlockComment@AST@CppParser@CppSharp@@QEAAXXZ")]
                    internal static extern void clearLines_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getLinesCount@VerbatimBlockComment@AST@CppParser@CppSharp@@QEAAIXZ")]
                    internal static extern uint getLinesCount_0(global::System.IntPtr instance);
                }

                public static new VerbatimBlockComment __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new VerbatimBlockComment(native.ToPointer(), skipVTables);
                }

                public static VerbatimBlockComment __CreateInstance(VerbatimBlockComment.Internal native, bool skipVTables = false)
                {
                    return new VerbatimBlockComment(native, skipVTables);
                }

                private static void* __CopyValue(VerbatimBlockComment.Internal native)
                {
                    var ret = Marshal.AllocHGlobal(64);
                    CppSharp.Parser.AST.VerbatimBlockComment.Internal.cctor_1(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private VerbatimBlockComment(VerbatimBlockComment.Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected VerbatimBlockComment(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public VerbatimBlockComment()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(64);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_0((__Instance + __PointerAdjustment));
                }

                public VerbatimBlockComment(CppSharp.Parser.AST.VerbatimBlockComment _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(64);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
                }

                protected override void Dispose(bool disposing)
                {
                    CppSharp.Parser.AST.Comment __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    Internal.dtor_0((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public CppSharp.Parser.AST.VerbatimBlockLineComment getLines(uint i)
                {
                    var __ret = Internal.getLines_0((__Instance + __PointerAdjustment), i);
                    CppSharp.Parser.AST.VerbatimBlockLineComment __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (CppSharp.Parser.AST.VerbatimBlockLineComment.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (CppSharp.Parser.AST.VerbatimBlockLineComment) CppSharp.Parser.AST.VerbatimBlockLineComment.NativeToManagedMap[__ret];
                    else __result0 = CppSharp.Parser.AST.VerbatimBlockLineComment.__CreateInstance(__ret);
                    return __result0;
                }

                public void addLines(CppSharp.Parser.AST.VerbatimBlockLineComment s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    Internal.addLines_0((__Instance + __PointerAdjustment), __arg0);
                }

                public void clearLines()
                {
                    Internal.clearLines_0((__Instance + __PointerAdjustment));
                }

                public uint LinesCount
                {
                    get
                    {
                        var __ret = Internal.getLinesCount_0((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }
            }

            public unsafe partial class VerbatimLineComment : CppSharp.Parser.AST.BlockCommandComment, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 72)]
                public new partial struct Internal
                {
                    [FieldOffset(0)]
                    public CppSharp.Parser.AST.CommentKind Kind;

                    [FieldOffset(4)]
                    public uint CommandId;

                    [FieldOffset(8)]
                    public global::System.IntPtr ParagraphComment;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0VerbatimLineComment@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0VerbatimLineComment@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1VerbatimLineComment@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor_0(global::System.IntPtr instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getText@VerbatimLineComment@AST@CppParser@CppSharp@@QEAAPEBDXZ")]
                    internal static extern global::System.IntPtr getText_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?setText@VerbatimLineComment@AST@CppParser@CppSharp@@QEAAXPEBD@Z")]
                    internal static extern void setText_0(global::System.IntPtr instance, global::System.IntPtr s);
                }

                public static new VerbatimLineComment __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new VerbatimLineComment(native.ToPointer(), skipVTables);
                }

                public static VerbatimLineComment __CreateInstance(VerbatimLineComment.Internal native, bool skipVTables = false)
                {
                    return new VerbatimLineComment(native, skipVTables);
                }

                private static void* __CopyValue(VerbatimLineComment.Internal native)
                {
                    var ret = Marshal.AllocHGlobal(72);
                    CppSharp.Parser.AST.VerbatimLineComment.Internal.cctor_2(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private VerbatimLineComment(VerbatimLineComment.Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected VerbatimLineComment(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public VerbatimLineComment()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(72);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_0((__Instance + __PointerAdjustment));
                }

                public VerbatimLineComment(CppSharp.Parser.AST.VerbatimLineComment _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(72);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    Internal.cctor_2((__Instance + __PointerAdjustment), __arg0);
                }

                protected override void Dispose(bool disposing)
                {
                    CppSharp.Parser.AST.Comment __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    Internal.dtor_0((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public string Text
                {
                    get
                    {
                        var __ret = Internal.getText_0((__Instance + __PointerAdjustment));
                        return Marshal.PtrToStringAnsi(__ret);
                    }

                    set
                    {
                        var __arg0 = Marshal.StringToHGlobalAnsi(value);
                        Internal.setText_0((__Instance + __PointerAdjustment), __arg0);
                        Marshal.FreeHGlobal(__arg0);
                    }
                }
            }

            public unsafe partial class InlineCommandComment : CppSharp.Parser.AST.InlineContentComment, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 40)]
                public new partial struct Internal
                {
                    [FieldOffset(0)]
                    public CppSharp.Parser.AST.CommentKind Kind;

                    [FieldOffset(4)]
                    public byte HasTrailingNewline;

                    [FieldOffset(8)]
                    public uint CommandId;

                    [FieldOffset(12)]
                    public CppSharp.Parser.AST.InlineCommandComment.RenderKind CommentRenderKind;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0InlineCommandComment@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0InlineCommandComment@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1InlineCommandComment@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor_0(global::System.IntPtr instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getArguments@InlineCommandComment@AST@CppParser@CppSharp@@QEAA?AVArgument@1234@I@Z")]
                    internal static extern void getArguments_0(global::System.IntPtr instance, global::System.IntPtr @return, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?addArguments@InlineCommandComment@AST@CppParser@CppSharp@@QEAAXAEAVArgument@1234@@Z")]
                    internal static extern void addArguments_0(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?clearArguments@InlineCommandComment@AST@CppParser@CppSharp@@QEAAXXZ")]
                    internal static extern void clearArguments_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getArgumentsCount@InlineCommandComment@AST@CppParser@CppSharp@@QEAAIXZ")]
                    internal static extern uint getArgumentsCount_0(global::System.IntPtr instance);
                }

                public enum RenderKind
                {
                    RenderNormal = 0,
                    RenderBold = 1,
                    RenderMonospaced = 2,
                    RenderEmphasized = 3
                }

                public unsafe partial class Argument : IDisposable
                {
                    [StructLayout(LayoutKind.Explicit, Size = 32)]
                    public partial struct Internal
                    {
                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="??0Argument@InlineCommandComment@AST@CppParser@CppSharp@@QEAA@XZ")]
                        internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="??0Argument@InlineCommandComment@AST@CppParser@CppSharp@@QEAA@AEBV01234@@Z")]
                        internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="??1Argument@InlineCommandComment@AST@CppParser@CppSharp@@QEAA@XZ")]
                        internal static extern void dtor_0(global::System.IntPtr instance, int delete);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="?getText@Argument@InlineCommandComment@AST@CppParser@CppSharp@@QEAAPEBDXZ")]
                        internal static extern global::System.IntPtr getText_0(global::System.IntPtr instance);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="?setText@Argument@InlineCommandComment@AST@CppParser@CppSharp@@QEAAXPEBD@Z")]
                        internal static extern void setText_0(global::System.IntPtr instance, global::System.IntPtr s);
                    }

                    public global::System.IntPtr __Instance { get; protected set; }

                    protected int __PointerAdjustment;
                    public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, Argument> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, Argument>();
                    protected void*[] __OriginalVTables;

                    protected bool __ownsNativeInstance;

                    public static Argument __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                    {
                        return new Argument(native.ToPointer(), skipVTables);
                    }

                    public static Argument __CreateInstance(Argument.Internal native, bool skipVTables = false)
                    {
                        return new Argument(native, skipVTables);
                    }

                    private static void* __CopyValue(Argument.Internal native)
                    {
                        var ret = Marshal.AllocHGlobal(32);
                        CppSharp.Parser.AST.InlineCommandComment.Argument.Internal.cctor_1(ret, new global::System.IntPtr(&native));
                        return ret.ToPointer();
                    }

                    private Argument(Argument.Internal native, bool skipVTables = false)
                        : this(__CopyValue(native), skipVTables)
                    {
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                    }

                    protected Argument(void* native, bool skipVTables = false)
                    {
                        if (native == null)
                            return;
                        __Instance = new global::System.IntPtr(native);
                    }

                    public Argument()
                    {
                        __Instance = Marshal.AllocHGlobal(32);
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                        Internal.ctor_0((__Instance + __PointerAdjustment));
                    }

                    public Argument(CppSharp.Parser.AST.InlineCommandComment.Argument _0)
                    {
                        __Instance = Marshal.AllocHGlobal(32);
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                        if (ReferenceEquals(_0, null))
                            throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                        var __arg0 = _0.__Instance;
                        Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
                    }

                    public void Dispose()
                    {
                        Dispose(disposing: true);
                    }

                    protected virtual void Dispose(bool disposing)
                    {
                        CppSharp.Parser.AST.InlineCommandComment.Argument __dummy;
                        NativeToManagedMap.TryRemove(__Instance, out __dummy);
                        Internal.dtor_0((__Instance + __PointerAdjustment), 0);
                        if (__ownsNativeInstance)
                            Marshal.FreeHGlobal(__Instance);
                    }

                    public string Text
                    {
                        get
                        {
                            var __ret = Internal.getText_0((__Instance + __PointerAdjustment));
                            return Marshal.PtrToStringAnsi(__ret);
                        }

                        set
                        {
                            var __arg0 = Marshal.StringToHGlobalAnsi(value);
                            Internal.setText_0((__Instance + __PointerAdjustment), __arg0);
                            Marshal.FreeHGlobal(__arg0);
                        }
                    }
                }

                public static new InlineCommandComment __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new InlineCommandComment(native.ToPointer(), skipVTables);
                }

                public static InlineCommandComment __CreateInstance(InlineCommandComment.Internal native, bool skipVTables = false)
                {
                    return new InlineCommandComment(native, skipVTables);
                }

                private static void* __CopyValue(InlineCommandComment.Internal native)
                {
                    var ret = Marshal.AllocHGlobal(40);
                    CppSharp.Parser.AST.InlineCommandComment.Internal.cctor_2(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private InlineCommandComment(InlineCommandComment.Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected InlineCommandComment(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public InlineCommandComment()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(40);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_0((__Instance + __PointerAdjustment));
                }

                public InlineCommandComment(CppSharp.Parser.AST.InlineCommandComment _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(40);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    Internal.cctor_2((__Instance + __PointerAdjustment), __arg0);
                }

                protected override void Dispose(bool disposing)
                {
                    CppSharp.Parser.AST.Comment __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    Internal.dtor_0((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public CppSharp.Parser.AST.InlineCommandComment.Argument getArguments(uint i)
                {
                    var __ret = new CppSharp.Parser.AST.InlineCommandComment.Argument.Internal();
                    Internal.getArguments_0((__Instance + __PointerAdjustment), new IntPtr(&__ret), i);
                    return CppSharp.Parser.AST.InlineCommandComment.Argument.__CreateInstance(__ret);
                }

                public void addArguments(CppSharp.Parser.AST.InlineCommandComment.Argument s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    Internal.addArguments_0((__Instance + __PointerAdjustment), __arg0);
                }

                public void clearArguments()
                {
                    Internal.clearArguments_0((__Instance + __PointerAdjustment));
                }

                public uint ArgumentsCount
                {
                    get
                    {
                        var __ret = Internal.getArgumentsCount_0((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                public uint CommandId
                {
                    get
                    {
                        return ((Internal*) __Instance)->CommandId;
                    }

                    set
                    {
                        ((Internal*) __Instance)->CommandId = value;
                    }
                }

                public CppSharp.Parser.AST.InlineCommandComment.RenderKind CommentRenderKind
                {
                    get
                    {
                        return ((Internal*) __Instance)->CommentRenderKind;
                    }

                    set
                    {
                        ((Internal*) __Instance)->CommentRenderKind = value;
                    }
                }
            }

            public unsafe partial class HTMLTagComment : CppSharp.Parser.AST.InlineContentComment, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 8)]
                public new partial struct Internal
                {
                    [FieldOffset(0)]
                    public CppSharp.Parser.AST.CommentKind Kind;

                    [FieldOffset(4)]
                    public byte HasTrailingNewline;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0HTMLTagComment@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0HTMLTagComment@AST@CppParser@CppSharp@@QEAA@W4CommentKind@123@@Z")]
                    internal static extern global::System.IntPtr ctor_1(global::System.IntPtr instance, CppSharp.Parser.AST.CommentKind Kind);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0HTMLTagComment@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public static new HTMLTagComment __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new HTMLTagComment(native.ToPointer(), skipVTables);
                }

                public static HTMLTagComment __CreateInstance(HTMLTagComment.Internal native, bool skipVTables = false)
                {
                    return new HTMLTagComment(native, skipVTables);
                }

                private static void* __CopyValue(HTMLTagComment.Internal native)
                {
                    var ret = Marshal.AllocHGlobal(8);
                    *(HTMLTagComment.Internal*) ret = native;
                    return ret.ToPointer();
                }

                private HTMLTagComment(HTMLTagComment.Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected HTMLTagComment(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public HTMLTagComment()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(8);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_0((__Instance + __PointerAdjustment));
                }

                public HTMLTagComment(CppSharp.Parser.AST.CommentKind Kind)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(8);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    var __arg0 = Kind;
                    Internal.ctor_1((__Instance + __PointerAdjustment), __arg0);
                }

                public HTMLTagComment(CppSharp.Parser.AST.HTMLTagComment _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(8);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((HTMLTagComment.Internal*) __Instance) = *((HTMLTagComment.Internal*) _0.__Instance);
                }
            }

            public unsafe partial class HTMLStartTagComment : CppSharp.Parser.AST.HTMLTagComment, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 64)]
                public new partial struct Internal
                {
                    [FieldOffset(0)]
                    public CppSharp.Parser.AST.CommentKind Kind;

                    [FieldOffset(4)]
                    public byte HasTrailingNewline;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0HTMLStartTagComment@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0HTMLStartTagComment@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1HTMLStartTagComment@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor_0(global::System.IntPtr instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getAttributes@HTMLStartTagComment@AST@CppParser@CppSharp@@QEAA?AVAttribute@1234@I@Z")]
                    internal static extern void getAttributes_0(global::System.IntPtr instance, global::System.IntPtr @return, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?addAttributes@HTMLStartTagComment@AST@CppParser@CppSharp@@QEAAXAEAVAttribute@1234@@Z")]
                    internal static extern void addAttributes_0(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?clearAttributes@HTMLStartTagComment@AST@CppParser@CppSharp@@QEAAXXZ")]
                    internal static extern void clearAttributes_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getTagName@HTMLStartTagComment@AST@CppParser@CppSharp@@QEAAPEBDXZ")]
                    internal static extern global::System.IntPtr getTagName_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?setTagName@HTMLStartTagComment@AST@CppParser@CppSharp@@QEAAXPEBD@Z")]
                    internal static extern void setTagName_0(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getAttributesCount@HTMLStartTagComment@AST@CppParser@CppSharp@@QEAAIXZ")]
                    internal static extern uint getAttributesCount_0(global::System.IntPtr instance);
                }

                public unsafe partial class Attribute : IDisposable
                {
                    [StructLayout(LayoutKind.Explicit, Size = 64)]
                    public partial struct Internal
                    {
                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="??0Attribute@HTMLStartTagComment@AST@CppParser@CppSharp@@QEAA@XZ")]
                        internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="??0Attribute@HTMLStartTagComment@AST@CppParser@CppSharp@@QEAA@AEBV01234@@Z")]
                        internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="??1Attribute@HTMLStartTagComment@AST@CppParser@CppSharp@@QEAA@XZ")]
                        internal static extern void dtor_0(global::System.IntPtr instance, int delete);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="?getName@Attribute@HTMLStartTagComment@AST@CppParser@CppSharp@@QEAAPEBDXZ")]
                        internal static extern global::System.IntPtr getName_0(global::System.IntPtr instance);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="?setName@Attribute@HTMLStartTagComment@AST@CppParser@CppSharp@@QEAAXPEBD@Z")]
                        internal static extern void setName_0(global::System.IntPtr instance, global::System.IntPtr s);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="?getValue@Attribute@HTMLStartTagComment@AST@CppParser@CppSharp@@QEAAPEBDXZ")]
                        internal static extern global::System.IntPtr getValue_0(global::System.IntPtr instance);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="?setValue@Attribute@HTMLStartTagComment@AST@CppParser@CppSharp@@QEAAXPEBD@Z")]
                        internal static extern void setValue_0(global::System.IntPtr instance, global::System.IntPtr s);
                    }

                    public global::System.IntPtr __Instance { get; protected set; }

                    protected int __PointerAdjustment;
                    public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, Attribute> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, Attribute>();
                    protected void*[] __OriginalVTables;

                    protected bool __ownsNativeInstance;

                    public static Attribute __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                    {
                        return new Attribute(native.ToPointer(), skipVTables);
                    }

                    public static Attribute __CreateInstance(Attribute.Internal native, bool skipVTables = false)
                    {
                        return new Attribute(native, skipVTables);
                    }

                    private static void* __CopyValue(Attribute.Internal native)
                    {
                        var ret = Marshal.AllocHGlobal(64);
                        CppSharp.Parser.AST.HTMLStartTagComment.Attribute.Internal.cctor_1(ret, new global::System.IntPtr(&native));
                        return ret.ToPointer();
                    }

                    private Attribute(Attribute.Internal native, bool skipVTables = false)
                        : this(__CopyValue(native), skipVTables)
                    {
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                    }

                    protected Attribute(void* native, bool skipVTables = false)
                    {
                        if (native == null)
                            return;
                        __Instance = new global::System.IntPtr(native);
                    }

                    public Attribute()
                    {
                        __Instance = Marshal.AllocHGlobal(64);
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                        Internal.ctor_0((__Instance + __PointerAdjustment));
                    }

                    public Attribute(CppSharp.Parser.AST.HTMLStartTagComment.Attribute _0)
                    {
                        __Instance = Marshal.AllocHGlobal(64);
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                        if (ReferenceEquals(_0, null))
                            throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                        var __arg0 = _0.__Instance;
                        Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
                    }

                    public void Dispose()
                    {
                        Dispose(disposing: true);
                    }

                    protected virtual void Dispose(bool disposing)
                    {
                        CppSharp.Parser.AST.HTMLStartTagComment.Attribute __dummy;
                        NativeToManagedMap.TryRemove(__Instance, out __dummy);
                        Internal.dtor_0((__Instance + __PointerAdjustment), 0);
                        if (__ownsNativeInstance)
                            Marshal.FreeHGlobal(__Instance);
                    }

                    public string Name
                    {
                        get
                        {
                            var __ret = Internal.getName_0((__Instance + __PointerAdjustment));
                            return Marshal.PtrToStringAnsi(__ret);
                        }

                        set
                        {
                            var __arg0 = Marshal.StringToHGlobalAnsi(value);
                            Internal.setName_0((__Instance + __PointerAdjustment), __arg0);
                            Marshal.FreeHGlobal(__arg0);
                        }
                    }

                    public string Value
                    {
                        get
                        {
                            var __ret = Internal.getValue_0((__Instance + __PointerAdjustment));
                            return Marshal.PtrToStringAnsi(__ret);
                        }

                        set
                        {
                            var __arg0 = Marshal.StringToHGlobalAnsi(value);
                            Internal.setValue_0((__Instance + __PointerAdjustment), __arg0);
                            Marshal.FreeHGlobal(__arg0);
                        }
                    }
                }

                public static new HTMLStartTagComment __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new HTMLStartTagComment(native.ToPointer(), skipVTables);
                }

                public static HTMLStartTagComment __CreateInstance(HTMLStartTagComment.Internal native, bool skipVTables = false)
                {
                    return new HTMLStartTagComment(native, skipVTables);
                }

                private static void* __CopyValue(HTMLStartTagComment.Internal native)
                {
                    var ret = Marshal.AllocHGlobal(64);
                    CppSharp.Parser.AST.HTMLStartTagComment.Internal.cctor_2(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private HTMLStartTagComment(HTMLStartTagComment.Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected HTMLStartTagComment(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public HTMLStartTagComment()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(64);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_0((__Instance + __PointerAdjustment));
                }

                public HTMLStartTagComment(CppSharp.Parser.AST.HTMLStartTagComment _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(64);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    Internal.cctor_2((__Instance + __PointerAdjustment), __arg0);
                }

                protected override void Dispose(bool disposing)
                {
                    CppSharp.Parser.AST.Comment __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    Internal.dtor_0((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public CppSharp.Parser.AST.HTMLStartTagComment.Attribute getAttributes(uint i)
                {
                    var __ret = new CppSharp.Parser.AST.HTMLStartTagComment.Attribute.Internal();
                    Internal.getAttributes_0((__Instance + __PointerAdjustment), new IntPtr(&__ret), i);
                    return CppSharp.Parser.AST.HTMLStartTagComment.Attribute.__CreateInstance(__ret);
                }

                public void addAttributes(CppSharp.Parser.AST.HTMLStartTagComment.Attribute s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    Internal.addAttributes_0((__Instance + __PointerAdjustment), __arg0);
                }

                public void clearAttributes()
                {
                    Internal.clearAttributes_0((__Instance + __PointerAdjustment));
                }

                public string TagName
                {
                    get
                    {
                        var __ret = Internal.getTagName_0((__Instance + __PointerAdjustment));
                        return Marshal.PtrToStringAnsi(__ret);
                    }

                    set
                    {
                        var __arg0 = Marshal.StringToHGlobalAnsi(value);
                        Internal.setTagName_0((__Instance + __PointerAdjustment), __arg0);
                        Marshal.FreeHGlobal(__arg0);
                    }
                }

                public uint AttributesCount
                {
                    get
                    {
                        var __ret = Internal.getAttributesCount_0((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }
            }

            public unsafe partial class HTMLEndTagComment : CppSharp.Parser.AST.HTMLTagComment, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 40)]
                public new partial struct Internal
                {
                    [FieldOffset(0)]
                    public CppSharp.Parser.AST.CommentKind Kind;

                    [FieldOffset(4)]
                    public byte HasTrailingNewline;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0HTMLEndTagComment@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0HTMLEndTagComment@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1HTMLEndTagComment@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor_0(global::System.IntPtr instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getTagName@HTMLEndTagComment@AST@CppParser@CppSharp@@QEAAPEBDXZ")]
                    internal static extern global::System.IntPtr getTagName_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?setTagName@HTMLEndTagComment@AST@CppParser@CppSharp@@QEAAXPEBD@Z")]
                    internal static extern void setTagName_0(global::System.IntPtr instance, global::System.IntPtr s);
                }

                public static new HTMLEndTagComment __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new HTMLEndTagComment(native.ToPointer(), skipVTables);
                }

                public static HTMLEndTagComment __CreateInstance(HTMLEndTagComment.Internal native, bool skipVTables = false)
                {
                    return new HTMLEndTagComment(native, skipVTables);
                }

                private static void* __CopyValue(HTMLEndTagComment.Internal native)
                {
                    var ret = Marshal.AllocHGlobal(40);
                    CppSharp.Parser.AST.HTMLEndTagComment.Internal.cctor_2(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private HTMLEndTagComment(HTMLEndTagComment.Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected HTMLEndTagComment(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public HTMLEndTagComment()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(40);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_0((__Instance + __PointerAdjustment));
                }

                public HTMLEndTagComment(CppSharp.Parser.AST.HTMLEndTagComment _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(40);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    Internal.cctor_2((__Instance + __PointerAdjustment), __arg0);
                }

                protected override void Dispose(bool disposing)
                {
                    CppSharp.Parser.AST.Comment __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    Internal.dtor_0((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public string TagName
                {
                    get
                    {
                        var __ret = Internal.getTagName_0((__Instance + __PointerAdjustment));
                        return Marshal.PtrToStringAnsi(__ret);
                    }

                    set
                    {
                        var __arg0 = Marshal.StringToHGlobalAnsi(value);
                        Internal.setTagName_0((__Instance + __PointerAdjustment), __arg0);
                        Marshal.FreeHGlobal(__arg0);
                    }
                }
            }

            public unsafe partial class TextComment : CppSharp.Parser.AST.InlineContentComment, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 40)]
                public new partial struct Internal
                {
                    [FieldOffset(0)]
                    public CppSharp.Parser.AST.CommentKind Kind;

                    [FieldOffset(4)]
                    public byte HasTrailingNewline;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0TextComment@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0TextComment@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1TextComment@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor_0(global::System.IntPtr instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getText@TextComment@AST@CppParser@CppSharp@@QEAAPEBDXZ")]
                    internal static extern global::System.IntPtr getText_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?setText@TextComment@AST@CppParser@CppSharp@@QEAAXPEBD@Z")]
                    internal static extern void setText_0(global::System.IntPtr instance, global::System.IntPtr s);
                }

                public static new TextComment __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new TextComment(native.ToPointer(), skipVTables);
                }

                public static TextComment __CreateInstance(TextComment.Internal native, bool skipVTables = false)
                {
                    return new TextComment(native, skipVTables);
                }

                private static void* __CopyValue(TextComment.Internal native)
                {
                    var ret = Marshal.AllocHGlobal(40);
                    CppSharp.Parser.AST.TextComment.Internal.cctor_2(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private TextComment(TextComment.Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected TextComment(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public TextComment()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(40);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_0((__Instance + __PointerAdjustment));
                }

                public TextComment(CppSharp.Parser.AST.TextComment _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(40);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    Internal.cctor_2((__Instance + __PointerAdjustment), __arg0);
                }

                protected override void Dispose(bool disposing)
                {
                    CppSharp.Parser.AST.Comment __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    Internal.dtor_0((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public string Text
                {
                    get
                    {
                        var __ret = Internal.getText_0((__Instance + __PointerAdjustment));
                        return Marshal.PtrToStringAnsi(__ret);
                    }

                    set
                    {
                        var __arg0 = Marshal.StringToHGlobalAnsi(value);
                        Internal.setText_0((__Instance + __PointerAdjustment), __arg0);
                        Marshal.FreeHGlobal(__arg0);
                    }
                }
            }

            public unsafe partial class RawComment : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 80)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public CppSharp.Parser.AST.RawCommentKind Kind;

                    [FieldOffset(72)]
                    public global::System.IntPtr FullCommentBlock;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0RawComment@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0RawComment@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1RawComment@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor_0(global::System.IntPtr instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getText@RawComment@AST@CppParser@CppSharp@@QEAAPEBDXZ")]
                    internal static extern global::System.IntPtr getText_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?setText@RawComment@AST@CppParser@CppSharp@@QEAAXPEBD@Z")]
                    internal static extern void setText_0(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getBriefText@RawComment@AST@CppParser@CppSharp@@QEAAPEBDXZ")]
                    internal static extern global::System.IntPtr getBriefText_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?setBriefText@RawComment@AST@CppParser@CppSharp@@QEAAXPEBD@Z")]
                    internal static extern void setBriefText_0(global::System.IntPtr instance, global::System.IntPtr s);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                protected int __PointerAdjustment;
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, RawComment> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, RawComment>();
                protected void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                public static RawComment __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new RawComment(native.ToPointer(), skipVTables);
                }

                public static RawComment __CreateInstance(RawComment.Internal native, bool skipVTables = false)
                {
                    return new RawComment(native, skipVTables);
                }

                private static void* __CopyValue(RawComment.Internal native)
                {
                    var ret = Marshal.AllocHGlobal(80);
                    CppSharp.Parser.AST.RawComment.Internal.cctor_1(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private RawComment(RawComment.Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected RawComment(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public RawComment()
                {
                    __Instance = Marshal.AllocHGlobal(80);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_0((__Instance + __PointerAdjustment));
                }

                public RawComment(CppSharp.Parser.AST.RawComment _0)
                {
                    __Instance = Marshal.AllocHGlobal(80);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    Internal.cctor_1((__Instance + __PointerAdjustment), __arg0);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    CppSharp.Parser.AST.RawComment __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    Internal.dtor_0((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public string Text
                {
                    get
                    {
                        var __ret = Internal.getText_0((__Instance + __PointerAdjustment));
                        return Marshal.PtrToStringAnsi(__ret);
                    }

                    set
                    {
                        var __arg0 = Marshal.StringToHGlobalAnsi(value);
                        Internal.setText_0((__Instance + __PointerAdjustment), __arg0);
                        Marshal.FreeHGlobal(__arg0);
                    }
                }

                public string BriefText
                {
                    get
                    {
                        var __ret = Internal.getBriefText_0((__Instance + __PointerAdjustment));
                        return Marshal.PtrToStringAnsi(__ret);
                    }

                    set
                    {
                        var __arg0 = Marshal.StringToHGlobalAnsi(value);
                        Internal.setBriefText_0((__Instance + __PointerAdjustment), __arg0);
                        Marshal.FreeHGlobal(__arg0);
                    }
                }

                public CppSharp.Parser.AST.RawCommentKind Kind
                {
                    get
                    {
                        return ((Internal*) __Instance)->Kind;
                    }

                    set
                    {
                        ((Internal*) __Instance)->Kind = value;
                    }
                }

                public CppSharp.Parser.AST.FullComment FullCommentBlock
                {
                    get
                    {
                        CppSharp.Parser.AST.FullComment __result0;
                        if (((Internal*) __Instance)->FullCommentBlock == IntPtr.Zero) __result0 = null;
                        else if (CppSharp.Parser.AST.FullComment.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->FullCommentBlock))
                            __result0 = (CppSharp.Parser.AST.FullComment) CppSharp.Parser.AST.FullComment.NativeToManagedMap[((Internal*) __Instance)->FullCommentBlock];
                        else __result0 = CppSharp.Parser.AST.FullComment.__CreateInstance(((Internal*) __Instance)->FullCommentBlock);
                        return __result0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->FullCommentBlock = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }
            }
        }
    }
}
