// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using System.Runtime.CompilerServices;

[assembly:InternalsVisibleTo("CppSharp.Parser")]

namespace CppSharp
{
    namespace Parser
    {
        namespace AST
        {
            public enum TypeKind
            {
                Tag = 0,
                Array = 1,
                Function = 2,
                Pointer = 3,
                MemberPointer = 4,
                Typedef = 5,
                Attributed = 6,
                Decayed = 7,
                TemplateSpecialization = 8,
                DependentTemplateSpecialization = 9,
                TemplateParameter = 10,
                TemplateParameterSubstitution = 11,
                InjectedClassName = 12,
                DependentName = 13,
                PackExpansion = 14,
                Builtin = 15,
                UnaryTransform = 16,
                Vector = 17
            }

            public enum DeclarationKind
            {
                DeclarationContext = 0,
                Typedef = 1,
                TypeAlias = 2,
                Parameter = 3,
                Function = 4,
                Method = 5,
                Enumeration = 6,
                EnumerationItem = 7,
                Variable = 8,
                Field = 9,
                AccessSpecifier = 10,
                Class = 11,
                Template = 12,
                TypeAliasTemplate = 13,
                ClassTemplate = 14,
                ClassTemplateSpecialization = 15,
                ClassTemplatePartialSpecialization = 16,
                FunctionTemplate = 17,
                Namespace = 18,
                PreprocessedEntity = 19,
                MacroDefinition = 20,
                MacroExpansion = 21,
                TranslationUnit = 22,
                Friend = 23,
                TemplateTemplateParm = 24,
                TemplateTypeParm = 25,
                NonTypeTemplateParm = 26,
                VarTemplate = 27,
                VarTemplateSpecialization = 28,
                VarTemplatePartialSpecialization = 29
            }

            public enum AccessSpecifier
            {
                Private = 0,
                Protected = 1,
                Public = 2
            }

            public enum MacroLocation
            {
                Unknown = 0,
                ClassHead = 1,
                ClassBody = 2,
                FunctionHead = 3,
                FunctionParameters = 4,
                FunctionBody = 5
            }

            public enum RawCommentKind
            {
                Invalid = 0,
                OrdinaryBCPL = 1,
                OrdinaryC = 2,
                BCPLSlash = 3,
                BCPLExcl = 4,
                JavaDoc = 5,
                Qt = 6,
                Merged = 7
            }

            public enum CommentKind
            {
                FullComment = 0,
                BlockContentComment = 1,
                BlockCommandComment = 2,
                ParamCommandComment = 3,
                TParamCommandComment = 4,
                VerbatimBlockComment = 5,
                VerbatimLineComment = 6,
                ParagraphComment = 7,
                HTMLTagComment = 8,
                HTMLStartTagComment = 9,
                HTMLEndTagComment = 10,
                TextComment = 11,
                InlineContentComment = 12,
                InlineCommandComment = 13,
                VerbatimBlockLineComment = 14
            }

            public enum FriendKind
            {
                None = 0,
                Declared = 1,
                Undeclared = 2
            }

            public enum CXXOperatorKind
            {
                None = 0,
                New = 1,
                Delete = 2,
                ArrayNew = 3,
                ArrayDelete = 4,
                Plus = 5,
                Minus = 6,
                Star = 7,
                Slash = 8,
                Percent = 9,
                Caret = 10,
                Amp = 11,
                Pipe = 12,
                Tilde = 13,
                Exclaim = 14,
                Equal = 15,
                Less = 16,
                Greater = 17,
                PlusEqual = 18,
                MinusEqual = 19,
                StarEqual = 20,
                SlashEqual = 21,
                PercentEqual = 22,
                CaretEqual = 23,
                AmpEqual = 24,
                PipeEqual = 25,
                LessLess = 26,
                GreaterGreater = 27,
                LessLessEqual = 28,
                GreaterGreaterEqual = 29,
                EqualEqual = 30,
                ExclaimEqual = 31,
                LessEqual = 32,
                GreaterEqual = 33,
                AmpAmp = 34,
                PipePipe = 35,
                PlusPlus = 36,
                MinusMinus = 37,
                Comma = 38,
                ArrowStar = 39,
                Arrow = 40,
                Call = 41,
                Subscript = 42,
                Conditional = 43,
                Coawait = 44
            }

            public enum CallingConvention
            {
                Default = 0,
                C = 1,
                StdCall = 2,
                ThisCall = 3,
                FastCall = 4,
                Unknown = 5
            }

            public enum StatementClass
            {
                Any = 0,
                BinaryOperator = 1,
                CallExprClass = 2,
                DeclRefExprClass = 3,
                CXXConstructExprClass = 4,
                CXXOperatorCallExpr = 5,
                ImplicitCastExpr = 6,
                ExplicitCastExpr = 7
            }

            public enum TemplateSpecializationKind
            {
                Undeclared = 0,
                ImplicitInstantiation = 1,
                ExplicitSpecialization = 2,
                ExplicitInstantiationDeclaration = 3,
                ExplicitInstantiationDefinition = 4
            }

            public enum CXXMethodKind
            {
                Normal = 0,
                Constructor = 1,
                Destructor = 2,
                Conversion = 3,
                Operator = 4,
                UsingDirective = 5
            }

            public enum RefQualifierKind
            {
                None = 0,
                LValue = 1,
                RValue = 2
            }

            public enum CppAbi
            {
                Itanium = 0,
                Microsoft = 1,
                ARM = 2,
                iOS = 3,
                iOS64 = 4
            }

            public enum VTableComponentKind
            {
                VCallOffset = 0,
                VBaseOffset = 1,
                OffsetToTop = 2,
                RTTI = 3,
                FunctionPointer = 4,
                CompleteDtorPointer = 5,
                DeletingDtorPointer = 6,
                UnusedFunctionPointer = 7
            }

            public enum PrimitiveType
            {
                Null = 0,
                Void = 1,
                Bool = 2,
                WideChar = 3,
                Char = 4,
                SChar = 5,
                UChar = 6,
                Char16 = 7,
                Char32 = 8,
                Short = 9,
                UShort = 10,
                Int = 11,
                UInt = 12,
                Long = 13,
                ULong = 14,
                LongLong = 15,
                ULongLong = 16,
                Int128 = 17,
                UInt128 = 18,
                Half = 19,
                Float = 20,
                Double = 21,
                LongDouble = 22,
                Float128 = 23,
                IntPtr = 24
            }

            public enum ExceptionSpecType
            {
                None = 0,
                DynamicNone = 1,
                Dynamic = 2,
                MSAny = 3,
                BasicNoexcept = 4,
                ComputedNoexcept = 5,
                Unevaluated = 6,
                Uninstantiated = 7,
                Unparsed = 8
            }

            public enum ArchType
            {
                UnknownArch = 0,
                X86 = 1,
                X86_64 = 2
            }

            public unsafe partial class Type : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 8)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.TypeKind kind;

                    [FieldOffset(4)]
                    internal byte isDependent;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0Type@AST@CppParser@CppSharp@@QEAA@W4TypeKind@123@@Z")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::CppSharp.Parser.AST.TypeKind kind);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0Type@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                protected int __PointerAdjustment;
                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.Type> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.Type>();
                protected void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                internal static global::CppSharp.Parser.AST.Type __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.Type(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.Type __CreateInstance(global::CppSharp.Parser.AST.Type.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.Type(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.Type.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Type.__Internal));
                    global::CppSharp.Parser.AST.Type.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private Type(global::CppSharp.Parser.AST.Type.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected Type(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public Type(global::CppSharp.Parser.AST.TypeKind kind)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Type.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment), kind);
                }

                public Type(global::CppSharp.Parser.AST.Type _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Type.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                public virtual void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Type __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public static implicit operator global::CppSharp.Parser.AST.Type(global::CppSharp.Parser.AST.TypeKind kind)
                {
                    return new global::CppSharp.Parser.AST.Type(kind);
                }

                public global::CppSharp.Parser.AST.TypeKind Kind
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Type.__Internal*) __Instance)->kind;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Type.__Internal*) __Instance)->kind = value;
                    }
                }

                public bool IsDependent
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Type.__Internal*) __Instance)->isDependent != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Type.__Internal*) __Instance)->isDependent = (byte) (value ? 1 : 0);
                    }
                }
            }

            public unsafe partial class TypeQualifiers : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 3)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal byte isConst;

                    [FieldOffset(1)]
                    internal byte isVolatile;

                    [FieldOffset(2)]
                    internal byte isRestrict;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0TypeQualifiers@AST@CppParser@CppSharp@@QEAA@AEBU0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                protected int __PointerAdjustment;
                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.TypeQualifiers> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.TypeQualifiers>();
                protected void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                internal static global::CppSharp.Parser.AST.TypeQualifiers __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.TypeQualifiers(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.TypeQualifiers __CreateInstance(global::CppSharp.Parser.AST.TypeQualifiers.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.TypeQualifiers(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.TypeQualifiers.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TypeQualifiers.__Internal));
                    *(global::CppSharp.Parser.AST.TypeQualifiers.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private TypeQualifiers(global::CppSharp.Parser.AST.TypeQualifiers.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected TypeQualifiers(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public TypeQualifiers(global::CppSharp.Parser.AST.TypeQualifiers _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TypeQualifiers.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.TypeQualifiers.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.TypeQualifiers.__Internal*) _0.__Instance);
                }

                public TypeQualifiers()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TypeQualifiers.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                public virtual void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.TypeQualifiers __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public bool IsConst
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.TypeQualifiers.__Internal*) __Instance)->isConst != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.TypeQualifiers.__Internal*) __Instance)->isConst = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsVolatile
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.TypeQualifiers.__Internal*) __Instance)->isVolatile != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.TypeQualifiers.__Internal*) __Instance)->isVolatile = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsRestrict
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.TypeQualifiers.__Internal*) __Instance)->isRestrict != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.TypeQualifiers.__Internal*) __Instance)->isRestrict = (byte) (value ? 1 : 0);
                    }
                }
            }

            public unsafe partial class QualifiedType : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 16)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::System.IntPtr type;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.TypeQualifiers.__Internal qualifiers;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0QualifiedType@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0QualifiedType@AST@CppParser@CppSharp@@QEAA@AEBU0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                protected int __PointerAdjustment;
                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.QualifiedType> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.QualifiedType>();
                protected void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                internal static global::CppSharp.Parser.AST.QualifiedType __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.QualifiedType(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.QualifiedType __CreateInstance(global::CppSharp.Parser.AST.QualifiedType.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.QualifiedType(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.QualifiedType.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.QualifiedType.__Internal));
                    *(global::CppSharp.Parser.AST.QualifiedType.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private QualifiedType(global::CppSharp.Parser.AST.QualifiedType.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected QualifiedType(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public QualifiedType()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.QualifiedType.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment));
                }

                public QualifiedType(global::CppSharp.Parser.AST.QualifiedType _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.QualifiedType.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.QualifiedType.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.QualifiedType.__Internal*) _0.__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                public virtual void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.QualifiedType __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.Type Type
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Type __result0;
                        if (((global::CppSharp.Parser.AST.QualifiedType.__Internal*) __Instance)->type == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Type.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.QualifiedType.__Internal*) __Instance)->type))
                            __result0 = (global::CppSharp.Parser.AST.Type) global::CppSharp.Parser.AST.Type.NativeToManagedMap[((global::CppSharp.Parser.AST.QualifiedType.__Internal*) __Instance)->type];
                        else __result0 = global::CppSharp.Parser.AST.Type.__CreateInstance(((global::CppSharp.Parser.AST.QualifiedType.__Internal*) __Instance)->type);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.QualifiedType.__Internal*) __Instance)->type = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.TypeQualifiers Qualifiers
                {
                    get
                    {
                        return global::CppSharp.Parser.AST.TypeQualifiers.__CreateInstance(((global::CppSharp.Parser.AST.QualifiedType.__Internal*) __Instance)->qualifiers);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.QualifiedType.__Internal*) __Instance)->qualifiers = ReferenceEquals(value, null) ? new global::CppSharp.Parser.AST.TypeQualifiers.__Internal() : *(global::CppSharp.Parser.AST.TypeQualifiers.__Internal*) value.__Instance;
                    }
                }
            }

            public unsafe partial class TagType : global::CppSharp.Parser.AST.Type, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 16)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.TypeKind kind;

                    [FieldOffset(4)]
                    internal byte isDependent;

                    [FieldOffset(8)]
                    internal global::System.IntPtr declaration;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0TagType@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0TagType@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.TagType __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.TagType(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.TagType __CreateInstance(global::CppSharp.Parser.AST.TagType.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.TagType(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.TagType.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TagType.__Internal));
                    global::CppSharp.Parser.AST.TagType.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private TagType(global::CppSharp.Parser.AST.TagType.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected TagType(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public TagType()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TagType.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment));
                }

                public TagType(global::CppSharp.Parser.AST.TagType _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TagType.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
                }

                public global::CppSharp.Parser.AST.Declaration Declaration
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Declaration __result0;
                        if (((global::CppSharp.Parser.AST.TagType.__Internal*) __Instance)->declaration == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Declaration.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.TagType.__Internal*) __Instance)->declaration))
                            __result0 = (global::CppSharp.Parser.AST.Declaration) global::CppSharp.Parser.AST.Declaration.NativeToManagedMap[((global::CppSharp.Parser.AST.TagType.__Internal*) __Instance)->declaration];
                        else __result0 = global::CppSharp.Parser.AST.Declaration.__CreateInstance(((global::CppSharp.Parser.AST.TagType.__Internal*) __Instance)->declaration);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.TagType.__Internal*) __Instance)->declaration = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }
            }

            public unsafe partial class ArrayType : global::CppSharp.Parser.AST.Type, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 40)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.TypeKind kind;

                    [FieldOffset(4)]
                    internal byte isDependent;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal qualifiedType;

                    [FieldOffset(24)]
                    internal global::CppSharp.Parser.AST.ArrayType.ArraySize sizeType;

                    [FieldOffset(28)]
                    internal int size;

                    [FieldOffset(32)]
                    internal int elementSize;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0ArrayType@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0ArrayType@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public enum ArraySize
                {
                    Constant = 0,
                    Variable = 1,
                    Dependent = 2,
                    Incomplete = 3
                }

                internal static new global::CppSharp.Parser.AST.ArrayType __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.ArrayType(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.ArrayType __CreateInstance(global::CppSharp.Parser.AST.ArrayType.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.ArrayType(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.ArrayType.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ArrayType.__Internal));
                    global::CppSharp.Parser.AST.ArrayType.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private ArrayType(global::CppSharp.Parser.AST.ArrayType.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected ArrayType(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public ArrayType()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ArrayType.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment));
                }

                public ArrayType(global::CppSharp.Parser.AST.ArrayType _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ArrayType.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
                }

                public global::CppSharp.Parser.AST.QualifiedType QualifiedType
                {
                    get
                    {
                        return global::CppSharp.Parser.AST.QualifiedType.__CreateInstance(((global::CppSharp.Parser.AST.ArrayType.__Internal*) __Instance)->qualifiedType);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.ArrayType.__Internal*) __Instance)->qualifiedType = ReferenceEquals(value, null) ? new global::CppSharp.Parser.AST.QualifiedType.__Internal() : *(global::CppSharp.Parser.AST.QualifiedType.__Internal*) value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.ArrayType.ArraySize SizeType
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.ArrayType.__Internal*) __Instance)->sizeType;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.ArrayType.__Internal*) __Instance)->sizeType = value;
                    }
                }

                public int Size
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.ArrayType.__Internal*) __Instance)->size;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.ArrayType.__Internal*) __Instance)->size = value;
                    }
                }

                public int ElementSize
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.ArrayType.__Internal*) __Instance)->elementSize;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.ArrayType.__Internal*) __Instance)->elementSize = value;
                    }
                }
            }

            public unsafe partial class FunctionType : global::CppSharp.Parser.AST.Type, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 56)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.TypeKind kind;

                    [FieldOffset(4)]
                    internal byte isDependent;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal returnType;

                    [FieldOffset(24)]
                    internal global::CppSharp.Parser.AST.CallingConvention callingConvention;

                    [FieldOffset(28)]
                    internal global::CppSharp.Parser.AST.ExceptionSpecType exceptionSpecType;

                    [FieldOffset(32)]
                    internal global::Std.Vector.__Internal Parameters;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0FunctionType@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0FunctionType@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1FunctionType@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor(global::System.IntPtr instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getParameters@FunctionType@AST@CppParser@CppSharp@@QEAAPEAVParameter@234@I@Z")]
                    internal static extern global::System.IntPtr GetParameters(global::System.IntPtr instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?addParameters@FunctionType@AST@CppParser@CppSharp@@QEAAXAEAPEAVParameter@234@@Z")]
                    internal static extern void AddParameters(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?clearParameters@FunctionType@AST@CppParser@CppSharp@@QEAAXXZ")]
                    internal static extern void ClearParameters(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getParametersCount@FunctionType@AST@CppParser@CppSharp@@QEAAIXZ")]
                    internal static extern uint GetParametersCount(global::System.IntPtr instance);
                }

                internal static new global::CppSharp.Parser.AST.FunctionType __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.FunctionType(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.FunctionType __CreateInstance(global::CppSharp.Parser.AST.FunctionType.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.FunctionType(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.FunctionType.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.FunctionType.__Internal));
                    global::CppSharp.Parser.AST.FunctionType.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private FunctionType(global::CppSharp.Parser.AST.FunctionType.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected FunctionType(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public FunctionType()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.FunctionType.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment));
                }

                public FunctionType(global::CppSharp.Parser.AST.FunctionType _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.FunctionType.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Type __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.Parameter GetParameters(uint i)
                {
                    var __ret = __Internal.GetParameters((__Instance + __PointerAdjustment), i);
                    global::CppSharp.Parser.AST.Parameter __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.Parameter.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::CppSharp.Parser.AST.Parameter) global::CppSharp.Parser.AST.Parameter.NativeToManagedMap[__ret];
                    else __result0 = global::CppSharp.Parser.AST.Parameter.__CreateInstance(__ret);
                    return __result0;
                }

                public void AddParameters(global::CppSharp.Parser.AST.Parameter s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    __Internal.AddParameters((__Instance + __PointerAdjustment), __arg0);
                }

                public void ClearParameters()
                {
                    __Internal.ClearParameters((__Instance + __PointerAdjustment));
                }

                public global::CppSharp.Parser.AST.QualifiedType ReturnType
                {
                    get
                    {
                        return global::CppSharp.Parser.AST.QualifiedType.__CreateInstance(((global::CppSharp.Parser.AST.FunctionType.__Internal*) __Instance)->returnType);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.FunctionType.__Internal*) __Instance)->returnType = ReferenceEquals(value, null) ? new global::CppSharp.Parser.AST.QualifiedType.__Internal() : *(global::CppSharp.Parser.AST.QualifiedType.__Internal*) value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.CallingConvention CallingConvention
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.FunctionType.__Internal*) __Instance)->callingConvention;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.FunctionType.__Internal*) __Instance)->callingConvention = value;
                    }
                }

                public global::CppSharp.Parser.AST.ExceptionSpecType ExceptionSpecType
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.FunctionType.__Internal*) __Instance)->exceptionSpecType;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.FunctionType.__Internal*) __Instance)->exceptionSpecType = value;
                    }
                }

                public uint ParametersCount
                {
                    get
                    {
                        var __ret = __Internal.GetParametersCount((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }
            }

            public unsafe partial class PointerType : global::CppSharp.Parser.AST.Type, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 32)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.TypeKind kind;

                    [FieldOffset(4)]
                    internal byte isDependent;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal qualifiedPointee;

                    [FieldOffset(24)]
                    internal global::CppSharp.Parser.AST.PointerType.TypeModifier modifier;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0PointerType@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0PointerType@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public enum TypeModifier
                {
                    Value = 0,
                    Pointer = 1,
                    LVReference = 2,
                    RVReference = 3
                }

                internal static new global::CppSharp.Parser.AST.PointerType __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.PointerType(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.PointerType __CreateInstance(global::CppSharp.Parser.AST.PointerType.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.PointerType(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.PointerType.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.PointerType.__Internal));
                    global::CppSharp.Parser.AST.PointerType.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private PointerType(global::CppSharp.Parser.AST.PointerType.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected PointerType(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public PointerType()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.PointerType.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment));
                }

                public PointerType(global::CppSharp.Parser.AST.PointerType _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.PointerType.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
                }

                public global::CppSharp.Parser.AST.QualifiedType QualifiedPointee
                {
                    get
                    {
                        return global::CppSharp.Parser.AST.QualifiedType.__CreateInstance(((global::CppSharp.Parser.AST.PointerType.__Internal*) __Instance)->qualifiedPointee);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.PointerType.__Internal*) __Instance)->qualifiedPointee = ReferenceEquals(value, null) ? new global::CppSharp.Parser.AST.QualifiedType.__Internal() : *(global::CppSharp.Parser.AST.QualifiedType.__Internal*) value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.PointerType.TypeModifier Modifier
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.PointerType.__Internal*) __Instance)->modifier;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.PointerType.__Internal*) __Instance)->modifier = value;
                    }
                }
            }

            public unsafe partial class MemberPointerType : global::CppSharp.Parser.AST.Type, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 24)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.TypeKind kind;

                    [FieldOffset(4)]
                    internal byte isDependent;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal pointee;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0MemberPointerType@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0MemberPointerType@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.MemberPointerType __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.MemberPointerType(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.MemberPointerType __CreateInstance(global::CppSharp.Parser.AST.MemberPointerType.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.MemberPointerType(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.MemberPointerType.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.MemberPointerType.__Internal));
                    global::CppSharp.Parser.AST.MemberPointerType.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private MemberPointerType(global::CppSharp.Parser.AST.MemberPointerType.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected MemberPointerType(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public MemberPointerType()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.MemberPointerType.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment));
                }

                public MemberPointerType(global::CppSharp.Parser.AST.MemberPointerType _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.MemberPointerType.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
                }

                public global::CppSharp.Parser.AST.QualifiedType Pointee
                {
                    get
                    {
                        return global::CppSharp.Parser.AST.QualifiedType.__CreateInstance(((global::CppSharp.Parser.AST.MemberPointerType.__Internal*) __Instance)->pointee);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.MemberPointerType.__Internal*) __Instance)->pointee = ReferenceEquals(value, null) ? new global::CppSharp.Parser.AST.QualifiedType.__Internal() : *(global::CppSharp.Parser.AST.QualifiedType.__Internal*) value.__Instance;
                    }
                }
            }

            public unsafe partial class TypedefType : global::CppSharp.Parser.AST.Type, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 16)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.TypeKind kind;

                    [FieldOffset(4)]
                    internal byte isDependent;

                    [FieldOffset(8)]
                    internal global::System.IntPtr declaration;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0TypedefType@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0TypedefType@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.TypedefType __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.TypedefType(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.TypedefType __CreateInstance(global::CppSharp.Parser.AST.TypedefType.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.TypedefType(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.TypedefType.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TypedefType.__Internal));
                    global::CppSharp.Parser.AST.TypedefType.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private TypedefType(global::CppSharp.Parser.AST.TypedefType.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected TypedefType(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public TypedefType()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TypedefType.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment));
                }

                public TypedefType(global::CppSharp.Parser.AST.TypedefType _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TypedefType.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
                }

                public global::CppSharp.Parser.AST.TypedefNameDecl Declaration
                {
                    get
                    {
                        global::CppSharp.Parser.AST.TypedefNameDecl __result0;
                        if (((global::CppSharp.Parser.AST.TypedefType.__Internal*) __Instance)->declaration == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.TypedefNameDecl.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.TypedefType.__Internal*) __Instance)->declaration))
                            __result0 = (global::CppSharp.Parser.AST.TypedefNameDecl) global::CppSharp.Parser.AST.TypedefNameDecl.NativeToManagedMap[((global::CppSharp.Parser.AST.TypedefType.__Internal*) __Instance)->declaration];
                        else __result0 = global::CppSharp.Parser.AST.TypedefNameDecl.__CreateInstance(((global::CppSharp.Parser.AST.TypedefType.__Internal*) __Instance)->declaration);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.TypedefType.__Internal*) __Instance)->declaration = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }
            }

            public unsafe partial class AttributedType : global::CppSharp.Parser.AST.Type, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 40)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.TypeKind kind;

                    [FieldOffset(4)]
                    internal byte isDependent;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal modified;

                    [FieldOffset(24)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal equivalent;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0AttributedType@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0AttributedType@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.AttributedType __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.AttributedType(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.AttributedType __CreateInstance(global::CppSharp.Parser.AST.AttributedType.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.AttributedType(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.AttributedType.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.AttributedType.__Internal));
                    global::CppSharp.Parser.AST.AttributedType.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private AttributedType(global::CppSharp.Parser.AST.AttributedType.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected AttributedType(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public AttributedType()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.AttributedType.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment));
                }

                public AttributedType(global::CppSharp.Parser.AST.AttributedType _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.AttributedType.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
                }

                public global::CppSharp.Parser.AST.QualifiedType Modified
                {
                    get
                    {
                        return global::CppSharp.Parser.AST.QualifiedType.__CreateInstance(((global::CppSharp.Parser.AST.AttributedType.__Internal*) __Instance)->modified);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.AttributedType.__Internal*) __Instance)->modified = ReferenceEquals(value, null) ? new global::CppSharp.Parser.AST.QualifiedType.__Internal() : *(global::CppSharp.Parser.AST.QualifiedType.__Internal*) value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.QualifiedType Equivalent
                {
                    get
                    {
                        return global::CppSharp.Parser.AST.QualifiedType.__CreateInstance(((global::CppSharp.Parser.AST.AttributedType.__Internal*) __Instance)->equivalent);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.AttributedType.__Internal*) __Instance)->equivalent = ReferenceEquals(value, null) ? new global::CppSharp.Parser.AST.QualifiedType.__Internal() : *(global::CppSharp.Parser.AST.QualifiedType.__Internal*) value.__Instance;
                    }
                }
            }

            public unsafe partial class DecayedType : global::CppSharp.Parser.AST.Type, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 56)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.TypeKind kind;

                    [FieldOffset(4)]
                    internal byte isDependent;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal decayed;

                    [FieldOffset(24)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal original;

                    [FieldOffset(40)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal pointee;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0DecayedType@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0DecayedType@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.DecayedType __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.DecayedType(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.DecayedType __CreateInstance(global::CppSharp.Parser.AST.DecayedType.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.DecayedType(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.DecayedType.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.DecayedType.__Internal));
                    global::CppSharp.Parser.AST.DecayedType.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private DecayedType(global::CppSharp.Parser.AST.DecayedType.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected DecayedType(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public DecayedType()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.DecayedType.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment));
                }

                public DecayedType(global::CppSharp.Parser.AST.DecayedType _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.DecayedType.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
                }

                public global::CppSharp.Parser.AST.QualifiedType Decayed
                {
                    get
                    {
                        return global::CppSharp.Parser.AST.QualifiedType.__CreateInstance(((global::CppSharp.Parser.AST.DecayedType.__Internal*) __Instance)->decayed);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.DecayedType.__Internal*) __Instance)->decayed = ReferenceEquals(value, null) ? new global::CppSharp.Parser.AST.QualifiedType.__Internal() : *(global::CppSharp.Parser.AST.QualifiedType.__Internal*) value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.QualifiedType Original
                {
                    get
                    {
                        return global::CppSharp.Parser.AST.QualifiedType.__CreateInstance(((global::CppSharp.Parser.AST.DecayedType.__Internal*) __Instance)->original);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.DecayedType.__Internal*) __Instance)->original = ReferenceEquals(value, null) ? new global::CppSharp.Parser.AST.QualifiedType.__Internal() : *(global::CppSharp.Parser.AST.QualifiedType.__Internal*) value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.QualifiedType Pointee
                {
                    get
                    {
                        return global::CppSharp.Parser.AST.QualifiedType.__CreateInstance(((global::CppSharp.Parser.AST.DecayedType.__Internal*) __Instance)->pointee);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.DecayedType.__Internal*) __Instance)->pointee = ReferenceEquals(value, null) ? new global::CppSharp.Parser.AST.QualifiedType.__Internal() : *(global::CppSharp.Parser.AST.QualifiedType.__Internal*) value.__Instance;
                    }
                }
            }

            public unsafe partial class TemplateArgument : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 40)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.TemplateArgument.ArgumentKind kind;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(24)]
                    internal global::System.IntPtr declaration;

                    [FieldOffset(32)]
                    internal int integral;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0TemplateArgument@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0TemplateArgument@AST@CppParser@CppSharp@@QEAA@AEBU0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public enum ArgumentKind
                {
                    Type = 0,
                    Declaration = 1,
                    NullPtr = 2,
                    Integral = 3,
                    Template = 4,
                    TemplateExpansion = 5,
                    Expression = 6,
                    Pack = 7
                }

                public global::System.IntPtr __Instance { get; protected set; }

                protected int __PointerAdjustment;
                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.TemplateArgument> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.TemplateArgument>();
                protected void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                internal static global::CppSharp.Parser.AST.TemplateArgument __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.TemplateArgument(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.TemplateArgument __CreateInstance(global::CppSharp.Parser.AST.TemplateArgument.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.TemplateArgument(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.TemplateArgument.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TemplateArgument.__Internal));
                    *(global::CppSharp.Parser.AST.TemplateArgument.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private TemplateArgument(global::CppSharp.Parser.AST.TemplateArgument.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected TemplateArgument(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public TemplateArgument()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TemplateArgument.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment));
                }

                public TemplateArgument(global::CppSharp.Parser.AST.TemplateArgument _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TemplateArgument.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.TemplateArgument.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.TemplateArgument.__Internal*) _0.__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                public virtual void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.TemplateArgument __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.TemplateArgument.ArgumentKind Kind
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.TemplateArgument.__Internal*) __Instance)->kind;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.TemplateArgument.__Internal*) __Instance)->kind = value;
                    }
                }

                public global::CppSharp.Parser.AST.QualifiedType Type
                {
                    get
                    {
                        return global::CppSharp.Parser.AST.QualifiedType.__CreateInstance(((global::CppSharp.Parser.AST.TemplateArgument.__Internal*) __Instance)->type);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.TemplateArgument.__Internal*) __Instance)->type = ReferenceEquals(value, null) ? new global::CppSharp.Parser.AST.QualifiedType.__Internal() : *(global::CppSharp.Parser.AST.QualifiedType.__Internal*) value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Declaration Declaration
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Declaration __result0;
                        if (((global::CppSharp.Parser.AST.TemplateArgument.__Internal*) __Instance)->declaration == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Declaration.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.TemplateArgument.__Internal*) __Instance)->declaration))
                            __result0 = (global::CppSharp.Parser.AST.Declaration) global::CppSharp.Parser.AST.Declaration.NativeToManagedMap[((global::CppSharp.Parser.AST.TemplateArgument.__Internal*) __Instance)->declaration];
                        else __result0 = global::CppSharp.Parser.AST.Declaration.__CreateInstance(((global::CppSharp.Parser.AST.TemplateArgument.__Internal*) __Instance)->declaration);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.TemplateArgument.__Internal*) __Instance)->declaration = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public int Integral
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.TemplateArgument.__Internal*) __Instance)->integral;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.TemplateArgument.__Internal*) __Instance)->integral = value;
                    }
                }
            }

            public unsafe partial class TemplateSpecializationType : global::CppSharp.Parser.AST.Type, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 56)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.TypeKind kind;

                    [FieldOffset(4)]
                    internal byte isDependent;

                    [FieldOffset(8)]
                    internal global::Std.Vector.__Internal Arguments;

                    [FieldOffset(32)]
                    internal global::System.IntPtr _template;

                    [FieldOffset(40)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal desugared;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0TemplateSpecializationType@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0TemplateSpecializationType@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1TemplateSpecializationType@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor(global::System.IntPtr instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getArguments@TemplateSpecializationType@AST@CppParser@CppSharp@@QEAA?AUTemplateArgument@234@I@Z")]
                    internal static extern void GetArguments(global::System.IntPtr instance, global::System.IntPtr @return, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?addArguments@TemplateSpecializationType@AST@CppParser@CppSharp@@QEAAXAEAUTemplateArgument@234@@Z")]
                    internal static extern void AddArguments(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?clearArguments@TemplateSpecializationType@AST@CppParser@CppSharp@@QEAAXXZ")]
                    internal static extern void ClearArguments(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getArgumentsCount@TemplateSpecializationType@AST@CppParser@CppSharp@@QEAAIXZ")]
                    internal static extern uint GetArgumentsCount(global::System.IntPtr instance);
                }

                internal static new global::CppSharp.Parser.AST.TemplateSpecializationType __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.TemplateSpecializationType(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.TemplateSpecializationType __CreateInstance(global::CppSharp.Parser.AST.TemplateSpecializationType.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.TemplateSpecializationType(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.TemplateSpecializationType.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TemplateSpecializationType.__Internal));
                    global::CppSharp.Parser.AST.TemplateSpecializationType.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private TemplateSpecializationType(global::CppSharp.Parser.AST.TemplateSpecializationType.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected TemplateSpecializationType(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public TemplateSpecializationType()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TemplateSpecializationType.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment));
                }

                public TemplateSpecializationType(global::CppSharp.Parser.AST.TemplateSpecializationType _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TemplateSpecializationType.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Type __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.TemplateArgument GetArguments(uint i)
                {
                    var __ret = new global::CppSharp.Parser.AST.TemplateArgument.__Internal();
                    __Internal.GetArguments((__Instance + __PointerAdjustment), new IntPtr(&__ret), i);
                    return global::CppSharp.Parser.AST.TemplateArgument.__CreateInstance(__ret);
                }

                public void AddArguments(global::CppSharp.Parser.AST.TemplateArgument s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    __Internal.AddArguments((__Instance + __PointerAdjustment), __arg0);
                }

                public void ClearArguments()
                {
                    __Internal.ClearArguments((__Instance + __PointerAdjustment));
                }

                public global::CppSharp.Parser.AST.Template Template
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Template __result0;
                        if (((global::CppSharp.Parser.AST.TemplateSpecializationType.__Internal*) __Instance)->_template == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Template.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.TemplateSpecializationType.__Internal*) __Instance)->_template))
                            __result0 = (global::CppSharp.Parser.AST.Template) global::CppSharp.Parser.AST.Template.NativeToManagedMap[((global::CppSharp.Parser.AST.TemplateSpecializationType.__Internal*) __Instance)->_template];
                        else __result0 = global::CppSharp.Parser.AST.Template.__CreateInstance(((global::CppSharp.Parser.AST.TemplateSpecializationType.__Internal*) __Instance)->_template);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.TemplateSpecializationType.__Internal*) __Instance)->_template = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.QualifiedType Desugared
                {
                    get
                    {
                        return global::CppSharp.Parser.AST.QualifiedType.__CreateInstance(((global::CppSharp.Parser.AST.TemplateSpecializationType.__Internal*) __Instance)->desugared);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.TemplateSpecializationType.__Internal*) __Instance)->desugared = ReferenceEquals(value, null) ? new global::CppSharp.Parser.AST.QualifiedType.__Internal() : *(global::CppSharp.Parser.AST.QualifiedType.__Internal*) value.__Instance;
                    }
                }

                public uint ArgumentsCount
                {
                    get
                    {
                        var __ret = __Internal.GetArgumentsCount((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }
            }

            public unsafe partial class DependentTemplateSpecializationType : global::CppSharp.Parser.AST.Type, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 48)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.TypeKind kind;

                    [FieldOffset(4)]
                    internal byte isDependent;

                    [FieldOffset(8)]
                    internal global::Std.Vector.__Internal Arguments;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal desugared;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0DependentTemplateSpecializationType@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0DependentTemplateSpecializationType@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1DependentTemplateSpecializationType@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor(global::System.IntPtr instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getArguments@DependentTemplateSpecializationType@AST@CppParser@CppSharp@@QEAA?AUTemplateArgument@234@I@Z")]
                    internal static extern void GetArguments(global::System.IntPtr instance, global::System.IntPtr @return, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?addArguments@DependentTemplateSpecializationType@AST@CppParser@CppSharp@@QEAAXAEAUTemplateArgument@234@@Z")]
                    internal static extern void AddArguments(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?clearArguments@DependentTemplateSpecializationType@AST@CppParser@CppSharp@@QEAAXXZ")]
                    internal static extern void ClearArguments(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getArgumentsCount@DependentTemplateSpecializationType@AST@CppParser@CppSharp@@QEAAIXZ")]
                    internal static extern uint GetArgumentsCount(global::System.IntPtr instance);
                }

                internal static new global::CppSharp.Parser.AST.DependentTemplateSpecializationType __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.DependentTemplateSpecializationType(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.DependentTemplateSpecializationType __CreateInstance(global::CppSharp.Parser.AST.DependentTemplateSpecializationType.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.DependentTemplateSpecializationType(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.DependentTemplateSpecializationType.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.DependentTemplateSpecializationType.__Internal));
                    global::CppSharp.Parser.AST.DependentTemplateSpecializationType.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private DependentTemplateSpecializationType(global::CppSharp.Parser.AST.DependentTemplateSpecializationType.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected DependentTemplateSpecializationType(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public DependentTemplateSpecializationType()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.DependentTemplateSpecializationType.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment));
                }

                public DependentTemplateSpecializationType(global::CppSharp.Parser.AST.DependentTemplateSpecializationType _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.DependentTemplateSpecializationType.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Type __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.TemplateArgument GetArguments(uint i)
                {
                    var __ret = new global::CppSharp.Parser.AST.TemplateArgument.__Internal();
                    __Internal.GetArguments((__Instance + __PointerAdjustment), new IntPtr(&__ret), i);
                    return global::CppSharp.Parser.AST.TemplateArgument.__CreateInstance(__ret);
                }

                public void AddArguments(global::CppSharp.Parser.AST.TemplateArgument s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    __Internal.AddArguments((__Instance + __PointerAdjustment), __arg0);
                }

                public void ClearArguments()
                {
                    __Internal.ClearArguments((__Instance + __PointerAdjustment));
                }

                public global::CppSharp.Parser.AST.QualifiedType Desugared
                {
                    get
                    {
                        return global::CppSharp.Parser.AST.QualifiedType.__CreateInstance(((global::CppSharp.Parser.AST.DependentTemplateSpecializationType.__Internal*) __Instance)->desugared);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.DependentTemplateSpecializationType.__Internal*) __Instance)->desugared = ReferenceEquals(value, null) ? new global::CppSharp.Parser.AST.QualifiedType.__Internal() : *(global::CppSharp.Parser.AST.QualifiedType.__Internal*) value.__Instance;
                    }
                }

                public uint ArgumentsCount
                {
                    get
                    {
                        var __ret = __Internal.GetArgumentsCount((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }
            }

            public unsafe partial class TemplateParameterType : global::CppSharp.Parser.AST.Type, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 32)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.TypeKind kind;

                    [FieldOffset(4)]
                    internal byte isDependent;

                    [FieldOffset(8)]
                    internal global::System.IntPtr parameter;

                    [FieldOffset(16)]
                    internal uint depth;

                    [FieldOffset(20)]
                    internal uint index;

                    [FieldOffset(24)]
                    internal byte isParameterPack;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0TemplateParameterType@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0TemplateParameterType@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1TemplateParameterType@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor(global::System.IntPtr instance, int delete);
                }

                internal static new global::CppSharp.Parser.AST.TemplateParameterType __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.TemplateParameterType(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.TemplateParameterType __CreateInstance(global::CppSharp.Parser.AST.TemplateParameterType.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.TemplateParameterType(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.TemplateParameterType.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TemplateParameterType.__Internal));
                    global::CppSharp.Parser.AST.TemplateParameterType.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private TemplateParameterType(global::CppSharp.Parser.AST.TemplateParameterType.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected TemplateParameterType(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public TemplateParameterType()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TemplateParameterType.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment));
                }

                public TemplateParameterType(global::CppSharp.Parser.AST.TemplateParameterType _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TemplateParameterType.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Type __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.TypeTemplateParameter Parameter
                {
                    get
                    {
                        global::CppSharp.Parser.AST.TypeTemplateParameter __result0;
                        if (((global::CppSharp.Parser.AST.TemplateParameterType.__Internal*) __Instance)->parameter == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.TypeTemplateParameter.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.TemplateParameterType.__Internal*) __Instance)->parameter))
                            __result0 = (global::CppSharp.Parser.AST.TypeTemplateParameter) global::CppSharp.Parser.AST.TypeTemplateParameter.NativeToManagedMap[((global::CppSharp.Parser.AST.TemplateParameterType.__Internal*) __Instance)->parameter];
                        else __result0 = global::CppSharp.Parser.AST.TypeTemplateParameter.__CreateInstance(((global::CppSharp.Parser.AST.TemplateParameterType.__Internal*) __Instance)->parameter);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.TemplateParameterType.__Internal*) __Instance)->parameter = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public uint Depth
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.TemplateParameterType.__Internal*) __Instance)->depth;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.TemplateParameterType.__Internal*) __Instance)->depth = value;
                    }
                }

                public uint Index
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.TemplateParameterType.__Internal*) __Instance)->index;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.TemplateParameterType.__Internal*) __Instance)->index = value;
                    }
                }

                public bool IsParameterPack
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.TemplateParameterType.__Internal*) __Instance)->isParameterPack != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.TemplateParameterType.__Internal*) __Instance)->isParameterPack = (byte) (value ? 1 : 0);
                    }
                }
            }

            public unsafe partial class TemplateParameterSubstitutionType : global::CppSharp.Parser.AST.Type, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 32)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.TypeKind kind;

                    [FieldOffset(4)]
                    internal byte isDependent;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal replacement;

                    [FieldOffset(24)]
                    internal global::System.IntPtr replacedParameter;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0TemplateParameterSubstitutionType@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0TemplateParameterSubstitutionType@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.TemplateParameterSubstitutionType __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.TemplateParameterSubstitutionType(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.TemplateParameterSubstitutionType __CreateInstance(global::CppSharp.Parser.AST.TemplateParameterSubstitutionType.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.TemplateParameterSubstitutionType(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.TemplateParameterSubstitutionType.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TemplateParameterSubstitutionType.__Internal));
                    global::CppSharp.Parser.AST.TemplateParameterSubstitutionType.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private TemplateParameterSubstitutionType(global::CppSharp.Parser.AST.TemplateParameterSubstitutionType.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected TemplateParameterSubstitutionType(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public TemplateParameterSubstitutionType()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TemplateParameterSubstitutionType.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment));
                }

                public TemplateParameterSubstitutionType(global::CppSharp.Parser.AST.TemplateParameterSubstitutionType _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TemplateParameterSubstitutionType.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
                }

                public global::CppSharp.Parser.AST.QualifiedType Replacement
                {
                    get
                    {
                        return global::CppSharp.Parser.AST.QualifiedType.__CreateInstance(((global::CppSharp.Parser.AST.TemplateParameterSubstitutionType.__Internal*) __Instance)->replacement);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.TemplateParameterSubstitutionType.__Internal*) __Instance)->replacement = ReferenceEquals(value, null) ? new global::CppSharp.Parser.AST.QualifiedType.__Internal() : *(global::CppSharp.Parser.AST.QualifiedType.__Internal*) value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.TemplateParameterType ReplacedParameter
                {
                    get
                    {
                        global::CppSharp.Parser.AST.TemplateParameterType __result0;
                        if (((global::CppSharp.Parser.AST.TemplateParameterSubstitutionType.__Internal*) __Instance)->replacedParameter == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.TemplateParameterType.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.TemplateParameterSubstitutionType.__Internal*) __Instance)->replacedParameter))
                            __result0 = (global::CppSharp.Parser.AST.TemplateParameterType) global::CppSharp.Parser.AST.TemplateParameterType.NativeToManagedMap[((global::CppSharp.Parser.AST.TemplateParameterSubstitutionType.__Internal*) __Instance)->replacedParameter];
                        else __result0 = global::CppSharp.Parser.AST.TemplateParameterType.__CreateInstance(((global::CppSharp.Parser.AST.TemplateParameterSubstitutionType.__Internal*) __Instance)->replacedParameter);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.TemplateParameterSubstitutionType.__Internal*) __Instance)->replacedParameter = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }
            }

            public unsafe partial class InjectedClassNameType : global::CppSharp.Parser.AST.Type, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 32)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.TypeKind kind;

                    [FieldOffset(4)]
                    internal byte isDependent;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal injectedSpecializationType;

                    [FieldOffset(24)]
                    internal global::System.IntPtr _class;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0InjectedClassNameType@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0InjectedClassNameType@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.InjectedClassNameType __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.InjectedClassNameType(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.InjectedClassNameType __CreateInstance(global::CppSharp.Parser.AST.InjectedClassNameType.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.InjectedClassNameType(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.InjectedClassNameType.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.InjectedClassNameType.__Internal));
                    global::CppSharp.Parser.AST.InjectedClassNameType.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private InjectedClassNameType(global::CppSharp.Parser.AST.InjectedClassNameType.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected InjectedClassNameType(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public InjectedClassNameType()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.InjectedClassNameType.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment));
                }

                public InjectedClassNameType(global::CppSharp.Parser.AST.InjectedClassNameType _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.InjectedClassNameType.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
                }

                public global::CppSharp.Parser.AST.QualifiedType InjectedSpecializationType
                {
                    get
                    {
                        return global::CppSharp.Parser.AST.QualifiedType.__CreateInstance(((global::CppSharp.Parser.AST.InjectedClassNameType.__Internal*) __Instance)->injectedSpecializationType);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.InjectedClassNameType.__Internal*) __Instance)->injectedSpecializationType = ReferenceEquals(value, null) ? new global::CppSharp.Parser.AST.QualifiedType.__Internal() : *(global::CppSharp.Parser.AST.QualifiedType.__Internal*) value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Class Class
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Class __result0;
                        if (((global::CppSharp.Parser.AST.InjectedClassNameType.__Internal*) __Instance)->_class == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Class.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.InjectedClassNameType.__Internal*) __Instance)->_class))
                            __result0 = (global::CppSharp.Parser.AST.Class) global::CppSharp.Parser.AST.Class.NativeToManagedMap[((global::CppSharp.Parser.AST.InjectedClassNameType.__Internal*) __Instance)->_class];
                        else __result0 = global::CppSharp.Parser.AST.Class.__CreateInstance(((global::CppSharp.Parser.AST.InjectedClassNameType.__Internal*) __Instance)->_class);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.InjectedClassNameType.__Internal*) __Instance)->_class = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }
            }

            public unsafe partial class DependentNameType : global::CppSharp.Parser.AST.Type, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 56)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.TypeKind kind;

                    [FieldOffset(4)]
                    internal byte isDependent;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal qualifier;

                    [FieldOffset(24)]
                    internal global::Std.BasicString.__Internal identifier;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0DependentNameType@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0DependentNameType@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1DependentNameType@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor(global::System.IntPtr instance, int delete);
                }

                internal static new global::CppSharp.Parser.AST.DependentNameType __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.DependentNameType(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.DependentNameType __CreateInstance(global::CppSharp.Parser.AST.DependentNameType.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.DependentNameType(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.DependentNameType.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.DependentNameType.__Internal));
                    global::CppSharp.Parser.AST.DependentNameType.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private DependentNameType(global::CppSharp.Parser.AST.DependentNameType.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected DependentNameType(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public DependentNameType()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.DependentNameType.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment));
                }

                public DependentNameType(global::CppSharp.Parser.AST.DependentNameType _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.DependentNameType.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Type __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.QualifiedType Qualifier
                {
                    get
                    {
                        return global::CppSharp.Parser.AST.QualifiedType.__CreateInstance(((global::CppSharp.Parser.AST.DependentNameType.__Internal*) __Instance)->qualifier);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.DependentNameType.__Internal*) __Instance)->qualifier = ReferenceEquals(value, null) ? new global::CppSharp.Parser.AST.QualifiedType.__Internal() : *(global::CppSharp.Parser.AST.QualifiedType.__Internal*) value.__Instance;
                    }
                }

                public string Identifier
                {
                    get
                    {
                        var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(((global::CppSharp.Parser.AST.DependentNameType.__Internal*) __Instance)->identifier);
                        var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                        __basicStringRet.Dispose(false);
                        return __stringRet;
                    }

                    set
                    {
                        var __allocator0 = new global::Std.Allocator<sbyte>();
                        var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                        ((global::CppSharp.Parser.AST.DependentNameType.__Internal*) __Instance)->identifier = *(global::Std.BasicString.__Internal*) __basicString0.__Instance;
                    }
                }
            }

            public unsafe partial class PackExpansionType : global::CppSharp.Parser.AST.Type, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 8)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.TypeKind kind;

                    [FieldOffset(4)]
                    internal byte isDependent;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0PackExpansionType@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0PackExpansionType@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.PackExpansionType __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.PackExpansionType(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.PackExpansionType __CreateInstance(global::CppSharp.Parser.AST.PackExpansionType.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.PackExpansionType(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.PackExpansionType.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.PackExpansionType.__Internal));
                    global::CppSharp.Parser.AST.PackExpansionType.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private PackExpansionType(global::CppSharp.Parser.AST.PackExpansionType.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected PackExpansionType(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public PackExpansionType()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.PackExpansionType.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment));
                }

                public PackExpansionType(global::CppSharp.Parser.AST.PackExpansionType _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.PackExpansionType.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
                }
            }

            public unsafe partial class UnaryTransformType : global::CppSharp.Parser.AST.Type, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 40)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.TypeKind kind;

                    [FieldOffset(4)]
                    internal byte isDependent;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal desugared;

                    [FieldOffset(24)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal baseType;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0UnaryTransformType@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0UnaryTransformType@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.UnaryTransformType __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.UnaryTransformType(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.UnaryTransformType __CreateInstance(global::CppSharp.Parser.AST.UnaryTransformType.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.UnaryTransformType(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.UnaryTransformType.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.UnaryTransformType.__Internal));
                    global::CppSharp.Parser.AST.UnaryTransformType.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private UnaryTransformType(global::CppSharp.Parser.AST.UnaryTransformType.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected UnaryTransformType(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public UnaryTransformType()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.UnaryTransformType.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment));
                }

                public UnaryTransformType(global::CppSharp.Parser.AST.UnaryTransformType _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.UnaryTransformType.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
                }

                public global::CppSharp.Parser.AST.QualifiedType Desugared
                {
                    get
                    {
                        return global::CppSharp.Parser.AST.QualifiedType.__CreateInstance(((global::CppSharp.Parser.AST.UnaryTransformType.__Internal*) __Instance)->desugared);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.UnaryTransformType.__Internal*) __Instance)->desugared = ReferenceEquals(value, null) ? new global::CppSharp.Parser.AST.QualifiedType.__Internal() : *(global::CppSharp.Parser.AST.QualifiedType.__Internal*) value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.QualifiedType BaseType
                {
                    get
                    {
                        return global::CppSharp.Parser.AST.QualifiedType.__CreateInstance(((global::CppSharp.Parser.AST.UnaryTransformType.__Internal*) __Instance)->baseType);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.UnaryTransformType.__Internal*) __Instance)->baseType = ReferenceEquals(value, null) ? new global::CppSharp.Parser.AST.QualifiedType.__Internal() : *(global::CppSharp.Parser.AST.QualifiedType.__Internal*) value.__Instance;
                    }
                }
            }

            public unsafe partial class VectorType : global::CppSharp.Parser.AST.Type, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 32)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.TypeKind kind;

                    [FieldOffset(4)]
                    internal byte isDependent;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal elementType;

                    [FieldOffset(24)]
                    internal uint numElements;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0VectorType@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0VectorType@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.VectorType __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.VectorType(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.VectorType __CreateInstance(global::CppSharp.Parser.AST.VectorType.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.VectorType(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.VectorType.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.VectorType.__Internal));
                    global::CppSharp.Parser.AST.VectorType.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private VectorType(global::CppSharp.Parser.AST.VectorType.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected VectorType(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public VectorType()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.VectorType.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment));
                }

                public VectorType(global::CppSharp.Parser.AST.VectorType _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.VectorType.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
                }

                public global::CppSharp.Parser.AST.QualifiedType ElementType
                {
                    get
                    {
                        return global::CppSharp.Parser.AST.QualifiedType.__CreateInstance(((global::CppSharp.Parser.AST.VectorType.__Internal*) __Instance)->elementType);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.VectorType.__Internal*) __Instance)->elementType = ReferenceEquals(value, null) ? new global::CppSharp.Parser.AST.QualifiedType.__Internal() : *(global::CppSharp.Parser.AST.QualifiedType.__Internal*) value.__Instance;
                    }
                }

                public uint NumElements
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.VectorType.__Internal*) __Instance)->numElements;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.VectorType.__Internal*) __Instance)->numElements = value;
                    }
                }
            }

            public unsafe partial class BuiltinType : global::CppSharp.Parser.AST.Type, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 12)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.TypeKind kind;

                    [FieldOffset(4)]
                    internal byte isDependent;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.PrimitiveType type;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0BuiltinType@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0BuiltinType@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.BuiltinType __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.BuiltinType(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.BuiltinType __CreateInstance(global::CppSharp.Parser.AST.BuiltinType.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.BuiltinType(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.BuiltinType.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.BuiltinType.__Internal));
                    global::CppSharp.Parser.AST.BuiltinType.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private BuiltinType(global::CppSharp.Parser.AST.BuiltinType.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected BuiltinType(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public BuiltinType()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.BuiltinType.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment));
                }

                public BuiltinType(global::CppSharp.Parser.AST.BuiltinType _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.BuiltinType.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
                }

                public global::CppSharp.Parser.AST.PrimitiveType Type
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.BuiltinType.__Internal*) __Instance)->type;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.BuiltinType.__Internal*) __Instance)->type = value;
                    }
                }
            }

            public unsafe partial class VTableComponent : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 16)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.VTableComponentKind kind;

                    [FieldOffset(4)]
                    internal uint offset;

                    [FieldOffset(8)]
                    internal global::System.IntPtr declaration;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0VTableComponent@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0VTableComponent@AST@CppParser@CppSharp@@QEAA@AEBU0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                protected int __PointerAdjustment;
                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.VTableComponent> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.VTableComponent>();
                protected void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                internal static global::CppSharp.Parser.AST.VTableComponent __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.VTableComponent(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.VTableComponent __CreateInstance(global::CppSharp.Parser.AST.VTableComponent.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.VTableComponent(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.VTableComponent.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.VTableComponent.__Internal));
                    *(global::CppSharp.Parser.AST.VTableComponent.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private VTableComponent(global::CppSharp.Parser.AST.VTableComponent.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected VTableComponent(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public VTableComponent()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.VTableComponent.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment));
                }

                public VTableComponent(global::CppSharp.Parser.AST.VTableComponent _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.VTableComponent.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.VTableComponent.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.VTableComponent.__Internal*) _0.__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                public virtual void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.VTableComponent __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.VTableComponentKind Kind
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.VTableComponent.__Internal*) __Instance)->kind;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.VTableComponent.__Internal*) __Instance)->kind = value;
                    }
                }

                public uint Offset
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.VTableComponent.__Internal*) __Instance)->offset;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.VTableComponent.__Internal*) __Instance)->offset = value;
                    }
                }

                public global::CppSharp.Parser.AST.Declaration Declaration
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Declaration __result0;
                        if (((global::CppSharp.Parser.AST.VTableComponent.__Internal*) __Instance)->declaration == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Declaration.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.VTableComponent.__Internal*) __Instance)->declaration))
                            __result0 = (global::CppSharp.Parser.AST.Declaration) global::CppSharp.Parser.AST.Declaration.NativeToManagedMap[((global::CppSharp.Parser.AST.VTableComponent.__Internal*) __Instance)->declaration];
                        else __result0 = global::CppSharp.Parser.AST.Declaration.__CreateInstance(((global::CppSharp.Parser.AST.VTableComponent.__Internal*) __Instance)->declaration);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.VTableComponent.__Internal*) __Instance)->declaration = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }
            }

            public unsafe partial class VTableLayout : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 24)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::Std.Vector.__Internal Components;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0VTableLayout@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0VTableLayout@AST@CppParser@CppSharp@@QEAA@AEBU0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1VTableLayout@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor(global::System.IntPtr instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getComponents@VTableLayout@AST@CppParser@CppSharp@@QEAA?AUVTableComponent@234@I@Z")]
                    internal static extern void GetComponents(global::System.IntPtr instance, global::System.IntPtr @return, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?addComponents@VTableLayout@AST@CppParser@CppSharp@@QEAAXAEAUVTableComponent@234@@Z")]
                    internal static extern void AddComponents(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?clearComponents@VTableLayout@AST@CppParser@CppSharp@@QEAAXXZ")]
                    internal static extern void ClearComponents(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getComponentsCount@VTableLayout@AST@CppParser@CppSharp@@QEAAIXZ")]
                    internal static extern uint GetComponentsCount(global::System.IntPtr instance);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                protected int __PointerAdjustment;
                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.VTableLayout> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.VTableLayout>();
                protected void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                internal static global::CppSharp.Parser.AST.VTableLayout __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.VTableLayout(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.VTableLayout __CreateInstance(global::CppSharp.Parser.AST.VTableLayout.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.VTableLayout(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.VTableLayout.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.VTableLayout.__Internal));
                    global::CppSharp.Parser.AST.VTableLayout.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private VTableLayout(global::CppSharp.Parser.AST.VTableLayout.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected VTableLayout(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public VTableLayout()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.VTableLayout.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment));
                }

                public VTableLayout(global::CppSharp.Parser.AST.VTableLayout _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.VTableLayout.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                public virtual void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.VTableLayout __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.VTableComponent GetComponents(uint i)
                {
                    var __ret = new global::CppSharp.Parser.AST.VTableComponent.__Internal();
                    __Internal.GetComponents((__Instance + __PointerAdjustment), new IntPtr(&__ret), i);
                    return global::CppSharp.Parser.AST.VTableComponent.__CreateInstance(__ret);
                }

                public void AddComponents(global::CppSharp.Parser.AST.VTableComponent s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    __Internal.AddComponents((__Instance + __PointerAdjustment), __arg0);
                }

                public void ClearComponents()
                {
                    __Internal.ClearComponents((__Instance + __PointerAdjustment));
                }

                public uint ComponentsCount
                {
                    get
                    {
                        var __ret = __Internal.GetComponentsCount((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }
            }

            public unsafe partial class VFTableInfo : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 40)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal ulong VBTableIndex;

                    [FieldOffset(8)]
                    internal uint VFPtrOffset;

                    [FieldOffset(12)]
                    internal uint VFPtrFullOffset;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.AST.VTableLayout.__Internal layout;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0VFTableInfo@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0VFTableInfo@AST@CppParser@CppSharp@@QEAA@AEBU0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1VFTableInfo@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor(global::System.IntPtr instance, int delete);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                protected int __PointerAdjustment;
                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.VFTableInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.VFTableInfo>();
                protected void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                internal static global::CppSharp.Parser.AST.VFTableInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.VFTableInfo(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.VFTableInfo __CreateInstance(global::CppSharp.Parser.AST.VFTableInfo.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.VFTableInfo(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.VFTableInfo.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.VFTableInfo.__Internal));
                    global::CppSharp.Parser.AST.VFTableInfo.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private VFTableInfo(global::CppSharp.Parser.AST.VFTableInfo.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected VFTableInfo(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public VFTableInfo()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.VFTableInfo.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment));
                }

                public VFTableInfo(global::CppSharp.Parser.AST.VFTableInfo _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.VFTableInfo.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                public virtual void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.VFTableInfo __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public ulong VBTableIndex
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.VFTableInfo.__Internal*) __Instance)->VBTableIndex;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.VFTableInfo.__Internal*) __Instance)->VBTableIndex = value;
                    }
                }

                public uint VFPtrOffset
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.VFTableInfo.__Internal*) __Instance)->VFPtrOffset;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.VFTableInfo.__Internal*) __Instance)->VFPtrOffset = value;
                    }
                }

                public uint VFPtrFullOffset
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.VFTableInfo.__Internal*) __Instance)->VFPtrFullOffset;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.VFTableInfo.__Internal*) __Instance)->VFPtrFullOffset = value;
                    }
                }

                public global::CppSharp.Parser.AST.VTableLayout Layout
                {
                    get
                    {
                        return global::CppSharp.Parser.AST.VTableLayout.__CreateInstance(((global::CppSharp.Parser.AST.VFTableInfo.__Internal*) __Instance)->layout);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.VFTableInfo.__Internal*) __Instance)->layout = ReferenceEquals(value, null) ? new global::CppSharp.Parser.AST.VTableLayout.__Internal() : *(global::CppSharp.Parser.AST.VTableLayout.__Internal*) value.__Instance;
                    }
                }
            }

            public unsafe partial class LayoutField : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 64)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal uint offset;

                    [FieldOffset(8)]
                    internal global::Std.BasicString.__Internal name;

                    [FieldOffset(40)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal qualifiedType;

                    [FieldOffset(56)]
                    internal global::System.IntPtr fieldPtr;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0LayoutField@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0LayoutField@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr other);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1LayoutField@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor(global::System.IntPtr instance, int delete);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                protected int __PointerAdjustment;
                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.LayoutField> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.LayoutField>();
                protected void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                internal static global::CppSharp.Parser.AST.LayoutField __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.LayoutField(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.LayoutField __CreateInstance(global::CppSharp.Parser.AST.LayoutField.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.LayoutField(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.LayoutField.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.LayoutField.__Internal));
                    global::CppSharp.Parser.AST.LayoutField.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private LayoutField(global::CppSharp.Parser.AST.LayoutField.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected LayoutField(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public LayoutField()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.LayoutField.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment));
                }

                public LayoutField(global::CppSharp.Parser.AST.LayoutField other)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.LayoutField.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(other, null))
                        throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = other.__Instance;
                    __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                public virtual void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.LayoutField __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public uint Offset
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.LayoutField.__Internal*) __Instance)->offset;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.LayoutField.__Internal*) __Instance)->offset = value;
                    }
                }

                public string Name
                {
                    get
                    {
                        var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(((global::CppSharp.Parser.AST.LayoutField.__Internal*) __Instance)->name);
                        var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                        __basicStringRet.Dispose(false);
                        return __stringRet;
                    }

                    set
                    {
                        var __allocator0 = new global::Std.Allocator<sbyte>();
                        var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                        ((global::CppSharp.Parser.AST.LayoutField.__Internal*) __Instance)->name = *(global::Std.BasicString.__Internal*) __basicString0.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.QualifiedType QualifiedType
                {
                    get
                    {
                        return global::CppSharp.Parser.AST.QualifiedType.__CreateInstance(((global::CppSharp.Parser.AST.LayoutField.__Internal*) __Instance)->qualifiedType);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.LayoutField.__Internal*) __Instance)->qualifiedType = ReferenceEquals(value, null) ? new global::CppSharp.Parser.AST.QualifiedType.__Internal() : *(global::CppSharp.Parser.AST.QualifiedType.__Internal*) value.__Instance;
                    }
                }

                public global::System.IntPtr FieldPtr
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.LayoutField.__Internal*) __Instance)->fieldPtr;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.LayoutField.__Internal*) __Instance)->fieldPtr = (global::System.IntPtr) value;
                    }
                }
            }

            public unsafe partial class LayoutBase : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 16)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal uint offset;

                    [FieldOffset(8)]
                    internal global::System.IntPtr _class;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0LayoutBase@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0LayoutBase@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr other);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1LayoutBase@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor(global::System.IntPtr instance, int delete);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                protected int __PointerAdjustment;
                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.LayoutBase> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.LayoutBase>();
                protected void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                internal static global::CppSharp.Parser.AST.LayoutBase __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.LayoutBase(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.LayoutBase __CreateInstance(global::CppSharp.Parser.AST.LayoutBase.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.LayoutBase(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.LayoutBase.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.LayoutBase.__Internal));
                    global::CppSharp.Parser.AST.LayoutBase.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private LayoutBase(global::CppSharp.Parser.AST.LayoutBase.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected LayoutBase(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public LayoutBase()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.LayoutBase.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment));
                }

                public LayoutBase(global::CppSharp.Parser.AST.LayoutBase other)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.LayoutBase.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(other, null))
                        throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = other.__Instance;
                    __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                public virtual void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.LayoutBase __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public uint Offset
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.LayoutBase.__Internal*) __Instance)->offset;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.LayoutBase.__Internal*) __Instance)->offset = value;
                    }
                }

                public global::CppSharp.Parser.AST.Class Class
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Class __result0;
                        if (((global::CppSharp.Parser.AST.LayoutBase.__Internal*) __Instance)->_class == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Class.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.LayoutBase.__Internal*) __Instance)->_class))
                            __result0 = (global::CppSharp.Parser.AST.Class) global::CppSharp.Parser.AST.Class.NativeToManagedMap[((global::CppSharp.Parser.AST.LayoutBase.__Internal*) __Instance)->_class];
                        else __result0 = global::CppSharp.Parser.AST.Class.__CreateInstance(((global::CppSharp.Parser.AST.LayoutBase.__Internal*) __Instance)->_class);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.LayoutBase.__Internal*) __Instance)->_class = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }
            }

            public unsafe partial class ClassLayout : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 128)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.CppAbi ABI;

                    [FieldOffset(8)]
                    internal global::Std.Vector.__Internal VFTables;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.AST.VTableLayout.__Internal layout;

                    [FieldOffset(56)]
                    internal byte hasOwnVFPtr;

                    [FieldOffset(60)]
                    internal int VBPtrOffset;

                    [FieldOffset(64)]
                    internal int alignment;

                    [FieldOffset(68)]
                    internal int size;

                    [FieldOffset(72)]
                    internal int dataSize;

                    [FieldOffset(80)]
                    internal global::Std.Vector.__Internal Fields;

                    [FieldOffset(104)]
                    internal global::Std.Vector.__Internal Bases;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0ClassLayout@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0ClassLayout@AST@CppParser@CppSharp@@QEAA@AEBU0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1ClassLayout@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor(global::System.IntPtr instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getVFTables@ClassLayout@AST@CppParser@CppSharp@@QEAA?AUVFTableInfo@234@I@Z")]
                    internal static extern void GetVFTables(global::System.IntPtr instance, global::System.IntPtr @return, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?addVFTables@ClassLayout@AST@CppParser@CppSharp@@QEAAXAEAUVFTableInfo@234@@Z")]
                    internal static extern void AddVFTables(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?clearVFTables@ClassLayout@AST@CppParser@CppSharp@@QEAAXXZ")]
                    internal static extern void ClearVFTables(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getFields@ClassLayout@AST@CppParser@CppSharp@@QEAA?AVLayoutField@234@I@Z")]
                    internal static extern void GetFields(global::System.IntPtr instance, global::System.IntPtr @return, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?addFields@ClassLayout@AST@CppParser@CppSharp@@QEAAXAEAVLayoutField@234@@Z")]
                    internal static extern void AddFields(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?clearFields@ClassLayout@AST@CppParser@CppSharp@@QEAAXXZ")]
                    internal static extern void ClearFields(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getBases@ClassLayout@AST@CppParser@CppSharp@@QEAA?AVLayoutBase@234@I@Z")]
                    internal static extern void GetBases(global::System.IntPtr instance, global::System.IntPtr @return, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?addBases@ClassLayout@AST@CppParser@CppSharp@@QEAAXAEAVLayoutBase@234@@Z")]
                    internal static extern void AddBases(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?clearBases@ClassLayout@AST@CppParser@CppSharp@@QEAAXXZ")]
                    internal static extern void ClearBases(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getVFTablesCount@ClassLayout@AST@CppParser@CppSharp@@QEAAIXZ")]
                    internal static extern uint GetVFTablesCount(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getFieldsCount@ClassLayout@AST@CppParser@CppSharp@@QEAAIXZ")]
                    internal static extern uint GetFieldsCount(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getBasesCount@ClassLayout@AST@CppParser@CppSharp@@QEAAIXZ")]
                    internal static extern uint GetBasesCount(global::System.IntPtr instance);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                protected int __PointerAdjustment;
                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.ClassLayout> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.ClassLayout>();
                protected void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                internal static global::CppSharp.Parser.AST.ClassLayout __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.ClassLayout(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.ClassLayout __CreateInstance(global::CppSharp.Parser.AST.ClassLayout.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.ClassLayout(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.ClassLayout.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ClassLayout.__Internal));
                    global::CppSharp.Parser.AST.ClassLayout.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private ClassLayout(global::CppSharp.Parser.AST.ClassLayout.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected ClassLayout(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public ClassLayout()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ClassLayout.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment));
                }

                public ClassLayout(global::CppSharp.Parser.AST.ClassLayout _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ClassLayout.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                public virtual void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.ClassLayout __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.VFTableInfo GetVFTables(uint i)
                {
                    var __ret = new global::CppSharp.Parser.AST.VFTableInfo.__Internal();
                    __Internal.GetVFTables((__Instance + __PointerAdjustment), new IntPtr(&__ret), i);
                    return global::CppSharp.Parser.AST.VFTableInfo.__CreateInstance(__ret);
                }

                public void AddVFTables(global::CppSharp.Parser.AST.VFTableInfo s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    __Internal.AddVFTables((__Instance + __PointerAdjustment), __arg0);
                }

                public void ClearVFTables()
                {
                    __Internal.ClearVFTables((__Instance + __PointerAdjustment));
                }

                public global::CppSharp.Parser.AST.LayoutField GetFields(uint i)
                {
                    var __ret = new global::CppSharp.Parser.AST.LayoutField.__Internal();
                    __Internal.GetFields((__Instance + __PointerAdjustment), new IntPtr(&__ret), i);
                    return global::CppSharp.Parser.AST.LayoutField.__CreateInstance(__ret);
                }

                public void AddFields(global::CppSharp.Parser.AST.LayoutField s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    __Internal.AddFields((__Instance + __PointerAdjustment), __arg0);
                }

                public void ClearFields()
                {
                    __Internal.ClearFields((__Instance + __PointerAdjustment));
                }

                public global::CppSharp.Parser.AST.LayoutBase GetBases(uint i)
                {
                    var __ret = new global::CppSharp.Parser.AST.LayoutBase.__Internal();
                    __Internal.GetBases((__Instance + __PointerAdjustment), new IntPtr(&__ret), i);
                    return global::CppSharp.Parser.AST.LayoutBase.__CreateInstance(__ret);
                }

                public void AddBases(global::CppSharp.Parser.AST.LayoutBase s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    __Internal.AddBases((__Instance + __PointerAdjustment), __arg0);
                }

                public void ClearBases()
                {
                    __Internal.ClearBases((__Instance + __PointerAdjustment));
                }

                public global::CppSharp.Parser.AST.CppAbi ABI
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.ClassLayout.__Internal*) __Instance)->ABI;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.ClassLayout.__Internal*) __Instance)->ABI = value;
                    }
                }

                public global::CppSharp.Parser.AST.VTableLayout Layout
                {
                    get
                    {
                        return global::CppSharp.Parser.AST.VTableLayout.__CreateInstance(((global::CppSharp.Parser.AST.ClassLayout.__Internal*) __Instance)->layout);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.ClassLayout.__Internal*) __Instance)->layout = ReferenceEquals(value, null) ? new global::CppSharp.Parser.AST.VTableLayout.__Internal() : *(global::CppSharp.Parser.AST.VTableLayout.__Internal*) value.__Instance;
                    }
                }

                public bool HasOwnVFPtr
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.ClassLayout.__Internal*) __Instance)->hasOwnVFPtr != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.ClassLayout.__Internal*) __Instance)->hasOwnVFPtr = (byte) (value ? 1 : 0);
                    }
                }

                public int VBPtrOffset
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.ClassLayout.__Internal*) __Instance)->VBPtrOffset;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.ClassLayout.__Internal*) __Instance)->VBPtrOffset = value;
                    }
                }

                public int Alignment
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.ClassLayout.__Internal*) __Instance)->alignment;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.ClassLayout.__Internal*) __Instance)->alignment = value;
                    }
                }

                public int Size
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.ClassLayout.__Internal*) __Instance)->size;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.ClassLayout.__Internal*) __Instance)->size = value;
                    }
                }

                public int DataSize
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.ClassLayout.__Internal*) __Instance)->dataSize;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.ClassLayout.__Internal*) __Instance)->dataSize = value;
                    }
                }

                public uint VFTablesCount
                {
                    get
                    {
                        var __ret = __Internal.GetVFTablesCount((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                public uint FieldsCount
                {
                    get
                    {
                        var __ret = __Internal.GetFieldsCount((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                public uint BasesCount
                {
                    get
                    {
                        var __ret = __Internal.GetBasesCount((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }
            }

            public unsafe partial class Declaration : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 224)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.DeclarationKind kind;

                    [FieldOffset(4)]
                    internal int maxFieldAlignment;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.AccessSpecifier access;

                    [FieldOffset(16)]
                    internal global::System.IntPtr _namespace;

                    [FieldOffset(24)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal location;

                    [FieldOffset(28)]
                    internal int lineNumberStart;

                    [FieldOffset(32)]
                    internal int lineNumberEnd;

                    [FieldOffset(40)]
                    internal global::Std.BasicString.__Internal name;

                    [FieldOffset(72)]
                    internal global::Std.BasicString.__Internal USR;

                    [FieldOffset(104)]
                    internal global::Std.BasicString.__Internal debugText;

                    [FieldOffset(136)]
                    internal byte isIncomplete;

                    [FieldOffset(137)]
                    internal byte isDependent;

                    [FieldOffset(138)]
                    internal byte isImplicit;

                    [FieldOffset(144)]
                    internal global::System.IntPtr completeDeclaration;

                    [FieldOffset(152)]
                    internal uint definitionOrder;

                    [FieldOffset(160)]
                    internal global::Std.Vector.__Internal PreprocessedEntities;

                    [FieldOffset(184)]
                    internal global::Std.Vector.__Internal Redeclarations;

                    [FieldOffset(208)]
                    internal global::System.IntPtr originalPtr;

                    [FieldOffset(216)]
                    internal global::System.IntPtr comment;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0Declaration@AST@CppParser@CppSharp@@QEAA@W4DeclarationKind@123@@Z")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::CppSharp.Parser.AST.DeclarationKind kind);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0Declaration@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1Declaration@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor(global::System.IntPtr instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getPreprocessedEntities@Declaration@AST@CppParser@CppSharp@@QEAAPEAVPreprocessedEntity@234@I@Z")]
                    internal static extern global::System.IntPtr GetPreprocessedEntities(global::System.IntPtr instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?addPreprocessedEntities@Declaration@AST@CppParser@CppSharp@@QEAAXAEAPEAVPreprocessedEntity@234@@Z")]
                    internal static extern void AddPreprocessedEntities(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?clearPreprocessedEntities@Declaration@AST@CppParser@CppSharp@@QEAAXXZ")]
                    internal static extern void ClearPreprocessedEntities(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getRedeclarations@Declaration@AST@CppParser@CppSharp@@QEAAPEAV1234@I@Z")]
                    internal static extern global::System.IntPtr GetRedeclarations(global::System.IntPtr instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?addRedeclarations@Declaration@AST@CppParser@CppSharp@@QEAAXAEAPEAV1234@@Z")]
                    internal static extern void AddRedeclarations(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?clearRedeclarations@Declaration@AST@CppParser@CppSharp@@QEAAXXZ")]
                    internal static extern void ClearRedeclarations(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getPreprocessedEntitiesCount@Declaration@AST@CppParser@CppSharp@@QEAAIXZ")]
                    internal static extern uint GetPreprocessedEntitiesCount(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getRedeclarationsCount@Declaration@AST@CppParser@CppSharp@@QEAAIXZ")]
                    internal static extern uint GetRedeclarationsCount(global::System.IntPtr instance);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                protected int __PointerAdjustment;
                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.Declaration> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.Declaration>();
                protected void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                internal static global::CppSharp.Parser.AST.Declaration __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.Declaration(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.Declaration __CreateInstance(global::CppSharp.Parser.AST.Declaration.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.Declaration(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.Declaration.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Declaration.__Internal));
                    global::CppSharp.Parser.AST.Declaration.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private Declaration(global::CppSharp.Parser.AST.Declaration.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected Declaration(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public Declaration(global::CppSharp.Parser.AST.DeclarationKind kind)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Declaration.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment), kind);
                }

                public Declaration(global::CppSharp.Parser.AST.Declaration _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Declaration.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                public virtual void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Declaration __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.PreprocessedEntity GetPreprocessedEntities(uint i)
                {
                    var __ret = __Internal.GetPreprocessedEntities((__Instance + __PointerAdjustment), i);
                    global::CppSharp.Parser.AST.PreprocessedEntity __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.PreprocessedEntity.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::CppSharp.Parser.AST.PreprocessedEntity) global::CppSharp.Parser.AST.PreprocessedEntity.NativeToManagedMap[__ret];
                    else __result0 = global::CppSharp.Parser.AST.PreprocessedEntity.__CreateInstance(__ret);
                    return __result0;
                }

                public void AddPreprocessedEntities(global::CppSharp.Parser.AST.PreprocessedEntity s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    __Internal.AddPreprocessedEntities((__Instance + __PointerAdjustment), __arg0);
                }

                public void ClearPreprocessedEntities()
                {
                    __Internal.ClearPreprocessedEntities((__Instance + __PointerAdjustment));
                }

                public global::CppSharp.Parser.AST.Declaration GetRedeclarations(uint i)
                {
                    var __ret = __Internal.GetRedeclarations((__Instance + __PointerAdjustment), i);
                    global::CppSharp.Parser.AST.Declaration __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.Declaration.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::CppSharp.Parser.AST.Declaration) global::CppSharp.Parser.AST.Declaration.NativeToManagedMap[__ret];
                    else __result0 = global::CppSharp.Parser.AST.Declaration.__CreateInstance(__ret);
                    return __result0;
                }

                public void AddRedeclarations(global::CppSharp.Parser.AST.Declaration s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    __Internal.AddRedeclarations((__Instance + __PointerAdjustment), __arg0);
                }

                public void ClearRedeclarations()
                {
                    __Internal.ClearRedeclarations((__Instance + __PointerAdjustment));
                }

                public static implicit operator global::CppSharp.Parser.AST.Declaration(global::CppSharp.Parser.AST.DeclarationKind kind)
                {
                    return new global::CppSharp.Parser.AST.Declaration(kind);
                }

                public global::CppSharp.Parser.AST.DeclarationKind Kind
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Declaration.__Internal*) __Instance)->kind;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Declaration.__Internal*) __Instance)->kind = value;
                    }
                }

                public int MaxFieldAlignment
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Declaration.__Internal*) __Instance)->maxFieldAlignment;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Declaration.__Internal*) __Instance)->maxFieldAlignment = value;
                    }
                }

                public global::CppSharp.Parser.AST.AccessSpecifier Access
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Declaration.__Internal*) __Instance)->access;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Declaration.__Internal*) __Instance)->access = value;
                    }
                }

                public global::CppSharp.Parser.AST.DeclarationContext Namespace
                {
                    get
                    {
                        global::CppSharp.Parser.AST.DeclarationContext __result0;
                        if (((global::CppSharp.Parser.AST.Declaration.__Internal*) __Instance)->_namespace == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.DeclarationContext.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.Declaration.__Internal*) __Instance)->_namespace))
                            __result0 = (global::CppSharp.Parser.AST.DeclarationContext) global::CppSharp.Parser.AST.DeclarationContext.NativeToManagedMap[((global::CppSharp.Parser.AST.Declaration.__Internal*) __Instance)->_namespace];
                        else __result0 = global::CppSharp.Parser.AST.DeclarationContext.__CreateInstance(((global::CppSharp.Parser.AST.Declaration.__Internal*) __Instance)->_namespace);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Declaration.__Internal*) __Instance)->_namespace = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.SourceLocation Location
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.Declaration.__Internal*) __Instance)->location);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Declaration.__Internal*) __Instance)->location = value.__Instance;
                    }
                }

                public int LineNumberStart
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Declaration.__Internal*) __Instance)->lineNumberStart;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Declaration.__Internal*) __Instance)->lineNumberStart = value;
                    }
                }

                public int LineNumberEnd
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Declaration.__Internal*) __Instance)->lineNumberEnd;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Declaration.__Internal*) __Instance)->lineNumberEnd = value;
                    }
                }

                public string Name
                {
                    get
                    {
                        var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(((global::CppSharp.Parser.AST.Declaration.__Internal*) __Instance)->name);
                        var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                        __basicStringRet.Dispose(false);
                        return __stringRet;
                    }

                    set
                    {
                        var __allocator0 = new global::Std.Allocator<sbyte>();
                        var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                        ((global::CppSharp.Parser.AST.Declaration.__Internal*) __Instance)->name = *(global::Std.BasicString.__Internal*) __basicString0.__Instance;
                    }
                }

                public string USR
                {
                    get
                    {
                        var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(((global::CppSharp.Parser.AST.Declaration.__Internal*) __Instance)->USR);
                        var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                        __basicStringRet.Dispose(false);
                        return __stringRet;
                    }

                    set
                    {
                        var __allocator0 = new global::Std.Allocator<sbyte>();
                        var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                        ((global::CppSharp.Parser.AST.Declaration.__Internal*) __Instance)->USR = *(global::Std.BasicString.__Internal*) __basicString0.__Instance;
                    }
                }

                public string DebugText
                {
                    get
                    {
                        var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(((global::CppSharp.Parser.AST.Declaration.__Internal*) __Instance)->debugText);
                        var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                        __basicStringRet.Dispose(false);
                        return __stringRet;
                    }

                    set
                    {
                        var __allocator0 = new global::Std.Allocator<sbyte>();
                        var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                        ((global::CppSharp.Parser.AST.Declaration.__Internal*) __Instance)->debugText = *(global::Std.BasicString.__Internal*) __basicString0.__Instance;
                    }
                }

                public bool IsIncomplete
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Declaration.__Internal*) __Instance)->isIncomplete != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Declaration.__Internal*) __Instance)->isIncomplete = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsDependent
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Declaration.__Internal*) __Instance)->isDependent != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Declaration.__Internal*) __Instance)->isDependent = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsImplicit
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Declaration.__Internal*) __Instance)->isImplicit != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Declaration.__Internal*) __Instance)->isImplicit = (byte) (value ? 1 : 0);
                    }
                }

                public global::CppSharp.Parser.AST.Declaration CompleteDeclaration
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Declaration __result0;
                        if (((global::CppSharp.Parser.AST.Declaration.__Internal*) __Instance)->completeDeclaration == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Declaration.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.Declaration.__Internal*) __Instance)->completeDeclaration))
                            __result0 = (global::CppSharp.Parser.AST.Declaration) global::CppSharp.Parser.AST.Declaration.NativeToManagedMap[((global::CppSharp.Parser.AST.Declaration.__Internal*) __Instance)->completeDeclaration];
                        else __result0 = global::CppSharp.Parser.AST.Declaration.__CreateInstance(((global::CppSharp.Parser.AST.Declaration.__Internal*) __Instance)->completeDeclaration);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Declaration.__Internal*) __Instance)->completeDeclaration = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public uint DefinitionOrder
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Declaration.__Internal*) __Instance)->definitionOrder;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Declaration.__Internal*) __Instance)->definitionOrder = value;
                    }
                }

                public global::System.IntPtr OriginalPtr
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Declaration.__Internal*) __Instance)->originalPtr;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Declaration.__Internal*) __Instance)->originalPtr = (global::System.IntPtr) value;
                    }
                }

                public global::CppSharp.Parser.AST.RawComment Comment
                {
                    get
                    {
                        global::CppSharp.Parser.AST.RawComment __result0;
                        if (((global::CppSharp.Parser.AST.Declaration.__Internal*) __Instance)->comment == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.RawComment.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.Declaration.__Internal*) __Instance)->comment))
                            __result0 = (global::CppSharp.Parser.AST.RawComment) global::CppSharp.Parser.AST.RawComment.NativeToManagedMap[((global::CppSharp.Parser.AST.Declaration.__Internal*) __Instance)->comment];
                        else __result0 = global::CppSharp.Parser.AST.RawComment.__CreateInstance(((global::CppSharp.Parser.AST.Declaration.__Internal*) __Instance)->comment);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Declaration.__Internal*) __Instance)->comment = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public uint PreprocessedEntitiesCount
                {
                    get
                    {
                        var __ret = __Internal.GetPreprocessedEntitiesCount((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                public uint RedeclarationsCount
                {
                    get
                    {
                        var __ret = __Internal.GetRedeclarationsCount((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }
            }

            public unsafe partial class DeclarationContext : global::CppSharp.Parser.AST.Declaration, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 464)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.DeclarationKind kind;

                    [FieldOffset(4)]
                    internal int maxFieldAlignment;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.AccessSpecifier access;

                    [FieldOffset(16)]
                    internal global::System.IntPtr _namespace;

                    [FieldOffset(24)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal location;

                    [FieldOffset(28)]
                    internal int lineNumberStart;

                    [FieldOffset(32)]
                    internal int lineNumberEnd;

                    [FieldOffset(40)]
                    internal global::Std.BasicString.__Internal name;

                    [FieldOffset(72)]
                    internal global::Std.BasicString.__Internal USR;

                    [FieldOffset(104)]
                    internal global::Std.BasicString.__Internal debugText;

                    [FieldOffset(136)]
                    internal byte isIncomplete;

                    [FieldOffset(137)]
                    internal byte isDependent;

                    [FieldOffset(138)]
                    internal byte isImplicit;

                    [FieldOffset(144)]
                    internal global::System.IntPtr completeDeclaration;

                    [FieldOffset(152)]
                    internal uint definitionOrder;

                    [FieldOffset(160)]
                    internal global::Std.Vector.__Internal PreprocessedEntities;

                    [FieldOffset(184)]
                    internal global::Std.Vector.__Internal Redeclarations;

                    [FieldOffset(208)]
                    internal global::System.IntPtr originalPtr;

                    [FieldOffset(216)]
                    internal global::System.IntPtr comment;

                    [FieldOffset(224)]
                    internal global::Std.Vector.__Internal Namespaces;

                    [FieldOffset(248)]
                    internal global::Std.Vector.__Internal Enums;

                    [FieldOffset(272)]
                    internal global::Std.Vector.__Internal Functions;

                    [FieldOffset(296)]
                    internal global::Std.Vector.__Internal Classes;

                    [FieldOffset(320)]
                    internal global::Std.Vector.__Internal Templates;

                    [FieldOffset(344)]
                    internal global::Std.Vector.__Internal Typedefs;

                    [FieldOffset(368)]
                    internal global::Std.Vector.__Internal TypeAliases;

                    [FieldOffset(392)]
                    internal global::Std.Vector.__Internal Variables;

                    [FieldOffset(416)]
                    internal global::Std.Vector.__Internal Friends;

                    [FieldOffset(440)]
                    internal global::Std.Map.__Internal anonymous;

                    [FieldOffset(456)]
                    internal byte isAnonymous;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0DeclarationContext@AST@CppParser@CppSharp@@QEAA@W4DeclarationKind@123@@Z")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::CppSharp.Parser.AST.DeclarationKind kind);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0DeclarationContext@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1DeclarationContext@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor(global::System.IntPtr instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getNamespaces@DeclarationContext@AST@CppParser@CppSharp@@QEAAPEAVNamespace@234@I@Z")]
                    internal static extern global::System.IntPtr GetNamespaces(global::System.IntPtr instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?addNamespaces@DeclarationContext@AST@CppParser@CppSharp@@QEAAXAEAPEAVNamespace@234@@Z")]
                    internal static extern void AddNamespaces(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?clearNamespaces@DeclarationContext@AST@CppParser@CppSharp@@QEAAXXZ")]
                    internal static extern void ClearNamespaces(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getEnums@DeclarationContext@AST@CppParser@CppSharp@@QEAAPEAVEnumeration@234@I@Z")]
                    internal static extern global::System.IntPtr GetEnums(global::System.IntPtr instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?addEnums@DeclarationContext@AST@CppParser@CppSharp@@QEAAXAEAPEAVEnumeration@234@@Z")]
                    internal static extern void AddEnums(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?clearEnums@DeclarationContext@AST@CppParser@CppSharp@@QEAAXXZ")]
                    internal static extern void ClearEnums(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getFunctions@DeclarationContext@AST@CppParser@CppSharp@@QEAAPEAVFunction@234@I@Z")]
                    internal static extern global::System.IntPtr GetFunctions(global::System.IntPtr instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?addFunctions@DeclarationContext@AST@CppParser@CppSharp@@QEAAXAEAPEAVFunction@234@@Z")]
                    internal static extern void AddFunctions(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?clearFunctions@DeclarationContext@AST@CppParser@CppSharp@@QEAAXXZ")]
                    internal static extern void ClearFunctions(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getClasses@DeclarationContext@AST@CppParser@CppSharp@@QEAAPEAVClass@234@I@Z")]
                    internal static extern global::System.IntPtr GetClasses(global::System.IntPtr instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?addClasses@DeclarationContext@AST@CppParser@CppSharp@@QEAAXAEAPEAVClass@234@@Z")]
                    internal static extern void AddClasses(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?clearClasses@DeclarationContext@AST@CppParser@CppSharp@@QEAAXXZ")]
                    internal static extern void ClearClasses(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getTemplates@DeclarationContext@AST@CppParser@CppSharp@@QEAAPEAVTemplate@234@I@Z")]
                    internal static extern global::System.IntPtr GetTemplates(global::System.IntPtr instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?addTemplates@DeclarationContext@AST@CppParser@CppSharp@@QEAAXAEAPEAVTemplate@234@@Z")]
                    internal static extern void AddTemplates(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?clearTemplates@DeclarationContext@AST@CppParser@CppSharp@@QEAAXXZ")]
                    internal static extern void ClearTemplates(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getTypedefs@DeclarationContext@AST@CppParser@CppSharp@@QEAAPEAVTypedefDecl@234@I@Z")]
                    internal static extern global::System.IntPtr GetTypedefs(global::System.IntPtr instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?addTypedefs@DeclarationContext@AST@CppParser@CppSharp@@QEAAXAEAPEAVTypedefDecl@234@@Z")]
                    internal static extern void AddTypedefs(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?clearTypedefs@DeclarationContext@AST@CppParser@CppSharp@@QEAAXXZ")]
                    internal static extern void ClearTypedefs(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getTypeAliases@DeclarationContext@AST@CppParser@CppSharp@@QEAAPEAVTypeAlias@234@I@Z")]
                    internal static extern global::System.IntPtr GetTypeAliases(global::System.IntPtr instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?addTypeAliases@DeclarationContext@AST@CppParser@CppSharp@@QEAAXAEAPEAVTypeAlias@234@@Z")]
                    internal static extern void AddTypeAliases(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?clearTypeAliases@DeclarationContext@AST@CppParser@CppSharp@@QEAAXXZ")]
                    internal static extern void ClearTypeAliases(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getVariables@DeclarationContext@AST@CppParser@CppSharp@@QEAAPEAVVariable@234@I@Z")]
                    internal static extern global::System.IntPtr GetVariables(global::System.IntPtr instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?addVariables@DeclarationContext@AST@CppParser@CppSharp@@QEAAXAEAPEAVVariable@234@@Z")]
                    internal static extern void AddVariables(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?clearVariables@DeclarationContext@AST@CppParser@CppSharp@@QEAAXXZ")]
                    internal static extern void ClearVariables(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getFriends@DeclarationContext@AST@CppParser@CppSharp@@QEAAPEAVFriend@234@I@Z")]
                    internal static extern global::System.IntPtr GetFriends(global::System.IntPtr instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?addFriends@DeclarationContext@AST@CppParser@CppSharp@@QEAAXAEAPEAVFriend@234@@Z")]
                    internal static extern void AddFriends(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?clearFriends@DeclarationContext@AST@CppParser@CppSharp@@QEAAXXZ")]
                    internal static extern void ClearFriends(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getNamespacesCount@DeclarationContext@AST@CppParser@CppSharp@@QEAAIXZ")]
                    internal static extern uint GetNamespacesCount(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getEnumsCount@DeclarationContext@AST@CppParser@CppSharp@@QEAAIXZ")]
                    internal static extern uint GetEnumsCount(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getFunctionsCount@DeclarationContext@AST@CppParser@CppSharp@@QEAAIXZ")]
                    internal static extern uint GetFunctionsCount(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getClassesCount@DeclarationContext@AST@CppParser@CppSharp@@QEAAIXZ")]
                    internal static extern uint GetClassesCount(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getTemplatesCount@DeclarationContext@AST@CppParser@CppSharp@@QEAAIXZ")]
                    internal static extern uint GetTemplatesCount(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getTypedefsCount@DeclarationContext@AST@CppParser@CppSharp@@QEAAIXZ")]
                    internal static extern uint GetTypedefsCount(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getTypeAliasesCount@DeclarationContext@AST@CppParser@CppSharp@@QEAAIXZ")]
                    internal static extern uint GetTypeAliasesCount(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getVariablesCount@DeclarationContext@AST@CppParser@CppSharp@@QEAAIXZ")]
                    internal static extern uint GetVariablesCount(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getFriendsCount@DeclarationContext@AST@CppParser@CppSharp@@QEAAIXZ")]
                    internal static extern uint GetFriendsCount(global::System.IntPtr instance);
                }

                internal static new global::CppSharp.Parser.AST.DeclarationContext __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.DeclarationContext(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.DeclarationContext __CreateInstance(global::CppSharp.Parser.AST.DeclarationContext.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.DeclarationContext(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.DeclarationContext.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.DeclarationContext.__Internal));
                    global::CppSharp.Parser.AST.DeclarationContext.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private DeclarationContext(global::CppSharp.Parser.AST.DeclarationContext.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected DeclarationContext(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public DeclarationContext(global::CppSharp.Parser.AST.DeclarationKind kind)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.DeclarationContext.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment), kind);
                }

                public DeclarationContext(global::CppSharp.Parser.AST.DeclarationContext _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.DeclarationContext.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Declaration __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.Namespace GetNamespaces(uint i)
                {
                    var __ret = __Internal.GetNamespaces((__Instance + __PointerAdjustment), i);
                    global::CppSharp.Parser.AST.Namespace __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.Namespace.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::CppSharp.Parser.AST.Namespace) global::CppSharp.Parser.AST.Namespace.NativeToManagedMap[__ret];
                    else __result0 = global::CppSharp.Parser.AST.Namespace.__CreateInstance(__ret);
                    return __result0;
                }

                public void AddNamespaces(global::CppSharp.Parser.AST.Namespace s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    __Internal.AddNamespaces((__Instance + __PointerAdjustment), __arg0);
                }

                public void ClearNamespaces()
                {
                    __Internal.ClearNamespaces((__Instance + __PointerAdjustment));
                }

                public global::CppSharp.Parser.AST.Enumeration GetEnums(uint i)
                {
                    var __ret = __Internal.GetEnums((__Instance + __PointerAdjustment), i);
                    global::CppSharp.Parser.AST.Enumeration __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.Enumeration.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::CppSharp.Parser.AST.Enumeration) global::CppSharp.Parser.AST.Enumeration.NativeToManagedMap[__ret];
                    else __result0 = global::CppSharp.Parser.AST.Enumeration.__CreateInstance(__ret);
                    return __result0;
                }

                public void AddEnums(global::CppSharp.Parser.AST.Enumeration s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    __Internal.AddEnums((__Instance + __PointerAdjustment), __arg0);
                }

                public void ClearEnums()
                {
                    __Internal.ClearEnums((__Instance + __PointerAdjustment));
                }

                public global::CppSharp.Parser.AST.Function GetFunctions(uint i)
                {
                    var __ret = __Internal.GetFunctions((__Instance + __PointerAdjustment), i);
                    global::CppSharp.Parser.AST.Function __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.Function.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::CppSharp.Parser.AST.Function) global::CppSharp.Parser.AST.Function.NativeToManagedMap[__ret];
                    else __result0 = global::CppSharp.Parser.AST.Function.__CreateInstance(__ret);
                    return __result0;
                }

                public void AddFunctions(global::CppSharp.Parser.AST.Function s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    __Internal.AddFunctions((__Instance + __PointerAdjustment), __arg0);
                }

                public void ClearFunctions()
                {
                    __Internal.ClearFunctions((__Instance + __PointerAdjustment));
                }

                public global::CppSharp.Parser.AST.Class GetClasses(uint i)
                {
                    var __ret = __Internal.GetClasses((__Instance + __PointerAdjustment), i);
                    global::CppSharp.Parser.AST.Class __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.Class.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::CppSharp.Parser.AST.Class) global::CppSharp.Parser.AST.Class.NativeToManagedMap[__ret];
                    else __result0 = global::CppSharp.Parser.AST.Class.__CreateInstance(__ret);
                    return __result0;
                }

                public void AddClasses(global::CppSharp.Parser.AST.Class s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    __Internal.AddClasses((__Instance + __PointerAdjustment), __arg0);
                }

                public void ClearClasses()
                {
                    __Internal.ClearClasses((__Instance + __PointerAdjustment));
                }

                public global::CppSharp.Parser.AST.Template GetTemplates(uint i)
                {
                    var __ret = __Internal.GetTemplates((__Instance + __PointerAdjustment), i);
                    global::CppSharp.Parser.AST.Template __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.Template.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::CppSharp.Parser.AST.Template) global::CppSharp.Parser.AST.Template.NativeToManagedMap[__ret];
                    else __result0 = global::CppSharp.Parser.AST.Template.__CreateInstance(__ret);
                    return __result0;
                }

                public void AddTemplates(global::CppSharp.Parser.AST.Template s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    __Internal.AddTemplates((__Instance + __PointerAdjustment), __arg0);
                }

                public void ClearTemplates()
                {
                    __Internal.ClearTemplates((__Instance + __PointerAdjustment));
                }

                public global::CppSharp.Parser.AST.TypedefDecl GetTypedefs(uint i)
                {
                    var __ret = __Internal.GetTypedefs((__Instance + __PointerAdjustment), i);
                    global::CppSharp.Parser.AST.TypedefDecl __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.TypedefDecl.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::CppSharp.Parser.AST.TypedefDecl) global::CppSharp.Parser.AST.TypedefDecl.NativeToManagedMap[__ret];
                    else __result0 = global::CppSharp.Parser.AST.TypedefDecl.__CreateInstance(__ret);
                    return __result0;
                }

                public void AddTypedefs(global::CppSharp.Parser.AST.TypedefDecl s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    __Internal.AddTypedefs((__Instance + __PointerAdjustment), __arg0);
                }

                public void ClearTypedefs()
                {
                    __Internal.ClearTypedefs((__Instance + __PointerAdjustment));
                }

                public global::CppSharp.Parser.AST.TypeAlias GetTypeAliases(uint i)
                {
                    var __ret = __Internal.GetTypeAliases((__Instance + __PointerAdjustment), i);
                    global::CppSharp.Parser.AST.TypeAlias __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.TypeAlias.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::CppSharp.Parser.AST.TypeAlias) global::CppSharp.Parser.AST.TypeAlias.NativeToManagedMap[__ret];
                    else __result0 = global::CppSharp.Parser.AST.TypeAlias.__CreateInstance(__ret);
                    return __result0;
                }

                public void AddTypeAliases(global::CppSharp.Parser.AST.TypeAlias s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    __Internal.AddTypeAliases((__Instance + __PointerAdjustment), __arg0);
                }

                public void ClearTypeAliases()
                {
                    __Internal.ClearTypeAliases((__Instance + __PointerAdjustment));
                }

                public global::CppSharp.Parser.AST.Variable GetVariables(uint i)
                {
                    var __ret = __Internal.GetVariables((__Instance + __PointerAdjustment), i);
                    global::CppSharp.Parser.AST.Variable __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.Variable.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::CppSharp.Parser.AST.Variable) global::CppSharp.Parser.AST.Variable.NativeToManagedMap[__ret];
                    else __result0 = global::CppSharp.Parser.AST.Variable.__CreateInstance(__ret);
                    return __result0;
                }

                public void AddVariables(global::CppSharp.Parser.AST.Variable s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    __Internal.AddVariables((__Instance + __PointerAdjustment), __arg0);
                }

                public void ClearVariables()
                {
                    __Internal.ClearVariables((__Instance + __PointerAdjustment));
                }

                public global::CppSharp.Parser.AST.Friend GetFriends(uint i)
                {
                    var __ret = __Internal.GetFriends((__Instance + __PointerAdjustment), i);
                    global::CppSharp.Parser.AST.Friend __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.Friend.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::CppSharp.Parser.AST.Friend) global::CppSharp.Parser.AST.Friend.NativeToManagedMap[__ret];
                    else __result0 = global::CppSharp.Parser.AST.Friend.__CreateInstance(__ret);
                    return __result0;
                }

                public void AddFriends(global::CppSharp.Parser.AST.Friend s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    __Internal.AddFriends((__Instance + __PointerAdjustment), __arg0);
                }

                public void ClearFriends()
                {
                    __Internal.ClearFriends((__Instance + __PointerAdjustment));
                }

                public static implicit operator global::CppSharp.Parser.AST.DeclarationContext(global::CppSharp.Parser.AST.DeclarationKind kind)
                {
                    return new global::CppSharp.Parser.AST.DeclarationContext(kind);
                }

                public bool IsAnonymous
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.DeclarationContext.__Internal*) __Instance)->isAnonymous != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.DeclarationContext.__Internal*) __Instance)->isAnonymous = (byte) (value ? 1 : 0);
                    }
                }

                public uint NamespacesCount
                {
                    get
                    {
                        var __ret = __Internal.GetNamespacesCount((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                public uint EnumsCount
                {
                    get
                    {
                        var __ret = __Internal.GetEnumsCount((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                public uint FunctionsCount
                {
                    get
                    {
                        var __ret = __Internal.GetFunctionsCount((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                public uint ClassesCount
                {
                    get
                    {
                        var __ret = __Internal.GetClassesCount((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                public uint TemplatesCount
                {
                    get
                    {
                        var __ret = __Internal.GetTemplatesCount((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                public uint TypedefsCount
                {
                    get
                    {
                        var __ret = __Internal.GetTypedefsCount((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                public uint TypeAliasesCount
                {
                    get
                    {
                        var __ret = __Internal.GetTypeAliasesCount((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                public uint VariablesCount
                {
                    get
                    {
                        var __ret = __Internal.GetVariablesCount((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                public uint FriendsCount
                {
                    get
                    {
                        var __ret = __Internal.GetFriendsCount((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }
            }

            public unsafe partial class TypedefNameDecl : global::CppSharp.Parser.AST.Declaration, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 240)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.DeclarationKind kind;

                    [FieldOffset(4)]
                    internal int maxFieldAlignment;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.AccessSpecifier access;

                    [FieldOffset(16)]
                    internal global::System.IntPtr _namespace;

                    [FieldOffset(24)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal location;

                    [FieldOffset(28)]
                    internal int lineNumberStart;

                    [FieldOffset(32)]
                    internal int lineNumberEnd;

                    [FieldOffset(40)]
                    internal global::Std.BasicString.__Internal name;

                    [FieldOffset(72)]
                    internal global::Std.BasicString.__Internal USR;

                    [FieldOffset(104)]
                    internal global::Std.BasicString.__Internal debugText;

                    [FieldOffset(136)]
                    internal byte isIncomplete;

                    [FieldOffset(137)]
                    internal byte isDependent;

                    [FieldOffset(138)]
                    internal byte isImplicit;

                    [FieldOffset(144)]
                    internal global::System.IntPtr completeDeclaration;

                    [FieldOffset(152)]
                    internal uint definitionOrder;

                    [FieldOffset(160)]
                    internal global::Std.Vector.__Internal PreprocessedEntities;

                    [FieldOffset(184)]
                    internal global::Std.Vector.__Internal Redeclarations;

                    [FieldOffset(208)]
                    internal global::System.IntPtr originalPtr;

                    [FieldOffset(216)]
                    internal global::System.IntPtr comment;

                    [FieldOffset(224)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal qualifiedType;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0TypedefNameDecl@AST@CppParser@CppSharp@@QEAA@W4DeclarationKind@123@@Z")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::CppSharp.Parser.AST.DeclarationKind kind);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0TypedefNameDecl@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1TypedefNameDecl@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor(global::System.IntPtr instance, int delete);
                }

                internal static new global::CppSharp.Parser.AST.TypedefNameDecl __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.TypedefNameDecl(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.TypedefNameDecl __CreateInstance(global::CppSharp.Parser.AST.TypedefNameDecl.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.TypedefNameDecl(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.TypedefNameDecl.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TypedefNameDecl.__Internal));
                    global::CppSharp.Parser.AST.TypedefNameDecl.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private TypedefNameDecl(global::CppSharp.Parser.AST.TypedefNameDecl.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected TypedefNameDecl(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public TypedefNameDecl(global::CppSharp.Parser.AST.DeclarationKind kind)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TypedefNameDecl.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment), kind);
                }

                public TypedefNameDecl(global::CppSharp.Parser.AST.TypedefNameDecl _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TypedefNameDecl.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Declaration __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public static implicit operator global::CppSharp.Parser.AST.TypedefNameDecl(global::CppSharp.Parser.AST.DeclarationKind kind)
                {
                    return new global::CppSharp.Parser.AST.TypedefNameDecl(kind);
                }

                public global::CppSharp.Parser.AST.QualifiedType QualifiedType
                {
                    get
                    {
                        return global::CppSharp.Parser.AST.QualifiedType.__CreateInstance(((global::CppSharp.Parser.AST.TypedefNameDecl.__Internal*) __Instance)->qualifiedType);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.TypedefNameDecl.__Internal*) __Instance)->qualifiedType = ReferenceEquals(value, null) ? new global::CppSharp.Parser.AST.QualifiedType.__Internal() : *(global::CppSharp.Parser.AST.QualifiedType.__Internal*) value.__Instance;
                    }
                }
            }

            public unsafe partial class TypedefDecl : global::CppSharp.Parser.AST.TypedefNameDecl, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 240)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.DeclarationKind kind;

                    [FieldOffset(4)]
                    internal int maxFieldAlignment;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.AccessSpecifier access;

                    [FieldOffset(16)]
                    internal global::System.IntPtr _namespace;

                    [FieldOffset(24)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal location;

                    [FieldOffset(28)]
                    internal int lineNumberStart;

                    [FieldOffset(32)]
                    internal int lineNumberEnd;

                    [FieldOffset(40)]
                    internal global::Std.BasicString.__Internal name;

                    [FieldOffset(72)]
                    internal global::Std.BasicString.__Internal USR;

                    [FieldOffset(104)]
                    internal global::Std.BasicString.__Internal debugText;

                    [FieldOffset(136)]
                    internal byte isIncomplete;

                    [FieldOffset(137)]
                    internal byte isDependent;

                    [FieldOffset(138)]
                    internal byte isImplicit;

                    [FieldOffset(144)]
                    internal global::System.IntPtr completeDeclaration;

                    [FieldOffset(152)]
                    internal uint definitionOrder;

                    [FieldOffset(160)]
                    internal global::Std.Vector.__Internal PreprocessedEntities;

                    [FieldOffset(184)]
                    internal global::Std.Vector.__Internal Redeclarations;

                    [FieldOffset(208)]
                    internal global::System.IntPtr originalPtr;

                    [FieldOffset(216)]
                    internal global::System.IntPtr comment;

                    [FieldOffset(224)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal qualifiedType;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0TypedefDecl@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0TypedefDecl@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1TypedefDecl@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor(global::System.IntPtr instance, int delete);
                }

                internal static new global::CppSharp.Parser.AST.TypedefDecl __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.TypedefDecl(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.TypedefDecl __CreateInstance(global::CppSharp.Parser.AST.TypedefDecl.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.TypedefDecl(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.TypedefDecl.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TypedefDecl.__Internal));
                    global::CppSharp.Parser.AST.TypedefDecl.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private TypedefDecl(global::CppSharp.Parser.AST.TypedefDecl.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected TypedefDecl(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public TypedefDecl()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TypedefDecl.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment));
                }

                public TypedefDecl(global::CppSharp.Parser.AST.TypedefDecl _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TypedefDecl.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Declaration __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }
            }

            public unsafe partial class TypeAlias : global::CppSharp.Parser.AST.TypedefNameDecl, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 248)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.DeclarationKind kind;

                    [FieldOffset(4)]
                    internal int maxFieldAlignment;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.AccessSpecifier access;

                    [FieldOffset(16)]
                    internal global::System.IntPtr _namespace;

                    [FieldOffset(24)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal location;

                    [FieldOffset(28)]
                    internal int lineNumberStart;

                    [FieldOffset(32)]
                    internal int lineNumberEnd;

                    [FieldOffset(40)]
                    internal global::Std.BasicString.__Internal name;

                    [FieldOffset(72)]
                    internal global::Std.BasicString.__Internal USR;

                    [FieldOffset(104)]
                    internal global::Std.BasicString.__Internal debugText;

                    [FieldOffset(136)]
                    internal byte isIncomplete;

                    [FieldOffset(137)]
                    internal byte isDependent;

                    [FieldOffset(138)]
                    internal byte isImplicit;

                    [FieldOffset(144)]
                    internal global::System.IntPtr completeDeclaration;

                    [FieldOffset(152)]
                    internal uint definitionOrder;

                    [FieldOffset(160)]
                    internal global::Std.Vector.__Internal PreprocessedEntities;

                    [FieldOffset(184)]
                    internal global::Std.Vector.__Internal Redeclarations;

                    [FieldOffset(208)]
                    internal global::System.IntPtr originalPtr;

                    [FieldOffset(216)]
                    internal global::System.IntPtr comment;

                    [FieldOffset(224)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal qualifiedType;

                    [FieldOffset(240)]
                    internal global::System.IntPtr describedAliasTemplate;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0TypeAlias@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0TypeAlias@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1TypeAlias@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor(global::System.IntPtr instance, int delete);
                }

                internal static new global::CppSharp.Parser.AST.TypeAlias __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.TypeAlias(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.TypeAlias __CreateInstance(global::CppSharp.Parser.AST.TypeAlias.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.TypeAlias(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.TypeAlias.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TypeAlias.__Internal));
                    global::CppSharp.Parser.AST.TypeAlias.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private TypeAlias(global::CppSharp.Parser.AST.TypeAlias.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected TypeAlias(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public TypeAlias()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TypeAlias.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment));
                }

                public TypeAlias(global::CppSharp.Parser.AST.TypeAlias _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TypeAlias.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Declaration __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.TypeAliasTemplate DescribedAliasTemplate
                {
                    get
                    {
                        global::CppSharp.Parser.AST.TypeAliasTemplate __result0;
                        if (((global::CppSharp.Parser.AST.TypeAlias.__Internal*) __Instance)->describedAliasTemplate == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.TypeAliasTemplate.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.TypeAlias.__Internal*) __Instance)->describedAliasTemplate))
                            __result0 = (global::CppSharp.Parser.AST.TypeAliasTemplate) global::CppSharp.Parser.AST.TypeAliasTemplate.NativeToManagedMap[((global::CppSharp.Parser.AST.TypeAlias.__Internal*) __Instance)->describedAliasTemplate];
                        else __result0 = global::CppSharp.Parser.AST.TypeAliasTemplate.__CreateInstance(((global::CppSharp.Parser.AST.TypeAlias.__Internal*) __Instance)->describedAliasTemplate);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.TypeAlias.__Internal*) __Instance)->describedAliasTemplate = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }
            }

            public unsafe partial class Friend : global::CppSharp.Parser.AST.Declaration, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 232)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.DeclarationKind kind;

                    [FieldOffset(4)]
                    internal int maxFieldAlignment;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.AccessSpecifier access;

                    [FieldOffset(16)]
                    internal global::System.IntPtr _namespace;

                    [FieldOffset(24)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal location;

                    [FieldOffset(28)]
                    internal int lineNumberStart;

                    [FieldOffset(32)]
                    internal int lineNumberEnd;

                    [FieldOffset(40)]
                    internal global::Std.BasicString.__Internal name;

                    [FieldOffset(72)]
                    internal global::Std.BasicString.__Internal USR;

                    [FieldOffset(104)]
                    internal global::Std.BasicString.__Internal debugText;

                    [FieldOffset(136)]
                    internal byte isIncomplete;

                    [FieldOffset(137)]
                    internal byte isDependent;

                    [FieldOffset(138)]
                    internal byte isImplicit;

                    [FieldOffset(144)]
                    internal global::System.IntPtr completeDeclaration;

                    [FieldOffset(152)]
                    internal uint definitionOrder;

                    [FieldOffset(160)]
                    internal global::Std.Vector.__Internal PreprocessedEntities;

                    [FieldOffset(184)]
                    internal global::Std.Vector.__Internal Redeclarations;

                    [FieldOffset(208)]
                    internal global::System.IntPtr originalPtr;

                    [FieldOffset(216)]
                    internal global::System.IntPtr comment;

                    [FieldOffset(224)]
                    internal global::System.IntPtr declaration;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0Friend@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0Friend@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1Friend@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor(global::System.IntPtr instance, int delete);
                }

                internal static new global::CppSharp.Parser.AST.Friend __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.Friend(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.Friend __CreateInstance(global::CppSharp.Parser.AST.Friend.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.Friend(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.Friend.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Friend.__Internal));
                    global::CppSharp.Parser.AST.Friend.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private Friend(global::CppSharp.Parser.AST.Friend.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected Friend(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public Friend()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Friend.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment));
                }

                public Friend(global::CppSharp.Parser.AST.Friend _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Friend.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Declaration __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.Declaration Declaration
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Declaration __result0;
                        if (((global::CppSharp.Parser.AST.Friend.__Internal*) __Instance)->declaration == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Declaration.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.Friend.__Internal*) __Instance)->declaration))
                            __result0 = (global::CppSharp.Parser.AST.Declaration) global::CppSharp.Parser.AST.Declaration.NativeToManagedMap[((global::CppSharp.Parser.AST.Friend.__Internal*) __Instance)->declaration];
                        else __result0 = global::CppSharp.Parser.AST.Declaration.__CreateInstance(((global::CppSharp.Parser.AST.Friend.__Internal*) __Instance)->declaration);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Friend.__Internal*) __Instance)->declaration = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }
            }

            public unsafe partial class Statement : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 48)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StatementClass _class;

                    [FieldOffset(8)]
                    internal global::System.IntPtr decl;

                    [FieldOffset(16)]
                    internal global::Std.BasicString.__Internal @string;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0Statement@AST@CppParser@CppSharp@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4StatementClass@123@PEAVDeclaration@123@@Z")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr str, global::CppSharp.Parser.AST.StatementClass Class, global::System.IntPtr decl);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0Statement@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1Statement@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor(global::System.IntPtr instance, int delete);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                protected int __PointerAdjustment;
                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.Statement> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.Statement>();
                protected void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                internal static global::CppSharp.Parser.AST.Statement __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.Statement(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.Statement __CreateInstance(global::CppSharp.Parser.AST.Statement.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.Statement(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.Statement.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Statement.__Internal));
                    global::CppSharp.Parser.AST.Statement.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private Statement(global::CppSharp.Parser.AST.Statement.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected Statement(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public Statement(string str, global::CppSharp.Parser.AST.StatementClass Class, global::CppSharp.Parser.AST.Declaration decl)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Statement.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    var __allocator0 = new global::Std.Allocator<sbyte>();
                    var __basicString0 = global::Std.BasicStringExtensions.BasicString(str, __allocator0);
                    var __arg0 = __basicString0.__Instance;
                    var __arg2 = ReferenceEquals(decl, null) ? global::System.IntPtr.Zero : decl.__Instance;
                    __Internal.ctor((__Instance + __PointerAdjustment), __arg0, Class, __arg2);
                    __basicString0.Dispose(false);
                    __allocator0.Dispose();
                }

                public Statement(global::CppSharp.Parser.AST.Statement _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Statement.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                public virtual void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Statement __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.StatementClass Class
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Statement.__Internal*) __Instance)->_class;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Statement.__Internal*) __Instance)->_class = value;
                    }
                }

                public global::CppSharp.Parser.AST.Declaration Decl
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Declaration __result0;
                        if (((global::CppSharp.Parser.AST.Statement.__Internal*) __Instance)->decl == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Declaration.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.Statement.__Internal*) __Instance)->decl))
                            __result0 = (global::CppSharp.Parser.AST.Declaration) global::CppSharp.Parser.AST.Declaration.NativeToManagedMap[((global::CppSharp.Parser.AST.Statement.__Internal*) __Instance)->decl];
                        else __result0 = global::CppSharp.Parser.AST.Declaration.__CreateInstance(((global::CppSharp.Parser.AST.Statement.__Internal*) __Instance)->decl);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Statement.__Internal*) __Instance)->decl = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public string String
                {
                    get
                    {
                        var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(((global::CppSharp.Parser.AST.Statement.__Internal*) __Instance)->@string);
                        var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                        __basicStringRet.Dispose(false);
                        return __stringRet;
                    }

                    set
                    {
                        var __allocator0 = new global::Std.Allocator<sbyte>();
                        var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                        ((global::CppSharp.Parser.AST.Statement.__Internal*) __Instance)->@string = *(global::Std.BasicString.__Internal*) __basicString0.__Instance;
                    }
                }
            }

            public unsafe partial class Expression : global::CppSharp.Parser.AST.Statement, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 48)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StatementClass _class;

                    [FieldOffset(8)]
                    internal global::System.IntPtr decl;

                    [FieldOffset(16)]
                    internal global::Std.BasicString.__Internal @string;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0Expression@AST@CppParser@CppSharp@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4StatementClass@123@PEAVDeclaration@123@@Z")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr str, global::CppSharp.Parser.AST.StatementClass Class, global::System.IntPtr decl);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0Expression@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1Expression@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor(global::System.IntPtr instance, int delete);
                }

                internal static new global::CppSharp.Parser.AST.Expression __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.Expression(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.Expression __CreateInstance(global::CppSharp.Parser.AST.Expression.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.Expression(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.Expression.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Expression.__Internal));
                    global::CppSharp.Parser.AST.Expression.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private Expression(global::CppSharp.Parser.AST.Expression.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected Expression(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public Expression(string str, global::CppSharp.Parser.AST.StatementClass Class, global::CppSharp.Parser.AST.Declaration decl)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Expression.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    var __allocator0 = new global::Std.Allocator<sbyte>();
                    var __basicString0 = global::Std.BasicStringExtensions.BasicString(str, __allocator0);
                    var __arg0 = __basicString0.__Instance;
                    var __arg2 = ReferenceEquals(decl, null) ? global::System.IntPtr.Zero : decl.__Instance;
                    __Internal.ctor((__Instance + __PointerAdjustment), __arg0, Class, __arg2);
                    __basicString0.Dispose(false);
                    __allocator0.Dispose();
                }

                public Expression(global::CppSharp.Parser.AST.Expression _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Expression.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Statement __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }
            }

            public unsafe partial class BinaryOperator : global::CppSharp.Parser.AST.Expression, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 96)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StatementClass _class;

                    [FieldOffset(8)]
                    internal global::System.IntPtr decl;

                    [FieldOffset(16)]
                    internal global::Std.BasicString.__Internal @string;

                    [FieldOffset(48)]
                    internal global::System.IntPtr LHS;

                    [FieldOffset(56)]
                    internal global::System.IntPtr RHS;

                    [FieldOffset(64)]
                    internal global::Std.BasicString.__Internal opcodeStr;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0BinaryOperator@AST@CppParser@CppSharp@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAVExpression@123@10@Z")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr str, global::System.IntPtr lhs, global::System.IntPtr rhs, global::System.IntPtr opcodeStr);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0BinaryOperator@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1BinaryOperator@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor(global::System.IntPtr instance, int delete);
                }

                internal static new global::CppSharp.Parser.AST.BinaryOperator __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.BinaryOperator(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.BinaryOperator __CreateInstance(global::CppSharp.Parser.AST.BinaryOperator.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.BinaryOperator(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.BinaryOperator.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.BinaryOperator.__Internal));
                    global::CppSharp.Parser.AST.BinaryOperator.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private BinaryOperator(global::CppSharp.Parser.AST.BinaryOperator.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected BinaryOperator(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public BinaryOperator(string str, global::CppSharp.Parser.AST.Expression lhs, global::CppSharp.Parser.AST.Expression rhs, string opcodeStr)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.BinaryOperator.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    var __allocator0 = new global::Std.Allocator<sbyte>();
                    var __basicString0 = global::Std.BasicStringExtensions.BasicString(str, __allocator0);
                    var __arg0 = __basicString0.__Instance;
                    var __arg1 = ReferenceEquals(lhs, null) ? global::System.IntPtr.Zero : lhs.__Instance;
                    var __arg2 = ReferenceEquals(rhs, null) ? global::System.IntPtr.Zero : rhs.__Instance;
                    var __allocator3 = new global::Std.Allocator<sbyte>();
                    var __basicString3 = global::Std.BasicStringExtensions.BasicString(opcodeStr, __allocator3);
                    var __arg3 = __basicString3.__Instance;
                    __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1, __arg2, __arg3);
                    __basicString0.Dispose(false);
                    __allocator0.Dispose();
                    __basicString3.Dispose(false);
                    __allocator3.Dispose();
                }

                public BinaryOperator(global::CppSharp.Parser.AST.BinaryOperator _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.BinaryOperator.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Statement __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.Expression LHS
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expression __result0;
                        if (((global::CppSharp.Parser.AST.BinaryOperator.__Internal*) __Instance)->LHS == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expression.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.BinaryOperator.__Internal*) __Instance)->LHS))
                            __result0 = (global::CppSharp.Parser.AST.Expression) global::CppSharp.Parser.AST.Expression.NativeToManagedMap[((global::CppSharp.Parser.AST.BinaryOperator.__Internal*) __Instance)->LHS];
                        else __result0 = global::CppSharp.Parser.AST.Expression.__CreateInstance(((global::CppSharp.Parser.AST.BinaryOperator.__Internal*) __Instance)->LHS);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.BinaryOperator.__Internal*) __Instance)->LHS = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Expression RHS
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expression __result0;
                        if (((global::CppSharp.Parser.AST.BinaryOperator.__Internal*) __Instance)->RHS == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expression.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.BinaryOperator.__Internal*) __Instance)->RHS))
                            __result0 = (global::CppSharp.Parser.AST.Expression) global::CppSharp.Parser.AST.Expression.NativeToManagedMap[((global::CppSharp.Parser.AST.BinaryOperator.__Internal*) __Instance)->RHS];
                        else __result0 = global::CppSharp.Parser.AST.Expression.__CreateInstance(((global::CppSharp.Parser.AST.BinaryOperator.__Internal*) __Instance)->RHS);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.BinaryOperator.__Internal*) __Instance)->RHS = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public string OpcodeStr
                {
                    get
                    {
                        var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(((global::CppSharp.Parser.AST.BinaryOperator.__Internal*) __Instance)->opcodeStr);
                        var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                        __basicStringRet.Dispose(false);
                        return __stringRet;
                    }

                    set
                    {
                        var __allocator0 = new global::Std.Allocator<sbyte>();
                        var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                        ((global::CppSharp.Parser.AST.BinaryOperator.__Internal*) __Instance)->opcodeStr = *(global::Std.BasicString.__Internal*) __basicString0.__Instance;
                    }
                }
            }

            public unsafe partial class CallExpr : global::CppSharp.Parser.AST.Expression, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 72)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StatementClass _class;

                    [FieldOffset(8)]
                    internal global::System.IntPtr decl;

                    [FieldOffset(16)]
                    internal global::Std.BasicString.__Internal @string;

                    [FieldOffset(48)]
                    internal global::Std.Vector.__Internal Arguments;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0CallExpr@AST@CppParser@CppSharp@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAVDeclaration@123@@Z")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr str, global::System.IntPtr decl);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0CallExpr@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1CallExpr@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor(global::System.IntPtr instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getArguments@CallExpr@AST@CppParser@CppSharp@@QEAAPEAVExpression@234@I@Z")]
                    internal static extern global::System.IntPtr GetArguments(global::System.IntPtr instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?addArguments@CallExpr@AST@CppParser@CppSharp@@QEAAXAEAPEAVExpression@234@@Z")]
                    internal static extern void AddArguments(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?clearArguments@CallExpr@AST@CppParser@CppSharp@@QEAAXXZ")]
                    internal static extern void ClearArguments(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getArgumentsCount@CallExpr@AST@CppParser@CppSharp@@QEAAIXZ")]
                    internal static extern uint GetArgumentsCount(global::System.IntPtr instance);
                }

                internal static new global::CppSharp.Parser.AST.CallExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CallExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.CallExpr __CreateInstance(global::CppSharp.Parser.AST.CallExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CallExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.CallExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CallExpr.__Internal));
                    global::CppSharp.Parser.AST.CallExpr.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private CallExpr(global::CppSharp.Parser.AST.CallExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected CallExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public CallExpr(string str, global::CppSharp.Parser.AST.Declaration decl)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CallExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    var __allocator0 = new global::Std.Allocator<sbyte>();
                    var __basicString0 = global::Std.BasicStringExtensions.BasicString(str, __allocator0);
                    var __arg0 = __basicString0.__Instance;
                    var __arg1 = ReferenceEquals(decl, null) ? global::System.IntPtr.Zero : decl.__Instance;
                    __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1);
                    __basicString0.Dispose(false);
                    __allocator0.Dispose();
                }

                public CallExpr(global::CppSharp.Parser.AST.CallExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CallExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Statement __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.Expression GetArguments(uint i)
                {
                    var __ret = __Internal.GetArguments((__Instance + __PointerAdjustment), i);
                    global::CppSharp.Parser.AST.Expression __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.Expression.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::CppSharp.Parser.AST.Expression) global::CppSharp.Parser.AST.Expression.NativeToManagedMap[__ret];
                    else __result0 = global::CppSharp.Parser.AST.Expression.__CreateInstance(__ret);
                    return __result0;
                }

                public void AddArguments(global::CppSharp.Parser.AST.Expression s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    __Internal.AddArguments((__Instance + __PointerAdjustment), __arg0);
                }

                public void ClearArguments()
                {
                    __Internal.ClearArguments((__Instance + __PointerAdjustment));
                }

                public uint ArgumentsCount
                {
                    get
                    {
                        var __ret = __Internal.GetArgumentsCount((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }
            }

            public unsafe partial class CXXConstructExpr : global::CppSharp.Parser.AST.Expression, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 72)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StatementClass _class;

                    [FieldOffset(8)]
                    internal global::System.IntPtr decl;

                    [FieldOffset(16)]
                    internal global::Std.BasicString.__Internal @string;

                    [FieldOffset(48)]
                    internal global::Std.Vector.__Internal Arguments;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0CXXConstructExpr@AST@CppParser@CppSharp@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PEAVDeclaration@123@@Z")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::System.IntPtr str, global::System.IntPtr decl);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0CXXConstructExpr@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1CXXConstructExpr@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor(global::System.IntPtr instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getArguments@CXXConstructExpr@AST@CppParser@CppSharp@@QEAAPEAVExpression@234@I@Z")]
                    internal static extern global::System.IntPtr GetArguments(global::System.IntPtr instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?addArguments@CXXConstructExpr@AST@CppParser@CppSharp@@QEAAXAEAPEAVExpression@234@@Z")]
                    internal static extern void AddArguments(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?clearArguments@CXXConstructExpr@AST@CppParser@CppSharp@@QEAAXXZ")]
                    internal static extern void ClearArguments(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getArgumentsCount@CXXConstructExpr@AST@CppParser@CppSharp@@QEAAIXZ")]
                    internal static extern uint GetArgumentsCount(global::System.IntPtr instance);
                }

                internal static new global::CppSharp.Parser.AST.CXXConstructExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CXXConstructExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.CXXConstructExpr __CreateInstance(global::CppSharp.Parser.AST.CXXConstructExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CXXConstructExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.CXXConstructExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXConstructExpr.__Internal));
                    global::CppSharp.Parser.AST.CXXConstructExpr.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private CXXConstructExpr(global::CppSharp.Parser.AST.CXXConstructExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected CXXConstructExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public CXXConstructExpr(string str, global::CppSharp.Parser.AST.Declaration decl)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXConstructExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    var __allocator0 = new global::Std.Allocator<sbyte>();
                    var __basicString0 = global::Std.BasicStringExtensions.BasicString(str, __allocator0);
                    var __arg0 = __basicString0.__Instance;
                    var __arg1 = ReferenceEquals(decl, null) ? global::System.IntPtr.Zero : decl.__Instance;
                    __Internal.ctor((__Instance + __PointerAdjustment), __arg0, __arg1);
                    __basicString0.Dispose(false);
                    __allocator0.Dispose();
                }

                public CXXConstructExpr(global::CppSharp.Parser.AST.CXXConstructExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXConstructExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Statement __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.Expression GetArguments(uint i)
                {
                    var __ret = __Internal.GetArguments((__Instance + __PointerAdjustment), i);
                    global::CppSharp.Parser.AST.Expression __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.Expression.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::CppSharp.Parser.AST.Expression) global::CppSharp.Parser.AST.Expression.NativeToManagedMap[__ret];
                    else __result0 = global::CppSharp.Parser.AST.Expression.__CreateInstance(__ret);
                    return __result0;
                }

                public void AddArguments(global::CppSharp.Parser.AST.Expression s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    __Internal.AddArguments((__Instance + __PointerAdjustment), __arg0);
                }

                public void ClearArguments()
                {
                    __Internal.ClearArguments((__Instance + __PointerAdjustment));
                }

                public uint ArgumentsCount
                {
                    get
                    {
                        var __ret = __Internal.GetArgumentsCount((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }
            }

            public unsafe partial class Parameter : global::CppSharp.Parser.AST.Declaration, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 256)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.DeclarationKind kind;

                    [FieldOffset(4)]
                    internal int maxFieldAlignment;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.AccessSpecifier access;

                    [FieldOffset(16)]
                    internal global::System.IntPtr _namespace;

                    [FieldOffset(24)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal location;

                    [FieldOffset(28)]
                    internal int lineNumberStart;

                    [FieldOffset(32)]
                    internal int lineNumberEnd;

                    [FieldOffset(40)]
                    internal global::Std.BasicString.__Internal name;

                    [FieldOffset(72)]
                    internal global::Std.BasicString.__Internal USR;

                    [FieldOffset(104)]
                    internal global::Std.BasicString.__Internal debugText;

                    [FieldOffset(136)]
                    internal byte isIncomplete;

                    [FieldOffset(137)]
                    internal byte isDependent;

                    [FieldOffset(138)]
                    internal byte isImplicit;

                    [FieldOffset(144)]
                    internal global::System.IntPtr completeDeclaration;

                    [FieldOffset(152)]
                    internal uint definitionOrder;

                    [FieldOffset(160)]
                    internal global::Std.Vector.__Internal PreprocessedEntities;

                    [FieldOffset(184)]
                    internal global::Std.Vector.__Internal Redeclarations;

                    [FieldOffset(208)]
                    internal global::System.IntPtr originalPtr;

                    [FieldOffset(216)]
                    internal global::System.IntPtr comment;

                    [FieldOffset(224)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal qualifiedType;

                    [FieldOffset(240)]
                    internal byte isIndirect;

                    [FieldOffset(241)]
                    internal byte hasDefaultValue;

                    [FieldOffset(244)]
                    internal uint index;

                    [FieldOffset(248)]
                    internal global::System.IntPtr defaultArgument;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0Parameter@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0Parameter@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1Parameter@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor(global::System.IntPtr instance, int delete);
                }

                internal static new global::CppSharp.Parser.AST.Parameter __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.Parameter(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.Parameter __CreateInstance(global::CppSharp.Parser.AST.Parameter.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.Parameter(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.Parameter.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Parameter.__Internal));
                    global::CppSharp.Parser.AST.Parameter.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private Parameter(global::CppSharp.Parser.AST.Parameter.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected Parameter(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public Parameter()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Parameter.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment));
                }

                public Parameter(global::CppSharp.Parser.AST.Parameter _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Parameter.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Declaration __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.QualifiedType QualifiedType
                {
                    get
                    {
                        return global::CppSharp.Parser.AST.QualifiedType.__CreateInstance(((global::CppSharp.Parser.AST.Parameter.__Internal*) __Instance)->qualifiedType);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Parameter.__Internal*) __Instance)->qualifiedType = ReferenceEquals(value, null) ? new global::CppSharp.Parser.AST.QualifiedType.__Internal() : *(global::CppSharp.Parser.AST.QualifiedType.__Internal*) value.__Instance;
                    }
                }

                public bool IsIndirect
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Parameter.__Internal*) __Instance)->isIndirect != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Parameter.__Internal*) __Instance)->isIndirect = (byte) (value ? 1 : 0);
                    }
                }

                public bool HasDefaultValue
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Parameter.__Internal*) __Instance)->hasDefaultValue != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Parameter.__Internal*) __Instance)->hasDefaultValue = (byte) (value ? 1 : 0);
                    }
                }

                public uint Index
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Parameter.__Internal*) __Instance)->index;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Parameter.__Internal*) __Instance)->index = value;
                    }
                }

                public global::CppSharp.Parser.AST.Expression DefaultArgument
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expression __result0;
                        if (((global::CppSharp.Parser.AST.Parameter.__Internal*) __Instance)->defaultArgument == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expression.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.Parameter.__Internal*) __Instance)->defaultArgument))
                            __result0 = (global::CppSharp.Parser.AST.Expression) global::CppSharp.Parser.AST.Expression.NativeToManagedMap[((global::CppSharp.Parser.AST.Parameter.__Internal*) __Instance)->defaultArgument];
                        else __result0 = global::CppSharp.Parser.AST.Expression.__CreateInstance(((global::CppSharp.Parser.AST.Parameter.__Internal*) __Instance)->defaultArgument);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Parameter.__Internal*) __Instance)->defaultArgument = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }
            }

            public unsafe partial class Function : global::CppSharp.Parser.AST.DeclarationContext, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 656)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.DeclarationKind kind;

                    [FieldOffset(4)]
                    internal int maxFieldAlignment;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.AccessSpecifier access;

                    [FieldOffset(16)]
                    internal global::System.IntPtr _namespace;

                    [FieldOffset(24)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal location;

                    [FieldOffset(28)]
                    internal int lineNumberStart;

                    [FieldOffset(32)]
                    internal int lineNumberEnd;

                    [FieldOffset(40)]
                    internal global::Std.BasicString.__Internal name;

                    [FieldOffset(72)]
                    internal global::Std.BasicString.__Internal USR;

                    [FieldOffset(104)]
                    internal global::Std.BasicString.__Internal debugText;

                    [FieldOffset(136)]
                    internal byte isIncomplete;

                    [FieldOffset(137)]
                    internal byte isDependent;

                    [FieldOffset(138)]
                    internal byte isImplicit;

                    [FieldOffset(144)]
                    internal global::System.IntPtr completeDeclaration;

                    [FieldOffset(152)]
                    internal uint definitionOrder;

                    [FieldOffset(160)]
                    internal global::Std.Vector.__Internal PreprocessedEntities;

                    [FieldOffset(184)]
                    internal global::Std.Vector.__Internal Redeclarations;

                    [FieldOffset(208)]
                    internal global::System.IntPtr originalPtr;

                    [FieldOffset(216)]
                    internal global::System.IntPtr comment;

                    [FieldOffset(224)]
                    internal global::Std.Vector.__Internal Namespaces;

                    [FieldOffset(248)]
                    internal global::Std.Vector.__Internal Enums;

                    [FieldOffset(272)]
                    internal global::Std.Vector.__Internal Functions;

                    [FieldOffset(296)]
                    internal global::Std.Vector.__Internal Classes;

                    [FieldOffset(320)]
                    internal global::Std.Vector.__Internal Templates;

                    [FieldOffset(344)]
                    internal global::Std.Vector.__Internal Typedefs;

                    [FieldOffset(368)]
                    internal global::Std.Vector.__Internal TypeAliases;

                    [FieldOffset(392)]
                    internal global::Std.Vector.__Internal Variables;

                    [FieldOffset(416)]
                    internal global::Std.Vector.__Internal Friends;

                    [FieldOffset(440)]
                    internal global::Std.Map.__Internal anonymous;

                    [FieldOffset(456)]
                    internal byte isAnonymous;

                    [FieldOffset(464)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal returnType;

                    [FieldOffset(480)]
                    internal byte isReturnIndirect;

                    [FieldOffset(481)]
                    internal byte hasThisReturn;

                    [FieldOffset(482)]
                    internal byte isConstExpr;

                    [FieldOffset(483)]
                    internal byte isVariadic;

                    [FieldOffset(484)]
                    internal byte isInline;

                    [FieldOffset(485)]
                    internal byte isPure;

                    [FieldOffset(486)]
                    internal byte isDeleted;

                    [FieldOffset(488)]
                    internal global::CppSharp.Parser.AST.FriendKind friendKind;

                    [FieldOffset(492)]
                    internal global::CppSharp.Parser.AST.CXXOperatorKind operatorKind;

                    [FieldOffset(496)]
                    internal global::Std.BasicString.__Internal mangled;

                    [FieldOffset(528)]
                    internal global::Std.BasicString.__Internal signature;

                    [FieldOffset(560)]
                    internal global::Std.BasicString.__Internal body;

                    [FieldOffset(592)]
                    internal global::CppSharp.Parser.AST.CallingConvention callingConvention;

                    [FieldOffset(600)]
                    internal global::Std.Vector.__Internal Parameters;

                    [FieldOffset(624)]
                    internal global::System.IntPtr specializationInfo;

                    [FieldOffset(632)]
                    internal global::System.IntPtr instantiatedFrom;

                    [FieldOffset(640)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal qualifiedType;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0Function@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0Function@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1Function@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor(global::System.IntPtr instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getParameters@Function@AST@CppParser@CppSharp@@QEAAPEAVParameter@234@I@Z")]
                    internal static extern global::System.IntPtr GetParameters(global::System.IntPtr instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?addParameters@Function@AST@CppParser@CppSharp@@QEAAXAEAPEAVParameter@234@@Z")]
                    internal static extern void AddParameters(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?clearParameters@Function@AST@CppParser@CppSharp@@QEAAXXZ")]
                    internal static extern void ClearParameters(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getParametersCount@Function@AST@CppParser@CppSharp@@QEAAIXZ")]
                    internal static extern uint GetParametersCount(global::System.IntPtr instance);
                }

                internal static new global::CppSharp.Parser.AST.Function __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.Function(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.Function __CreateInstance(global::CppSharp.Parser.AST.Function.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.Function(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.Function.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Function.__Internal));
                    global::CppSharp.Parser.AST.Function.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private Function(global::CppSharp.Parser.AST.Function.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected Function(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public Function()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Function.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment));
                }

                public Function(global::CppSharp.Parser.AST.Function _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Function.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Declaration __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.Parameter GetParameters(uint i)
                {
                    var __ret = __Internal.GetParameters((__Instance + __PointerAdjustment), i);
                    global::CppSharp.Parser.AST.Parameter __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.Parameter.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::CppSharp.Parser.AST.Parameter) global::CppSharp.Parser.AST.Parameter.NativeToManagedMap[__ret];
                    else __result0 = global::CppSharp.Parser.AST.Parameter.__CreateInstance(__ret);
                    return __result0;
                }

                public void AddParameters(global::CppSharp.Parser.AST.Parameter s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    __Internal.AddParameters((__Instance + __PointerAdjustment), __arg0);
                }

                public void ClearParameters()
                {
                    __Internal.ClearParameters((__Instance + __PointerAdjustment));
                }

                public global::CppSharp.Parser.AST.QualifiedType ReturnType
                {
                    get
                    {
                        return global::CppSharp.Parser.AST.QualifiedType.__CreateInstance(((global::CppSharp.Parser.AST.Function.__Internal*) __Instance)->returnType);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Function.__Internal*) __Instance)->returnType = ReferenceEquals(value, null) ? new global::CppSharp.Parser.AST.QualifiedType.__Internal() : *(global::CppSharp.Parser.AST.QualifiedType.__Internal*) value.__Instance;
                    }
                }

                public bool IsReturnIndirect
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Function.__Internal*) __Instance)->isReturnIndirect != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Function.__Internal*) __Instance)->isReturnIndirect = (byte) (value ? 1 : 0);
                    }
                }

                public bool HasThisReturn
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Function.__Internal*) __Instance)->hasThisReturn != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Function.__Internal*) __Instance)->hasThisReturn = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsConstExpr
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Function.__Internal*) __Instance)->isConstExpr != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Function.__Internal*) __Instance)->isConstExpr = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsVariadic
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Function.__Internal*) __Instance)->isVariadic != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Function.__Internal*) __Instance)->isVariadic = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsInline
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Function.__Internal*) __Instance)->isInline != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Function.__Internal*) __Instance)->isInline = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsPure
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Function.__Internal*) __Instance)->isPure != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Function.__Internal*) __Instance)->isPure = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsDeleted
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Function.__Internal*) __Instance)->isDeleted != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Function.__Internal*) __Instance)->isDeleted = (byte) (value ? 1 : 0);
                    }
                }

                public global::CppSharp.Parser.AST.FriendKind FriendKind
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Function.__Internal*) __Instance)->friendKind;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Function.__Internal*) __Instance)->friendKind = value;
                    }
                }

                public global::CppSharp.Parser.AST.CXXOperatorKind OperatorKind
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Function.__Internal*) __Instance)->operatorKind;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Function.__Internal*) __Instance)->operatorKind = value;
                    }
                }

                public string Mangled
                {
                    get
                    {
                        var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(((global::CppSharp.Parser.AST.Function.__Internal*) __Instance)->mangled);
                        var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                        __basicStringRet.Dispose(false);
                        return __stringRet;
                    }

                    set
                    {
                        var __allocator0 = new global::Std.Allocator<sbyte>();
                        var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                        ((global::CppSharp.Parser.AST.Function.__Internal*) __Instance)->mangled = *(global::Std.BasicString.__Internal*) __basicString0.__Instance;
                    }
                }

                public string Signature
                {
                    get
                    {
                        var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(((global::CppSharp.Parser.AST.Function.__Internal*) __Instance)->signature);
                        var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                        __basicStringRet.Dispose(false);
                        return __stringRet;
                    }

                    set
                    {
                        var __allocator0 = new global::Std.Allocator<sbyte>();
                        var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                        ((global::CppSharp.Parser.AST.Function.__Internal*) __Instance)->signature = *(global::Std.BasicString.__Internal*) __basicString0.__Instance;
                    }
                }

                public string Body
                {
                    get
                    {
                        var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(((global::CppSharp.Parser.AST.Function.__Internal*) __Instance)->body);
                        var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                        __basicStringRet.Dispose(false);
                        return __stringRet;
                    }

                    set
                    {
                        var __allocator0 = new global::Std.Allocator<sbyte>();
                        var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                        ((global::CppSharp.Parser.AST.Function.__Internal*) __Instance)->body = *(global::Std.BasicString.__Internal*) __basicString0.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.CallingConvention CallingConvention
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Function.__Internal*) __Instance)->callingConvention;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Function.__Internal*) __Instance)->callingConvention = value;
                    }
                }

                public global::CppSharp.Parser.AST.FunctionTemplateSpecialization SpecializationInfo
                {
                    get
                    {
                        global::CppSharp.Parser.AST.FunctionTemplateSpecialization __result0;
                        if (((global::CppSharp.Parser.AST.Function.__Internal*) __Instance)->specializationInfo == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.FunctionTemplateSpecialization.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.Function.__Internal*) __Instance)->specializationInfo))
                            __result0 = (global::CppSharp.Parser.AST.FunctionTemplateSpecialization) global::CppSharp.Parser.AST.FunctionTemplateSpecialization.NativeToManagedMap[((global::CppSharp.Parser.AST.Function.__Internal*) __Instance)->specializationInfo];
                        else __result0 = global::CppSharp.Parser.AST.FunctionTemplateSpecialization.__CreateInstance(((global::CppSharp.Parser.AST.Function.__Internal*) __Instance)->specializationInfo);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Function.__Internal*) __Instance)->specializationInfo = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Function InstantiatedFrom
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Function __result0;
                        if (((global::CppSharp.Parser.AST.Function.__Internal*) __Instance)->instantiatedFrom == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Function.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.Function.__Internal*) __Instance)->instantiatedFrom))
                            __result0 = (global::CppSharp.Parser.AST.Function) global::CppSharp.Parser.AST.Function.NativeToManagedMap[((global::CppSharp.Parser.AST.Function.__Internal*) __Instance)->instantiatedFrom];
                        else __result0 = global::CppSharp.Parser.AST.Function.__CreateInstance(((global::CppSharp.Parser.AST.Function.__Internal*) __Instance)->instantiatedFrom);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Function.__Internal*) __Instance)->instantiatedFrom = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.QualifiedType QualifiedType
                {
                    get
                    {
                        return global::CppSharp.Parser.AST.QualifiedType.__CreateInstance(((global::CppSharp.Parser.AST.Function.__Internal*) __Instance)->qualifiedType);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Function.__Internal*) __Instance)->qualifiedType = ReferenceEquals(value, null) ? new global::CppSharp.Parser.AST.QualifiedType.__Internal() : *(global::CppSharp.Parser.AST.QualifiedType.__Internal*) value.__Instance;
                    }
                }

                public uint ParametersCount
                {
                    get
                    {
                        var __ret = __Internal.GetParametersCount((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }
            }

            public unsafe partial class Method : global::CppSharp.Parser.AST.Function, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 696)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.DeclarationKind kind;

                    [FieldOffset(4)]
                    internal int maxFieldAlignment;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.AccessSpecifier access;

                    [FieldOffset(16)]
                    internal global::System.IntPtr _namespace;

                    [FieldOffset(24)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal location;

                    [FieldOffset(28)]
                    internal int lineNumberStart;

                    [FieldOffset(32)]
                    internal int lineNumberEnd;

                    [FieldOffset(40)]
                    internal global::Std.BasicString.__Internal name;

                    [FieldOffset(72)]
                    internal global::Std.BasicString.__Internal USR;

                    [FieldOffset(104)]
                    internal global::Std.BasicString.__Internal debugText;

                    [FieldOffset(136)]
                    internal byte isIncomplete;

                    [FieldOffset(137)]
                    internal byte isDependent;

                    [FieldOffset(138)]
                    internal byte isImplicit;

                    [FieldOffset(144)]
                    internal global::System.IntPtr completeDeclaration;

                    [FieldOffset(152)]
                    internal uint definitionOrder;

                    [FieldOffset(160)]
                    internal global::Std.Vector.__Internal PreprocessedEntities;

                    [FieldOffset(184)]
                    internal global::Std.Vector.__Internal Redeclarations;

                    [FieldOffset(208)]
                    internal global::System.IntPtr originalPtr;

                    [FieldOffset(216)]
                    internal global::System.IntPtr comment;

                    [FieldOffset(224)]
                    internal global::Std.Vector.__Internal Namespaces;

                    [FieldOffset(248)]
                    internal global::Std.Vector.__Internal Enums;

                    [FieldOffset(272)]
                    internal global::Std.Vector.__Internal Functions;

                    [FieldOffset(296)]
                    internal global::Std.Vector.__Internal Classes;

                    [FieldOffset(320)]
                    internal global::Std.Vector.__Internal Templates;

                    [FieldOffset(344)]
                    internal global::Std.Vector.__Internal Typedefs;

                    [FieldOffset(368)]
                    internal global::Std.Vector.__Internal TypeAliases;

                    [FieldOffset(392)]
                    internal global::Std.Vector.__Internal Variables;

                    [FieldOffset(416)]
                    internal global::Std.Vector.__Internal Friends;

                    [FieldOffset(440)]
                    internal global::Std.Map.__Internal anonymous;

                    [FieldOffset(456)]
                    internal byte isAnonymous;

                    [FieldOffset(464)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal returnType;

                    [FieldOffset(480)]
                    internal byte isReturnIndirect;

                    [FieldOffset(481)]
                    internal byte hasThisReturn;

                    [FieldOffset(482)]
                    internal byte isConstExpr;

                    [FieldOffset(483)]
                    internal byte isVariadic;

                    [FieldOffset(484)]
                    internal byte isInline;

                    [FieldOffset(485)]
                    internal byte isPure;

                    [FieldOffset(486)]
                    internal byte isDeleted;

                    [FieldOffset(488)]
                    internal global::CppSharp.Parser.AST.FriendKind friendKind;

                    [FieldOffset(492)]
                    internal global::CppSharp.Parser.AST.CXXOperatorKind operatorKind;

                    [FieldOffset(496)]
                    internal global::Std.BasicString.__Internal mangled;

                    [FieldOffset(528)]
                    internal global::Std.BasicString.__Internal signature;

                    [FieldOffset(560)]
                    internal global::Std.BasicString.__Internal body;

                    [FieldOffset(592)]
                    internal global::CppSharp.Parser.AST.CallingConvention callingConvention;

                    [FieldOffset(600)]
                    internal global::Std.Vector.__Internal Parameters;

                    [FieldOffset(624)]
                    internal global::System.IntPtr specializationInfo;

                    [FieldOffset(632)]
                    internal global::System.IntPtr instantiatedFrom;

                    [FieldOffset(640)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal qualifiedType;

                    [FieldOffset(656)]
                    internal byte isVirtual;

                    [FieldOffset(657)]
                    internal byte isStatic;

                    [FieldOffset(658)]
                    internal byte isConst;

                    [FieldOffset(659)]
                    internal byte isExplicit;

                    [FieldOffset(660)]
                    internal byte isOverride;

                    [FieldOffset(664)]
                    internal global::CppSharp.Parser.AST.CXXMethodKind methodKind;

                    [FieldOffset(668)]
                    internal byte isDefaultConstructor;

                    [FieldOffset(669)]
                    internal byte isCopyConstructor;

                    [FieldOffset(670)]
                    internal byte isMoveConstructor;

                    [FieldOffset(672)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal conversionType;

                    [FieldOffset(688)]
                    internal global::CppSharp.Parser.AST.RefQualifierKind refQualifier;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0Method@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0Method@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1Method@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor(global::System.IntPtr instance, int delete);
                }

                internal static new global::CppSharp.Parser.AST.Method __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.Method(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.Method __CreateInstance(global::CppSharp.Parser.AST.Method.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.Method(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.Method.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Method.__Internal));
                    global::CppSharp.Parser.AST.Method.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private Method(global::CppSharp.Parser.AST.Method.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected Method(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public Method()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Method.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment));
                }

                public Method(global::CppSharp.Parser.AST.Method _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Method.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Declaration __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public bool IsVirtual
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Method.__Internal*) __Instance)->isVirtual != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Method.__Internal*) __Instance)->isVirtual = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsStatic
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Method.__Internal*) __Instance)->isStatic != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Method.__Internal*) __Instance)->isStatic = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsConst
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Method.__Internal*) __Instance)->isConst != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Method.__Internal*) __Instance)->isConst = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsExplicit
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Method.__Internal*) __Instance)->isExplicit != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Method.__Internal*) __Instance)->isExplicit = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsOverride
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Method.__Internal*) __Instance)->isOverride != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Method.__Internal*) __Instance)->isOverride = (byte) (value ? 1 : 0);
                    }
                }

                public global::CppSharp.Parser.AST.CXXMethodKind MethodKind
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Method.__Internal*) __Instance)->methodKind;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Method.__Internal*) __Instance)->methodKind = value;
                    }
                }

                public bool IsDefaultConstructor
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Method.__Internal*) __Instance)->isDefaultConstructor != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Method.__Internal*) __Instance)->isDefaultConstructor = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsCopyConstructor
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Method.__Internal*) __Instance)->isCopyConstructor != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Method.__Internal*) __Instance)->isCopyConstructor = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsMoveConstructor
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Method.__Internal*) __Instance)->isMoveConstructor != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Method.__Internal*) __Instance)->isMoveConstructor = (byte) (value ? 1 : 0);
                    }
                }

                public global::CppSharp.Parser.AST.QualifiedType ConversionType
                {
                    get
                    {
                        return global::CppSharp.Parser.AST.QualifiedType.__CreateInstance(((global::CppSharp.Parser.AST.Method.__Internal*) __Instance)->conversionType);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Method.__Internal*) __Instance)->conversionType = ReferenceEquals(value, null) ? new global::CppSharp.Parser.AST.QualifiedType.__Internal() : *(global::CppSharp.Parser.AST.QualifiedType.__Internal*) value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.RefQualifierKind RefQualifier
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Method.__Internal*) __Instance)->refQualifier;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Method.__Internal*) __Instance)->refQualifier = value;
                    }
                }
            }

            public unsafe partial class Enumeration : global::CppSharp.Parser.AST.DeclarationContext, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 512)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.DeclarationKind kind;

                    [FieldOffset(4)]
                    internal int maxFieldAlignment;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.AccessSpecifier access;

                    [FieldOffset(16)]
                    internal global::System.IntPtr _namespace;

                    [FieldOffset(24)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal location;

                    [FieldOffset(28)]
                    internal int lineNumberStart;

                    [FieldOffset(32)]
                    internal int lineNumberEnd;

                    [FieldOffset(40)]
                    internal global::Std.BasicString.__Internal name;

                    [FieldOffset(72)]
                    internal global::Std.BasicString.__Internal USR;

                    [FieldOffset(104)]
                    internal global::Std.BasicString.__Internal debugText;

                    [FieldOffset(136)]
                    internal byte isIncomplete;

                    [FieldOffset(137)]
                    internal byte isDependent;

                    [FieldOffset(138)]
                    internal byte isImplicit;

                    [FieldOffset(144)]
                    internal global::System.IntPtr completeDeclaration;

                    [FieldOffset(152)]
                    internal uint definitionOrder;

                    [FieldOffset(160)]
                    internal global::Std.Vector.__Internal PreprocessedEntities;

                    [FieldOffset(184)]
                    internal global::Std.Vector.__Internal Redeclarations;

                    [FieldOffset(208)]
                    internal global::System.IntPtr originalPtr;

                    [FieldOffset(216)]
                    internal global::System.IntPtr comment;

                    [FieldOffset(224)]
                    internal global::Std.Vector.__Internal Namespaces;

                    [FieldOffset(248)]
                    internal global::Std.Vector.__Internal Enums;

                    [FieldOffset(272)]
                    internal global::Std.Vector.__Internal Functions;

                    [FieldOffset(296)]
                    internal global::Std.Vector.__Internal Classes;

                    [FieldOffset(320)]
                    internal global::Std.Vector.__Internal Templates;

                    [FieldOffset(344)]
                    internal global::Std.Vector.__Internal Typedefs;

                    [FieldOffset(368)]
                    internal global::Std.Vector.__Internal TypeAliases;

                    [FieldOffset(392)]
                    internal global::Std.Vector.__Internal Variables;

                    [FieldOffset(416)]
                    internal global::Std.Vector.__Internal Friends;

                    [FieldOffset(440)]
                    internal global::Std.Map.__Internal anonymous;

                    [FieldOffset(456)]
                    internal byte isAnonymous;

                    [FieldOffset(464)]
                    internal global::CppSharp.Parser.AST.Enumeration.EnumModifiers modifiers;

                    [FieldOffset(472)]
                    internal global::System.IntPtr type;

                    [FieldOffset(480)]
                    internal global::System.IntPtr builtinType;

                    [FieldOffset(488)]
                    internal global::Std.Vector.__Internal Items;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0Enumeration@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0Enumeration@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1Enumeration@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor(global::System.IntPtr instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getItems@Enumeration@AST@CppParser@CppSharp@@QEAAPEAVItem@1234@I@Z")]
                    internal static extern global::System.IntPtr GetItems(global::System.IntPtr instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?addItems@Enumeration@AST@CppParser@CppSharp@@QEAAXAEAPEAVItem@1234@@Z")]
                    internal static extern void AddItems(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?clearItems@Enumeration@AST@CppParser@CppSharp@@QEAAXXZ")]
                    internal static extern void ClearItems(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?FindItemByName@Enumeration@AST@CppParser@CppSharp@@QEAAPEAVItem@1234@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
                    internal static extern global::System.IntPtr FindItemByName(global::System.IntPtr instance, global::System.IntPtr Name);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getItemsCount@Enumeration@AST@CppParser@CppSharp@@QEAAIXZ")]
                    internal static extern uint GetItemsCount(global::System.IntPtr instance);
                }

                [Flags]
                public enum EnumModifiers
                {
                    Anonymous = 1,
                    Scoped = 2,
                    Flags = 4
                }

                public unsafe partial class Item : global::CppSharp.Parser.AST.Declaration, IDisposable
                {
                    [StructLayout(LayoutKind.Explicit, Size = 264)]
                    public new partial struct __Internal
                    {
                        [FieldOffset(0)]
                        internal global::CppSharp.Parser.AST.DeclarationKind kind;

                        [FieldOffset(4)]
                        internal int maxFieldAlignment;

                        [FieldOffset(8)]
                        internal global::CppSharp.Parser.AST.AccessSpecifier access;

                        [FieldOffset(16)]
                        internal global::System.IntPtr _namespace;

                        [FieldOffset(24)]
                        internal global::CppSharp.Parser.SourceLocation.__Internal location;

                        [FieldOffset(28)]
                        internal int lineNumberStart;

                        [FieldOffset(32)]
                        internal int lineNumberEnd;

                        [FieldOffset(40)]
                        internal global::Std.BasicString.__Internal name;

                        [FieldOffset(72)]
                        internal global::Std.BasicString.__Internal USR;

                        [FieldOffset(104)]
                        internal global::Std.BasicString.__Internal debugText;

                        [FieldOffset(136)]
                        internal byte isIncomplete;

                        [FieldOffset(137)]
                        internal byte isDependent;

                        [FieldOffset(138)]
                        internal byte isImplicit;

                        [FieldOffset(144)]
                        internal global::System.IntPtr completeDeclaration;

                        [FieldOffset(152)]
                        internal uint definitionOrder;

                        [FieldOffset(160)]
                        internal global::Std.Vector.__Internal PreprocessedEntities;

                        [FieldOffset(184)]
                        internal global::Std.Vector.__Internal Redeclarations;

                        [FieldOffset(208)]
                        internal global::System.IntPtr originalPtr;

                        [FieldOffset(216)]
                        internal global::System.IntPtr comment;

                        [FieldOffset(224)]
                        internal global::Std.BasicString.__Internal expression;

                        [FieldOffset(256)]
                        internal ulong value;

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="??0Item@Enumeration@AST@CppParser@CppSharp@@QEAA@XZ")]
                        internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="??0Item@Enumeration@AST@CppParser@CppSharp@@QEAA@AEBV01234@@Z")]
                        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="??1Item@Enumeration@AST@CppParser@CppSharp@@QEAA@XZ")]
                        internal static extern void dtor(global::System.IntPtr instance, int delete);
                    }

                    internal static new global::CppSharp.Parser.AST.Enumeration.Item __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                    {
                        return new global::CppSharp.Parser.AST.Enumeration.Item(native.ToPointer(), skipVTables);
                    }

                    internal static global::CppSharp.Parser.AST.Enumeration.Item __CreateInstance(global::CppSharp.Parser.AST.Enumeration.Item.__Internal native, bool skipVTables = false)
                    {
                        return new global::CppSharp.Parser.AST.Enumeration.Item(native, skipVTables);
                    }

                    private static void* __CopyValue(global::CppSharp.Parser.AST.Enumeration.Item.__Internal native)
                    {
                        var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Enumeration.Item.__Internal));
                        global::CppSharp.Parser.AST.Enumeration.Item.__Internal.cctor(ret, new global::System.IntPtr(&native));
                        return ret.ToPointer();
                    }

                    private Item(global::CppSharp.Parser.AST.Enumeration.Item.__Internal native, bool skipVTables = false)
                        : this(__CopyValue(native), skipVTables)
                    {
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                    }

                    protected Item(void* native, bool skipVTables = false)
                        : base((void*) null)
                    {
                        __PointerAdjustment = 0;
                        if (native == null)
                            return;
                        __Instance = new global::System.IntPtr(native);
                    }

                    public Item()
                        : this((void*) null)
                    {
                        __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Enumeration.Item.__Internal));
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                        __Internal.ctor((__Instance + __PointerAdjustment));
                    }

                    public Item(global::CppSharp.Parser.AST.Enumeration.Item _0)
                        : this((void*) null)
                    {
                        __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Enumeration.Item.__Internal));
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                        if (ReferenceEquals(_0, null))
                            throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                        var __arg0 = _0.__Instance;
                        __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
                    }

                    public override void Dispose(bool disposing)
                    {
                        if (__Instance == IntPtr.Zero)
                            return;
                        global::CppSharp.Parser.AST.Declaration __dummy;
                        NativeToManagedMap.TryRemove(__Instance, out __dummy);
                        if (disposing)
                            __Internal.dtor((__Instance + __PointerAdjustment), 0);
                        if (__ownsNativeInstance)
                            Marshal.FreeHGlobal(__Instance);
                        __Instance = IntPtr.Zero;
                    }

                    public string Expression
                    {
                        get
                        {
                            var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(((global::CppSharp.Parser.AST.Enumeration.Item.__Internal*) __Instance)->expression);
                            var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                            __basicStringRet.Dispose(false);
                            return __stringRet;
                        }

                        set
                        {
                            var __allocator0 = new global::Std.Allocator<sbyte>();
                            var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                            ((global::CppSharp.Parser.AST.Enumeration.Item.__Internal*) __Instance)->expression = *(global::Std.BasicString.__Internal*) __basicString0.__Instance;
                        }
                    }

                    public ulong Value
                    {
                        get
                        {
                            return ((global::CppSharp.Parser.AST.Enumeration.Item.__Internal*) __Instance)->value;
                        }

                        set
                        {
                            ((global::CppSharp.Parser.AST.Enumeration.Item.__Internal*) __Instance)->value = value;
                        }
                    }
                }

                internal static new global::CppSharp.Parser.AST.Enumeration __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.Enumeration(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.Enumeration __CreateInstance(global::CppSharp.Parser.AST.Enumeration.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.Enumeration(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.Enumeration.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Enumeration.__Internal));
                    global::CppSharp.Parser.AST.Enumeration.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private Enumeration(global::CppSharp.Parser.AST.Enumeration.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected Enumeration(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public Enumeration()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Enumeration.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment));
                }

                public Enumeration(global::CppSharp.Parser.AST.Enumeration _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Enumeration.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Declaration __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.Enumeration.Item GetItems(uint i)
                {
                    var __ret = __Internal.GetItems((__Instance + __PointerAdjustment), i);
                    global::CppSharp.Parser.AST.Enumeration.Item __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.Enumeration.Item.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::CppSharp.Parser.AST.Enumeration.Item) global::CppSharp.Parser.AST.Enumeration.Item.NativeToManagedMap[__ret];
                    else __result0 = global::CppSharp.Parser.AST.Enumeration.Item.__CreateInstance(__ret);
                    return __result0;
                }

                public void AddItems(global::CppSharp.Parser.AST.Enumeration.Item s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    __Internal.AddItems((__Instance + __PointerAdjustment), __arg0);
                }

                public void ClearItems()
                {
                    __Internal.ClearItems((__Instance + __PointerAdjustment));
                }

                public global::CppSharp.Parser.AST.Enumeration.Item FindItemByName(string Name)
                {
                    var __allocator0 = new global::Std.Allocator<sbyte>();
                    var __basicString0 = global::Std.BasicStringExtensions.BasicString(Name, __allocator0);
                    var __arg0 = __basicString0.__Instance;
                    var __ret = __Internal.FindItemByName((__Instance + __PointerAdjustment), __arg0);
                    __basicString0.Dispose(false);
                    __allocator0.Dispose();
                    global::CppSharp.Parser.AST.Enumeration.Item __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.Enumeration.Item.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::CppSharp.Parser.AST.Enumeration.Item) global::CppSharp.Parser.AST.Enumeration.Item.NativeToManagedMap[__ret];
                    else __result0 = global::CppSharp.Parser.AST.Enumeration.Item.__CreateInstance(__ret);
                    return __result0;
                }

                public global::CppSharp.Parser.AST.Enumeration.EnumModifiers Modifiers
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Enumeration.__Internal*) __Instance)->modifiers;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Enumeration.__Internal*) __Instance)->modifiers = value;
                    }
                }

                public global::CppSharp.Parser.AST.Type Type
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Type __result0;
                        if (((global::CppSharp.Parser.AST.Enumeration.__Internal*) __Instance)->type == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Type.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.Enumeration.__Internal*) __Instance)->type))
                            __result0 = (global::CppSharp.Parser.AST.Type) global::CppSharp.Parser.AST.Type.NativeToManagedMap[((global::CppSharp.Parser.AST.Enumeration.__Internal*) __Instance)->type];
                        else __result0 = global::CppSharp.Parser.AST.Type.__CreateInstance(((global::CppSharp.Parser.AST.Enumeration.__Internal*) __Instance)->type);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Enumeration.__Internal*) __Instance)->type = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.BuiltinType BuiltinType
                {
                    get
                    {
                        global::CppSharp.Parser.AST.BuiltinType __result0;
                        if (((global::CppSharp.Parser.AST.Enumeration.__Internal*) __Instance)->builtinType == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.BuiltinType.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.Enumeration.__Internal*) __Instance)->builtinType))
                            __result0 = (global::CppSharp.Parser.AST.BuiltinType) global::CppSharp.Parser.AST.BuiltinType.NativeToManagedMap[((global::CppSharp.Parser.AST.Enumeration.__Internal*) __Instance)->builtinType];
                        else __result0 = global::CppSharp.Parser.AST.BuiltinType.__CreateInstance(((global::CppSharp.Parser.AST.Enumeration.__Internal*) __Instance)->builtinType);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Enumeration.__Internal*) __Instance)->builtinType = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public uint ItemsCount
                {
                    get
                    {
                        var __ret = __Internal.GetItemsCount((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }
            }

            public unsafe partial class Variable : global::CppSharp.Parser.AST.Declaration, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 272)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.DeclarationKind kind;

                    [FieldOffset(4)]
                    internal int maxFieldAlignment;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.AccessSpecifier access;

                    [FieldOffset(16)]
                    internal global::System.IntPtr _namespace;

                    [FieldOffset(24)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal location;

                    [FieldOffset(28)]
                    internal int lineNumberStart;

                    [FieldOffset(32)]
                    internal int lineNumberEnd;

                    [FieldOffset(40)]
                    internal global::Std.BasicString.__Internal name;

                    [FieldOffset(72)]
                    internal global::Std.BasicString.__Internal USR;

                    [FieldOffset(104)]
                    internal global::Std.BasicString.__Internal debugText;

                    [FieldOffset(136)]
                    internal byte isIncomplete;

                    [FieldOffset(137)]
                    internal byte isDependent;

                    [FieldOffset(138)]
                    internal byte isImplicit;

                    [FieldOffset(144)]
                    internal global::System.IntPtr completeDeclaration;

                    [FieldOffset(152)]
                    internal uint definitionOrder;

                    [FieldOffset(160)]
                    internal global::Std.Vector.__Internal PreprocessedEntities;

                    [FieldOffset(184)]
                    internal global::Std.Vector.__Internal Redeclarations;

                    [FieldOffset(208)]
                    internal global::System.IntPtr originalPtr;

                    [FieldOffset(216)]
                    internal global::System.IntPtr comment;

                    [FieldOffset(224)]
                    internal global::Std.BasicString.__Internal mangled;

                    [FieldOffset(256)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal qualifiedType;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0Variable@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0Variable@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1Variable@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor(global::System.IntPtr instance, int delete);
                }

                internal static new global::CppSharp.Parser.AST.Variable __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.Variable(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.Variable __CreateInstance(global::CppSharp.Parser.AST.Variable.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.Variable(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.Variable.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Variable.__Internal));
                    global::CppSharp.Parser.AST.Variable.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private Variable(global::CppSharp.Parser.AST.Variable.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected Variable(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public Variable()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Variable.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment));
                }

                public Variable(global::CppSharp.Parser.AST.Variable _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Variable.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Declaration __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public string Mangled
                {
                    get
                    {
                        var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(((global::CppSharp.Parser.AST.Variable.__Internal*) __Instance)->mangled);
                        var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                        __basicStringRet.Dispose(false);
                        return __stringRet;
                    }

                    set
                    {
                        var __allocator0 = new global::Std.Allocator<sbyte>();
                        var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                        ((global::CppSharp.Parser.AST.Variable.__Internal*) __Instance)->mangled = *(global::Std.BasicString.__Internal*) __basicString0.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.QualifiedType QualifiedType
                {
                    get
                    {
                        return global::CppSharp.Parser.AST.QualifiedType.__CreateInstance(((global::CppSharp.Parser.AST.Variable.__Internal*) __Instance)->qualifiedType);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Variable.__Internal*) __Instance)->qualifiedType = ReferenceEquals(value, null) ? new global::CppSharp.Parser.AST.QualifiedType.__Internal() : *(global::CppSharp.Parser.AST.QualifiedType.__Internal*) value.__Instance;
                    }
                }
            }

            public unsafe partial class BaseClassSpecifier : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 24)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.AccessSpecifier access;

                    [FieldOffset(4)]
                    internal byte isVirtual;

                    [FieldOffset(8)]
                    internal global::System.IntPtr type;

                    [FieldOffset(16)]
                    internal int offset;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0BaseClassSpecifier@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0BaseClassSpecifier@AST@CppParser@CppSharp@@QEAA@AEBU0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                protected int __PointerAdjustment;
                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.BaseClassSpecifier> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.BaseClassSpecifier>();
                protected void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                internal static global::CppSharp.Parser.AST.BaseClassSpecifier __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.BaseClassSpecifier(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.BaseClassSpecifier __CreateInstance(global::CppSharp.Parser.AST.BaseClassSpecifier.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.BaseClassSpecifier(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.BaseClassSpecifier.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.BaseClassSpecifier.__Internal));
                    *(global::CppSharp.Parser.AST.BaseClassSpecifier.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private BaseClassSpecifier(global::CppSharp.Parser.AST.BaseClassSpecifier.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected BaseClassSpecifier(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public BaseClassSpecifier()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.BaseClassSpecifier.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment));
                }

                public BaseClassSpecifier(global::CppSharp.Parser.AST.BaseClassSpecifier _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.BaseClassSpecifier.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.BaseClassSpecifier.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.BaseClassSpecifier.__Internal*) _0.__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                public virtual void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.BaseClassSpecifier __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.AccessSpecifier Access
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.BaseClassSpecifier.__Internal*) __Instance)->access;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.BaseClassSpecifier.__Internal*) __Instance)->access = value;
                    }
                }

                public bool IsVirtual
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.BaseClassSpecifier.__Internal*) __Instance)->isVirtual != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.BaseClassSpecifier.__Internal*) __Instance)->isVirtual = (byte) (value ? 1 : 0);
                    }
                }

                public global::CppSharp.Parser.AST.Type Type
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Type __result0;
                        if (((global::CppSharp.Parser.AST.BaseClassSpecifier.__Internal*) __Instance)->type == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Type.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.BaseClassSpecifier.__Internal*) __Instance)->type))
                            __result0 = (global::CppSharp.Parser.AST.Type) global::CppSharp.Parser.AST.Type.NativeToManagedMap[((global::CppSharp.Parser.AST.BaseClassSpecifier.__Internal*) __Instance)->type];
                        else __result0 = global::CppSharp.Parser.AST.Type.__CreateInstance(((global::CppSharp.Parser.AST.BaseClassSpecifier.__Internal*) __Instance)->type);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.BaseClassSpecifier.__Internal*) __Instance)->type = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public int Offset
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.BaseClassSpecifier.__Internal*) __Instance)->offset;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.BaseClassSpecifier.__Internal*) __Instance)->offset = value;
                    }
                }
            }

            public unsafe partial class Field : global::CppSharp.Parser.AST.Declaration, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 256)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.DeclarationKind kind;

                    [FieldOffset(4)]
                    internal int maxFieldAlignment;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.AccessSpecifier access;

                    [FieldOffset(16)]
                    internal global::System.IntPtr _namespace;

                    [FieldOffset(24)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal location;

                    [FieldOffset(28)]
                    internal int lineNumberStart;

                    [FieldOffset(32)]
                    internal int lineNumberEnd;

                    [FieldOffset(40)]
                    internal global::Std.BasicString.__Internal name;

                    [FieldOffset(72)]
                    internal global::Std.BasicString.__Internal USR;

                    [FieldOffset(104)]
                    internal global::Std.BasicString.__Internal debugText;

                    [FieldOffset(136)]
                    internal byte isIncomplete;

                    [FieldOffset(137)]
                    internal byte isDependent;

                    [FieldOffset(138)]
                    internal byte isImplicit;

                    [FieldOffset(144)]
                    internal global::System.IntPtr completeDeclaration;

                    [FieldOffset(152)]
                    internal uint definitionOrder;

                    [FieldOffset(160)]
                    internal global::Std.Vector.__Internal PreprocessedEntities;

                    [FieldOffset(184)]
                    internal global::Std.Vector.__Internal Redeclarations;

                    [FieldOffset(208)]
                    internal global::System.IntPtr originalPtr;

                    [FieldOffset(216)]
                    internal global::System.IntPtr comment;

                    [FieldOffset(224)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal qualifiedType;

                    [FieldOffset(240)]
                    internal global::System.IntPtr _class;

                    [FieldOffset(248)]
                    internal byte isBitField;

                    [FieldOffset(252)]
                    internal uint bitWidth;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0Field@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0Field@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1Field@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor(global::System.IntPtr instance, int delete);
                }

                internal static new global::CppSharp.Parser.AST.Field __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.Field(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.Field __CreateInstance(global::CppSharp.Parser.AST.Field.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.Field(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.Field.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Field.__Internal));
                    global::CppSharp.Parser.AST.Field.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private Field(global::CppSharp.Parser.AST.Field.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected Field(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public Field()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Field.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment));
                }

                public Field(global::CppSharp.Parser.AST.Field _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Field.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Declaration __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.QualifiedType QualifiedType
                {
                    get
                    {
                        return global::CppSharp.Parser.AST.QualifiedType.__CreateInstance(((global::CppSharp.Parser.AST.Field.__Internal*) __Instance)->qualifiedType);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Field.__Internal*) __Instance)->qualifiedType = ReferenceEquals(value, null) ? new global::CppSharp.Parser.AST.QualifiedType.__Internal() : *(global::CppSharp.Parser.AST.QualifiedType.__Internal*) value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Class Class
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Class __result0;
                        if (((global::CppSharp.Parser.AST.Field.__Internal*) __Instance)->_class == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Class.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.Field.__Internal*) __Instance)->_class))
                            __result0 = (global::CppSharp.Parser.AST.Class) global::CppSharp.Parser.AST.Class.NativeToManagedMap[((global::CppSharp.Parser.AST.Field.__Internal*) __Instance)->_class];
                        else __result0 = global::CppSharp.Parser.AST.Class.__CreateInstance(((global::CppSharp.Parser.AST.Field.__Internal*) __Instance)->_class);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Field.__Internal*) __Instance)->_class = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public bool IsBitField
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Field.__Internal*) __Instance)->isBitField != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Field.__Internal*) __Instance)->isBitField = (byte) (value ? 1 : 0);
                    }
                }

                public uint BitWidth
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Field.__Internal*) __Instance)->bitWidth;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Field.__Internal*) __Instance)->bitWidth = value;
                    }
                }
            }

            public unsafe partial class AccessSpecifierDecl : global::CppSharp.Parser.AST.Declaration, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 224)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.DeclarationKind kind;

                    [FieldOffset(4)]
                    internal int maxFieldAlignment;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.AccessSpecifier access;

                    [FieldOffset(16)]
                    internal global::System.IntPtr _namespace;

                    [FieldOffset(24)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal location;

                    [FieldOffset(28)]
                    internal int lineNumberStart;

                    [FieldOffset(32)]
                    internal int lineNumberEnd;

                    [FieldOffset(40)]
                    internal global::Std.BasicString.__Internal name;

                    [FieldOffset(72)]
                    internal global::Std.BasicString.__Internal USR;

                    [FieldOffset(104)]
                    internal global::Std.BasicString.__Internal debugText;

                    [FieldOffset(136)]
                    internal byte isIncomplete;

                    [FieldOffset(137)]
                    internal byte isDependent;

                    [FieldOffset(138)]
                    internal byte isImplicit;

                    [FieldOffset(144)]
                    internal global::System.IntPtr completeDeclaration;

                    [FieldOffset(152)]
                    internal uint definitionOrder;

                    [FieldOffset(160)]
                    internal global::Std.Vector.__Internal PreprocessedEntities;

                    [FieldOffset(184)]
                    internal global::Std.Vector.__Internal Redeclarations;

                    [FieldOffset(208)]
                    internal global::System.IntPtr originalPtr;

                    [FieldOffset(216)]
                    internal global::System.IntPtr comment;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0AccessSpecifierDecl@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0AccessSpecifierDecl@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1AccessSpecifierDecl@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor(global::System.IntPtr instance, int delete);
                }

                internal static new global::CppSharp.Parser.AST.AccessSpecifierDecl __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.AccessSpecifierDecl(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.AccessSpecifierDecl __CreateInstance(global::CppSharp.Parser.AST.AccessSpecifierDecl.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.AccessSpecifierDecl(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.AccessSpecifierDecl.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.AccessSpecifierDecl.__Internal));
                    global::CppSharp.Parser.AST.AccessSpecifierDecl.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private AccessSpecifierDecl(global::CppSharp.Parser.AST.AccessSpecifierDecl.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected AccessSpecifierDecl(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public AccessSpecifierDecl()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.AccessSpecifierDecl.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment));
                }

                public AccessSpecifierDecl(global::CppSharp.Parser.AST.AccessSpecifierDecl _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.AccessSpecifierDecl.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Declaration __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }
            }

            public unsafe partial class Class : global::CppSharp.Parser.AST.DeclarationContext, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 584)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.DeclarationKind kind;

                    [FieldOffset(4)]
                    internal int maxFieldAlignment;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.AccessSpecifier access;

                    [FieldOffset(16)]
                    internal global::System.IntPtr _namespace;

                    [FieldOffset(24)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal location;

                    [FieldOffset(28)]
                    internal int lineNumberStart;

                    [FieldOffset(32)]
                    internal int lineNumberEnd;

                    [FieldOffset(40)]
                    internal global::Std.BasicString.__Internal name;

                    [FieldOffset(72)]
                    internal global::Std.BasicString.__Internal USR;

                    [FieldOffset(104)]
                    internal global::Std.BasicString.__Internal debugText;

                    [FieldOffset(136)]
                    internal byte isIncomplete;

                    [FieldOffset(137)]
                    internal byte isDependent;

                    [FieldOffset(138)]
                    internal byte isImplicit;

                    [FieldOffset(144)]
                    internal global::System.IntPtr completeDeclaration;

                    [FieldOffset(152)]
                    internal uint definitionOrder;

                    [FieldOffset(160)]
                    internal global::Std.Vector.__Internal PreprocessedEntities;

                    [FieldOffset(184)]
                    internal global::Std.Vector.__Internal Redeclarations;

                    [FieldOffset(208)]
                    internal global::System.IntPtr originalPtr;

                    [FieldOffset(216)]
                    internal global::System.IntPtr comment;

                    [FieldOffset(224)]
                    internal global::Std.Vector.__Internal Namespaces;

                    [FieldOffset(248)]
                    internal global::Std.Vector.__Internal Enums;

                    [FieldOffset(272)]
                    internal global::Std.Vector.__Internal Functions;

                    [FieldOffset(296)]
                    internal global::Std.Vector.__Internal Classes;

                    [FieldOffset(320)]
                    internal global::Std.Vector.__Internal Templates;

                    [FieldOffset(344)]
                    internal global::Std.Vector.__Internal Typedefs;

                    [FieldOffset(368)]
                    internal global::Std.Vector.__Internal TypeAliases;

                    [FieldOffset(392)]
                    internal global::Std.Vector.__Internal Variables;

                    [FieldOffset(416)]
                    internal global::Std.Vector.__Internal Friends;

                    [FieldOffset(440)]
                    internal global::Std.Map.__Internal anonymous;

                    [FieldOffset(456)]
                    internal byte isAnonymous;

                    [FieldOffset(464)]
                    internal global::Std.Vector.__Internal Bases;

                    [FieldOffset(488)]
                    internal global::Std.Vector.__Internal Fields;

                    [FieldOffset(512)]
                    internal global::Std.Vector.__Internal Methods;

                    [FieldOffset(536)]
                    internal global::Std.Vector.__Internal Specifiers;

                    [FieldOffset(560)]
                    internal byte isPOD;

                    [FieldOffset(561)]
                    internal byte isAbstract;

                    [FieldOffset(562)]
                    internal byte isUnion;

                    [FieldOffset(563)]
                    internal byte isDynamic;

                    [FieldOffset(564)]
                    internal byte isPolymorphic;

                    [FieldOffset(565)]
                    internal byte hasNonTrivialDefaultConstructor;

                    [FieldOffset(566)]
                    internal byte hasNonTrivialCopyConstructor;

                    [FieldOffset(567)]
                    internal byte hasNonTrivialDestructor;

                    [FieldOffset(568)]
                    internal byte isExternCContext;

                    [FieldOffset(569)]
                    internal byte isInjected;

                    [FieldOffset(576)]
                    internal global::System.IntPtr layout;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0Class@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0Class@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1Class@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor(global::System.IntPtr instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getBases@Class@AST@CppParser@CppSharp@@QEAAPEAUBaseClassSpecifier@234@I@Z")]
                    internal static extern global::System.IntPtr GetBases(global::System.IntPtr instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?addBases@Class@AST@CppParser@CppSharp@@QEAAXAEAPEAUBaseClassSpecifier@234@@Z")]
                    internal static extern void AddBases(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?clearBases@Class@AST@CppParser@CppSharp@@QEAAXXZ")]
                    internal static extern void ClearBases(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getFields@Class@AST@CppParser@CppSharp@@QEAAPEAVField@234@I@Z")]
                    internal static extern global::System.IntPtr GetFields(global::System.IntPtr instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?addFields@Class@AST@CppParser@CppSharp@@QEAAXAEAPEAVField@234@@Z")]
                    internal static extern void AddFields(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?clearFields@Class@AST@CppParser@CppSharp@@QEAAXXZ")]
                    internal static extern void ClearFields(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getMethods@Class@AST@CppParser@CppSharp@@QEAAPEAVMethod@234@I@Z")]
                    internal static extern global::System.IntPtr GetMethods(global::System.IntPtr instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?addMethods@Class@AST@CppParser@CppSharp@@QEAAXAEAPEAVMethod@234@@Z")]
                    internal static extern void AddMethods(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?clearMethods@Class@AST@CppParser@CppSharp@@QEAAXXZ")]
                    internal static extern void ClearMethods(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getSpecifiers@Class@AST@CppParser@CppSharp@@QEAAPEAVAccessSpecifierDecl@234@I@Z")]
                    internal static extern global::System.IntPtr GetSpecifiers(global::System.IntPtr instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?addSpecifiers@Class@AST@CppParser@CppSharp@@QEAAXAEAPEAVAccessSpecifierDecl@234@@Z")]
                    internal static extern void AddSpecifiers(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?clearSpecifiers@Class@AST@CppParser@CppSharp@@QEAAXXZ")]
                    internal static extern void ClearSpecifiers(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getBasesCount@Class@AST@CppParser@CppSharp@@QEAAIXZ")]
                    internal static extern uint GetBasesCount(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getFieldsCount@Class@AST@CppParser@CppSharp@@QEAAIXZ")]
                    internal static extern uint GetFieldsCount(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getMethodsCount@Class@AST@CppParser@CppSharp@@QEAAIXZ")]
                    internal static extern uint GetMethodsCount(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getSpecifiersCount@Class@AST@CppParser@CppSharp@@QEAAIXZ")]
                    internal static extern uint GetSpecifiersCount(global::System.IntPtr instance);
                }

                internal static new global::CppSharp.Parser.AST.Class __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.Class(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.Class __CreateInstance(global::CppSharp.Parser.AST.Class.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.Class(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.Class.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Class.__Internal));
                    global::CppSharp.Parser.AST.Class.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private Class(global::CppSharp.Parser.AST.Class.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected Class(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public Class()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Class.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment));
                }

                public Class(global::CppSharp.Parser.AST.Class _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Class.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Declaration __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.BaseClassSpecifier GetBases(uint i)
                {
                    var __ret = __Internal.GetBases((__Instance + __PointerAdjustment), i);
                    global::CppSharp.Parser.AST.BaseClassSpecifier __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.BaseClassSpecifier.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::CppSharp.Parser.AST.BaseClassSpecifier) global::CppSharp.Parser.AST.BaseClassSpecifier.NativeToManagedMap[__ret];
                    else __result0 = global::CppSharp.Parser.AST.BaseClassSpecifier.__CreateInstance(__ret);
                    return __result0;
                }

                public void AddBases(global::CppSharp.Parser.AST.BaseClassSpecifier s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    __Internal.AddBases((__Instance + __PointerAdjustment), __arg0);
                }

                public void ClearBases()
                {
                    __Internal.ClearBases((__Instance + __PointerAdjustment));
                }

                public global::CppSharp.Parser.AST.Field GetFields(uint i)
                {
                    var __ret = __Internal.GetFields((__Instance + __PointerAdjustment), i);
                    global::CppSharp.Parser.AST.Field __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.Field.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::CppSharp.Parser.AST.Field) global::CppSharp.Parser.AST.Field.NativeToManagedMap[__ret];
                    else __result0 = global::CppSharp.Parser.AST.Field.__CreateInstance(__ret);
                    return __result0;
                }

                public void AddFields(global::CppSharp.Parser.AST.Field s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    __Internal.AddFields((__Instance + __PointerAdjustment), __arg0);
                }

                public void ClearFields()
                {
                    __Internal.ClearFields((__Instance + __PointerAdjustment));
                }

                public global::CppSharp.Parser.AST.Method GetMethods(uint i)
                {
                    var __ret = __Internal.GetMethods((__Instance + __PointerAdjustment), i);
                    global::CppSharp.Parser.AST.Method __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.Method.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::CppSharp.Parser.AST.Method) global::CppSharp.Parser.AST.Method.NativeToManagedMap[__ret];
                    else __result0 = global::CppSharp.Parser.AST.Method.__CreateInstance(__ret);
                    return __result0;
                }

                public void AddMethods(global::CppSharp.Parser.AST.Method s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    __Internal.AddMethods((__Instance + __PointerAdjustment), __arg0);
                }

                public void ClearMethods()
                {
                    __Internal.ClearMethods((__Instance + __PointerAdjustment));
                }

                public global::CppSharp.Parser.AST.AccessSpecifierDecl GetSpecifiers(uint i)
                {
                    var __ret = __Internal.GetSpecifiers((__Instance + __PointerAdjustment), i);
                    global::CppSharp.Parser.AST.AccessSpecifierDecl __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.AccessSpecifierDecl.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::CppSharp.Parser.AST.AccessSpecifierDecl) global::CppSharp.Parser.AST.AccessSpecifierDecl.NativeToManagedMap[__ret];
                    else __result0 = global::CppSharp.Parser.AST.AccessSpecifierDecl.__CreateInstance(__ret);
                    return __result0;
                }

                public void AddSpecifiers(global::CppSharp.Parser.AST.AccessSpecifierDecl s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    __Internal.AddSpecifiers((__Instance + __PointerAdjustment), __arg0);
                }

                public void ClearSpecifiers()
                {
                    __Internal.ClearSpecifiers((__Instance + __PointerAdjustment));
                }

                public bool IsPOD
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Class.__Internal*) __Instance)->isPOD != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Class.__Internal*) __Instance)->isPOD = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsAbstract
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Class.__Internal*) __Instance)->isAbstract != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Class.__Internal*) __Instance)->isAbstract = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsUnion
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Class.__Internal*) __Instance)->isUnion != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Class.__Internal*) __Instance)->isUnion = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsDynamic
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Class.__Internal*) __Instance)->isDynamic != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Class.__Internal*) __Instance)->isDynamic = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsPolymorphic
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Class.__Internal*) __Instance)->isPolymorphic != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Class.__Internal*) __Instance)->isPolymorphic = (byte) (value ? 1 : 0);
                    }
                }

                public bool HasNonTrivialDefaultConstructor
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Class.__Internal*) __Instance)->hasNonTrivialDefaultConstructor != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Class.__Internal*) __Instance)->hasNonTrivialDefaultConstructor = (byte) (value ? 1 : 0);
                    }
                }

                public bool HasNonTrivialCopyConstructor
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Class.__Internal*) __Instance)->hasNonTrivialCopyConstructor != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Class.__Internal*) __Instance)->hasNonTrivialCopyConstructor = (byte) (value ? 1 : 0);
                    }
                }

                public bool HasNonTrivialDestructor
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Class.__Internal*) __Instance)->hasNonTrivialDestructor != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Class.__Internal*) __Instance)->hasNonTrivialDestructor = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsExternCContext
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Class.__Internal*) __Instance)->isExternCContext != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Class.__Internal*) __Instance)->isExternCContext = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsInjected
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Class.__Internal*) __Instance)->isInjected != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Class.__Internal*) __Instance)->isInjected = (byte) (value ? 1 : 0);
                    }
                }

                public global::CppSharp.Parser.AST.ClassLayout Layout
                {
                    get
                    {
                        global::CppSharp.Parser.AST.ClassLayout __result0;
                        if (((global::CppSharp.Parser.AST.Class.__Internal*) __Instance)->layout == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.ClassLayout.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.Class.__Internal*) __Instance)->layout))
                            __result0 = (global::CppSharp.Parser.AST.ClassLayout) global::CppSharp.Parser.AST.ClassLayout.NativeToManagedMap[((global::CppSharp.Parser.AST.Class.__Internal*) __Instance)->layout];
                        else __result0 = global::CppSharp.Parser.AST.ClassLayout.__CreateInstance(((global::CppSharp.Parser.AST.Class.__Internal*) __Instance)->layout);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Class.__Internal*) __Instance)->layout = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public uint BasesCount
                {
                    get
                    {
                        var __ret = __Internal.GetBasesCount((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                public uint FieldsCount
                {
                    get
                    {
                        var __ret = __Internal.GetFieldsCount((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                public uint MethodsCount
                {
                    get
                    {
                        var __ret = __Internal.GetMethodsCount((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                public uint SpecifiersCount
                {
                    get
                    {
                        var __ret = __Internal.GetSpecifiersCount((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }
            }

            public unsafe partial class Template : global::CppSharp.Parser.AST.Declaration, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 256)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.DeclarationKind kind;

                    [FieldOffset(4)]
                    internal int maxFieldAlignment;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.AccessSpecifier access;

                    [FieldOffset(16)]
                    internal global::System.IntPtr _namespace;

                    [FieldOffset(24)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal location;

                    [FieldOffset(28)]
                    internal int lineNumberStart;

                    [FieldOffset(32)]
                    internal int lineNumberEnd;

                    [FieldOffset(40)]
                    internal global::Std.BasicString.__Internal name;

                    [FieldOffset(72)]
                    internal global::Std.BasicString.__Internal USR;

                    [FieldOffset(104)]
                    internal global::Std.BasicString.__Internal debugText;

                    [FieldOffset(136)]
                    internal byte isIncomplete;

                    [FieldOffset(137)]
                    internal byte isDependent;

                    [FieldOffset(138)]
                    internal byte isImplicit;

                    [FieldOffset(144)]
                    internal global::System.IntPtr completeDeclaration;

                    [FieldOffset(152)]
                    internal uint definitionOrder;

                    [FieldOffset(160)]
                    internal global::Std.Vector.__Internal PreprocessedEntities;

                    [FieldOffset(184)]
                    internal global::Std.Vector.__Internal Redeclarations;

                    [FieldOffset(208)]
                    internal global::System.IntPtr originalPtr;

                    [FieldOffset(216)]
                    internal global::System.IntPtr comment;

                    [FieldOffset(224)]
                    internal global::System.IntPtr TemplatedDecl;

                    [FieldOffset(232)]
                    internal global::Std.Vector.__Internal Parameters;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0Template@AST@CppParser@CppSharp@@QEAA@W4DeclarationKind@123@@Z")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::CppSharp.Parser.AST.DeclarationKind kind);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0Template@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0Template@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1Template@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor(global::System.IntPtr instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getParameters@Template@AST@CppParser@CppSharp@@QEAAPEAVDeclaration@234@I@Z")]
                    internal static extern global::System.IntPtr GetParameters(global::System.IntPtr instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?addParameters@Template@AST@CppParser@CppSharp@@QEAAXAEAPEAVDeclaration@234@@Z")]
                    internal static extern void AddParameters(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?clearParameters@Template@AST@CppParser@CppSharp@@QEAAXXZ")]
                    internal static extern void ClearParameters(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getParametersCount@Template@AST@CppParser@CppSharp@@QEAAIXZ")]
                    internal static extern uint GetParametersCount(global::System.IntPtr instance);
                }

                internal static new global::CppSharp.Parser.AST.Template __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.Template(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.Template __CreateInstance(global::CppSharp.Parser.AST.Template.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.Template(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.Template.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Template.__Internal));
                    global::CppSharp.Parser.AST.Template.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private Template(global::CppSharp.Parser.AST.Template.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected Template(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public Template(global::CppSharp.Parser.AST.DeclarationKind kind)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Template.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment), kind);
                }

                public Template()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Template.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment));
                }

                public Template(global::CppSharp.Parser.AST.Template _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Template.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Declaration __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.Declaration GetParameters(uint i)
                {
                    var __ret = __Internal.GetParameters((__Instance + __PointerAdjustment), i);
                    global::CppSharp.Parser.AST.Declaration __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.Declaration.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::CppSharp.Parser.AST.Declaration) global::CppSharp.Parser.AST.Declaration.NativeToManagedMap[__ret];
                    else __result0 = global::CppSharp.Parser.AST.Declaration.__CreateInstance(__ret);
                    return __result0;
                }

                public void AddParameters(global::CppSharp.Parser.AST.Declaration s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    __Internal.AddParameters((__Instance + __PointerAdjustment), __arg0);
                }

                public void ClearParameters()
                {
                    __Internal.ClearParameters((__Instance + __PointerAdjustment));
                }

                public static implicit operator global::CppSharp.Parser.AST.Template(global::CppSharp.Parser.AST.DeclarationKind kind)
                {
                    return new global::CppSharp.Parser.AST.Template(kind);
                }

                public global::CppSharp.Parser.AST.Declaration TemplatedDecl
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Declaration __result0;
                        if (((global::CppSharp.Parser.AST.Template.__Internal*) __Instance)->TemplatedDecl == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Declaration.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.Template.__Internal*) __Instance)->TemplatedDecl))
                            __result0 = (global::CppSharp.Parser.AST.Declaration) global::CppSharp.Parser.AST.Declaration.NativeToManagedMap[((global::CppSharp.Parser.AST.Template.__Internal*) __Instance)->TemplatedDecl];
                        else __result0 = global::CppSharp.Parser.AST.Declaration.__CreateInstance(((global::CppSharp.Parser.AST.Template.__Internal*) __Instance)->TemplatedDecl);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Template.__Internal*) __Instance)->TemplatedDecl = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public uint ParametersCount
                {
                    get
                    {
                        var __ret = __Internal.GetParametersCount((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }
            }

            public unsafe partial class TypeAliasTemplate : global::CppSharp.Parser.AST.Template, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 256)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.DeclarationKind kind;

                    [FieldOffset(4)]
                    internal int maxFieldAlignment;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.AccessSpecifier access;

                    [FieldOffset(16)]
                    internal global::System.IntPtr _namespace;

                    [FieldOffset(24)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal location;

                    [FieldOffset(28)]
                    internal int lineNumberStart;

                    [FieldOffset(32)]
                    internal int lineNumberEnd;

                    [FieldOffset(40)]
                    internal global::Std.BasicString.__Internal name;

                    [FieldOffset(72)]
                    internal global::Std.BasicString.__Internal USR;

                    [FieldOffset(104)]
                    internal global::Std.BasicString.__Internal debugText;

                    [FieldOffset(136)]
                    internal byte isIncomplete;

                    [FieldOffset(137)]
                    internal byte isDependent;

                    [FieldOffset(138)]
                    internal byte isImplicit;

                    [FieldOffset(144)]
                    internal global::System.IntPtr completeDeclaration;

                    [FieldOffset(152)]
                    internal uint definitionOrder;

                    [FieldOffset(160)]
                    internal global::Std.Vector.__Internal PreprocessedEntities;

                    [FieldOffset(184)]
                    internal global::Std.Vector.__Internal Redeclarations;

                    [FieldOffset(208)]
                    internal global::System.IntPtr originalPtr;

                    [FieldOffset(216)]
                    internal global::System.IntPtr comment;

                    [FieldOffset(224)]
                    internal global::System.IntPtr TemplatedDecl;

                    [FieldOffset(232)]
                    internal global::Std.Vector.__Internal Parameters;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0TypeAliasTemplate@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0TypeAliasTemplate@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1TypeAliasTemplate@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor(global::System.IntPtr instance, int delete);
                }

                internal static new global::CppSharp.Parser.AST.TypeAliasTemplate __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.TypeAliasTemplate(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.TypeAliasTemplate __CreateInstance(global::CppSharp.Parser.AST.TypeAliasTemplate.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.TypeAliasTemplate(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.TypeAliasTemplate.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TypeAliasTemplate.__Internal));
                    global::CppSharp.Parser.AST.TypeAliasTemplate.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private TypeAliasTemplate(global::CppSharp.Parser.AST.TypeAliasTemplate.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected TypeAliasTemplate(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public TypeAliasTemplate()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TypeAliasTemplate.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment));
                }

                public TypeAliasTemplate(global::CppSharp.Parser.AST.TypeAliasTemplate _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TypeAliasTemplate.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Declaration __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }
            }

            public unsafe partial class TemplateParameter : global::CppSharp.Parser.AST.Declaration, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 240)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.DeclarationKind kind;

                    [FieldOffset(4)]
                    internal int maxFieldAlignment;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.AccessSpecifier access;

                    [FieldOffset(16)]
                    internal global::System.IntPtr _namespace;

                    [FieldOffset(24)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal location;

                    [FieldOffset(28)]
                    internal int lineNumberStart;

                    [FieldOffset(32)]
                    internal int lineNumberEnd;

                    [FieldOffset(40)]
                    internal global::Std.BasicString.__Internal name;

                    [FieldOffset(72)]
                    internal global::Std.BasicString.__Internal USR;

                    [FieldOffset(104)]
                    internal global::Std.BasicString.__Internal debugText;

                    [FieldOffset(136)]
                    internal byte isIncomplete;

                    [FieldOffset(137)]
                    internal byte isDependent;

                    [FieldOffset(138)]
                    internal byte isImplicit;

                    [FieldOffset(144)]
                    internal global::System.IntPtr completeDeclaration;

                    [FieldOffset(152)]
                    internal uint definitionOrder;

                    [FieldOffset(160)]
                    internal global::Std.Vector.__Internal PreprocessedEntities;

                    [FieldOffset(184)]
                    internal global::Std.Vector.__Internal Redeclarations;

                    [FieldOffset(208)]
                    internal global::System.IntPtr originalPtr;

                    [FieldOffset(216)]
                    internal global::System.IntPtr comment;

                    [FieldOffset(224)]
                    internal uint depth;

                    [FieldOffset(228)]
                    internal uint index;

                    [FieldOffset(232)]
                    internal byte isParameterPack;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0TemplateParameter@AST@CppParser@CppSharp@@QEAA@W4DeclarationKind@123@@Z")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::CppSharp.Parser.AST.DeclarationKind kind);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0TemplateParameter@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1TemplateParameter@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor(global::System.IntPtr instance, int delete);
                }

                internal static new global::CppSharp.Parser.AST.TemplateParameter __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.TemplateParameter(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.TemplateParameter __CreateInstance(global::CppSharp.Parser.AST.TemplateParameter.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.TemplateParameter(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.TemplateParameter.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TemplateParameter.__Internal));
                    global::CppSharp.Parser.AST.TemplateParameter.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private TemplateParameter(global::CppSharp.Parser.AST.TemplateParameter.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected TemplateParameter(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public TemplateParameter(global::CppSharp.Parser.AST.DeclarationKind kind)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TemplateParameter.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment), kind);
                }

                public TemplateParameter(global::CppSharp.Parser.AST.TemplateParameter _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TemplateParameter.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Declaration __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public static implicit operator global::CppSharp.Parser.AST.TemplateParameter(global::CppSharp.Parser.AST.DeclarationKind kind)
                {
                    return new global::CppSharp.Parser.AST.TemplateParameter(kind);
                }

                public uint Depth
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.TemplateParameter.__Internal*) __Instance)->depth;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.TemplateParameter.__Internal*) __Instance)->depth = value;
                    }
                }

                public uint Index
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.TemplateParameter.__Internal*) __Instance)->index;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.TemplateParameter.__Internal*) __Instance)->index = value;
                    }
                }

                public bool IsParameterPack
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.TemplateParameter.__Internal*) __Instance)->isParameterPack != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.TemplateParameter.__Internal*) __Instance)->isParameterPack = (byte) (value ? 1 : 0);
                    }
                }
            }

            public unsafe partial class TemplateTemplateParameter : global::CppSharp.Parser.AST.Template, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 264)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.DeclarationKind kind;

                    [FieldOffset(4)]
                    internal int maxFieldAlignment;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.AccessSpecifier access;

                    [FieldOffset(16)]
                    internal global::System.IntPtr _namespace;

                    [FieldOffset(24)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal location;

                    [FieldOffset(28)]
                    internal int lineNumberStart;

                    [FieldOffset(32)]
                    internal int lineNumberEnd;

                    [FieldOffset(40)]
                    internal global::Std.BasicString.__Internal name;

                    [FieldOffset(72)]
                    internal global::Std.BasicString.__Internal USR;

                    [FieldOffset(104)]
                    internal global::Std.BasicString.__Internal debugText;

                    [FieldOffset(136)]
                    internal byte isIncomplete;

                    [FieldOffset(137)]
                    internal byte isDependent;

                    [FieldOffset(138)]
                    internal byte isImplicit;

                    [FieldOffset(144)]
                    internal global::System.IntPtr completeDeclaration;

                    [FieldOffset(152)]
                    internal uint definitionOrder;

                    [FieldOffset(160)]
                    internal global::Std.Vector.__Internal PreprocessedEntities;

                    [FieldOffset(184)]
                    internal global::Std.Vector.__Internal Redeclarations;

                    [FieldOffset(208)]
                    internal global::System.IntPtr originalPtr;

                    [FieldOffset(216)]
                    internal global::System.IntPtr comment;

                    [FieldOffset(224)]
                    internal global::System.IntPtr TemplatedDecl;

                    [FieldOffset(232)]
                    internal global::Std.Vector.__Internal Parameters;

                    [FieldOffset(256)]
                    internal byte isParameterPack;

                    [FieldOffset(257)]
                    internal byte isPackExpansion;

                    [FieldOffset(258)]
                    internal byte isExpandedParameterPack;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0TemplateTemplateParameter@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0TemplateTemplateParameter@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1TemplateTemplateParameter@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor(global::System.IntPtr instance, int delete);
                }

                internal static new global::CppSharp.Parser.AST.TemplateTemplateParameter __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.TemplateTemplateParameter(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.TemplateTemplateParameter __CreateInstance(global::CppSharp.Parser.AST.TemplateTemplateParameter.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.TemplateTemplateParameter(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.TemplateTemplateParameter.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TemplateTemplateParameter.__Internal));
                    global::CppSharp.Parser.AST.TemplateTemplateParameter.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private TemplateTemplateParameter(global::CppSharp.Parser.AST.TemplateTemplateParameter.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected TemplateTemplateParameter(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public TemplateTemplateParameter()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TemplateTemplateParameter.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment));
                }

                public TemplateTemplateParameter(global::CppSharp.Parser.AST.TemplateTemplateParameter _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TemplateTemplateParameter.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Declaration __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public bool IsParameterPack
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.TemplateTemplateParameter.__Internal*) __Instance)->isParameterPack != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.TemplateTemplateParameter.__Internal*) __Instance)->isParameterPack = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsPackExpansion
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.TemplateTemplateParameter.__Internal*) __Instance)->isPackExpansion != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.TemplateTemplateParameter.__Internal*) __Instance)->isPackExpansion = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsExpandedParameterPack
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.TemplateTemplateParameter.__Internal*) __Instance)->isExpandedParameterPack != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.TemplateTemplateParameter.__Internal*) __Instance)->isExpandedParameterPack = (byte) (value ? 1 : 0);
                    }
                }
            }

            public unsafe partial class TypeTemplateParameter : global::CppSharp.Parser.AST.TemplateParameter, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 256)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.DeclarationKind kind;

                    [FieldOffset(4)]
                    internal int maxFieldAlignment;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.AccessSpecifier access;

                    [FieldOffset(16)]
                    internal global::System.IntPtr _namespace;

                    [FieldOffset(24)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal location;

                    [FieldOffset(28)]
                    internal int lineNumberStart;

                    [FieldOffset(32)]
                    internal int lineNumberEnd;

                    [FieldOffset(40)]
                    internal global::Std.BasicString.__Internal name;

                    [FieldOffset(72)]
                    internal global::Std.BasicString.__Internal USR;

                    [FieldOffset(104)]
                    internal global::Std.BasicString.__Internal debugText;

                    [FieldOffset(136)]
                    internal byte isIncomplete;

                    [FieldOffset(137)]
                    internal byte isDependent;

                    [FieldOffset(138)]
                    internal byte isImplicit;

                    [FieldOffset(144)]
                    internal global::System.IntPtr completeDeclaration;

                    [FieldOffset(152)]
                    internal uint definitionOrder;

                    [FieldOffset(160)]
                    internal global::Std.Vector.__Internal PreprocessedEntities;

                    [FieldOffset(184)]
                    internal global::Std.Vector.__Internal Redeclarations;

                    [FieldOffset(208)]
                    internal global::System.IntPtr originalPtr;

                    [FieldOffset(216)]
                    internal global::System.IntPtr comment;

                    [FieldOffset(224)]
                    internal uint depth;

                    [FieldOffset(228)]
                    internal uint index;

                    [FieldOffset(232)]
                    internal byte isParameterPack;

                    [FieldOffset(240)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal defaultArgument;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0TypeTemplateParameter@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0TypeTemplateParameter@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1TypeTemplateParameter@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor(global::System.IntPtr instance, int delete);
                }

                internal static new global::CppSharp.Parser.AST.TypeTemplateParameter __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.TypeTemplateParameter(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.TypeTemplateParameter __CreateInstance(global::CppSharp.Parser.AST.TypeTemplateParameter.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.TypeTemplateParameter(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.TypeTemplateParameter.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TypeTemplateParameter.__Internal));
                    global::CppSharp.Parser.AST.TypeTemplateParameter.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private TypeTemplateParameter(global::CppSharp.Parser.AST.TypeTemplateParameter.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected TypeTemplateParameter(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public TypeTemplateParameter()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TypeTemplateParameter.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment));
                }

                public TypeTemplateParameter(global::CppSharp.Parser.AST.TypeTemplateParameter _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TypeTemplateParameter.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Declaration __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.QualifiedType DefaultArgument
                {
                    get
                    {
                        return global::CppSharp.Parser.AST.QualifiedType.__CreateInstance(((global::CppSharp.Parser.AST.TypeTemplateParameter.__Internal*) __Instance)->defaultArgument);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.TypeTemplateParameter.__Internal*) __Instance)->defaultArgument = ReferenceEquals(value, null) ? new global::CppSharp.Parser.AST.QualifiedType.__Internal() : *(global::CppSharp.Parser.AST.QualifiedType.__Internal*) value.__Instance;
                    }
                }
            }

            public unsafe partial class NonTypeTemplateParameter : global::CppSharp.Parser.AST.TemplateParameter, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 256)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.DeclarationKind kind;

                    [FieldOffset(4)]
                    internal int maxFieldAlignment;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.AccessSpecifier access;

                    [FieldOffset(16)]
                    internal global::System.IntPtr _namespace;

                    [FieldOffset(24)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal location;

                    [FieldOffset(28)]
                    internal int lineNumberStart;

                    [FieldOffset(32)]
                    internal int lineNumberEnd;

                    [FieldOffset(40)]
                    internal global::Std.BasicString.__Internal name;

                    [FieldOffset(72)]
                    internal global::Std.BasicString.__Internal USR;

                    [FieldOffset(104)]
                    internal global::Std.BasicString.__Internal debugText;

                    [FieldOffset(136)]
                    internal byte isIncomplete;

                    [FieldOffset(137)]
                    internal byte isDependent;

                    [FieldOffset(138)]
                    internal byte isImplicit;

                    [FieldOffset(144)]
                    internal global::System.IntPtr completeDeclaration;

                    [FieldOffset(152)]
                    internal uint definitionOrder;

                    [FieldOffset(160)]
                    internal global::Std.Vector.__Internal PreprocessedEntities;

                    [FieldOffset(184)]
                    internal global::Std.Vector.__Internal Redeclarations;

                    [FieldOffset(208)]
                    internal global::System.IntPtr originalPtr;

                    [FieldOffset(216)]
                    internal global::System.IntPtr comment;

                    [FieldOffset(224)]
                    internal uint depth;

                    [FieldOffset(228)]
                    internal uint index;

                    [FieldOffset(232)]
                    internal byte isParameterPack;

                    [FieldOffset(240)]
                    internal global::System.IntPtr defaultArgument;

                    [FieldOffset(248)]
                    internal uint position;

                    [FieldOffset(252)]
                    internal byte isPackExpansion;

                    [FieldOffset(253)]
                    internal byte isExpandedParameterPack;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0NonTypeTemplateParameter@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0NonTypeTemplateParameter@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1NonTypeTemplateParameter@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor(global::System.IntPtr instance, int delete);
                }

                internal static new global::CppSharp.Parser.AST.NonTypeTemplateParameter __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.NonTypeTemplateParameter(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.NonTypeTemplateParameter __CreateInstance(global::CppSharp.Parser.AST.NonTypeTemplateParameter.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.NonTypeTemplateParameter(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.NonTypeTemplateParameter.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.NonTypeTemplateParameter.__Internal));
                    global::CppSharp.Parser.AST.NonTypeTemplateParameter.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private NonTypeTemplateParameter(global::CppSharp.Parser.AST.NonTypeTemplateParameter.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected NonTypeTemplateParameter(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public NonTypeTemplateParameter()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.NonTypeTemplateParameter.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment));
                }

                public NonTypeTemplateParameter(global::CppSharp.Parser.AST.NonTypeTemplateParameter _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.NonTypeTemplateParameter.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Declaration __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.Expression DefaultArgument
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expression __result0;
                        if (((global::CppSharp.Parser.AST.NonTypeTemplateParameter.__Internal*) __Instance)->defaultArgument == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expression.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.NonTypeTemplateParameter.__Internal*) __Instance)->defaultArgument))
                            __result0 = (global::CppSharp.Parser.AST.Expression) global::CppSharp.Parser.AST.Expression.NativeToManagedMap[((global::CppSharp.Parser.AST.NonTypeTemplateParameter.__Internal*) __Instance)->defaultArgument];
                        else __result0 = global::CppSharp.Parser.AST.Expression.__CreateInstance(((global::CppSharp.Parser.AST.NonTypeTemplateParameter.__Internal*) __Instance)->defaultArgument);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.NonTypeTemplateParameter.__Internal*) __Instance)->defaultArgument = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public uint Position
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.NonTypeTemplateParameter.__Internal*) __Instance)->position;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.NonTypeTemplateParameter.__Internal*) __Instance)->position = value;
                    }
                }

                public bool IsPackExpansion
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.NonTypeTemplateParameter.__Internal*) __Instance)->isPackExpansion != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.NonTypeTemplateParameter.__Internal*) __Instance)->isPackExpansion = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsExpandedParameterPack
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.NonTypeTemplateParameter.__Internal*) __Instance)->isExpandedParameterPack != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.NonTypeTemplateParameter.__Internal*) __Instance)->isExpandedParameterPack = (byte) (value ? 1 : 0);
                    }
                }
            }

            public unsafe partial class ClassTemplate : global::CppSharp.Parser.AST.Template, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 280)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.DeclarationKind kind;

                    [FieldOffset(4)]
                    internal int maxFieldAlignment;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.AccessSpecifier access;

                    [FieldOffset(16)]
                    internal global::System.IntPtr _namespace;

                    [FieldOffset(24)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal location;

                    [FieldOffset(28)]
                    internal int lineNumberStart;

                    [FieldOffset(32)]
                    internal int lineNumberEnd;

                    [FieldOffset(40)]
                    internal global::Std.BasicString.__Internal name;

                    [FieldOffset(72)]
                    internal global::Std.BasicString.__Internal USR;

                    [FieldOffset(104)]
                    internal global::Std.BasicString.__Internal debugText;

                    [FieldOffset(136)]
                    internal byte isIncomplete;

                    [FieldOffset(137)]
                    internal byte isDependent;

                    [FieldOffset(138)]
                    internal byte isImplicit;

                    [FieldOffset(144)]
                    internal global::System.IntPtr completeDeclaration;

                    [FieldOffset(152)]
                    internal uint definitionOrder;

                    [FieldOffset(160)]
                    internal global::Std.Vector.__Internal PreprocessedEntities;

                    [FieldOffset(184)]
                    internal global::Std.Vector.__Internal Redeclarations;

                    [FieldOffset(208)]
                    internal global::System.IntPtr originalPtr;

                    [FieldOffset(216)]
                    internal global::System.IntPtr comment;

                    [FieldOffset(224)]
                    internal global::System.IntPtr TemplatedDecl;

                    [FieldOffset(232)]
                    internal global::Std.Vector.__Internal Parameters;

                    [FieldOffset(256)]
                    internal global::Std.Vector.__Internal Specializations;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0ClassTemplate@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0ClassTemplate@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1ClassTemplate@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor(global::System.IntPtr instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getSpecializations@ClassTemplate@AST@CppParser@CppSharp@@QEAAPEAVClassTemplateSpecialization@234@I@Z")]
                    internal static extern global::System.IntPtr GetSpecializations(global::System.IntPtr instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?addSpecializations@ClassTemplate@AST@CppParser@CppSharp@@QEAAXAEAPEAVClassTemplateSpecialization@234@@Z")]
                    internal static extern void AddSpecializations(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?clearSpecializations@ClassTemplate@AST@CppParser@CppSharp@@QEAAXXZ")]
                    internal static extern void ClearSpecializations(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?FindSpecialization@ClassTemplate@AST@CppParser@CppSharp@@QEAAPEAVClassTemplateSpecialization@234@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
                    internal static extern global::System.IntPtr FindSpecialization(global::System.IntPtr instance, global::System.IntPtr usr);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?FindPartialSpecialization@ClassTemplate@AST@CppParser@CppSharp@@QEAAPEAVClassTemplatePartialSpecialization@234@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
                    internal static extern global::System.IntPtr FindPartialSpecialization(global::System.IntPtr instance, global::System.IntPtr usr);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getSpecializationsCount@ClassTemplate@AST@CppParser@CppSharp@@QEAAIXZ")]
                    internal static extern uint GetSpecializationsCount(global::System.IntPtr instance);
                }

                internal static new global::CppSharp.Parser.AST.ClassTemplate __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.ClassTemplate(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.ClassTemplate __CreateInstance(global::CppSharp.Parser.AST.ClassTemplate.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.ClassTemplate(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.ClassTemplate.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ClassTemplate.__Internal));
                    global::CppSharp.Parser.AST.ClassTemplate.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private ClassTemplate(global::CppSharp.Parser.AST.ClassTemplate.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected ClassTemplate(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public ClassTemplate()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ClassTemplate.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment));
                }

                public ClassTemplate(global::CppSharp.Parser.AST.ClassTemplate _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ClassTemplate.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Declaration __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.ClassTemplateSpecialization GetSpecializations(uint i)
                {
                    var __ret = __Internal.GetSpecializations((__Instance + __PointerAdjustment), i);
                    global::CppSharp.Parser.AST.ClassTemplateSpecialization __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.ClassTemplateSpecialization.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::CppSharp.Parser.AST.ClassTemplateSpecialization) global::CppSharp.Parser.AST.ClassTemplateSpecialization.NativeToManagedMap[__ret];
                    else __result0 = global::CppSharp.Parser.AST.ClassTemplateSpecialization.__CreateInstance(__ret);
                    return __result0;
                }

                public void AddSpecializations(global::CppSharp.Parser.AST.ClassTemplateSpecialization s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    __Internal.AddSpecializations((__Instance + __PointerAdjustment), __arg0);
                }

                public void ClearSpecializations()
                {
                    __Internal.ClearSpecializations((__Instance + __PointerAdjustment));
                }

                public global::CppSharp.Parser.AST.ClassTemplateSpecialization FindSpecialization(string usr)
                {
                    var __allocator0 = new global::Std.Allocator<sbyte>();
                    var __basicString0 = global::Std.BasicStringExtensions.BasicString(usr, __allocator0);
                    var __arg0 = __basicString0.__Instance;
                    var __ret = __Internal.FindSpecialization((__Instance + __PointerAdjustment), __arg0);
                    __basicString0.Dispose(false);
                    __allocator0.Dispose();
                    global::CppSharp.Parser.AST.ClassTemplateSpecialization __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.ClassTemplateSpecialization.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::CppSharp.Parser.AST.ClassTemplateSpecialization) global::CppSharp.Parser.AST.ClassTemplateSpecialization.NativeToManagedMap[__ret];
                    else __result0 = global::CppSharp.Parser.AST.ClassTemplateSpecialization.__CreateInstance(__ret);
                    return __result0;
                }

                public global::CppSharp.Parser.AST.ClassTemplatePartialSpecialization FindPartialSpecialization(string usr)
                {
                    var __allocator0 = new global::Std.Allocator<sbyte>();
                    var __basicString0 = global::Std.BasicStringExtensions.BasicString(usr, __allocator0);
                    var __arg0 = __basicString0.__Instance;
                    var __ret = __Internal.FindPartialSpecialization((__Instance + __PointerAdjustment), __arg0);
                    __basicString0.Dispose(false);
                    __allocator0.Dispose();
                    global::CppSharp.Parser.AST.ClassTemplatePartialSpecialization __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.ClassTemplatePartialSpecialization.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::CppSharp.Parser.AST.ClassTemplatePartialSpecialization) global::CppSharp.Parser.AST.ClassTemplatePartialSpecialization.NativeToManagedMap[__ret];
                    else __result0 = global::CppSharp.Parser.AST.ClassTemplatePartialSpecialization.__CreateInstance(__ret);
                    return __result0;
                }

                public uint SpecializationsCount
                {
                    get
                    {
                        var __ret = __Internal.GetSpecializationsCount((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }
            }

            public unsafe partial class ClassTemplateSpecialization : global::CppSharp.Parser.AST.Class, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 624)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.DeclarationKind kind;

                    [FieldOffset(4)]
                    internal int maxFieldAlignment;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.AccessSpecifier access;

                    [FieldOffset(16)]
                    internal global::System.IntPtr _namespace;

                    [FieldOffset(24)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal location;

                    [FieldOffset(28)]
                    internal int lineNumberStart;

                    [FieldOffset(32)]
                    internal int lineNumberEnd;

                    [FieldOffset(40)]
                    internal global::Std.BasicString.__Internal name;

                    [FieldOffset(72)]
                    internal global::Std.BasicString.__Internal USR;

                    [FieldOffset(104)]
                    internal global::Std.BasicString.__Internal debugText;

                    [FieldOffset(136)]
                    internal byte isIncomplete;

                    [FieldOffset(137)]
                    internal byte isDependent;

                    [FieldOffset(138)]
                    internal byte isImplicit;

                    [FieldOffset(144)]
                    internal global::System.IntPtr completeDeclaration;

                    [FieldOffset(152)]
                    internal uint definitionOrder;

                    [FieldOffset(160)]
                    internal global::Std.Vector.__Internal PreprocessedEntities;

                    [FieldOffset(184)]
                    internal global::Std.Vector.__Internal Redeclarations;

                    [FieldOffset(208)]
                    internal global::System.IntPtr originalPtr;

                    [FieldOffset(216)]
                    internal global::System.IntPtr comment;

                    [FieldOffset(224)]
                    internal global::Std.Vector.__Internal Namespaces;

                    [FieldOffset(248)]
                    internal global::Std.Vector.__Internal Enums;

                    [FieldOffset(272)]
                    internal global::Std.Vector.__Internal Functions;

                    [FieldOffset(296)]
                    internal global::Std.Vector.__Internal Classes;

                    [FieldOffset(320)]
                    internal global::Std.Vector.__Internal Templates;

                    [FieldOffset(344)]
                    internal global::Std.Vector.__Internal Typedefs;

                    [FieldOffset(368)]
                    internal global::Std.Vector.__Internal TypeAliases;

                    [FieldOffset(392)]
                    internal global::Std.Vector.__Internal Variables;

                    [FieldOffset(416)]
                    internal global::Std.Vector.__Internal Friends;

                    [FieldOffset(440)]
                    internal global::Std.Map.__Internal anonymous;

                    [FieldOffset(456)]
                    internal byte isAnonymous;

                    [FieldOffset(464)]
                    internal global::Std.Vector.__Internal Bases;

                    [FieldOffset(488)]
                    internal global::Std.Vector.__Internal Fields;

                    [FieldOffset(512)]
                    internal global::Std.Vector.__Internal Methods;

                    [FieldOffset(536)]
                    internal global::Std.Vector.__Internal Specifiers;

                    [FieldOffset(560)]
                    internal byte isPOD;

                    [FieldOffset(561)]
                    internal byte isAbstract;

                    [FieldOffset(562)]
                    internal byte isUnion;

                    [FieldOffset(563)]
                    internal byte isDynamic;

                    [FieldOffset(564)]
                    internal byte isPolymorphic;

                    [FieldOffset(565)]
                    internal byte hasNonTrivialDefaultConstructor;

                    [FieldOffset(566)]
                    internal byte hasNonTrivialCopyConstructor;

                    [FieldOffset(567)]
                    internal byte hasNonTrivialDestructor;

                    [FieldOffset(568)]
                    internal byte isExternCContext;

                    [FieldOffset(569)]
                    internal byte isInjected;

                    [FieldOffset(576)]
                    internal global::System.IntPtr layout;

                    [FieldOffset(584)]
                    internal global::System.IntPtr templatedDecl;

                    [FieldOffset(592)]
                    internal global::Std.Vector.__Internal Arguments;

                    [FieldOffset(616)]
                    internal global::CppSharp.Parser.AST.TemplateSpecializationKind specializationKind;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0ClassTemplateSpecialization@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0ClassTemplateSpecialization@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1ClassTemplateSpecialization@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor(global::System.IntPtr instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getArguments@ClassTemplateSpecialization@AST@CppParser@CppSharp@@QEAA?AUTemplateArgument@234@I@Z")]
                    internal static extern void GetArguments(global::System.IntPtr instance, global::System.IntPtr @return, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?addArguments@ClassTemplateSpecialization@AST@CppParser@CppSharp@@QEAAXAEAUTemplateArgument@234@@Z")]
                    internal static extern void AddArguments(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?clearArguments@ClassTemplateSpecialization@AST@CppParser@CppSharp@@QEAAXXZ")]
                    internal static extern void ClearArguments(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getArgumentsCount@ClassTemplateSpecialization@AST@CppParser@CppSharp@@QEAAIXZ")]
                    internal static extern uint GetArgumentsCount(global::System.IntPtr instance);
                }

                internal static new global::CppSharp.Parser.AST.ClassTemplateSpecialization __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.ClassTemplateSpecialization(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.ClassTemplateSpecialization __CreateInstance(global::CppSharp.Parser.AST.ClassTemplateSpecialization.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.ClassTemplateSpecialization(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.ClassTemplateSpecialization.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ClassTemplateSpecialization.__Internal));
                    global::CppSharp.Parser.AST.ClassTemplateSpecialization.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private ClassTemplateSpecialization(global::CppSharp.Parser.AST.ClassTemplateSpecialization.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected ClassTemplateSpecialization(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public ClassTemplateSpecialization()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ClassTemplateSpecialization.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment));
                }

                public ClassTemplateSpecialization(global::CppSharp.Parser.AST.ClassTemplateSpecialization _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ClassTemplateSpecialization.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Declaration __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.TemplateArgument GetArguments(uint i)
                {
                    var __ret = new global::CppSharp.Parser.AST.TemplateArgument.__Internal();
                    __Internal.GetArguments((__Instance + __PointerAdjustment), new IntPtr(&__ret), i);
                    return global::CppSharp.Parser.AST.TemplateArgument.__CreateInstance(__ret);
                }

                public void AddArguments(global::CppSharp.Parser.AST.TemplateArgument s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    __Internal.AddArguments((__Instance + __PointerAdjustment), __arg0);
                }

                public void ClearArguments()
                {
                    __Internal.ClearArguments((__Instance + __PointerAdjustment));
                }

                public global::CppSharp.Parser.AST.ClassTemplate TemplatedDecl
                {
                    get
                    {
                        global::CppSharp.Parser.AST.ClassTemplate __result0;
                        if (((global::CppSharp.Parser.AST.ClassTemplateSpecialization.__Internal*) __Instance)->templatedDecl == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.ClassTemplate.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.ClassTemplateSpecialization.__Internal*) __Instance)->templatedDecl))
                            __result0 = (global::CppSharp.Parser.AST.ClassTemplate) global::CppSharp.Parser.AST.ClassTemplate.NativeToManagedMap[((global::CppSharp.Parser.AST.ClassTemplateSpecialization.__Internal*) __Instance)->templatedDecl];
                        else __result0 = global::CppSharp.Parser.AST.ClassTemplate.__CreateInstance(((global::CppSharp.Parser.AST.ClassTemplateSpecialization.__Internal*) __Instance)->templatedDecl);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.ClassTemplateSpecialization.__Internal*) __Instance)->templatedDecl = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.TemplateSpecializationKind SpecializationKind
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.ClassTemplateSpecialization.__Internal*) __Instance)->specializationKind;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.ClassTemplateSpecialization.__Internal*) __Instance)->specializationKind = value;
                    }
                }

                public uint ArgumentsCount
                {
                    get
                    {
                        var __ret = __Internal.GetArgumentsCount((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }
            }

            public unsafe partial class ClassTemplatePartialSpecialization : global::CppSharp.Parser.AST.ClassTemplateSpecialization, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 624)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.DeclarationKind kind;

                    [FieldOffset(4)]
                    internal int maxFieldAlignment;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.AccessSpecifier access;

                    [FieldOffset(16)]
                    internal global::System.IntPtr _namespace;

                    [FieldOffset(24)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal location;

                    [FieldOffset(28)]
                    internal int lineNumberStart;

                    [FieldOffset(32)]
                    internal int lineNumberEnd;

                    [FieldOffset(40)]
                    internal global::Std.BasicString.__Internal name;

                    [FieldOffset(72)]
                    internal global::Std.BasicString.__Internal USR;

                    [FieldOffset(104)]
                    internal global::Std.BasicString.__Internal debugText;

                    [FieldOffset(136)]
                    internal byte isIncomplete;

                    [FieldOffset(137)]
                    internal byte isDependent;

                    [FieldOffset(138)]
                    internal byte isImplicit;

                    [FieldOffset(144)]
                    internal global::System.IntPtr completeDeclaration;

                    [FieldOffset(152)]
                    internal uint definitionOrder;

                    [FieldOffset(160)]
                    internal global::Std.Vector.__Internal PreprocessedEntities;

                    [FieldOffset(184)]
                    internal global::Std.Vector.__Internal Redeclarations;

                    [FieldOffset(208)]
                    internal global::System.IntPtr originalPtr;

                    [FieldOffset(216)]
                    internal global::System.IntPtr comment;

                    [FieldOffset(224)]
                    internal global::Std.Vector.__Internal Namespaces;

                    [FieldOffset(248)]
                    internal global::Std.Vector.__Internal Enums;

                    [FieldOffset(272)]
                    internal global::Std.Vector.__Internal Functions;

                    [FieldOffset(296)]
                    internal global::Std.Vector.__Internal Classes;

                    [FieldOffset(320)]
                    internal global::Std.Vector.__Internal Templates;

                    [FieldOffset(344)]
                    internal global::Std.Vector.__Internal Typedefs;

                    [FieldOffset(368)]
                    internal global::Std.Vector.__Internal TypeAliases;

                    [FieldOffset(392)]
                    internal global::Std.Vector.__Internal Variables;

                    [FieldOffset(416)]
                    internal global::Std.Vector.__Internal Friends;

                    [FieldOffset(440)]
                    internal global::Std.Map.__Internal anonymous;

                    [FieldOffset(456)]
                    internal byte isAnonymous;

                    [FieldOffset(464)]
                    internal global::Std.Vector.__Internal Bases;

                    [FieldOffset(488)]
                    internal global::Std.Vector.__Internal Fields;

                    [FieldOffset(512)]
                    internal global::Std.Vector.__Internal Methods;

                    [FieldOffset(536)]
                    internal global::Std.Vector.__Internal Specifiers;

                    [FieldOffset(560)]
                    internal byte isPOD;

                    [FieldOffset(561)]
                    internal byte isAbstract;

                    [FieldOffset(562)]
                    internal byte isUnion;

                    [FieldOffset(563)]
                    internal byte isDynamic;

                    [FieldOffset(564)]
                    internal byte isPolymorphic;

                    [FieldOffset(565)]
                    internal byte hasNonTrivialDefaultConstructor;

                    [FieldOffset(566)]
                    internal byte hasNonTrivialCopyConstructor;

                    [FieldOffset(567)]
                    internal byte hasNonTrivialDestructor;

                    [FieldOffset(568)]
                    internal byte isExternCContext;

                    [FieldOffset(569)]
                    internal byte isInjected;

                    [FieldOffset(576)]
                    internal global::System.IntPtr layout;

                    [FieldOffset(584)]
                    internal global::System.IntPtr templatedDecl;

                    [FieldOffset(592)]
                    internal global::Std.Vector.__Internal Arguments;

                    [FieldOffset(616)]
                    internal global::CppSharp.Parser.AST.TemplateSpecializationKind specializationKind;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0ClassTemplatePartialSpecialization@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0ClassTemplatePartialSpecialization@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1ClassTemplatePartialSpecialization@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor(global::System.IntPtr instance, int delete);
                }

                internal static new global::CppSharp.Parser.AST.ClassTemplatePartialSpecialization __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.ClassTemplatePartialSpecialization(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.ClassTemplatePartialSpecialization __CreateInstance(global::CppSharp.Parser.AST.ClassTemplatePartialSpecialization.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.ClassTemplatePartialSpecialization(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.ClassTemplatePartialSpecialization.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ClassTemplatePartialSpecialization.__Internal));
                    global::CppSharp.Parser.AST.ClassTemplatePartialSpecialization.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private ClassTemplatePartialSpecialization(global::CppSharp.Parser.AST.ClassTemplatePartialSpecialization.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected ClassTemplatePartialSpecialization(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public ClassTemplatePartialSpecialization()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ClassTemplatePartialSpecialization.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment));
                }

                public ClassTemplatePartialSpecialization(global::CppSharp.Parser.AST.ClassTemplatePartialSpecialization _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ClassTemplatePartialSpecialization.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Declaration __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }
            }

            public unsafe partial class FunctionTemplate : global::CppSharp.Parser.AST.Template, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 280)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.DeclarationKind kind;

                    [FieldOffset(4)]
                    internal int maxFieldAlignment;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.AccessSpecifier access;

                    [FieldOffset(16)]
                    internal global::System.IntPtr _namespace;

                    [FieldOffset(24)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal location;

                    [FieldOffset(28)]
                    internal int lineNumberStart;

                    [FieldOffset(32)]
                    internal int lineNumberEnd;

                    [FieldOffset(40)]
                    internal global::Std.BasicString.__Internal name;

                    [FieldOffset(72)]
                    internal global::Std.BasicString.__Internal USR;

                    [FieldOffset(104)]
                    internal global::Std.BasicString.__Internal debugText;

                    [FieldOffset(136)]
                    internal byte isIncomplete;

                    [FieldOffset(137)]
                    internal byte isDependent;

                    [FieldOffset(138)]
                    internal byte isImplicit;

                    [FieldOffset(144)]
                    internal global::System.IntPtr completeDeclaration;

                    [FieldOffset(152)]
                    internal uint definitionOrder;

                    [FieldOffset(160)]
                    internal global::Std.Vector.__Internal PreprocessedEntities;

                    [FieldOffset(184)]
                    internal global::Std.Vector.__Internal Redeclarations;

                    [FieldOffset(208)]
                    internal global::System.IntPtr originalPtr;

                    [FieldOffset(216)]
                    internal global::System.IntPtr comment;

                    [FieldOffset(224)]
                    internal global::System.IntPtr TemplatedDecl;

                    [FieldOffset(232)]
                    internal global::Std.Vector.__Internal Parameters;

                    [FieldOffset(256)]
                    internal global::Std.Vector.__Internal Specializations;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0FunctionTemplate@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0FunctionTemplate@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1FunctionTemplate@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor(global::System.IntPtr instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getSpecializations@FunctionTemplate@AST@CppParser@CppSharp@@QEAAPEAVFunctionTemplateSpecialization@234@I@Z")]
                    internal static extern global::System.IntPtr GetSpecializations(global::System.IntPtr instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?addSpecializations@FunctionTemplate@AST@CppParser@CppSharp@@QEAAXAEAPEAVFunctionTemplateSpecialization@234@@Z")]
                    internal static extern void AddSpecializations(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?clearSpecializations@FunctionTemplate@AST@CppParser@CppSharp@@QEAAXXZ")]
                    internal static extern void ClearSpecializations(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?FindSpecialization@FunctionTemplate@AST@CppParser@CppSharp@@QEAAPEAVFunctionTemplateSpecialization@234@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
                    internal static extern global::System.IntPtr FindSpecialization(global::System.IntPtr instance, global::System.IntPtr usr);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getSpecializationsCount@FunctionTemplate@AST@CppParser@CppSharp@@QEAAIXZ")]
                    internal static extern uint GetSpecializationsCount(global::System.IntPtr instance);
                }

                internal static new global::CppSharp.Parser.AST.FunctionTemplate __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.FunctionTemplate(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.FunctionTemplate __CreateInstance(global::CppSharp.Parser.AST.FunctionTemplate.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.FunctionTemplate(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.FunctionTemplate.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.FunctionTemplate.__Internal));
                    global::CppSharp.Parser.AST.FunctionTemplate.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private FunctionTemplate(global::CppSharp.Parser.AST.FunctionTemplate.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected FunctionTemplate(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public FunctionTemplate()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.FunctionTemplate.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment));
                }

                public FunctionTemplate(global::CppSharp.Parser.AST.FunctionTemplate _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.FunctionTemplate.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Declaration __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.FunctionTemplateSpecialization GetSpecializations(uint i)
                {
                    var __ret = __Internal.GetSpecializations((__Instance + __PointerAdjustment), i);
                    global::CppSharp.Parser.AST.FunctionTemplateSpecialization __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.FunctionTemplateSpecialization.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::CppSharp.Parser.AST.FunctionTemplateSpecialization) global::CppSharp.Parser.AST.FunctionTemplateSpecialization.NativeToManagedMap[__ret];
                    else __result0 = global::CppSharp.Parser.AST.FunctionTemplateSpecialization.__CreateInstance(__ret);
                    return __result0;
                }

                public void AddSpecializations(global::CppSharp.Parser.AST.FunctionTemplateSpecialization s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    __Internal.AddSpecializations((__Instance + __PointerAdjustment), __arg0);
                }

                public void ClearSpecializations()
                {
                    __Internal.ClearSpecializations((__Instance + __PointerAdjustment));
                }

                public global::CppSharp.Parser.AST.FunctionTemplateSpecialization FindSpecialization(string usr)
                {
                    var __allocator0 = new global::Std.Allocator<sbyte>();
                    var __basicString0 = global::Std.BasicStringExtensions.BasicString(usr, __allocator0);
                    var __arg0 = __basicString0.__Instance;
                    var __ret = __Internal.FindSpecialization((__Instance + __PointerAdjustment), __arg0);
                    __basicString0.Dispose(false);
                    __allocator0.Dispose();
                    global::CppSharp.Parser.AST.FunctionTemplateSpecialization __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.FunctionTemplateSpecialization.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::CppSharp.Parser.AST.FunctionTemplateSpecialization) global::CppSharp.Parser.AST.FunctionTemplateSpecialization.NativeToManagedMap[__ret];
                    else __result0 = global::CppSharp.Parser.AST.FunctionTemplateSpecialization.__CreateInstance(__ret);
                    return __result0;
                }

                public uint SpecializationsCount
                {
                    get
                    {
                        var __ret = __Internal.GetSpecializationsCount((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }
            }

            public unsafe partial class FunctionTemplateSpecialization : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 48)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::System.IntPtr _template;

                    [FieldOffset(8)]
                    internal global::Std.Vector.__Internal Arguments;

                    [FieldOffset(32)]
                    internal global::System.IntPtr specializedFunction;

                    [FieldOffset(40)]
                    internal global::CppSharp.Parser.AST.TemplateSpecializationKind specializationKind;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0FunctionTemplateSpecialization@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0FunctionTemplateSpecialization@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1FunctionTemplateSpecialization@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor(global::System.IntPtr instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getArguments@FunctionTemplateSpecialization@AST@CppParser@CppSharp@@QEAA?AUTemplateArgument@234@I@Z")]
                    internal static extern void GetArguments(global::System.IntPtr instance, global::System.IntPtr @return, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?addArguments@FunctionTemplateSpecialization@AST@CppParser@CppSharp@@QEAAXAEAUTemplateArgument@234@@Z")]
                    internal static extern void AddArguments(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?clearArguments@FunctionTemplateSpecialization@AST@CppParser@CppSharp@@QEAAXXZ")]
                    internal static extern void ClearArguments(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getArgumentsCount@FunctionTemplateSpecialization@AST@CppParser@CppSharp@@QEAAIXZ")]
                    internal static extern uint GetArgumentsCount(global::System.IntPtr instance);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                protected int __PointerAdjustment;
                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.FunctionTemplateSpecialization> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.FunctionTemplateSpecialization>();
                protected void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                internal static global::CppSharp.Parser.AST.FunctionTemplateSpecialization __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.FunctionTemplateSpecialization(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.FunctionTemplateSpecialization __CreateInstance(global::CppSharp.Parser.AST.FunctionTemplateSpecialization.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.FunctionTemplateSpecialization(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.FunctionTemplateSpecialization.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.FunctionTemplateSpecialization.__Internal));
                    global::CppSharp.Parser.AST.FunctionTemplateSpecialization.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private FunctionTemplateSpecialization(global::CppSharp.Parser.AST.FunctionTemplateSpecialization.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected FunctionTemplateSpecialization(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public FunctionTemplateSpecialization()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.FunctionTemplateSpecialization.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment));
                }

                public FunctionTemplateSpecialization(global::CppSharp.Parser.AST.FunctionTemplateSpecialization _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.FunctionTemplateSpecialization.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                public virtual void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.FunctionTemplateSpecialization __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.TemplateArgument GetArguments(uint i)
                {
                    var __ret = new global::CppSharp.Parser.AST.TemplateArgument.__Internal();
                    __Internal.GetArguments((__Instance + __PointerAdjustment), new IntPtr(&__ret), i);
                    return global::CppSharp.Parser.AST.TemplateArgument.__CreateInstance(__ret);
                }

                public void AddArguments(global::CppSharp.Parser.AST.TemplateArgument s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    __Internal.AddArguments((__Instance + __PointerAdjustment), __arg0);
                }

                public void ClearArguments()
                {
                    __Internal.ClearArguments((__Instance + __PointerAdjustment));
                }

                public global::CppSharp.Parser.AST.FunctionTemplate Template
                {
                    get
                    {
                        global::CppSharp.Parser.AST.FunctionTemplate __result0;
                        if (((global::CppSharp.Parser.AST.FunctionTemplateSpecialization.__Internal*) __Instance)->_template == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.FunctionTemplate.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.FunctionTemplateSpecialization.__Internal*) __Instance)->_template))
                            __result0 = (global::CppSharp.Parser.AST.FunctionTemplate) global::CppSharp.Parser.AST.FunctionTemplate.NativeToManagedMap[((global::CppSharp.Parser.AST.FunctionTemplateSpecialization.__Internal*) __Instance)->_template];
                        else __result0 = global::CppSharp.Parser.AST.FunctionTemplate.__CreateInstance(((global::CppSharp.Parser.AST.FunctionTemplateSpecialization.__Internal*) __Instance)->_template);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.FunctionTemplateSpecialization.__Internal*) __Instance)->_template = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Function SpecializedFunction
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Function __result0;
                        if (((global::CppSharp.Parser.AST.FunctionTemplateSpecialization.__Internal*) __Instance)->specializedFunction == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Function.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.FunctionTemplateSpecialization.__Internal*) __Instance)->specializedFunction))
                            __result0 = (global::CppSharp.Parser.AST.Function) global::CppSharp.Parser.AST.Function.NativeToManagedMap[((global::CppSharp.Parser.AST.FunctionTemplateSpecialization.__Internal*) __Instance)->specializedFunction];
                        else __result0 = global::CppSharp.Parser.AST.Function.__CreateInstance(((global::CppSharp.Parser.AST.FunctionTemplateSpecialization.__Internal*) __Instance)->specializedFunction);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.FunctionTemplateSpecialization.__Internal*) __Instance)->specializedFunction = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.TemplateSpecializationKind SpecializationKind
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.FunctionTemplateSpecialization.__Internal*) __Instance)->specializationKind;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.FunctionTemplateSpecialization.__Internal*) __Instance)->specializationKind = value;
                    }
                }

                public uint ArgumentsCount
                {
                    get
                    {
                        var __ret = __Internal.GetArgumentsCount((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }
            }

            public unsafe partial class VarTemplate : global::CppSharp.Parser.AST.Template, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 280)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.DeclarationKind kind;

                    [FieldOffset(4)]
                    internal int maxFieldAlignment;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.AccessSpecifier access;

                    [FieldOffset(16)]
                    internal global::System.IntPtr _namespace;

                    [FieldOffset(24)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal location;

                    [FieldOffset(28)]
                    internal int lineNumberStart;

                    [FieldOffset(32)]
                    internal int lineNumberEnd;

                    [FieldOffset(40)]
                    internal global::Std.BasicString.__Internal name;

                    [FieldOffset(72)]
                    internal global::Std.BasicString.__Internal USR;

                    [FieldOffset(104)]
                    internal global::Std.BasicString.__Internal debugText;

                    [FieldOffset(136)]
                    internal byte isIncomplete;

                    [FieldOffset(137)]
                    internal byte isDependent;

                    [FieldOffset(138)]
                    internal byte isImplicit;

                    [FieldOffset(144)]
                    internal global::System.IntPtr completeDeclaration;

                    [FieldOffset(152)]
                    internal uint definitionOrder;

                    [FieldOffset(160)]
                    internal global::Std.Vector.__Internal PreprocessedEntities;

                    [FieldOffset(184)]
                    internal global::Std.Vector.__Internal Redeclarations;

                    [FieldOffset(208)]
                    internal global::System.IntPtr originalPtr;

                    [FieldOffset(216)]
                    internal global::System.IntPtr comment;

                    [FieldOffset(224)]
                    internal global::System.IntPtr TemplatedDecl;

                    [FieldOffset(232)]
                    internal global::Std.Vector.__Internal Parameters;

                    [FieldOffset(256)]
                    internal global::Std.Vector.__Internal Specializations;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0VarTemplate@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0VarTemplate@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1VarTemplate@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor(global::System.IntPtr instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getSpecializations@VarTemplate@AST@CppParser@CppSharp@@QEAAPEAVVarTemplateSpecialization@234@I@Z")]
                    internal static extern global::System.IntPtr GetSpecializations(global::System.IntPtr instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?addSpecializations@VarTemplate@AST@CppParser@CppSharp@@QEAAXAEAPEAVVarTemplateSpecialization@234@@Z")]
                    internal static extern void AddSpecializations(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?clearSpecializations@VarTemplate@AST@CppParser@CppSharp@@QEAAXXZ")]
                    internal static extern void ClearSpecializations(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?FindSpecialization@VarTemplate@AST@CppParser@CppSharp@@QEAAPEAVVarTemplateSpecialization@234@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
                    internal static extern global::System.IntPtr FindSpecialization(global::System.IntPtr instance, global::System.IntPtr usr);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?FindPartialSpecialization@VarTemplate@AST@CppParser@CppSharp@@QEAAPEAVVarTemplatePartialSpecialization@234@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
                    internal static extern global::System.IntPtr FindPartialSpecialization(global::System.IntPtr instance, global::System.IntPtr usr);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getSpecializationsCount@VarTemplate@AST@CppParser@CppSharp@@QEAAIXZ")]
                    internal static extern uint GetSpecializationsCount(global::System.IntPtr instance);
                }

                internal static new global::CppSharp.Parser.AST.VarTemplate __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.VarTemplate(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.VarTemplate __CreateInstance(global::CppSharp.Parser.AST.VarTemplate.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.VarTemplate(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.VarTemplate.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.VarTemplate.__Internal));
                    global::CppSharp.Parser.AST.VarTemplate.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private VarTemplate(global::CppSharp.Parser.AST.VarTemplate.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected VarTemplate(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public VarTemplate()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.VarTemplate.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment));
                }

                public VarTemplate(global::CppSharp.Parser.AST.VarTemplate _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.VarTemplate.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Declaration __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.VarTemplateSpecialization GetSpecializations(uint i)
                {
                    var __ret = __Internal.GetSpecializations((__Instance + __PointerAdjustment), i);
                    global::CppSharp.Parser.AST.VarTemplateSpecialization __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.VarTemplateSpecialization.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::CppSharp.Parser.AST.VarTemplateSpecialization) global::CppSharp.Parser.AST.VarTemplateSpecialization.NativeToManagedMap[__ret];
                    else __result0 = global::CppSharp.Parser.AST.VarTemplateSpecialization.__CreateInstance(__ret);
                    return __result0;
                }

                public void AddSpecializations(global::CppSharp.Parser.AST.VarTemplateSpecialization s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    __Internal.AddSpecializations((__Instance + __PointerAdjustment), __arg0);
                }

                public void ClearSpecializations()
                {
                    __Internal.ClearSpecializations((__Instance + __PointerAdjustment));
                }

                public global::CppSharp.Parser.AST.VarTemplateSpecialization FindSpecialization(string usr)
                {
                    var __allocator0 = new global::Std.Allocator<sbyte>();
                    var __basicString0 = global::Std.BasicStringExtensions.BasicString(usr, __allocator0);
                    var __arg0 = __basicString0.__Instance;
                    var __ret = __Internal.FindSpecialization((__Instance + __PointerAdjustment), __arg0);
                    __basicString0.Dispose(false);
                    __allocator0.Dispose();
                    global::CppSharp.Parser.AST.VarTemplateSpecialization __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.VarTemplateSpecialization.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::CppSharp.Parser.AST.VarTemplateSpecialization) global::CppSharp.Parser.AST.VarTemplateSpecialization.NativeToManagedMap[__ret];
                    else __result0 = global::CppSharp.Parser.AST.VarTemplateSpecialization.__CreateInstance(__ret);
                    return __result0;
                }

                public global::CppSharp.Parser.AST.VarTemplatePartialSpecialization FindPartialSpecialization(string usr)
                {
                    var __allocator0 = new global::Std.Allocator<sbyte>();
                    var __basicString0 = global::Std.BasicStringExtensions.BasicString(usr, __allocator0);
                    var __arg0 = __basicString0.__Instance;
                    var __ret = __Internal.FindPartialSpecialization((__Instance + __PointerAdjustment), __arg0);
                    __basicString0.Dispose(false);
                    __allocator0.Dispose();
                    global::CppSharp.Parser.AST.VarTemplatePartialSpecialization __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.VarTemplatePartialSpecialization.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::CppSharp.Parser.AST.VarTemplatePartialSpecialization) global::CppSharp.Parser.AST.VarTemplatePartialSpecialization.NativeToManagedMap[__ret];
                    else __result0 = global::CppSharp.Parser.AST.VarTemplatePartialSpecialization.__CreateInstance(__ret);
                    return __result0;
                }

                public uint SpecializationsCount
                {
                    get
                    {
                        var __ret = __Internal.GetSpecializationsCount((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }
            }

            public unsafe partial class VarTemplateSpecialization : global::CppSharp.Parser.AST.Variable, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 312)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.DeclarationKind kind;

                    [FieldOffset(4)]
                    internal int maxFieldAlignment;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.AccessSpecifier access;

                    [FieldOffset(16)]
                    internal global::System.IntPtr _namespace;

                    [FieldOffset(24)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal location;

                    [FieldOffset(28)]
                    internal int lineNumberStart;

                    [FieldOffset(32)]
                    internal int lineNumberEnd;

                    [FieldOffset(40)]
                    internal global::Std.BasicString.__Internal name;

                    [FieldOffset(72)]
                    internal global::Std.BasicString.__Internal USR;

                    [FieldOffset(104)]
                    internal global::Std.BasicString.__Internal debugText;

                    [FieldOffset(136)]
                    internal byte isIncomplete;

                    [FieldOffset(137)]
                    internal byte isDependent;

                    [FieldOffset(138)]
                    internal byte isImplicit;

                    [FieldOffset(144)]
                    internal global::System.IntPtr completeDeclaration;

                    [FieldOffset(152)]
                    internal uint definitionOrder;

                    [FieldOffset(160)]
                    internal global::Std.Vector.__Internal PreprocessedEntities;

                    [FieldOffset(184)]
                    internal global::Std.Vector.__Internal Redeclarations;

                    [FieldOffset(208)]
                    internal global::System.IntPtr originalPtr;

                    [FieldOffset(216)]
                    internal global::System.IntPtr comment;

                    [FieldOffset(224)]
                    internal global::Std.BasicString.__Internal mangled;

                    [FieldOffset(256)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal qualifiedType;

                    [FieldOffset(272)]
                    internal global::System.IntPtr templatedDecl;

                    [FieldOffset(280)]
                    internal global::Std.Vector.__Internal Arguments;

                    [FieldOffset(304)]
                    internal global::CppSharp.Parser.AST.TemplateSpecializationKind specializationKind;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0VarTemplateSpecialization@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0VarTemplateSpecialization@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1VarTemplateSpecialization@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor(global::System.IntPtr instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getArguments@VarTemplateSpecialization@AST@CppParser@CppSharp@@QEAA?AUTemplateArgument@234@I@Z")]
                    internal static extern void GetArguments(global::System.IntPtr instance, global::System.IntPtr @return, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?addArguments@VarTemplateSpecialization@AST@CppParser@CppSharp@@QEAAXAEAUTemplateArgument@234@@Z")]
                    internal static extern void AddArguments(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?clearArguments@VarTemplateSpecialization@AST@CppParser@CppSharp@@QEAAXXZ")]
                    internal static extern void ClearArguments(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getArgumentsCount@VarTemplateSpecialization@AST@CppParser@CppSharp@@QEAAIXZ")]
                    internal static extern uint GetArgumentsCount(global::System.IntPtr instance);
                }

                internal static new global::CppSharp.Parser.AST.VarTemplateSpecialization __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.VarTemplateSpecialization(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.VarTemplateSpecialization __CreateInstance(global::CppSharp.Parser.AST.VarTemplateSpecialization.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.VarTemplateSpecialization(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.VarTemplateSpecialization.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.VarTemplateSpecialization.__Internal));
                    global::CppSharp.Parser.AST.VarTemplateSpecialization.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private VarTemplateSpecialization(global::CppSharp.Parser.AST.VarTemplateSpecialization.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected VarTemplateSpecialization(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public VarTemplateSpecialization()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.VarTemplateSpecialization.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment));
                }

                public VarTemplateSpecialization(global::CppSharp.Parser.AST.VarTemplateSpecialization _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.VarTemplateSpecialization.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Declaration __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.TemplateArgument GetArguments(uint i)
                {
                    var __ret = new global::CppSharp.Parser.AST.TemplateArgument.__Internal();
                    __Internal.GetArguments((__Instance + __PointerAdjustment), new IntPtr(&__ret), i);
                    return global::CppSharp.Parser.AST.TemplateArgument.__CreateInstance(__ret);
                }

                public void AddArguments(global::CppSharp.Parser.AST.TemplateArgument s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    __Internal.AddArguments((__Instance + __PointerAdjustment), __arg0);
                }

                public void ClearArguments()
                {
                    __Internal.ClearArguments((__Instance + __PointerAdjustment));
                }

                public global::CppSharp.Parser.AST.VarTemplate TemplatedDecl
                {
                    get
                    {
                        global::CppSharp.Parser.AST.VarTemplate __result0;
                        if (((global::CppSharp.Parser.AST.VarTemplateSpecialization.__Internal*) __Instance)->templatedDecl == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.VarTemplate.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.VarTemplateSpecialization.__Internal*) __Instance)->templatedDecl))
                            __result0 = (global::CppSharp.Parser.AST.VarTemplate) global::CppSharp.Parser.AST.VarTemplate.NativeToManagedMap[((global::CppSharp.Parser.AST.VarTemplateSpecialization.__Internal*) __Instance)->templatedDecl];
                        else __result0 = global::CppSharp.Parser.AST.VarTemplate.__CreateInstance(((global::CppSharp.Parser.AST.VarTemplateSpecialization.__Internal*) __Instance)->templatedDecl);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.VarTemplateSpecialization.__Internal*) __Instance)->templatedDecl = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.TemplateSpecializationKind SpecializationKind
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.VarTemplateSpecialization.__Internal*) __Instance)->specializationKind;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.VarTemplateSpecialization.__Internal*) __Instance)->specializationKind = value;
                    }
                }

                public uint ArgumentsCount
                {
                    get
                    {
                        var __ret = __Internal.GetArgumentsCount((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }
            }

            public unsafe partial class VarTemplatePartialSpecialization : global::CppSharp.Parser.AST.VarTemplateSpecialization, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 312)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.DeclarationKind kind;

                    [FieldOffset(4)]
                    internal int maxFieldAlignment;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.AccessSpecifier access;

                    [FieldOffset(16)]
                    internal global::System.IntPtr _namespace;

                    [FieldOffset(24)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal location;

                    [FieldOffset(28)]
                    internal int lineNumberStart;

                    [FieldOffset(32)]
                    internal int lineNumberEnd;

                    [FieldOffset(40)]
                    internal global::Std.BasicString.__Internal name;

                    [FieldOffset(72)]
                    internal global::Std.BasicString.__Internal USR;

                    [FieldOffset(104)]
                    internal global::Std.BasicString.__Internal debugText;

                    [FieldOffset(136)]
                    internal byte isIncomplete;

                    [FieldOffset(137)]
                    internal byte isDependent;

                    [FieldOffset(138)]
                    internal byte isImplicit;

                    [FieldOffset(144)]
                    internal global::System.IntPtr completeDeclaration;

                    [FieldOffset(152)]
                    internal uint definitionOrder;

                    [FieldOffset(160)]
                    internal global::Std.Vector.__Internal PreprocessedEntities;

                    [FieldOffset(184)]
                    internal global::Std.Vector.__Internal Redeclarations;

                    [FieldOffset(208)]
                    internal global::System.IntPtr originalPtr;

                    [FieldOffset(216)]
                    internal global::System.IntPtr comment;

                    [FieldOffset(224)]
                    internal global::Std.BasicString.__Internal mangled;

                    [FieldOffset(256)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal qualifiedType;

                    [FieldOffset(272)]
                    internal global::System.IntPtr templatedDecl;

                    [FieldOffset(280)]
                    internal global::Std.Vector.__Internal Arguments;

                    [FieldOffset(304)]
                    internal global::CppSharp.Parser.AST.TemplateSpecializationKind specializationKind;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0VarTemplatePartialSpecialization@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0VarTemplatePartialSpecialization@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1VarTemplatePartialSpecialization@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor(global::System.IntPtr instance, int delete);
                }

                internal static new global::CppSharp.Parser.AST.VarTemplatePartialSpecialization __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.VarTemplatePartialSpecialization(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.VarTemplatePartialSpecialization __CreateInstance(global::CppSharp.Parser.AST.VarTemplatePartialSpecialization.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.VarTemplatePartialSpecialization(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.VarTemplatePartialSpecialization.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.VarTemplatePartialSpecialization.__Internal));
                    global::CppSharp.Parser.AST.VarTemplatePartialSpecialization.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private VarTemplatePartialSpecialization(global::CppSharp.Parser.AST.VarTemplatePartialSpecialization.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected VarTemplatePartialSpecialization(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public VarTemplatePartialSpecialization()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.VarTemplatePartialSpecialization.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment));
                }

                public VarTemplatePartialSpecialization(global::CppSharp.Parser.AST.VarTemplatePartialSpecialization _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.VarTemplatePartialSpecialization.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Declaration __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }
            }

            public unsafe partial class Namespace : global::CppSharp.Parser.AST.DeclarationContext, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 472)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.DeclarationKind kind;

                    [FieldOffset(4)]
                    internal int maxFieldAlignment;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.AccessSpecifier access;

                    [FieldOffset(16)]
                    internal global::System.IntPtr _namespace;

                    [FieldOffset(24)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal location;

                    [FieldOffset(28)]
                    internal int lineNumberStart;

                    [FieldOffset(32)]
                    internal int lineNumberEnd;

                    [FieldOffset(40)]
                    internal global::Std.BasicString.__Internal name;

                    [FieldOffset(72)]
                    internal global::Std.BasicString.__Internal USR;

                    [FieldOffset(104)]
                    internal global::Std.BasicString.__Internal debugText;

                    [FieldOffset(136)]
                    internal byte isIncomplete;

                    [FieldOffset(137)]
                    internal byte isDependent;

                    [FieldOffset(138)]
                    internal byte isImplicit;

                    [FieldOffset(144)]
                    internal global::System.IntPtr completeDeclaration;

                    [FieldOffset(152)]
                    internal uint definitionOrder;

                    [FieldOffset(160)]
                    internal global::Std.Vector.__Internal PreprocessedEntities;

                    [FieldOffset(184)]
                    internal global::Std.Vector.__Internal Redeclarations;

                    [FieldOffset(208)]
                    internal global::System.IntPtr originalPtr;

                    [FieldOffset(216)]
                    internal global::System.IntPtr comment;

                    [FieldOffset(224)]
                    internal global::Std.Vector.__Internal Namespaces;

                    [FieldOffset(248)]
                    internal global::Std.Vector.__Internal Enums;

                    [FieldOffset(272)]
                    internal global::Std.Vector.__Internal Functions;

                    [FieldOffset(296)]
                    internal global::Std.Vector.__Internal Classes;

                    [FieldOffset(320)]
                    internal global::Std.Vector.__Internal Templates;

                    [FieldOffset(344)]
                    internal global::Std.Vector.__Internal Typedefs;

                    [FieldOffset(368)]
                    internal global::Std.Vector.__Internal TypeAliases;

                    [FieldOffset(392)]
                    internal global::Std.Vector.__Internal Variables;

                    [FieldOffset(416)]
                    internal global::Std.Vector.__Internal Friends;

                    [FieldOffset(440)]
                    internal global::Std.Map.__Internal anonymous;

                    [FieldOffset(456)]
                    internal byte isAnonymous;

                    [FieldOffset(464)]
                    internal byte isInline;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0Namespace@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0Namespace@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1Namespace@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor(global::System.IntPtr instance, int delete);
                }

                internal static new global::CppSharp.Parser.AST.Namespace __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.Namespace(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.Namespace __CreateInstance(global::CppSharp.Parser.AST.Namespace.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.Namespace(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.Namespace.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Namespace.__Internal));
                    global::CppSharp.Parser.AST.Namespace.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private Namespace(global::CppSharp.Parser.AST.Namespace.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected Namespace(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public Namespace()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Namespace.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment));
                }

                public Namespace(global::CppSharp.Parser.AST.Namespace _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Namespace.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Declaration __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public bool IsInline
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Namespace.__Internal*) __Instance)->isInline != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Namespace.__Internal*) __Instance)->isInline = (byte) (value ? 1 : 0);
                    }
                }
            }

            public unsafe partial class PreprocessedEntity : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 24)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.MacroLocation macroLocation;

                    [FieldOffset(8)]
                    internal global::System.IntPtr originalPtr;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.AST.DeclarationKind kind;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0PreprocessedEntity@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0PreprocessedEntity@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                protected int __PointerAdjustment;
                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.PreprocessedEntity> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.PreprocessedEntity>();
                protected void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                internal static global::CppSharp.Parser.AST.PreprocessedEntity __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.PreprocessedEntity(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.PreprocessedEntity __CreateInstance(global::CppSharp.Parser.AST.PreprocessedEntity.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.PreprocessedEntity(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.PreprocessedEntity.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.PreprocessedEntity.__Internal));
                    *(global::CppSharp.Parser.AST.PreprocessedEntity.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private PreprocessedEntity(global::CppSharp.Parser.AST.PreprocessedEntity.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected PreprocessedEntity(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public PreprocessedEntity()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.PreprocessedEntity.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment));
                }

                public PreprocessedEntity(global::CppSharp.Parser.AST.PreprocessedEntity _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.PreprocessedEntity.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.PreprocessedEntity.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.PreprocessedEntity.__Internal*) _0.__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                public virtual void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.PreprocessedEntity __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.MacroLocation MacroLocation
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.PreprocessedEntity.__Internal*) __Instance)->macroLocation;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.PreprocessedEntity.__Internal*) __Instance)->macroLocation = value;
                    }
                }

                public global::System.IntPtr OriginalPtr
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.PreprocessedEntity.__Internal*) __Instance)->originalPtr;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.PreprocessedEntity.__Internal*) __Instance)->originalPtr = (global::System.IntPtr) value;
                    }
                }

                public global::CppSharp.Parser.AST.DeclarationKind Kind
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.PreprocessedEntity.__Internal*) __Instance)->kind;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.PreprocessedEntity.__Internal*) __Instance)->kind = value;
                    }
                }
            }

            public unsafe partial class MacroDefinition : global::CppSharp.Parser.AST.PreprocessedEntity, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 96)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.MacroLocation macroLocation;

                    [FieldOffset(8)]
                    internal global::System.IntPtr originalPtr;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.AST.DeclarationKind kind;

                    [FieldOffset(24)]
                    internal global::Std.BasicString.__Internal name;

                    [FieldOffset(56)]
                    internal global::Std.BasicString.__Internal expression;

                    [FieldOffset(88)]
                    internal int lineNumberStart;

                    [FieldOffset(92)]
                    internal int lineNumberEnd;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0MacroDefinition@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0MacroDefinition@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1MacroDefinition@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor(global::System.IntPtr instance, int delete);
                }

                internal static new global::CppSharp.Parser.AST.MacroDefinition __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.MacroDefinition(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.MacroDefinition __CreateInstance(global::CppSharp.Parser.AST.MacroDefinition.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.MacroDefinition(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.MacroDefinition.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.MacroDefinition.__Internal));
                    global::CppSharp.Parser.AST.MacroDefinition.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private MacroDefinition(global::CppSharp.Parser.AST.MacroDefinition.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected MacroDefinition(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public MacroDefinition()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.MacroDefinition.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment));
                }

                public MacroDefinition(global::CppSharp.Parser.AST.MacroDefinition _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.MacroDefinition.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.PreprocessedEntity __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public string Name
                {
                    get
                    {
                        var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(((global::CppSharp.Parser.AST.MacroDefinition.__Internal*) __Instance)->name);
                        var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                        __basicStringRet.Dispose(false);
                        return __stringRet;
                    }

                    set
                    {
                        var __allocator0 = new global::Std.Allocator<sbyte>();
                        var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                        ((global::CppSharp.Parser.AST.MacroDefinition.__Internal*) __Instance)->name = *(global::Std.BasicString.__Internal*) __basicString0.__Instance;
                    }
                }

                public string Expression
                {
                    get
                    {
                        var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(((global::CppSharp.Parser.AST.MacroDefinition.__Internal*) __Instance)->expression);
                        var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                        __basicStringRet.Dispose(false);
                        return __stringRet;
                    }

                    set
                    {
                        var __allocator0 = new global::Std.Allocator<sbyte>();
                        var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                        ((global::CppSharp.Parser.AST.MacroDefinition.__Internal*) __Instance)->expression = *(global::Std.BasicString.__Internal*) __basicString0.__Instance;
                    }
                }

                public int LineNumberStart
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.MacroDefinition.__Internal*) __Instance)->lineNumberStart;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.MacroDefinition.__Internal*) __Instance)->lineNumberStart = value;
                    }
                }

                public int LineNumberEnd
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.MacroDefinition.__Internal*) __Instance)->lineNumberEnd;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.MacroDefinition.__Internal*) __Instance)->lineNumberEnd = value;
                    }
                }
            }

            public unsafe partial class MacroExpansion : global::CppSharp.Parser.AST.PreprocessedEntity, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 96)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.MacroLocation macroLocation;

                    [FieldOffset(8)]
                    internal global::System.IntPtr originalPtr;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.AST.DeclarationKind kind;

                    [FieldOffset(24)]
                    internal global::Std.BasicString.__Internal name;

                    [FieldOffset(56)]
                    internal global::Std.BasicString.__Internal text;

                    [FieldOffset(88)]
                    internal global::System.IntPtr definition;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0MacroExpansion@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0MacroExpansion@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1MacroExpansion@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor(global::System.IntPtr instance, int delete);
                }

                internal static new global::CppSharp.Parser.AST.MacroExpansion __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.MacroExpansion(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.MacroExpansion __CreateInstance(global::CppSharp.Parser.AST.MacroExpansion.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.MacroExpansion(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.MacroExpansion.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.MacroExpansion.__Internal));
                    global::CppSharp.Parser.AST.MacroExpansion.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private MacroExpansion(global::CppSharp.Parser.AST.MacroExpansion.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected MacroExpansion(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public MacroExpansion()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.MacroExpansion.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment));
                }

                public MacroExpansion(global::CppSharp.Parser.AST.MacroExpansion _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.MacroExpansion.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.PreprocessedEntity __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public string Name
                {
                    get
                    {
                        var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(((global::CppSharp.Parser.AST.MacroExpansion.__Internal*) __Instance)->name);
                        var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                        __basicStringRet.Dispose(false);
                        return __stringRet;
                    }

                    set
                    {
                        var __allocator0 = new global::Std.Allocator<sbyte>();
                        var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                        ((global::CppSharp.Parser.AST.MacroExpansion.__Internal*) __Instance)->name = *(global::Std.BasicString.__Internal*) __basicString0.__Instance;
                    }
                }

                public string Text
                {
                    get
                    {
                        var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(((global::CppSharp.Parser.AST.MacroExpansion.__Internal*) __Instance)->text);
                        var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                        __basicStringRet.Dispose(false);
                        return __stringRet;
                    }

                    set
                    {
                        var __allocator0 = new global::Std.Allocator<sbyte>();
                        var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                        ((global::CppSharp.Parser.AST.MacroExpansion.__Internal*) __Instance)->text = *(global::Std.BasicString.__Internal*) __basicString0.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.MacroDefinition Definition
                {
                    get
                    {
                        global::CppSharp.Parser.AST.MacroDefinition __result0;
                        if (((global::CppSharp.Parser.AST.MacroExpansion.__Internal*) __Instance)->definition == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.MacroDefinition.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.MacroExpansion.__Internal*) __Instance)->definition))
                            __result0 = (global::CppSharp.Parser.AST.MacroDefinition) global::CppSharp.Parser.AST.MacroDefinition.NativeToManagedMap[((global::CppSharp.Parser.AST.MacroExpansion.__Internal*) __Instance)->definition];
                        else __result0 = global::CppSharp.Parser.AST.MacroDefinition.__CreateInstance(((global::CppSharp.Parser.AST.MacroExpansion.__Internal*) __Instance)->definition);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.MacroExpansion.__Internal*) __Instance)->definition = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }
            }

            public unsafe partial class TranslationUnit : global::CppSharp.Parser.AST.Namespace, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 536)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.DeclarationKind kind;

                    [FieldOffset(4)]
                    internal int maxFieldAlignment;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.AccessSpecifier access;

                    [FieldOffset(16)]
                    internal global::System.IntPtr _namespace;

                    [FieldOffset(24)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal location;

                    [FieldOffset(28)]
                    internal int lineNumberStart;

                    [FieldOffset(32)]
                    internal int lineNumberEnd;

                    [FieldOffset(40)]
                    internal global::Std.BasicString.__Internal name;

                    [FieldOffset(72)]
                    internal global::Std.BasicString.__Internal USR;

                    [FieldOffset(104)]
                    internal global::Std.BasicString.__Internal debugText;

                    [FieldOffset(136)]
                    internal byte isIncomplete;

                    [FieldOffset(137)]
                    internal byte isDependent;

                    [FieldOffset(138)]
                    internal byte isImplicit;

                    [FieldOffset(144)]
                    internal global::System.IntPtr completeDeclaration;

                    [FieldOffset(152)]
                    internal uint definitionOrder;

                    [FieldOffset(160)]
                    internal global::Std.Vector.__Internal PreprocessedEntities;

                    [FieldOffset(184)]
                    internal global::Std.Vector.__Internal Redeclarations;

                    [FieldOffset(208)]
                    internal global::System.IntPtr originalPtr;

                    [FieldOffset(216)]
                    internal global::System.IntPtr comment;

                    [FieldOffset(224)]
                    internal global::Std.Vector.__Internal Namespaces;

                    [FieldOffset(248)]
                    internal global::Std.Vector.__Internal Enums;

                    [FieldOffset(272)]
                    internal global::Std.Vector.__Internal Functions;

                    [FieldOffset(296)]
                    internal global::Std.Vector.__Internal Classes;

                    [FieldOffset(320)]
                    internal global::Std.Vector.__Internal Templates;

                    [FieldOffset(344)]
                    internal global::Std.Vector.__Internal Typedefs;

                    [FieldOffset(368)]
                    internal global::Std.Vector.__Internal TypeAliases;

                    [FieldOffset(392)]
                    internal global::Std.Vector.__Internal Variables;

                    [FieldOffset(416)]
                    internal global::Std.Vector.__Internal Friends;

                    [FieldOffset(440)]
                    internal global::Std.Map.__Internal anonymous;

                    [FieldOffset(456)]
                    internal byte isAnonymous;

                    [FieldOffset(464)]
                    internal byte isInline;

                    [FieldOffset(472)]
                    internal global::Std.BasicString.__Internal fileName;

                    [FieldOffset(504)]
                    internal byte isSystemHeader;

                    [FieldOffset(512)]
                    internal global::Std.Vector.__Internal Macros;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0TranslationUnit@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0TranslationUnit@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1TranslationUnit@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor(global::System.IntPtr instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getMacros@TranslationUnit@AST@CppParser@CppSharp@@QEAAPEAVMacroDefinition@234@I@Z")]
                    internal static extern global::System.IntPtr GetMacros(global::System.IntPtr instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?addMacros@TranslationUnit@AST@CppParser@CppSharp@@QEAAXAEAPEAVMacroDefinition@234@@Z")]
                    internal static extern void AddMacros(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?clearMacros@TranslationUnit@AST@CppParser@CppSharp@@QEAAXXZ")]
                    internal static extern void ClearMacros(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getMacrosCount@TranslationUnit@AST@CppParser@CppSharp@@QEAAIXZ")]
                    internal static extern uint GetMacrosCount(global::System.IntPtr instance);
                }

                internal static new global::CppSharp.Parser.AST.TranslationUnit __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.TranslationUnit(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.TranslationUnit __CreateInstance(global::CppSharp.Parser.AST.TranslationUnit.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.TranslationUnit(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.TranslationUnit.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TranslationUnit.__Internal));
                    global::CppSharp.Parser.AST.TranslationUnit.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private TranslationUnit(global::CppSharp.Parser.AST.TranslationUnit.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected TranslationUnit(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public TranslationUnit()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TranslationUnit.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment));
                }

                public TranslationUnit(global::CppSharp.Parser.AST.TranslationUnit _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TranslationUnit.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Declaration __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.MacroDefinition GetMacros(uint i)
                {
                    var __ret = __Internal.GetMacros((__Instance + __PointerAdjustment), i);
                    global::CppSharp.Parser.AST.MacroDefinition __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.MacroDefinition.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::CppSharp.Parser.AST.MacroDefinition) global::CppSharp.Parser.AST.MacroDefinition.NativeToManagedMap[__ret];
                    else __result0 = global::CppSharp.Parser.AST.MacroDefinition.__CreateInstance(__ret);
                    return __result0;
                }

                public void AddMacros(global::CppSharp.Parser.AST.MacroDefinition s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    __Internal.AddMacros((__Instance + __PointerAdjustment), __arg0);
                }

                public void ClearMacros()
                {
                    __Internal.ClearMacros((__Instance + __PointerAdjustment));
                }

                public string FileName
                {
                    get
                    {
                        var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(((global::CppSharp.Parser.AST.TranslationUnit.__Internal*) __Instance)->fileName);
                        var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                        __basicStringRet.Dispose(false);
                        return __stringRet;
                    }

                    set
                    {
                        var __allocator0 = new global::Std.Allocator<sbyte>();
                        var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                        ((global::CppSharp.Parser.AST.TranslationUnit.__Internal*) __Instance)->fileName = *(global::Std.BasicString.__Internal*) __basicString0.__Instance;
                    }
                }

                public bool IsSystemHeader
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.TranslationUnit.__Internal*) __Instance)->isSystemHeader != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.TranslationUnit.__Internal*) __Instance)->isSystemHeader = (byte) (value ? 1 : 0);
                    }
                }

                public uint MacrosCount
                {
                    get
                    {
                        var __ret = __Internal.GetMacrosCount((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }
            }

            public unsafe partial class NativeLibrary : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 88)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::Std.BasicString.__Internal fileName;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.AST.ArchType archType;

                    [FieldOffset(40)]
                    internal global::Std.Vector.__Internal Symbols;

                    [FieldOffset(64)]
                    internal global::Std.Vector.__Internal Dependencies;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0NativeLibrary@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0NativeLibrary@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1NativeLibrary@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor(global::System.IntPtr instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getSymbols@NativeLibrary@AST@CppParser@CppSharp@@QEAAPEBDI@Z")]
                    internal static extern global::System.IntPtr GetSymbols(global::System.IntPtr instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?addSymbols@NativeLibrary@AST@CppParser@CppSharp@@QEAAXPEBD@Z")]
                    internal static extern void AddSymbols(global::System.IntPtr instance, [MarshalAs(UnmanagedType.LPStr)] string s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?clearSymbols@NativeLibrary@AST@CppParser@CppSharp@@QEAAXXZ")]
                    internal static extern void ClearSymbols(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getDependencies@NativeLibrary@AST@CppParser@CppSharp@@QEAAPEBDI@Z")]
                    internal static extern global::System.IntPtr GetDependencies(global::System.IntPtr instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?addDependencies@NativeLibrary@AST@CppParser@CppSharp@@QEAAXPEBD@Z")]
                    internal static extern void AddDependencies(global::System.IntPtr instance, [MarshalAs(UnmanagedType.LPStr)] string s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?clearDependencies@NativeLibrary@AST@CppParser@CppSharp@@QEAAXXZ")]
                    internal static extern void ClearDependencies(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getSymbolsCount@NativeLibrary@AST@CppParser@CppSharp@@QEAAIXZ")]
                    internal static extern uint GetSymbolsCount(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getDependenciesCount@NativeLibrary@AST@CppParser@CppSharp@@QEAAIXZ")]
                    internal static extern uint GetDependenciesCount(global::System.IntPtr instance);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                protected int __PointerAdjustment;
                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.NativeLibrary> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.NativeLibrary>();
                protected void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                internal static global::CppSharp.Parser.AST.NativeLibrary __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.NativeLibrary(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.NativeLibrary __CreateInstance(global::CppSharp.Parser.AST.NativeLibrary.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.NativeLibrary(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.NativeLibrary.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.NativeLibrary.__Internal));
                    global::CppSharp.Parser.AST.NativeLibrary.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private NativeLibrary(global::CppSharp.Parser.AST.NativeLibrary.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected NativeLibrary(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public NativeLibrary()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.NativeLibrary.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment));
                }

                public NativeLibrary(global::CppSharp.Parser.AST.NativeLibrary _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.NativeLibrary.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                public virtual void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.NativeLibrary __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public string GetSymbols(uint i)
                {
                    var __ret = __Internal.GetSymbols((__Instance + __PointerAdjustment), i);
                    return Marshal.PtrToStringAnsi(__ret);
                }

                public void AddSymbols(string s)
                {
                    __Internal.AddSymbols((__Instance + __PointerAdjustment), s);
                }

                public void ClearSymbols()
                {
                    __Internal.ClearSymbols((__Instance + __PointerAdjustment));
                }

                public string GetDependencies(uint i)
                {
                    var __ret = __Internal.GetDependencies((__Instance + __PointerAdjustment), i);
                    return Marshal.PtrToStringAnsi(__ret);
                }

                public void AddDependencies(string s)
                {
                    __Internal.AddDependencies((__Instance + __PointerAdjustment), s);
                }

                public void ClearDependencies()
                {
                    __Internal.ClearDependencies((__Instance + __PointerAdjustment));
                }

                public string FileName
                {
                    get
                    {
                        var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(((global::CppSharp.Parser.AST.NativeLibrary.__Internal*) __Instance)->fileName);
                        var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                        __basicStringRet.Dispose(false);
                        return __stringRet;
                    }

                    set
                    {
                        var __allocator0 = new global::Std.Allocator<sbyte>();
                        var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                        ((global::CppSharp.Parser.AST.NativeLibrary.__Internal*) __Instance)->fileName = *(global::Std.BasicString.__Internal*) __basicString0.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.ArchType ArchType
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.NativeLibrary.__Internal*) __Instance)->archType;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.NativeLibrary.__Internal*) __Instance)->archType = value;
                    }
                }

                public uint SymbolsCount
                {
                    get
                    {
                        var __ret = __Internal.GetSymbolsCount((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }

                public uint DependenciesCount
                {
                    get
                    {
                        var __ret = __Internal.GetDependenciesCount((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }
            }

            public unsafe partial class ASTContext : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 24)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::Std.Vector.__Internal TranslationUnits;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0ASTContext@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0ASTContext@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1ASTContext@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor(global::System.IntPtr instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?FindOrCreateModule@ASTContext@AST@CppParser@CppSharp@@QEAAPEAVTranslationUnit@234@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
                    internal static extern global::System.IntPtr FindOrCreateModule(global::System.IntPtr instance, global::Std.BasicString.__Internal File);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getTranslationUnits@ASTContext@AST@CppParser@CppSharp@@QEAAPEAVTranslationUnit@234@I@Z")]
                    internal static extern global::System.IntPtr GetTranslationUnits(global::System.IntPtr instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?addTranslationUnits@ASTContext@AST@CppParser@CppSharp@@QEAAXAEAPEAVTranslationUnit@234@@Z")]
                    internal static extern void AddTranslationUnits(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?clearTranslationUnits@ASTContext@AST@CppParser@CppSharp@@QEAAXXZ")]
                    internal static extern void ClearTranslationUnits(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getTranslationUnitsCount@ASTContext@AST@CppParser@CppSharp@@QEAAIXZ")]
                    internal static extern uint GetTranslationUnitsCount(global::System.IntPtr instance);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                protected int __PointerAdjustment;
                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.ASTContext> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.ASTContext>();
                protected void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                internal static global::CppSharp.Parser.AST.ASTContext __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.ASTContext(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.ASTContext __CreateInstance(global::CppSharp.Parser.AST.ASTContext.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.ASTContext(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.ASTContext.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ASTContext.__Internal));
                    global::CppSharp.Parser.AST.ASTContext.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private ASTContext(global::CppSharp.Parser.AST.ASTContext.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected ASTContext(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public ASTContext()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ASTContext.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment));
                }

                public ASTContext(global::CppSharp.Parser.AST.ASTContext _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ASTContext.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                public virtual void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.ASTContext __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.TranslationUnit FindOrCreateModule(string File)
                {
                    var __allocator0 = new global::Std.Allocator<sbyte>();
                    var __basicString0 = global::Std.BasicStringExtensions.BasicString(File, __allocator0);
                    var __arg0 = *(global::Std.BasicString.__Internal*) __basicString0.__Instance;
                    var __ret = __Internal.FindOrCreateModule((__Instance + __PointerAdjustment), __arg0);
                    __basicString0.Dispose(false);
                    __allocator0.Dispose();
                    global::CppSharp.Parser.AST.TranslationUnit __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.TranslationUnit.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::CppSharp.Parser.AST.TranslationUnit) global::CppSharp.Parser.AST.TranslationUnit.NativeToManagedMap[__ret];
                    else __result0 = global::CppSharp.Parser.AST.TranslationUnit.__CreateInstance(__ret);
                    return __result0;
                }

                public global::CppSharp.Parser.AST.TranslationUnit GetTranslationUnits(uint i)
                {
                    var __ret = __Internal.GetTranslationUnits((__Instance + __PointerAdjustment), i);
                    global::CppSharp.Parser.AST.TranslationUnit __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.TranslationUnit.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::CppSharp.Parser.AST.TranslationUnit) global::CppSharp.Parser.AST.TranslationUnit.NativeToManagedMap[__ret];
                    else __result0 = global::CppSharp.Parser.AST.TranslationUnit.__CreateInstance(__ret);
                    return __result0;
                }

                public void AddTranslationUnits(global::CppSharp.Parser.AST.TranslationUnit s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    __Internal.AddTranslationUnits((__Instance + __PointerAdjustment), __arg0);
                }

                public void ClearTranslationUnits()
                {
                    __Internal.ClearTranslationUnits((__Instance + __PointerAdjustment));
                }

                public uint TranslationUnitsCount
                {
                    get
                    {
                        var __ret = __Internal.GetTranslationUnitsCount((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }
            }

            public unsafe partial class Comment : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 4)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.CommentKind kind;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0Comment@AST@CppParser@CppSharp@@QEAA@W4CommentKind@123@@Z")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::CppSharp.Parser.AST.CommentKind kind);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0Comment@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                protected int __PointerAdjustment;
                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.Comment> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.Comment>();
                protected void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                internal static global::CppSharp.Parser.AST.Comment __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.Comment(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.Comment __CreateInstance(global::CppSharp.Parser.AST.Comment.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.Comment(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.Comment.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Comment.__Internal));
                    *(global::CppSharp.Parser.AST.Comment.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private Comment(global::CppSharp.Parser.AST.Comment.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected Comment(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public Comment(global::CppSharp.Parser.AST.CommentKind kind)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Comment.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment), kind);
                }

                public Comment(global::CppSharp.Parser.AST.Comment _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Comment.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.Comment.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.Comment.__Internal*) _0.__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                public virtual void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Comment __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public static implicit operator global::CppSharp.Parser.AST.Comment(global::CppSharp.Parser.AST.CommentKind kind)
                {
                    return new global::CppSharp.Parser.AST.Comment(kind);
                }

                public global::CppSharp.Parser.AST.CommentKind Kind
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Comment.__Internal*) __Instance)->kind;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Comment.__Internal*) __Instance)->kind = value;
                    }
                }
            }

            public unsafe partial class BlockContentComment : global::CppSharp.Parser.AST.Comment, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 4)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.CommentKind kind;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0BlockContentComment@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0BlockContentComment@AST@CppParser@CppSharp@@QEAA@W4CommentKind@123@@Z")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::CppSharp.Parser.AST.CommentKind Kind);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0BlockContentComment@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.BlockContentComment __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.BlockContentComment(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.BlockContentComment __CreateInstance(global::CppSharp.Parser.AST.BlockContentComment.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.BlockContentComment(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.BlockContentComment.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.BlockContentComment.__Internal));
                    *(global::CppSharp.Parser.AST.BlockContentComment.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private BlockContentComment(global::CppSharp.Parser.AST.BlockContentComment.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected BlockContentComment(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public BlockContentComment()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.BlockContentComment.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment));
                }

                public BlockContentComment(global::CppSharp.Parser.AST.CommentKind Kind)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.BlockContentComment.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment), Kind);
                }

                public BlockContentComment(global::CppSharp.Parser.AST.BlockContentComment _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.BlockContentComment.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.BlockContentComment.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.BlockContentComment.__Internal*) _0.__Instance);
                }

                public static implicit operator global::CppSharp.Parser.AST.BlockContentComment(global::CppSharp.Parser.AST.CommentKind Kind)
                {
                    return new global::CppSharp.Parser.AST.BlockContentComment(Kind);
                }
            }

            public unsafe partial class FullComment : global::CppSharp.Parser.AST.Comment, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 32)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.CommentKind kind;

                    [FieldOffset(8)]
                    internal global::Std.Vector.__Internal Blocks;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0FullComment@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0FullComment@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1FullComment@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor(global::System.IntPtr instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getBlocks@FullComment@AST@CppParser@CppSharp@@QEAAPEAVBlockContentComment@234@I@Z")]
                    internal static extern global::System.IntPtr GetBlocks(global::System.IntPtr instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?addBlocks@FullComment@AST@CppParser@CppSharp@@QEAAXAEAPEAVBlockContentComment@234@@Z")]
                    internal static extern void AddBlocks(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?clearBlocks@FullComment@AST@CppParser@CppSharp@@QEAAXXZ")]
                    internal static extern void ClearBlocks(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getBlocksCount@FullComment@AST@CppParser@CppSharp@@QEAAIXZ")]
                    internal static extern uint GetBlocksCount(global::System.IntPtr instance);
                }

                internal static new global::CppSharp.Parser.AST.FullComment __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.FullComment(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.FullComment __CreateInstance(global::CppSharp.Parser.AST.FullComment.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.FullComment(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.FullComment.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.FullComment.__Internal));
                    global::CppSharp.Parser.AST.FullComment.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private FullComment(global::CppSharp.Parser.AST.FullComment.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected FullComment(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public FullComment()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.FullComment.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment));
                }

                public FullComment(global::CppSharp.Parser.AST.FullComment _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.FullComment.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Comment __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.BlockContentComment GetBlocks(uint i)
                {
                    var __ret = __Internal.GetBlocks((__Instance + __PointerAdjustment), i);
                    global::CppSharp.Parser.AST.BlockContentComment __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.BlockContentComment.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::CppSharp.Parser.AST.BlockContentComment) global::CppSharp.Parser.AST.BlockContentComment.NativeToManagedMap[__ret];
                    else __result0 = global::CppSharp.Parser.AST.BlockContentComment.__CreateInstance(__ret);
                    return __result0;
                }

                public void AddBlocks(global::CppSharp.Parser.AST.BlockContentComment s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    __Internal.AddBlocks((__Instance + __PointerAdjustment), __arg0);
                }

                public void ClearBlocks()
                {
                    __Internal.ClearBlocks((__Instance + __PointerAdjustment));
                }

                public uint BlocksCount
                {
                    get
                    {
                        var __ret = __Internal.GetBlocksCount((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }
            }

            public unsafe partial class InlineContentComment : global::CppSharp.Parser.AST.Comment, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 8)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.CommentKind kind;

                    [FieldOffset(4)]
                    internal byte hasTrailingNewline;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0InlineContentComment@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0InlineContentComment@AST@CppParser@CppSharp@@QEAA@W4CommentKind@123@@Z")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::CppSharp.Parser.AST.CommentKind Kind);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0InlineContentComment@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.InlineContentComment __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.InlineContentComment(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.InlineContentComment __CreateInstance(global::CppSharp.Parser.AST.InlineContentComment.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.InlineContentComment(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.InlineContentComment.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.InlineContentComment.__Internal));
                    *(global::CppSharp.Parser.AST.InlineContentComment.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private InlineContentComment(global::CppSharp.Parser.AST.InlineContentComment.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected InlineContentComment(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public InlineContentComment()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.InlineContentComment.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment));
                }

                public InlineContentComment(global::CppSharp.Parser.AST.CommentKind Kind)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.InlineContentComment.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment), Kind);
                }

                public InlineContentComment(global::CppSharp.Parser.AST.InlineContentComment _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.InlineContentComment.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.InlineContentComment.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.InlineContentComment.__Internal*) _0.__Instance);
                }

                public static implicit operator global::CppSharp.Parser.AST.InlineContentComment(global::CppSharp.Parser.AST.CommentKind Kind)
                {
                    return new global::CppSharp.Parser.AST.InlineContentComment(Kind);
                }

                public bool HasTrailingNewline
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.InlineContentComment.__Internal*) __Instance)->hasTrailingNewline != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.InlineContentComment.__Internal*) __Instance)->hasTrailingNewline = (byte) (value ? 1 : 0);
                    }
                }
            }

            public unsafe partial class ParagraphComment : global::CppSharp.Parser.AST.BlockContentComment, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 32)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.CommentKind kind;

                    [FieldOffset(4)]
                    internal byte isWhitespace;

                    [FieldOffset(8)]
                    internal global::Std.Vector.__Internal Content;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0ParagraphComment@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0ParagraphComment@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1ParagraphComment@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor(global::System.IntPtr instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getContent@ParagraphComment@AST@CppParser@CppSharp@@QEAAPEAVInlineContentComment@234@I@Z")]
                    internal static extern global::System.IntPtr GetContent(global::System.IntPtr instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?addContent@ParagraphComment@AST@CppParser@CppSharp@@QEAAXAEAPEAVInlineContentComment@234@@Z")]
                    internal static extern void AddContent(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?clearContent@ParagraphComment@AST@CppParser@CppSharp@@QEAAXXZ")]
                    internal static extern void ClearContent(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getContentCount@ParagraphComment@AST@CppParser@CppSharp@@QEAAIXZ")]
                    internal static extern uint GetContentCount(global::System.IntPtr instance);
                }

                internal static new global::CppSharp.Parser.AST.ParagraphComment __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.ParagraphComment(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.ParagraphComment __CreateInstance(global::CppSharp.Parser.AST.ParagraphComment.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.ParagraphComment(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.ParagraphComment.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ParagraphComment.__Internal));
                    global::CppSharp.Parser.AST.ParagraphComment.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private ParagraphComment(global::CppSharp.Parser.AST.ParagraphComment.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected ParagraphComment(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public ParagraphComment()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ParagraphComment.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment));
                }

                public ParagraphComment(global::CppSharp.Parser.AST.ParagraphComment _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ParagraphComment.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Comment __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.InlineContentComment GetContent(uint i)
                {
                    var __ret = __Internal.GetContent((__Instance + __PointerAdjustment), i);
                    global::CppSharp.Parser.AST.InlineContentComment __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.InlineContentComment.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::CppSharp.Parser.AST.InlineContentComment) global::CppSharp.Parser.AST.InlineContentComment.NativeToManagedMap[__ret];
                    else __result0 = global::CppSharp.Parser.AST.InlineContentComment.__CreateInstance(__ret);
                    return __result0;
                }

                public void AddContent(global::CppSharp.Parser.AST.InlineContentComment s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    __Internal.AddContent((__Instance + __PointerAdjustment), __arg0);
                }

                public void ClearContent()
                {
                    __Internal.ClearContent((__Instance + __PointerAdjustment));
                }

                public bool IsWhitespace
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.ParagraphComment.__Internal*) __Instance)->isWhitespace != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.ParagraphComment.__Internal*) __Instance)->isWhitespace = (byte) (value ? 1 : 0);
                    }
                }

                public uint ContentCount
                {
                    get
                    {
                        var __ret = __Internal.GetContentCount((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }
            }

            public unsafe partial class BlockCommandComment : global::CppSharp.Parser.AST.BlockContentComment, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 40)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.CommentKind kind;

                    [FieldOffset(4)]
                    internal uint commandId;

                    [FieldOffset(8)]
                    internal global::System.IntPtr paragraphComment;

                    [FieldOffset(16)]
                    internal global::Std.Vector.__Internal Arguments;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0BlockCommandComment@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0BlockCommandComment@AST@CppParser@CppSharp@@QEAA@W4CommentKind@123@@Z")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::CppSharp.Parser.AST.CommentKind Kind);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0BlockCommandComment@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1BlockCommandComment@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor(global::System.IntPtr instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getArguments@BlockCommandComment@AST@CppParser@CppSharp@@QEAA?AVArgument@1234@I@Z")]
                    internal static extern void GetArguments(global::System.IntPtr instance, global::System.IntPtr @return, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?addArguments@BlockCommandComment@AST@CppParser@CppSharp@@QEAAXAEAVArgument@1234@@Z")]
                    internal static extern void AddArguments(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?clearArguments@BlockCommandComment@AST@CppParser@CppSharp@@QEAAXXZ")]
                    internal static extern void ClearArguments(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getArgumentsCount@BlockCommandComment@AST@CppParser@CppSharp@@QEAAIXZ")]
                    internal static extern uint GetArgumentsCount(global::System.IntPtr instance);
                }

                public unsafe partial class Argument : IDisposable
                {
                    [StructLayout(LayoutKind.Explicit, Size = 32)]
                    public partial struct __Internal
                    {
                        [FieldOffset(0)]
                        internal global::Std.BasicString.__Internal text;

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="??0Argument@BlockCommandComment@AST@CppParser@CppSharp@@QEAA@XZ")]
                        internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="??0Argument@BlockCommandComment@AST@CppParser@CppSharp@@QEAA@AEBV01234@@Z")]
                        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="??1Argument@BlockCommandComment@AST@CppParser@CppSharp@@QEAA@XZ")]
                        internal static extern void dtor(global::System.IntPtr instance, int delete);
                    }

                    public global::System.IntPtr __Instance { get; protected set; }

                    protected int __PointerAdjustment;
                    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.BlockCommandComment.Argument> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.BlockCommandComment.Argument>();
                    protected void*[] __OriginalVTables;

                    protected bool __ownsNativeInstance;

                    internal static global::CppSharp.Parser.AST.BlockCommandComment.Argument __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                    {
                        return new global::CppSharp.Parser.AST.BlockCommandComment.Argument(native.ToPointer(), skipVTables);
                    }

                    internal static global::CppSharp.Parser.AST.BlockCommandComment.Argument __CreateInstance(global::CppSharp.Parser.AST.BlockCommandComment.Argument.__Internal native, bool skipVTables = false)
                    {
                        return new global::CppSharp.Parser.AST.BlockCommandComment.Argument(native, skipVTables);
                    }

                    private static void* __CopyValue(global::CppSharp.Parser.AST.BlockCommandComment.Argument.__Internal native)
                    {
                        var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.BlockCommandComment.Argument.__Internal));
                        global::CppSharp.Parser.AST.BlockCommandComment.Argument.__Internal.cctor(ret, new global::System.IntPtr(&native));
                        return ret.ToPointer();
                    }

                    private Argument(global::CppSharp.Parser.AST.BlockCommandComment.Argument.__Internal native, bool skipVTables = false)
                        : this(__CopyValue(native), skipVTables)
                    {
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                    }

                    protected Argument(void* native, bool skipVTables = false)
                    {
                        if (native == null)
                            return;
                        __Instance = new global::System.IntPtr(native);
                    }

                    public Argument()
                    {
                        __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.BlockCommandComment.Argument.__Internal));
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                        __Internal.ctor((__Instance + __PointerAdjustment));
                    }

                    public Argument(global::CppSharp.Parser.AST.BlockCommandComment.Argument _0)
                    {
                        __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.BlockCommandComment.Argument.__Internal));
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                        if (ReferenceEquals(_0, null))
                            throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                        var __arg0 = _0.__Instance;
                        __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
                    }

                    public void Dispose()
                    {
                        Dispose(disposing: true);
                    }

                    public virtual void Dispose(bool disposing)
                    {
                        if (__Instance == IntPtr.Zero)
                            return;
                        global::CppSharp.Parser.AST.BlockCommandComment.Argument __dummy;
                        NativeToManagedMap.TryRemove(__Instance, out __dummy);
                        if (disposing)
                            __Internal.dtor((__Instance + __PointerAdjustment), 0);
                        if (__ownsNativeInstance)
                            Marshal.FreeHGlobal(__Instance);
                        __Instance = IntPtr.Zero;
                    }

                    public string Text
                    {
                        get
                        {
                            var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(((global::CppSharp.Parser.AST.BlockCommandComment.Argument.__Internal*) __Instance)->text);
                            var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                            __basicStringRet.Dispose(false);
                            return __stringRet;
                        }

                        set
                        {
                            var __allocator0 = new global::Std.Allocator<sbyte>();
                            var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                            ((global::CppSharp.Parser.AST.BlockCommandComment.Argument.__Internal*) __Instance)->text = *(global::Std.BasicString.__Internal*) __basicString0.__Instance;
                        }
                    }
                }

                internal static new global::CppSharp.Parser.AST.BlockCommandComment __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.BlockCommandComment(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.BlockCommandComment __CreateInstance(global::CppSharp.Parser.AST.BlockCommandComment.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.BlockCommandComment(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.BlockCommandComment.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.BlockCommandComment.__Internal));
                    global::CppSharp.Parser.AST.BlockCommandComment.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private BlockCommandComment(global::CppSharp.Parser.AST.BlockCommandComment.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected BlockCommandComment(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public BlockCommandComment()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.BlockCommandComment.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment));
                }

                public BlockCommandComment(global::CppSharp.Parser.AST.CommentKind Kind)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.BlockCommandComment.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment), Kind);
                }

                public BlockCommandComment(global::CppSharp.Parser.AST.BlockCommandComment _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.BlockCommandComment.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Comment __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.BlockCommandComment.Argument GetArguments(uint i)
                {
                    var __ret = new global::CppSharp.Parser.AST.BlockCommandComment.Argument.__Internal();
                    __Internal.GetArguments((__Instance + __PointerAdjustment), new IntPtr(&__ret), i);
                    return global::CppSharp.Parser.AST.BlockCommandComment.Argument.__CreateInstance(__ret);
                }

                public void AddArguments(global::CppSharp.Parser.AST.BlockCommandComment.Argument s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    __Internal.AddArguments((__Instance + __PointerAdjustment), __arg0);
                }

                public void ClearArguments()
                {
                    __Internal.ClearArguments((__Instance + __PointerAdjustment));
                }

                public static implicit operator global::CppSharp.Parser.AST.BlockCommandComment(global::CppSharp.Parser.AST.CommentKind Kind)
                {
                    return new global::CppSharp.Parser.AST.BlockCommandComment(Kind);
                }

                public uint CommandId
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.BlockCommandComment.__Internal*) __Instance)->commandId;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.BlockCommandComment.__Internal*) __Instance)->commandId = value;
                    }
                }

                public global::CppSharp.Parser.AST.ParagraphComment ParagraphComment
                {
                    get
                    {
                        global::CppSharp.Parser.AST.ParagraphComment __result0;
                        if (((global::CppSharp.Parser.AST.BlockCommandComment.__Internal*) __Instance)->paragraphComment == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.ParagraphComment.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.BlockCommandComment.__Internal*) __Instance)->paragraphComment))
                            __result0 = (global::CppSharp.Parser.AST.ParagraphComment) global::CppSharp.Parser.AST.ParagraphComment.NativeToManagedMap[((global::CppSharp.Parser.AST.BlockCommandComment.__Internal*) __Instance)->paragraphComment];
                        else __result0 = global::CppSharp.Parser.AST.ParagraphComment.__CreateInstance(((global::CppSharp.Parser.AST.BlockCommandComment.__Internal*) __Instance)->paragraphComment);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.BlockCommandComment.__Internal*) __Instance)->paragraphComment = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public uint ArgumentsCount
                {
                    get
                    {
                        var __ret = __Internal.GetArgumentsCount((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }
            }

            public unsafe partial class ParamCommandComment : global::CppSharp.Parser.AST.BlockCommandComment, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 48)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.CommentKind kind;

                    [FieldOffset(4)]
                    internal uint commandId;

                    [FieldOffset(8)]
                    internal global::System.IntPtr paragraphComment;

                    [FieldOffset(16)]
                    internal global::Std.Vector.__Internal Arguments;

                    [FieldOffset(40)]
                    internal global::CppSharp.Parser.AST.ParamCommandComment.PassDirection direction;

                    [FieldOffset(44)]
                    internal uint paramIndex;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0ParamCommandComment@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0ParamCommandComment@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1ParamCommandComment@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor(global::System.IntPtr instance, int delete);
                }

                public enum PassDirection
                {
                    In = 0,
                    Out = 1,
                    InOut = 2
                }

                internal static new global::CppSharp.Parser.AST.ParamCommandComment __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.ParamCommandComment(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.ParamCommandComment __CreateInstance(global::CppSharp.Parser.AST.ParamCommandComment.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.ParamCommandComment(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.ParamCommandComment.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ParamCommandComment.__Internal));
                    global::CppSharp.Parser.AST.ParamCommandComment.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private ParamCommandComment(global::CppSharp.Parser.AST.ParamCommandComment.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected ParamCommandComment(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public ParamCommandComment()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ParamCommandComment.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment));
                }

                public ParamCommandComment(global::CppSharp.Parser.AST.ParamCommandComment _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ParamCommandComment.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Comment __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.ParamCommandComment.PassDirection Direction
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.ParamCommandComment.__Internal*) __Instance)->direction;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.ParamCommandComment.__Internal*) __Instance)->direction = value;
                    }
                }

                public uint ParamIndex
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.ParamCommandComment.__Internal*) __Instance)->paramIndex;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.ParamCommandComment.__Internal*) __Instance)->paramIndex = value;
                    }
                }
            }

            public unsafe partial class TParamCommandComment : global::CppSharp.Parser.AST.BlockCommandComment, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 64)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.CommentKind kind;

                    [FieldOffset(4)]
                    internal uint commandId;

                    [FieldOffset(8)]
                    internal global::System.IntPtr paragraphComment;

                    [FieldOffset(16)]
                    internal global::Std.Vector.__Internal Arguments;

                    [FieldOffset(40)]
                    internal global::Std.Vector.__Internal Position;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0TParamCommandComment@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0TParamCommandComment@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1TParamCommandComment@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor(global::System.IntPtr instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getPosition@TParamCommandComment@AST@CppParser@CppSharp@@QEAAII@Z")]
                    internal static extern uint GetPosition(global::System.IntPtr instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?addPosition@TParamCommandComment@AST@CppParser@CppSharp@@QEAAXAEAI@Z")]
                    internal static extern void AddPosition(global::System.IntPtr instance, uint* s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?clearPosition@TParamCommandComment@AST@CppParser@CppSharp@@QEAAXXZ")]
                    internal static extern void ClearPosition(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getPositionCount@TParamCommandComment@AST@CppParser@CppSharp@@QEAAIXZ")]
                    internal static extern uint GetPositionCount(global::System.IntPtr instance);
                }

                internal static new global::CppSharp.Parser.AST.TParamCommandComment __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.TParamCommandComment(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.TParamCommandComment __CreateInstance(global::CppSharp.Parser.AST.TParamCommandComment.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.TParamCommandComment(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.TParamCommandComment.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TParamCommandComment.__Internal));
                    global::CppSharp.Parser.AST.TParamCommandComment.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private TParamCommandComment(global::CppSharp.Parser.AST.TParamCommandComment.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected TParamCommandComment(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public TParamCommandComment()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TParamCommandComment.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment));
                }

                public TParamCommandComment(global::CppSharp.Parser.AST.TParamCommandComment _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TParamCommandComment.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Comment __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public uint GetPosition(uint i)
                {
                    var __ret = __Internal.GetPosition((__Instance + __PointerAdjustment), i);
                    return __ret;
                }

                public void AddPosition(ref uint s)
                {
                    fixed (uint* __refParamPtr0 = &s)
                    {
                        var __arg0 = __refParamPtr0;
                        __Internal.AddPosition((__Instance + __PointerAdjustment), __arg0);
                    }
                }

                public void ClearPosition()
                {
                    __Internal.ClearPosition((__Instance + __PointerAdjustment));
                }

                public uint PositionCount
                {
                    get
                    {
                        var __ret = __Internal.GetPositionCount((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }
            }

            public unsafe partial class VerbatimBlockLineComment : global::CppSharp.Parser.AST.Comment, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 40)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.CommentKind kind;

                    [FieldOffset(8)]
                    internal global::Std.BasicString.__Internal text;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0VerbatimBlockLineComment@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0VerbatimBlockLineComment@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1VerbatimBlockLineComment@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor(global::System.IntPtr instance, int delete);
                }

                internal static new global::CppSharp.Parser.AST.VerbatimBlockLineComment __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.VerbatimBlockLineComment(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.VerbatimBlockLineComment __CreateInstance(global::CppSharp.Parser.AST.VerbatimBlockLineComment.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.VerbatimBlockLineComment(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.VerbatimBlockLineComment.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.VerbatimBlockLineComment.__Internal));
                    global::CppSharp.Parser.AST.VerbatimBlockLineComment.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private VerbatimBlockLineComment(global::CppSharp.Parser.AST.VerbatimBlockLineComment.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected VerbatimBlockLineComment(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public VerbatimBlockLineComment()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.VerbatimBlockLineComment.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment));
                }

                public VerbatimBlockLineComment(global::CppSharp.Parser.AST.VerbatimBlockLineComment _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.VerbatimBlockLineComment.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Comment __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public string Text
                {
                    get
                    {
                        var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(((global::CppSharp.Parser.AST.VerbatimBlockLineComment.__Internal*) __Instance)->text);
                        var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                        __basicStringRet.Dispose(false);
                        return __stringRet;
                    }

                    set
                    {
                        var __allocator0 = new global::Std.Allocator<sbyte>();
                        var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                        ((global::CppSharp.Parser.AST.VerbatimBlockLineComment.__Internal*) __Instance)->text = *(global::Std.BasicString.__Internal*) __basicString0.__Instance;
                    }
                }
            }

            public unsafe partial class VerbatimBlockComment : global::CppSharp.Parser.AST.BlockCommandComment, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 64)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.CommentKind kind;

                    [FieldOffset(4)]
                    internal uint commandId;

                    [FieldOffset(8)]
                    internal global::System.IntPtr paragraphComment;

                    [FieldOffset(16)]
                    internal global::Std.Vector.__Internal Arguments;

                    [FieldOffset(40)]
                    internal global::Std.Vector.__Internal Lines;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0VerbatimBlockComment@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0VerbatimBlockComment@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1VerbatimBlockComment@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor(global::System.IntPtr instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getLines@VerbatimBlockComment@AST@CppParser@CppSharp@@QEAAPEAVVerbatimBlockLineComment@234@I@Z")]
                    internal static extern global::System.IntPtr GetLines(global::System.IntPtr instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?addLines@VerbatimBlockComment@AST@CppParser@CppSharp@@QEAAXAEAPEAVVerbatimBlockLineComment@234@@Z")]
                    internal static extern void AddLines(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?clearLines@VerbatimBlockComment@AST@CppParser@CppSharp@@QEAAXXZ")]
                    internal static extern void ClearLines(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getLinesCount@VerbatimBlockComment@AST@CppParser@CppSharp@@QEAAIXZ")]
                    internal static extern uint GetLinesCount(global::System.IntPtr instance);
                }

                internal static new global::CppSharp.Parser.AST.VerbatimBlockComment __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.VerbatimBlockComment(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.VerbatimBlockComment __CreateInstance(global::CppSharp.Parser.AST.VerbatimBlockComment.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.VerbatimBlockComment(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.VerbatimBlockComment.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.VerbatimBlockComment.__Internal));
                    global::CppSharp.Parser.AST.VerbatimBlockComment.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private VerbatimBlockComment(global::CppSharp.Parser.AST.VerbatimBlockComment.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected VerbatimBlockComment(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public VerbatimBlockComment()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.VerbatimBlockComment.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment));
                }

                public VerbatimBlockComment(global::CppSharp.Parser.AST.VerbatimBlockComment _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.VerbatimBlockComment.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Comment __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.VerbatimBlockLineComment GetLines(uint i)
                {
                    var __ret = __Internal.GetLines((__Instance + __PointerAdjustment), i);
                    global::CppSharp.Parser.AST.VerbatimBlockLineComment __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.VerbatimBlockLineComment.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::CppSharp.Parser.AST.VerbatimBlockLineComment) global::CppSharp.Parser.AST.VerbatimBlockLineComment.NativeToManagedMap[__ret];
                    else __result0 = global::CppSharp.Parser.AST.VerbatimBlockLineComment.__CreateInstance(__ret);
                    return __result0;
                }

                public void AddLines(global::CppSharp.Parser.AST.VerbatimBlockLineComment s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    __Internal.AddLines((__Instance + __PointerAdjustment), __arg0);
                }

                public void ClearLines()
                {
                    __Internal.ClearLines((__Instance + __PointerAdjustment));
                }

                public uint LinesCount
                {
                    get
                    {
                        var __ret = __Internal.GetLinesCount((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }
            }

            public unsafe partial class VerbatimLineComment : global::CppSharp.Parser.AST.BlockCommandComment, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 72)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.CommentKind kind;

                    [FieldOffset(4)]
                    internal uint commandId;

                    [FieldOffset(8)]
                    internal global::System.IntPtr paragraphComment;

                    [FieldOffset(16)]
                    internal global::Std.Vector.__Internal Arguments;

                    [FieldOffset(40)]
                    internal global::Std.BasicString.__Internal text;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0VerbatimLineComment@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0VerbatimLineComment@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1VerbatimLineComment@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor(global::System.IntPtr instance, int delete);
                }

                internal static new global::CppSharp.Parser.AST.VerbatimLineComment __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.VerbatimLineComment(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.VerbatimLineComment __CreateInstance(global::CppSharp.Parser.AST.VerbatimLineComment.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.VerbatimLineComment(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.VerbatimLineComment.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.VerbatimLineComment.__Internal));
                    global::CppSharp.Parser.AST.VerbatimLineComment.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private VerbatimLineComment(global::CppSharp.Parser.AST.VerbatimLineComment.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected VerbatimLineComment(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public VerbatimLineComment()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.VerbatimLineComment.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment));
                }

                public VerbatimLineComment(global::CppSharp.Parser.AST.VerbatimLineComment _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.VerbatimLineComment.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Comment __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public string Text
                {
                    get
                    {
                        var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(((global::CppSharp.Parser.AST.VerbatimLineComment.__Internal*) __Instance)->text);
                        var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                        __basicStringRet.Dispose(false);
                        return __stringRet;
                    }

                    set
                    {
                        var __allocator0 = new global::Std.Allocator<sbyte>();
                        var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                        ((global::CppSharp.Parser.AST.VerbatimLineComment.__Internal*) __Instance)->text = *(global::Std.BasicString.__Internal*) __basicString0.__Instance;
                    }
                }
            }

            public unsafe partial class InlineCommandComment : global::CppSharp.Parser.AST.InlineContentComment, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 40)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.CommentKind kind;

                    [FieldOffset(4)]
                    internal byte hasTrailingNewline;

                    [FieldOffset(8)]
                    internal uint commandId;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.AST.InlineCommandComment.RenderKind commentRenderKind;

                    [FieldOffset(16)]
                    internal global::Std.Vector.__Internal Arguments;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0InlineCommandComment@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0InlineCommandComment@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1InlineCommandComment@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor(global::System.IntPtr instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getArguments@InlineCommandComment@AST@CppParser@CppSharp@@QEAA?AVArgument@1234@I@Z")]
                    internal static extern void GetArguments(global::System.IntPtr instance, global::System.IntPtr @return, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?addArguments@InlineCommandComment@AST@CppParser@CppSharp@@QEAAXAEAVArgument@1234@@Z")]
                    internal static extern void AddArguments(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?clearArguments@InlineCommandComment@AST@CppParser@CppSharp@@QEAAXXZ")]
                    internal static extern void ClearArguments(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getArgumentsCount@InlineCommandComment@AST@CppParser@CppSharp@@QEAAIXZ")]
                    internal static extern uint GetArgumentsCount(global::System.IntPtr instance);
                }

                public enum RenderKind
                {
                    RenderNormal = 0,
                    RenderBold = 1,
                    RenderMonospaced = 2,
                    RenderEmphasized = 3
                }

                public unsafe partial class Argument : IDisposable
                {
                    [StructLayout(LayoutKind.Explicit, Size = 32)]
                    public partial struct __Internal
                    {
                        [FieldOffset(0)]
                        internal global::Std.BasicString.__Internal text;

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="??0Argument@InlineCommandComment@AST@CppParser@CppSharp@@QEAA@XZ")]
                        internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="??0Argument@InlineCommandComment@AST@CppParser@CppSharp@@QEAA@AEBV01234@@Z")]
                        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="??1Argument@InlineCommandComment@AST@CppParser@CppSharp@@QEAA@XZ")]
                        internal static extern void dtor(global::System.IntPtr instance, int delete);
                    }

                    public global::System.IntPtr __Instance { get; protected set; }

                    protected int __PointerAdjustment;
                    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.InlineCommandComment.Argument> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.InlineCommandComment.Argument>();
                    protected void*[] __OriginalVTables;

                    protected bool __ownsNativeInstance;

                    internal static global::CppSharp.Parser.AST.InlineCommandComment.Argument __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                    {
                        return new global::CppSharp.Parser.AST.InlineCommandComment.Argument(native.ToPointer(), skipVTables);
                    }

                    internal static global::CppSharp.Parser.AST.InlineCommandComment.Argument __CreateInstance(global::CppSharp.Parser.AST.InlineCommandComment.Argument.__Internal native, bool skipVTables = false)
                    {
                        return new global::CppSharp.Parser.AST.InlineCommandComment.Argument(native, skipVTables);
                    }

                    private static void* __CopyValue(global::CppSharp.Parser.AST.InlineCommandComment.Argument.__Internal native)
                    {
                        var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.InlineCommandComment.Argument.__Internal));
                        global::CppSharp.Parser.AST.InlineCommandComment.Argument.__Internal.cctor(ret, new global::System.IntPtr(&native));
                        return ret.ToPointer();
                    }

                    private Argument(global::CppSharp.Parser.AST.InlineCommandComment.Argument.__Internal native, bool skipVTables = false)
                        : this(__CopyValue(native), skipVTables)
                    {
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                    }

                    protected Argument(void* native, bool skipVTables = false)
                    {
                        if (native == null)
                            return;
                        __Instance = new global::System.IntPtr(native);
                    }

                    public Argument()
                    {
                        __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.InlineCommandComment.Argument.__Internal));
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                        __Internal.ctor((__Instance + __PointerAdjustment));
                    }

                    public Argument(global::CppSharp.Parser.AST.InlineCommandComment.Argument _0)
                    {
                        __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.InlineCommandComment.Argument.__Internal));
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                        if (ReferenceEquals(_0, null))
                            throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                        var __arg0 = _0.__Instance;
                        __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
                    }

                    public void Dispose()
                    {
                        Dispose(disposing: true);
                    }

                    public virtual void Dispose(bool disposing)
                    {
                        if (__Instance == IntPtr.Zero)
                            return;
                        global::CppSharp.Parser.AST.InlineCommandComment.Argument __dummy;
                        NativeToManagedMap.TryRemove(__Instance, out __dummy);
                        if (disposing)
                            __Internal.dtor((__Instance + __PointerAdjustment), 0);
                        if (__ownsNativeInstance)
                            Marshal.FreeHGlobal(__Instance);
                        __Instance = IntPtr.Zero;
                    }

                    public string Text
                    {
                        get
                        {
                            var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(((global::CppSharp.Parser.AST.InlineCommandComment.Argument.__Internal*) __Instance)->text);
                            var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                            __basicStringRet.Dispose(false);
                            return __stringRet;
                        }

                        set
                        {
                            var __allocator0 = new global::Std.Allocator<sbyte>();
                            var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                            ((global::CppSharp.Parser.AST.InlineCommandComment.Argument.__Internal*) __Instance)->text = *(global::Std.BasicString.__Internal*) __basicString0.__Instance;
                        }
                    }
                }

                internal static new global::CppSharp.Parser.AST.InlineCommandComment __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.InlineCommandComment(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.InlineCommandComment __CreateInstance(global::CppSharp.Parser.AST.InlineCommandComment.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.InlineCommandComment(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.InlineCommandComment.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.InlineCommandComment.__Internal));
                    global::CppSharp.Parser.AST.InlineCommandComment.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private InlineCommandComment(global::CppSharp.Parser.AST.InlineCommandComment.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected InlineCommandComment(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public InlineCommandComment()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.InlineCommandComment.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment));
                }

                public InlineCommandComment(global::CppSharp.Parser.AST.InlineCommandComment _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.InlineCommandComment.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Comment __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.InlineCommandComment.Argument GetArguments(uint i)
                {
                    var __ret = new global::CppSharp.Parser.AST.InlineCommandComment.Argument.__Internal();
                    __Internal.GetArguments((__Instance + __PointerAdjustment), new IntPtr(&__ret), i);
                    return global::CppSharp.Parser.AST.InlineCommandComment.Argument.__CreateInstance(__ret);
                }

                public void AddArguments(global::CppSharp.Parser.AST.InlineCommandComment.Argument s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    __Internal.AddArguments((__Instance + __PointerAdjustment), __arg0);
                }

                public void ClearArguments()
                {
                    __Internal.ClearArguments((__Instance + __PointerAdjustment));
                }

                public uint CommandId
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.InlineCommandComment.__Internal*) __Instance)->commandId;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.InlineCommandComment.__Internal*) __Instance)->commandId = value;
                    }
                }

                public global::CppSharp.Parser.AST.InlineCommandComment.RenderKind CommentRenderKind
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.InlineCommandComment.__Internal*) __Instance)->commentRenderKind;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.InlineCommandComment.__Internal*) __Instance)->commentRenderKind = value;
                    }
                }

                public uint ArgumentsCount
                {
                    get
                    {
                        var __ret = __Internal.GetArgumentsCount((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }
            }

            public unsafe partial class HTMLTagComment : global::CppSharp.Parser.AST.InlineContentComment, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 8)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.CommentKind kind;

                    [FieldOffset(4)]
                    internal byte hasTrailingNewline;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0HTMLTagComment@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0HTMLTagComment@AST@CppParser@CppSharp@@QEAA@W4CommentKind@123@@Z")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, global::CppSharp.Parser.AST.CommentKind Kind);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0HTMLTagComment@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.HTMLTagComment __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.HTMLTagComment(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.HTMLTagComment __CreateInstance(global::CppSharp.Parser.AST.HTMLTagComment.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.HTMLTagComment(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.HTMLTagComment.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.HTMLTagComment.__Internal));
                    *(global::CppSharp.Parser.AST.HTMLTagComment.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private HTMLTagComment(global::CppSharp.Parser.AST.HTMLTagComment.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected HTMLTagComment(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public HTMLTagComment()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.HTMLTagComment.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment));
                }

                public HTMLTagComment(global::CppSharp.Parser.AST.CommentKind Kind)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.HTMLTagComment.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment), Kind);
                }

                public HTMLTagComment(global::CppSharp.Parser.AST.HTMLTagComment _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.HTMLTagComment.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.HTMLTagComment.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.HTMLTagComment.__Internal*) _0.__Instance);
                }

                public static implicit operator global::CppSharp.Parser.AST.HTMLTagComment(global::CppSharp.Parser.AST.CommentKind Kind)
                {
                    return new global::CppSharp.Parser.AST.HTMLTagComment(Kind);
                }
            }

            public unsafe partial class HTMLStartTagComment : global::CppSharp.Parser.AST.HTMLTagComment, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 64)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.CommentKind kind;

                    [FieldOffset(4)]
                    internal byte hasTrailingNewline;

                    [FieldOffset(8)]
                    internal global::Std.BasicString.__Internal tagName;

                    [FieldOffset(40)]
                    internal global::Std.Vector.__Internal Attributes;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0HTMLStartTagComment@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0HTMLStartTagComment@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1HTMLStartTagComment@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor(global::System.IntPtr instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getAttributes@HTMLStartTagComment@AST@CppParser@CppSharp@@QEAA?AVAttribute@1234@I@Z")]
                    internal static extern void GetAttributes(global::System.IntPtr instance, global::System.IntPtr @return, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?addAttributes@HTMLStartTagComment@AST@CppParser@CppSharp@@QEAAXAEAVAttribute@1234@@Z")]
                    internal static extern void AddAttributes(global::System.IntPtr instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?clearAttributes@HTMLStartTagComment@AST@CppParser@CppSharp@@QEAAXXZ")]
                    internal static extern void ClearAttributes(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="?getAttributesCount@HTMLStartTagComment@AST@CppParser@CppSharp@@QEAAIXZ")]
                    internal static extern uint GetAttributesCount(global::System.IntPtr instance);
                }

                public unsafe partial class Attribute : IDisposable
                {
                    [StructLayout(LayoutKind.Explicit, Size = 64)]
                    public partial struct __Internal
                    {
                        [FieldOffset(0)]
                        internal global::Std.BasicString.__Internal name;

                        [FieldOffset(32)]
                        internal global::Std.BasicString.__Internal value;

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="??0Attribute@HTMLStartTagComment@AST@CppParser@CppSharp@@QEAA@XZ")]
                        internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="??0Attribute@HTMLStartTagComment@AST@CppParser@CppSharp@@QEAA@AEBV01234@@Z")]
                        internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="??1Attribute@HTMLStartTagComment@AST@CppParser@CppSharp@@QEAA@XZ")]
                        internal static extern void dtor(global::System.IntPtr instance, int delete);
                    }

                    public global::System.IntPtr __Instance { get; protected set; }

                    protected int __PointerAdjustment;
                    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.HTMLStartTagComment.Attribute> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.HTMLStartTagComment.Attribute>();
                    protected void*[] __OriginalVTables;

                    protected bool __ownsNativeInstance;

                    internal static global::CppSharp.Parser.AST.HTMLStartTagComment.Attribute __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                    {
                        return new global::CppSharp.Parser.AST.HTMLStartTagComment.Attribute(native.ToPointer(), skipVTables);
                    }

                    internal static global::CppSharp.Parser.AST.HTMLStartTagComment.Attribute __CreateInstance(global::CppSharp.Parser.AST.HTMLStartTagComment.Attribute.__Internal native, bool skipVTables = false)
                    {
                        return new global::CppSharp.Parser.AST.HTMLStartTagComment.Attribute(native, skipVTables);
                    }

                    private static void* __CopyValue(global::CppSharp.Parser.AST.HTMLStartTagComment.Attribute.__Internal native)
                    {
                        var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.HTMLStartTagComment.Attribute.__Internal));
                        global::CppSharp.Parser.AST.HTMLStartTagComment.Attribute.__Internal.cctor(ret, new global::System.IntPtr(&native));
                        return ret.ToPointer();
                    }

                    private Attribute(global::CppSharp.Parser.AST.HTMLStartTagComment.Attribute.__Internal native, bool skipVTables = false)
                        : this(__CopyValue(native), skipVTables)
                    {
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                    }

                    protected Attribute(void* native, bool skipVTables = false)
                    {
                        if (native == null)
                            return;
                        __Instance = new global::System.IntPtr(native);
                    }

                    public Attribute()
                    {
                        __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.HTMLStartTagComment.Attribute.__Internal));
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                        __Internal.ctor((__Instance + __PointerAdjustment));
                    }

                    public Attribute(global::CppSharp.Parser.AST.HTMLStartTagComment.Attribute _0)
                    {
                        __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.HTMLStartTagComment.Attribute.__Internal));
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                        if (ReferenceEquals(_0, null))
                            throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                        var __arg0 = _0.__Instance;
                        __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
                    }

                    public void Dispose()
                    {
                        Dispose(disposing: true);
                    }

                    public virtual void Dispose(bool disposing)
                    {
                        if (__Instance == IntPtr.Zero)
                            return;
                        global::CppSharp.Parser.AST.HTMLStartTagComment.Attribute __dummy;
                        NativeToManagedMap.TryRemove(__Instance, out __dummy);
                        if (disposing)
                            __Internal.dtor((__Instance + __PointerAdjustment), 0);
                        if (__ownsNativeInstance)
                            Marshal.FreeHGlobal(__Instance);
                        __Instance = IntPtr.Zero;
                    }

                    public string Name
                    {
                        get
                        {
                            var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(((global::CppSharp.Parser.AST.HTMLStartTagComment.Attribute.__Internal*) __Instance)->name);
                            var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                            __basicStringRet.Dispose(false);
                            return __stringRet;
                        }

                        set
                        {
                            var __allocator0 = new global::Std.Allocator<sbyte>();
                            var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                            ((global::CppSharp.Parser.AST.HTMLStartTagComment.Attribute.__Internal*) __Instance)->name = *(global::Std.BasicString.__Internal*) __basicString0.__Instance;
                        }
                    }

                    public string Value
                    {
                        get
                        {
                            var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(((global::CppSharp.Parser.AST.HTMLStartTagComment.Attribute.__Internal*) __Instance)->value);
                            var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                            __basicStringRet.Dispose(false);
                            return __stringRet;
                        }

                        set
                        {
                            var __allocator0 = new global::Std.Allocator<sbyte>();
                            var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                            ((global::CppSharp.Parser.AST.HTMLStartTagComment.Attribute.__Internal*) __Instance)->value = *(global::Std.BasicString.__Internal*) __basicString0.__Instance;
                        }
                    }
                }

                internal static new global::CppSharp.Parser.AST.HTMLStartTagComment __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.HTMLStartTagComment(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.HTMLStartTagComment __CreateInstance(global::CppSharp.Parser.AST.HTMLStartTagComment.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.HTMLStartTagComment(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.HTMLStartTagComment.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.HTMLStartTagComment.__Internal));
                    global::CppSharp.Parser.AST.HTMLStartTagComment.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private HTMLStartTagComment(global::CppSharp.Parser.AST.HTMLStartTagComment.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected HTMLStartTagComment(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public HTMLStartTagComment()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.HTMLStartTagComment.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment));
                }

                public HTMLStartTagComment(global::CppSharp.Parser.AST.HTMLStartTagComment _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.HTMLStartTagComment.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Comment __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.HTMLStartTagComment.Attribute GetAttributes(uint i)
                {
                    var __ret = new global::CppSharp.Parser.AST.HTMLStartTagComment.Attribute.__Internal();
                    __Internal.GetAttributes((__Instance + __PointerAdjustment), new IntPtr(&__ret), i);
                    return global::CppSharp.Parser.AST.HTMLStartTagComment.Attribute.__CreateInstance(__ret);
                }

                public void AddAttributes(global::CppSharp.Parser.AST.HTMLStartTagComment.Attribute s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    __Internal.AddAttributes((__Instance + __PointerAdjustment), __arg0);
                }

                public void ClearAttributes()
                {
                    __Internal.ClearAttributes((__Instance + __PointerAdjustment));
                }

                public string TagName
                {
                    get
                    {
                        var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(((global::CppSharp.Parser.AST.HTMLStartTagComment.__Internal*) __Instance)->tagName);
                        var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                        __basicStringRet.Dispose(false);
                        return __stringRet;
                    }

                    set
                    {
                        var __allocator0 = new global::Std.Allocator<sbyte>();
                        var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                        ((global::CppSharp.Parser.AST.HTMLStartTagComment.__Internal*) __Instance)->tagName = *(global::Std.BasicString.__Internal*) __basicString0.__Instance;
                    }
                }

                public uint AttributesCount
                {
                    get
                    {
                        var __ret = __Internal.GetAttributesCount((__Instance + __PointerAdjustment));
                        return __ret;
                    }
                }
            }

            public unsafe partial class HTMLEndTagComment : global::CppSharp.Parser.AST.HTMLTagComment, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 40)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.CommentKind kind;

                    [FieldOffset(4)]
                    internal byte hasTrailingNewline;

                    [FieldOffset(8)]
                    internal global::Std.BasicString.__Internal tagName;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0HTMLEndTagComment@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0HTMLEndTagComment@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1HTMLEndTagComment@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor(global::System.IntPtr instance, int delete);
                }

                internal static new global::CppSharp.Parser.AST.HTMLEndTagComment __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.HTMLEndTagComment(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.HTMLEndTagComment __CreateInstance(global::CppSharp.Parser.AST.HTMLEndTagComment.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.HTMLEndTagComment(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.HTMLEndTagComment.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.HTMLEndTagComment.__Internal));
                    global::CppSharp.Parser.AST.HTMLEndTagComment.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private HTMLEndTagComment(global::CppSharp.Parser.AST.HTMLEndTagComment.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected HTMLEndTagComment(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public HTMLEndTagComment()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.HTMLEndTagComment.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment));
                }

                public HTMLEndTagComment(global::CppSharp.Parser.AST.HTMLEndTagComment _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.HTMLEndTagComment.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Comment __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public string TagName
                {
                    get
                    {
                        var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(((global::CppSharp.Parser.AST.HTMLEndTagComment.__Internal*) __Instance)->tagName);
                        var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                        __basicStringRet.Dispose(false);
                        return __stringRet;
                    }

                    set
                    {
                        var __allocator0 = new global::Std.Allocator<sbyte>();
                        var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                        ((global::CppSharp.Parser.AST.HTMLEndTagComment.__Internal*) __Instance)->tagName = *(global::Std.BasicString.__Internal*) __basicString0.__Instance;
                    }
                }
            }

            public unsafe partial class TextComment : global::CppSharp.Parser.AST.InlineContentComment, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 40)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.CommentKind kind;

                    [FieldOffset(4)]
                    internal byte hasTrailingNewline;

                    [FieldOffset(8)]
                    internal global::Std.BasicString.__Internal text;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0TextComment@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0TextComment@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1TextComment@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor(global::System.IntPtr instance, int delete);
                }

                internal static new global::CppSharp.Parser.AST.TextComment __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.TextComment(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.TextComment __CreateInstance(global::CppSharp.Parser.AST.TextComment.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.TextComment(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.TextComment.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TextComment.__Internal));
                    global::CppSharp.Parser.AST.TextComment.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private TextComment(global::CppSharp.Parser.AST.TextComment.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected TextComment(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    __PointerAdjustment = 0;
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public TextComment()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TextComment.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment));
                }

                public TextComment(global::CppSharp.Parser.AST.TextComment _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TextComment.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Comment __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public string Text
                {
                    get
                    {
                        var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(((global::CppSharp.Parser.AST.TextComment.__Internal*) __Instance)->text);
                        var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                        __basicStringRet.Dispose(false);
                        return __stringRet;
                    }

                    set
                    {
                        var __allocator0 = new global::Std.Allocator<sbyte>();
                        var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                        ((global::CppSharp.Parser.AST.TextComment.__Internal*) __Instance)->text = *(global::Std.BasicString.__Internal*) __basicString0.__Instance;
                    }
                }
            }

            public unsafe partial class RawComment : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 80)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.RawCommentKind kind;

                    [FieldOffset(8)]
                    internal global::Std.BasicString.__Internal text;

                    [FieldOffset(40)]
                    internal global::Std.BasicString.__Internal briefText;

                    [FieldOffset(72)]
                    internal global::System.IntPtr fullCommentBlock;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0RawComment@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??0RawComment@AST@CppParser@CppSharp@@QEAA@AEBV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="??1RawComment@AST@CppParser@CppSharp@@QEAA@XZ")]
                    internal static extern void dtor(global::System.IntPtr instance, int delete);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                protected int __PointerAdjustment;
                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.RawComment> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.RawComment>();
                protected void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                internal static global::CppSharp.Parser.AST.RawComment __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.RawComment(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.RawComment __CreateInstance(global::CppSharp.Parser.AST.RawComment.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.RawComment(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.RawComment.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.RawComment.__Internal));
                    global::CppSharp.Parser.AST.RawComment.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private RawComment(global::CppSharp.Parser.AST.RawComment.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected RawComment(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public RawComment()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.RawComment.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor((__Instance + __PointerAdjustment));
                }

                public RawComment(global::CppSharp.Parser.AST.RawComment _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.RawComment.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                public virtual void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.RawComment __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor((__Instance + __PointerAdjustment), 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.RawCommentKind Kind
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.RawComment.__Internal*) __Instance)->kind;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.RawComment.__Internal*) __Instance)->kind = value;
                    }
                }

                public string Text
                {
                    get
                    {
                        var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(((global::CppSharp.Parser.AST.RawComment.__Internal*) __Instance)->text);
                        var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                        __basicStringRet.Dispose(false);
                        return __stringRet;
                    }

                    set
                    {
                        var __allocator0 = new global::Std.Allocator<sbyte>();
                        var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                        ((global::CppSharp.Parser.AST.RawComment.__Internal*) __Instance)->text = *(global::Std.BasicString.__Internal*) __basicString0.__Instance;
                    }
                }

                public string BriefText
                {
                    get
                    {
                        var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(((global::CppSharp.Parser.AST.RawComment.__Internal*) __Instance)->briefText);
                        var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                        __basicStringRet.Dispose(false);
                        return __stringRet;
                    }

                    set
                    {
                        var __allocator0 = new global::Std.Allocator<sbyte>();
                        var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                        ((global::CppSharp.Parser.AST.RawComment.__Internal*) __Instance)->briefText = *(global::Std.BasicString.__Internal*) __basicString0.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.FullComment FullCommentBlock
                {
                    get
                    {
                        global::CppSharp.Parser.AST.FullComment __result0;
                        if (((global::CppSharp.Parser.AST.RawComment.__Internal*) __Instance)->fullCommentBlock == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.FullComment.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.RawComment.__Internal*) __Instance)->fullCommentBlock))
                            __result0 = (global::CppSharp.Parser.AST.FullComment) global::CppSharp.Parser.AST.FullComment.NativeToManagedMap[((global::CppSharp.Parser.AST.RawComment.__Internal*) __Instance)->fullCommentBlock];
                        else __result0 = global::CppSharp.Parser.AST.FullComment.__CreateInstance(((global::CppSharp.Parser.AST.RawComment.__Internal*) __Instance)->fullCommentBlock);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.RawComment.__Internal*) __Instance)->fullCommentBlock = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }
            }
        }
    }
}

namespace CppSharp
{
    namespace Parser
    {
        public unsafe partial struct SourceLocation
        {
            [StructLayout(LayoutKind.Explicit, Size = 4)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal uint ID;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0SourceLocation@CppParser@CppSharp@@QEAA@XZ")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0SourceLocation@CppParser@CppSharp@@QEAA@I@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance, uint ID);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0SourceLocation@CppParser@CppSharp@@QEAA@AEBU012@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);
            }

            private SourceLocation.__Internal __instance;
            internal SourceLocation.__Internal __Instance { get { return __instance; } }

            internal static global::CppSharp.Parser.SourceLocation __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::CppSharp.Parser.SourceLocation(native.ToPointer(), skipVTables);
            }

            internal static global::CppSharp.Parser.SourceLocation __CreateInstance(global::CppSharp.Parser.SourceLocation.__Internal native, bool skipVTables = false)
            {
                return new global::CppSharp.Parser.SourceLocation(native, skipVTables);
            }

            private SourceLocation(global::CppSharp.Parser.SourceLocation.__Internal native, bool skipVTables = false)
                : this()
            {
                __instance = native;
            }

            private SourceLocation(void* native, bool skipVTables = false) : this()
            {
                __instance = *(global::CppSharp.Parser.SourceLocation.__Internal*) native;
            }

            public SourceLocation(uint ID)
                : this()
            {
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.ctor(new global::System.IntPtr(__instancePtr), ID);
                }
            }

            public SourceLocation(global::CppSharp.Parser.SourceLocation _0)
                : this()
            {
                var ____arg0 = _0.__Instance;
                var __arg0 = new global::System.IntPtr(&____arg0);
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.cctor(new global::System.IntPtr(__instancePtr), __arg0);
                }
            }

            public static implicit operator global::CppSharp.Parser.SourceLocation(uint ID)
            {
                return new global::CppSharp.Parser.SourceLocation(ID);
            }

            public uint ID
            {
                get
                {
                    return __instance.ID;
                }

                set
                {
                    __instance.ID = value;
                }
            }
        }
    }
}

namespace CppSharp
{
    namespace Parser
    {
        public enum ParserIntType
        {
            NoInt = 0,
            SignedChar = 1,
            UnsignedChar = 2,
            SignedShort = 3,
            UnsignedShort = 4,
            SignedInt = 5,
            UnsignedInt = 6,
            SignedLong = 7,
            UnsignedLong = 8,
            SignedLongLong = 9,
            UnsignedLongLong = 10
        }

        public unsafe partial class ParserTargetInfo : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 192)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::Std.BasicString.__Internal ABI;

                [FieldOffset(32)]
                internal global::CppSharp.Parser.ParserIntType char16Type;

                [FieldOffset(36)]
                internal global::CppSharp.Parser.ParserIntType char32Type;

                [FieldOffset(40)]
                internal global::CppSharp.Parser.ParserIntType int64Type;

                [FieldOffset(44)]
                internal global::CppSharp.Parser.ParserIntType intMaxType;

                [FieldOffset(48)]
                internal global::CppSharp.Parser.ParserIntType intPtrType;

                [FieldOffset(52)]
                internal global::CppSharp.Parser.ParserIntType sizeType;

                [FieldOffset(56)]
                internal global::CppSharp.Parser.ParserIntType uIntMaxType;

                [FieldOffset(60)]
                internal global::CppSharp.Parser.ParserIntType wCharType;

                [FieldOffset(64)]
                internal global::CppSharp.Parser.ParserIntType wIntType;

                [FieldOffset(68)]
                internal uint boolAlign;

                [FieldOffset(72)]
                internal uint boolWidth;

                [FieldOffset(76)]
                internal uint charAlign;

                [FieldOffset(80)]
                internal uint charWidth;

                [FieldOffset(84)]
                internal uint char16Align;

                [FieldOffset(88)]
                internal uint char16Width;

                [FieldOffset(92)]
                internal uint char32Align;

                [FieldOffset(96)]
                internal uint char32Width;

                [FieldOffset(100)]
                internal uint halfAlign;

                [FieldOffset(104)]
                internal uint halfWidth;

                [FieldOffset(108)]
                internal uint floatAlign;

                [FieldOffset(112)]
                internal uint floatWidth;

                [FieldOffset(116)]
                internal uint doubleAlign;

                [FieldOffset(120)]
                internal uint doubleWidth;

                [FieldOffset(124)]
                internal uint shortAlign;

                [FieldOffset(128)]
                internal uint shortWidth;

                [FieldOffset(132)]
                internal uint intAlign;

                [FieldOffset(136)]
                internal uint intWidth;

                [FieldOffset(140)]
                internal uint intMaxTWidth;

                [FieldOffset(144)]
                internal uint longAlign;

                [FieldOffset(148)]
                internal uint longWidth;

                [FieldOffset(152)]
                internal uint longDoubleAlign;

                [FieldOffset(156)]
                internal uint longDoubleWidth;

                [FieldOffset(160)]
                internal uint longLongAlign;

                [FieldOffset(164)]
                internal uint longLongWidth;

                [FieldOffset(168)]
                internal uint pointerAlign;

                [FieldOffset(172)]
                internal uint pointerWidth;

                [FieldOffset(176)]
                internal uint wCharAlign;

                [FieldOffset(180)]
                internal uint wCharWidth;

                [FieldOffset(184)]
                internal uint float128Align;

                [FieldOffset(188)]
                internal uint float128Width;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0ParserTargetInfo@CppParser@CppSharp@@QEAA@XZ")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0ParserTargetInfo@CppParser@CppSharp@@QEAA@AEBU012@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??1ParserTargetInfo@CppParser@CppSharp@@QEAA@XZ")]
                internal static extern void dtor(global::System.IntPtr instance, int delete);
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.ParserTargetInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.ParserTargetInfo>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::CppSharp.Parser.ParserTargetInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::CppSharp.Parser.ParserTargetInfo(native.ToPointer(), skipVTables);
            }

            internal static global::CppSharp.Parser.ParserTargetInfo __CreateInstance(global::CppSharp.Parser.ParserTargetInfo.__Internal native, bool skipVTables = false)
            {
                return new global::CppSharp.Parser.ParserTargetInfo(native, skipVTables);
            }

            private static void* __CopyValue(global::CppSharp.Parser.ParserTargetInfo.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.ParserTargetInfo.__Internal));
                global::CppSharp.Parser.ParserTargetInfo.__Internal.cctor(ret, new global::System.IntPtr(&native));
                return ret.ToPointer();
            }

            private ParserTargetInfo(global::CppSharp.Parser.ParserTargetInfo.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected ParserTargetInfo(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public ParserTargetInfo()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.ParserTargetInfo.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor((__Instance + __PointerAdjustment));
            }

            public ParserTargetInfo(global::CppSharp.Parser.ParserTargetInfo _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.ParserTargetInfo.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::CppSharp.Parser.ParserTargetInfo __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (disposing)
                    __Internal.dtor((__Instance + __PointerAdjustment), 0);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public string ABI
            {
                get
                {
                    var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->ABI);
                    var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                    __basicStringRet.Dispose(false);
                    return __stringRet;
                }

                set
                {
                    var __allocator0 = new global::Std.Allocator<sbyte>();
                    var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                    ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->ABI = *(global::Std.BasicString.__Internal*) __basicString0.__Instance;
                }
            }

            public global::CppSharp.Parser.ParserIntType Char16Type
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->char16Type;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->char16Type = value;
                }
            }

            public global::CppSharp.Parser.ParserIntType Char32Type
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->char32Type;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->char32Type = value;
                }
            }

            public global::CppSharp.Parser.ParserIntType Int64Type
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->int64Type;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->int64Type = value;
                }
            }

            public global::CppSharp.Parser.ParserIntType IntMaxType
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->intMaxType;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->intMaxType = value;
                }
            }

            public global::CppSharp.Parser.ParserIntType IntPtrType
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->intPtrType;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->intPtrType = value;
                }
            }

            public global::CppSharp.Parser.ParserIntType SizeType
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->sizeType;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->sizeType = value;
                }
            }

            public global::CppSharp.Parser.ParserIntType UIntMaxType
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->uIntMaxType;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->uIntMaxType = value;
                }
            }

            public global::CppSharp.Parser.ParserIntType WCharType
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->wCharType;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->wCharType = value;
                }
            }

            public global::CppSharp.Parser.ParserIntType WIntType
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->wIntType;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->wIntType = value;
                }
            }

            public uint BoolAlign
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->boolAlign;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->boolAlign = value;
                }
            }

            public uint BoolWidth
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->boolWidth;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->boolWidth = value;
                }
            }

            public uint CharAlign
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->charAlign;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->charAlign = value;
                }
            }

            public uint CharWidth
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->charWidth;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->charWidth = value;
                }
            }

            public uint Char16Align
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->char16Align;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->char16Align = value;
                }
            }

            public uint Char16Width
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->char16Width;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->char16Width = value;
                }
            }

            public uint Char32Align
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->char32Align;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->char32Align = value;
                }
            }

            public uint Char32Width
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->char32Width;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->char32Width = value;
                }
            }

            public uint HalfAlign
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->halfAlign;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->halfAlign = value;
                }
            }

            public uint HalfWidth
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->halfWidth;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->halfWidth = value;
                }
            }

            public uint FloatAlign
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->floatAlign;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->floatAlign = value;
                }
            }

            public uint FloatWidth
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->floatWidth;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->floatWidth = value;
                }
            }

            public uint DoubleAlign
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->doubleAlign;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->doubleAlign = value;
                }
            }

            public uint DoubleWidth
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->doubleWidth;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->doubleWidth = value;
                }
            }

            public uint ShortAlign
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->shortAlign;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->shortAlign = value;
                }
            }

            public uint ShortWidth
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->shortWidth;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->shortWidth = value;
                }
            }

            public uint IntAlign
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->intAlign;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->intAlign = value;
                }
            }

            public uint IntWidth
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->intWidth;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->intWidth = value;
                }
            }

            public uint IntMaxTWidth
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->intMaxTWidth;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->intMaxTWidth = value;
                }
            }

            public uint LongAlign
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->longAlign;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->longAlign = value;
                }
            }

            public uint LongWidth
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->longWidth;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->longWidth = value;
                }
            }

            public uint LongDoubleAlign
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->longDoubleAlign;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->longDoubleAlign = value;
                }
            }

            public uint LongDoubleWidth
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->longDoubleWidth;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->longDoubleWidth = value;
                }
            }

            public uint LongLongAlign
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->longLongAlign;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->longLongAlign = value;
                }
            }

            public uint LongLongWidth
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->longLongWidth;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->longLongWidth = value;
                }
            }

            public uint PointerAlign
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->pointerAlign;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->pointerAlign = value;
                }
            }

            public uint PointerWidth
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->pointerWidth;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->pointerWidth = value;
                }
            }

            public uint WCharAlign
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->wCharAlign;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->wCharAlign = value;
                }
            }

            public uint WCharWidth
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->wCharWidth;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->wCharWidth = value;
                }
            }

            public uint Float128Align
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->float128Align;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->float128Align = value;
                }
            }

            public uint Float128Width
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->float128Width;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->float128Width = value;
                }
            }
        }
    }
}

namespace CppSharp
{
    namespace Parser
    {
        public enum ParserDiagnosticLevel
        {
            Ignored = 0,
            Note = 1,
            Warning = 2,
            Error = 3,
            Fatal = 4
        }

        public enum ParserResultKind
        {
            Success = 0,
            Error = 1,
            FileNotFound = 2
        }

        public enum SourceLocationKind
        {
            Invalid = 0,
            Builtin = 1,
            CommandLine = 2,
            System = 3,
            User = 4
        }

        public unsafe partial class Parser
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct __Internal
            {
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.Parser> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.Parser>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::CppSharp.Parser.Parser __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::CppSharp.Parser.Parser(native.ToPointer(), skipVTables);
            }

            internal static global::CppSharp.Parser.Parser __CreateInstance(global::CppSharp.Parser.Parser.__Internal native, bool skipVTables = false)
            {
                return new global::CppSharp.Parser.Parser(native, skipVTables);
            }

            private static void* __CopyValue(global::CppSharp.Parser.Parser.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.Parser.__Internal));
                *(global::CppSharp.Parser.Parser.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private Parser(global::CppSharp.Parser.Parser.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected Parser(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }
        }

        public unsafe partial class CppParserOptions : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 296)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::Std.Vector.__Internal Arguments;

                [FieldOffset(24)]
                internal global::Std.BasicString.__Internal libraryFile;

                [FieldOffset(56)]
                internal global::Std.Vector.__Internal SourceFiles;

                [FieldOffset(80)]
                internal global::Std.Vector.__Internal IncludeDirs;

                [FieldOffset(104)]
                internal global::Std.Vector.__Internal SystemIncludeDirs;

                [FieldOffset(128)]
                internal global::Std.Vector.__Internal Defines;

                [FieldOffset(152)]
                internal global::Std.Vector.__Internal Undefines;

                [FieldOffset(176)]
                internal global::Std.Vector.__Internal LibraryDirs;

                [FieldOffset(200)]
                internal global::System.IntPtr ASTContext;

                [FieldOffset(208)]
                internal int toolSetToUse;

                [FieldOffset(216)]
                internal global::Std.BasicString.__Internal targetTriple;

                [FieldOffset(248)]
                internal global::Std.BasicString.__Internal currentDir;

                [FieldOffset(280)]
                internal global::CppSharp.Parser.AST.CppAbi abi;

                [FieldOffset(284)]
                internal byte noStandardIncludes;

                [FieldOffset(285)]
                internal byte noBuiltinIncludes;

                [FieldOffset(286)]
                internal byte microsoftMode;

                [FieldOffset(287)]
                internal byte verbose;

                [FieldOffset(288)]
                internal global::System.IntPtr targetInfo;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0CppParserOptions@CppParser@CppSharp@@QEAA@XZ")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0CppParserOptions@CppParser@CppSharp@@QEAA@AEBU012@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??1CppParserOptions@CppParser@CppSharp@@QEAA@XZ")]
                internal static extern void dtor(global::System.IntPtr instance, int delete);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getArguments@CppParserOptions@CppParser@CppSharp@@QEAAPEBDI@Z")]
                internal static extern global::System.IntPtr GetArguments(global::System.IntPtr instance, uint i);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?addArguments@CppParserOptions@CppParser@CppSharp@@QEAAXPEBD@Z")]
                internal static extern void AddArguments(global::System.IntPtr instance, [MarshalAs(UnmanagedType.LPStr)] string s);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?clearArguments@CppParserOptions@CppParser@CppSharp@@QEAAXXZ")]
                internal static extern void ClearArguments(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getSourceFiles@CppParserOptions@CppParser@CppSharp@@QEAAPEBDI@Z")]
                internal static extern global::System.IntPtr GetSourceFiles(global::System.IntPtr instance, uint i);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?addSourceFiles@CppParserOptions@CppParser@CppSharp@@QEAAXPEBD@Z")]
                internal static extern void AddSourceFiles(global::System.IntPtr instance, [MarshalAs(UnmanagedType.LPStr)] string s);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?clearSourceFiles@CppParserOptions@CppParser@CppSharp@@QEAAXXZ")]
                internal static extern void ClearSourceFiles(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getIncludeDirs@CppParserOptions@CppParser@CppSharp@@QEAAPEBDI@Z")]
                internal static extern global::System.IntPtr GetIncludeDirs(global::System.IntPtr instance, uint i);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?addIncludeDirs@CppParserOptions@CppParser@CppSharp@@QEAAXPEBD@Z")]
                internal static extern void AddIncludeDirs(global::System.IntPtr instance, [MarshalAs(UnmanagedType.LPStr)] string s);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?clearIncludeDirs@CppParserOptions@CppParser@CppSharp@@QEAAXXZ")]
                internal static extern void ClearIncludeDirs(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getSystemIncludeDirs@CppParserOptions@CppParser@CppSharp@@QEAAPEBDI@Z")]
                internal static extern global::System.IntPtr GetSystemIncludeDirs(global::System.IntPtr instance, uint i);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?addSystemIncludeDirs@CppParserOptions@CppParser@CppSharp@@QEAAXPEBD@Z")]
                internal static extern void AddSystemIncludeDirs(global::System.IntPtr instance, [MarshalAs(UnmanagedType.LPStr)] string s);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?clearSystemIncludeDirs@CppParserOptions@CppParser@CppSharp@@QEAAXXZ")]
                internal static extern void ClearSystemIncludeDirs(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getDefines@CppParserOptions@CppParser@CppSharp@@QEAAPEBDI@Z")]
                internal static extern global::System.IntPtr GetDefines(global::System.IntPtr instance, uint i);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?addDefines@CppParserOptions@CppParser@CppSharp@@QEAAXPEBD@Z")]
                internal static extern void AddDefines(global::System.IntPtr instance, [MarshalAs(UnmanagedType.LPStr)] string s);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?clearDefines@CppParserOptions@CppParser@CppSharp@@QEAAXXZ")]
                internal static extern void ClearDefines(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getUndefines@CppParserOptions@CppParser@CppSharp@@QEAAPEBDI@Z")]
                internal static extern global::System.IntPtr GetUndefines(global::System.IntPtr instance, uint i);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?addUndefines@CppParserOptions@CppParser@CppSharp@@QEAAXPEBD@Z")]
                internal static extern void AddUndefines(global::System.IntPtr instance, [MarshalAs(UnmanagedType.LPStr)] string s);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?clearUndefines@CppParserOptions@CppParser@CppSharp@@QEAAXXZ")]
                internal static extern void ClearUndefines(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getLibraryDirs@CppParserOptions@CppParser@CppSharp@@QEAAPEBDI@Z")]
                internal static extern global::System.IntPtr GetLibraryDirs(global::System.IntPtr instance, uint i);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?addLibraryDirs@CppParserOptions@CppParser@CppSharp@@QEAAXPEBD@Z")]
                internal static extern void AddLibraryDirs(global::System.IntPtr instance, [MarshalAs(UnmanagedType.LPStr)] string s);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?clearLibraryDirs@CppParserOptions@CppParser@CppSharp@@QEAAXXZ")]
                internal static extern void ClearLibraryDirs(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getArgumentsCount@CppParserOptions@CppParser@CppSharp@@QEAAIXZ")]
                internal static extern uint GetArgumentsCount(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getSourceFilesCount@CppParserOptions@CppParser@CppSharp@@QEAAIXZ")]
                internal static extern uint GetSourceFilesCount(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getIncludeDirsCount@CppParserOptions@CppParser@CppSharp@@QEAAIXZ")]
                internal static extern uint GetIncludeDirsCount(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getSystemIncludeDirsCount@CppParserOptions@CppParser@CppSharp@@QEAAIXZ")]
                internal static extern uint GetSystemIncludeDirsCount(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getDefinesCount@CppParserOptions@CppParser@CppSharp@@QEAAIXZ")]
                internal static extern uint GetDefinesCount(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getUndefinesCount@CppParserOptions@CppParser@CppSharp@@QEAAIXZ")]
                internal static extern uint GetUndefinesCount(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getLibraryDirsCount@CppParserOptions@CppParser@CppSharp@@QEAAIXZ")]
                internal static extern uint GetLibraryDirsCount(global::System.IntPtr instance);
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.CppParserOptions> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.CppParserOptions>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::CppSharp.Parser.CppParserOptions __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::CppSharp.Parser.CppParserOptions(native.ToPointer(), skipVTables);
            }

            internal static global::CppSharp.Parser.CppParserOptions __CreateInstance(global::CppSharp.Parser.CppParserOptions.__Internal native, bool skipVTables = false)
            {
                return new global::CppSharp.Parser.CppParserOptions(native, skipVTables);
            }

            private static void* __CopyValue(global::CppSharp.Parser.CppParserOptions.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.CppParserOptions.__Internal));
                global::CppSharp.Parser.CppParserOptions.__Internal.cctor(ret, new global::System.IntPtr(&native));
                return ret.ToPointer();
            }

            private CppParserOptions(global::CppSharp.Parser.CppParserOptions.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected CppParserOptions(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public CppParserOptions()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.CppParserOptions.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor((__Instance + __PointerAdjustment));
            }

            public CppParserOptions(global::CppSharp.Parser.CppParserOptions _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.CppParserOptions.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::CppSharp.Parser.CppParserOptions __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (disposing)
                    __Internal.dtor((__Instance + __PointerAdjustment), 0);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public string GetArguments(uint i)
            {
                var __ret = __Internal.GetArguments((__Instance + __PointerAdjustment), i);
                return Marshal.PtrToStringAnsi(__ret);
            }

            public void AddArguments(string s)
            {
                __Internal.AddArguments((__Instance + __PointerAdjustment), s);
            }

            public void ClearArguments()
            {
                __Internal.ClearArguments((__Instance + __PointerAdjustment));
            }

            public string GetSourceFiles(uint i)
            {
                var __ret = __Internal.GetSourceFiles((__Instance + __PointerAdjustment), i);
                return Marshal.PtrToStringAnsi(__ret);
            }

            public void AddSourceFiles(string s)
            {
                __Internal.AddSourceFiles((__Instance + __PointerAdjustment), s);
            }

            public void ClearSourceFiles()
            {
                __Internal.ClearSourceFiles((__Instance + __PointerAdjustment));
            }

            public string GetIncludeDirs(uint i)
            {
                var __ret = __Internal.GetIncludeDirs((__Instance + __PointerAdjustment), i);
                return Marshal.PtrToStringAnsi(__ret);
            }

            public void AddIncludeDirs(string s)
            {
                __Internal.AddIncludeDirs((__Instance + __PointerAdjustment), s);
            }

            public void ClearIncludeDirs()
            {
                __Internal.ClearIncludeDirs((__Instance + __PointerAdjustment));
            }

            public string GetSystemIncludeDirs(uint i)
            {
                var __ret = __Internal.GetSystemIncludeDirs((__Instance + __PointerAdjustment), i);
                return Marshal.PtrToStringAnsi(__ret);
            }

            public void AddSystemIncludeDirs(string s)
            {
                __Internal.AddSystemIncludeDirs((__Instance + __PointerAdjustment), s);
            }

            public void ClearSystemIncludeDirs()
            {
                __Internal.ClearSystemIncludeDirs((__Instance + __PointerAdjustment));
            }

            public string GetDefines(uint i)
            {
                var __ret = __Internal.GetDefines((__Instance + __PointerAdjustment), i);
                return Marshal.PtrToStringAnsi(__ret);
            }

            public void AddDefines(string s)
            {
                __Internal.AddDefines((__Instance + __PointerAdjustment), s);
            }

            public void ClearDefines()
            {
                __Internal.ClearDefines((__Instance + __PointerAdjustment));
            }

            public string GetUndefines(uint i)
            {
                var __ret = __Internal.GetUndefines((__Instance + __PointerAdjustment), i);
                return Marshal.PtrToStringAnsi(__ret);
            }

            public void AddUndefines(string s)
            {
                __Internal.AddUndefines((__Instance + __PointerAdjustment), s);
            }

            public void ClearUndefines()
            {
                __Internal.ClearUndefines((__Instance + __PointerAdjustment));
            }

            public string GetLibraryDirs(uint i)
            {
                var __ret = __Internal.GetLibraryDirs((__Instance + __PointerAdjustment), i);
                return Marshal.PtrToStringAnsi(__ret);
            }

            public void AddLibraryDirs(string s)
            {
                __Internal.AddLibraryDirs((__Instance + __PointerAdjustment), s);
            }

            public void ClearLibraryDirs()
            {
                __Internal.ClearLibraryDirs((__Instance + __PointerAdjustment));
            }

            public string LibraryFile
            {
                get
                {
                    var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(((global::CppSharp.Parser.CppParserOptions.__Internal*) __Instance)->libraryFile);
                    var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                    __basicStringRet.Dispose(false);
                    return __stringRet;
                }

                set
                {
                    var __allocator0 = new global::Std.Allocator<sbyte>();
                    var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                    ((global::CppSharp.Parser.CppParserOptions.__Internal*) __Instance)->libraryFile = *(global::Std.BasicString.__Internal*) __basicString0.__Instance;
                }
            }

            public global::CppSharp.Parser.AST.ASTContext ASTContext
            {
                get
                {
                    global::CppSharp.Parser.AST.ASTContext __result0;
                    if (((global::CppSharp.Parser.CppParserOptions.__Internal*) __Instance)->ASTContext == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.ASTContext.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.CppParserOptions.__Internal*) __Instance)->ASTContext))
                        __result0 = (global::CppSharp.Parser.AST.ASTContext) global::CppSharp.Parser.AST.ASTContext.NativeToManagedMap[((global::CppSharp.Parser.CppParserOptions.__Internal*) __Instance)->ASTContext];
                    else __result0 = global::CppSharp.Parser.AST.ASTContext.__CreateInstance(((global::CppSharp.Parser.CppParserOptions.__Internal*) __Instance)->ASTContext);
                    return __result0;
                }

                set
                {
                    ((global::CppSharp.Parser.CppParserOptions.__Internal*) __Instance)->ASTContext = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                }
            }

            public int ToolSetToUse
            {
                get
                {
                    return ((global::CppSharp.Parser.CppParserOptions.__Internal*) __Instance)->toolSetToUse;
                }

                set
                {
                    ((global::CppSharp.Parser.CppParserOptions.__Internal*) __Instance)->toolSetToUse = value;
                }
            }

            public string TargetTriple
            {
                get
                {
                    var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(((global::CppSharp.Parser.CppParserOptions.__Internal*) __Instance)->targetTriple);
                    var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                    __basicStringRet.Dispose(false);
                    return __stringRet;
                }

                set
                {
                    var __allocator0 = new global::Std.Allocator<sbyte>();
                    var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                    ((global::CppSharp.Parser.CppParserOptions.__Internal*) __Instance)->targetTriple = *(global::Std.BasicString.__Internal*) __basicString0.__Instance;
                }
            }

            public string CurrentDir
            {
                get
                {
                    var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(((global::CppSharp.Parser.CppParserOptions.__Internal*) __Instance)->currentDir);
                    var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                    __basicStringRet.Dispose(false);
                    return __stringRet;
                }

                set
                {
                    var __allocator0 = new global::Std.Allocator<sbyte>();
                    var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                    ((global::CppSharp.Parser.CppParserOptions.__Internal*) __Instance)->currentDir = *(global::Std.BasicString.__Internal*) __basicString0.__Instance;
                }
            }

            public global::CppSharp.Parser.AST.CppAbi Abi
            {
                get
                {
                    return ((global::CppSharp.Parser.CppParserOptions.__Internal*) __Instance)->abi;
                }

                set
                {
                    ((global::CppSharp.Parser.CppParserOptions.__Internal*) __Instance)->abi = value;
                }
            }

            public bool NoStandardIncludes
            {
                get
                {
                    return ((global::CppSharp.Parser.CppParserOptions.__Internal*) __Instance)->noStandardIncludes != 0;
                }

                set
                {
                    ((global::CppSharp.Parser.CppParserOptions.__Internal*) __Instance)->noStandardIncludes = (byte) (value ? 1 : 0);
                }
            }

            public bool NoBuiltinIncludes
            {
                get
                {
                    return ((global::CppSharp.Parser.CppParserOptions.__Internal*) __Instance)->noBuiltinIncludes != 0;
                }

                set
                {
                    ((global::CppSharp.Parser.CppParserOptions.__Internal*) __Instance)->noBuiltinIncludes = (byte) (value ? 1 : 0);
                }
            }

            public bool MicrosoftMode
            {
                get
                {
                    return ((global::CppSharp.Parser.CppParserOptions.__Internal*) __Instance)->microsoftMode != 0;
                }

                set
                {
                    ((global::CppSharp.Parser.CppParserOptions.__Internal*) __Instance)->microsoftMode = (byte) (value ? 1 : 0);
                }
            }

            public bool Verbose
            {
                get
                {
                    return ((global::CppSharp.Parser.CppParserOptions.__Internal*) __Instance)->verbose != 0;
                }

                set
                {
                    ((global::CppSharp.Parser.CppParserOptions.__Internal*) __Instance)->verbose = (byte) (value ? 1 : 0);
                }
            }

            public global::CppSharp.Parser.ParserTargetInfo TargetInfo
            {
                get
                {
                    global::CppSharp.Parser.ParserTargetInfo __result0;
                    if (((global::CppSharp.Parser.CppParserOptions.__Internal*) __Instance)->targetInfo == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.ParserTargetInfo.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.CppParserOptions.__Internal*) __Instance)->targetInfo))
                        __result0 = (global::CppSharp.Parser.ParserTargetInfo) global::CppSharp.Parser.ParserTargetInfo.NativeToManagedMap[((global::CppSharp.Parser.CppParserOptions.__Internal*) __Instance)->targetInfo];
                    else __result0 = global::CppSharp.Parser.ParserTargetInfo.__CreateInstance(((global::CppSharp.Parser.CppParserOptions.__Internal*) __Instance)->targetInfo);
                    return __result0;
                }

                set
                {
                    ((global::CppSharp.Parser.CppParserOptions.__Internal*) __Instance)->targetInfo = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                }
            }

            public uint ArgumentsCount
            {
                get
                {
                    var __ret = __Internal.GetArgumentsCount((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            public uint SourceFilesCount
            {
                get
                {
                    var __ret = __Internal.GetSourceFilesCount((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            public uint IncludeDirsCount
            {
                get
                {
                    var __ret = __Internal.GetIncludeDirsCount((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            public uint SystemIncludeDirsCount
            {
                get
                {
                    var __ret = __Internal.GetSystemIncludeDirsCount((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            public uint DefinesCount
            {
                get
                {
                    var __ret = __Internal.GetDefinesCount((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            public uint UndefinesCount
            {
                get
                {
                    var __ret = __Internal.GetUndefinesCount((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }

            public uint LibraryDirsCount
            {
                get
                {
                    var __ret = __Internal.GetLibraryDirsCount((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }
        }

        public unsafe partial class ParserDiagnostic : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 80)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::Std.BasicString.__Internal fileName;

                [FieldOffset(32)]
                internal global::Std.BasicString.__Internal message;

                [FieldOffset(64)]
                internal global::CppSharp.Parser.ParserDiagnosticLevel level;

                [FieldOffset(68)]
                internal int lineNumber;

                [FieldOffset(72)]
                internal int columnNumber;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0ParserDiagnostic@CppParser@CppSharp@@QEAA@XZ")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0ParserDiagnostic@CppParser@CppSharp@@QEAA@AEBU012@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??1ParserDiagnostic@CppParser@CppSharp@@QEAA@XZ")]
                internal static extern void dtor(global::System.IntPtr instance, int delete);
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.ParserDiagnostic> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.ParserDiagnostic>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::CppSharp.Parser.ParserDiagnostic __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::CppSharp.Parser.ParserDiagnostic(native.ToPointer(), skipVTables);
            }

            internal static global::CppSharp.Parser.ParserDiagnostic __CreateInstance(global::CppSharp.Parser.ParserDiagnostic.__Internal native, bool skipVTables = false)
            {
                return new global::CppSharp.Parser.ParserDiagnostic(native, skipVTables);
            }

            private static void* __CopyValue(global::CppSharp.Parser.ParserDiagnostic.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.ParserDiagnostic.__Internal));
                global::CppSharp.Parser.ParserDiagnostic.__Internal.cctor(ret, new global::System.IntPtr(&native));
                return ret.ToPointer();
            }

            private ParserDiagnostic(global::CppSharp.Parser.ParserDiagnostic.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected ParserDiagnostic(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public ParserDiagnostic()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.ParserDiagnostic.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor((__Instance + __PointerAdjustment));
            }

            public ParserDiagnostic(global::CppSharp.Parser.ParserDiagnostic _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.ParserDiagnostic.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::CppSharp.Parser.ParserDiagnostic __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (disposing)
                    __Internal.dtor((__Instance + __PointerAdjustment), 0);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public string FileName
            {
                get
                {
                    var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(((global::CppSharp.Parser.ParserDiagnostic.__Internal*) __Instance)->fileName);
                    var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                    __basicStringRet.Dispose(false);
                    return __stringRet;
                }

                set
                {
                    var __allocator0 = new global::Std.Allocator<sbyte>();
                    var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                    ((global::CppSharp.Parser.ParserDiagnostic.__Internal*) __Instance)->fileName = *(global::Std.BasicString.__Internal*) __basicString0.__Instance;
                }
            }

            public string Message
            {
                get
                {
                    var __basicStringRet = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(((global::CppSharp.Parser.ParserDiagnostic.__Internal*) __Instance)->message);
                    var __stringRet = global::Std.BasicStringExtensions.CStr(__basicStringRet);
                    __basicStringRet.Dispose(false);
                    return __stringRet;
                }

                set
                {
                    var __allocator0 = new global::Std.Allocator<sbyte>();
                    var __basicString0 = global::Std.BasicStringExtensions.BasicString(value, __allocator0);
                    ((global::CppSharp.Parser.ParserDiagnostic.__Internal*) __Instance)->message = *(global::Std.BasicString.__Internal*) __basicString0.__Instance;
                }
            }

            public global::CppSharp.Parser.ParserDiagnosticLevel Level
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserDiagnostic.__Internal*) __Instance)->level;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserDiagnostic.__Internal*) __Instance)->level = value;
                }
            }

            public int LineNumber
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserDiagnostic.__Internal*) __Instance)->lineNumber;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserDiagnostic.__Internal*) __Instance)->lineNumber = value;
                }
            }

            public int ColumnNumber
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserDiagnostic.__Internal*) __Instance)->columnNumber;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserDiagnostic.__Internal*) __Instance)->columnNumber = value;
                }
            }
        }

        public unsafe partial class ParserResult : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 56)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::CppSharp.Parser.ParserResultKind kind;

                [FieldOffset(8)]
                internal global::Std.Vector.__Internal Diagnostics;

                [FieldOffset(32)]
                internal global::System.IntPtr ASTContext;

                [FieldOffset(40)]
                internal global::System.IntPtr library;

                [FieldOffset(48)]
                internal global::System.IntPtr codeParser;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0ParserResult@CppParser@CppSharp@@QEAA@XZ")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0ParserResult@CppParser@CppSharp@@QEAA@AEBU012@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??1ParserResult@CppParser@CppSharp@@QEAA@XZ")]
                internal static extern void dtor(global::System.IntPtr instance, int delete);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getDiagnostics@ParserResult@CppParser@CppSharp@@QEAA?AUParserDiagnostic@23@I@Z")]
                internal static extern void GetDiagnostics(global::System.IntPtr instance, global::System.IntPtr @return, uint i);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?addDiagnostics@ParserResult@CppParser@CppSharp@@QEAAXAEAUParserDiagnostic@23@@Z")]
                internal static extern void AddDiagnostics(global::System.IntPtr instance, global::System.IntPtr s);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?clearDiagnostics@ParserResult@CppParser@CppSharp@@QEAAXXZ")]
                internal static extern void ClearDiagnostics(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?getDiagnosticsCount@ParserResult@CppParser@CppSharp@@QEAAIXZ")]
                internal static extern uint GetDiagnosticsCount(global::System.IntPtr instance);
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.ParserResult> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.ParserResult>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::CppSharp.Parser.ParserResult __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::CppSharp.Parser.ParserResult(native.ToPointer(), skipVTables);
            }

            internal static global::CppSharp.Parser.ParserResult __CreateInstance(global::CppSharp.Parser.ParserResult.__Internal native, bool skipVTables = false)
            {
                return new global::CppSharp.Parser.ParserResult(native, skipVTables);
            }

            private static void* __CopyValue(global::CppSharp.Parser.ParserResult.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.ParserResult.__Internal));
                global::CppSharp.Parser.ParserResult.__Internal.cctor(ret, new global::System.IntPtr(&native));
                return ret.ToPointer();
            }

            private ParserResult(global::CppSharp.Parser.ParserResult.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected ParserResult(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public ParserResult()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.ParserResult.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor((__Instance + __PointerAdjustment));
            }

            public ParserResult(global::CppSharp.Parser.ParserResult _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.ParserResult.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor((__Instance + __PointerAdjustment), __arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::CppSharp.Parser.ParserResult __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (disposing)
                    __Internal.dtor((__Instance + __PointerAdjustment), 0);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public global::CppSharp.Parser.ParserDiagnostic GetDiagnostics(uint i)
            {
                var __ret = new global::CppSharp.Parser.ParserDiagnostic.__Internal();
                __Internal.GetDiagnostics((__Instance + __PointerAdjustment), new IntPtr(&__ret), i);
                return global::CppSharp.Parser.ParserDiagnostic.__CreateInstance(__ret);
            }

            public void AddDiagnostics(global::CppSharp.Parser.ParserDiagnostic s)
            {
                if (ReferenceEquals(s, null))
                    throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = s.__Instance;
                __Internal.AddDiagnostics((__Instance + __PointerAdjustment), __arg0);
            }

            public void ClearDiagnostics()
            {
                __Internal.ClearDiagnostics((__Instance + __PointerAdjustment));
            }

            public global::CppSharp.Parser.ParserResultKind Kind
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserResult.__Internal*) __Instance)->kind;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserResult.__Internal*) __Instance)->kind = value;
                }
            }

            public global::CppSharp.Parser.AST.ASTContext ASTContext
            {
                get
                {
                    global::CppSharp.Parser.AST.ASTContext __result0;
                    if (((global::CppSharp.Parser.ParserResult.__Internal*) __Instance)->ASTContext == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.ASTContext.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.ParserResult.__Internal*) __Instance)->ASTContext))
                        __result0 = (global::CppSharp.Parser.AST.ASTContext) global::CppSharp.Parser.AST.ASTContext.NativeToManagedMap[((global::CppSharp.Parser.ParserResult.__Internal*) __Instance)->ASTContext];
                    else __result0 = global::CppSharp.Parser.AST.ASTContext.__CreateInstance(((global::CppSharp.Parser.ParserResult.__Internal*) __Instance)->ASTContext);
                    return __result0;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserResult.__Internal*) __Instance)->ASTContext = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                }
            }

            public global::CppSharp.Parser.AST.NativeLibrary Library
            {
                get
                {
                    global::CppSharp.Parser.AST.NativeLibrary __result0;
                    if (((global::CppSharp.Parser.ParserResult.__Internal*) __Instance)->library == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.NativeLibrary.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.ParserResult.__Internal*) __Instance)->library))
                        __result0 = (global::CppSharp.Parser.AST.NativeLibrary) global::CppSharp.Parser.AST.NativeLibrary.NativeToManagedMap[((global::CppSharp.Parser.ParserResult.__Internal*) __Instance)->library];
                    else __result0 = global::CppSharp.Parser.AST.NativeLibrary.__CreateInstance(((global::CppSharp.Parser.ParserResult.__Internal*) __Instance)->library);
                    return __result0;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserResult.__Internal*) __Instance)->library = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                }
            }

            public global::CppSharp.Parser.Parser CodeParser
            {
                get
                {
                    global::CppSharp.Parser.Parser __result0;
                    if (((global::CppSharp.Parser.ParserResult.__Internal*) __Instance)->codeParser == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.Parser.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.ParserResult.__Internal*) __Instance)->codeParser))
                        __result0 = (global::CppSharp.Parser.Parser) global::CppSharp.Parser.Parser.NativeToManagedMap[((global::CppSharp.Parser.ParserResult.__Internal*) __Instance)->codeParser];
                    else __result0 = global::CppSharp.Parser.Parser.__CreateInstance(((global::CppSharp.Parser.ParserResult.__Internal*) __Instance)->codeParser);
                    return __result0;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserResult.__Internal*) __Instance)->codeParser = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                }
            }

            public uint DiagnosticsCount
            {
                get
                {
                    var __ret = __Internal.GetDiagnosticsCount((__Instance + __PointerAdjustment));
                    return __ret;
                }
            }
        }

        public unsafe partial class ClangParser : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct __Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="??0ClangParser@CppParser@CppSharp@@QEAA@AEBV012@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?ParseHeader@ClangParser@CppParser@CppSharp@@SAPEAUParserResult@23@PEAUCppParserOptions@23@@Z")]
                internal static extern global::System.IntPtr ParseHeader(global::System.IntPtr Opts);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?ParseLibrary@ClangParser@CppParser@CppSharp@@SAPEAUParserResult@23@PEAUCppParserOptions@23@@Z")]
                internal static extern global::System.IntPtr ParseLibrary(global::System.IntPtr Opts);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?GetTargetInfo@ClangParser@CppParser@CppSharp@@SAPEAUParserTargetInfo@23@PEAUCppParserOptions@23@@Z")]
                internal static extern global::System.IntPtr GetTargetInfo(global::System.IntPtr Opts);
            }

            public global::System.IntPtr __Instance { get; protected set; }

            protected int __PointerAdjustment;
            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.ClangParser> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.ClangParser>();
            protected void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::CppSharp.Parser.ClangParser __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::CppSharp.Parser.ClangParser(native.ToPointer(), skipVTables);
            }

            internal static global::CppSharp.Parser.ClangParser __CreateInstance(global::CppSharp.Parser.ClangParser.__Internal native, bool skipVTables = false)
            {
                return new global::CppSharp.Parser.ClangParser(native, skipVTables);
            }

            private static void* __CopyValue(global::CppSharp.Parser.ClangParser.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.ClangParser.__Internal));
                *(global::CppSharp.Parser.ClangParser.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private ClangParser(global::CppSharp.Parser.ClangParser.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected ClangParser(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public ClangParser()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.ClangParser.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            public ClangParser(global::CppSharp.Parser.ClangParser _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.ClangParser.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::CppSharp.Parser.ClangParser.__Internal*) __Instance) = *((global::CppSharp.Parser.ClangParser.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::CppSharp.Parser.ClangParser __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static global::CppSharp.Parser.ParserResult ParseHeader(global::CppSharp.Parser.CppParserOptions Opts)
            {
                var __arg0 = ReferenceEquals(Opts, null) ? global::System.IntPtr.Zero : Opts.__Instance;
                var __ret = __Internal.ParseHeader(__arg0);
                global::CppSharp.Parser.ParserResult __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::CppSharp.Parser.ParserResult.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::CppSharp.Parser.ParserResult) global::CppSharp.Parser.ParserResult.NativeToManagedMap[__ret];
                else __result0 = global::CppSharp.Parser.ParserResult.__CreateInstance(__ret);
                return __result0;
            }

            public static global::CppSharp.Parser.ParserResult ParseLibrary(global::CppSharp.Parser.CppParserOptions Opts)
            {
                var __arg0 = ReferenceEquals(Opts, null) ? global::System.IntPtr.Zero : Opts.__Instance;
                var __ret = __Internal.ParseLibrary(__arg0);
                global::CppSharp.Parser.ParserResult __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::CppSharp.Parser.ParserResult.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::CppSharp.Parser.ParserResult) global::CppSharp.Parser.ParserResult.NativeToManagedMap[__ret];
                else __result0 = global::CppSharp.Parser.ParserResult.__CreateInstance(__ret);
                return __result0;
            }

            public static global::CppSharp.Parser.ParserTargetInfo GetTargetInfo(global::CppSharp.Parser.CppParserOptions Opts)
            {
                var __arg0 = ReferenceEquals(Opts, null) ? global::System.IntPtr.Zero : Opts.__Instance;
                var __ret = __Internal.GetTargetInfo(__arg0);
                global::CppSharp.Parser.ParserTargetInfo __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::CppSharp.Parser.ParserTargetInfo.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::CppSharp.Parser.ParserTargetInfo) global::CppSharp.Parser.ParserTargetInfo.NativeToManagedMap[__ret];
                else __result0 = global::CppSharp.Parser.ParserTargetInfo.__CreateInstance(__ret);
                return __result0;
            }
        }
    }
}
