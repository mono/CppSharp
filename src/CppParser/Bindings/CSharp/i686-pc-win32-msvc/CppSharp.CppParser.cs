// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using System.Runtime.CompilerServices;

[assembly:InternalsVisibleTo("CppSharp.Parser")]

namespace CppSharp
{
    namespace Parser
    {
        namespace AST
        {
            public enum RawCommentKind
            {
                Invalid = 0,
                OrdinaryBCPL = 1,
                OrdinaryC = 2,
                BCPLSlash = 3,
                BCPLExcl = 4,
                JavaDoc = 5,
                Qt = 6,
                Merged = 7
            }

            public enum CommentKind
            {
                FullComment = 0,
                BlockContentComment = 1,
                BlockCommandComment = 2,
                ParamCommandComment = 3,
                TParamCommandComment = 4,
                VerbatimBlockComment = 5,
                VerbatimLineComment = 6,
                ParagraphComment = 7,
                HTMLTagComment = 8,
                HTMLStartTagComment = 9,
                HTMLEndTagComment = 10,
                TextComment = 11,
                InlineContentComment = 12,
                InlineCommandComment = 13,
                VerbatimBlockLineComment = 14
            }

            public enum ArchType
            {
                UnknownArch = 0,
                X86 = 1,
                X86_64 = 2
            }

            public unsafe partial class NativeLibrary : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 52)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C fileName;

                    [FieldOffset(24)]
                    internal global::CppSharp.Parser.AST.ArchType archType;

                    [FieldOffset(28)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C___N_std_S_allocator__S0_ Symbols;

                    [FieldOffset(40)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C___N_std_S_allocator__S0_ Dependencies;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0NativeLibrary@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0NativeLibrary@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??1NativeLibrary@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern void dtor(global::System.IntPtr __instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getSymbols@NativeLibrary@AST@CppParser@CppSharp@@QAEPBDI@Z")]
                    internal static extern global::System.IntPtr GetSymbols(global::System.IntPtr __instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?addSymbols@NativeLibrary@AST@CppParser@CppSharp@@QAEXPBD@Z")]
                    internal static extern void AddSymbols(global::System.IntPtr __instance, [MarshalAs(UnmanagedType.LPUTF8Str)] string s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?clearSymbols@NativeLibrary@AST@CppParser@CppSharp@@QAEXXZ")]
                    internal static extern void ClearSymbols(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getDependencies@NativeLibrary@AST@CppParser@CppSharp@@QAEPBDI@Z")]
                    internal static extern global::System.IntPtr GetDependencies(global::System.IntPtr __instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?addDependencies@NativeLibrary@AST@CppParser@CppSharp@@QAEXPBD@Z")]
                    internal static extern void AddDependencies(global::System.IntPtr __instance, [MarshalAs(UnmanagedType.LPUTF8Str)] string s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?clearDependencies@NativeLibrary@AST@CppParser@CppSharp@@QAEXXZ")]
                    internal static extern void ClearDependencies(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getSymbolsCount@NativeLibrary@AST@CppParser@CppSharp@@QAEIXZ")]
                    internal static extern uint GetSymbolsCount(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getDependenciesCount@NativeLibrary@AST@CppParser@CppSharp@@QAEIXZ")]
                    internal static extern uint GetDependenciesCount(global::System.IntPtr __instance);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.NativeLibrary> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.NativeLibrary>();
                protected internal void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                internal static global::CppSharp.Parser.AST.NativeLibrary __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.NativeLibrary(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.NativeLibrary __CreateInstance(global::CppSharp.Parser.AST.NativeLibrary.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.NativeLibrary(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.NativeLibrary.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.NativeLibrary.__Internal));
                    global::CppSharp.Parser.AST.NativeLibrary.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private NativeLibrary(global::CppSharp.Parser.AST.NativeLibrary.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected NativeLibrary(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public NativeLibrary()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.NativeLibrary.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public NativeLibrary(global::CppSharp.Parser.AST.NativeLibrary _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.NativeLibrary.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                public virtual void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.NativeLibrary __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor(__Instance, 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public string GetSymbols(uint i)
                {
                    var __ret = __Internal.GetSymbols(__Instance, i);
                    if (__ret == global::System.IntPtr.Zero)
                        return default(string);
                    var __retPtr = (byte*) __ret;
                    int __length = 0;
                    while (*(__retPtr++) != 0) __length += sizeof(byte);
                    return global::System.Text.Encoding.UTF8.GetString((byte*) __ret, __length);
                }

                public void AddSymbols(string s)
                {
                    __Internal.AddSymbols(__Instance, s);
                }

                public void ClearSymbols()
                {
                    __Internal.ClearSymbols(__Instance);
                }

                public string GetDependencies(uint i)
                {
                    var __ret = __Internal.GetDependencies(__Instance, i);
                    if (__ret == global::System.IntPtr.Zero)
                        return default(string);
                    var __retPtr = (byte*) __ret;
                    int __length = 0;
                    while (*(__retPtr++) != 0) __length += sizeof(byte);
                    return global::System.Text.Encoding.UTF8.GetString((byte*) __ret, __length);
                }

                public void AddDependencies(string s)
                {
                    __Internal.AddDependencies(__Instance, s);
                }

                public void ClearDependencies()
                {
                    __Internal.ClearDependencies(__Instance);
                }

                public string FileName
                {
                    get
                    {
                        var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.NativeLibrary.__Internal*) __Instance)->fileName));
                        return global::Std.BasicStringExtensions.Data(__basicStringRet0);
                    }

                    set
                    {
                        global::Std.BasicStringExtensions.__Internal.Assign(new global::System.IntPtr(&((global::CppSharp.Parser.AST.NativeLibrary.__Internal*)__Instance)->fileName), value);
                    }
                }

                public global::CppSharp.Parser.AST.ArchType ArchType
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.NativeLibrary.__Internal*) __Instance)->archType;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.NativeLibrary.__Internal*)__Instance)->archType = value;
                    }
                }

                public uint SymbolsCount
                {
                    get
                    {
                        var __ret = __Internal.GetSymbolsCount(__Instance);
                        return __ret;
                    }
                }

                public uint DependenciesCount
                {
                    get
                    {
                        var __ret = __Internal.GetDependenciesCount(__Instance);
                        return __ret;
                    }
                }
            }

            public unsafe partial class Comment : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 4)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.CommentKind kind;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0Comment@AST@CppParser@CppSharp@@QAE@W4CommentKind@123@@Z")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance, global::CppSharp.Parser.AST.CommentKind kind);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0Comment@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.Comment> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.Comment>();
                protected internal void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                internal static global::CppSharp.Parser.AST.Comment __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.Comment(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.Comment __CreateInstance(global::CppSharp.Parser.AST.Comment.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.Comment(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.Comment.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Comment.__Internal));
                    *(global::CppSharp.Parser.AST.Comment.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private Comment(global::CppSharp.Parser.AST.Comment.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected Comment(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public Comment(global::CppSharp.Parser.AST.CommentKind kind)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Comment.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance, kind);
                }

                public Comment(global::CppSharp.Parser.AST.Comment _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Comment.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.Comment.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.Comment.__Internal*) _0.__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                public virtual void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Comment __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public static implicit operator global::CppSharp.Parser.AST.Comment(global::CppSharp.Parser.AST.CommentKind kind)
                {
                    return new global::CppSharp.Parser.AST.Comment(kind);
                }

                public global::CppSharp.Parser.AST.CommentKind Kind
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Comment.__Internal*) __Instance)->kind;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Comment.__Internal*)__Instance)->kind = value;
                    }
                }
            }

            public unsafe partial class BlockContentComment : global::CppSharp.Parser.AST.Comment, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 4)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.CommentKind kind;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0BlockContentComment@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0BlockContentComment@AST@CppParser@CppSharp@@QAE@W4CommentKind@123@@Z")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance, global::CppSharp.Parser.AST.CommentKind Kind);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0BlockContentComment@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.BlockContentComment __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.BlockContentComment(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.BlockContentComment __CreateInstance(global::CppSharp.Parser.AST.BlockContentComment.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.BlockContentComment(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.BlockContentComment.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.BlockContentComment.__Internal));
                    *(global::CppSharp.Parser.AST.BlockContentComment.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private BlockContentComment(global::CppSharp.Parser.AST.BlockContentComment.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected BlockContentComment(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public BlockContentComment()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.BlockContentComment.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public BlockContentComment(global::CppSharp.Parser.AST.CommentKind Kind)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.BlockContentComment.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance, Kind);
                }

                public BlockContentComment(global::CppSharp.Parser.AST.BlockContentComment _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.BlockContentComment.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.BlockContentComment.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.BlockContentComment.__Internal*) _0.__Instance);
                }

                public static implicit operator global::CppSharp.Parser.AST.BlockContentComment(global::CppSharp.Parser.AST.CommentKind Kind)
                {
                    return new global::CppSharp.Parser.AST.BlockContentComment(Kind);
                }
            }

            public unsafe partial class FullComment : global::CppSharp.Parser.AST.Comment, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 16)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.CommentKind kind;

                    [FieldOffset(4)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_BlockContentComment___N_std_S_allocator__S0_ Blocks;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0FullComment@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0FullComment@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??1FullComment@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern void dtor(global::System.IntPtr __instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getBlocks@FullComment@AST@CppParser@CppSharp@@QAEPAVBlockContentComment@234@I@Z")]
                    internal static extern global::System.IntPtr GetBlocks(global::System.IntPtr __instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?addBlocks@FullComment@AST@CppParser@CppSharp@@QAEXAAPAVBlockContentComment@234@@Z")]
                    internal static extern void AddBlocks(global::System.IntPtr __instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?clearBlocks@FullComment@AST@CppParser@CppSharp@@QAEXXZ")]
                    internal static extern void ClearBlocks(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getBlocksCount@FullComment@AST@CppParser@CppSharp@@QAEIXZ")]
                    internal static extern uint GetBlocksCount(global::System.IntPtr __instance);
                }

                internal static new global::CppSharp.Parser.AST.FullComment __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.FullComment(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.FullComment __CreateInstance(global::CppSharp.Parser.AST.FullComment.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.FullComment(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.FullComment.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.FullComment.__Internal));
                    global::CppSharp.Parser.AST.FullComment.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private FullComment(global::CppSharp.Parser.AST.FullComment.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected FullComment(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public FullComment()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.FullComment.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public FullComment(global::CppSharp.Parser.AST.FullComment _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.FullComment.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Comment __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor(__Instance, 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.BlockContentComment GetBlocks(uint i)
                {
                    var __ret = __Internal.GetBlocks(__Instance, i);
                    global::CppSharp.Parser.AST.BlockContentComment __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.BlockContentComment.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::CppSharp.Parser.AST.BlockContentComment) global::CppSharp.Parser.AST.BlockContentComment.NativeToManagedMap[__ret];
                    else __result0 = global::CppSharp.Parser.AST.BlockContentComment.__CreateInstance(__ret);
                    return __result0;
                }

                public void AddBlocks(global::CppSharp.Parser.AST.BlockContentComment s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var ____arg0 = s.__Instance;
                    var __arg0 = new global::System.IntPtr(&____arg0);
                    __Internal.AddBlocks(__Instance, __arg0);
                }

                public void ClearBlocks()
                {
                    __Internal.ClearBlocks(__Instance);
                }

                public uint BlocksCount
                {
                    get
                    {
                        var __ret = __Internal.GetBlocksCount(__Instance);
                        return __ret;
                    }
                }
            }

            public unsafe partial class InlineContentComment : global::CppSharp.Parser.AST.Comment, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 8)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.CommentKind kind;

                    [FieldOffset(4)]
                    internal byte hasTrailingNewline;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0InlineContentComment@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0InlineContentComment@AST@CppParser@CppSharp@@QAE@W4CommentKind@123@@Z")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance, global::CppSharp.Parser.AST.CommentKind Kind);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0InlineContentComment@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.InlineContentComment __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.InlineContentComment(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.InlineContentComment __CreateInstance(global::CppSharp.Parser.AST.InlineContentComment.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.InlineContentComment(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.InlineContentComment.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.InlineContentComment.__Internal));
                    *(global::CppSharp.Parser.AST.InlineContentComment.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private InlineContentComment(global::CppSharp.Parser.AST.InlineContentComment.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected InlineContentComment(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public InlineContentComment()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.InlineContentComment.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public InlineContentComment(global::CppSharp.Parser.AST.CommentKind Kind)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.InlineContentComment.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance, Kind);
                }

                public InlineContentComment(global::CppSharp.Parser.AST.InlineContentComment _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.InlineContentComment.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.InlineContentComment.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.InlineContentComment.__Internal*) _0.__Instance);
                }

                public static implicit operator global::CppSharp.Parser.AST.InlineContentComment(global::CppSharp.Parser.AST.CommentKind Kind)
                {
                    return new global::CppSharp.Parser.AST.InlineContentComment(Kind);
                }

                public bool HasTrailingNewline
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.InlineContentComment.__Internal*) __Instance)->hasTrailingNewline != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.InlineContentComment.__Internal*)__Instance)->hasTrailingNewline = (byte) (value ? 1 : 0);
                    }
                }
            }

            public unsafe partial class ParagraphComment : global::CppSharp.Parser.AST.BlockContentComment, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 20)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.CommentKind kind;

                    [FieldOffset(4)]
                    internal byte isWhitespace;

                    [FieldOffset(8)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_InlineContentComment___N_std_S_allocator__S0_ Content;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0ParagraphComment@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0ParagraphComment@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??1ParagraphComment@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern void dtor(global::System.IntPtr __instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getContent@ParagraphComment@AST@CppParser@CppSharp@@QAEPAVInlineContentComment@234@I@Z")]
                    internal static extern global::System.IntPtr GetContent(global::System.IntPtr __instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?addContent@ParagraphComment@AST@CppParser@CppSharp@@QAEXAAPAVInlineContentComment@234@@Z")]
                    internal static extern void AddContent(global::System.IntPtr __instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?clearContent@ParagraphComment@AST@CppParser@CppSharp@@QAEXXZ")]
                    internal static extern void ClearContent(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getContentCount@ParagraphComment@AST@CppParser@CppSharp@@QAEIXZ")]
                    internal static extern uint GetContentCount(global::System.IntPtr __instance);
                }

                internal static new global::CppSharp.Parser.AST.ParagraphComment __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.ParagraphComment(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.ParagraphComment __CreateInstance(global::CppSharp.Parser.AST.ParagraphComment.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.ParagraphComment(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.ParagraphComment.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ParagraphComment.__Internal));
                    global::CppSharp.Parser.AST.ParagraphComment.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private ParagraphComment(global::CppSharp.Parser.AST.ParagraphComment.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected ParagraphComment(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public ParagraphComment()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ParagraphComment.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public ParagraphComment(global::CppSharp.Parser.AST.ParagraphComment _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ParagraphComment.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Comment __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor(__Instance, 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.InlineContentComment GetContent(uint i)
                {
                    var __ret = __Internal.GetContent(__Instance, i);
                    global::CppSharp.Parser.AST.InlineContentComment __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.InlineContentComment.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::CppSharp.Parser.AST.InlineContentComment) global::CppSharp.Parser.AST.InlineContentComment.NativeToManagedMap[__ret];
                    else __result0 = global::CppSharp.Parser.AST.InlineContentComment.__CreateInstance(__ret);
                    return __result0;
                }

                public void AddContent(global::CppSharp.Parser.AST.InlineContentComment s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var ____arg0 = s.__Instance;
                    var __arg0 = new global::System.IntPtr(&____arg0);
                    __Internal.AddContent(__Instance, __arg0);
                }

                public void ClearContent()
                {
                    __Internal.ClearContent(__Instance);
                }

                public bool IsWhitespace
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.ParagraphComment.__Internal*) __Instance)->isWhitespace != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.ParagraphComment.__Internal*)__Instance)->isWhitespace = (byte) (value ? 1 : 0);
                    }
                }

                public uint ContentCount
                {
                    get
                    {
                        var __ret = __Internal.GetContentCount(__Instance);
                        return __ret;
                    }
                }
            }

            public unsafe partial class BlockCommandComment : global::CppSharp.Parser.AST.BlockContentComment, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 24)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.CommentKind kind;

                    [FieldOffset(4)]
                    internal uint commandId;

                    [FieldOffset(8)]
                    internal global::System.IntPtr paragraphComment;

                    [FieldOffset(12)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector____N_CppSharp_N_CppParser_N_AST_S_BlockCommandComment_S_Argument___N_std_S_allocator__S0_ Arguments;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0BlockCommandComment@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0BlockCommandComment@AST@CppParser@CppSharp@@QAE@W4CommentKind@123@@Z")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance, global::CppSharp.Parser.AST.CommentKind Kind);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0BlockCommandComment@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??1BlockCommandComment@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern void dtor(global::System.IntPtr __instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getArguments@BlockCommandComment@AST@CppParser@CppSharp@@QAE?AVArgument@1234@I@Z")]
                    internal static extern void GetArguments(global::System.IntPtr __instance, global::System.IntPtr @return, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?addArguments@BlockCommandComment@AST@CppParser@CppSharp@@QAEXAAVArgument@1234@@Z")]
                    internal static extern void AddArguments(global::System.IntPtr __instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?clearArguments@BlockCommandComment@AST@CppParser@CppSharp@@QAEXXZ")]
                    internal static extern void ClearArguments(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getArgumentsCount@BlockCommandComment@AST@CppParser@CppSharp@@QAEIXZ")]
                    internal static extern uint GetArgumentsCount(global::System.IntPtr __instance);
                }

                public unsafe partial class Argument : IDisposable
                {
                    [StructLayout(LayoutKind.Explicit, Size = 24)]
                    public partial struct __Internal
                    {
                        [FieldOffset(0)]
                        internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C text;

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                            EntryPoint="??0Argument@BlockCommandComment@AST@CppParser@CppSharp@@QAE@XZ")]
                        internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                            EntryPoint="??0Argument@BlockCommandComment@AST@CppParser@CppSharp@@QAE@ABV01234@@Z")]
                        internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                            EntryPoint="??1Argument@BlockCommandComment@AST@CppParser@CppSharp@@QAE@XZ")]
                        internal static extern void dtor(global::System.IntPtr __instance, int delete);
                    }

                    public global::System.IntPtr __Instance { get; protected set; }

                    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.BlockCommandComment.Argument> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.BlockCommandComment.Argument>();
                    protected internal void*[] __OriginalVTables;

                    protected bool __ownsNativeInstance;

                    internal static global::CppSharp.Parser.AST.BlockCommandComment.Argument __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                    {
                        return new global::CppSharp.Parser.AST.BlockCommandComment.Argument(native.ToPointer(), skipVTables);
                    }

                    internal static global::CppSharp.Parser.AST.BlockCommandComment.Argument __CreateInstance(global::CppSharp.Parser.AST.BlockCommandComment.Argument.__Internal native, bool skipVTables = false)
                    {
                        return new global::CppSharp.Parser.AST.BlockCommandComment.Argument(native, skipVTables);
                    }

                    private static void* __CopyValue(global::CppSharp.Parser.AST.BlockCommandComment.Argument.__Internal native)
                    {
                        var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.BlockCommandComment.Argument.__Internal));
                        global::CppSharp.Parser.AST.BlockCommandComment.Argument.__Internal.cctor(ret, new global::System.IntPtr(&native));
                        return ret.ToPointer();
                    }

                    private Argument(global::CppSharp.Parser.AST.BlockCommandComment.Argument.__Internal native, bool skipVTables = false)
                        : this(__CopyValue(native), skipVTables)
                    {
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                    }

                    protected Argument(void* native, bool skipVTables = false)
                    {
                        if (native == null)
                            return;
                        __Instance = new global::System.IntPtr(native);
                    }

                    public Argument()
                    {
                        __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.BlockCommandComment.Argument.__Internal));
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                        __Internal.ctor(__Instance);
                    }

                    public Argument(global::CppSharp.Parser.AST.BlockCommandComment.Argument _0)
                    {
                        __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.BlockCommandComment.Argument.__Internal));
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                        if (ReferenceEquals(_0, null))
                            throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                        var __arg0 = _0.__Instance;
                        __Internal.cctor(__Instance, __arg0);
                    }

                    public void Dispose()
                    {
                        Dispose(disposing: true);
                    }

                    public virtual void Dispose(bool disposing)
                    {
                        if (__Instance == IntPtr.Zero)
                            return;
                        global::CppSharp.Parser.AST.BlockCommandComment.Argument __dummy;
                        NativeToManagedMap.TryRemove(__Instance, out __dummy);
                        if (disposing)
                            __Internal.dtor(__Instance, 0);
                        if (__ownsNativeInstance)
                            Marshal.FreeHGlobal(__Instance);
                        __Instance = IntPtr.Zero;
                    }

                    public string Text
                    {
                        get
                        {
                            var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.BlockCommandComment.Argument.__Internal*) __Instance)->text));
                            return global::Std.BasicStringExtensions.Data(__basicStringRet0);
                        }

                        set
                        {
                            global::Std.BasicStringExtensions.__Internal.Assign(new global::System.IntPtr(&((global::CppSharp.Parser.AST.BlockCommandComment.Argument.__Internal*)__Instance)->text), value);
                        }
                    }
                }

                internal static new global::CppSharp.Parser.AST.BlockCommandComment __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.BlockCommandComment(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.BlockCommandComment __CreateInstance(global::CppSharp.Parser.AST.BlockCommandComment.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.BlockCommandComment(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.BlockCommandComment.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.BlockCommandComment.__Internal));
                    global::CppSharp.Parser.AST.BlockCommandComment.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private BlockCommandComment(global::CppSharp.Parser.AST.BlockCommandComment.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected BlockCommandComment(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public BlockCommandComment()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.BlockCommandComment.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public BlockCommandComment(global::CppSharp.Parser.AST.CommentKind Kind)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.BlockCommandComment.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance, Kind);
                }

                public BlockCommandComment(global::CppSharp.Parser.AST.BlockCommandComment _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.BlockCommandComment.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Comment __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor(__Instance, 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.BlockCommandComment.Argument GetArguments(uint i)
                {
                    var __ret = new global::CppSharp.Parser.AST.BlockCommandComment.Argument.__Internal();
                    __Internal.GetArguments(__Instance, new IntPtr(&__ret), i);
                    return global::CppSharp.Parser.AST.BlockCommandComment.Argument.__CreateInstance(__ret);
                }

                public void AddArguments(global::CppSharp.Parser.AST.BlockCommandComment.Argument s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    __Internal.AddArguments(__Instance, __arg0);
                }

                public void ClearArguments()
                {
                    __Internal.ClearArguments(__Instance);
                }

                public static implicit operator global::CppSharp.Parser.AST.BlockCommandComment(global::CppSharp.Parser.AST.CommentKind Kind)
                {
                    return new global::CppSharp.Parser.AST.BlockCommandComment(Kind);
                }

                public uint CommandId
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.BlockCommandComment.__Internal*) __Instance)->commandId;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.BlockCommandComment.__Internal*)__Instance)->commandId = value;
                    }
                }

                public global::CppSharp.Parser.AST.ParagraphComment ParagraphComment
                {
                    get
                    {
                        global::CppSharp.Parser.AST.ParagraphComment __result0;
                        if (((global::CppSharp.Parser.AST.BlockCommandComment.__Internal*) __Instance)->paragraphComment == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.ParagraphComment.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.BlockCommandComment.__Internal*) __Instance)->paragraphComment))
                            __result0 = (global::CppSharp.Parser.AST.ParagraphComment) global::CppSharp.Parser.AST.ParagraphComment.NativeToManagedMap[((global::CppSharp.Parser.AST.BlockCommandComment.__Internal*) __Instance)->paragraphComment];
                        else __result0 = global::CppSharp.Parser.AST.ParagraphComment.__CreateInstance(((global::CppSharp.Parser.AST.BlockCommandComment.__Internal*) __Instance)->paragraphComment);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.BlockCommandComment.__Internal*)__Instance)->paragraphComment = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public uint ArgumentsCount
                {
                    get
                    {
                        var __ret = __Internal.GetArgumentsCount(__Instance);
                        return __ret;
                    }
                }
            }

            public unsafe partial class ParamCommandComment : global::CppSharp.Parser.AST.BlockCommandComment, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 32)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.CommentKind kind;

                    [FieldOffset(4)]
                    internal uint commandId;

                    [FieldOffset(8)]
                    internal global::System.IntPtr paragraphComment;

                    [FieldOffset(12)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector____N_CppSharp_N_CppParser_N_AST_S_BlockCommandComment_S_Argument___N_std_S_allocator__S0_ Arguments;

                    [FieldOffset(24)]
                    internal global::CppSharp.Parser.AST.ParamCommandComment.PassDirection direction;

                    [FieldOffset(28)]
                    internal uint paramIndex;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0ParamCommandComment@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0ParamCommandComment@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??1ParamCommandComment@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern void dtor(global::System.IntPtr __instance, int delete);
                }

                public enum PassDirection
                {
                    In = 0,
                    Out = 1,
                    InOut = 2
                }

                internal static new global::CppSharp.Parser.AST.ParamCommandComment __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.ParamCommandComment(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.ParamCommandComment __CreateInstance(global::CppSharp.Parser.AST.ParamCommandComment.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.ParamCommandComment(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.ParamCommandComment.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ParamCommandComment.__Internal));
                    global::CppSharp.Parser.AST.ParamCommandComment.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private ParamCommandComment(global::CppSharp.Parser.AST.ParamCommandComment.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected ParamCommandComment(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public ParamCommandComment()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ParamCommandComment.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public ParamCommandComment(global::CppSharp.Parser.AST.ParamCommandComment _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ParamCommandComment.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Comment __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor(__Instance, 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.ParamCommandComment.PassDirection Direction
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.ParamCommandComment.__Internal*) __Instance)->direction;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.ParamCommandComment.__Internal*)__Instance)->direction = value;
                    }
                }

                public uint ParamIndex
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.ParamCommandComment.__Internal*) __Instance)->paramIndex;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.ParamCommandComment.__Internal*)__Instance)->paramIndex = value;
                    }
                }
            }

            public unsafe partial class TParamCommandComment : global::CppSharp.Parser.AST.BlockCommandComment, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 36)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.CommentKind kind;

                    [FieldOffset(4)]
                    internal uint commandId;

                    [FieldOffset(8)]
                    internal global::System.IntPtr paragraphComment;

                    [FieldOffset(12)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector____N_CppSharp_N_CppParser_N_AST_S_BlockCommandComment_S_Argument___N_std_S_allocator__S0_ Arguments;

                    [FieldOffset(24)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector__i___N_std_S_allocator__i Position;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0TParamCommandComment@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0TParamCommandComment@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??1TParamCommandComment@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern void dtor(global::System.IntPtr __instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getPosition@TParamCommandComment@AST@CppParser@CppSharp@@QAEII@Z")]
                    internal static extern uint GetPosition(global::System.IntPtr __instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?addPosition@TParamCommandComment@AST@CppParser@CppSharp@@QAEXAAI@Z")]
                    internal static extern void AddPosition(global::System.IntPtr __instance, uint* s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?clearPosition@TParamCommandComment@AST@CppParser@CppSharp@@QAEXXZ")]
                    internal static extern void ClearPosition(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getPositionCount@TParamCommandComment@AST@CppParser@CppSharp@@QAEIXZ")]
                    internal static extern uint GetPositionCount(global::System.IntPtr __instance);
                }

                internal static new global::CppSharp.Parser.AST.TParamCommandComment __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.TParamCommandComment(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.TParamCommandComment __CreateInstance(global::CppSharp.Parser.AST.TParamCommandComment.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.TParamCommandComment(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.TParamCommandComment.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TParamCommandComment.__Internal));
                    global::CppSharp.Parser.AST.TParamCommandComment.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private TParamCommandComment(global::CppSharp.Parser.AST.TParamCommandComment.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected TParamCommandComment(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public TParamCommandComment()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TParamCommandComment.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public TParamCommandComment(global::CppSharp.Parser.AST.TParamCommandComment _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TParamCommandComment.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Comment __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor(__Instance, 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public uint GetPosition(uint i)
                {
                    var __ret = __Internal.GetPosition(__Instance, i);
                    return __ret;
                }

                public void AddPosition(ref uint s)
                {
                    fixed (uint* __s0 = &s)
                    {
                        var __arg0 = __s0;
                        __Internal.AddPosition(__Instance, __arg0);
                    }
                }

                public void ClearPosition()
                {
                    __Internal.ClearPosition(__Instance);
                }

                public uint PositionCount
                {
                    get
                    {
                        var __ret = __Internal.GetPositionCount(__Instance);
                        return __ret;
                    }
                }
            }

            public unsafe partial class VerbatimBlockLineComment : global::CppSharp.Parser.AST.Comment, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 28)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.CommentKind kind;

                    [FieldOffset(4)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C text;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0VerbatimBlockLineComment@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0VerbatimBlockLineComment@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??1VerbatimBlockLineComment@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern void dtor(global::System.IntPtr __instance, int delete);
                }

                internal static new global::CppSharp.Parser.AST.VerbatimBlockLineComment __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.VerbatimBlockLineComment(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.VerbatimBlockLineComment __CreateInstance(global::CppSharp.Parser.AST.VerbatimBlockLineComment.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.VerbatimBlockLineComment(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.VerbatimBlockLineComment.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.VerbatimBlockLineComment.__Internal));
                    global::CppSharp.Parser.AST.VerbatimBlockLineComment.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private VerbatimBlockLineComment(global::CppSharp.Parser.AST.VerbatimBlockLineComment.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected VerbatimBlockLineComment(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public VerbatimBlockLineComment()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.VerbatimBlockLineComment.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public VerbatimBlockLineComment(global::CppSharp.Parser.AST.VerbatimBlockLineComment _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.VerbatimBlockLineComment.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Comment __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor(__Instance, 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public string Text
                {
                    get
                    {
                        var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.VerbatimBlockLineComment.__Internal*) __Instance)->text));
                        return global::Std.BasicStringExtensions.Data(__basicStringRet0);
                    }

                    set
                    {
                        global::Std.BasicStringExtensions.__Internal.Assign(new global::System.IntPtr(&((global::CppSharp.Parser.AST.VerbatimBlockLineComment.__Internal*)__Instance)->text), value);
                    }
                }
            }

            public unsafe partial class VerbatimBlockComment : global::CppSharp.Parser.AST.BlockCommandComment, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 36)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.CommentKind kind;

                    [FieldOffset(4)]
                    internal uint commandId;

                    [FieldOffset(8)]
                    internal global::System.IntPtr paragraphComment;

                    [FieldOffset(12)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector____N_CppSharp_N_CppParser_N_AST_S_BlockCommandComment_S_Argument___N_std_S_allocator__S0_ Arguments;

                    [FieldOffset(24)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_VerbatimBlockLineComment___N_std_S_allocator__S0_ Lines;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0VerbatimBlockComment@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0VerbatimBlockComment@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??1VerbatimBlockComment@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern void dtor(global::System.IntPtr __instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getLines@VerbatimBlockComment@AST@CppParser@CppSharp@@QAEPAVVerbatimBlockLineComment@234@I@Z")]
                    internal static extern global::System.IntPtr GetLines(global::System.IntPtr __instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?addLines@VerbatimBlockComment@AST@CppParser@CppSharp@@QAEXAAPAVVerbatimBlockLineComment@234@@Z")]
                    internal static extern void AddLines(global::System.IntPtr __instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?clearLines@VerbatimBlockComment@AST@CppParser@CppSharp@@QAEXXZ")]
                    internal static extern void ClearLines(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getLinesCount@VerbatimBlockComment@AST@CppParser@CppSharp@@QAEIXZ")]
                    internal static extern uint GetLinesCount(global::System.IntPtr __instance);
                }

                internal static new global::CppSharp.Parser.AST.VerbatimBlockComment __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.VerbatimBlockComment(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.VerbatimBlockComment __CreateInstance(global::CppSharp.Parser.AST.VerbatimBlockComment.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.VerbatimBlockComment(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.VerbatimBlockComment.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.VerbatimBlockComment.__Internal));
                    global::CppSharp.Parser.AST.VerbatimBlockComment.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private VerbatimBlockComment(global::CppSharp.Parser.AST.VerbatimBlockComment.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected VerbatimBlockComment(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public VerbatimBlockComment()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.VerbatimBlockComment.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public VerbatimBlockComment(global::CppSharp.Parser.AST.VerbatimBlockComment _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.VerbatimBlockComment.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Comment __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor(__Instance, 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.VerbatimBlockLineComment GetLines(uint i)
                {
                    var __ret = __Internal.GetLines(__Instance, i);
                    global::CppSharp.Parser.AST.VerbatimBlockLineComment __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.VerbatimBlockLineComment.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::CppSharp.Parser.AST.VerbatimBlockLineComment) global::CppSharp.Parser.AST.VerbatimBlockLineComment.NativeToManagedMap[__ret];
                    else __result0 = global::CppSharp.Parser.AST.VerbatimBlockLineComment.__CreateInstance(__ret);
                    return __result0;
                }

                public void AddLines(global::CppSharp.Parser.AST.VerbatimBlockLineComment s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var ____arg0 = s.__Instance;
                    var __arg0 = new global::System.IntPtr(&____arg0);
                    __Internal.AddLines(__Instance, __arg0);
                }

                public void ClearLines()
                {
                    __Internal.ClearLines(__Instance);
                }

                public uint LinesCount
                {
                    get
                    {
                        var __ret = __Internal.GetLinesCount(__Instance);
                        return __ret;
                    }
                }
            }

            public unsafe partial class VerbatimLineComment : global::CppSharp.Parser.AST.BlockCommandComment, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 48)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.CommentKind kind;

                    [FieldOffset(4)]
                    internal uint commandId;

                    [FieldOffset(8)]
                    internal global::System.IntPtr paragraphComment;

                    [FieldOffset(12)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector____N_CppSharp_N_CppParser_N_AST_S_BlockCommandComment_S_Argument___N_std_S_allocator__S0_ Arguments;

                    [FieldOffset(24)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C text;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0VerbatimLineComment@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0VerbatimLineComment@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??1VerbatimLineComment@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern void dtor(global::System.IntPtr __instance, int delete);
                }

                internal static new global::CppSharp.Parser.AST.VerbatimLineComment __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.VerbatimLineComment(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.VerbatimLineComment __CreateInstance(global::CppSharp.Parser.AST.VerbatimLineComment.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.VerbatimLineComment(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.VerbatimLineComment.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.VerbatimLineComment.__Internal));
                    global::CppSharp.Parser.AST.VerbatimLineComment.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private VerbatimLineComment(global::CppSharp.Parser.AST.VerbatimLineComment.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected VerbatimLineComment(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public VerbatimLineComment()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.VerbatimLineComment.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public VerbatimLineComment(global::CppSharp.Parser.AST.VerbatimLineComment _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.VerbatimLineComment.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Comment __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor(__Instance, 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public string Text
                {
                    get
                    {
                        var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.VerbatimLineComment.__Internal*) __Instance)->text));
                        return global::Std.BasicStringExtensions.Data(__basicStringRet0);
                    }

                    set
                    {
                        global::Std.BasicStringExtensions.__Internal.Assign(new global::System.IntPtr(&((global::CppSharp.Parser.AST.VerbatimLineComment.__Internal*)__Instance)->text), value);
                    }
                }
            }

            public unsafe partial class InlineCommandComment : global::CppSharp.Parser.AST.InlineContentComment, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 28)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.CommentKind kind;

                    [FieldOffset(4)]
                    internal byte hasTrailingNewline;

                    [FieldOffset(8)]
                    internal uint commandId;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.AST.InlineCommandComment.RenderKind commentRenderKind;

                    [FieldOffset(16)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector____N_CppSharp_N_CppParser_N_AST_S_InlineCommandComment_S_Argument___N_std_S_allocator__S0_ Arguments;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0InlineCommandComment@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0InlineCommandComment@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??1InlineCommandComment@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern void dtor(global::System.IntPtr __instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getArguments@InlineCommandComment@AST@CppParser@CppSharp@@QAE?AVArgument@1234@I@Z")]
                    internal static extern void GetArguments(global::System.IntPtr __instance, global::System.IntPtr @return, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?addArguments@InlineCommandComment@AST@CppParser@CppSharp@@QAEXAAVArgument@1234@@Z")]
                    internal static extern void AddArguments(global::System.IntPtr __instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?clearArguments@InlineCommandComment@AST@CppParser@CppSharp@@QAEXXZ")]
                    internal static extern void ClearArguments(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getArgumentsCount@InlineCommandComment@AST@CppParser@CppSharp@@QAEIXZ")]
                    internal static extern uint GetArgumentsCount(global::System.IntPtr __instance);
                }

                public enum RenderKind
                {
                    RenderNormal = 0,
                    RenderBold = 1,
                    RenderMonospaced = 2,
                    RenderEmphasized = 3,
                    RenderAnchor = 4
                }

                public unsafe partial class Argument : IDisposable
                {
                    [StructLayout(LayoutKind.Explicit, Size = 24)]
                    public partial struct __Internal
                    {
                        [FieldOffset(0)]
                        internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C text;

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                            EntryPoint="??0Argument@InlineCommandComment@AST@CppParser@CppSharp@@QAE@XZ")]
                        internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                            EntryPoint="??0Argument@InlineCommandComment@AST@CppParser@CppSharp@@QAE@ABV01234@@Z")]
                        internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                            EntryPoint="??1Argument@InlineCommandComment@AST@CppParser@CppSharp@@QAE@XZ")]
                        internal static extern void dtor(global::System.IntPtr __instance, int delete);
                    }

                    public global::System.IntPtr __Instance { get; protected set; }

                    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.InlineCommandComment.Argument> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.InlineCommandComment.Argument>();
                    protected internal void*[] __OriginalVTables;

                    protected bool __ownsNativeInstance;

                    internal static global::CppSharp.Parser.AST.InlineCommandComment.Argument __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                    {
                        return new global::CppSharp.Parser.AST.InlineCommandComment.Argument(native.ToPointer(), skipVTables);
                    }

                    internal static global::CppSharp.Parser.AST.InlineCommandComment.Argument __CreateInstance(global::CppSharp.Parser.AST.InlineCommandComment.Argument.__Internal native, bool skipVTables = false)
                    {
                        return new global::CppSharp.Parser.AST.InlineCommandComment.Argument(native, skipVTables);
                    }

                    private static void* __CopyValue(global::CppSharp.Parser.AST.InlineCommandComment.Argument.__Internal native)
                    {
                        var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.InlineCommandComment.Argument.__Internal));
                        global::CppSharp.Parser.AST.InlineCommandComment.Argument.__Internal.cctor(ret, new global::System.IntPtr(&native));
                        return ret.ToPointer();
                    }

                    private Argument(global::CppSharp.Parser.AST.InlineCommandComment.Argument.__Internal native, bool skipVTables = false)
                        : this(__CopyValue(native), skipVTables)
                    {
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                    }

                    protected Argument(void* native, bool skipVTables = false)
                    {
                        if (native == null)
                            return;
                        __Instance = new global::System.IntPtr(native);
                    }

                    public Argument()
                    {
                        __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.InlineCommandComment.Argument.__Internal));
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                        __Internal.ctor(__Instance);
                    }

                    public Argument(global::CppSharp.Parser.AST.InlineCommandComment.Argument _0)
                    {
                        __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.InlineCommandComment.Argument.__Internal));
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                        if (ReferenceEquals(_0, null))
                            throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                        var __arg0 = _0.__Instance;
                        __Internal.cctor(__Instance, __arg0);
                    }

                    public void Dispose()
                    {
                        Dispose(disposing: true);
                    }

                    public virtual void Dispose(bool disposing)
                    {
                        if (__Instance == IntPtr.Zero)
                            return;
                        global::CppSharp.Parser.AST.InlineCommandComment.Argument __dummy;
                        NativeToManagedMap.TryRemove(__Instance, out __dummy);
                        if (disposing)
                            __Internal.dtor(__Instance, 0);
                        if (__ownsNativeInstance)
                            Marshal.FreeHGlobal(__Instance);
                        __Instance = IntPtr.Zero;
                    }

                    public string Text
                    {
                        get
                        {
                            var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.InlineCommandComment.Argument.__Internal*) __Instance)->text));
                            return global::Std.BasicStringExtensions.Data(__basicStringRet0);
                        }

                        set
                        {
                            global::Std.BasicStringExtensions.__Internal.Assign(new global::System.IntPtr(&((global::CppSharp.Parser.AST.InlineCommandComment.Argument.__Internal*)__Instance)->text), value);
                        }
                    }
                }

                internal static new global::CppSharp.Parser.AST.InlineCommandComment __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.InlineCommandComment(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.InlineCommandComment __CreateInstance(global::CppSharp.Parser.AST.InlineCommandComment.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.InlineCommandComment(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.InlineCommandComment.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.InlineCommandComment.__Internal));
                    global::CppSharp.Parser.AST.InlineCommandComment.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private InlineCommandComment(global::CppSharp.Parser.AST.InlineCommandComment.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected InlineCommandComment(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public InlineCommandComment()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.InlineCommandComment.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public InlineCommandComment(global::CppSharp.Parser.AST.InlineCommandComment _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.InlineCommandComment.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Comment __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor(__Instance, 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.InlineCommandComment.Argument GetArguments(uint i)
                {
                    var __ret = new global::CppSharp.Parser.AST.InlineCommandComment.Argument.__Internal();
                    __Internal.GetArguments(__Instance, new IntPtr(&__ret), i);
                    return global::CppSharp.Parser.AST.InlineCommandComment.Argument.__CreateInstance(__ret);
                }

                public void AddArguments(global::CppSharp.Parser.AST.InlineCommandComment.Argument s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    __Internal.AddArguments(__Instance, __arg0);
                }

                public void ClearArguments()
                {
                    __Internal.ClearArguments(__Instance);
                }

                public uint CommandId
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.InlineCommandComment.__Internal*) __Instance)->commandId;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.InlineCommandComment.__Internal*)__Instance)->commandId = value;
                    }
                }

                public global::CppSharp.Parser.AST.InlineCommandComment.RenderKind CommentRenderKind
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.InlineCommandComment.__Internal*) __Instance)->commentRenderKind;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.InlineCommandComment.__Internal*)__Instance)->commentRenderKind = value;
                    }
                }

                public uint ArgumentsCount
                {
                    get
                    {
                        var __ret = __Internal.GetArgumentsCount(__Instance);
                        return __ret;
                    }
                }
            }

            public unsafe partial class HTMLTagComment : global::CppSharp.Parser.AST.InlineContentComment, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 8)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.CommentKind kind;

                    [FieldOffset(4)]
                    internal byte hasTrailingNewline;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0HTMLTagComment@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0HTMLTagComment@AST@CppParser@CppSharp@@QAE@W4CommentKind@123@@Z")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance, global::CppSharp.Parser.AST.CommentKind Kind);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0HTMLTagComment@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.HTMLTagComment __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.HTMLTagComment(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.HTMLTagComment __CreateInstance(global::CppSharp.Parser.AST.HTMLTagComment.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.HTMLTagComment(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.HTMLTagComment.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.HTMLTagComment.__Internal));
                    *(global::CppSharp.Parser.AST.HTMLTagComment.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private HTMLTagComment(global::CppSharp.Parser.AST.HTMLTagComment.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected HTMLTagComment(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public HTMLTagComment()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.HTMLTagComment.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public HTMLTagComment(global::CppSharp.Parser.AST.CommentKind Kind)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.HTMLTagComment.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance, Kind);
                }

                public HTMLTagComment(global::CppSharp.Parser.AST.HTMLTagComment _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.HTMLTagComment.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.HTMLTagComment.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.HTMLTagComment.__Internal*) _0.__Instance);
                }

                public static implicit operator global::CppSharp.Parser.AST.HTMLTagComment(global::CppSharp.Parser.AST.CommentKind Kind)
                {
                    return new global::CppSharp.Parser.AST.HTMLTagComment(Kind);
                }
            }

            public unsafe partial class HTMLStartTagComment : global::CppSharp.Parser.AST.HTMLTagComment, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 44)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.CommentKind kind;

                    [FieldOffset(4)]
                    internal byte hasTrailingNewline;

                    [FieldOffset(8)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C tagName;

                    [FieldOffset(32)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector____N_CppSharp_N_CppParser_N_AST_S_HTMLStartTagComment_S_Attribute___N_std_S_allocator__S0_ Attributes;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0HTMLStartTagComment@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0HTMLStartTagComment@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??1HTMLStartTagComment@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern void dtor(global::System.IntPtr __instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getAttributes@HTMLStartTagComment@AST@CppParser@CppSharp@@QAE?AVAttribute@1234@I@Z")]
                    internal static extern void GetAttributes(global::System.IntPtr __instance, global::System.IntPtr @return, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?addAttributes@HTMLStartTagComment@AST@CppParser@CppSharp@@QAEXAAVAttribute@1234@@Z")]
                    internal static extern void AddAttributes(global::System.IntPtr __instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?clearAttributes@HTMLStartTagComment@AST@CppParser@CppSharp@@QAEXXZ")]
                    internal static extern void ClearAttributes(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getAttributesCount@HTMLStartTagComment@AST@CppParser@CppSharp@@QAEIXZ")]
                    internal static extern uint GetAttributesCount(global::System.IntPtr __instance);
                }

                public unsafe partial class Attribute : IDisposable
                {
                    [StructLayout(LayoutKind.Explicit, Size = 48)]
                    public partial struct __Internal
                    {
                        [FieldOffset(0)]
                        internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C name;

                        [FieldOffset(24)]
                        internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C value;

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                            EntryPoint="??0Attribute@HTMLStartTagComment@AST@CppParser@CppSharp@@QAE@XZ")]
                        internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                            EntryPoint="??0Attribute@HTMLStartTagComment@AST@CppParser@CppSharp@@QAE@ABV01234@@Z")]
                        internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                            EntryPoint="??1Attribute@HTMLStartTagComment@AST@CppParser@CppSharp@@QAE@XZ")]
                        internal static extern void dtor(global::System.IntPtr __instance, int delete);
                    }

                    public global::System.IntPtr __Instance { get; protected set; }

                    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.HTMLStartTagComment.Attribute> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.HTMLStartTagComment.Attribute>();
                    protected internal void*[] __OriginalVTables;

                    protected bool __ownsNativeInstance;

                    internal static global::CppSharp.Parser.AST.HTMLStartTagComment.Attribute __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                    {
                        return new global::CppSharp.Parser.AST.HTMLStartTagComment.Attribute(native.ToPointer(), skipVTables);
                    }

                    internal static global::CppSharp.Parser.AST.HTMLStartTagComment.Attribute __CreateInstance(global::CppSharp.Parser.AST.HTMLStartTagComment.Attribute.__Internal native, bool skipVTables = false)
                    {
                        return new global::CppSharp.Parser.AST.HTMLStartTagComment.Attribute(native, skipVTables);
                    }

                    private static void* __CopyValue(global::CppSharp.Parser.AST.HTMLStartTagComment.Attribute.__Internal native)
                    {
                        var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.HTMLStartTagComment.Attribute.__Internal));
                        global::CppSharp.Parser.AST.HTMLStartTagComment.Attribute.__Internal.cctor(ret, new global::System.IntPtr(&native));
                        return ret.ToPointer();
                    }

                    private Attribute(global::CppSharp.Parser.AST.HTMLStartTagComment.Attribute.__Internal native, bool skipVTables = false)
                        : this(__CopyValue(native), skipVTables)
                    {
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                    }

                    protected Attribute(void* native, bool skipVTables = false)
                    {
                        if (native == null)
                            return;
                        __Instance = new global::System.IntPtr(native);
                    }

                    public Attribute()
                    {
                        __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.HTMLStartTagComment.Attribute.__Internal));
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                        __Internal.ctor(__Instance);
                    }

                    public Attribute(global::CppSharp.Parser.AST.HTMLStartTagComment.Attribute _0)
                    {
                        __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.HTMLStartTagComment.Attribute.__Internal));
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                        if (ReferenceEquals(_0, null))
                            throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                        var __arg0 = _0.__Instance;
                        __Internal.cctor(__Instance, __arg0);
                    }

                    public void Dispose()
                    {
                        Dispose(disposing: true);
                    }

                    public virtual void Dispose(bool disposing)
                    {
                        if (__Instance == IntPtr.Zero)
                            return;
                        global::CppSharp.Parser.AST.HTMLStartTagComment.Attribute __dummy;
                        NativeToManagedMap.TryRemove(__Instance, out __dummy);
                        if (disposing)
                            __Internal.dtor(__Instance, 0);
                        if (__ownsNativeInstance)
                            Marshal.FreeHGlobal(__Instance);
                        __Instance = IntPtr.Zero;
                    }

                    public string Name
                    {
                        get
                        {
                            var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.HTMLStartTagComment.Attribute.__Internal*) __Instance)->name));
                            return global::Std.BasicStringExtensions.Data(__basicStringRet0);
                        }

                        set
                        {
                            global::Std.BasicStringExtensions.__Internal.Assign(new global::System.IntPtr(&((global::CppSharp.Parser.AST.HTMLStartTagComment.Attribute.__Internal*)__Instance)->name), value);
                        }
                    }

                    public string Value
                    {
                        get
                        {
                            var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.HTMLStartTagComment.Attribute.__Internal*) __Instance)->value));
                            return global::Std.BasicStringExtensions.Data(__basicStringRet0);
                        }

                        set
                        {
                            global::Std.BasicStringExtensions.__Internal.Assign(new global::System.IntPtr(&((global::CppSharp.Parser.AST.HTMLStartTagComment.Attribute.__Internal*)__Instance)->value), value);
                        }
                    }
                }

                internal static new global::CppSharp.Parser.AST.HTMLStartTagComment __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.HTMLStartTagComment(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.HTMLStartTagComment __CreateInstance(global::CppSharp.Parser.AST.HTMLStartTagComment.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.HTMLStartTagComment(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.HTMLStartTagComment.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.HTMLStartTagComment.__Internal));
                    global::CppSharp.Parser.AST.HTMLStartTagComment.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private HTMLStartTagComment(global::CppSharp.Parser.AST.HTMLStartTagComment.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected HTMLStartTagComment(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public HTMLStartTagComment()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.HTMLStartTagComment.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public HTMLStartTagComment(global::CppSharp.Parser.AST.HTMLStartTagComment _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.HTMLStartTagComment.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Comment __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor(__Instance, 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.HTMLStartTagComment.Attribute GetAttributes(uint i)
                {
                    var __ret = new global::CppSharp.Parser.AST.HTMLStartTagComment.Attribute.__Internal();
                    __Internal.GetAttributes(__Instance, new IntPtr(&__ret), i);
                    return global::CppSharp.Parser.AST.HTMLStartTagComment.Attribute.__CreateInstance(__ret);
                }

                public void AddAttributes(global::CppSharp.Parser.AST.HTMLStartTagComment.Attribute s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    __Internal.AddAttributes(__Instance, __arg0);
                }

                public void ClearAttributes()
                {
                    __Internal.ClearAttributes(__Instance);
                }

                public string TagName
                {
                    get
                    {
                        var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.HTMLStartTagComment.__Internal*) __Instance)->tagName));
                        return global::Std.BasicStringExtensions.Data(__basicStringRet0);
                    }

                    set
                    {
                        global::Std.BasicStringExtensions.__Internal.Assign(new global::System.IntPtr(&((global::CppSharp.Parser.AST.HTMLStartTagComment.__Internal*)__Instance)->tagName), value);
                    }
                }

                public uint AttributesCount
                {
                    get
                    {
                        var __ret = __Internal.GetAttributesCount(__Instance);
                        return __ret;
                    }
                }
            }

            public unsafe partial class HTMLEndTagComment : global::CppSharp.Parser.AST.HTMLTagComment, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 32)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.CommentKind kind;

                    [FieldOffset(4)]
                    internal byte hasTrailingNewline;

                    [FieldOffset(8)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C tagName;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0HTMLEndTagComment@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0HTMLEndTagComment@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??1HTMLEndTagComment@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern void dtor(global::System.IntPtr __instance, int delete);
                }

                internal static new global::CppSharp.Parser.AST.HTMLEndTagComment __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.HTMLEndTagComment(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.HTMLEndTagComment __CreateInstance(global::CppSharp.Parser.AST.HTMLEndTagComment.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.HTMLEndTagComment(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.HTMLEndTagComment.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.HTMLEndTagComment.__Internal));
                    global::CppSharp.Parser.AST.HTMLEndTagComment.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private HTMLEndTagComment(global::CppSharp.Parser.AST.HTMLEndTagComment.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected HTMLEndTagComment(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public HTMLEndTagComment()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.HTMLEndTagComment.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public HTMLEndTagComment(global::CppSharp.Parser.AST.HTMLEndTagComment _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.HTMLEndTagComment.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Comment __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor(__Instance, 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public string TagName
                {
                    get
                    {
                        var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.HTMLEndTagComment.__Internal*) __Instance)->tagName));
                        return global::Std.BasicStringExtensions.Data(__basicStringRet0);
                    }

                    set
                    {
                        global::Std.BasicStringExtensions.__Internal.Assign(new global::System.IntPtr(&((global::CppSharp.Parser.AST.HTMLEndTagComment.__Internal*)__Instance)->tagName), value);
                    }
                }
            }

            public unsafe partial class TextComment : global::CppSharp.Parser.AST.InlineContentComment, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 32)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.CommentKind kind;

                    [FieldOffset(4)]
                    internal byte hasTrailingNewline;

                    [FieldOffset(8)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C text;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0TextComment@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0TextComment@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??1TextComment@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern void dtor(global::System.IntPtr __instance, int delete);
                }

                internal static new global::CppSharp.Parser.AST.TextComment __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.TextComment(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.TextComment __CreateInstance(global::CppSharp.Parser.AST.TextComment.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.TextComment(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.TextComment.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TextComment.__Internal));
                    global::CppSharp.Parser.AST.TextComment.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private TextComment(global::CppSharp.Parser.AST.TextComment.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected TextComment(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public TextComment()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TextComment.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public TextComment(global::CppSharp.Parser.AST.TextComment _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TextComment.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Comment __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor(__Instance, 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public string Text
                {
                    get
                    {
                        var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.TextComment.__Internal*) __Instance)->text));
                        return global::Std.BasicStringExtensions.Data(__basicStringRet0);
                    }

                    set
                    {
                        global::Std.BasicStringExtensions.__Internal.Assign(new global::System.IntPtr(&((global::CppSharp.Parser.AST.TextComment.__Internal*)__Instance)->text), value);
                    }
                }
            }

            public unsafe partial class RawComment : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 56)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.RawCommentKind kind;

                    [FieldOffset(4)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C text;

                    [FieldOffset(28)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C briefText;

                    [FieldOffset(52)]
                    internal global::System.IntPtr fullCommentBlock;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0RawComment@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0RawComment@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??1RawComment@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern void dtor(global::System.IntPtr __instance, int delete);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.RawComment> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.RawComment>();
                protected internal void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                internal static global::CppSharp.Parser.AST.RawComment __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.RawComment(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.RawComment __CreateInstance(global::CppSharp.Parser.AST.RawComment.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.RawComment(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.RawComment.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.RawComment.__Internal));
                    global::CppSharp.Parser.AST.RawComment.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private RawComment(global::CppSharp.Parser.AST.RawComment.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected RawComment(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public RawComment()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.RawComment.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public RawComment(global::CppSharp.Parser.AST.RawComment _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.RawComment.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                public virtual void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.RawComment __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor(__Instance, 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.RawCommentKind Kind
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.RawComment.__Internal*) __Instance)->kind;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.RawComment.__Internal*)__Instance)->kind = value;
                    }
                }

                public string Text
                {
                    get
                    {
                        var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.RawComment.__Internal*) __Instance)->text));
                        return global::Std.BasicStringExtensions.Data(__basicStringRet0);
                    }

                    set
                    {
                        global::Std.BasicStringExtensions.__Internal.Assign(new global::System.IntPtr(&((global::CppSharp.Parser.AST.RawComment.__Internal*)__Instance)->text), value);
                    }
                }

                public string BriefText
                {
                    get
                    {
                        var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.RawComment.__Internal*) __Instance)->briefText));
                        return global::Std.BasicStringExtensions.Data(__basicStringRet0);
                    }

                    set
                    {
                        global::Std.BasicStringExtensions.__Internal.Assign(new global::System.IntPtr(&((global::CppSharp.Parser.AST.RawComment.__Internal*)__Instance)->briefText), value);
                    }
                }

                public global::CppSharp.Parser.AST.FullComment FullCommentBlock
                {
                    get
                    {
                        global::CppSharp.Parser.AST.FullComment __result0;
                        if (((global::CppSharp.Parser.AST.RawComment.__Internal*) __Instance)->fullCommentBlock == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.FullComment.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.RawComment.__Internal*) __Instance)->fullCommentBlock))
                            __result0 = (global::CppSharp.Parser.AST.FullComment) global::CppSharp.Parser.AST.FullComment.NativeToManagedMap[((global::CppSharp.Parser.AST.RawComment.__Internal*) __Instance)->fullCommentBlock];
                        else __result0 = global::CppSharp.Parser.AST.FullComment.__CreateInstance(((global::CppSharp.Parser.AST.RawComment.__Internal*) __Instance)->fullCommentBlock);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.RawComment.__Internal*)__Instance)->fullCommentBlock = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }
            }
        }
    }
}

namespace CppSharp
{
    namespace Parser
    {
        public unsafe partial struct SourceLocation
        {
            [StructLayout(LayoutKind.Explicit, Size = 4)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal uint ID;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="??0SourceLocation@CppParser@CppSharp@@QAE@XZ")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="??0SourceLocation@CppParser@CppSharp@@QAE@I@Z")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance, uint ID);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="??0SourceLocation@CppParser@CppSharp@@QAE@ABU012@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
            }

            private SourceLocation.__Internal __instance;
            internal SourceLocation.__Internal __Instance { get { return __instance; } }

            internal static global::CppSharp.Parser.SourceLocation __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::CppSharp.Parser.SourceLocation(native.ToPointer(), skipVTables);
            }

            internal static global::CppSharp.Parser.SourceLocation __CreateInstance(global::CppSharp.Parser.SourceLocation.__Internal native, bool skipVTables = false)
            {
                return new global::CppSharp.Parser.SourceLocation(native, skipVTables);
            }

            private SourceLocation(global::CppSharp.Parser.SourceLocation.__Internal native, bool skipVTables = false)
                : this()
            {
                __instance = native;
            }

            private SourceLocation(void* native, bool skipVTables = false) : this()
            {
                __instance = *(global::CppSharp.Parser.SourceLocation.__Internal*) native;
            }

            public SourceLocation(uint ID)
                : this()
            {
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.ctor(new global::System.IntPtr(__instancePtr), ID);
                }
            }

            public SourceLocation(global::CppSharp.Parser.SourceLocation _0)
                : this()
            {
                var ____arg0 = _0.__Instance;
                var __arg0 = new global::System.IntPtr(&____arg0);
                fixed (__Internal* __instancePtr = &__instance)
                {
                    __Internal.cctor(new global::System.IntPtr(__instancePtr), __arg0);
                }
            }

            public static implicit operator global::CppSharp.Parser.SourceLocation(uint ID)
            {
                return new global::CppSharp.Parser.SourceLocation(ID);
            }

            public uint ID
            {
                get
                {
                    return __instance.ID;
                }

                set
                {
                    __instance.ID = value;
                }
            }
        }

        public unsafe partial class SourceRange : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 8)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                [FieldOffset(4)]
                internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="??0SourceRange@CppParser@CppSharp@@QAE@ABU012@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="??0SourceRange@CppParser@CppSharp@@QAE@XZ")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);
            }

            public global::System.IntPtr __Instance { get; protected set; }

            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.SourceRange> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.SourceRange>();
            protected internal void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::CppSharp.Parser.SourceRange __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::CppSharp.Parser.SourceRange(native.ToPointer(), skipVTables);
            }

            internal static global::CppSharp.Parser.SourceRange __CreateInstance(global::CppSharp.Parser.SourceRange.__Internal native, bool skipVTables = false)
            {
                return new global::CppSharp.Parser.SourceRange(native, skipVTables);
            }

            private static void* __CopyValue(global::CppSharp.Parser.SourceRange.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.SourceRange.__Internal));
                *(global::CppSharp.Parser.SourceRange.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private SourceRange(global::CppSharp.Parser.SourceRange.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected SourceRange(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public SourceRange(global::CppSharp.Parser.SourceRange _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.SourceRange.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::CppSharp.Parser.SourceRange.__Internal*) __Instance) = *((global::CppSharp.Parser.SourceRange.__Internal*) _0.__Instance);
            }

            public SourceRange()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.SourceRange.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::CppSharp.Parser.SourceRange __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public global::CppSharp.Parser.SourceLocation BeginLoc
            {
                get
                {
                    return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.SourceRange.__Internal*) __Instance)->beginLoc);
                }

                set
                {
                    ((global::CppSharp.Parser.SourceRange.__Internal*)__Instance)->beginLoc = value.__Instance;
                }
            }

            public global::CppSharp.Parser.SourceLocation EndLoc
            {
                get
                {
                    return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.SourceRange.__Internal*) __Instance)->endLoc);
                }

                set
                {
                    ((global::CppSharp.Parser.SourceRange.__Internal*)__Instance)->endLoc = value.__Instance;
                }
            }
        }
    }
}

namespace CppSharp
{
    namespace Parser
    {
        namespace AST
        {
            public enum TypeKind
            {
                Tag = 0,
                Array = 1,
                Function = 2,
                Pointer = 3,
                MemberPointer = 4,
                Typedef = 5,
                Attributed = 6,
                Decayed = 7,
                TemplateSpecialization = 8,
                DependentTemplateSpecialization = 9,
                TemplateParameter = 10,
                TemplateParameterSubstitution = 11,
                InjectedClassName = 12,
                DependentName = 13,
                PackExpansion = 14,
                Builtin = 15,
                UnaryTransform = 16,
                UnresolvedUsing = 17,
                Vector = 18
            }

            public enum CallingConvention
            {
                Default = 0,
                C = 1,
                StdCall = 2,
                ThisCall = 3,
                FastCall = 4,
                Unknown = 5
            }

            public enum PrimitiveType
            {
                Null = 0,
                Void = 1,
                Bool = 2,
                WideChar = 3,
                Char = 4,
                SChar = 5,
                UChar = 6,
                Char16 = 7,
                Char32 = 8,
                Short = 9,
                UShort = 10,
                Int = 11,
                UInt = 12,
                Long = 13,
                ULong = 14,
                LongLong = 15,
                ULongLong = 16,
                Int128 = 17,
                UInt128 = 18,
                Half = 19,
                Float = 20,
                Double = 21,
                LongDouble = 22,
                Float128 = 23,
                IntPtr = 24
            }

            public enum ExceptionSpecType
            {
                None = 0,
                DynamicNone = 1,
                Dynamic = 2,
                MSAny = 3,
                BasicNoexcept = 4,
                DependentNoexcept = 5,
                NoexceptFalse = 6,
                NoexceptTrue = 7,
                Unevaluated = 8,
                Uninstantiated = 9,
                Unparsed = 10
            }

            public unsafe partial class Type : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 8)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.TypeKind kind;

                    [FieldOffset(4)]
                    internal byte isDependent;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0Type@AST@CppParser@CppSharp@@QAE@W4TypeKind@123@@Z")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance, global::CppSharp.Parser.AST.TypeKind kind);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0Type@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.Type> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.Type>();
                protected internal void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                internal static global::CppSharp.Parser.AST.Type __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.Type(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.Type __CreateInstance(global::CppSharp.Parser.AST.Type.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.Type(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.Type.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Type.__Internal));
                    global::CppSharp.Parser.AST.Type.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private Type(global::CppSharp.Parser.AST.Type.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected Type(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public Type(global::CppSharp.Parser.AST.TypeKind kind)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Type.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance, kind);
                }

                public Type(global::CppSharp.Parser.AST.Type _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Type.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                public virtual void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Type __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public static implicit operator global::CppSharp.Parser.AST.Type(global::CppSharp.Parser.AST.TypeKind kind)
                {
                    return new global::CppSharp.Parser.AST.Type(kind);
                }

                public global::CppSharp.Parser.AST.TypeKind Kind
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Type.__Internal*) __Instance)->kind;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Type.__Internal*)__Instance)->kind = value;
                    }
                }

                public bool IsDependent
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Type.__Internal*) __Instance)->isDependent != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Type.__Internal*)__Instance)->isDependent = (byte) (value ? 1 : 0);
                    }
                }
            }

            public unsafe partial class TypeQualifiers : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 3)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal byte isConst;

                    [FieldOffset(1)]
                    internal byte isVolatile;

                    [FieldOffset(2)]
                    internal byte isRestrict;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0TypeQualifiers@AST@CppParser@CppSharp@@QAE@ABU0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.TypeQualifiers> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.TypeQualifiers>();
                protected internal void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                internal static global::CppSharp.Parser.AST.TypeQualifiers __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.TypeQualifiers(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.TypeQualifiers __CreateInstance(global::CppSharp.Parser.AST.TypeQualifiers.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.TypeQualifiers(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.TypeQualifiers.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TypeQualifiers.__Internal));
                    *(global::CppSharp.Parser.AST.TypeQualifiers.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private TypeQualifiers(global::CppSharp.Parser.AST.TypeQualifiers.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected TypeQualifiers(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public TypeQualifiers(global::CppSharp.Parser.AST.TypeQualifiers _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TypeQualifiers.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.TypeQualifiers.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.TypeQualifiers.__Internal*) _0.__Instance);
                }

                public TypeQualifiers()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TypeQualifiers.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                public virtual void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.TypeQualifiers __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public bool IsConst
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.TypeQualifiers.__Internal*) __Instance)->isConst != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.TypeQualifiers.__Internal*)__Instance)->isConst = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsVolatile
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.TypeQualifiers.__Internal*) __Instance)->isVolatile != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.TypeQualifiers.__Internal*)__Instance)->isVolatile = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsRestrict
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.TypeQualifiers.__Internal*) __Instance)->isRestrict != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.TypeQualifiers.__Internal*)__Instance)->isRestrict = (byte) (value ? 1 : 0);
                    }
                }
            }

            public unsafe partial class QualifiedType : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 8)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::System.IntPtr type;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.AST.TypeQualifiers.__Internal qualifiers;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0QualifiedType@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0QualifiedType@AST@CppParser@CppSharp@@QAE@ABU0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.QualifiedType> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.QualifiedType>();
                protected internal void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                internal static global::CppSharp.Parser.AST.QualifiedType __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.QualifiedType(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.QualifiedType __CreateInstance(global::CppSharp.Parser.AST.QualifiedType.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.QualifiedType(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.QualifiedType.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.QualifiedType.__Internal));
                    *(global::CppSharp.Parser.AST.QualifiedType.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private QualifiedType(global::CppSharp.Parser.AST.QualifiedType.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected QualifiedType(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public QualifiedType()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.QualifiedType.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public QualifiedType(global::CppSharp.Parser.AST.QualifiedType _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.QualifiedType.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.QualifiedType.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.QualifiedType.__Internal*) _0.__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                public virtual void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.QualifiedType __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.Type Type
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Type __result0;
                        if (((global::CppSharp.Parser.AST.QualifiedType.__Internal*) __Instance)->type == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Type.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.QualifiedType.__Internal*) __Instance)->type))
                            __result0 = (global::CppSharp.Parser.AST.Type) global::CppSharp.Parser.AST.Type.NativeToManagedMap[((global::CppSharp.Parser.AST.QualifiedType.__Internal*) __Instance)->type];
                        else __result0 = global::CppSharp.Parser.AST.Type.__CreateInstance(((global::CppSharp.Parser.AST.QualifiedType.__Internal*) __Instance)->type);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.QualifiedType.__Internal*)__Instance)->type = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.TypeQualifiers Qualifiers
                {
                    get
                    {
                        return global::CppSharp.Parser.AST.TypeQualifiers.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.QualifiedType.__Internal*) __Instance)->qualifiers));
                    }

                    set
                    {
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                        ((global::CppSharp.Parser.AST.QualifiedType.__Internal*)__Instance)->qualifiers = *(global::CppSharp.Parser.AST.TypeQualifiers.__Internal*) value.__Instance;
                    }
                }
            }

            public unsafe partial class TagType : global::CppSharp.Parser.AST.Type, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 12)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.TypeKind kind;

                    [FieldOffset(4)]
                    internal byte isDependent;

                    [FieldOffset(8)]
                    internal global::System.IntPtr declaration;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0TagType@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0TagType@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.TagType __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.TagType(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.TagType __CreateInstance(global::CppSharp.Parser.AST.TagType.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.TagType(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.TagType.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TagType.__Internal));
                    global::CppSharp.Parser.AST.TagType.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private TagType(global::CppSharp.Parser.AST.TagType.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected TagType(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public TagType()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TagType.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public TagType(global::CppSharp.Parser.AST.TagType _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TagType.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public global::CppSharp.Parser.AST.Declaration Declaration
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Declaration __result0;
                        if (((global::CppSharp.Parser.AST.TagType.__Internal*) __Instance)->declaration == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Declaration.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.TagType.__Internal*) __Instance)->declaration))
                            __result0 = (global::CppSharp.Parser.AST.Declaration) global::CppSharp.Parser.AST.Declaration.NativeToManagedMap[((global::CppSharp.Parser.AST.TagType.__Internal*) __Instance)->declaration];
                        else __result0 = global::CppSharp.Parser.AST.Declaration.__CreateInstance(((global::CppSharp.Parser.AST.TagType.__Internal*) __Instance)->declaration);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.TagType.__Internal*)__Instance)->declaration = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }
            }

            public unsafe partial class ArrayType : global::CppSharp.Parser.AST.Type, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 28)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.TypeKind kind;

                    [FieldOffset(4)]
                    internal byte isDependent;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal qualifiedType;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.AST.ArrayType.ArraySize sizeType;

                    [FieldOffset(20)]
                    internal int size;

                    [FieldOffset(24)]
                    internal int elementSize;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0ArrayType@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0ArrayType@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                public enum ArraySize
                {
                    Constant = 0,
                    Variable = 1,
                    Dependent = 2,
                    Incomplete = 3
                }

                internal static new global::CppSharp.Parser.AST.ArrayType __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.ArrayType(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.ArrayType __CreateInstance(global::CppSharp.Parser.AST.ArrayType.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.ArrayType(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.ArrayType.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ArrayType.__Internal));
                    global::CppSharp.Parser.AST.ArrayType.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private ArrayType(global::CppSharp.Parser.AST.ArrayType.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected ArrayType(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public ArrayType()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ArrayType.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public ArrayType(global::CppSharp.Parser.AST.ArrayType _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ArrayType.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public global::CppSharp.Parser.AST.QualifiedType QualifiedType
                {
                    get
                    {
                        return global::CppSharp.Parser.AST.QualifiedType.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.ArrayType.__Internal*) __Instance)->qualifiedType));
                    }

                    set
                    {
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                        ((global::CppSharp.Parser.AST.ArrayType.__Internal*)__Instance)->qualifiedType = *(global::CppSharp.Parser.AST.QualifiedType.__Internal*) value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.ArrayType.ArraySize SizeType
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.ArrayType.__Internal*) __Instance)->sizeType;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.ArrayType.__Internal*)__Instance)->sizeType = value;
                    }
                }

                public int Size
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.ArrayType.__Internal*) __Instance)->size;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.ArrayType.__Internal*)__Instance)->size = value;
                    }
                }

                public int ElementSize
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.ArrayType.__Internal*) __Instance)->elementSize;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.ArrayType.__Internal*)__Instance)->elementSize = value;
                    }
                }
            }

            public unsafe partial class FunctionType : global::CppSharp.Parser.AST.Type, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 36)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.TypeKind kind;

                    [FieldOffset(4)]
                    internal byte isDependent;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal returnType;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.AST.CallingConvention callingConvention;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.ExceptionSpecType exceptionSpecType;

                    [FieldOffset(24)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Parameter___N_std_S_allocator__S0_ Parameters;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0FunctionType@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0FunctionType@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??1FunctionType@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern void dtor(global::System.IntPtr __instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getParameters@FunctionType@AST@CppParser@CppSharp@@QAEPAVParameter@234@I@Z")]
                    internal static extern global::System.IntPtr GetParameters(global::System.IntPtr __instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?addParameters@FunctionType@AST@CppParser@CppSharp@@QAEXAAPAVParameter@234@@Z")]
                    internal static extern void AddParameters(global::System.IntPtr __instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?clearParameters@FunctionType@AST@CppParser@CppSharp@@QAEXXZ")]
                    internal static extern void ClearParameters(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getParametersCount@FunctionType@AST@CppParser@CppSharp@@QAEIXZ")]
                    internal static extern uint GetParametersCount(global::System.IntPtr __instance);
                }

                internal static new global::CppSharp.Parser.AST.FunctionType __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.FunctionType(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.FunctionType __CreateInstance(global::CppSharp.Parser.AST.FunctionType.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.FunctionType(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.FunctionType.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.FunctionType.__Internal));
                    global::CppSharp.Parser.AST.FunctionType.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private FunctionType(global::CppSharp.Parser.AST.FunctionType.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected FunctionType(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public FunctionType()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.FunctionType.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public FunctionType(global::CppSharp.Parser.AST.FunctionType _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.FunctionType.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Type __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor(__Instance, 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.Parameter GetParameters(uint i)
                {
                    var __ret = __Internal.GetParameters(__Instance, i);
                    global::CppSharp.Parser.AST.Parameter __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.Parameter.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::CppSharp.Parser.AST.Parameter) global::CppSharp.Parser.AST.Parameter.NativeToManagedMap[__ret];
                    else __result0 = global::CppSharp.Parser.AST.Parameter.__CreateInstance(__ret);
                    return __result0;
                }

                public void AddParameters(global::CppSharp.Parser.AST.Parameter s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var ____arg0 = s.__Instance;
                    var __arg0 = new global::System.IntPtr(&____arg0);
                    __Internal.AddParameters(__Instance, __arg0);
                }

                public void ClearParameters()
                {
                    __Internal.ClearParameters(__Instance);
                }

                public global::CppSharp.Parser.AST.QualifiedType ReturnType
                {
                    get
                    {
                        return global::CppSharp.Parser.AST.QualifiedType.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.FunctionType.__Internal*) __Instance)->returnType));
                    }

                    set
                    {
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                        ((global::CppSharp.Parser.AST.FunctionType.__Internal*)__Instance)->returnType = *(global::CppSharp.Parser.AST.QualifiedType.__Internal*) value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.CallingConvention CallingConvention
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.FunctionType.__Internal*) __Instance)->callingConvention;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.FunctionType.__Internal*)__Instance)->callingConvention = value;
                    }
                }

                public global::CppSharp.Parser.AST.ExceptionSpecType ExceptionSpecType
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.FunctionType.__Internal*) __Instance)->exceptionSpecType;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.FunctionType.__Internal*)__Instance)->exceptionSpecType = value;
                    }
                }

                public uint ParametersCount
                {
                    get
                    {
                        var __ret = __Internal.GetParametersCount(__Instance);
                        return __ret;
                    }
                }
            }

            public unsafe partial class PointerType : global::CppSharp.Parser.AST.Type, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 20)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.TypeKind kind;

                    [FieldOffset(4)]
                    internal byte isDependent;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal qualifiedPointee;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.AST.PointerType.TypeModifier modifier;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0PointerType@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0PointerType@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                public enum TypeModifier
                {
                    Value = 0,
                    Pointer = 1,
                    LVReference = 2,
                    RVReference = 3
                }

                internal static new global::CppSharp.Parser.AST.PointerType __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.PointerType(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.PointerType __CreateInstance(global::CppSharp.Parser.AST.PointerType.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.PointerType(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.PointerType.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.PointerType.__Internal));
                    global::CppSharp.Parser.AST.PointerType.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private PointerType(global::CppSharp.Parser.AST.PointerType.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected PointerType(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public PointerType()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.PointerType.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public PointerType(global::CppSharp.Parser.AST.PointerType _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.PointerType.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public global::CppSharp.Parser.AST.QualifiedType QualifiedPointee
                {
                    get
                    {
                        return global::CppSharp.Parser.AST.QualifiedType.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.PointerType.__Internal*) __Instance)->qualifiedPointee));
                    }

                    set
                    {
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                        ((global::CppSharp.Parser.AST.PointerType.__Internal*)__Instance)->qualifiedPointee = *(global::CppSharp.Parser.AST.QualifiedType.__Internal*) value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.PointerType.TypeModifier Modifier
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.PointerType.__Internal*) __Instance)->modifier;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.PointerType.__Internal*)__Instance)->modifier = value;
                    }
                }
            }

            public unsafe partial class MemberPointerType : global::CppSharp.Parser.AST.Type, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 16)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.TypeKind kind;

                    [FieldOffset(4)]
                    internal byte isDependent;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal pointee;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0MemberPointerType@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0MemberPointerType@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.MemberPointerType __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.MemberPointerType(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.MemberPointerType __CreateInstance(global::CppSharp.Parser.AST.MemberPointerType.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.MemberPointerType(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.MemberPointerType.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.MemberPointerType.__Internal));
                    global::CppSharp.Parser.AST.MemberPointerType.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private MemberPointerType(global::CppSharp.Parser.AST.MemberPointerType.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected MemberPointerType(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public MemberPointerType()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.MemberPointerType.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public MemberPointerType(global::CppSharp.Parser.AST.MemberPointerType _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.MemberPointerType.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public global::CppSharp.Parser.AST.QualifiedType Pointee
                {
                    get
                    {
                        return global::CppSharp.Parser.AST.QualifiedType.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.MemberPointerType.__Internal*) __Instance)->pointee));
                    }

                    set
                    {
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                        ((global::CppSharp.Parser.AST.MemberPointerType.__Internal*)__Instance)->pointee = *(global::CppSharp.Parser.AST.QualifiedType.__Internal*) value.__Instance;
                    }
                }
            }

            public unsafe partial class TypedefType : global::CppSharp.Parser.AST.Type, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 12)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.TypeKind kind;

                    [FieldOffset(4)]
                    internal byte isDependent;

                    [FieldOffset(8)]
                    internal global::System.IntPtr declaration;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0TypedefType@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0TypedefType@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.TypedefType __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.TypedefType(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.TypedefType __CreateInstance(global::CppSharp.Parser.AST.TypedefType.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.TypedefType(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.TypedefType.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TypedefType.__Internal));
                    global::CppSharp.Parser.AST.TypedefType.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private TypedefType(global::CppSharp.Parser.AST.TypedefType.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected TypedefType(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public TypedefType()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TypedefType.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public TypedefType(global::CppSharp.Parser.AST.TypedefType _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TypedefType.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public global::CppSharp.Parser.AST.TypedefNameDecl Declaration
                {
                    get
                    {
                        global::CppSharp.Parser.AST.TypedefNameDecl __result0;
                        if (((global::CppSharp.Parser.AST.TypedefType.__Internal*) __Instance)->declaration == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.TypedefNameDecl.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.TypedefType.__Internal*) __Instance)->declaration))
                            __result0 = (global::CppSharp.Parser.AST.TypedefNameDecl) global::CppSharp.Parser.AST.TypedefNameDecl.NativeToManagedMap[((global::CppSharp.Parser.AST.TypedefType.__Internal*) __Instance)->declaration];
                        else __result0 = global::CppSharp.Parser.AST.TypedefNameDecl.__CreateInstance(((global::CppSharp.Parser.AST.TypedefType.__Internal*) __Instance)->declaration);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.TypedefType.__Internal*)__Instance)->declaration = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }
            }

            public unsafe partial class AttributedType : global::CppSharp.Parser.AST.Type, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 24)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.TypeKind kind;

                    [FieldOffset(4)]
                    internal byte isDependent;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal modified;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal equivalent;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0AttributedType@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0AttributedType@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.AttributedType __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.AttributedType(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.AttributedType __CreateInstance(global::CppSharp.Parser.AST.AttributedType.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.AttributedType(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.AttributedType.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.AttributedType.__Internal));
                    global::CppSharp.Parser.AST.AttributedType.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private AttributedType(global::CppSharp.Parser.AST.AttributedType.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected AttributedType(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public AttributedType()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.AttributedType.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public AttributedType(global::CppSharp.Parser.AST.AttributedType _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.AttributedType.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public global::CppSharp.Parser.AST.QualifiedType Modified
                {
                    get
                    {
                        return global::CppSharp.Parser.AST.QualifiedType.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.AttributedType.__Internal*) __Instance)->modified));
                    }

                    set
                    {
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                        ((global::CppSharp.Parser.AST.AttributedType.__Internal*)__Instance)->modified = *(global::CppSharp.Parser.AST.QualifiedType.__Internal*) value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.QualifiedType Equivalent
                {
                    get
                    {
                        return global::CppSharp.Parser.AST.QualifiedType.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.AttributedType.__Internal*) __Instance)->equivalent));
                    }

                    set
                    {
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                        ((global::CppSharp.Parser.AST.AttributedType.__Internal*)__Instance)->equivalent = *(global::CppSharp.Parser.AST.QualifiedType.__Internal*) value.__Instance;
                    }
                }
            }

            public unsafe partial class DecayedType : global::CppSharp.Parser.AST.Type, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 32)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.TypeKind kind;

                    [FieldOffset(4)]
                    internal byte isDependent;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal decayed;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal original;

                    [FieldOffset(24)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal pointee;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0DecayedType@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0DecayedType@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.DecayedType __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.DecayedType(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.DecayedType __CreateInstance(global::CppSharp.Parser.AST.DecayedType.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.DecayedType(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.DecayedType.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.DecayedType.__Internal));
                    global::CppSharp.Parser.AST.DecayedType.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private DecayedType(global::CppSharp.Parser.AST.DecayedType.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected DecayedType(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public DecayedType()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.DecayedType.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public DecayedType(global::CppSharp.Parser.AST.DecayedType _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.DecayedType.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public global::CppSharp.Parser.AST.QualifiedType Decayed
                {
                    get
                    {
                        return global::CppSharp.Parser.AST.QualifiedType.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.DecayedType.__Internal*) __Instance)->decayed));
                    }

                    set
                    {
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                        ((global::CppSharp.Parser.AST.DecayedType.__Internal*)__Instance)->decayed = *(global::CppSharp.Parser.AST.QualifiedType.__Internal*) value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.QualifiedType Original
                {
                    get
                    {
                        return global::CppSharp.Parser.AST.QualifiedType.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.DecayedType.__Internal*) __Instance)->original));
                    }

                    set
                    {
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                        ((global::CppSharp.Parser.AST.DecayedType.__Internal*)__Instance)->original = *(global::CppSharp.Parser.AST.QualifiedType.__Internal*) value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.QualifiedType Pointee
                {
                    get
                    {
                        return global::CppSharp.Parser.AST.QualifiedType.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.DecayedType.__Internal*) __Instance)->pointee));
                    }

                    set
                    {
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                        ((global::CppSharp.Parser.AST.DecayedType.__Internal*)__Instance)->pointee = *(global::CppSharp.Parser.AST.QualifiedType.__Internal*) value.__Instance;
                    }
                }
            }

            public unsafe partial class TemplateArgument : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 20)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.TemplateArgument.ArgumentKind kind;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(12)]
                    internal global::System.IntPtr declaration;

                    [FieldOffset(16)]
                    internal int integral;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0TemplateArgument@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0TemplateArgument@AST@CppParser@CppSharp@@QAE@ABU0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                public enum ArgumentKind
                {
                    Type = 0,
                    Declaration = 1,
                    NullPtr = 2,
                    Integral = 3,
                    Template = 4,
                    TemplateExpansion = 5,
                    Expression = 6,
                    Pack = 7
                }

                public global::System.IntPtr __Instance { get; protected set; }

                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.TemplateArgument> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.TemplateArgument>();
                protected internal void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                internal static global::CppSharp.Parser.AST.TemplateArgument __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.TemplateArgument(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.TemplateArgument __CreateInstance(global::CppSharp.Parser.AST.TemplateArgument.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.TemplateArgument(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.TemplateArgument.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TemplateArgument.__Internal));
                    *(global::CppSharp.Parser.AST.TemplateArgument.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private TemplateArgument(global::CppSharp.Parser.AST.TemplateArgument.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected TemplateArgument(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public TemplateArgument()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TemplateArgument.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public TemplateArgument(global::CppSharp.Parser.AST.TemplateArgument _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TemplateArgument.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.TemplateArgument.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.TemplateArgument.__Internal*) _0.__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                public virtual void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.TemplateArgument __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.TemplateArgument.ArgumentKind Kind
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.TemplateArgument.__Internal*) __Instance)->kind;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.TemplateArgument.__Internal*)__Instance)->kind = value;
                    }
                }

                public global::CppSharp.Parser.AST.QualifiedType Type
                {
                    get
                    {
                        return global::CppSharp.Parser.AST.QualifiedType.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.TemplateArgument.__Internal*) __Instance)->type));
                    }

                    set
                    {
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                        ((global::CppSharp.Parser.AST.TemplateArgument.__Internal*)__Instance)->type = *(global::CppSharp.Parser.AST.QualifiedType.__Internal*) value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Declaration Declaration
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Declaration __result0;
                        if (((global::CppSharp.Parser.AST.TemplateArgument.__Internal*) __Instance)->declaration == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Declaration.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.TemplateArgument.__Internal*) __Instance)->declaration))
                            __result0 = (global::CppSharp.Parser.AST.Declaration) global::CppSharp.Parser.AST.Declaration.NativeToManagedMap[((global::CppSharp.Parser.AST.TemplateArgument.__Internal*) __Instance)->declaration];
                        else __result0 = global::CppSharp.Parser.AST.Declaration.__CreateInstance(((global::CppSharp.Parser.AST.TemplateArgument.__Internal*) __Instance)->declaration);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.TemplateArgument.__Internal*)__Instance)->declaration = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public int Integral
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.TemplateArgument.__Internal*) __Instance)->integral;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.TemplateArgument.__Internal*)__Instance)->integral = value;
                    }
                }
            }

            public unsafe partial class TemplateSpecializationType : global::CppSharp.Parser.AST.Type, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 32)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.TypeKind kind;

                    [FieldOffset(4)]
                    internal byte isDependent;

                    [FieldOffset(8)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector____N_CppSharp_N_CppParser_N_AST_S_TemplateArgument___N_std_S_allocator__S0_ Arguments;

                    [FieldOffset(20)]
                    internal global::System.IntPtr _template;

                    [FieldOffset(24)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal desugared;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0TemplateSpecializationType@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0TemplateSpecializationType@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??1TemplateSpecializationType@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern void dtor(global::System.IntPtr __instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getArguments@TemplateSpecializationType@AST@CppParser@CppSharp@@QAE?AUTemplateArgument@234@I@Z")]
                    internal static extern void GetArguments(global::System.IntPtr __instance, global::System.IntPtr @return, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?addArguments@TemplateSpecializationType@AST@CppParser@CppSharp@@QAEXAAUTemplateArgument@234@@Z")]
                    internal static extern void AddArguments(global::System.IntPtr __instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?clearArguments@TemplateSpecializationType@AST@CppParser@CppSharp@@QAEXXZ")]
                    internal static extern void ClearArguments(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getArgumentsCount@TemplateSpecializationType@AST@CppParser@CppSharp@@QAEIXZ")]
                    internal static extern uint GetArgumentsCount(global::System.IntPtr __instance);
                }

                internal static new global::CppSharp.Parser.AST.TemplateSpecializationType __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.TemplateSpecializationType(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.TemplateSpecializationType __CreateInstance(global::CppSharp.Parser.AST.TemplateSpecializationType.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.TemplateSpecializationType(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.TemplateSpecializationType.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TemplateSpecializationType.__Internal));
                    global::CppSharp.Parser.AST.TemplateSpecializationType.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private TemplateSpecializationType(global::CppSharp.Parser.AST.TemplateSpecializationType.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected TemplateSpecializationType(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public TemplateSpecializationType()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TemplateSpecializationType.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public TemplateSpecializationType(global::CppSharp.Parser.AST.TemplateSpecializationType _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TemplateSpecializationType.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Type __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor(__Instance, 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.TemplateArgument GetArguments(uint i)
                {
                    var __ret = new global::CppSharp.Parser.AST.TemplateArgument.__Internal();
                    __Internal.GetArguments(__Instance, new IntPtr(&__ret), i);
                    return global::CppSharp.Parser.AST.TemplateArgument.__CreateInstance(__ret);
                }

                public void AddArguments(global::CppSharp.Parser.AST.TemplateArgument s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    __Internal.AddArguments(__Instance, __arg0);
                }

                public void ClearArguments()
                {
                    __Internal.ClearArguments(__Instance);
                }

                public global::CppSharp.Parser.AST.Template Template
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Template __result0;
                        if (((global::CppSharp.Parser.AST.TemplateSpecializationType.__Internal*) __Instance)->_template == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Template.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.TemplateSpecializationType.__Internal*) __Instance)->_template))
                            __result0 = (global::CppSharp.Parser.AST.Template) global::CppSharp.Parser.AST.Template.NativeToManagedMap[((global::CppSharp.Parser.AST.TemplateSpecializationType.__Internal*) __Instance)->_template];
                        else __result0 = global::CppSharp.Parser.AST.Template.__CreateInstance(((global::CppSharp.Parser.AST.TemplateSpecializationType.__Internal*) __Instance)->_template);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.TemplateSpecializationType.__Internal*)__Instance)->_template = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.QualifiedType Desugared
                {
                    get
                    {
                        return global::CppSharp.Parser.AST.QualifiedType.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.TemplateSpecializationType.__Internal*) __Instance)->desugared));
                    }

                    set
                    {
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                        ((global::CppSharp.Parser.AST.TemplateSpecializationType.__Internal*)__Instance)->desugared = *(global::CppSharp.Parser.AST.QualifiedType.__Internal*) value.__Instance;
                    }
                }

                public uint ArgumentsCount
                {
                    get
                    {
                        var __ret = __Internal.GetArgumentsCount(__Instance);
                        return __ret;
                    }
                }
            }

            public unsafe partial class DependentTemplateSpecializationType : global::CppSharp.Parser.AST.Type, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 28)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.TypeKind kind;

                    [FieldOffset(4)]
                    internal byte isDependent;

                    [FieldOffset(8)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector____N_CppSharp_N_CppParser_N_AST_S_TemplateArgument___N_std_S_allocator__S0_ Arguments;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal desugared;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0DependentTemplateSpecializationType@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0DependentTemplateSpecializationType@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??1DependentTemplateSpecializationType@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern void dtor(global::System.IntPtr __instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getArguments@DependentTemplateSpecializationType@AST@CppParser@CppSharp@@QAE?AUTemplateArgument@234@I@Z")]
                    internal static extern void GetArguments(global::System.IntPtr __instance, global::System.IntPtr @return, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?addArguments@DependentTemplateSpecializationType@AST@CppParser@CppSharp@@QAEXAAUTemplateArgument@234@@Z")]
                    internal static extern void AddArguments(global::System.IntPtr __instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?clearArguments@DependentTemplateSpecializationType@AST@CppParser@CppSharp@@QAEXXZ")]
                    internal static extern void ClearArguments(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getArgumentsCount@DependentTemplateSpecializationType@AST@CppParser@CppSharp@@QAEIXZ")]
                    internal static extern uint GetArgumentsCount(global::System.IntPtr __instance);
                }

                internal static new global::CppSharp.Parser.AST.DependentTemplateSpecializationType __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.DependentTemplateSpecializationType(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.DependentTemplateSpecializationType __CreateInstance(global::CppSharp.Parser.AST.DependentTemplateSpecializationType.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.DependentTemplateSpecializationType(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.DependentTemplateSpecializationType.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.DependentTemplateSpecializationType.__Internal));
                    global::CppSharp.Parser.AST.DependentTemplateSpecializationType.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private DependentTemplateSpecializationType(global::CppSharp.Parser.AST.DependentTemplateSpecializationType.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected DependentTemplateSpecializationType(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public DependentTemplateSpecializationType()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.DependentTemplateSpecializationType.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public DependentTemplateSpecializationType(global::CppSharp.Parser.AST.DependentTemplateSpecializationType _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.DependentTemplateSpecializationType.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Type __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor(__Instance, 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.TemplateArgument GetArguments(uint i)
                {
                    var __ret = new global::CppSharp.Parser.AST.TemplateArgument.__Internal();
                    __Internal.GetArguments(__Instance, new IntPtr(&__ret), i);
                    return global::CppSharp.Parser.AST.TemplateArgument.__CreateInstance(__ret);
                }

                public void AddArguments(global::CppSharp.Parser.AST.TemplateArgument s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    __Internal.AddArguments(__Instance, __arg0);
                }

                public void ClearArguments()
                {
                    __Internal.ClearArguments(__Instance);
                }

                public global::CppSharp.Parser.AST.QualifiedType Desugared
                {
                    get
                    {
                        return global::CppSharp.Parser.AST.QualifiedType.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.DependentTemplateSpecializationType.__Internal*) __Instance)->desugared));
                    }

                    set
                    {
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                        ((global::CppSharp.Parser.AST.DependentTemplateSpecializationType.__Internal*)__Instance)->desugared = *(global::CppSharp.Parser.AST.QualifiedType.__Internal*) value.__Instance;
                    }
                }

                public uint ArgumentsCount
                {
                    get
                    {
                        var __ret = __Internal.GetArgumentsCount(__Instance);
                        return __ret;
                    }
                }
            }

            public unsafe partial class TemplateParameterType : global::CppSharp.Parser.AST.Type, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 24)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.TypeKind kind;

                    [FieldOffset(4)]
                    internal byte isDependent;

                    [FieldOffset(8)]
                    internal global::System.IntPtr parameter;

                    [FieldOffset(12)]
                    internal uint depth;

                    [FieldOffset(16)]
                    internal uint index;

                    [FieldOffset(20)]
                    internal byte isParameterPack;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0TemplateParameterType@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0TemplateParameterType@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??1TemplateParameterType@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern void dtor(global::System.IntPtr __instance, int delete);
                }

                internal static new global::CppSharp.Parser.AST.TemplateParameterType __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.TemplateParameterType(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.TemplateParameterType __CreateInstance(global::CppSharp.Parser.AST.TemplateParameterType.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.TemplateParameterType(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.TemplateParameterType.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TemplateParameterType.__Internal));
                    global::CppSharp.Parser.AST.TemplateParameterType.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private TemplateParameterType(global::CppSharp.Parser.AST.TemplateParameterType.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected TemplateParameterType(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public TemplateParameterType()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TemplateParameterType.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public TemplateParameterType(global::CppSharp.Parser.AST.TemplateParameterType _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TemplateParameterType.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Type __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor(__Instance, 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.TypeTemplateParameter Parameter
                {
                    get
                    {
                        global::CppSharp.Parser.AST.TypeTemplateParameter __result0;
                        if (((global::CppSharp.Parser.AST.TemplateParameterType.__Internal*) __Instance)->parameter == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.TypeTemplateParameter.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.TemplateParameterType.__Internal*) __Instance)->parameter))
                            __result0 = (global::CppSharp.Parser.AST.TypeTemplateParameter) global::CppSharp.Parser.AST.TypeTemplateParameter.NativeToManagedMap[((global::CppSharp.Parser.AST.TemplateParameterType.__Internal*) __Instance)->parameter];
                        else __result0 = global::CppSharp.Parser.AST.TypeTemplateParameter.__CreateInstance(((global::CppSharp.Parser.AST.TemplateParameterType.__Internal*) __Instance)->parameter);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.TemplateParameterType.__Internal*)__Instance)->parameter = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public uint Depth
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.TemplateParameterType.__Internal*) __Instance)->depth;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.TemplateParameterType.__Internal*)__Instance)->depth = value;
                    }
                }

                public uint Index
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.TemplateParameterType.__Internal*) __Instance)->index;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.TemplateParameterType.__Internal*)__Instance)->index = value;
                    }
                }

                public bool IsParameterPack
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.TemplateParameterType.__Internal*) __Instance)->isParameterPack != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.TemplateParameterType.__Internal*)__Instance)->isParameterPack = (byte) (value ? 1 : 0);
                    }
                }
            }

            public unsafe partial class TemplateParameterSubstitutionType : global::CppSharp.Parser.AST.Type, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 20)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.TypeKind kind;

                    [FieldOffset(4)]
                    internal byte isDependent;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal replacement;

                    [FieldOffset(16)]
                    internal global::System.IntPtr replacedParameter;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0TemplateParameterSubstitutionType@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0TemplateParameterSubstitutionType@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.TemplateParameterSubstitutionType __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.TemplateParameterSubstitutionType(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.TemplateParameterSubstitutionType __CreateInstance(global::CppSharp.Parser.AST.TemplateParameterSubstitutionType.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.TemplateParameterSubstitutionType(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.TemplateParameterSubstitutionType.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TemplateParameterSubstitutionType.__Internal));
                    global::CppSharp.Parser.AST.TemplateParameterSubstitutionType.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private TemplateParameterSubstitutionType(global::CppSharp.Parser.AST.TemplateParameterSubstitutionType.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected TemplateParameterSubstitutionType(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public TemplateParameterSubstitutionType()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TemplateParameterSubstitutionType.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public TemplateParameterSubstitutionType(global::CppSharp.Parser.AST.TemplateParameterSubstitutionType _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TemplateParameterSubstitutionType.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public global::CppSharp.Parser.AST.QualifiedType Replacement
                {
                    get
                    {
                        return global::CppSharp.Parser.AST.QualifiedType.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.TemplateParameterSubstitutionType.__Internal*) __Instance)->replacement));
                    }

                    set
                    {
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                        ((global::CppSharp.Parser.AST.TemplateParameterSubstitutionType.__Internal*)__Instance)->replacement = *(global::CppSharp.Parser.AST.QualifiedType.__Internal*) value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.TemplateParameterType ReplacedParameter
                {
                    get
                    {
                        global::CppSharp.Parser.AST.TemplateParameterType __result0;
                        if (((global::CppSharp.Parser.AST.TemplateParameterSubstitutionType.__Internal*) __Instance)->replacedParameter == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.TemplateParameterType.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.TemplateParameterSubstitutionType.__Internal*) __Instance)->replacedParameter))
                            __result0 = (global::CppSharp.Parser.AST.TemplateParameterType) global::CppSharp.Parser.AST.TemplateParameterType.NativeToManagedMap[((global::CppSharp.Parser.AST.TemplateParameterSubstitutionType.__Internal*) __Instance)->replacedParameter];
                        else __result0 = global::CppSharp.Parser.AST.TemplateParameterType.__CreateInstance(((global::CppSharp.Parser.AST.TemplateParameterSubstitutionType.__Internal*) __Instance)->replacedParameter);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.TemplateParameterSubstitutionType.__Internal*)__Instance)->replacedParameter = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }
            }

            public unsafe partial class InjectedClassNameType : global::CppSharp.Parser.AST.Type, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 20)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.TypeKind kind;

                    [FieldOffset(4)]
                    internal byte isDependent;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal injectedSpecializationType;

                    [FieldOffset(16)]
                    internal global::System.IntPtr _class;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0InjectedClassNameType@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0InjectedClassNameType@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.InjectedClassNameType __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.InjectedClassNameType(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.InjectedClassNameType __CreateInstance(global::CppSharp.Parser.AST.InjectedClassNameType.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.InjectedClassNameType(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.InjectedClassNameType.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.InjectedClassNameType.__Internal));
                    global::CppSharp.Parser.AST.InjectedClassNameType.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private InjectedClassNameType(global::CppSharp.Parser.AST.InjectedClassNameType.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected InjectedClassNameType(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public InjectedClassNameType()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.InjectedClassNameType.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public InjectedClassNameType(global::CppSharp.Parser.AST.InjectedClassNameType _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.InjectedClassNameType.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public global::CppSharp.Parser.AST.QualifiedType InjectedSpecializationType
                {
                    get
                    {
                        return global::CppSharp.Parser.AST.QualifiedType.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.InjectedClassNameType.__Internal*) __Instance)->injectedSpecializationType));
                    }

                    set
                    {
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                        ((global::CppSharp.Parser.AST.InjectedClassNameType.__Internal*)__Instance)->injectedSpecializationType = *(global::CppSharp.Parser.AST.QualifiedType.__Internal*) value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Class Class
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Class __result0;
                        if (((global::CppSharp.Parser.AST.InjectedClassNameType.__Internal*) __Instance)->_class == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Class.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.InjectedClassNameType.__Internal*) __Instance)->_class))
                            __result0 = (global::CppSharp.Parser.AST.Class) global::CppSharp.Parser.AST.Class.NativeToManagedMap[((global::CppSharp.Parser.AST.InjectedClassNameType.__Internal*) __Instance)->_class];
                        else __result0 = global::CppSharp.Parser.AST.Class.__CreateInstance(((global::CppSharp.Parser.AST.InjectedClassNameType.__Internal*) __Instance)->_class);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.InjectedClassNameType.__Internal*)__Instance)->_class = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }
            }

            public unsafe partial class DependentNameType : global::CppSharp.Parser.AST.Type, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 40)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.TypeKind kind;

                    [FieldOffset(4)]
                    internal byte isDependent;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal qualifier;

                    [FieldOffset(16)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C identifier;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0DependentNameType@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0DependentNameType@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??1DependentNameType@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern void dtor(global::System.IntPtr __instance, int delete);
                }

                internal static new global::CppSharp.Parser.AST.DependentNameType __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.DependentNameType(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.DependentNameType __CreateInstance(global::CppSharp.Parser.AST.DependentNameType.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.DependentNameType(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.DependentNameType.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.DependentNameType.__Internal));
                    global::CppSharp.Parser.AST.DependentNameType.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private DependentNameType(global::CppSharp.Parser.AST.DependentNameType.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected DependentNameType(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public DependentNameType()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.DependentNameType.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public DependentNameType(global::CppSharp.Parser.AST.DependentNameType _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.DependentNameType.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Type __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor(__Instance, 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.QualifiedType Qualifier
                {
                    get
                    {
                        return global::CppSharp.Parser.AST.QualifiedType.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.DependentNameType.__Internal*) __Instance)->qualifier));
                    }

                    set
                    {
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                        ((global::CppSharp.Parser.AST.DependentNameType.__Internal*)__Instance)->qualifier = *(global::CppSharp.Parser.AST.QualifiedType.__Internal*) value.__Instance;
                    }
                }

                public string Identifier
                {
                    get
                    {
                        var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.DependentNameType.__Internal*) __Instance)->identifier));
                        return global::Std.BasicStringExtensions.Data(__basicStringRet0);
                    }

                    set
                    {
                        global::Std.BasicStringExtensions.__Internal.Assign(new global::System.IntPtr(&((global::CppSharp.Parser.AST.DependentNameType.__Internal*)__Instance)->identifier), value);
                    }
                }
            }

            public unsafe partial class PackExpansionType : global::CppSharp.Parser.AST.Type, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 8)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.TypeKind kind;

                    [FieldOffset(4)]
                    internal byte isDependent;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0PackExpansionType@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0PackExpansionType@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.PackExpansionType __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.PackExpansionType(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.PackExpansionType __CreateInstance(global::CppSharp.Parser.AST.PackExpansionType.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.PackExpansionType(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.PackExpansionType.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.PackExpansionType.__Internal));
                    global::CppSharp.Parser.AST.PackExpansionType.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private PackExpansionType(global::CppSharp.Parser.AST.PackExpansionType.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected PackExpansionType(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public PackExpansionType()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.PackExpansionType.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public PackExpansionType(global::CppSharp.Parser.AST.PackExpansionType _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.PackExpansionType.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }
            }

            public unsafe partial class UnaryTransformType : global::CppSharp.Parser.AST.Type, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 24)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.TypeKind kind;

                    [FieldOffset(4)]
                    internal byte isDependent;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal desugared;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal baseType;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0UnaryTransformType@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0UnaryTransformType@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.UnaryTransformType __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.UnaryTransformType(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.UnaryTransformType __CreateInstance(global::CppSharp.Parser.AST.UnaryTransformType.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.UnaryTransformType(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.UnaryTransformType.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.UnaryTransformType.__Internal));
                    global::CppSharp.Parser.AST.UnaryTransformType.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private UnaryTransformType(global::CppSharp.Parser.AST.UnaryTransformType.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected UnaryTransformType(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public UnaryTransformType()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.UnaryTransformType.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public UnaryTransformType(global::CppSharp.Parser.AST.UnaryTransformType _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.UnaryTransformType.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public global::CppSharp.Parser.AST.QualifiedType Desugared
                {
                    get
                    {
                        return global::CppSharp.Parser.AST.QualifiedType.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.UnaryTransformType.__Internal*) __Instance)->desugared));
                    }

                    set
                    {
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                        ((global::CppSharp.Parser.AST.UnaryTransformType.__Internal*)__Instance)->desugared = *(global::CppSharp.Parser.AST.QualifiedType.__Internal*) value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.QualifiedType BaseType
                {
                    get
                    {
                        return global::CppSharp.Parser.AST.QualifiedType.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.UnaryTransformType.__Internal*) __Instance)->baseType));
                    }

                    set
                    {
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                        ((global::CppSharp.Parser.AST.UnaryTransformType.__Internal*)__Instance)->baseType = *(global::CppSharp.Parser.AST.QualifiedType.__Internal*) value.__Instance;
                    }
                }
            }

            public unsafe partial class UnresolvedUsingType : global::CppSharp.Parser.AST.Type, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 12)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.TypeKind kind;

                    [FieldOffset(4)]
                    internal byte isDependent;

                    [FieldOffset(8)]
                    internal global::System.IntPtr declaration;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0UnresolvedUsingType@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0UnresolvedUsingType@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.UnresolvedUsingType __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.UnresolvedUsingType(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.UnresolvedUsingType __CreateInstance(global::CppSharp.Parser.AST.UnresolvedUsingType.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.UnresolvedUsingType(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.UnresolvedUsingType.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.UnresolvedUsingType.__Internal));
                    global::CppSharp.Parser.AST.UnresolvedUsingType.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private UnresolvedUsingType(global::CppSharp.Parser.AST.UnresolvedUsingType.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected UnresolvedUsingType(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public UnresolvedUsingType()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.UnresolvedUsingType.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public UnresolvedUsingType(global::CppSharp.Parser.AST.UnresolvedUsingType _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.UnresolvedUsingType.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public global::CppSharp.Parser.AST.UnresolvedUsingTypename Declaration
                {
                    get
                    {
                        global::CppSharp.Parser.AST.UnresolvedUsingTypename __result0;
                        if (((global::CppSharp.Parser.AST.UnresolvedUsingType.__Internal*) __Instance)->declaration == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.UnresolvedUsingTypename.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.UnresolvedUsingType.__Internal*) __Instance)->declaration))
                            __result0 = (global::CppSharp.Parser.AST.UnresolvedUsingTypename) global::CppSharp.Parser.AST.UnresolvedUsingTypename.NativeToManagedMap[((global::CppSharp.Parser.AST.UnresolvedUsingType.__Internal*) __Instance)->declaration];
                        else __result0 = global::CppSharp.Parser.AST.UnresolvedUsingTypename.__CreateInstance(((global::CppSharp.Parser.AST.UnresolvedUsingType.__Internal*) __Instance)->declaration);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.UnresolvedUsingType.__Internal*)__Instance)->declaration = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }
            }

            public unsafe partial class VectorType : global::CppSharp.Parser.AST.Type, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 20)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.TypeKind kind;

                    [FieldOffset(4)]
                    internal byte isDependent;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal elementType;

                    [FieldOffset(16)]
                    internal uint numElements;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0VectorType@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0VectorType@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.VectorType __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.VectorType(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.VectorType __CreateInstance(global::CppSharp.Parser.AST.VectorType.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.VectorType(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.VectorType.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.VectorType.__Internal));
                    global::CppSharp.Parser.AST.VectorType.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private VectorType(global::CppSharp.Parser.AST.VectorType.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected VectorType(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public VectorType()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.VectorType.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public VectorType(global::CppSharp.Parser.AST.VectorType _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.VectorType.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public global::CppSharp.Parser.AST.QualifiedType ElementType
                {
                    get
                    {
                        return global::CppSharp.Parser.AST.QualifiedType.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.VectorType.__Internal*) __Instance)->elementType));
                    }

                    set
                    {
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                        ((global::CppSharp.Parser.AST.VectorType.__Internal*)__Instance)->elementType = *(global::CppSharp.Parser.AST.QualifiedType.__Internal*) value.__Instance;
                    }
                }

                public uint NumElements
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.VectorType.__Internal*) __Instance)->numElements;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.VectorType.__Internal*)__Instance)->numElements = value;
                    }
                }
            }

            public unsafe partial class BuiltinType : global::CppSharp.Parser.AST.Type, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 12)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.TypeKind kind;

                    [FieldOffset(4)]
                    internal byte isDependent;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.PrimitiveType type;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0BuiltinType@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0BuiltinType@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.BuiltinType __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.BuiltinType(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.BuiltinType __CreateInstance(global::CppSharp.Parser.AST.BuiltinType.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.BuiltinType(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.BuiltinType.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.BuiltinType.__Internal));
                    global::CppSharp.Parser.AST.BuiltinType.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private BuiltinType(global::CppSharp.Parser.AST.BuiltinType.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected BuiltinType(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public BuiltinType()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.BuiltinType.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public BuiltinType(global::CppSharp.Parser.AST.BuiltinType _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.BuiltinType.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public global::CppSharp.Parser.AST.PrimitiveType Type
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.BuiltinType.__Internal*) __Instance)->type;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.BuiltinType.__Internal*)__Instance)->type = value;
                    }
                }
            }
        }
    }
}

namespace CppSharp
{
    namespace Parser
    {
        namespace AST
        {
            public enum DeclarationKind
            {
                DeclarationContext = 0,
                Typedef = 1,
                TypeAlias = 2,
                Parameter = 3,
                Function = 4,
                Method = 5,
                Enumeration = 6,
                EnumerationItem = 7,
                Variable = 8,
                Field = 9,
                AccessSpecifier = 10,
                Class = 11,
                Template = 12,
                TypeAliasTemplate = 13,
                ClassTemplate = 14,
                ClassTemplateSpecialization = 15,
                ClassTemplatePartialSpecialization = 16,
                FunctionTemplate = 17,
                Namespace = 18,
                PreprocessedEntity = 19,
                MacroDefinition = 20,
                MacroExpansion = 21,
                TranslationUnit = 22,
                Friend = 23,
                TemplateTemplateParm = 24,
                TemplateTypeParm = 25,
                NonTypeTemplateParm = 26,
                VarTemplate = 27,
                VarTemplateSpecialization = 28,
                VarTemplatePartialSpecialization = 29,
                UnresolvedUsingTypename = 30
            }

            public enum AccessSpecifier
            {
                Private = 0,
                Protected = 1,
                Public = 2
            }

            public enum MacroLocation
            {
                Unknown = 0,
                ClassHead = 1,
                ClassBody = 2,
                FunctionHead = 3,
                FunctionParameters = 4,
                FunctionBody = 5
            }

            public enum FriendKind
            {
                None = 0,
                Declared = 1,
                Undeclared = 2
            }

            public enum CXXOperatorKind
            {
                None = 0,
                New = 1,
                Delete = 2,
                ArrayNew = 3,
                ArrayDelete = 4,
                Plus = 5,
                Minus = 6,
                Star = 7,
                Slash = 8,
                Percent = 9,
                Caret = 10,
                Amp = 11,
                Pipe = 12,
                Tilde = 13,
                Exclaim = 14,
                Equal = 15,
                Less = 16,
                Greater = 17,
                PlusEqual = 18,
                MinusEqual = 19,
                StarEqual = 20,
                SlashEqual = 21,
                PercentEqual = 22,
                CaretEqual = 23,
                AmpEqual = 24,
                PipeEqual = 25,
                LessLess = 26,
                GreaterGreater = 27,
                LessLessEqual = 28,
                GreaterGreaterEqual = 29,
                EqualEqual = 30,
                ExclaimEqual = 31,
                LessEqual = 32,
                GreaterEqual = 33,
                Spaceship = 34,
                AmpAmp = 35,
                PipePipe = 36,
                PlusPlus = 37,
                MinusMinus = 38,
                Comma = 39,
                ArrowStar = 40,
                Arrow = 41,
                Call = 42,
                Subscript = 43,
                Conditional = 44,
                Coawait = 45
            }

            public enum StatementClassObsolete
            {
                Any = 0,
                BinaryOperator = 1,
                CallExprClass = 2,
                DeclRefExprClass = 3,
                CXXConstructExprClass = 4,
                CXXOperatorCallExpr = 5,
                ImplicitCastExpr = 6,
                ExplicitCastExpr = 7
            }

            public enum TemplateSpecializationKind
            {
                Undeclared = 0,
                ImplicitInstantiation = 1,
                ExplicitSpecialization = 2,
                ExplicitInstantiationDeclaration = 3,
                ExplicitInstantiationDefinition = 4
            }

            public enum CXXMethodKind
            {
                Normal = 0,
                Constructor = 1,
                Destructor = 2,
                Conversion = 3,
                Operator = 4,
                UsingDirective = 5
            }

            public enum RefQualifierKind
            {
                None = 0,
                LValue = 1,
                RValue = 2
            }

            public enum CppAbi
            {
                Itanium = 0,
                Microsoft = 1,
                ARM = 2,
                iOS = 3,
                iOS64 = 4
            }

            public enum RecordArgABI
            {
                /// <summary>
                /// <para>Pass it using the normal C aggregate rules for the ABI,</para>
                /// <para>potentially introducing extra copies and passing some</para>
                /// <para>or all of it in registers.</para>
                /// </summary>
                Default = 0,
                /// <summary>
                /// <para>Pass it on the stack using its defined layout.</para>
                /// <para>The argument must be evaluated directly into the correct</para>
                /// <para>stack position in the arguments area, and the call machinery</para>
                /// <para>must not move it or introduce extra copies.</para>
                /// </summary>
                DirectInMemory = 1,
                /// <summary>Pass it as a pointer to temporary memory.</summary>
                Indirect = 2
            }

            public enum VTableComponentKind
            {
                VCallOffset = 0,
                VBaseOffset = 1,
                OffsetToTop = 2,
                RTTI = 3,
                FunctionPointer = 4,
                CompleteDtorPointer = 5,
                DeletingDtorPointer = 6,
                UnusedFunctionPointer = 7
            }

            public unsafe partial class Declaration : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 148)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.DeclarationKind kind;

                    [FieldOffset(4)]
                    internal int maxFieldAlignment;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.AccessSpecifier access;

                    [FieldOffset(12)]
                    internal global::System.IntPtr _namespace;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal location;

                    [FieldOffset(20)]
                    internal int lineNumberStart;

                    [FieldOffset(24)]
                    internal int lineNumberEnd;

                    [FieldOffset(28)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C name;

                    [FieldOffset(52)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C USR;

                    [FieldOffset(76)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C debugText;

                    [FieldOffset(100)]
                    internal byte isIncomplete;

                    [FieldOffset(101)]
                    internal byte isDependent;

                    [FieldOffset(102)]
                    internal byte isImplicit;

                    [FieldOffset(103)]
                    internal byte isInvalid;

                    [FieldOffset(104)]
                    internal byte isDeprecated;

                    [FieldOffset(108)]
                    internal global::System.IntPtr completeDeclaration;

                    [FieldOffset(112)]
                    internal uint definitionOrder;

                    [FieldOffset(116)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_PreprocessedEntity___N_std_S_allocator__S0_ PreprocessedEntities;

                    [FieldOffset(128)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Declaration___N_std_S_allocator__S0_ Redeclarations;

                    [FieldOffset(140)]
                    internal global::System.IntPtr originalPtr;

                    [FieldOffset(144)]
                    internal global::System.IntPtr comment;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0Declaration@AST@CppParser@CppSharp@@QAE@W4DeclarationKind@123@@Z")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance, global::CppSharp.Parser.AST.DeclarationKind kind);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0Declaration@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??1Declaration@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern void dtor(global::System.IntPtr __instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getPreprocessedEntities@Declaration@AST@CppParser@CppSharp@@QAEPAVPreprocessedEntity@234@I@Z")]
                    internal static extern global::System.IntPtr GetPreprocessedEntities(global::System.IntPtr __instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?addPreprocessedEntities@Declaration@AST@CppParser@CppSharp@@QAEXAAPAVPreprocessedEntity@234@@Z")]
                    internal static extern void AddPreprocessedEntities(global::System.IntPtr __instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?clearPreprocessedEntities@Declaration@AST@CppParser@CppSharp@@QAEXXZ")]
                    internal static extern void ClearPreprocessedEntities(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getRedeclarations@Declaration@AST@CppParser@CppSharp@@QAEPAV1234@I@Z")]
                    internal static extern global::System.IntPtr GetRedeclarations(global::System.IntPtr __instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?addRedeclarations@Declaration@AST@CppParser@CppSharp@@QAEXAAPAV1234@@Z")]
                    internal static extern void AddRedeclarations(global::System.IntPtr __instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?clearRedeclarations@Declaration@AST@CppParser@CppSharp@@QAEXXZ")]
                    internal static extern void ClearRedeclarations(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getPreprocessedEntitiesCount@Declaration@AST@CppParser@CppSharp@@QAEIXZ")]
                    internal static extern uint GetPreprocessedEntitiesCount(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getRedeclarationsCount@Declaration@AST@CppParser@CppSharp@@QAEIXZ")]
                    internal static extern uint GetRedeclarationsCount(global::System.IntPtr __instance);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.Declaration> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.Declaration>();
                protected internal void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                internal static global::CppSharp.Parser.AST.Declaration __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.Declaration(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.Declaration __CreateInstance(global::CppSharp.Parser.AST.Declaration.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.Declaration(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.Declaration.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Declaration.__Internal));
                    global::CppSharp.Parser.AST.Declaration.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private Declaration(global::CppSharp.Parser.AST.Declaration.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected Declaration(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public Declaration(global::CppSharp.Parser.AST.DeclarationKind kind)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Declaration.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance, kind);
                }

                public Declaration(global::CppSharp.Parser.AST.Declaration _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Declaration.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                public virtual void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Declaration __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor(__Instance, 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.PreprocessedEntity GetPreprocessedEntities(uint i)
                {
                    var __ret = __Internal.GetPreprocessedEntities(__Instance, i);
                    global::CppSharp.Parser.AST.PreprocessedEntity __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.PreprocessedEntity.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::CppSharp.Parser.AST.PreprocessedEntity) global::CppSharp.Parser.AST.PreprocessedEntity.NativeToManagedMap[__ret];
                    else __result0 = global::CppSharp.Parser.AST.PreprocessedEntity.__CreateInstance(__ret);
                    return __result0;
                }

                public void AddPreprocessedEntities(global::CppSharp.Parser.AST.PreprocessedEntity s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var ____arg0 = s.__Instance;
                    var __arg0 = new global::System.IntPtr(&____arg0);
                    __Internal.AddPreprocessedEntities(__Instance, __arg0);
                }

                public void ClearPreprocessedEntities()
                {
                    __Internal.ClearPreprocessedEntities(__Instance);
                }

                public global::CppSharp.Parser.AST.Declaration GetRedeclarations(uint i)
                {
                    var __ret = __Internal.GetRedeclarations(__Instance, i);
                    global::CppSharp.Parser.AST.Declaration __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.Declaration.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::CppSharp.Parser.AST.Declaration) global::CppSharp.Parser.AST.Declaration.NativeToManagedMap[__ret];
                    else __result0 = global::CppSharp.Parser.AST.Declaration.__CreateInstance(__ret);
                    return __result0;
                }

                public void AddRedeclarations(global::CppSharp.Parser.AST.Declaration s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var ____arg0 = s.__Instance;
                    var __arg0 = new global::System.IntPtr(&____arg0);
                    __Internal.AddRedeclarations(__Instance, __arg0);
                }

                public void ClearRedeclarations()
                {
                    __Internal.ClearRedeclarations(__Instance);
                }

                public static implicit operator global::CppSharp.Parser.AST.Declaration(global::CppSharp.Parser.AST.DeclarationKind kind)
                {
                    return new global::CppSharp.Parser.AST.Declaration(kind);
                }

                public global::CppSharp.Parser.AST.DeclarationKind Kind
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Declaration.__Internal*) __Instance)->kind;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Declaration.__Internal*)__Instance)->kind = value;
                    }
                }

                public int MaxFieldAlignment
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Declaration.__Internal*) __Instance)->maxFieldAlignment;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Declaration.__Internal*)__Instance)->maxFieldAlignment = value;
                    }
                }

                public global::CppSharp.Parser.AST.AccessSpecifier Access
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Declaration.__Internal*) __Instance)->access;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Declaration.__Internal*)__Instance)->access = value;
                    }
                }

                public global::CppSharp.Parser.AST.DeclarationContext Namespace
                {
                    get
                    {
                        global::CppSharp.Parser.AST.DeclarationContext __result0;
                        if (((global::CppSharp.Parser.AST.Declaration.__Internal*) __Instance)->_namespace == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.DeclarationContext.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.Declaration.__Internal*) __Instance)->_namespace))
                            __result0 = (global::CppSharp.Parser.AST.DeclarationContext) global::CppSharp.Parser.AST.DeclarationContext.NativeToManagedMap[((global::CppSharp.Parser.AST.Declaration.__Internal*) __Instance)->_namespace];
                        else __result0 = global::CppSharp.Parser.AST.DeclarationContext.__CreateInstance(((global::CppSharp.Parser.AST.Declaration.__Internal*) __Instance)->_namespace);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Declaration.__Internal*)__Instance)->_namespace = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.SourceLocation Location
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.Declaration.__Internal*) __Instance)->location);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Declaration.__Internal*)__Instance)->location = value.__Instance;
                    }
                }

                public int LineNumberStart
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Declaration.__Internal*) __Instance)->lineNumberStart;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Declaration.__Internal*)__Instance)->lineNumberStart = value;
                    }
                }

                public int LineNumberEnd
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Declaration.__Internal*) __Instance)->lineNumberEnd;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Declaration.__Internal*)__Instance)->lineNumberEnd = value;
                    }
                }

                public string Name
                {
                    get
                    {
                        var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.Declaration.__Internal*) __Instance)->name));
                        return global::Std.BasicStringExtensions.Data(__basicStringRet0);
                    }

                    set
                    {
                        global::Std.BasicStringExtensions.__Internal.Assign(new global::System.IntPtr(&((global::CppSharp.Parser.AST.Declaration.__Internal*)__Instance)->name), value);
                    }
                }

                public string USR
                {
                    get
                    {
                        var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.Declaration.__Internal*) __Instance)->USR));
                        return global::Std.BasicStringExtensions.Data(__basicStringRet0);
                    }

                    set
                    {
                        global::Std.BasicStringExtensions.__Internal.Assign(new global::System.IntPtr(&((global::CppSharp.Parser.AST.Declaration.__Internal*)__Instance)->USR), value);
                    }
                }

                public string DebugText
                {
                    get
                    {
                        var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.Declaration.__Internal*) __Instance)->debugText));
                        return global::Std.BasicStringExtensions.Data(__basicStringRet0);
                    }

                    set
                    {
                        global::Std.BasicStringExtensions.__Internal.Assign(new global::System.IntPtr(&((global::CppSharp.Parser.AST.Declaration.__Internal*)__Instance)->debugText), value);
                    }
                }

                public bool IsIncomplete
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Declaration.__Internal*) __Instance)->isIncomplete != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Declaration.__Internal*)__Instance)->isIncomplete = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsDependent
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Declaration.__Internal*) __Instance)->isDependent != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Declaration.__Internal*)__Instance)->isDependent = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsImplicit
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Declaration.__Internal*) __Instance)->isImplicit != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Declaration.__Internal*)__Instance)->isImplicit = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsInvalid
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Declaration.__Internal*) __Instance)->isInvalid != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Declaration.__Internal*)__Instance)->isInvalid = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsDeprecated
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Declaration.__Internal*) __Instance)->isDeprecated != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Declaration.__Internal*)__Instance)->isDeprecated = (byte) (value ? 1 : 0);
                    }
                }

                public global::CppSharp.Parser.AST.Declaration CompleteDeclaration
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Declaration __result0;
                        if (((global::CppSharp.Parser.AST.Declaration.__Internal*) __Instance)->completeDeclaration == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Declaration.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.Declaration.__Internal*) __Instance)->completeDeclaration))
                            __result0 = (global::CppSharp.Parser.AST.Declaration) global::CppSharp.Parser.AST.Declaration.NativeToManagedMap[((global::CppSharp.Parser.AST.Declaration.__Internal*) __Instance)->completeDeclaration];
                        else __result0 = global::CppSharp.Parser.AST.Declaration.__CreateInstance(((global::CppSharp.Parser.AST.Declaration.__Internal*) __Instance)->completeDeclaration);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Declaration.__Internal*)__Instance)->completeDeclaration = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public uint DefinitionOrder
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Declaration.__Internal*) __Instance)->definitionOrder;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Declaration.__Internal*)__Instance)->definitionOrder = value;
                    }
                }

                public global::System.IntPtr OriginalPtr
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Declaration.__Internal*) __Instance)->originalPtr;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Declaration.__Internal*)__Instance)->originalPtr = (global::System.IntPtr) value;
                    }
                }

                public global::CppSharp.Parser.AST.RawComment Comment
                {
                    get
                    {
                        global::CppSharp.Parser.AST.RawComment __result0;
                        if (((global::CppSharp.Parser.AST.Declaration.__Internal*) __Instance)->comment == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.RawComment.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.Declaration.__Internal*) __Instance)->comment))
                            __result0 = (global::CppSharp.Parser.AST.RawComment) global::CppSharp.Parser.AST.RawComment.NativeToManagedMap[((global::CppSharp.Parser.AST.Declaration.__Internal*) __Instance)->comment];
                        else __result0 = global::CppSharp.Parser.AST.RawComment.__CreateInstance(((global::CppSharp.Parser.AST.Declaration.__Internal*) __Instance)->comment);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Declaration.__Internal*)__Instance)->comment = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public uint PreprocessedEntitiesCount
                {
                    get
                    {
                        var __ret = __Internal.GetPreprocessedEntitiesCount(__Instance);
                        return __ret;
                    }
                }

                public uint RedeclarationsCount
                {
                    get
                    {
                        var __ret = __Internal.GetRedeclarationsCount(__Instance);
                        return __ret;
                    }
                }
            }

            public unsafe partial class DeclarationContext : global::CppSharp.Parser.AST.Declaration, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 268)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.DeclarationKind kind;

                    [FieldOffset(4)]
                    internal int maxFieldAlignment;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.AccessSpecifier access;

                    [FieldOffset(12)]
                    internal global::System.IntPtr _namespace;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal location;

                    [FieldOffset(20)]
                    internal int lineNumberStart;

                    [FieldOffset(24)]
                    internal int lineNumberEnd;

                    [FieldOffset(28)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C name;

                    [FieldOffset(52)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C USR;

                    [FieldOffset(76)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C debugText;

                    [FieldOffset(100)]
                    internal byte isIncomplete;

                    [FieldOffset(101)]
                    internal byte isDependent;

                    [FieldOffset(102)]
                    internal byte isImplicit;

                    [FieldOffset(103)]
                    internal byte isInvalid;

                    [FieldOffset(104)]
                    internal byte isDeprecated;

                    [FieldOffset(108)]
                    internal global::System.IntPtr completeDeclaration;

                    [FieldOffset(112)]
                    internal uint definitionOrder;

                    [FieldOffset(116)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_PreprocessedEntity___N_std_S_allocator__S0_ PreprocessedEntities;

                    [FieldOffset(128)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Declaration___N_std_S_allocator__S0_ Redeclarations;

                    [FieldOffset(140)]
                    internal global::System.IntPtr originalPtr;

                    [FieldOffset(144)]
                    internal global::System.IntPtr comment;

                    [FieldOffset(148)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Namespace___N_std_S_allocator__S0_ Namespaces;

                    [FieldOffset(160)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Enumeration___N_std_S_allocator__S0_ Enums;

                    [FieldOffset(172)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Function___N_std_S_allocator__S0_ Functions;

                    [FieldOffset(184)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Class___N_std_S_allocator__S0_ Classes;

                    [FieldOffset(196)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Template___N_std_S_allocator__S0_ Templates;

                    [FieldOffset(208)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_TypedefDecl___N_std_S_allocator__S0_ Typedefs;

                    [FieldOffset(220)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_TypeAlias___N_std_S_allocator__S0_ TypeAliases;

                    [FieldOffset(232)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Variable___N_std_S_allocator__S0_ Variables;

                    [FieldOffset(244)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Friend___N_std_S_allocator__S0_ Friends;

                    [FieldOffset(256)]
                    internal global::Std.Map.__Internalc__N_std_S_map____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C____N_CppSharp_N_CppParser_N_AST_S_Declaration___N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__S3_ anonymous;

                    [FieldOffset(264)]
                    internal byte isAnonymous;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0DeclarationContext@AST@CppParser@CppSharp@@QAE@W4DeclarationKind@123@@Z")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance, global::CppSharp.Parser.AST.DeclarationKind kind);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0DeclarationContext@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??1DeclarationContext@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern void dtor(global::System.IntPtr __instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getNamespaces@DeclarationContext@AST@CppParser@CppSharp@@QAEPAVNamespace@234@I@Z")]
                    internal static extern global::System.IntPtr GetNamespaces(global::System.IntPtr __instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?addNamespaces@DeclarationContext@AST@CppParser@CppSharp@@QAEXAAPAVNamespace@234@@Z")]
                    internal static extern void AddNamespaces(global::System.IntPtr __instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?clearNamespaces@DeclarationContext@AST@CppParser@CppSharp@@QAEXXZ")]
                    internal static extern void ClearNamespaces(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getEnums@DeclarationContext@AST@CppParser@CppSharp@@QAEPAVEnumeration@234@I@Z")]
                    internal static extern global::System.IntPtr GetEnums(global::System.IntPtr __instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?addEnums@DeclarationContext@AST@CppParser@CppSharp@@QAEXAAPAVEnumeration@234@@Z")]
                    internal static extern void AddEnums(global::System.IntPtr __instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?clearEnums@DeclarationContext@AST@CppParser@CppSharp@@QAEXXZ")]
                    internal static extern void ClearEnums(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getFunctions@DeclarationContext@AST@CppParser@CppSharp@@QAEPAVFunction@234@I@Z")]
                    internal static extern global::System.IntPtr GetFunctions(global::System.IntPtr __instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?addFunctions@DeclarationContext@AST@CppParser@CppSharp@@QAEXAAPAVFunction@234@@Z")]
                    internal static extern void AddFunctions(global::System.IntPtr __instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?clearFunctions@DeclarationContext@AST@CppParser@CppSharp@@QAEXXZ")]
                    internal static extern void ClearFunctions(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getClasses@DeclarationContext@AST@CppParser@CppSharp@@QAEPAVClass@234@I@Z")]
                    internal static extern global::System.IntPtr GetClasses(global::System.IntPtr __instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?addClasses@DeclarationContext@AST@CppParser@CppSharp@@QAEXAAPAVClass@234@@Z")]
                    internal static extern void AddClasses(global::System.IntPtr __instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?clearClasses@DeclarationContext@AST@CppParser@CppSharp@@QAEXXZ")]
                    internal static extern void ClearClasses(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getTemplates@DeclarationContext@AST@CppParser@CppSharp@@QAEPAVTemplate@234@I@Z")]
                    internal static extern global::System.IntPtr GetTemplates(global::System.IntPtr __instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?addTemplates@DeclarationContext@AST@CppParser@CppSharp@@QAEXAAPAVTemplate@234@@Z")]
                    internal static extern void AddTemplates(global::System.IntPtr __instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?clearTemplates@DeclarationContext@AST@CppParser@CppSharp@@QAEXXZ")]
                    internal static extern void ClearTemplates(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getTypedefs@DeclarationContext@AST@CppParser@CppSharp@@QAEPAVTypedefDecl@234@I@Z")]
                    internal static extern global::System.IntPtr GetTypedefs(global::System.IntPtr __instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?addTypedefs@DeclarationContext@AST@CppParser@CppSharp@@QAEXAAPAVTypedefDecl@234@@Z")]
                    internal static extern void AddTypedefs(global::System.IntPtr __instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?clearTypedefs@DeclarationContext@AST@CppParser@CppSharp@@QAEXXZ")]
                    internal static extern void ClearTypedefs(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getTypeAliases@DeclarationContext@AST@CppParser@CppSharp@@QAEPAVTypeAlias@234@I@Z")]
                    internal static extern global::System.IntPtr GetTypeAliases(global::System.IntPtr __instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?addTypeAliases@DeclarationContext@AST@CppParser@CppSharp@@QAEXAAPAVTypeAlias@234@@Z")]
                    internal static extern void AddTypeAliases(global::System.IntPtr __instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?clearTypeAliases@DeclarationContext@AST@CppParser@CppSharp@@QAEXXZ")]
                    internal static extern void ClearTypeAliases(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getVariables@DeclarationContext@AST@CppParser@CppSharp@@QAEPAVVariable@234@I@Z")]
                    internal static extern global::System.IntPtr GetVariables(global::System.IntPtr __instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?addVariables@DeclarationContext@AST@CppParser@CppSharp@@QAEXAAPAVVariable@234@@Z")]
                    internal static extern void AddVariables(global::System.IntPtr __instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?clearVariables@DeclarationContext@AST@CppParser@CppSharp@@QAEXXZ")]
                    internal static extern void ClearVariables(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getFriends@DeclarationContext@AST@CppParser@CppSharp@@QAEPAVFriend@234@I@Z")]
                    internal static extern global::System.IntPtr GetFriends(global::System.IntPtr __instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?addFriends@DeclarationContext@AST@CppParser@CppSharp@@QAEXAAPAVFriend@234@@Z")]
                    internal static extern void AddFriends(global::System.IntPtr __instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?clearFriends@DeclarationContext@AST@CppParser@CppSharp@@QAEXXZ")]
                    internal static extern void ClearFriends(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getNamespacesCount@DeclarationContext@AST@CppParser@CppSharp@@QAEIXZ")]
                    internal static extern uint GetNamespacesCount(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getEnumsCount@DeclarationContext@AST@CppParser@CppSharp@@QAEIXZ")]
                    internal static extern uint GetEnumsCount(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getFunctionsCount@DeclarationContext@AST@CppParser@CppSharp@@QAEIXZ")]
                    internal static extern uint GetFunctionsCount(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getClassesCount@DeclarationContext@AST@CppParser@CppSharp@@QAEIXZ")]
                    internal static extern uint GetClassesCount(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getTemplatesCount@DeclarationContext@AST@CppParser@CppSharp@@QAEIXZ")]
                    internal static extern uint GetTemplatesCount(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getTypedefsCount@DeclarationContext@AST@CppParser@CppSharp@@QAEIXZ")]
                    internal static extern uint GetTypedefsCount(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getTypeAliasesCount@DeclarationContext@AST@CppParser@CppSharp@@QAEIXZ")]
                    internal static extern uint GetTypeAliasesCount(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getVariablesCount@DeclarationContext@AST@CppParser@CppSharp@@QAEIXZ")]
                    internal static extern uint GetVariablesCount(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getFriendsCount@DeclarationContext@AST@CppParser@CppSharp@@QAEIXZ")]
                    internal static extern uint GetFriendsCount(global::System.IntPtr __instance);
                }

                internal static new global::CppSharp.Parser.AST.DeclarationContext __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.DeclarationContext(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.DeclarationContext __CreateInstance(global::CppSharp.Parser.AST.DeclarationContext.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.DeclarationContext(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.DeclarationContext.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.DeclarationContext.__Internal));
                    global::CppSharp.Parser.AST.DeclarationContext.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private DeclarationContext(global::CppSharp.Parser.AST.DeclarationContext.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected DeclarationContext(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public DeclarationContext(global::CppSharp.Parser.AST.DeclarationKind kind)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.DeclarationContext.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance, kind);
                }

                public DeclarationContext(global::CppSharp.Parser.AST.DeclarationContext _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.DeclarationContext.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Declaration __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor(__Instance, 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.Namespace GetNamespaces(uint i)
                {
                    var __ret = __Internal.GetNamespaces(__Instance, i);
                    global::CppSharp.Parser.AST.Namespace __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.Namespace.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::CppSharp.Parser.AST.Namespace) global::CppSharp.Parser.AST.Namespace.NativeToManagedMap[__ret];
                    else __result0 = global::CppSharp.Parser.AST.Namespace.__CreateInstance(__ret);
                    return __result0;
                }

                public void AddNamespaces(global::CppSharp.Parser.AST.Namespace s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var ____arg0 = s.__Instance;
                    var __arg0 = new global::System.IntPtr(&____arg0);
                    __Internal.AddNamespaces(__Instance, __arg0);
                }

                public void ClearNamespaces()
                {
                    __Internal.ClearNamespaces(__Instance);
                }

                public global::CppSharp.Parser.AST.Enumeration GetEnums(uint i)
                {
                    var __ret = __Internal.GetEnums(__Instance, i);
                    global::CppSharp.Parser.AST.Enumeration __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.Enumeration.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::CppSharp.Parser.AST.Enumeration) global::CppSharp.Parser.AST.Enumeration.NativeToManagedMap[__ret];
                    else __result0 = global::CppSharp.Parser.AST.Enumeration.__CreateInstance(__ret);
                    return __result0;
                }

                public void AddEnums(global::CppSharp.Parser.AST.Enumeration s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var ____arg0 = s.__Instance;
                    var __arg0 = new global::System.IntPtr(&____arg0);
                    __Internal.AddEnums(__Instance, __arg0);
                }

                public void ClearEnums()
                {
                    __Internal.ClearEnums(__Instance);
                }

                public global::CppSharp.Parser.AST.Function GetFunctions(uint i)
                {
                    var __ret = __Internal.GetFunctions(__Instance, i);
                    global::CppSharp.Parser.AST.Function __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.Function.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::CppSharp.Parser.AST.Function) global::CppSharp.Parser.AST.Function.NativeToManagedMap[__ret];
                    else __result0 = global::CppSharp.Parser.AST.Function.__CreateInstance(__ret);
                    return __result0;
                }

                public void AddFunctions(global::CppSharp.Parser.AST.Function s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var ____arg0 = s.__Instance;
                    var __arg0 = new global::System.IntPtr(&____arg0);
                    __Internal.AddFunctions(__Instance, __arg0);
                }

                public void ClearFunctions()
                {
                    __Internal.ClearFunctions(__Instance);
                }

                public global::CppSharp.Parser.AST.Class GetClasses(uint i)
                {
                    var __ret = __Internal.GetClasses(__Instance, i);
                    global::CppSharp.Parser.AST.Class __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.Class.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::CppSharp.Parser.AST.Class) global::CppSharp.Parser.AST.Class.NativeToManagedMap[__ret];
                    else __result0 = global::CppSharp.Parser.AST.Class.__CreateInstance(__ret);
                    return __result0;
                }

                public void AddClasses(global::CppSharp.Parser.AST.Class s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var ____arg0 = s.__Instance;
                    var __arg0 = new global::System.IntPtr(&____arg0);
                    __Internal.AddClasses(__Instance, __arg0);
                }

                public void ClearClasses()
                {
                    __Internal.ClearClasses(__Instance);
                }

                public global::CppSharp.Parser.AST.Template GetTemplates(uint i)
                {
                    var __ret = __Internal.GetTemplates(__Instance, i);
                    global::CppSharp.Parser.AST.Template __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.Template.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::CppSharp.Parser.AST.Template) global::CppSharp.Parser.AST.Template.NativeToManagedMap[__ret];
                    else __result0 = global::CppSharp.Parser.AST.Template.__CreateInstance(__ret);
                    return __result0;
                }

                public void AddTemplates(global::CppSharp.Parser.AST.Template s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var ____arg0 = s.__Instance;
                    var __arg0 = new global::System.IntPtr(&____arg0);
                    __Internal.AddTemplates(__Instance, __arg0);
                }

                public void ClearTemplates()
                {
                    __Internal.ClearTemplates(__Instance);
                }

                public global::CppSharp.Parser.AST.TypedefDecl GetTypedefs(uint i)
                {
                    var __ret = __Internal.GetTypedefs(__Instance, i);
                    global::CppSharp.Parser.AST.TypedefDecl __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.TypedefDecl.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::CppSharp.Parser.AST.TypedefDecl) global::CppSharp.Parser.AST.TypedefDecl.NativeToManagedMap[__ret];
                    else __result0 = global::CppSharp.Parser.AST.TypedefDecl.__CreateInstance(__ret);
                    return __result0;
                }

                public void AddTypedefs(global::CppSharp.Parser.AST.TypedefDecl s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var ____arg0 = s.__Instance;
                    var __arg0 = new global::System.IntPtr(&____arg0);
                    __Internal.AddTypedefs(__Instance, __arg0);
                }

                public void ClearTypedefs()
                {
                    __Internal.ClearTypedefs(__Instance);
                }

                public global::CppSharp.Parser.AST.TypeAlias GetTypeAliases(uint i)
                {
                    var __ret = __Internal.GetTypeAliases(__Instance, i);
                    global::CppSharp.Parser.AST.TypeAlias __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.TypeAlias.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::CppSharp.Parser.AST.TypeAlias) global::CppSharp.Parser.AST.TypeAlias.NativeToManagedMap[__ret];
                    else __result0 = global::CppSharp.Parser.AST.TypeAlias.__CreateInstance(__ret);
                    return __result0;
                }

                public void AddTypeAliases(global::CppSharp.Parser.AST.TypeAlias s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var ____arg0 = s.__Instance;
                    var __arg0 = new global::System.IntPtr(&____arg0);
                    __Internal.AddTypeAliases(__Instance, __arg0);
                }

                public void ClearTypeAliases()
                {
                    __Internal.ClearTypeAliases(__Instance);
                }

                public global::CppSharp.Parser.AST.Variable GetVariables(uint i)
                {
                    var __ret = __Internal.GetVariables(__Instance, i);
                    global::CppSharp.Parser.AST.Variable __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.Variable.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::CppSharp.Parser.AST.Variable) global::CppSharp.Parser.AST.Variable.NativeToManagedMap[__ret];
                    else __result0 = global::CppSharp.Parser.AST.Variable.__CreateInstance(__ret);
                    return __result0;
                }

                public void AddVariables(global::CppSharp.Parser.AST.Variable s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var ____arg0 = s.__Instance;
                    var __arg0 = new global::System.IntPtr(&____arg0);
                    __Internal.AddVariables(__Instance, __arg0);
                }

                public void ClearVariables()
                {
                    __Internal.ClearVariables(__Instance);
                }

                public global::CppSharp.Parser.AST.Friend GetFriends(uint i)
                {
                    var __ret = __Internal.GetFriends(__Instance, i);
                    global::CppSharp.Parser.AST.Friend __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.Friend.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::CppSharp.Parser.AST.Friend) global::CppSharp.Parser.AST.Friend.NativeToManagedMap[__ret];
                    else __result0 = global::CppSharp.Parser.AST.Friend.__CreateInstance(__ret);
                    return __result0;
                }

                public void AddFriends(global::CppSharp.Parser.AST.Friend s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var ____arg0 = s.__Instance;
                    var __arg0 = new global::System.IntPtr(&____arg0);
                    __Internal.AddFriends(__Instance, __arg0);
                }

                public void ClearFriends()
                {
                    __Internal.ClearFriends(__Instance);
                }

                public static implicit operator global::CppSharp.Parser.AST.DeclarationContext(global::CppSharp.Parser.AST.DeclarationKind kind)
                {
                    return new global::CppSharp.Parser.AST.DeclarationContext(kind);
                }

                public bool IsAnonymous
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.DeclarationContext.__Internal*) __Instance)->isAnonymous != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.DeclarationContext.__Internal*)__Instance)->isAnonymous = (byte) (value ? 1 : 0);
                    }
                }

                public uint NamespacesCount
                {
                    get
                    {
                        var __ret = __Internal.GetNamespacesCount(__Instance);
                        return __ret;
                    }
                }

                public uint EnumsCount
                {
                    get
                    {
                        var __ret = __Internal.GetEnumsCount(__Instance);
                        return __ret;
                    }
                }

                public uint FunctionsCount
                {
                    get
                    {
                        var __ret = __Internal.GetFunctionsCount(__Instance);
                        return __ret;
                    }
                }

                public uint ClassesCount
                {
                    get
                    {
                        var __ret = __Internal.GetClassesCount(__Instance);
                        return __ret;
                    }
                }

                public uint TemplatesCount
                {
                    get
                    {
                        var __ret = __Internal.GetTemplatesCount(__Instance);
                        return __ret;
                    }
                }

                public uint TypedefsCount
                {
                    get
                    {
                        var __ret = __Internal.GetTypedefsCount(__Instance);
                        return __ret;
                    }
                }

                public uint TypeAliasesCount
                {
                    get
                    {
                        var __ret = __Internal.GetTypeAliasesCount(__Instance);
                        return __ret;
                    }
                }

                public uint VariablesCount
                {
                    get
                    {
                        var __ret = __Internal.GetVariablesCount(__Instance);
                        return __ret;
                    }
                }

                public uint FriendsCount
                {
                    get
                    {
                        var __ret = __Internal.GetFriendsCount(__Instance);
                        return __ret;
                    }
                }
            }

            public unsafe partial class TypedefNameDecl : global::CppSharp.Parser.AST.Declaration, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 156)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.DeclarationKind kind;

                    [FieldOffset(4)]
                    internal int maxFieldAlignment;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.AccessSpecifier access;

                    [FieldOffset(12)]
                    internal global::System.IntPtr _namespace;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal location;

                    [FieldOffset(20)]
                    internal int lineNumberStart;

                    [FieldOffset(24)]
                    internal int lineNumberEnd;

                    [FieldOffset(28)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C name;

                    [FieldOffset(52)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C USR;

                    [FieldOffset(76)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C debugText;

                    [FieldOffset(100)]
                    internal byte isIncomplete;

                    [FieldOffset(101)]
                    internal byte isDependent;

                    [FieldOffset(102)]
                    internal byte isImplicit;

                    [FieldOffset(103)]
                    internal byte isInvalid;

                    [FieldOffset(104)]
                    internal byte isDeprecated;

                    [FieldOffset(108)]
                    internal global::System.IntPtr completeDeclaration;

                    [FieldOffset(112)]
                    internal uint definitionOrder;

                    [FieldOffset(116)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_PreprocessedEntity___N_std_S_allocator__S0_ PreprocessedEntities;

                    [FieldOffset(128)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Declaration___N_std_S_allocator__S0_ Redeclarations;

                    [FieldOffset(140)]
                    internal global::System.IntPtr originalPtr;

                    [FieldOffset(144)]
                    internal global::System.IntPtr comment;

                    [FieldOffset(148)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal qualifiedType;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0TypedefNameDecl@AST@CppParser@CppSharp@@QAE@W4DeclarationKind@123@@Z")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance, global::CppSharp.Parser.AST.DeclarationKind kind);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0TypedefNameDecl@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??1TypedefNameDecl@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern void dtor(global::System.IntPtr __instance, int delete);
                }

                internal static new global::CppSharp.Parser.AST.TypedefNameDecl __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.TypedefNameDecl(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.TypedefNameDecl __CreateInstance(global::CppSharp.Parser.AST.TypedefNameDecl.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.TypedefNameDecl(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.TypedefNameDecl.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TypedefNameDecl.__Internal));
                    global::CppSharp.Parser.AST.TypedefNameDecl.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private TypedefNameDecl(global::CppSharp.Parser.AST.TypedefNameDecl.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected TypedefNameDecl(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public TypedefNameDecl(global::CppSharp.Parser.AST.DeclarationKind kind)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TypedefNameDecl.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance, kind);
                }

                public TypedefNameDecl(global::CppSharp.Parser.AST.TypedefNameDecl _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TypedefNameDecl.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Declaration __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor(__Instance, 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public static implicit operator global::CppSharp.Parser.AST.TypedefNameDecl(global::CppSharp.Parser.AST.DeclarationKind kind)
                {
                    return new global::CppSharp.Parser.AST.TypedefNameDecl(kind);
                }

                public global::CppSharp.Parser.AST.QualifiedType QualifiedType
                {
                    get
                    {
                        return global::CppSharp.Parser.AST.QualifiedType.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.TypedefNameDecl.__Internal*) __Instance)->qualifiedType));
                    }

                    set
                    {
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                        ((global::CppSharp.Parser.AST.TypedefNameDecl.__Internal*)__Instance)->qualifiedType = *(global::CppSharp.Parser.AST.QualifiedType.__Internal*) value.__Instance;
                    }
                }
            }

            public unsafe partial class TypedefDecl : global::CppSharp.Parser.AST.TypedefNameDecl, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 156)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.DeclarationKind kind;

                    [FieldOffset(4)]
                    internal int maxFieldAlignment;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.AccessSpecifier access;

                    [FieldOffset(12)]
                    internal global::System.IntPtr _namespace;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal location;

                    [FieldOffset(20)]
                    internal int lineNumberStart;

                    [FieldOffset(24)]
                    internal int lineNumberEnd;

                    [FieldOffset(28)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C name;

                    [FieldOffset(52)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C USR;

                    [FieldOffset(76)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C debugText;

                    [FieldOffset(100)]
                    internal byte isIncomplete;

                    [FieldOffset(101)]
                    internal byte isDependent;

                    [FieldOffset(102)]
                    internal byte isImplicit;

                    [FieldOffset(103)]
                    internal byte isInvalid;

                    [FieldOffset(104)]
                    internal byte isDeprecated;

                    [FieldOffset(108)]
                    internal global::System.IntPtr completeDeclaration;

                    [FieldOffset(112)]
                    internal uint definitionOrder;

                    [FieldOffset(116)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_PreprocessedEntity___N_std_S_allocator__S0_ PreprocessedEntities;

                    [FieldOffset(128)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Declaration___N_std_S_allocator__S0_ Redeclarations;

                    [FieldOffset(140)]
                    internal global::System.IntPtr originalPtr;

                    [FieldOffset(144)]
                    internal global::System.IntPtr comment;

                    [FieldOffset(148)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal qualifiedType;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0TypedefDecl@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0TypedefDecl@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??1TypedefDecl@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern void dtor(global::System.IntPtr __instance, int delete);
                }

                internal static new global::CppSharp.Parser.AST.TypedefDecl __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.TypedefDecl(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.TypedefDecl __CreateInstance(global::CppSharp.Parser.AST.TypedefDecl.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.TypedefDecl(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.TypedefDecl.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TypedefDecl.__Internal));
                    global::CppSharp.Parser.AST.TypedefDecl.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private TypedefDecl(global::CppSharp.Parser.AST.TypedefDecl.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected TypedefDecl(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public TypedefDecl()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TypedefDecl.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public TypedefDecl(global::CppSharp.Parser.AST.TypedefDecl _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TypedefDecl.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Declaration __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor(__Instance, 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }
            }

            public unsafe partial class TypeAlias : global::CppSharp.Parser.AST.TypedefNameDecl, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 160)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.DeclarationKind kind;

                    [FieldOffset(4)]
                    internal int maxFieldAlignment;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.AccessSpecifier access;

                    [FieldOffset(12)]
                    internal global::System.IntPtr _namespace;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal location;

                    [FieldOffset(20)]
                    internal int lineNumberStart;

                    [FieldOffset(24)]
                    internal int lineNumberEnd;

                    [FieldOffset(28)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C name;

                    [FieldOffset(52)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C USR;

                    [FieldOffset(76)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C debugText;

                    [FieldOffset(100)]
                    internal byte isIncomplete;

                    [FieldOffset(101)]
                    internal byte isDependent;

                    [FieldOffset(102)]
                    internal byte isImplicit;

                    [FieldOffset(103)]
                    internal byte isInvalid;

                    [FieldOffset(104)]
                    internal byte isDeprecated;

                    [FieldOffset(108)]
                    internal global::System.IntPtr completeDeclaration;

                    [FieldOffset(112)]
                    internal uint definitionOrder;

                    [FieldOffset(116)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_PreprocessedEntity___N_std_S_allocator__S0_ PreprocessedEntities;

                    [FieldOffset(128)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Declaration___N_std_S_allocator__S0_ Redeclarations;

                    [FieldOffset(140)]
                    internal global::System.IntPtr originalPtr;

                    [FieldOffset(144)]
                    internal global::System.IntPtr comment;

                    [FieldOffset(148)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal qualifiedType;

                    [FieldOffset(156)]
                    internal global::System.IntPtr describedAliasTemplate;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0TypeAlias@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0TypeAlias@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??1TypeAlias@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern void dtor(global::System.IntPtr __instance, int delete);
                }

                internal static new global::CppSharp.Parser.AST.TypeAlias __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.TypeAlias(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.TypeAlias __CreateInstance(global::CppSharp.Parser.AST.TypeAlias.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.TypeAlias(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.TypeAlias.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TypeAlias.__Internal));
                    global::CppSharp.Parser.AST.TypeAlias.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private TypeAlias(global::CppSharp.Parser.AST.TypeAlias.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected TypeAlias(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public TypeAlias()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TypeAlias.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public TypeAlias(global::CppSharp.Parser.AST.TypeAlias _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TypeAlias.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Declaration __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor(__Instance, 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.TypeAliasTemplate DescribedAliasTemplate
                {
                    get
                    {
                        global::CppSharp.Parser.AST.TypeAliasTemplate __result0;
                        if (((global::CppSharp.Parser.AST.TypeAlias.__Internal*) __Instance)->describedAliasTemplate == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.TypeAliasTemplate.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.TypeAlias.__Internal*) __Instance)->describedAliasTemplate))
                            __result0 = (global::CppSharp.Parser.AST.TypeAliasTemplate) global::CppSharp.Parser.AST.TypeAliasTemplate.NativeToManagedMap[((global::CppSharp.Parser.AST.TypeAlias.__Internal*) __Instance)->describedAliasTemplate];
                        else __result0 = global::CppSharp.Parser.AST.TypeAliasTemplate.__CreateInstance(((global::CppSharp.Parser.AST.TypeAlias.__Internal*) __Instance)->describedAliasTemplate);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.TypeAlias.__Internal*)__Instance)->describedAliasTemplate = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }
            }

            public unsafe partial class Friend : global::CppSharp.Parser.AST.Declaration, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 152)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.DeclarationKind kind;

                    [FieldOffset(4)]
                    internal int maxFieldAlignment;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.AccessSpecifier access;

                    [FieldOffset(12)]
                    internal global::System.IntPtr _namespace;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal location;

                    [FieldOffset(20)]
                    internal int lineNumberStart;

                    [FieldOffset(24)]
                    internal int lineNumberEnd;

                    [FieldOffset(28)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C name;

                    [FieldOffset(52)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C USR;

                    [FieldOffset(76)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C debugText;

                    [FieldOffset(100)]
                    internal byte isIncomplete;

                    [FieldOffset(101)]
                    internal byte isDependent;

                    [FieldOffset(102)]
                    internal byte isImplicit;

                    [FieldOffset(103)]
                    internal byte isInvalid;

                    [FieldOffset(104)]
                    internal byte isDeprecated;

                    [FieldOffset(108)]
                    internal global::System.IntPtr completeDeclaration;

                    [FieldOffset(112)]
                    internal uint definitionOrder;

                    [FieldOffset(116)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_PreprocessedEntity___N_std_S_allocator__S0_ PreprocessedEntities;

                    [FieldOffset(128)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Declaration___N_std_S_allocator__S0_ Redeclarations;

                    [FieldOffset(140)]
                    internal global::System.IntPtr originalPtr;

                    [FieldOffset(144)]
                    internal global::System.IntPtr comment;

                    [FieldOffset(148)]
                    internal global::System.IntPtr declaration;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0Friend@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0Friend@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??1Friend@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern void dtor(global::System.IntPtr __instance, int delete);
                }

                internal static new global::CppSharp.Parser.AST.Friend __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.Friend(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.Friend __CreateInstance(global::CppSharp.Parser.AST.Friend.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.Friend(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.Friend.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Friend.__Internal));
                    global::CppSharp.Parser.AST.Friend.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private Friend(global::CppSharp.Parser.AST.Friend.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected Friend(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public Friend()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Friend.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public Friend(global::CppSharp.Parser.AST.Friend _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Friend.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Declaration __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor(__Instance, 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.Declaration Declaration
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Declaration __result0;
                        if (((global::CppSharp.Parser.AST.Friend.__Internal*) __Instance)->declaration == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Declaration.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.Friend.__Internal*) __Instance)->declaration))
                            __result0 = (global::CppSharp.Parser.AST.Declaration) global::CppSharp.Parser.AST.Declaration.NativeToManagedMap[((global::CppSharp.Parser.AST.Friend.__Internal*) __Instance)->declaration];
                        else __result0 = global::CppSharp.Parser.AST.Declaration.__CreateInstance(((global::CppSharp.Parser.AST.Friend.__Internal*) __Instance)->declaration);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Friend.__Internal*)__Instance)->declaration = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }
            }

            public unsafe partial class StatementObsolete : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 32)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StatementClassObsolete _class;

                    [FieldOffset(4)]
                    internal global::System.IntPtr decl;

                    [FieldOffset(8)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C @string;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0StatementObsolete@AST@CppParser@CppSharp@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4StatementClassObsolete@123@PAVDeclaration@123@@Z")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance, global::System.IntPtr str, global::CppSharp.Parser.AST.StatementClassObsolete Class, global::System.IntPtr decl);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0StatementObsolete@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??1StatementObsolete@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern void dtor(global::System.IntPtr __instance, int delete);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.StatementObsolete> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.StatementObsolete>();
                protected internal void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                internal static global::CppSharp.Parser.AST.StatementObsolete __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.StatementObsolete(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.StatementObsolete __CreateInstance(global::CppSharp.Parser.AST.StatementObsolete.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.StatementObsolete(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.StatementObsolete.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.StatementObsolete.__Internal));
                    global::CppSharp.Parser.AST.StatementObsolete.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private StatementObsolete(global::CppSharp.Parser.AST.StatementObsolete.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected StatementObsolete(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public StatementObsolete(string str, global::CppSharp.Parser.AST.StatementClassObsolete Class, global::CppSharp.Parser.AST.Declaration decl)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.StatementObsolete.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                    global::Std.BasicStringExtensions.Assign(__basicString0, str);
                    var __arg0 = __basicString0.__Instance;
                    var __arg2 = ReferenceEquals(decl, null) ? global::System.IntPtr.Zero : decl.__Instance;
                    __Internal.ctor(__Instance, __arg0, Class, __arg2);
                    __basicString0.Dispose();
                }

                public StatementObsolete(global::CppSharp.Parser.AST.StatementObsolete _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.StatementObsolete.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                public virtual void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.StatementObsolete __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor(__Instance, 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.StatementClassObsolete Class
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.StatementObsolete.__Internal*) __Instance)->_class;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.StatementObsolete.__Internal*)__Instance)->_class = value;
                    }
                }

                public global::CppSharp.Parser.AST.Declaration Decl
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Declaration __result0;
                        if (((global::CppSharp.Parser.AST.StatementObsolete.__Internal*) __Instance)->decl == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Declaration.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.StatementObsolete.__Internal*) __Instance)->decl))
                            __result0 = (global::CppSharp.Parser.AST.Declaration) global::CppSharp.Parser.AST.Declaration.NativeToManagedMap[((global::CppSharp.Parser.AST.StatementObsolete.__Internal*) __Instance)->decl];
                        else __result0 = global::CppSharp.Parser.AST.Declaration.__CreateInstance(((global::CppSharp.Parser.AST.StatementObsolete.__Internal*) __Instance)->decl);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.StatementObsolete.__Internal*)__Instance)->decl = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public string String
                {
                    get
                    {
                        var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.StatementObsolete.__Internal*) __Instance)->@string));
                        return global::Std.BasicStringExtensions.Data(__basicStringRet0);
                    }

                    set
                    {
                        global::Std.BasicStringExtensions.__Internal.Assign(new global::System.IntPtr(&((global::CppSharp.Parser.AST.StatementObsolete.__Internal*)__Instance)->@string), value);
                    }
                }
            }

            public unsafe partial class ExpressionObsolete : global::CppSharp.Parser.AST.StatementObsolete, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 32)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StatementClassObsolete _class;

                    [FieldOffset(4)]
                    internal global::System.IntPtr decl;

                    [FieldOffset(8)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C @string;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0ExpressionObsolete@AST@CppParser@CppSharp@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4StatementClassObsolete@123@PAVDeclaration@123@@Z")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance, global::System.IntPtr str, global::CppSharp.Parser.AST.StatementClassObsolete Class, global::System.IntPtr decl);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0ExpressionObsolete@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??1ExpressionObsolete@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern void dtor(global::System.IntPtr __instance, int delete);
                }

                internal static new global::CppSharp.Parser.AST.ExpressionObsolete __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.ExpressionObsolete(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.ExpressionObsolete __CreateInstance(global::CppSharp.Parser.AST.ExpressionObsolete.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.ExpressionObsolete(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.ExpressionObsolete.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ExpressionObsolete.__Internal));
                    global::CppSharp.Parser.AST.ExpressionObsolete.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private ExpressionObsolete(global::CppSharp.Parser.AST.ExpressionObsolete.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected ExpressionObsolete(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public ExpressionObsolete(string str, global::CppSharp.Parser.AST.StatementClassObsolete Class, global::CppSharp.Parser.AST.Declaration decl)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ExpressionObsolete.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                    global::Std.BasicStringExtensions.Assign(__basicString0, str);
                    var __arg0 = __basicString0.__Instance;
                    var __arg2 = ReferenceEquals(decl, null) ? global::System.IntPtr.Zero : decl.__Instance;
                    __Internal.ctor(__Instance, __arg0, Class, __arg2);
                    __basicString0.Dispose();
                }

                public ExpressionObsolete(global::CppSharp.Parser.AST.ExpressionObsolete _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ExpressionObsolete.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.StatementObsolete __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor(__Instance, 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }
            }

            public unsafe partial class BinaryOperatorObsolete : global::CppSharp.Parser.AST.ExpressionObsolete, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 64)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StatementClassObsolete _class;

                    [FieldOffset(4)]
                    internal global::System.IntPtr decl;

                    [FieldOffset(8)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C @string;

                    [FieldOffset(32)]
                    internal global::System.IntPtr LHS;

                    [FieldOffset(36)]
                    internal global::System.IntPtr RHS;

                    [FieldOffset(40)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C opcodeStr;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0BinaryOperatorObsolete@AST@CppParser@CppSharp@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAVExpressionObsolete@123@10@Z")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance, global::System.IntPtr str, global::System.IntPtr lhs, global::System.IntPtr rhs, global::System.IntPtr opcodeStr);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0BinaryOperatorObsolete@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??1BinaryOperatorObsolete@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern void dtor(global::System.IntPtr __instance, int delete);
                }

                internal static new global::CppSharp.Parser.AST.BinaryOperatorObsolete __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.BinaryOperatorObsolete(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.BinaryOperatorObsolete __CreateInstance(global::CppSharp.Parser.AST.BinaryOperatorObsolete.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.BinaryOperatorObsolete(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.BinaryOperatorObsolete.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.BinaryOperatorObsolete.__Internal));
                    global::CppSharp.Parser.AST.BinaryOperatorObsolete.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private BinaryOperatorObsolete(global::CppSharp.Parser.AST.BinaryOperatorObsolete.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected BinaryOperatorObsolete(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public BinaryOperatorObsolete(string str, global::CppSharp.Parser.AST.ExpressionObsolete lhs, global::CppSharp.Parser.AST.ExpressionObsolete rhs, string opcodeStr)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.BinaryOperatorObsolete.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                    global::Std.BasicStringExtensions.Assign(__basicString0, str);
                    var __arg0 = __basicString0.__Instance;
                    var __arg1 = ReferenceEquals(lhs, null) ? global::System.IntPtr.Zero : lhs.__Instance;
                    var __arg2 = ReferenceEquals(rhs, null) ? global::System.IntPtr.Zero : rhs.__Instance;
                    var __basicString3 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                    global::Std.BasicStringExtensions.Assign(__basicString3, opcodeStr);
                    var __arg3 = __basicString3.__Instance;
                    __Internal.ctor(__Instance, __arg0, __arg1, __arg2, __arg3);
                    __basicString0.Dispose();
                    __basicString3.Dispose();
                }

                public BinaryOperatorObsolete(global::CppSharp.Parser.AST.BinaryOperatorObsolete _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.BinaryOperatorObsolete.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.StatementObsolete __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor(__Instance, 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.ExpressionObsolete LHS
                {
                    get
                    {
                        global::CppSharp.Parser.AST.ExpressionObsolete __result0;
                        if (((global::CppSharp.Parser.AST.BinaryOperatorObsolete.__Internal*) __Instance)->LHS == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.ExpressionObsolete.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.BinaryOperatorObsolete.__Internal*) __Instance)->LHS))
                            __result0 = (global::CppSharp.Parser.AST.ExpressionObsolete) global::CppSharp.Parser.AST.ExpressionObsolete.NativeToManagedMap[((global::CppSharp.Parser.AST.BinaryOperatorObsolete.__Internal*) __Instance)->LHS];
                        else __result0 = global::CppSharp.Parser.AST.ExpressionObsolete.__CreateInstance(((global::CppSharp.Parser.AST.BinaryOperatorObsolete.__Internal*) __Instance)->LHS);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.BinaryOperatorObsolete.__Internal*)__Instance)->LHS = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.ExpressionObsolete RHS
                {
                    get
                    {
                        global::CppSharp.Parser.AST.ExpressionObsolete __result0;
                        if (((global::CppSharp.Parser.AST.BinaryOperatorObsolete.__Internal*) __Instance)->RHS == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.ExpressionObsolete.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.BinaryOperatorObsolete.__Internal*) __Instance)->RHS))
                            __result0 = (global::CppSharp.Parser.AST.ExpressionObsolete) global::CppSharp.Parser.AST.ExpressionObsolete.NativeToManagedMap[((global::CppSharp.Parser.AST.BinaryOperatorObsolete.__Internal*) __Instance)->RHS];
                        else __result0 = global::CppSharp.Parser.AST.ExpressionObsolete.__CreateInstance(((global::CppSharp.Parser.AST.BinaryOperatorObsolete.__Internal*) __Instance)->RHS);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.BinaryOperatorObsolete.__Internal*)__Instance)->RHS = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public string OpcodeStr
                {
                    get
                    {
                        var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.BinaryOperatorObsolete.__Internal*) __Instance)->opcodeStr));
                        return global::Std.BasicStringExtensions.Data(__basicStringRet0);
                    }

                    set
                    {
                        global::Std.BasicStringExtensions.__Internal.Assign(new global::System.IntPtr(&((global::CppSharp.Parser.AST.BinaryOperatorObsolete.__Internal*)__Instance)->opcodeStr), value);
                    }
                }
            }

            public unsafe partial class CallExprObsolete : global::CppSharp.Parser.AST.ExpressionObsolete, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 44)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StatementClassObsolete _class;

                    [FieldOffset(4)]
                    internal global::System.IntPtr decl;

                    [FieldOffset(8)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C @string;

                    [FieldOffset(32)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_ExpressionObsolete___N_std_S_allocator__S0_ Arguments;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CallExprObsolete@AST@CppParser@CppSharp@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAVDeclaration@123@@Z")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance, global::System.IntPtr str, global::System.IntPtr decl);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CallExprObsolete@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??1CallExprObsolete@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern void dtor(global::System.IntPtr __instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getArguments@CallExprObsolete@AST@CppParser@CppSharp@@QAEPAVExpressionObsolete@234@I@Z")]
                    internal static extern global::System.IntPtr GetArguments(global::System.IntPtr __instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?addArguments@CallExprObsolete@AST@CppParser@CppSharp@@QAEXAAPAVExpressionObsolete@234@@Z")]
                    internal static extern void AddArguments(global::System.IntPtr __instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?clearArguments@CallExprObsolete@AST@CppParser@CppSharp@@QAEXXZ")]
                    internal static extern void ClearArguments(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getArgumentsCount@CallExprObsolete@AST@CppParser@CppSharp@@QAEIXZ")]
                    internal static extern uint GetArgumentsCount(global::System.IntPtr __instance);
                }

                internal static new global::CppSharp.Parser.AST.CallExprObsolete __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CallExprObsolete(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.CallExprObsolete __CreateInstance(global::CppSharp.Parser.AST.CallExprObsolete.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CallExprObsolete(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.CallExprObsolete.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CallExprObsolete.__Internal));
                    global::CppSharp.Parser.AST.CallExprObsolete.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private CallExprObsolete(global::CppSharp.Parser.AST.CallExprObsolete.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected CallExprObsolete(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public CallExprObsolete(string str, global::CppSharp.Parser.AST.Declaration decl)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CallExprObsolete.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                    global::Std.BasicStringExtensions.Assign(__basicString0, str);
                    var __arg0 = __basicString0.__Instance;
                    var __arg1 = ReferenceEquals(decl, null) ? global::System.IntPtr.Zero : decl.__Instance;
                    __Internal.ctor(__Instance, __arg0, __arg1);
                    __basicString0.Dispose();
                }

                public CallExprObsolete(global::CppSharp.Parser.AST.CallExprObsolete _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CallExprObsolete.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.StatementObsolete __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor(__Instance, 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.ExpressionObsolete GetArguments(uint i)
                {
                    var __ret = __Internal.GetArguments(__Instance, i);
                    global::CppSharp.Parser.AST.ExpressionObsolete __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.ExpressionObsolete.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::CppSharp.Parser.AST.ExpressionObsolete) global::CppSharp.Parser.AST.ExpressionObsolete.NativeToManagedMap[__ret];
                    else __result0 = global::CppSharp.Parser.AST.ExpressionObsolete.__CreateInstance(__ret);
                    return __result0;
                }

                public void AddArguments(global::CppSharp.Parser.AST.ExpressionObsolete s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var ____arg0 = s.__Instance;
                    var __arg0 = new global::System.IntPtr(&____arg0);
                    __Internal.AddArguments(__Instance, __arg0);
                }

                public void ClearArguments()
                {
                    __Internal.ClearArguments(__Instance);
                }

                public uint ArgumentsCount
                {
                    get
                    {
                        var __ret = __Internal.GetArgumentsCount(__Instance);
                        return __ret;
                    }
                }
            }

            public unsafe partial class CXXConstructExprObsolete : global::CppSharp.Parser.AST.ExpressionObsolete, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 44)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StatementClassObsolete _class;

                    [FieldOffset(4)]
                    internal global::System.IntPtr decl;

                    [FieldOffset(8)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C @string;

                    [FieldOffset(32)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_ExpressionObsolete___N_std_S_allocator__S0_ Arguments;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CXXConstructExprObsolete@AST@CppParser@CppSharp@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAVDeclaration@123@@Z")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance, global::System.IntPtr str, global::System.IntPtr decl);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CXXConstructExprObsolete@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??1CXXConstructExprObsolete@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern void dtor(global::System.IntPtr __instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getArguments@CXXConstructExprObsolete@AST@CppParser@CppSharp@@QAEPAVExpressionObsolete@234@I@Z")]
                    internal static extern global::System.IntPtr GetArguments(global::System.IntPtr __instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?addArguments@CXXConstructExprObsolete@AST@CppParser@CppSharp@@QAEXAAPAVExpressionObsolete@234@@Z")]
                    internal static extern void AddArguments(global::System.IntPtr __instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?clearArguments@CXXConstructExprObsolete@AST@CppParser@CppSharp@@QAEXXZ")]
                    internal static extern void ClearArguments(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getArgumentsCount@CXXConstructExprObsolete@AST@CppParser@CppSharp@@QAEIXZ")]
                    internal static extern uint GetArgumentsCount(global::System.IntPtr __instance);
                }

                internal static new global::CppSharp.Parser.AST.CXXConstructExprObsolete __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CXXConstructExprObsolete(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.CXXConstructExprObsolete __CreateInstance(global::CppSharp.Parser.AST.CXXConstructExprObsolete.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CXXConstructExprObsolete(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.CXXConstructExprObsolete.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXConstructExprObsolete.__Internal));
                    global::CppSharp.Parser.AST.CXXConstructExprObsolete.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private CXXConstructExprObsolete(global::CppSharp.Parser.AST.CXXConstructExprObsolete.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected CXXConstructExprObsolete(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public CXXConstructExprObsolete(string str, global::CppSharp.Parser.AST.Declaration decl)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXConstructExprObsolete.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                    global::Std.BasicStringExtensions.Assign(__basicString0, str);
                    var __arg0 = __basicString0.__Instance;
                    var __arg1 = ReferenceEquals(decl, null) ? global::System.IntPtr.Zero : decl.__Instance;
                    __Internal.ctor(__Instance, __arg0, __arg1);
                    __basicString0.Dispose();
                }

                public CXXConstructExprObsolete(global::CppSharp.Parser.AST.CXXConstructExprObsolete _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXConstructExprObsolete.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.StatementObsolete __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor(__Instance, 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.ExpressionObsolete GetArguments(uint i)
                {
                    var __ret = __Internal.GetArguments(__Instance, i);
                    global::CppSharp.Parser.AST.ExpressionObsolete __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.ExpressionObsolete.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::CppSharp.Parser.AST.ExpressionObsolete) global::CppSharp.Parser.AST.ExpressionObsolete.NativeToManagedMap[__ret];
                    else __result0 = global::CppSharp.Parser.AST.ExpressionObsolete.__CreateInstance(__ret);
                    return __result0;
                }

                public void AddArguments(global::CppSharp.Parser.AST.ExpressionObsolete s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var ____arg0 = s.__Instance;
                    var __arg0 = new global::System.IntPtr(&____arg0);
                    __Internal.AddArguments(__Instance, __arg0);
                }

                public void ClearArguments()
                {
                    __Internal.ClearArguments(__Instance);
                }

                public uint ArgumentsCount
                {
                    get
                    {
                        var __ret = __Internal.GetArgumentsCount(__Instance);
                        return __ret;
                    }
                }
            }

            public unsafe partial class Parameter : global::CppSharp.Parser.AST.Declaration, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 172)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.DeclarationKind kind;

                    [FieldOffset(4)]
                    internal int maxFieldAlignment;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.AccessSpecifier access;

                    [FieldOffset(12)]
                    internal global::System.IntPtr _namespace;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal location;

                    [FieldOffset(20)]
                    internal int lineNumberStart;

                    [FieldOffset(24)]
                    internal int lineNumberEnd;

                    [FieldOffset(28)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C name;

                    [FieldOffset(52)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C USR;

                    [FieldOffset(76)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C debugText;

                    [FieldOffset(100)]
                    internal byte isIncomplete;

                    [FieldOffset(101)]
                    internal byte isDependent;

                    [FieldOffset(102)]
                    internal byte isImplicit;

                    [FieldOffset(103)]
                    internal byte isInvalid;

                    [FieldOffset(104)]
                    internal byte isDeprecated;

                    [FieldOffset(108)]
                    internal global::System.IntPtr completeDeclaration;

                    [FieldOffset(112)]
                    internal uint definitionOrder;

                    [FieldOffset(116)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_PreprocessedEntity___N_std_S_allocator__S0_ PreprocessedEntities;

                    [FieldOffset(128)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Declaration___N_std_S_allocator__S0_ Redeclarations;

                    [FieldOffset(140)]
                    internal global::System.IntPtr originalPtr;

                    [FieldOffset(144)]
                    internal global::System.IntPtr comment;

                    [FieldOffset(148)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal qualifiedType;

                    [FieldOffset(156)]
                    internal byte isIndirect;

                    [FieldOffset(157)]
                    internal byte hasDefaultValue;

                    [FieldOffset(160)]
                    internal uint index;

                    [FieldOffset(164)]
                    internal global::System.IntPtr defaultArgument;

                    [FieldOffset(168)]
                    internal global::System.IntPtr defaultValue;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0Parameter@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0Parameter@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??1Parameter@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern void dtor(global::System.IntPtr __instance, int delete);
                }

                internal static new global::CppSharp.Parser.AST.Parameter __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.Parameter(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.Parameter __CreateInstance(global::CppSharp.Parser.AST.Parameter.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.Parameter(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.Parameter.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Parameter.__Internal));
                    global::CppSharp.Parser.AST.Parameter.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private Parameter(global::CppSharp.Parser.AST.Parameter.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected Parameter(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public Parameter()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Parameter.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public Parameter(global::CppSharp.Parser.AST.Parameter _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Parameter.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Declaration __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor(__Instance, 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.QualifiedType QualifiedType
                {
                    get
                    {
                        return global::CppSharp.Parser.AST.QualifiedType.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.Parameter.__Internal*) __Instance)->qualifiedType));
                    }

                    set
                    {
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                        ((global::CppSharp.Parser.AST.Parameter.__Internal*)__Instance)->qualifiedType = *(global::CppSharp.Parser.AST.QualifiedType.__Internal*) value.__Instance;
                    }
                }

                public bool IsIndirect
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Parameter.__Internal*) __Instance)->isIndirect != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Parameter.__Internal*)__Instance)->isIndirect = (byte) (value ? 1 : 0);
                    }
                }

                public bool HasDefaultValue
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Parameter.__Internal*) __Instance)->hasDefaultValue != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Parameter.__Internal*)__Instance)->hasDefaultValue = (byte) (value ? 1 : 0);
                    }
                }

                public uint Index
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Parameter.__Internal*) __Instance)->index;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Parameter.__Internal*)__Instance)->index = value;
                    }
                }

                public global::CppSharp.Parser.AST.ExpressionObsolete DefaultArgument
                {
                    get
                    {
                        global::CppSharp.Parser.AST.ExpressionObsolete __result0;
                        if (((global::CppSharp.Parser.AST.Parameter.__Internal*) __Instance)->defaultArgument == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.ExpressionObsolete.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.Parameter.__Internal*) __Instance)->defaultArgument))
                            __result0 = (global::CppSharp.Parser.AST.ExpressionObsolete) global::CppSharp.Parser.AST.ExpressionObsolete.NativeToManagedMap[((global::CppSharp.Parser.AST.Parameter.__Internal*) __Instance)->defaultArgument];
                        else __result0 = global::CppSharp.Parser.AST.ExpressionObsolete.__CreateInstance(((global::CppSharp.Parser.AST.Parameter.__Internal*) __Instance)->defaultArgument);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Parameter.__Internal*)__Instance)->defaultArgument = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Expr DefaultValue
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.Parameter.__Internal*) __Instance)->defaultValue == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.Parameter.__Internal*) __Instance)->defaultValue))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.Parameter.__Internal*) __Instance)->defaultValue];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.Parameter.__Internal*) __Instance)->defaultValue);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Parameter.__Internal*)__Instance)->defaultValue = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }
            }

            public unsafe partial class Function : global::CppSharp.Parser.AST.DeclarationContext, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 400)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.DeclarationKind kind;

                    [FieldOffset(4)]
                    internal int maxFieldAlignment;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.AccessSpecifier access;

                    [FieldOffset(12)]
                    internal global::System.IntPtr _namespace;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal location;

                    [FieldOffset(20)]
                    internal int lineNumberStart;

                    [FieldOffset(24)]
                    internal int lineNumberEnd;

                    [FieldOffset(28)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C name;

                    [FieldOffset(52)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C USR;

                    [FieldOffset(76)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C debugText;

                    [FieldOffset(100)]
                    internal byte isIncomplete;

                    [FieldOffset(101)]
                    internal byte isDependent;

                    [FieldOffset(102)]
                    internal byte isImplicit;

                    [FieldOffset(103)]
                    internal byte isInvalid;

                    [FieldOffset(104)]
                    internal byte isDeprecated;

                    [FieldOffset(108)]
                    internal global::System.IntPtr completeDeclaration;

                    [FieldOffset(112)]
                    internal uint definitionOrder;

                    [FieldOffset(116)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_PreprocessedEntity___N_std_S_allocator__S0_ PreprocessedEntities;

                    [FieldOffset(128)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Declaration___N_std_S_allocator__S0_ Redeclarations;

                    [FieldOffset(140)]
                    internal global::System.IntPtr originalPtr;

                    [FieldOffset(144)]
                    internal global::System.IntPtr comment;

                    [FieldOffset(148)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Namespace___N_std_S_allocator__S0_ Namespaces;

                    [FieldOffset(160)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Enumeration___N_std_S_allocator__S0_ Enums;

                    [FieldOffset(172)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Function___N_std_S_allocator__S0_ Functions;

                    [FieldOffset(184)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Class___N_std_S_allocator__S0_ Classes;

                    [FieldOffset(196)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Template___N_std_S_allocator__S0_ Templates;

                    [FieldOffset(208)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_TypedefDecl___N_std_S_allocator__S0_ Typedefs;

                    [FieldOffset(220)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_TypeAlias___N_std_S_allocator__S0_ TypeAliases;

                    [FieldOffset(232)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Variable___N_std_S_allocator__S0_ Variables;

                    [FieldOffset(244)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Friend___N_std_S_allocator__S0_ Friends;

                    [FieldOffset(256)]
                    internal global::Std.Map.__Internalc__N_std_S_map____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C____N_CppSharp_N_CppParser_N_AST_S_Declaration___N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__S3_ anonymous;

                    [FieldOffset(264)]
                    internal byte isAnonymous;

                    [FieldOffset(268)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal returnType;

                    [FieldOffset(276)]
                    internal byte isReturnIndirect;

                    [FieldOffset(277)]
                    internal byte hasThisReturn;

                    [FieldOffset(278)]
                    internal byte isConstExpr;

                    [FieldOffset(279)]
                    internal byte isVariadic;

                    [FieldOffset(280)]
                    internal byte isInline;

                    [FieldOffset(281)]
                    internal byte isPure;

                    [FieldOffset(282)]
                    internal byte isDeleted;

                    [FieldOffset(283)]
                    internal byte isDefaulted;

                    [FieldOffset(284)]
                    internal global::CppSharp.Parser.AST.FriendKind friendKind;

                    [FieldOffset(288)]
                    internal global::CppSharp.Parser.AST.CXXOperatorKind operatorKind;

                    [FieldOffset(292)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C mangled;

                    [FieldOffset(316)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C signature;

                    [FieldOffset(340)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C body;

                    [FieldOffset(364)]
                    internal global::System.IntPtr bodyStmt;

                    [FieldOffset(368)]
                    internal global::CppSharp.Parser.AST.CallingConvention callingConvention;

                    [FieldOffset(372)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Parameter___N_std_S_allocator__S0_ Parameters;

                    [FieldOffset(384)]
                    internal global::System.IntPtr specializationInfo;

                    [FieldOffset(388)]
                    internal global::System.IntPtr instantiatedFrom;

                    [FieldOffset(392)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal qualifiedType;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0Function@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0Function@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??1Function@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern void dtor(global::System.IntPtr __instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getParameters@Function@AST@CppParser@CppSharp@@QAEPAVParameter@234@I@Z")]
                    internal static extern global::System.IntPtr GetParameters(global::System.IntPtr __instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?addParameters@Function@AST@CppParser@CppSharp@@QAEXAAPAVParameter@234@@Z")]
                    internal static extern void AddParameters(global::System.IntPtr __instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?clearParameters@Function@AST@CppParser@CppSharp@@QAEXXZ")]
                    internal static extern void ClearParameters(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getParametersCount@Function@AST@CppParser@CppSharp@@QAEIXZ")]
                    internal static extern uint GetParametersCount(global::System.IntPtr __instance);
                }

                internal static new global::CppSharp.Parser.AST.Function __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.Function(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.Function __CreateInstance(global::CppSharp.Parser.AST.Function.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.Function(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.Function.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Function.__Internal));
                    global::CppSharp.Parser.AST.Function.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private Function(global::CppSharp.Parser.AST.Function.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected Function(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public Function()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Function.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public Function(global::CppSharp.Parser.AST.Function _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Function.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Declaration __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor(__Instance, 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.Parameter GetParameters(uint i)
                {
                    var __ret = __Internal.GetParameters(__Instance, i);
                    global::CppSharp.Parser.AST.Parameter __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.Parameter.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::CppSharp.Parser.AST.Parameter) global::CppSharp.Parser.AST.Parameter.NativeToManagedMap[__ret];
                    else __result0 = global::CppSharp.Parser.AST.Parameter.__CreateInstance(__ret);
                    return __result0;
                }

                public void AddParameters(global::CppSharp.Parser.AST.Parameter s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var ____arg0 = s.__Instance;
                    var __arg0 = new global::System.IntPtr(&____arg0);
                    __Internal.AddParameters(__Instance, __arg0);
                }

                public void ClearParameters()
                {
                    __Internal.ClearParameters(__Instance);
                }

                public global::CppSharp.Parser.AST.QualifiedType ReturnType
                {
                    get
                    {
                        return global::CppSharp.Parser.AST.QualifiedType.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.Function.__Internal*) __Instance)->returnType));
                    }

                    set
                    {
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                        ((global::CppSharp.Parser.AST.Function.__Internal*)__Instance)->returnType = *(global::CppSharp.Parser.AST.QualifiedType.__Internal*) value.__Instance;
                    }
                }

                public bool IsReturnIndirect
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Function.__Internal*) __Instance)->isReturnIndirect != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Function.__Internal*)__Instance)->isReturnIndirect = (byte) (value ? 1 : 0);
                    }
                }

                public bool HasThisReturn
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Function.__Internal*) __Instance)->hasThisReturn != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Function.__Internal*)__Instance)->hasThisReturn = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsConstExpr
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Function.__Internal*) __Instance)->isConstExpr != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Function.__Internal*)__Instance)->isConstExpr = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsVariadic
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Function.__Internal*) __Instance)->isVariadic != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Function.__Internal*)__Instance)->isVariadic = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsInline
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Function.__Internal*) __Instance)->isInline != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Function.__Internal*)__Instance)->isInline = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsPure
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Function.__Internal*) __Instance)->isPure != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Function.__Internal*)__Instance)->isPure = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsDeleted
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Function.__Internal*) __Instance)->isDeleted != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Function.__Internal*)__Instance)->isDeleted = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsDefaulted
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Function.__Internal*) __Instance)->isDefaulted != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Function.__Internal*)__Instance)->isDefaulted = (byte) (value ? 1 : 0);
                    }
                }

                public global::CppSharp.Parser.AST.FriendKind FriendKind
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Function.__Internal*) __Instance)->friendKind;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Function.__Internal*)__Instance)->friendKind = value;
                    }
                }

                public global::CppSharp.Parser.AST.CXXOperatorKind OperatorKind
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Function.__Internal*) __Instance)->operatorKind;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Function.__Internal*)__Instance)->operatorKind = value;
                    }
                }

                public string Mangled
                {
                    get
                    {
                        var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.Function.__Internal*) __Instance)->mangled));
                        return global::Std.BasicStringExtensions.Data(__basicStringRet0);
                    }

                    set
                    {
                        global::Std.BasicStringExtensions.__Internal.Assign(new global::System.IntPtr(&((global::CppSharp.Parser.AST.Function.__Internal*)__Instance)->mangled), value);
                    }
                }

                public string Signature
                {
                    get
                    {
                        var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.Function.__Internal*) __Instance)->signature));
                        return global::Std.BasicStringExtensions.Data(__basicStringRet0);
                    }

                    set
                    {
                        global::Std.BasicStringExtensions.__Internal.Assign(new global::System.IntPtr(&((global::CppSharp.Parser.AST.Function.__Internal*)__Instance)->signature), value);
                    }
                }

                public string Body
                {
                    get
                    {
                        var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.Function.__Internal*) __Instance)->body));
                        return global::Std.BasicStringExtensions.Data(__basicStringRet0);
                    }

                    set
                    {
                        global::Std.BasicStringExtensions.__Internal.Assign(new global::System.IntPtr(&((global::CppSharp.Parser.AST.Function.__Internal*)__Instance)->body), value);
                    }
                }

                public global::CppSharp.Parser.AST.Stmt BodyStmt
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Stmt __result0;
                        if (((global::CppSharp.Parser.AST.Function.__Internal*) __Instance)->bodyStmt == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Stmt.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.Function.__Internal*) __Instance)->bodyStmt))
                            __result0 = (global::CppSharp.Parser.AST.Stmt) global::CppSharp.Parser.AST.Stmt.NativeToManagedMap[((global::CppSharp.Parser.AST.Function.__Internal*) __Instance)->bodyStmt];
                        else __result0 = global::CppSharp.Parser.AST.Stmt.__CreateInstance(((global::CppSharp.Parser.AST.Function.__Internal*) __Instance)->bodyStmt);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Function.__Internal*)__Instance)->bodyStmt = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.CallingConvention CallingConvention
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Function.__Internal*) __Instance)->callingConvention;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Function.__Internal*)__Instance)->callingConvention = value;
                    }
                }

                public global::CppSharp.Parser.AST.FunctionTemplateSpecialization SpecializationInfo
                {
                    get
                    {
                        global::CppSharp.Parser.AST.FunctionTemplateSpecialization __result0;
                        if (((global::CppSharp.Parser.AST.Function.__Internal*) __Instance)->specializationInfo == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.FunctionTemplateSpecialization.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.Function.__Internal*) __Instance)->specializationInfo))
                            __result0 = (global::CppSharp.Parser.AST.FunctionTemplateSpecialization) global::CppSharp.Parser.AST.FunctionTemplateSpecialization.NativeToManagedMap[((global::CppSharp.Parser.AST.Function.__Internal*) __Instance)->specializationInfo];
                        else __result0 = global::CppSharp.Parser.AST.FunctionTemplateSpecialization.__CreateInstance(((global::CppSharp.Parser.AST.Function.__Internal*) __Instance)->specializationInfo);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Function.__Internal*)__Instance)->specializationInfo = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Function InstantiatedFrom
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Function __result0;
                        if (((global::CppSharp.Parser.AST.Function.__Internal*) __Instance)->instantiatedFrom == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Function.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.Function.__Internal*) __Instance)->instantiatedFrom))
                            __result0 = (global::CppSharp.Parser.AST.Function) global::CppSharp.Parser.AST.Function.NativeToManagedMap[((global::CppSharp.Parser.AST.Function.__Internal*) __Instance)->instantiatedFrom];
                        else __result0 = global::CppSharp.Parser.AST.Function.__CreateInstance(((global::CppSharp.Parser.AST.Function.__Internal*) __Instance)->instantiatedFrom);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Function.__Internal*)__Instance)->instantiatedFrom = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.QualifiedType QualifiedType
                {
                    get
                    {
                        return global::CppSharp.Parser.AST.QualifiedType.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.Function.__Internal*) __Instance)->qualifiedType));
                    }

                    set
                    {
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                        ((global::CppSharp.Parser.AST.Function.__Internal*)__Instance)->qualifiedType = *(global::CppSharp.Parser.AST.QualifiedType.__Internal*) value.__Instance;
                    }
                }

                public uint ParametersCount
                {
                    get
                    {
                        var __ret = __Internal.GetParametersCount(__Instance);
                        return __ret;
                    }
                }
            }

            public unsafe partial class Method : global::CppSharp.Parser.AST.Function, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 436)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.DeclarationKind kind;

                    [FieldOffset(4)]
                    internal int maxFieldAlignment;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.AccessSpecifier access;

                    [FieldOffset(12)]
                    internal global::System.IntPtr _namespace;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal location;

                    [FieldOffset(20)]
                    internal int lineNumberStart;

                    [FieldOffset(24)]
                    internal int lineNumberEnd;

                    [FieldOffset(28)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C name;

                    [FieldOffset(52)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C USR;

                    [FieldOffset(76)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C debugText;

                    [FieldOffset(100)]
                    internal byte isIncomplete;

                    [FieldOffset(101)]
                    internal byte isDependent;

                    [FieldOffset(102)]
                    internal byte isImplicit;

                    [FieldOffset(103)]
                    internal byte isInvalid;

                    [FieldOffset(104)]
                    internal byte isDeprecated;

                    [FieldOffset(108)]
                    internal global::System.IntPtr completeDeclaration;

                    [FieldOffset(112)]
                    internal uint definitionOrder;

                    [FieldOffset(116)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_PreprocessedEntity___N_std_S_allocator__S0_ PreprocessedEntities;

                    [FieldOffset(128)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Declaration___N_std_S_allocator__S0_ Redeclarations;

                    [FieldOffset(140)]
                    internal global::System.IntPtr originalPtr;

                    [FieldOffset(144)]
                    internal global::System.IntPtr comment;

                    [FieldOffset(148)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Namespace___N_std_S_allocator__S0_ Namespaces;

                    [FieldOffset(160)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Enumeration___N_std_S_allocator__S0_ Enums;

                    [FieldOffset(172)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Function___N_std_S_allocator__S0_ Functions;

                    [FieldOffset(184)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Class___N_std_S_allocator__S0_ Classes;

                    [FieldOffset(196)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Template___N_std_S_allocator__S0_ Templates;

                    [FieldOffset(208)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_TypedefDecl___N_std_S_allocator__S0_ Typedefs;

                    [FieldOffset(220)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_TypeAlias___N_std_S_allocator__S0_ TypeAliases;

                    [FieldOffset(232)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Variable___N_std_S_allocator__S0_ Variables;

                    [FieldOffset(244)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Friend___N_std_S_allocator__S0_ Friends;

                    [FieldOffset(256)]
                    internal global::Std.Map.__Internalc__N_std_S_map____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C____N_CppSharp_N_CppParser_N_AST_S_Declaration___N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__S3_ anonymous;

                    [FieldOffset(264)]
                    internal byte isAnonymous;

                    [FieldOffset(268)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal returnType;

                    [FieldOffset(276)]
                    internal byte isReturnIndirect;

                    [FieldOffset(277)]
                    internal byte hasThisReturn;

                    [FieldOffset(278)]
                    internal byte isConstExpr;

                    [FieldOffset(279)]
                    internal byte isVariadic;

                    [FieldOffset(280)]
                    internal byte isInline;

                    [FieldOffset(281)]
                    internal byte isPure;

                    [FieldOffset(282)]
                    internal byte isDeleted;

                    [FieldOffset(283)]
                    internal byte isDefaulted;

                    [FieldOffset(284)]
                    internal global::CppSharp.Parser.AST.FriendKind friendKind;

                    [FieldOffset(288)]
                    internal global::CppSharp.Parser.AST.CXXOperatorKind operatorKind;

                    [FieldOffset(292)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C mangled;

                    [FieldOffset(316)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C signature;

                    [FieldOffset(340)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C body;

                    [FieldOffset(364)]
                    internal global::System.IntPtr bodyStmt;

                    [FieldOffset(368)]
                    internal global::CppSharp.Parser.AST.CallingConvention callingConvention;

                    [FieldOffset(372)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Parameter___N_std_S_allocator__S0_ Parameters;

                    [FieldOffset(384)]
                    internal global::System.IntPtr specializationInfo;

                    [FieldOffset(388)]
                    internal global::System.IntPtr instantiatedFrom;

                    [FieldOffset(392)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal qualifiedType;

                    [FieldOffset(400)]
                    internal byte isVirtual;

                    [FieldOffset(401)]
                    internal byte isStatic;

                    [FieldOffset(402)]
                    internal byte isConst;

                    [FieldOffset(403)]
                    internal byte isExplicit;

                    [FieldOffset(404)]
                    internal global::CppSharp.Parser.AST.CXXMethodKind methodKind;

                    [FieldOffset(408)]
                    internal byte isDefaultConstructor;

                    [FieldOffset(409)]
                    internal byte isCopyConstructor;

                    [FieldOffset(410)]
                    internal byte isMoveConstructor;

                    [FieldOffset(412)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal conversionType;

                    [FieldOffset(420)]
                    internal global::CppSharp.Parser.AST.RefQualifierKind refQualifier;

                    [FieldOffset(424)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Method___N_std_S_allocator__S0_ OverriddenMethods;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0Method@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0Method@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??1Method@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern void dtor(global::System.IntPtr __instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getOverriddenMethods@Method@AST@CppParser@CppSharp@@QAEPAV1234@I@Z")]
                    internal static extern global::System.IntPtr GetOverriddenMethods(global::System.IntPtr __instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?addOverriddenMethods@Method@AST@CppParser@CppSharp@@QAEXAAPAV1234@@Z")]
                    internal static extern void AddOverriddenMethods(global::System.IntPtr __instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?clearOverriddenMethods@Method@AST@CppParser@CppSharp@@QAEXXZ")]
                    internal static extern void ClearOverriddenMethods(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getOverriddenMethodsCount@Method@AST@CppParser@CppSharp@@QAEIXZ")]
                    internal static extern uint GetOverriddenMethodsCount(global::System.IntPtr __instance);
                }

                internal static new global::CppSharp.Parser.AST.Method __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.Method(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.Method __CreateInstance(global::CppSharp.Parser.AST.Method.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.Method(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.Method.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Method.__Internal));
                    global::CppSharp.Parser.AST.Method.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private Method(global::CppSharp.Parser.AST.Method.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected Method(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public Method()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Method.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public Method(global::CppSharp.Parser.AST.Method _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Method.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Declaration __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor(__Instance, 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.Method GetOverriddenMethods(uint i)
                {
                    var __ret = __Internal.GetOverriddenMethods(__Instance, i);
                    global::CppSharp.Parser.AST.Method __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.Method.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::CppSharp.Parser.AST.Method) global::CppSharp.Parser.AST.Method.NativeToManagedMap[__ret];
                    else __result0 = global::CppSharp.Parser.AST.Method.__CreateInstance(__ret);
                    return __result0;
                }

                public void AddOverriddenMethods(global::CppSharp.Parser.AST.Method s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var ____arg0 = s.__Instance;
                    var __arg0 = new global::System.IntPtr(&____arg0);
                    __Internal.AddOverriddenMethods(__Instance, __arg0);
                }

                public void ClearOverriddenMethods()
                {
                    __Internal.ClearOverriddenMethods(__Instance);
                }

                public bool IsVirtual
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Method.__Internal*) __Instance)->isVirtual != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Method.__Internal*)__Instance)->isVirtual = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsStatic
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Method.__Internal*) __Instance)->isStatic != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Method.__Internal*)__Instance)->isStatic = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsConst
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Method.__Internal*) __Instance)->isConst != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Method.__Internal*)__Instance)->isConst = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsExplicit
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Method.__Internal*) __Instance)->isExplicit != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Method.__Internal*)__Instance)->isExplicit = (byte) (value ? 1 : 0);
                    }
                }

                public global::CppSharp.Parser.AST.CXXMethodKind MethodKind
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Method.__Internal*) __Instance)->methodKind;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Method.__Internal*)__Instance)->methodKind = value;
                    }
                }

                public bool IsDefaultConstructor
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Method.__Internal*) __Instance)->isDefaultConstructor != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Method.__Internal*)__Instance)->isDefaultConstructor = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsCopyConstructor
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Method.__Internal*) __Instance)->isCopyConstructor != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Method.__Internal*)__Instance)->isCopyConstructor = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsMoveConstructor
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Method.__Internal*) __Instance)->isMoveConstructor != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Method.__Internal*)__Instance)->isMoveConstructor = (byte) (value ? 1 : 0);
                    }
                }

                public global::CppSharp.Parser.AST.QualifiedType ConversionType
                {
                    get
                    {
                        return global::CppSharp.Parser.AST.QualifiedType.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.Method.__Internal*) __Instance)->conversionType));
                    }

                    set
                    {
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                        ((global::CppSharp.Parser.AST.Method.__Internal*)__Instance)->conversionType = *(global::CppSharp.Parser.AST.QualifiedType.__Internal*) value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.RefQualifierKind RefQualifier
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Method.__Internal*) __Instance)->refQualifier;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Method.__Internal*)__Instance)->refQualifier = value;
                    }
                }

                public uint OverriddenMethodsCount
                {
                    get
                    {
                        var __ret = __Internal.GetOverriddenMethodsCount(__Instance);
                        return __ret;
                    }
                }
            }

            public unsafe partial class Enumeration : global::CppSharp.Parser.AST.DeclarationContext, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 292)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.DeclarationKind kind;

                    [FieldOffset(4)]
                    internal int maxFieldAlignment;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.AccessSpecifier access;

                    [FieldOffset(12)]
                    internal global::System.IntPtr _namespace;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal location;

                    [FieldOffset(20)]
                    internal int lineNumberStart;

                    [FieldOffset(24)]
                    internal int lineNumberEnd;

                    [FieldOffset(28)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C name;

                    [FieldOffset(52)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C USR;

                    [FieldOffset(76)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C debugText;

                    [FieldOffset(100)]
                    internal byte isIncomplete;

                    [FieldOffset(101)]
                    internal byte isDependent;

                    [FieldOffset(102)]
                    internal byte isImplicit;

                    [FieldOffset(103)]
                    internal byte isInvalid;

                    [FieldOffset(104)]
                    internal byte isDeprecated;

                    [FieldOffset(108)]
                    internal global::System.IntPtr completeDeclaration;

                    [FieldOffset(112)]
                    internal uint definitionOrder;

                    [FieldOffset(116)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_PreprocessedEntity___N_std_S_allocator__S0_ PreprocessedEntities;

                    [FieldOffset(128)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Declaration___N_std_S_allocator__S0_ Redeclarations;

                    [FieldOffset(140)]
                    internal global::System.IntPtr originalPtr;

                    [FieldOffset(144)]
                    internal global::System.IntPtr comment;

                    [FieldOffset(148)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Namespace___N_std_S_allocator__S0_ Namespaces;

                    [FieldOffset(160)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Enumeration___N_std_S_allocator__S0_ Enums;

                    [FieldOffset(172)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Function___N_std_S_allocator__S0_ Functions;

                    [FieldOffset(184)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Class___N_std_S_allocator__S0_ Classes;

                    [FieldOffset(196)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Template___N_std_S_allocator__S0_ Templates;

                    [FieldOffset(208)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_TypedefDecl___N_std_S_allocator__S0_ Typedefs;

                    [FieldOffset(220)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_TypeAlias___N_std_S_allocator__S0_ TypeAliases;

                    [FieldOffset(232)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Variable___N_std_S_allocator__S0_ Variables;

                    [FieldOffset(244)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Friend___N_std_S_allocator__S0_ Friends;

                    [FieldOffset(256)]
                    internal global::Std.Map.__Internalc__N_std_S_map____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C____N_CppSharp_N_CppParser_N_AST_S_Declaration___N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__S3_ anonymous;

                    [FieldOffset(264)]
                    internal byte isAnonymous;

                    [FieldOffset(268)]
                    internal global::CppSharp.Parser.AST.Enumeration.EnumModifiers modifiers;

                    [FieldOffset(272)]
                    internal global::System.IntPtr type;

                    [FieldOffset(276)]
                    internal global::System.IntPtr builtinType;

                    [FieldOffset(280)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Enumeration_S_Item___N_std_S_allocator__S0_ Items;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0Enumeration@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0Enumeration@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??1Enumeration@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern void dtor(global::System.IntPtr __instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getItems@Enumeration@AST@CppParser@CppSharp@@QAEPAVItem@1234@I@Z")]
                    internal static extern global::System.IntPtr GetItems(global::System.IntPtr __instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?addItems@Enumeration@AST@CppParser@CppSharp@@QAEXAAPAVItem@1234@@Z")]
                    internal static extern void AddItems(global::System.IntPtr __instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?clearItems@Enumeration@AST@CppParser@CppSharp@@QAEXXZ")]
                    internal static extern void ClearItems(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?FindItemByName@Enumeration@AST@CppParser@CppSharp@@QAEPAVItem@1234@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
                    internal static extern global::System.IntPtr FindItemByName(global::System.IntPtr __instance, global::System.IntPtr Name);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getItemsCount@Enumeration@AST@CppParser@CppSharp@@QAEIXZ")]
                    internal static extern uint GetItemsCount(global::System.IntPtr __instance);
                }

                [Flags]
                public enum EnumModifiers
                {
                    Anonymous = 1,
                    Scoped = 2,
                    Flags = 4
                }

                public unsafe partial class Item : global::CppSharp.Parser.AST.Declaration, IDisposable
                {
                    [StructLayout(LayoutKind.Explicit, Size = 184)]
                    public new partial struct __Internal
                    {
                        [FieldOffset(0)]
                        internal global::CppSharp.Parser.AST.DeclarationKind kind;

                        [FieldOffset(4)]
                        internal int maxFieldAlignment;

                        [FieldOffset(8)]
                        internal global::CppSharp.Parser.AST.AccessSpecifier access;

                        [FieldOffset(12)]
                        internal global::System.IntPtr _namespace;

                        [FieldOffset(16)]
                        internal global::CppSharp.Parser.SourceLocation.__Internal location;

                        [FieldOffset(20)]
                        internal int lineNumberStart;

                        [FieldOffset(24)]
                        internal int lineNumberEnd;

                        [FieldOffset(28)]
                        internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C name;

                        [FieldOffset(52)]
                        internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C USR;

                        [FieldOffset(76)]
                        internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C debugText;

                        [FieldOffset(100)]
                        internal byte isIncomplete;

                        [FieldOffset(101)]
                        internal byte isDependent;

                        [FieldOffset(102)]
                        internal byte isImplicit;

                        [FieldOffset(103)]
                        internal byte isInvalid;

                        [FieldOffset(104)]
                        internal byte isDeprecated;

                        [FieldOffset(108)]
                        internal global::System.IntPtr completeDeclaration;

                        [FieldOffset(112)]
                        internal uint definitionOrder;

                        [FieldOffset(116)]
                        internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_PreprocessedEntity___N_std_S_allocator__S0_ PreprocessedEntities;

                        [FieldOffset(128)]
                        internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Declaration___N_std_S_allocator__S0_ Redeclarations;

                        [FieldOffset(140)]
                        internal global::System.IntPtr originalPtr;

                        [FieldOffset(144)]
                        internal global::System.IntPtr comment;

                        [FieldOffset(148)]
                        internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C expression;

                        [FieldOffset(176)]
                        internal ulong value;

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                            EntryPoint="??0Item@Enumeration@AST@CppParser@CppSharp@@QAE@XZ")]
                        internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                            EntryPoint="??0Item@Enumeration@AST@CppParser@CppSharp@@QAE@ABV01234@@Z")]
                        internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                            EntryPoint="??1Item@Enumeration@AST@CppParser@CppSharp@@QAE@XZ")]
                        internal static extern void dtor(global::System.IntPtr __instance, int delete);
                    }

                    internal static new global::CppSharp.Parser.AST.Enumeration.Item __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                    {
                        return new global::CppSharp.Parser.AST.Enumeration.Item(native.ToPointer(), skipVTables);
                    }

                    internal static global::CppSharp.Parser.AST.Enumeration.Item __CreateInstance(global::CppSharp.Parser.AST.Enumeration.Item.__Internal native, bool skipVTables = false)
                    {
                        return new global::CppSharp.Parser.AST.Enumeration.Item(native, skipVTables);
                    }

                    private static void* __CopyValue(global::CppSharp.Parser.AST.Enumeration.Item.__Internal native)
                    {
                        var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Enumeration.Item.__Internal));
                        global::CppSharp.Parser.AST.Enumeration.Item.__Internal.cctor(ret, new global::System.IntPtr(&native));
                        return ret.ToPointer();
                    }

                    private Item(global::CppSharp.Parser.AST.Enumeration.Item.__Internal native, bool skipVTables = false)
                        : this(__CopyValue(native), skipVTables)
                    {
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                    }

                    protected Item(void* native, bool skipVTables = false)
                        : base((void*) null)
                    {
                        if (native == null)
                            return;
                        __Instance = new global::System.IntPtr(native);
                    }

                    public Item()
                        : this((void*) null)
                    {
                        __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Enumeration.Item.__Internal));
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                        __Internal.ctor(__Instance);
                    }

                    public Item(global::CppSharp.Parser.AST.Enumeration.Item _0)
                        : this((void*) null)
                    {
                        __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Enumeration.Item.__Internal));
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                        if (ReferenceEquals(_0, null))
                            throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                        var __arg0 = _0.__Instance;
                        __Internal.cctor(__Instance, __arg0);
                    }

                    public override void Dispose(bool disposing)
                    {
                        if (__Instance == IntPtr.Zero)
                            return;
                        global::CppSharp.Parser.AST.Declaration __dummy;
                        NativeToManagedMap.TryRemove(__Instance, out __dummy);
                        if (disposing)
                            __Internal.dtor(__Instance, 0);
                        if (__ownsNativeInstance)
                            Marshal.FreeHGlobal(__Instance);
                        __Instance = IntPtr.Zero;
                    }

                    public string Expression
                    {
                        get
                        {
                            var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.Enumeration.Item.__Internal*) __Instance)->expression));
                            return global::Std.BasicStringExtensions.Data(__basicStringRet0);
                        }

                        set
                        {
                            global::Std.BasicStringExtensions.__Internal.Assign(new global::System.IntPtr(&((global::CppSharp.Parser.AST.Enumeration.Item.__Internal*)__Instance)->expression), value);
                        }
                    }

                    public ulong Value
                    {
                        get
                        {
                            return ((global::CppSharp.Parser.AST.Enumeration.Item.__Internal*) __Instance)->value;
                        }

                        set
                        {
                            ((global::CppSharp.Parser.AST.Enumeration.Item.__Internal*)__Instance)->value = value;
                        }
                    }
                }

                internal static new global::CppSharp.Parser.AST.Enumeration __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.Enumeration(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.Enumeration __CreateInstance(global::CppSharp.Parser.AST.Enumeration.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.Enumeration(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.Enumeration.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Enumeration.__Internal));
                    global::CppSharp.Parser.AST.Enumeration.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private Enumeration(global::CppSharp.Parser.AST.Enumeration.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected Enumeration(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public Enumeration()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Enumeration.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public Enumeration(global::CppSharp.Parser.AST.Enumeration _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Enumeration.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Declaration __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor(__Instance, 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.Enumeration.Item GetItems(uint i)
                {
                    var __ret = __Internal.GetItems(__Instance, i);
                    global::CppSharp.Parser.AST.Enumeration.Item __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.Enumeration.Item.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::CppSharp.Parser.AST.Enumeration.Item) global::CppSharp.Parser.AST.Enumeration.Item.NativeToManagedMap[__ret];
                    else __result0 = global::CppSharp.Parser.AST.Enumeration.Item.__CreateInstance(__ret);
                    return __result0;
                }

                public void AddItems(global::CppSharp.Parser.AST.Enumeration.Item s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var ____arg0 = s.__Instance;
                    var __arg0 = new global::System.IntPtr(&____arg0);
                    __Internal.AddItems(__Instance, __arg0);
                }

                public void ClearItems()
                {
                    __Internal.ClearItems(__Instance);
                }

                public global::CppSharp.Parser.AST.Enumeration.Item FindItemByName(string Name)
                {
                    var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                    global::Std.BasicStringExtensions.Assign(__basicString0, Name);
                    var __arg0 = __basicString0.__Instance;
                    var __ret = __Internal.FindItemByName(__Instance, __arg0);
                    __basicString0.Dispose();
                    global::CppSharp.Parser.AST.Enumeration.Item __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.Enumeration.Item.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::CppSharp.Parser.AST.Enumeration.Item) global::CppSharp.Parser.AST.Enumeration.Item.NativeToManagedMap[__ret];
                    else __result0 = global::CppSharp.Parser.AST.Enumeration.Item.__CreateInstance(__ret);
                    return __result0;
                }

                public global::CppSharp.Parser.AST.Enumeration.EnumModifiers Modifiers
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Enumeration.__Internal*) __Instance)->modifiers;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Enumeration.__Internal*)__Instance)->modifiers = value;
                    }
                }

                public global::CppSharp.Parser.AST.Type Type
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Type __result0;
                        if (((global::CppSharp.Parser.AST.Enumeration.__Internal*) __Instance)->type == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Type.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.Enumeration.__Internal*) __Instance)->type))
                            __result0 = (global::CppSharp.Parser.AST.Type) global::CppSharp.Parser.AST.Type.NativeToManagedMap[((global::CppSharp.Parser.AST.Enumeration.__Internal*) __Instance)->type];
                        else __result0 = global::CppSharp.Parser.AST.Type.__CreateInstance(((global::CppSharp.Parser.AST.Enumeration.__Internal*) __Instance)->type);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Enumeration.__Internal*)__Instance)->type = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.BuiltinType BuiltinType
                {
                    get
                    {
                        global::CppSharp.Parser.AST.BuiltinType __result0;
                        if (((global::CppSharp.Parser.AST.Enumeration.__Internal*) __Instance)->builtinType == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.BuiltinType.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.Enumeration.__Internal*) __Instance)->builtinType))
                            __result0 = (global::CppSharp.Parser.AST.BuiltinType) global::CppSharp.Parser.AST.BuiltinType.NativeToManagedMap[((global::CppSharp.Parser.AST.Enumeration.__Internal*) __Instance)->builtinType];
                        else __result0 = global::CppSharp.Parser.AST.BuiltinType.__CreateInstance(((global::CppSharp.Parser.AST.Enumeration.__Internal*) __Instance)->builtinType);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Enumeration.__Internal*)__Instance)->builtinType = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public uint ItemsCount
                {
                    get
                    {
                        var __ret = __Internal.GetItemsCount(__Instance);
                        return __ret;
                    }
                }
            }

            public unsafe partial class Variable : global::CppSharp.Parser.AST.Declaration, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 180)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.DeclarationKind kind;

                    [FieldOffset(4)]
                    internal int maxFieldAlignment;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.AccessSpecifier access;

                    [FieldOffset(12)]
                    internal global::System.IntPtr _namespace;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal location;

                    [FieldOffset(20)]
                    internal int lineNumberStart;

                    [FieldOffset(24)]
                    internal int lineNumberEnd;

                    [FieldOffset(28)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C name;

                    [FieldOffset(52)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C USR;

                    [FieldOffset(76)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C debugText;

                    [FieldOffset(100)]
                    internal byte isIncomplete;

                    [FieldOffset(101)]
                    internal byte isDependent;

                    [FieldOffset(102)]
                    internal byte isImplicit;

                    [FieldOffset(103)]
                    internal byte isInvalid;

                    [FieldOffset(104)]
                    internal byte isDeprecated;

                    [FieldOffset(108)]
                    internal global::System.IntPtr completeDeclaration;

                    [FieldOffset(112)]
                    internal uint definitionOrder;

                    [FieldOffset(116)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_PreprocessedEntity___N_std_S_allocator__S0_ PreprocessedEntities;

                    [FieldOffset(128)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Declaration___N_std_S_allocator__S0_ Redeclarations;

                    [FieldOffset(140)]
                    internal global::System.IntPtr originalPtr;

                    [FieldOffset(144)]
                    internal global::System.IntPtr comment;

                    [FieldOffset(148)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C mangled;

                    [FieldOffset(172)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal qualifiedType;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0Variable@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0Variable@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??1Variable@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern void dtor(global::System.IntPtr __instance, int delete);
                }

                internal static new global::CppSharp.Parser.AST.Variable __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.Variable(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.Variable __CreateInstance(global::CppSharp.Parser.AST.Variable.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.Variable(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.Variable.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Variable.__Internal));
                    global::CppSharp.Parser.AST.Variable.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private Variable(global::CppSharp.Parser.AST.Variable.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected Variable(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public Variable()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Variable.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public Variable(global::CppSharp.Parser.AST.Variable _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Variable.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Declaration __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor(__Instance, 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public string Mangled
                {
                    get
                    {
                        var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.Variable.__Internal*) __Instance)->mangled));
                        return global::Std.BasicStringExtensions.Data(__basicStringRet0);
                    }

                    set
                    {
                        global::Std.BasicStringExtensions.__Internal.Assign(new global::System.IntPtr(&((global::CppSharp.Parser.AST.Variable.__Internal*)__Instance)->mangled), value);
                    }
                }

                public global::CppSharp.Parser.AST.QualifiedType QualifiedType
                {
                    get
                    {
                        return global::CppSharp.Parser.AST.QualifiedType.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.Variable.__Internal*) __Instance)->qualifiedType));
                    }

                    set
                    {
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                        ((global::CppSharp.Parser.AST.Variable.__Internal*)__Instance)->qualifiedType = *(global::CppSharp.Parser.AST.QualifiedType.__Internal*) value.__Instance;
                    }
                }
            }

            public unsafe partial class BaseClassSpecifier : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 16)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.AccessSpecifier access;

                    [FieldOffset(4)]
                    internal byte isVirtual;

                    [FieldOffset(8)]
                    internal global::System.IntPtr type;

                    [FieldOffset(12)]
                    internal int offset;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0BaseClassSpecifier@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0BaseClassSpecifier@AST@CppParser@CppSharp@@QAE@ABU0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.BaseClassSpecifier> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.BaseClassSpecifier>();
                protected internal void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                internal static global::CppSharp.Parser.AST.BaseClassSpecifier __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.BaseClassSpecifier(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.BaseClassSpecifier __CreateInstance(global::CppSharp.Parser.AST.BaseClassSpecifier.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.BaseClassSpecifier(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.BaseClassSpecifier.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.BaseClassSpecifier.__Internal));
                    *(global::CppSharp.Parser.AST.BaseClassSpecifier.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private BaseClassSpecifier(global::CppSharp.Parser.AST.BaseClassSpecifier.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected BaseClassSpecifier(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public BaseClassSpecifier()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.BaseClassSpecifier.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public BaseClassSpecifier(global::CppSharp.Parser.AST.BaseClassSpecifier _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.BaseClassSpecifier.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.BaseClassSpecifier.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.BaseClassSpecifier.__Internal*) _0.__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                public virtual void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.BaseClassSpecifier __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.AccessSpecifier Access
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.BaseClassSpecifier.__Internal*) __Instance)->access;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.BaseClassSpecifier.__Internal*)__Instance)->access = value;
                    }
                }

                public bool IsVirtual
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.BaseClassSpecifier.__Internal*) __Instance)->isVirtual != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.BaseClassSpecifier.__Internal*)__Instance)->isVirtual = (byte) (value ? 1 : 0);
                    }
                }

                public global::CppSharp.Parser.AST.Type Type
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Type __result0;
                        if (((global::CppSharp.Parser.AST.BaseClassSpecifier.__Internal*) __Instance)->type == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Type.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.BaseClassSpecifier.__Internal*) __Instance)->type))
                            __result0 = (global::CppSharp.Parser.AST.Type) global::CppSharp.Parser.AST.Type.NativeToManagedMap[((global::CppSharp.Parser.AST.BaseClassSpecifier.__Internal*) __Instance)->type];
                        else __result0 = global::CppSharp.Parser.AST.Type.__CreateInstance(((global::CppSharp.Parser.AST.BaseClassSpecifier.__Internal*) __Instance)->type);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.BaseClassSpecifier.__Internal*)__Instance)->type = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public int Offset
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.BaseClassSpecifier.__Internal*) __Instance)->offset;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.BaseClassSpecifier.__Internal*)__Instance)->offset = value;
                    }
                }
            }

            public unsafe partial class Field : global::CppSharp.Parser.AST.Declaration, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 168)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.DeclarationKind kind;

                    [FieldOffset(4)]
                    internal int maxFieldAlignment;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.AccessSpecifier access;

                    [FieldOffset(12)]
                    internal global::System.IntPtr _namespace;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal location;

                    [FieldOffset(20)]
                    internal int lineNumberStart;

                    [FieldOffset(24)]
                    internal int lineNumberEnd;

                    [FieldOffset(28)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C name;

                    [FieldOffset(52)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C USR;

                    [FieldOffset(76)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C debugText;

                    [FieldOffset(100)]
                    internal byte isIncomplete;

                    [FieldOffset(101)]
                    internal byte isDependent;

                    [FieldOffset(102)]
                    internal byte isImplicit;

                    [FieldOffset(103)]
                    internal byte isInvalid;

                    [FieldOffset(104)]
                    internal byte isDeprecated;

                    [FieldOffset(108)]
                    internal global::System.IntPtr completeDeclaration;

                    [FieldOffset(112)]
                    internal uint definitionOrder;

                    [FieldOffset(116)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_PreprocessedEntity___N_std_S_allocator__S0_ PreprocessedEntities;

                    [FieldOffset(128)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Declaration___N_std_S_allocator__S0_ Redeclarations;

                    [FieldOffset(140)]
                    internal global::System.IntPtr originalPtr;

                    [FieldOffset(144)]
                    internal global::System.IntPtr comment;

                    [FieldOffset(148)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal qualifiedType;

                    [FieldOffset(156)]
                    internal global::System.IntPtr _class;

                    [FieldOffset(160)]
                    internal byte isBitField;

                    [FieldOffset(164)]
                    internal uint bitWidth;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0Field@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0Field@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??1Field@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern void dtor(global::System.IntPtr __instance, int delete);
                }

                internal static new global::CppSharp.Parser.AST.Field __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.Field(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.Field __CreateInstance(global::CppSharp.Parser.AST.Field.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.Field(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.Field.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Field.__Internal));
                    global::CppSharp.Parser.AST.Field.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private Field(global::CppSharp.Parser.AST.Field.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected Field(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public Field()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Field.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public Field(global::CppSharp.Parser.AST.Field _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Field.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Declaration __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor(__Instance, 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.QualifiedType QualifiedType
                {
                    get
                    {
                        return global::CppSharp.Parser.AST.QualifiedType.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.Field.__Internal*) __Instance)->qualifiedType));
                    }

                    set
                    {
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                        ((global::CppSharp.Parser.AST.Field.__Internal*)__Instance)->qualifiedType = *(global::CppSharp.Parser.AST.QualifiedType.__Internal*) value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Class Class
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Class __result0;
                        if (((global::CppSharp.Parser.AST.Field.__Internal*) __Instance)->_class == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Class.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.Field.__Internal*) __Instance)->_class))
                            __result0 = (global::CppSharp.Parser.AST.Class) global::CppSharp.Parser.AST.Class.NativeToManagedMap[((global::CppSharp.Parser.AST.Field.__Internal*) __Instance)->_class];
                        else __result0 = global::CppSharp.Parser.AST.Class.__CreateInstance(((global::CppSharp.Parser.AST.Field.__Internal*) __Instance)->_class);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Field.__Internal*)__Instance)->_class = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public bool IsBitField
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Field.__Internal*) __Instance)->isBitField != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Field.__Internal*)__Instance)->isBitField = (byte) (value ? 1 : 0);
                    }
                }

                public uint BitWidth
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Field.__Internal*) __Instance)->bitWidth;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Field.__Internal*)__Instance)->bitWidth = value;
                    }
                }
            }

            public unsafe partial class AccessSpecifierDecl : global::CppSharp.Parser.AST.Declaration, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 148)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.DeclarationKind kind;

                    [FieldOffset(4)]
                    internal int maxFieldAlignment;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.AccessSpecifier access;

                    [FieldOffset(12)]
                    internal global::System.IntPtr _namespace;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal location;

                    [FieldOffset(20)]
                    internal int lineNumberStart;

                    [FieldOffset(24)]
                    internal int lineNumberEnd;

                    [FieldOffset(28)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C name;

                    [FieldOffset(52)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C USR;

                    [FieldOffset(76)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C debugText;

                    [FieldOffset(100)]
                    internal byte isIncomplete;

                    [FieldOffset(101)]
                    internal byte isDependent;

                    [FieldOffset(102)]
                    internal byte isImplicit;

                    [FieldOffset(103)]
                    internal byte isInvalid;

                    [FieldOffset(104)]
                    internal byte isDeprecated;

                    [FieldOffset(108)]
                    internal global::System.IntPtr completeDeclaration;

                    [FieldOffset(112)]
                    internal uint definitionOrder;

                    [FieldOffset(116)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_PreprocessedEntity___N_std_S_allocator__S0_ PreprocessedEntities;

                    [FieldOffset(128)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Declaration___N_std_S_allocator__S0_ Redeclarations;

                    [FieldOffset(140)]
                    internal global::System.IntPtr originalPtr;

                    [FieldOffset(144)]
                    internal global::System.IntPtr comment;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0AccessSpecifierDecl@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0AccessSpecifierDecl@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??1AccessSpecifierDecl@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern void dtor(global::System.IntPtr __instance, int delete);
                }

                internal static new global::CppSharp.Parser.AST.AccessSpecifierDecl __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.AccessSpecifierDecl(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.AccessSpecifierDecl __CreateInstance(global::CppSharp.Parser.AST.AccessSpecifierDecl.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.AccessSpecifierDecl(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.AccessSpecifierDecl.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.AccessSpecifierDecl.__Internal));
                    global::CppSharp.Parser.AST.AccessSpecifierDecl.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private AccessSpecifierDecl(global::CppSharp.Parser.AST.AccessSpecifierDecl.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected AccessSpecifierDecl(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public AccessSpecifierDecl()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.AccessSpecifierDecl.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public AccessSpecifierDecl(global::CppSharp.Parser.AST.AccessSpecifierDecl _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.AccessSpecifierDecl.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Declaration __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor(__Instance, 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }
            }

            public unsafe partial class VTableComponent : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 12)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.VTableComponentKind kind;

                    [FieldOffset(4)]
                    internal uint offset;

                    [FieldOffset(8)]
                    internal global::System.IntPtr declaration;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0VTableComponent@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0VTableComponent@AST@CppParser@CppSharp@@QAE@ABU0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.VTableComponent> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.VTableComponent>();
                protected internal void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                internal static global::CppSharp.Parser.AST.VTableComponent __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.VTableComponent(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.VTableComponent __CreateInstance(global::CppSharp.Parser.AST.VTableComponent.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.VTableComponent(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.VTableComponent.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.VTableComponent.__Internal));
                    *(global::CppSharp.Parser.AST.VTableComponent.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private VTableComponent(global::CppSharp.Parser.AST.VTableComponent.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected VTableComponent(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public VTableComponent()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.VTableComponent.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public VTableComponent(global::CppSharp.Parser.AST.VTableComponent _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.VTableComponent.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.VTableComponent.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.VTableComponent.__Internal*) _0.__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                public virtual void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.VTableComponent __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.VTableComponentKind Kind
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.VTableComponent.__Internal*) __Instance)->kind;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.VTableComponent.__Internal*)__Instance)->kind = value;
                    }
                }

                public uint Offset
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.VTableComponent.__Internal*) __Instance)->offset;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.VTableComponent.__Internal*)__Instance)->offset = value;
                    }
                }

                public global::CppSharp.Parser.AST.Declaration Declaration
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Declaration __result0;
                        if (((global::CppSharp.Parser.AST.VTableComponent.__Internal*) __Instance)->declaration == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Declaration.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.VTableComponent.__Internal*) __Instance)->declaration))
                            __result0 = (global::CppSharp.Parser.AST.Declaration) global::CppSharp.Parser.AST.Declaration.NativeToManagedMap[((global::CppSharp.Parser.AST.VTableComponent.__Internal*) __Instance)->declaration];
                        else __result0 = global::CppSharp.Parser.AST.Declaration.__CreateInstance(((global::CppSharp.Parser.AST.VTableComponent.__Internal*) __Instance)->declaration);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.VTableComponent.__Internal*)__Instance)->declaration = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }
            }

            public unsafe partial class VTableLayout : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 12)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector____N_CppSharp_N_CppParser_N_AST_S_VTableComponent___N_std_S_allocator__S0_ Components;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0VTableLayout@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0VTableLayout@AST@CppParser@CppSharp@@QAE@ABU0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??1VTableLayout@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern void dtor(global::System.IntPtr __instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getComponents@VTableLayout@AST@CppParser@CppSharp@@QAE?AUVTableComponent@234@I@Z")]
                    internal static extern void GetComponents(global::System.IntPtr __instance, global::System.IntPtr @return, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?addComponents@VTableLayout@AST@CppParser@CppSharp@@QAEXAAUVTableComponent@234@@Z")]
                    internal static extern void AddComponents(global::System.IntPtr __instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?clearComponents@VTableLayout@AST@CppParser@CppSharp@@QAEXXZ")]
                    internal static extern void ClearComponents(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getComponentsCount@VTableLayout@AST@CppParser@CppSharp@@QAEIXZ")]
                    internal static extern uint GetComponentsCount(global::System.IntPtr __instance);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.VTableLayout> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.VTableLayout>();
                protected internal void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                internal static global::CppSharp.Parser.AST.VTableLayout __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.VTableLayout(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.VTableLayout __CreateInstance(global::CppSharp.Parser.AST.VTableLayout.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.VTableLayout(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.VTableLayout.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.VTableLayout.__Internal));
                    global::CppSharp.Parser.AST.VTableLayout.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private VTableLayout(global::CppSharp.Parser.AST.VTableLayout.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected VTableLayout(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public VTableLayout()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.VTableLayout.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public VTableLayout(global::CppSharp.Parser.AST.VTableLayout _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.VTableLayout.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                public virtual void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.VTableLayout __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor(__Instance, 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.VTableComponent GetComponents(uint i)
                {
                    var __ret = new global::CppSharp.Parser.AST.VTableComponent.__Internal();
                    __Internal.GetComponents(__Instance, new IntPtr(&__ret), i);
                    return global::CppSharp.Parser.AST.VTableComponent.__CreateInstance(__ret);
                }

                public void AddComponents(global::CppSharp.Parser.AST.VTableComponent s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    __Internal.AddComponents(__Instance, __arg0);
                }

                public void ClearComponents()
                {
                    __Internal.ClearComponents(__Instance);
                }

                public uint ComponentsCount
                {
                    get
                    {
                        var __ret = __Internal.GetComponentsCount(__Instance);
                        return __ret;
                    }
                }
            }

            public unsafe partial class VFTableInfo : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 32)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal ulong VBTableIndex;

                    [FieldOffset(8)]
                    internal uint VFPtrOffset;

                    [FieldOffset(12)]
                    internal uint VFPtrFullOffset;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.AST.VTableLayout.__Internal layout;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0VFTableInfo@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0VFTableInfo@AST@CppParser@CppSharp@@QAE@ABU0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??1VFTableInfo@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern void dtor(global::System.IntPtr __instance, int delete);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.VFTableInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.VFTableInfo>();
                protected internal void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                internal static global::CppSharp.Parser.AST.VFTableInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.VFTableInfo(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.VFTableInfo __CreateInstance(global::CppSharp.Parser.AST.VFTableInfo.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.VFTableInfo(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.VFTableInfo.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.VFTableInfo.__Internal));
                    global::CppSharp.Parser.AST.VFTableInfo.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private VFTableInfo(global::CppSharp.Parser.AST.VFTableInfo.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected VFTableInfo(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public VFTableInfo()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.VFTableInfo.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public VFTableInfo(global::CppSharp.Parser.AST.VFTableInfo _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.VFTableInfo.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                public virtual void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.VFTableInfo __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor(__Instance, 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public ulong VBTableIndex
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.VFTableInfo.__Internal*) __Instance)->VBTableIndex;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.VFTableInfo.__Internal*)__Instance)->VBTableIndex = value;
                    }
                }

                public uint VFPtrOffset
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.VFTableInfo.__Internal*) __Instance)->VFPtrOffset;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.VFTableInfo.__Internal*)__Instance)->VFPtrOffset = value;
                    }
                }

                public uint VFPtrFullOffset
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.VFTableInfo.__Internal*) __Instance)->VFPtrFullOffset;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.VFTableInfo.__Internal*)__Instance)->VFPtrFullOffset = value;
                    }
                }

                public global::CppSharp.Parser.AST.VTableLayout Layout
                {
                    get
                    {
                        return global::CppSharp.Parser.AST.VTableLayout.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.VFTableInfo.__Internal*) __Instance)->layout));
                    }

                    set
                    {
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                        ((global::CppSharp.Parser.AST.VFTableInfo.__Internal*)__Instance)->layout = *(global::CppSharp.Parser.AST.VTableLayout.__Internal*) value.__Instance;
                    }
                }
            }

            public unsafe partial class LayoutField : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 40)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal uint offset;

                    [FieldOffset(4)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C name;

                    [FieldOffset(28)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal qualifiedType;

                    [FieldOffset(36)]
                    internal global::System.IntPtr fieldPtr;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0LayoutField@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0LayoutField@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr other);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??1LayoutField@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern void dtor(global::System.IntPtr __instance, int delete);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.LayoutField> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.LayoutField>();
                protected internal void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                internal static global::CppSharp.Parser.AST.LayoutField __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.LayoutField(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.LayoutField __CreateInstance(global::CppSharp.Parser.AST.LayoutField.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.LayoutField(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.LayoutField.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.LayoutField.__Internal));
                    global::CppSharp.Parser.AST.LayoutField.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private LayoutField(global::CppSharp.Parser.AST.LayoutField.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected LayoutField(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public LayoutField()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.LayoutField.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public LayoutField(global::CppSharp.Parser.AST.LayoutField other)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.LayoutField.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(other, null))
                        throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = other.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                public virtual void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.LayoutField __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor(__Instance, 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public uint Offset
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.LayoutField.__Internal*) __Instance)->offset;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.LayoutField.__Internal*)__Instance)->offset = value;
                    }
                }

                public string Name
                {
                    get
                    {
                        var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.LayoutField.__Internal*) __Instance)->name));
                        return global::Std.BasicStringExtensions.Data(__basicStringRet0);
                    }

                    set
                    {
                        global::Std.BasicStringExtensions.__Internal.Assign(new global::System.IntPtr(&((global::CppSharp.Parser.AST.LayoutField.__Internal*)__Instance)->name), value);
                    }
                }

                public global::CppSharp.Parser.AST.QualifiedType QualifiedType
                {
                    get
                    {
                        return global::CppSharp.Parser.AST.QualifiedType.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.LayoutField.__Internal*) __Instance)->qualifiedType));
                    }

                    set
                    {
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                        ((global::CppSharp.Parser.AST.LayoutField.__Internal*)__Instance)->qualifiedType = *(global::CppSharp.Parser.AST.QualifiedType.__Internal*) value.__Instance;
                    }
                }

                public global::System.IntPtr FieldPtr
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.LayoutField.__Internal*) __Instance)->fieldPtr;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.LayoutField.__Internal*)__Instance)->fieldPtr = (global::System.IntPtr) value;
                    }
                }
            }

            public unsafe partial class LayoutBase : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 8)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal uint offset;

                    [FieldOffset(4)]
                    internal global::System.IntPtr _class;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0LayoutBase@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0LayoutBase@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr other);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??1LayoutBase@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern void dtor(global::System.IntPtr __instance, int delete);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.LayoutBase> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.LayoutBase>();
                protected internal void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                internal static global::CppSharp.Parser.AST.LayoutBase __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.LayoutBase(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.LayoutBase __CreateInstance(global::CppSharp.Parser.AST.LayoutBase.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.LayoutBase(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.LayoutBase.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.LayoutBase.__Internal));
                    global::CppSharp.Parser.AST.LayoutBase.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private LayoutBase(global::CppSharp.Parser.AST.LayoutBase.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected LayoutBase(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public LayoutBase()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.LayoutBase.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public LayoutBase(global::CppSharp.Parser.AST.LayoutBase other)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.LayoutBase.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(other, null))
                        throw new global::System.ArgumentNullException("other", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = other.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                public virtual void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.LayoutBase __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor(__Instance, 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public uint Offset
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.LayoutBase.__Internal*) __Instance)->offset;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.LayoutBase.__Internal*)__Instance)->offset = value;
                    }
                }

                public global::CppSharp.Parser.AST.Class Class
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Class __result0;
                        if (((global::CppSharp.Parser.AST.LayoutBase.__Internal*) __Instance)->_class == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Class.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.LayoutBase.__Internal*) __Instance)->_class))
                            __result0 = (global::CppSharp.Parser.AST.Class) global::CppSharp.Parser.AST.Class.NativeToManagedMap[((global::CppSharp.Parser.AST.LayoutBase.__Internal*) __Instance)->_class];
                        else __result0 = global::CppSharp.Parser.AST.Class.__CreateInstance(((global::CppSharp.Parser.AST.LayoutBase.__Internal*) __Instance)->_class);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.LayoutBase.__Internal*)__Instance)->_class = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }
            }

            public unsafe partial class ClassLayout : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 76)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.CppAbi ABI;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.AST.RecordArgABI argABI;

                    [FieldOffset(8)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector____N_CppSharp_N_CppParser_N_AST_S_VFTableInfo___N_std_S_allocator__S0_ VFTables;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.VTableLayout.__Internal layout;

                    [FieldOffset(32)]
                    internal byte hasOwnVFPtr;

                    [FieldOffset(36)]
                    internal int VBPtrOffset;

                    [FieldOffset(40)]
                    internal int alignment;

                    [FieldOffset(44)]
                    internal int size;

                    [FieldOffset(48)]
                    internal int dataSize;

                    [FieldOffset(52)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector____N_CppSharp_N_CppParser_N_AST_S_LayoutField___N_std_S_allocator__S0_ Fields;

                    [FieldOffset(64)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector____N_CppSharp_N_CppParser_N_AST_S_LayoutBase___N_std_S_allocator__S0_ Bases;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0ClassLayout@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0ClassLayout@AST@CppParser@CppSharp@@QAE@ABU0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??1ClassLayout@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern void dtor(global::System.IntPtr __instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getVFTables@ClassLayout@AST@CppParser@CppSharp@@QAE?AUVFTableInfo@234@I@Z")]
                    internal static extern void GetVFTables(global::System.IntPtr __instance, global::System.IntPtr @return, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?addVFTables@ClassLayout@AST@CppParser@CppSharp@@QAEXAAUVFTableInfo@234@@Z")]
                    internal static extern void AddVFTables(global::System.IntPtr __instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?clearVFTables@ClassLayout@AST@CppParser@CppSharp@@QAEXXZ")]
                    internal static extern void ClearVFTables(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getFields@ClassLayout@AST@CppParser@CppSharp@@QAE?AVLayoutField@234@I@Z")]
                    internal static extern void GetFields(global::System.IntPtr __instance, global::System.IntPtr @return, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?addFields@ClassLayout@AST@CppParser@CppSharp@@QAEXAAVLayoutField@234@@Z")]
                    internal static extern void AddFields(global::System.IntPtr __instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?clearFields@ClassLayout@AST@CppParser@CppSharp@@QAEXXZ")]
                    internal static extern void ClearFields(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getBases@ClassLayout@AST@CppParser@CppSharp@@QAE?AVLayoutBase@234@I@Z")]
                    internal static extern void GetBases(global::System.IntPtr __instance, global::System.IntPtr @return, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?addBases@ClassLayout@AST@CppParser@CppSharp@@QAEXAAVLayoutBase@234@@Z")]
                    internal static extern void AddBases(global::System.IntPtr __instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?clearBases@ClassLayout@AST@CppParser@CppSharp@@QAEXXZ")]
                    internal static extern void ClearBases(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getVFTablesCount@ClassLayout@AST@CppParser@CppSharp@@QAEIXZ")]
                    internal static extern uint GetVFTablesCount(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getFieldsCount@ClassLayout@AST@CppParser@CppSharp@@QAEIXZ")]
                    internal static extern uint GetFieldsCount(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getBasesCount@ClassLayout@AST@CppParser@CppSharp@@QAEIXZ")]
                    internal static extern uint GetBasesCount(global::System.IntPtr __instance);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.ClassLayout> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.ClassLayout>();
                protected internal void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                internal static global::CppSharp.Parser.AST.ClassLayout __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.ClassLayout(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.ClassLayout __CreateInstance(global::CppSharp.Parser.AST.ClassLayout.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.ClassLayout(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.ClassLayout.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ClassLayout.__Internal));
                    global::CppSharp.Parser.AST.ClassLayout.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private ClassLayout(global::CppSharp.Parser.AST.ClassLayout.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected ClassLayout(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public ClassLayout()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ClassLayout.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public ClassLayout(global::CppSharp.Parser.AST.ClassLayout _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ClassLayout.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                public virtual void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.ClassLayout __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor(__Instance, 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.VFTableInfo GetVFTables(uint i)
                {
                    var __ret = new global::CppSharp.Parser.AST.VFTableInfo.__Internal();
                    __Internal.GetVFTables(__Instance, new IntPtr(&__ret), i);
                    return global::CppSharp.Parser.AST.VFTableInfo.__CreateInstance(__ret);
                }

                public void AddVFTables(global::CppSharp.Parser.AST.VFTableInfo s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    __Internal.AddVFTables(__Instance, __arg0);
                }

                public void ClearVFTables()
                {
                    __Internal.ClearVFTables(__Instance);
                }

                public global::CppSharp.Parser.AST.LayoutField GetFields(uint i)
                {
                    var __ret = new global::CppSharp.Parser.AST.LayoutField.__Internal();
                    __Internal.GetFields(__Instance, new IntPtr(&__ret), i);
                    return global::CppSharp.Parser.AST.LayoutField.__CreateInstance(__ret);
                }

                public void AddFields(global::CppSharp.Parser.AST.LayoutField s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    __Internal.AddFields(__Instance, __arg0);
                }

                public void ClearFields()
                {
                    __Internal.ClearFields(__Instance);
                }

                public global::CppSharp.Parser.AST.LayoutBase GetBases(uint i)
                {
                    var __ret = new global::CppSharp.Parser.AST.LayoutBase.__Internal();
                    __Internal.GetBases(__Instance, new IntPtr(&__ret), i);
                    return global::CppSharp.Parser.AST.LayoutBase.__CreateInstance(__ret);
                }

                public void AddBases(global::CppSharp.Parser.AST.LayoutBase s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    __Internal.AddBases(__Instance, __arg0);
                }

                public void ClearBases()
                {
                    __Internal.ClearBases(__Instance);
                }

                public global::CppSharp.Parser.AST.CppAbi ABI
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.ClassLayout.__Internal*) __Instance)->ABI;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.ClassLayout.__Internal*)__Instance)->ABI = value;
                    }
                }

                public global::CppSharp.Parser.AST.RecordArgABI ArgABI
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.ClassLayout.__Internal*) __Instance)->argABI;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.ClassLayout.__Internal*)__Instance)->argABI = value;
                    }
                }

                public global::CppSharp.Parser.AST.VTableLayout Layout
                {
                    get
                    {
                        return global::CppSharp.Parser.AST.VTableLayout.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.ClassLayout.__Internal*) __Instance)->layout));
                    }

                    set
                    {
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                        ((global::CppSharp.Parser.AST.ClassLayout.__Internal*)__Instance)->layout = *(global::CppSharp.Parser.AST.VTableLayout.__Internal*) value.__Instance;
                    }
                }

                public bool HasOwnVFPtr
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.ClassLayout.__Internal*) __Instance)->hasOwnVFPtr != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.ClassLayout.__Internal*)__Instance)->hasOwnVFPtr = (byte) (value ? 1 : 0);
                    }
                }

                public int VBPtrOffset
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.ClassLayout.__Internal*) __Instance)->VBPtrOffset;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.ClassLayout.__Internal*)__Instance)->VBPtrOffset = value;
                    }
                }

                public int Alignment
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.ClassLayout.__Internal*) __Instance)->alignment;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.ClassLayout.__Internal*)__Instance)->alignment = value;
                    }
                }

                public int Size
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.ClassLayout.__Internal*) __Instance)->size;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.ClassLayout.__Internal*)__Instance)->size = value;
                    }
                }

                public int DataSize
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.ClassLayout.__Internal*) __Instance)->dataSize;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.ClassLayout.__Internal*)__Instance)->dataSize = value;
                    }
                }

                public uint VFTablesCount
                {
                    get
                    {
                        var __ret = __Internal.GetVFTablesCount(__Instance);
                        return __ret;
                    }
                }

                public uint FieldsCount
                {
                    get
                    {
                        var __ret = __Internal.GetFieldsCount(__Instance);
                        return __ret;
                    }
                }

                public uint BasesCount
                {
                    get
                    {
                        var __ret = __Internal.GetBasesCount(__Instance);
                        return __ret;
                    }
                }
            }

            public unsafe partial class Class : global::CppSharp.Parser.AST.DeclarationContext, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 332)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.DeclarationKind kind;

                    [FieldOffset(4)]
                    internal int maxFieldAlignment;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.AccessSpecifier access;

                    [FieldOffset(12)]
                    internal global::System.IntPtr _namespace;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal location;

                    [FieldOffset(20)]
                    internal int lineNumberStart;

                    [FieldOffset(24)]
                    internal int lineNumberEnd;

                    [FieldOffset(28)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C name;

                    [FieldOffset(52)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C USR;

                    [FieldOffset(76)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C debugText;

                    [FieldOffset(100)]
                    internal byte isIncomplete;

                    [FieldOffset(101)]
                    internal byte isDependent;

                    [FieldOffset(102)]
                    internal byte isImplicit;

                    [FieldOffset(103)]
                    internal byte isInvalid;

                    [FieldOffset(104)]
                    internal byte isDeprecated;

                    [FieldOffset(108)]
                    internal global::System.IntPtr completeDeclaration;

                    [FieldOffset(112)]
                    internal uint definitionOrder;

                    [FieldOffset(116)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_PreprocessedEntity___N_std_S_allocator__S0_ PreprocessedEntities;

                    [FieldOffset(128)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Declaration___N_std_S_allocator__S0_ Redeclarations;

                    [FieldOffset(140)]
                    internal global::System.IntPtr originalPtr;

                    [FieldOffset(144)]
                    internal global::System.IntPtr comment;

                    [FieldOffset(148)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Namespace___N_std_S_allocator__S0_ Namespaces;

                    [FieldOffset(160)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Enumeration___N_std_S_allocator__S0_ Enums;

                    [FieldOffset(172)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Function___N_std_S_allocator__S0_ Functions;

                    [FieldOffset(184)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Class___N_std_S_allocator__S0_ Classes;

                    [FieldOffset(196)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Template___N_std_S_allocator__S0_ Templates;

                    [FieldOffset(208)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_TypedefDecl___N_std_S_allocator__S0_ Typedefs;

                    [FieldOffset(220)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_TypeAlias___N_std_S_allocator__S0_ TypeAliases;

                    [FieldOffset(232)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Variable___N_std_S_allocator__S0_ Variables;

                    [FieldOffset(244)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Friend___N_std_S_allocator__S0_ Friends;

                    [FieldOffset(256)]
                    internal global::Std.Map.__Internalc__N_std_S_map____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C____N_CppSharp_N_CppParser_N_AST_S_Declaration___N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__S3_ anonymous;

                    [FieldOffset(264)]
                    internal byte isAnonymous;

                    [FieldOffset(268)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_BaseClassSpecifier___N_std_S_allocator__S0_ Bases;

                    [FieldOffset(280)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Field___N_std_S_allocator__S0_ Fields;

                    [FieldOffset(292)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Method___N_std_S_allocator__S0_ Methods;

                    [FieldOffset(304)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_AccessSpecifierDecl___N_std_S_allocator__S0_ Specifiers;

                    [FieldOffset(316)]
                    internal byte isPOD;

                    [FieldOffset(317)]
                    internal byte isAbstract;

                    [FieldOffset(318)]
                    internal byte isUnion;

                    [FieldOffset(319)]
                    internal byte isDynamic;

                    [FieldOffset(320)]
                    internal byte isPolymorphic;

                    [FieldOffset(321)]
                    internal byte hasNonTrivialDefaultConstructor;

                    [FieldOffset(322)]
                    internal byte hasNonTrivialCopyConstructor;

                    [FieldOffset(323)]
                    internal byte hasNonTrivialDestructor;

                    [FieldOffset(324)]
                    internal byte isExternCContext;

                    [FieldOffset(325)]
                    internal byte isInjected;

                    [FieldOffset(328)]
                    internal global::System.IntPtr layout;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0Class@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0Class@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??1Class@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern void dtor(global::System.IntPtr __instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getBases@Class@AST@CppParser@CppSharp@@QAEPAUBaseClassSpecifier@234@I@Z")]
                    internal static extern global::System.IntPtr GetBases(global::System.IntPtr __instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?addBases@Class@AST@CppParser@CppSharp@@QAEXAAPAUBaseClassSpecifier@234@@Z")]
                    internal static extern void AddBases(global::System.IntPtr __instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?clearBases@Class@AST@CppParser@CppSharp@@QAEXXZ")]
                    internal static extern void ClearBases(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getFields@Class@AST@CppParser@CppSharp@@QAEPAVField@234@I@Z")]
                    internal static extern global::System.IntPtr GetFields(global::System.IntPtr __instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?addFields@Class@AST@CppParser@CppSharp@@QAEXAAPAVField@234@@Z")]
                    internal static extern void AddFields(global::System.IntPtr __instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?clearFields@Class@AST@CppParser@CppSharp@@QAEXXZ")]
                    internal static extern void ClearFields(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getMethods@Class@AST@CppParser@CppSharp@@QAEPAVMethod@234@I@Z")]
                    internal static extern global::System.IntPtr GetMethods(global::System.IntPtr __instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?addMethods@Class@AST@CppParser@CppSharp@@QAEXAAPAVMethod@234@@Z")]
                    internal static extern void AddMethods(global::System.IntPtr __instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?clearMethods@Class@AST@CppParser@CppSharp@@QAEXXZ")]
                    internal static extern void ClearMethods(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getSpecifiers@Class@AST@CppParser@CppSharp@@QAEPAVAccessSpecifierDecl@234@I@Z")]
                    internal static extern global::System.IntPtr GetSpecifiers(global::System.IntPtr __instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?addSpecifiers@Class@AST@CppParser@CppSharp@@QAEXAAPAVAccessSpecifierDecl@234@@Z")]
                    internal static extern void AddSpecifiers(global::System.IntPtr __instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?clearSpecifiers@Class@AST@CppParser@CppSharp@@QAEXXZ")]
                    internal static extern void ClearSpecifiers(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getBasesCount@Class@AST@CppParser@CppSharp@@QAEIXZ")]
                    internal static extern uint GetBasesCount(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getFieldsCount@Class@AST@CppParser@CppSharp@@QAEIXZ")]
                    internal static extern uint GetFieldsCount(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getMethodsCount@Class@AST@CppParser@CppSharp@@QAEIXZ")]
                    internal static extern uint GetMethodsCount(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getSpecifiersCount@Class@AST@CppParser@CppSharp@@QAEIXZ")]
                    internal static extern uint GetSpecifiersCount(global::System.IntPtr __instance);
                }

                internal static new global::CppSharp.Parser.AST.Class __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.Class(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.Class __CreateInstance(global::CppSharp.Parser.AST.Class.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.Class(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.Class.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Class.__Internal));
                    global::CppSharp.Parser.AST.Class.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private Class(global::CppSharp.Parser.AST.Class.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected Class(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public Class()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Class.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public Class(global::CppSharp.Parser.AST.Class _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Class.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Declaration __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor(__Instance, 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.BaseClassSpecifier GetBases(uint i)
                {
                    var __ret = __Internal.GetBases(__Instance, i);
                    global::CppSharp.Parser.AST.BaseClassSpecifier __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.BaseClassSpecifier.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::CppSharp.Parser.AST.BaseClassSpecifier) global::CppSharp.Parser.AST.BaseClassSpecifier.NativeToManagedMap[__ret];
                    else __result0 = global::CppSharp.Parser.AST.BaseClassSpecifier.__CreateInstance(__ret);
                    return __result0;
                }

                public void AddBases(global::CppSharp.Parser.AST.BaseClassSpecifier s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var ____arg0 = s.__Instance;
                    var __arg0 = new global::System.IntPtr(&____arg0);
                    __Internal.AddBases(__Instance, __arg0);
                }

                public void ClearBases()
                {
                    __Internal.ClearBases(__Instance);
                }

                public global::CppSharp.Parser.AST.Field GetFields(uint i)
                {
                    var __ret = __Internal.GetFields(__Instance, i);
                    global::CppSharp.Parser.AST.Field __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.Field.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::CppSharp.Parser.AST.Field) global::CppSharp.Parser.AST.Field.NativeToManagedMap[__ret];
                    else __result0 = global::CppSharp.Parser.AST.Field.__CreateInstance(__ret);
                    return __result0;
                }

                public void AddFields(global::CppSharp.Parser.AST.Field s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var ____arg0 = s.__Instance;
                    var __arg0 = new global::System.IntPtr(&____arg0);
                    __Internal.AddFields(__Instance, __arg0);
                }

                public void ClearFields()
                {
                    __Internal.ClearFields(__Instance);
                }

                public global::CppSharp.Parser.AST.Method GetMethods(uint i)
                {
                    var __ret = __Internal.GetMethods(__Instance, i);
                    global::CppSharp.Parser.AST.Method __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.Method.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::CppSharp.Parser.AST.Method) global::CppSharp.Parser.AST.Method.NativeToManagedMap[__ret];
                    else __result0 = global::CppSharp.Parser.AST.Method.__CreateInstance(__ret);
                    return __result0;
                }

                public void AddMethods(global::CppSharp.Parser.AST.Method s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var ____arg0 = s.__Instance;
                    var __arg0 = new global::System.IntPtr(&____arg0);
                    __Internal.AddMethods(__Instance, __arg0);
                }

                public void ClearMethods()
                {
                    __Internal.ClearMethods(__Instance);
                }

                public global::CppSharp.Parser.AST.AccessSpecifierDecl GetSpecifiers(uint i)
                {
                    var __ret = __Internal.GetSpecifiers(__Instance, i);
                    global::CppSharp.Parser.AST.AccessSpecifierDecl __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.AccessSpecifierDecl.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::CppSharp.Parser.AST.AccessSpecifierDecl) global::CppSharp.Parser.AST.AccessSpecifierDecl.NativeToManagedMap[__ret];
                    else __result0 = global::CppSharp.Parser.AST.AccessSpecifierDecl.__CreateInstance(__ret);
                    return __result0;
                }

                public void AddSpecifiers(global::CppSharp.Parser.AST.AccessSpecifierDecl s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var ____arg0 = s.__Instance;
                    var __arg0 = new global::System.IntPtr(&____arg0);
                    __Internal.AddSpecifiers(__Instance, __arg0);
                }

                public void ClearSpecifiers()
                {
                    __Internal.ClearSpecifiers(__Instance);
                }

                public bool IsPOD
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Class.__Internal*) __Instance)->isPOD != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Class.__Internal*)__Instance)->isPOD = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsAbstract
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Class.__Internal*) __Instance)->isAbstract != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Class.__Internal*)__Instance)->isAbstract = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsUnion
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Class.__Internal*) __Instance)->isUnion != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Class.__Internal*)__Instance)->isUnion = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsDynamic
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Class.__Internal*) __Instance)->isDynamic != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Class.__Internal*)__Instance)->isDynamic = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsPolymorphic
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Class.__Internal*) __Instance)->isPolymorphic != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Class.__Internal*)__Instance)->isPolymorphic = (byte) (value ? 1 : 0);
                    }
                }

                public bool HasNonTrivialDefaultConstructor
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Class.__Internal*) __Instance)->hasNonTrivialDefaultConstructor != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Class.__Internal*)__Instance)->hasNonTrivialDefaultConstructor = (byte) (value ? 1 : 0);
                    }
                }

                public bool HasNonTrivialCopyConstructor
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Class.__Internal*) __Instance)->hasNonTrivialCopyConstructor != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Class.__Internal*)__Instance)->hasNonTrivialCopyConstructor = (byte) (value ? 1 : 0);
                    }
                }

                public bool HasNonTrivialDestructor
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Class.__Internal*) __Instance)->hasNonTrivialDestructor != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Class.__Internal*)__Instance)->hasNonTrivialDestructor = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsExternCContext
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Class.__Internal*) __Instance)->isExternCContext != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Class.__Internal*)__Instance)->isExternCContext = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsInjected
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Class.__Internal*) __Instance)->isInjected != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Class.__Internal*)__Instance)->isInjected = (byte) (value ? 1 : 0);
                    }
                }

                public global::CppSharp.Parser.AST.ClassLayout Layout
                {
                    get
                    {
                        global::CppSharp.Parser.AST.ClassLayout __result0;
                        if (((global::CppSharp.Parser.AST.Class.__Internal*) __Instance)->layout == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.ClassLayout.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.Class.__Internal*) __Instance)->layout))
                            __result0 = (global::CppSharp.Parser.AST.ClassLayout) global::CppSharp.Parser.AST.ClassLayout.NativeToManagedMap[((global::CppSharp.Parser.AST.Class.__Internal*) __Instance)->layout];
                        else __result0 = global::CppSharp.Parser.AST.ClassLayout.__CreateInstance(((global::CppSharp.Parser.AST.Class.__Internal*) __Instance)->layout);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Class.__Internal*)__Instance)->layout = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public uint BasesCount
                {
                    get
                    {
                        var __ret = __Internal.GetBasesCount(__Instance);
                        return __ret;
                    }
                }

                public uint FieldsCount
                {
                    get
                    {
                        var __ret = __Internal.GetFieldsCount(__Instance);
                        return __ret;
                    }
                }

                public uint MethodsCount
                {
                    get
                    {
                        var __ret = __Internal.GetMethodsCount(__Instance);
                        return __ret;
                    }
                }

                public uint SpecifiersCount
                {
                    get
                    {
                        var __ret = __Internal.GetSpecifiersCount(__Instance);
                        return __ret;
                    }
                }
            }

            public unsafe partial class Template : global::CppSharp.Parser.AST.Declaration, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 164)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.DeclarationKind kind;

                    [FieldOffset(4)]
                    internal int maxFieldAlignment;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.AccessSpecifier access;

                    [FieldOffset(12)]
                    internal global::System.IntPtr _namespace;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal location;

                    [FieldOffset(20)]
                    internal int lineNumberStart;

                    [FieldOffset(24)]
                    internal int lineNumberEnd;

                    [FieldOffset(28)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C name;

                    [FieldOffset(52)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C USR;

                    [FieldOffset(76)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C debugText;

                    [FieldOffset(100)]
                    internal byte isIncomplete;

                    [FieldOffset(101)]
                    internal byte isDependent;

                    [FieldOffset(102)]
                    internal byte isImplicit;

                    [FieldOffset(103)]
                    internal byte isInvalid;

                    [FieldOffset(104)]
                    internal byte isDeprecated;

                    [FieldOffset(108)]
                    internal global::System.IntPtr completeDeclaration;

                    [FieldOffset(112)]
                    internal uint definitionOrder;

                    [FieldOffset(116)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_PreprocessedEntity___N_std_S_allocator__S0_ PreprocessedEntities;

                    [FieldOffset(128)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Declaration___N_std_S_allocator__S0_ Redeclarations;

                    [FieldOffset(140)]
                    internal global::System.IntPtr originalPtr;

                    [FieldOffset(144)]
                    internal global::System.IntPtr comment;

                    [FieldOffset(148)]
                    internal global::System.IntPtr TemplatedDecl;

                    [FieldOffset(152)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Declaration___N_std_S_allocator__S0_ Parameters;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0Template@AST@CppParser@CppSharp@@QAE@W4DeclarationKind@123@@Z")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance, global::CppSharp.Parser.AST.DeclarationKind kind);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0Template@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0Template@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??1Template@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern void dtor(global::System.IntPtr __instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getParameters@Template@AST@CppParser@CppSharp@@QAEPAVDeclaration@234@I@Z")]
                    internal static extern global::System.IntPtr GetParameters(global::System.IntPtr __instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?addParameters@Template@AST@CppParser@CppSharp@@QAEXAAPAVDeclaration@234@@Z")]
                    internal static extern void AddParameters(global::System.IntPtr __instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?clearParameters@Template@AST@CppParser@CppSharp@@QAEXXZ")]
                    internal static extern void ClearParameters(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getParametersCount@Template@AST@CppParser@CppSharp@@QAEIXZ")]
                    internal static extern uint GetParametersCount(global::System.IntPtr __instance);
                }

                internal static new global::CppSharp.Parser.AST.Template __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.Template(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.Template __CreateInstance(global::CppSharp.Parser.AST.Template.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.Template(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.Template.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Template.__Internal));
                    global::CppSharp.Parser.AST.Template.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private Template(global::CppSharp.Parser.AST.Template.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected Template(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public Template(global::CppSharp.Parser.AST.DeclarationKind kind)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Template.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance, kind);
                }

                public Template()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Template.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public Template(global::CppSharp.Parser.AST.Template _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Template.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Declaration __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor(__Instance, 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.Declaration GetParameters(uint i)
                {
                    var __ret = __Internal.GetParameters(__Instance, i);
                    global::CppSharp.Parser.AST.Declaration __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.Declaration.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::CppSharp.Parser.AST.Declaration) global::CppSharp.Parser.AST.Declaration.NativeToManagedMap[__ret];
                    else __result0 = global::CppSharp.Parser.AST.Declaration.__CreateInstance(__ret);
                    return __result0;
                }

                public void AddParameters(global::CppSharp.Parser.AST.Declaration s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var ____arg0 = s.__Instance;
                    var __arg0 = new global::System.IntPtr(&____arg0);
                    __Internal.AddParameters(__Instance, __arg0);
                }

                public void ClearParameters()
                {
                    __Internal.ClearParameters(__Instance);
                }

                public static implicit operator global::CppSharp.Parser.AST.Template(global::CppSharp.Parser.AST.DeclarationKind kind)
                {
                    return new global::CppSharp.Parser.AST.Template(kind);
                }

                public global::CppSharp.Parser.AST.Declaration TemplatedDecl
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Declaration __result0;
                        if (((global::CppSharp.Parser.AST.Template.__Internal*) __Instance)->TemplatedDecl == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Declaration.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.Template.__Internal*) __Instance)->TemplatedDecl))
                            __result0 = (global::CppSharp.Parser.AST.Declaration) global::CppSharp.Parser.AST.Declaration.NativeToManagedMap[((global::CppSharp.Parser.AST.Template.__Internal*) __Instance)->TemplatedDecl];
                        else __result0 = global::CppSharp.Parser.AST.Declaration.__CreateInstance(((global::CppSharp.Parser.AST.Template.__Internal*) __Instance)->TemplatedDecl);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Template.__Internal*)__Instance)->TemplatedDecl = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public uint ParametersCount
                {
                    get
                    {
                        var __ret = __Internal.GetParametersCount(__Instance);
                        return __ret;
                    }
                }
            }

            public unsafe partial class TypeAliasTemplate : global::CppSharp.Parser.AST.Template, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 164)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.DeclarationKind kind;

                    [FieldOffset(4)]
                    internal int maxFieldAlignment;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.AccessSpecifier access;

                    [FieldOffset(12)]
                    internal global::System.IntPtr _namespace;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal location;

                    [FieldOffset(20)]
                    internal int lineNumberStart;

                    [FieldOffset(24)]
                    internal int lineNumberEnd;

                    [FieldOffset(28)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C name;

                    [FieldOffset(52)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C USR;

                    [FieldOffset(76)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C debugText;

                    [FieldOffset(100)]
                    internal byte isIncomplete;

                    [FieldOffset(101)]
                    internal byte isDependent;

                    [FieldOffset(102)]
                    internal byte isImplicit;

                    [FieldOffset(103)]
                    internal byte isInvalid;

                    [FieldOffset(104)]
                    internal byte isDeprecated;

                    [FieldOffset(108)]
                    internal global::System.IntPtr completeDeclaration;

                    [FieldOffset(112)]
                    internal uint definitionOrder;

                    [FieldOffset(116)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_PreprocessedEntity___N_std_S_allocator__S0_ PreprocessedEntities;

                    [FieldOffset(128)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Declaration___N_std_S_allocator__S0_ Redeclarations;

                    [FieldOffset(140)]
                    internal global::System.IntPtr originalPtr;

                    [FieldOffset(144)]
                    internal global::System.IntPtr comment;

                    [FieldOffset(148)]
                    internal global::System.IntPtr TemplatedDecl;

                    [FieldOffset(152)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Declaration___N_std_S_allocator__S0_ Parameters;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0TypeAliasTemplate@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0TypeAliasTemplate@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??1TypeAliasTemplate@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern void dtor(global::System.IntPtr __instance, int delete);
                }

                internal static new global::CppSharp.Parser.AST.TypeAliasTemplate __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.TypeAliasTemplate(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.TypeAliasTemplate __CreateInstance(global::CppSharp.Parser.AST.TypeAliasTemplate.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.TypeAliasTemplate(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.TypeAliasTemplate.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TypeAliasTemplate.__Internal));
                    global::CppSharp.Parser.AST.TypeAliasTemplate.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private TypeAliasTemplate(global::CppSharp.Parser.AST.TypeAliasTemplate.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected TypeAliasTemplate(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public TypeAliasTemplate()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TypeAliasTemplate.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public TypeAliasTemplate(global::CppSharp.Parser.AST.TypeAliasTemplate _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TypeAliasTemplate.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Declaration __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor(__Instance, 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }
            }

            public unsafe partial class TemplateParameter : global::CppSharp.Parser.AST.Declaration, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 160)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.DeclarationKind kind;

                    [FieldOffset(4)]
                    internal int maxFieldAlignment;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.AccessSpecifier access;

                    [FieldOffset(12)]
                    internal global::System.IntPtr _namespace;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal location;

                    [FieldOffset(20)]
                    internal int lineNumberStart;

                    [FieldOffset(24)]
                    internal int lineNumberEnd;

                    [FieldOffset(28)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C name;

                    [FieldOffset(52)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C USR;

                    [FieldOffset(76)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C debugText;

                    [FieldOffset(100)]
                    internal byte isIncomplete;

                    [FieldOffset(101)]
                    internal byte isDependent;

                    [FieldOffset(102)]
                    internal byte isImplicit;

                    [FieldOffset(103)]
                    internal byte isInvalid;

                    [FieldOffset(104)]
                    internal byte isDeprecated;

                    [FieldOffset(108)]
                    internal global::System.IntPtr completeDeclaration;

                    [FieldOffset(112)]
                    internal uint definitionOrder;

                    [FieldOffset(116)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_PreprocessedEntity___N_std_S_allocator__S0_ PreprocessedEntities;

                    [FieldOffset(128)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Declaration___N_std_S_allocator__S0_ Redeclarations;

                    [FieldOffset(140)]
                    internal global::System.IntPtr originalPtr;

                    [FieldOffset(144)]
                    internal global::System.IntPtr comment;

                    [FieldOffset(148)]
                    internal uint depth;

                    [FieldOffset(152)]
                    internal uint index;

                    [FieldOffset(156)]
                    internal byte isParameterPack;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0TemplateParameter@AST@CppParser@CppSharp@@QAE@W4DeclarationKind@123@@Z")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance, global::CppSharp.Parser.AST.DeclarationKind kind);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0TemplateParameter@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??1TemplateParameter@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern void dtor(global::System.IntPtr __instance, int delete);
                }

                internal static new global::CppSharp.Parser.AST.TemplateParameter __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.TemplateParameter(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.TemplateParameter __CreateInstance(global::CppSharp.Parser.AST.TemplateParameter.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.TemplateParameter(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.TemplateParameter.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TemplateParameter.__Internal));
                    global::CppSharp.Parser.AST.TemplateParameter.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private TemplateParameter(global::CppSharp.Parser.AST.TemplateParameter.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected TemplateParameter(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public TemplateParameter(global::CppSharp.Parser.AST.DeclarationKind kind)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TemplateParameter.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance, kind);
                }

                public TemplateParameter(global::CppSharp.Parser.AST.TemplateParameter _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TemplateParameter.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Declaration __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor(__Instance, 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public static implicit operator global::CppSharp.Parser.AST.TemplateParameter(global::CppSharp.Parser.AST.DeclarationKind kind)
                {
                    return new global::CppSharp.Parser.AST.TemplateParameter(kind);
                }

                public uint Depth
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.TemplateParameter.__Internal*) __Instance)->depth;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.TemplateParameter.__Internal*)__Instance)->depth = value;
                    }
                }

                public uint Index
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.TemplateParameter.__Internal*) __Instance)->index;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.TemplateParameter.__Internal*)__Instance)->index = value;
                    }
                }

                public bool IsParameterPack
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.TemplateParameter.__Internal*) __Instance)->isParameterPack != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.TemplateParameter.__Internal*)__Instance)->isParameterPack = (byte) (value ? 1 : 0);
                    }
                }
            }

            public unsafe partial class TemplateTemplateParameter : global::CppSharp.Parser.AST.Template, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 168)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.DeclarationKind kind;

                    [FieldOffset(4)]
                    internal int maxFieldAlignment;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.AccessSpecifier access;

                    [FieldOffset(12)]
                    internal global::System.IntPtr _namespace;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal location;

                    [FieldOffset(20)]
                    internal int lineNumberStart;

                    [FieldOffset(24)]
                    internal int lineNumberEnd;

                    [FieldOffset(28)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C name;

                    [FieldOffset(52)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C USR;

                    [FieldOffset(76)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C debugText;

                    [FieldOffset(100)]
                    internal byte isIncomplete;

                    [FieldOffset(101)]
                    internal byte isDependent;

                    [FieldOffset(102)]
                    internal byte isImplicit;

                    [FieldOffset(103)]
                    internal byte isInvalid;

                    [FieldOffset(104)]
                    internal byte isDeprecated;

                    [FieldOffset(108)]
                    internal global::System.IntPtr completeDeclaration;

                    [FieldOffset(112)]
                    internal uint definitionOrder;

                    [FieldOffset(116)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_PreprocessedEntity___N_std_S_allocator__S0_ PreprocessedEntities;

                    [FieldOffset(128)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Declaration___N_std_S_allocator__S0_ Redeclarations;

                    [FieldOffset(140)]
                    internal global::System.IntPtr originalPtr;

                    [FieldOffset(144)]
                    internal global::System.IntPtr comment;

                    [FieldOffset(148)]
                    internal global::System.IntPtr TemplatedDecl;

                    [FieldOffset(152)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Declaration___N_std_S_allocator__S0_ Parameters;

                    [FieldOffset(164)]
                    internal byte isParameterPack;

                    [FieldOffset(165)]
                    internal byte isPackExpansion;

                    [FieldOffset(166)]
                    internal byte isExpandedParameterPack;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0TemplateTemplateParameter@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0TemplateTemplateParameter@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??1TemplateTemplateParameter@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern void dtor(global::System.IntPtr __instance, int delete);
                }

                internal static new global::CppSharp.Parser.AST.TemplateTemplateParameter __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.TemplateTemplateParameter(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.TemplateTemplateParameter __CreateInstance(global::CppSharp.Parser.AST.TemplateTemplateParameter.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.TemplateTemplateParameter(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.TemplateTemplateParameter.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TemplateTemplateParameter.__Internal));
                    global::CppSharp.Parser.AST.TemplateTemplateParameter.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private TemplateTemplateParameter(global::CppSharp.Parser.AST.TemplateTemplateParameter.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected TemplateTemplateParameter(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public TemplateTemplateParameter()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TemplateTemplateParameter.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public TemplateTemplateParameter(global::CppSharp.Parser.AST.TemplateTemplateParameter _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TemplateTemplateParameter.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Declaration __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor(__Instance, 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public bool IsParameterPack
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.TemplateTemplateParameter.__Internal*) __Instance)->isParameterPack != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.TemplateTemplateParameter.__Internal*)__Instance)->isParameterPack = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsPackExpansion
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.TemplateTemplateParameter.__Internal*) __Instance)->isPackExpansion != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.TemplateTemplateParameter.__Internal*)__Instance)->isPackExpansion = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsExpandedParameterPack
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.TemplateTemplateParameter.__Internal*) __Instance)->isExpandedParameterPack != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.TemplateTemplateParameter.__Internal*)__Instance)->isExpandedParameterPack = (byte) (value ? 1 : 0);
                    }
                }
            }

            public unsafe partial class TypeTemplateParameter : global::CppSharp.Parser.AST.TemplateParameter, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 168)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.DeclarationKind kind;

                    [FieldOffset(4)]
                    internal int maxFieldAlignment;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.AccessSpecifier access;

                    [FieldOffset(12)]
                    internal global::System.IntPtr _namespace;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal location;

                    [FieldOffset(20)]
                    internal int lineNumberStart;

                    [FieldOffset(24)]
                    internal int lineNumberEnd;

                    [FieldOffset(28)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C name;

                    [FieldOffset(52)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C USR;

                    [FieldOffset(76)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C debugText;

                    [FieldOffset(100)]
                    internal byte isIncomplete;

                    [FieldOffset(101)]
                    internal byte isDependent;

                    [FieldOffset(102)]
                    internal byte isImplicit;

                    [FieldOffset(103)]
                    internal byte isInvalid;

                    [FieldOffset(104)]
                    internal byte isDeprecated;

                    [FieldOffset(108)]
                    internal global::System.IntPtr completeDeclaration;

                    [FieldOffset(112)]
                    internal uint definitionOrder;

                    [FieldOffset(116)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_PreprocessedEntity___N_std_S_allocator__S0_ PreprocessedEntities;

                    [FieldOffset(128)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Declaration___N_std_S_allocator__S0_ Redeclarations;

                    [FieldOffset(140)]
                    internal global::System.IntPtr originalPtr;

                    [FieldOffset(144)]
                    internal global::System.IntPtr comment;

                    [FieldOffset(148)]
                    internal uint depth;

                    [FieldOffset(152)]
                    internal uint index;

                    [FieldOffset(156)]
                    internal byte isParameterPack;

                    [FieldOffset(160)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal defaultArgument;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0TypeTemplateParameter@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0TypeTemplateParameter@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??1TypeTemplateParameter@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern void dtor(global::System.IntPtr __instance, int delete);
                }

                internal static new global::CppSharp.Parser.AST.TypeTemplateParameter __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.TypeTemplateParameter(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.TypeTemplateParameter __CreateInstance(global::CppSharp.Parser.AST.TypeTemplateParameter.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.TypeTemplateParameter(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.TypeTemplateParameter.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TypeTemplateParameter.__Internal));
                    global::CppSharp.Parser.AST.TypeTemplateParameter.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private TypeTemplateParameter(global::CppSharp.Parser.AST.TypeTemplateParameter.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected TypeTemplateParameter(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public TypeTemplateParameter()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TypeTemplateParameter.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public TypeTemplateParameter(global::CppSharp.Parser.AST.TypeTemplateParameter _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TypeTemplateParameter.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Declaration __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor(__Instance, 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.QualifiedType DefaultArgument
                {
                    get
                    {
                        return global::CppSharp.Parser.AST.QualifiedType.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.TypeTemplateParameter.__Internal*) __Instance)->defaultArgument));
                    }

                    set
                    {
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                        ((global::CppSharp.Parser.AST.TypeTemplateParameter.__Internal*)__Instance)->defaultArgument = *(global::CppSharp.Parser.AST.QualifiedType.__Internal*) value.__Instance;
                    }
                }
            }

            public unsafe partial class NonTypeTemplateParameter : global::CppSharp.Parser.AST.TemplateParameter, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 176)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.DeclarationKind kind;

                    [FieldOffset(4)]
                    internal int maxFieldAlignment;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.AccessSpecifier access;

                    [FieldOffset(12)]
                    internal global::System.IntPtr _namespace;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal location;

                    [FieldOffset(20)]
                    internal int lineNumberStart;

                    [FieldOffset(24)]
                    internal int lineNumberEnd;

                    [FieldOffset(28)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C name;

                    [FieldOffset(52)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C USR;

                    [FieldOffset(76)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C debugText;

                    [FieldOffset(100)]
                    internal byte isIncomplete;

                    [FieldOffset(101)]
                    internal byte isDependent;

                    [FieldOffset(102)]
                    internal byte isImplicit;

                    [FieldOffset(103)]
                    internal byte isInvalid;

                    [FieldOffset(104)]
                    internal byte isDeprecated;

                    [FieldOffset(108)]
                    internal global::System.IntPtr completeDeclaration;

                    [FieldOffset(112)]
                    internal uint definitionOrder;

                    [FieldOffset(116)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_PreprocessedEntity___N_std_S_allocator__S0_ PreprocessedEntities;

                    [FieldOffset(128)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Declaration___N_std_S_allocator__S0_ Redeclarations;

                    [FieldOffset(140)]
                    internal global::System.IntPtr originalPtr;

                    [FieldOffset(144)]
                    internal global::System.IntPtr comment;

                    [FieldOffset(148)]
                    internal uint depth;

                    [FieldOffset(152)]
                    internal uint index;

                    [FieldOffset(156)]
                    internal byte isParameterPack;

                    [FieldOffset(160)]
                    internal global::System.IntPtr defaultArgument;

                    [FieldOffset(164)]
                    internal global::System.IntPtr defaultArgumentNew;

                    [FieldOffset(168)]
                    internal uint position;

                    [FieldOffset(172)]
                    internal byte isPackExpansion;

                    [FieldOffset(173)]
                    internal byte isExpandedParameterPack;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0NonTypeTemplateParameter@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0NonTypeTemplateParameter@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??1NonTypeTemplateParameter@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern void dtor(global::System.IntPtr __instance, int delete);
                }

                internal static new global::CppSharp.Parser.AST.NonTypeTemplateParameter __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.NonTypeTemplateParameter(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.NonTypeTemplateParameter __CreateInstance(global::CppSharp.Parser.AST.NonTypeTemplateParameter.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.NonTypeTemplateParameter(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.NonTypeTemplateParameter.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.NonTypeTemplateParameter.__Internal));
                    global::CppSharp.Parser.AST.NonTypeTemplateParameter.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private NonTypeTemplateParameter(global::CppSharp.Parser.AST.NonTypeTemplateParameter.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected NonTypeTemplateParameter(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public NonTypeTemplateParameter()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.NonTypeTemplateParameter.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public NonTypeTemplateParameter(global::CppSharp.Parser.AST.NonTypeTemplateParameter _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.NonTypeTemplateParameter.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Declaration __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor(__Instance, 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.ExpressionObsolete DefaultArgument
                {
                    get
                    {
                        global::CppSharp.Parser.AST.ExpressionObsolete __result0;
                        if (((global::CppSharp.Parser.AST.NonTypeTemplateParameter.__Internal*) __Instance)->defaultArgument == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.ExpressionObsolete.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.NonTypeTemplateParameter.__Internal*) __Instance)->defaultArgument))
                            __result0 = (global::CppSharp.Parser.AST.ExpressionObsolete) global::CppSharp.Parser.AST.ExpressionObsolete.NativeToManagedMap[((global::CppSharp.Parser.AST.NonTypeTemplateParameter.__Internal*) __Instance)->defaultArgument];
                        else __result0 = global::CppSharp.Parser.AST.ExpressionObsolete.__CreateInstance(((global::CppSharp.Parser.AST.NonTypeTemplateParameter.__Internal*) __Instance)->defaultArgument);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.NonTypeTemplateParameter.__Internal*)__Instance)->defaultArgument = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Expr DefaultArgumentNew
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.NonTypeTemplateParameter.__Internal*) __Instance)->defaultArgumentNew == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.NonTypeTemplateParameter.__Internal*) __Instance)->defaultArgumentNew))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.NonTypeTemplateParameter.__Internal*) __Instance)->defaultArgumentNew];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.NonTypeTemplateParameter.__Internal*) __Instance)->defaultArgumentNew);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.NonTypeTemplateParameter.__Internal*)__Instance)->defaultArgumentNew = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public uint Position
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.NonTypeTemplateParameter.__Internal*) __Instance)->position;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.NonTypeTemplateParameter.__Internal*)__Instance)->position = value;
                    }
                }

                public bool IsPackExpansion
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.NonTypeTemplateParameter.__Internal*) __Instance)->isPackExpansion != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.NonTypeTemplateParameter.__Internal*)__Instance)->isPackExpansion = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsExpandedParameterPack
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.NonTypeTemplateParameter.__Internal*) __Instance)->isExpandedParameterPack != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.NonTypeTemplateParameter.__Internal*)__Instance)->isExpandedParameterPack = (byte) (value ? 1 : 0);
                    }
                }
            }

            public unsafe partial class ClassTemplate : global::CppSharp.Parser.AST.Template, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 176)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.DeclarationKind kind;

                    [FieldOffset(4)]
                    internal int maxFieldAlignment;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.AccessSpecifier access;

                    [FieldOffset(12)]
                    internal global::System.IntPtr _namespace;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal location;

                    [FieldOffset(20)]
                    internal int lineNumberStart;

                    [FieldOffset(24)]
                    internal int lineNumberEnd;

                    [FieldOffset(28)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C name;

                    [FieldOffset(52)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C USR;

                    [FieldOffset(76)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C debugText;

                    [FieldOffset(100)]
                    internal byte isIncomplete;

                    [FieldOffset(101)]
                    internal byte isDependent;

                    [FieldOffset(102)]
                    internal byte isImplicit;

                    [FieldOffset(103)]
                    internal byte isInvalid;

                    [FieldOffset(104)]
                    internal byte isDeprecated;

                    [FieldOffset(108)]
                    internal global::System.IntPtr completeDeclaration;

                    [FieldOffset(112)]
                    internal uint definitionOrder;

                    [FieldOffset(116)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_PreprocessedEntity___N_std_S_allocator__S0_ PreprocessedEntities;

                    [FieldOffset(128)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Declaration___N_std_S_allocator__S0_ Redeclarations;

                    [FieldOffset(140)]
                    internal global::System.IntPtr originalPtr;

                    [FieldOffset(144)]
                    internal global::System.IntPtr comment;

                    [FieldOffset(148)]
                    internal global::System.IntPtr TemplatedDecl;

                    [FieldOffset(152)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Declaration___N_std_S_allocator__S0_ Parameters;

                    [FieldOffset(164)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_ClassTemplateSpecialization___N_std_S_allocator__S0_ Specializations;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0ClassTemplate@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0ClassTemplate@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??1ClassTemplate@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern void dtor(global::System.IntPtr __instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getSpecializations@ClassTemplate@AST@CppParser@CppSharp@@QAEPAVClassTemplateSpecialization@234@I@Z")]
                    internal static extern global::System.IntPtr GetSpecializations(global::System.IntPtr __instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?addSpecializations@ClassTemplate@AST@CppParser@CppSharp@@QAEXAAPAVClassTemplateSpecialization@234@@Z")]
                    internal static extern void AddSpecializations(global::System.IntPtr __instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?clearSpecializations@ClassTemplate@AST@CppParser@CppSharp@@QAEXXZ")]
                    internal static extern void ClearSpecializations(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?FindSpecialization@ClassTemplate@AST@CppParser@CppSharp@@QAEPAVClassTemplateSpecialization@234@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
                    internal static extern global::System.IntPtr FindSpecialization(global::System.IntPtr __instance, global::System.IntPtr usr);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?FindPartialSpecialization@ClassTemplate@AST@CppParser@CppSharp@@QAEPAVClassTemplatePartialSpecialization@234@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
                    internal static extern global::System.IntPtr FindPartialSpecialization(global::System.IntPtr __instance, global::System.IntPtr usr);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getSpecializationsCount@ClassTemplate@AST@CppParser@CppSharp@@QAEIXZ")]
                    internal static extern uint GetSpecializationsCount(global::System.IntPtr __instance);
                }

                internal static new global::CppSharp.Parser.AST.ClassTemplate __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.ClassTemplate(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.ClassTemplate __CreateInstance(global::CppSharp.Parser.AST.ClassTemplate.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.ClassTemplate(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.ClassTemplate.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ClassTemplate.__Internal));
                    global::CppSharp.Parser.AST.ClassTemplate.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private ClassTemplate(global::CppSharp.Parser.AST.ClassTemplate.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected ClassTemplate(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public ClassTemplate()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ClassTemplate.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public ClassTemplate(global::CppSharp.Parser.AST.ClassTemplate _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ClassTemplate.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Declaration __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor(__Instance, 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.ClassTemplateSpecialization GetSpecializations(uint i)
                {
                    var __ret = __Internal.GetSpecializations(__Instance, i);
                    global::CppSharp.Parser.AST.ClassTemplateSpecialization __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.ClassTemplateSpecialization.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::CppSharp.Parser.AST.ClassTemplateSpecialization) global::CppSharp.Parser.AST.ClassTemplateSpecialization.NativeToManagedMap[__ret];
                    else __result0 = global::CppSharp.Parser.AST.ClassTemplateSpecialization.__CreateInstance(__ret);
                    return __result0;
                }

                public void AddSpecializations(global::CppSharp.Parser.AST.ClassTemplateSpecialization s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var ____arg0 = s.__Instance;
                    var __arg0 = new global::System.IntPtr(&____arg0);
                    __Internal.AddSpecializations(__Instance, __arg0);
                }

                public void ClearSpecializations()
                {
                    __Internal.ClearSpecializations(__Instance);
                }

                public global::CppSharp.Parser.AST.ClassTemplateSpecialization FindSpecialization(string usr)
                {
                    var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                    global::Std.BasicStringExtensions.Assign(__basicString0, usr);
                    var __arg0 = __basicString0.__Instance;
                    var __ret = __Internal.FindSpecialization(__Instance, __arg0);
                    __basicString0.Dispose();
                    global::CppSharp.Parser.AST.ClassTemplateSpecialization __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.ClassTemplateSpecialization.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::CppSharp.Parser.AST.ClassTemplateSpecialization) global::CppSharp.Parser.AST.ClassTemplateSpecialization.NativeToManagedMap[__ret];
                    else __result0 = global::CppSharp.Parser.AST.ClassTemplateSpecialization.__CreateInstance(__ret);
                    return __result0;
                }

                public global::CppSharp.Parser.AST.ClassTemplatePartialSpecialization FindPartialSpecialization(string usr)
                {
                    var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                    global::Std.BasicStringExtensions.Assign(__basicString0, usr);
                    var __arg0 = __basicString0.__Instance;
                    var __ret = __Internal.FindPartialSpecialization(__Instance, __arg0);
                    __basicString0.Dispose();
                    global::CppSharp.Parser.AST.ClassTemplatePartialSpecialization __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.ClassTemplatePartialSpecialization.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::CppSharp.Parser.AST.ClassTemplatePartialSpecialization) global::CppSharp.Parser.AST.ClassTemplatePartialSpecialization.NativeToManagedMap[__ret];
                    else __result0 = global::CppSharp.Parser.AST.ClassTemplatePartialSpecialization.__CreateInstance(__ret);
                    return __result0;
                }

                public uint SpecializationsCount
                {
                    get
                    {
                        var __ret = __Internal.GetSpecializationsCount(__Instance);
                        return __ret;
                    }
                }
            }

            public unsafe partial class ClassTemplateSpecialization : global::CppSharp.Parser.AST.Class, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 352)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.DeclarationKind kind;

                    [FieldOffset(4)]
                    internal int maxFieldAlignment;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.AccessSpecifier access;

                    [FieldOffset(12)]
                    internal global::System.IntPtr _namespace;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal location;

                    [FieldOffset(20)]
                    internal int lineNumberStart;

                    [FieldOffset(24)]
                    internal int lineNumberEnd;

                    [FieldOffset(28)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C name;

                    [FieldOffset(52)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C USR;

                    [FieldOffset(76)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C debugText;

                    [FieldOffset(100)]
                    internal byte isIncomplete;

                    [FieldOffset(101)]
                    internal byte isDependent;

                    [FieldOffset(102)]
                    internal byte isImplicit;

                    [FieldOffset(103)]
                    internal byte isInvalid;

                    [FieldOffset(104)]
                    internal byte isDeprecated;

                    [FieldOffset(108)]
                    internal global::System.IntPtr completeDeclaration;

                    [FieldOffset(112)]
                    internal uint definitionOrder;

                    [FieldOffset(116)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_PreprocessedEntity___N_std_S_allocator__S0_ PreprocessedEntities;

                    [FieldOffset(128)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Declaration___N_std_S_allocator__S0_ Redeclarations;

                    [FieldOffset(140)]
                    internal global::System.IntPtr originalPtr;

                    [FieldOffset(144)]
                    internal global::System.IntPtr comment;

                    [FieldOffset(148)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Namespace___N_std_S_allocator__S0_ Namespaces;

                    [FieldOffset(160)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Enumeration___N_std_S_allocator__S0_ Enums;

                    [FieldOffset(172)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Function___N_std_S_allocator__S0_ Functions;

                    [FieldOffset(184)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Class___N_std_S_allocator__S0_ Classes;

                    [FieldOffset(196)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Template___N_std_S_allocator__S0_ Templates;

                    [FieldOffset(208)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_TypedefDecl___N_std_S_allocator__S0_ Typedefs;

                    [FieldOffset(220)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_TypeAlias___N_std_S_allocator__S0_ TypeAliases;

                    [FieldOffset(232)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Variable___N_std_S_allocator__S0_ Variables;

                    [FieldOffset(244)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Friend___N_std_S_allocator__S0_ Friends;

                    [FieldOffset(256)]
                    internal global::Std.Map.__Internalc__N_std_S_map____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C____N_CppSharp_N_CppParser_N_AST_S_Declaration___N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__S3_ anonymous;

                    [FieldOffset(264)]
                    internal byte isAnonymous;

                    [FieldOffset(268)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_BaseClassSpecifier___N_std_S_allocator__S0_ Bases;

                    [FieldOffset(280)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Field___N_std_S_allocator__S0_ Fields;

                    [FieldOffset(292)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Method___N_std_S_allocator__S0_ Methods;

                    [FieldOffset(304)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_AccessSpecifierDecl___N_std_S_allocator__S0_ Specifiers;

                    [FieldOffset(316)]
                    internal byte isPOD;

                    [FieldOffset(317)]
                    internal byte isAbstract;

                    [FieldOffset(318)]
                    internal byte isUnion;

                    [FieldOffset(319)]
                    internal byte isDynamic;

                    [FieldOffset(320)]
                    internal byte isPolymorphic;

                    [FieldOffset(321)]
                    internal byte hasNonTrivialDefaultConstructor;

                    [FieldOffset(322)]
                    internal byte hasNonTrivialCopyConstructor;

                    [FieldOffset(323)]
                    internal byte hasNonTrivialDestructor;

                    [FieldOffset(324)]
                    internal byte isExternCContext;

                    [FieldOffset(325)]
                    internal byte isInjected;

                    [FieldOffset(328)]
                    internal global::System.IntPtr layout;

                    [FieldOffset(332)]
                    internal global::System.IntPtr templatedDecl;

                    [FieldOffset(336)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector____N_CppSharp_N_CppParser_N_AST_S_TemplateArgument___N_std_S_allocator__S0_ Arguments;

                    [FieldOffset(348)]
                    internal global::CppSharp.Parser.AST.TemplateSpecializationKind specializationKind;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0ClassTemplateSpecialization@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0ClassTemplateSpecialization@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??1ClassTemplateSpecialization@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern void dtor(global::System.IntPtr __instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getArguments@ClassTemplateSpecialization@AST@CppParser@CppSharp@@QAE?AUTemplateArgument@234@I@Z")]
                    internal static extern void GetArguments(global::System.IntPtr __instance, global::System.IntPtr @return, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?addArguments@ClassTemplateSpecialization@AST@CppParser@CppSharp@@QAEXAAUTemplateArgument@234@@Z")]
                    internal static extern void AddArguments(global::System.IntPtr __instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?clearArguments@ClassTemplateSpecialization@AST@CppParser@CppSharp@@QAEXXZ")]
                    internal static extern void ClearArguments(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getArgumentsCount@ClassTemplateSpecialization@AST@CppParser@CppSharp@@QAEIXZ")]
                    internal static extern uint GetArgumentsCount(global::System.IntPtr __instance);
                }

                internal static new global::CppSharp.Parser.AST.ClassTemplateSpecialization __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.ClassTemplateSpecialization(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.ClassTemplateSpecialization __CreateInstance(global::CppSharp.Parser.AST.ClassTemplateSpecialization.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.ClassTemplateSpecialization(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.ClassTemplateSpecialization.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ClassTemplateSpecialization.__Internal));
                    global::CppSharp.Parser.AST.ClassTemplateSpecialization.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private ClassTemplateSpecialization(global::CppSharp.Parser.AST.ClassTemplateSpecialization.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected ClassTemplateSpecialization(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public ClassTemplateSpecialization()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ClassTemplateSpecialization.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public ClassTemplateSpecialization(global::CppSharp.Parser.AST.ClassTemplateSpecialization _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ClassTemplateSpecialization.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Declaration __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor(__Instance, 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.TemplateArgument GetArguments(uint i)
                {
                    var __ret = new global::CppSharp.Parser.AST.TemplateArgument.__Internal();
                    __Internal.GetArguments(__Instance, new IntPtr(&__ret), i);
                    return global::CppSharp.Parser.AST.TemplateArgument.__CreateInstance(__ret);
                }

                public void AddArguments(global::CppSharp.Parser.AST.TemplateArgument s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    __Internal.AddArguments(__Instance, __arg0);
                }

                public void ClearArguments()
                {
                    __Internal.ClearArguments(__Instance);
                }

                public global::CppSharp.Parser.AST.ClassTemplate TemplatedDecl
                {
                    get
                    {
                        global::CppSharp.Parser.AST.ClassTemplate __result0;
                        if (((global::CppSharp.Parser.AST.ClassTemplateSpecialization.__Internal*) __Instance)->templatedDecl == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.ClassTemplate.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.ClassTemplateSpecialization.__Internal*) __Instance)->templatedDecl))
                            __result0 = (global::CppSharp.Parser.AST.ClassTemplate) global::CppSharp.Parser.AST.ClassTemplate.NativeToManagedMap[((global::CppSharp.Parser.AST.ClassTemplateSpecialization.__Internal*) __Instance)->templatedDecl];
                        else __result0 = global::CppSharp.Parser.AST.ClassTemplate.__CreateInstance(((global::CppSharp.Parser.AST.ClassTemplateSpecialization.__Internal*) __Instance)->templatedDecl);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.ClassTemplateSpecialization.__Internal*)__Instance)->templatedDecl = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.TemplateSpecializationKind SpecializationKind
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.ClassTemplateSpecialization.__Internal*) __Instance)->specializationKind;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.ClassTemplateSpecialization.__Internal*)__Instance)->specializationKind = value;
                    }
                }

                public uint ArgumentsCount
                {
                    get
                    {
                        var __ret = __Internal.GetArgumentsCount(__Instance);
                        return __ret;
                    }
                }
            }

            public unsafe partial class ClassTemplatePartialSpecialization : global::CppSharp.Parser.AST.ClassTemplateSpecialization, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 352)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.DeclarationKind kind;

                    [FieldOffset(4)]
                    internal int maxFieldAlignment;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.AccessSpecifier access;

                    [FieldOffset(12)]
                    internal global::System.IntPtr _namespace;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal location;

                    [FieldOffset(20)]
                    internal int lineNumberStart;

                    [FieldOffset(24)]
                    internal int lineNumberEnd;

                    [FieldOffset(28)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C name;

                    [FieldOffset(52)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C USR;

                    [FieldOffset(76)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C debugText;

                    [FieldOffset(100)]
                    internal byte isIncomplete;

                    [FieldOffset(101)]
                    internal byte isDependent;

                    [FieldOffset(102)]
                    internal byte isImplicit;

                    [FieldOffset(103)]
                    internal byte isInvalid;

                    [FieldOffset(104)]
                    internal byte isDeprecated;

                    [FieldOffset(108)]
                    internal global::System.IntPtr completeDeclaration;

                    [FieldOffset(112)]
                    internal uint definitionOrder;

                    [FieldOffset(116)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_PreprocessedEntity___N_std_S_allocator__S0_ PreprocessedEntities;

                    [FieldOffset(128)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Declaration___N_std_S_allocator__S0_ Redeclarations;

                    [FieldOffset(140)]
                    internal global::System.IntPtr originalPtr;

                    [FieldOffset(144)]
                    internal global::System.IntPtr comment;

                    [FieldOffset(148)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Namespace___N_std_S_allocator__S0_ Namespaces;

                    [FieldOffset(160)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Enumeration___N_std_S_allocator__S0_ Enums;

                    [FieldOffset(172)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Function___N_std_S_allocator__S0_ Functions;

                    [FieldOffset(184)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Class___N_std_S_allocator__S0_ Classes;

                    [FieldOffset(196)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Template___N_std_S_allocator__S0_ Templates;

                    [FieldOffset(208)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_TypedefDecl___N_std_S_allocator__S0_ Typedefs;

                    [FieldOffset(220)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_TypeAlias___N_std_S_allocator__S0_ TypeAliases;

                    [FieldOffset(232)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Variable___N_std_S_allocator__S0_ Variables;

                    [FieldOffset(244)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Friend___N_std_S_allocator__S0_ Friends;

                    [FieldOffset(256)]
                    internal global::Std.Map.__Internalc__N_std_S_map____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C____N_CppSharp_N_CppParser_N_AST_S_Declaration___N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__S3_ anonymous;

                    [FieldOffset(264)]
                    internal byte isAnonymous;

                    [FieldOffset(268)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_BaseClassSpecifier___N_std_S_allocator__S0_ Bases;

                    [FieldOffset(280)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Field___N_std_S_allocator__S0_ Fields;

                    [FieldOffset(292)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Method___N_std_S_allocator__S0_ Methods;

                    [FieldOffset(304)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_AccessSpecifierDecl___N_std_S_allocator__S0_ Specifiers;

                    [FieldOffset(316)]
                    internal byte isPOD;

                    [FieldOffset(317)]
                    internal byte isAbstract;

                    [FieldOffset(318)]
                    internal byte isUnion;

                    [FieldOffset(319)]
                    internal byte isDynamic;

                    [FieldOffset(320)]
                    internal byte isPolymorphic;

                    [FieldOffset(321)]
                    internal byte hasNonTrivialDefaultConstructor;

                    [FieldOffset(322)]
                    internal byte hasNonTrivialCopyConstructor;

                    [FieldOffset(323)]
                    internal byte hasNonTrivialDestructor;

                    [FieldOffset(324)]
                    internal byte isExternCContext;

                    [FieldOffset(325)]
                    internal byte isInjected;

                    [FieldOffset(328)]
                    internal global::System.IntPtr layout;

                    [FieldOffset(332)]
                    internal global::System.IntPtr templatedDecl;

                    [FieldOffset(336)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector____N_CppSharp_N_CppParser_N_AST_S_TemplateArgument___N_std_S_allocator__S0_ Arguments;

                    [FieldOffset(348)]
                    internal global::CppSharp.Parser.AST.TemplateSpecializationKind specializationKind;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0ClassTemplatePartialSpecialization@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0ClassTemplatePartialSpecialization@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??1ClassTemplatePartialSpecialization@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern void dtor(global::System.IntPtr __instance, int delete);
                }

                internal static new global::CppSharp.Parser.AST.ClassTemplatePartialSpecialization __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.ClassTemplatePartialSpecialization(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.ClassTemplatePartialSpecialization __CreateInstance(global::CppSharp.Parser.AST.ClassTemplatePartialSpecialization.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.ClassTemplatePartialSpecialization(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.ClassTemplatePartialSpecialization.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ClassTemplatePartialSpecialization.__Internal));
                    global::CppSharp.Parser.AST.ClassTemplatePartialSpecialization.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private ClassTemplatePartialSpecialization(global::CppSharp.Parser.AST.ClassTemplatePartialSpecialization.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected ClassTemplatePartialSpecialization(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public ClassTemplatePartialSpecialization()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ClassTemplatePartialSpecialization.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public ClassTemplatePartialSpecialization(global::CppSharp.Parser.AST.ClassTemplatePartialSpecialization _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ClassTemplatePartialSpecialization.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Declaration __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor(__Instance, 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }
            }

            public unsafe partial class FunctionTemplate : global::CppSharp.Parser.AST.Template, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 176)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.DeclarationKind kind;

                    [FieldOffset(4)]
                    internal int maxFieldAlignment;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.AccessSpecifier access;

                    [FieldOffset(12)]
                    internal global::System.IntPtr _namespace;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal location;

                    [FieldOffset(20)]
                    internal int lineNumberStart;

                    [FieldOffset(24)]
                    internal int lineNumberEnd;

                    [FieldOffset(28)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C name;

                    [FieldOffset(52)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C USR;

                    [FieldOffset(76)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C debugText;

                    [FieldOffset(100)]
                    internal byte isIncomplete;

                    [FieldOffset(101)]
                    internal byte isDependent;

                    [FieldOffset(102)]
                    internal byte isImplicit;

                    [FieldOffset(103)]
                    internal byte isInvalid;

                    [FieldOffset(104)]
                    internal byte isDeprecated;

                    [FieldOffset(108)]
                    internal global::System.IntPtr completeDeclaration;

                    [FieldOffset(112)]
                    internal uint definitionOrder;

                    [FieldOffset(116)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_PreprocessedEntity___N_std_S_allocator__S0_ PreprocessedEntities;

                    [FieldOffset(128)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Declaration___N_std_S_allocator__S0_ Redeclarations;

                    [FieldOffset(140)]
                    internal global::System.IntPtr originalPtr;

                    [FieldOffset(144)]
                    internal global::System.IntPtr comment;

                    [FieldOffset(148)]
                    internal global::System.IntPtr TemplatedDecl;

                    [FieldOffset(152)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Declaration___N_std_S_allocator__S0_ Parameters;

                    [FieldOffset(164)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_FunctionTemplateSpecialization___N_std_S_allocator__S0_ Specializations;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0FunctionTemplate@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0FunctionTemplate@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??1FunctionTemplate@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern void dtor(global::System.IntPtr __instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getSpecializations@FunctionTemplate@AST@CppParser@CppSharp@@QAEPAVFunctionTemplateSpecialization@234@I@Z")]
                    internal static extern global::System.IntPtr GetSpecializations(global::System.IntPtr __instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?addSpecializations@FunctionTemplate@AST@CppParser@CppSharp@@QAEXAAPAVFunctionTemplateSpecialization@234@@Z")]
                    internal static extern void AddSpecializations(global::System.IntPtr __instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?clearSpecializations@FunctionTemplate@AST@CppParser@CppSharp@@QAEXXZ")]
                    internal static extern void ClearSpecializations(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?FindSpecialization@FunctionTemplate@AST@CppParser@CppSharp@@QAEPAVFunctionTemplateSpecialization@234@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
                    internal static extern global::System.IntPtr FindSpecialization(global::System.IntPtr __instance, global::System.IntPtr usr);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getSpecializationsCount@FunctionTemplate@AST@CppParser@CppSharp@@QAEIXZ")]
                    internal static extern uint GetSpecializationsCount(global::System.IntPtr __instance);
                }

                internal static new global::CppSharp.Parser.AST.FunctionTemplate __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.FunctionTemplate(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.FunctionTemplate __CreateInstance(global::CppSharp.Parser.AST.FunctionTemplate.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.FunctionTemplate(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.FunctionTemplate.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.FunctionTemplate.__Internal));
                    global::CppSharp.Parser.AST.FunctionTemplate.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private FunctionTemplate(global::CppSharp.Parser.AST.FunctionTemplate.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected FunctionTemplate(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public FunctionTemplate()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.FunctionTemplate.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public FunctionTemplate(global::CppSharp.Parser.AST.FunctionTemplate _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.FunctionTemplate.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Declaration __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor(__Instance, 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.FunctionTemplateSpecialization GetSpecializations(uint i)
                {
                    var __ret = __Internal.GetSpecializations(__Instance, i);
                    global::CppSharp.Parser.AST.FunctionTemplateSpecialization __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.FunctionTemplateSpecialization.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::CppSharp.Parser.AST.FunctionTemplateSpecialization) global::CppSharp.Parser.AST.FunctionTemplateSpecialization.NativeToManagedMap[__ret];
                    else __result0 = global::CppSharp.Parser.AST.FunctionTemplateSpecialization.__CreateInstance(__ret);
                    return __result0;
                }

                public void AddSpecializations(global::CppSharp.Parser.AST.FunctionTemplateSpecialization s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var ____arg0 = s.__Instance;
                    var __arg0 = new global::System.IntPtr(&____arg0);
                    __Internal.AddSpecializations(__Instance, __arg0);
                }

                public void ClearSpecializations()
                {
                    __Internal.ClearSpecializations(__Instance);
                }

                public global::CppSharp.Parser.AST.FunctionTemplateSpecialization FindSpecialization(string usr)
                {
                    var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                    global::Std.BasicStringExtensions.Assign(__basicString0, usr);
                    var __arg0 = __basicString0.__Instance;
                    var __ret = __Internal.FindSpecialization(__Instance, __arg0);
                    __basicString0.Dispose();
                    global::CppSharp.Parser.AST.FunctionTemplateSpecialization __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.FunctionTemplateSpecialization.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::CppSharp.Parser.AST.FunctionTemplateSpecialization) global::CppSharp.Parser.AST.FunctionTemplateSpecialization.NativeToManagedMap[__ret];
                    else __result0 = global::CppSharp.Parser.AST.FunctionTemplateSpecialization.__CreateInstance(__ret);
                    return __result0;
                }

                public uint SpecializationsCount
                {
                    get
                    {
                        var __ret = __Internal.GetSpecializationsCount(__Instance);
                        return __ret;
                    }
                }
            }

            public unsafe partial class FunctionTemplateSpecialization : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 24)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::System.IntPtr _template;

                    [FieldOffset(4)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector____N_CppSharp_N_CppParser_N_AST_S_TemplateArgument___N_std_S_allocator__S0_ Arguments;

                    [FieldOffset(16)]
                    internal global::System.IntPtr specializedFunction;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.TemplateSpecializationKind specializationKind;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0FunctionTemplateSpecialization@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0FunctionTemplateSpecialization@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??1FunctionTemplateSpecialization@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern void dtor(global::System.IntPtr __instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getArguments@FunctionTemplateSpecialization@AST@CppParser@CppSharp@@QAE?AUTemplateArgument@234@I@Z")]
                    internal static extern void GetArguments(global::System.IntPtr __instance, global::System.IntPtr @return, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?addArguments@FunctionTemplateSpecialization@AST@CppParser@CppSharp@@QAEXAAUTemplateArgument@234@@Z")]
                    internal static extern void AddArguments(global::System.IntPtr __instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?clearArguments@FunctionTemplateSpecialization@AST@CppParser@CppSharp@@QAEXXZ")]
                    internal static extern void ClearArguments(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getArgumentsCount@FunctionTemplateSpecialization@AST@CppParser@CppSharp@@QAEIXZ")]
                    internal static extern uint GetArgumentsCount(global::System.IntPtr __instance);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.FunctionTemplateSpecialization> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.FunctionTemplateSpecialization>();
                protected internal void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                internal static global::CppSharp.Parser.AST.FunctionTemplateSpecialization __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.FunctionTemplateSpecialization(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.FunctionTemplateSpecialization __CreateInstance(global::CppSharp.Parser.AST.FunctionTemplateSpecialization.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.FunctionTemplateSpecialization(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.FunctionTemplateSpecialization.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.FunctionTemplateSpecialization.__Internal));
                    global::CppSharp.Parser.AST.FunctionTemplateSpecialization.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private FunctionTemplateSpecialization(global::CppSharp.Parser.AST.FunctionTemplateSpecialization.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected FunctionTemplateSpecialization(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public FunctionTemplateSpecialization()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.FunctionTemplateSpecialization.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public FunctionTemplateSpecialization(global::CppSharp.Parser.AST.FunctionTemplateSpecialization _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.FunctionTemplateSpecialization.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                public virtual void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.FunctionTemplateSpecialization __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor(__Instance, 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.TemplateArgument GetArguments(uint i)
                {
                    var __ret = new global::CppSharp.Parser.AST.TemplateArgument.__Internal();
                    __Internal.GetArguments(__Instance, new IntPtr(&__ret), i);
                    return global::CppSharp.Parser.AST.TemplateArgument.__CreateInstance(__ret);
                }

                public void AddArguments(global::CppSharp.Parser.AST.TemplateArgument s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    __Internal.AddArguments(__Instance, __arg0);
                }

                public void ClearArguments()
                {
                    __Internal.ClearArguments(__Instance);
                }

                public global::CppSharp.Parser.AST.FunctionTemplate Template
                {
                    get
                    {
                        global::CppSharp.Parser.AST.FunctionTemplate __result0;
                        if (((global::CppSharp.Parser.AST.FunctionTemplateSpecialization.__Internal*) __Instance)->_template == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.FunctionTemplate.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.FunctionTemplateSpecialization.__Internal*) __Instance)->_template))
                            __result0 = (global::CppSharp.Parser.AST.FunctionTemplate) global::CppSharp.Parser.AST.FunctionTemplate.NativeToManagedMap[((global::CppSharp.Parser.AST.FunctionTemplateSpecialization.__Internal*) __Instance)->_template];
                        else __result0 = global::CppSharp.Parser.AST.FunctionTemplate.__CreateInstance(((global::CppSharp.Parser.AST.FunctionTemplateSpecialization.__Internal*) __Instance)->_template);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.FunctionTemplateSpecialization.__Internal*)__Instance)->_template = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Function SpecializedFunction
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Function __result0;
                        if (((global::CppSharp.Parser.AST.FunctionTemplateSpecialization.__Internal*) __Instance)->specializedFunction == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Function.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.FunctionTemplateSpecialization.__Internal*) __Instance)->specializedFunction))
                            __result0 = (global::CppSharp.Parser.AST.Function) global::CppSharp.Parser.AST.Function.NativeToManagedMap[((global::CppSharp.Parser.AST.FunctionTemplateSpecialization.__Internal*) __Instance)->specializedFunction];
                        else __result0 = global::CppSharp.Parser.AST.Function.__CreateInstance(((global::CppSharp.Parser.AST.FunctionTemplateSpecialization.__Internal*) __Instance)->specializedFunction);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.FunctionTemplateSpecialization.__Internal*)__Instance)->specializedFunction = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.TemplateSpecializationKind SpecializationKind
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.FunctionTemplateSpecialization.__Internal*) __Instance)->specializationKind;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.FunctionTemplateSpecialization.__Internal*)__Instance)->specializationKind = value;
                    }
                }

                public uint ArgumentsCount
                {
                    get
                    {
                        var __ret = __Internal.GetArgumentsCount(__Instance);
                        return __ret;
                    }
                }
            }

            public unsafe partial class VarTemplate : global::CppSharp.Parser.AST.Template, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 176)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.DeclarationKind kind;

                    [FieldOffset(4)]
                    internal int maxFieldAlignment;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.AccessSpecifier access;

                    [FieldOffset(12)]
                    internal global::System.IntPtr _namespace;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal location;

                    [FieldOffset(20)]
                    internal int lineNumberStart;

                    [FieldOffset(24)]
                    internal int lineNumberEnd;

                    [FieldOffset(28)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C name;

                    [FieldOffset(52)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C USR;

                    [FieldOffset(76)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C debugText;

                    [FieldOffset(100)]
                    internal byte isIncomplete;

                    [FieldOffset(101)]
                    internal byte isDependent;

                    [FieldOffset(102)]
                    internal byte isImplicit;

                    [FieldOffset(103)]
                    internal byte isInvalid;

                    [FieldOffset(104)]
                    internal byte isDeprecated;

                    [FieldOffset(108)]
                    internal global::System.IntPtr completeDeclaration;

                    [FieldOffset(112)]
                    internal uint definitionOrder;

                    [FieldOffset(116)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_PreprocessedEntity___N_std_S_allocator__S0_ PreprocessedEntities;

                    [FieldOffset(128)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Declaration___N_std_S_allocator__S0_ Redeclarations;

                    [FieldOffset(140)]
                    internal global::System.IntPtr originalPtr;

                    [FieldOffset(144)]
                    internal global::System.IntPtr comment;

                    [FieldOffset(148)]
                    internal global::System.IntPtr TemplatedDecl;

                    [FieldOffset(152)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Declaration___N_std_S_allocator__S0_ Parameters;

                    [FieldOffset(164)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_VarTemplateSpecialization___N_std_S_allocator__S0_ Specializations;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0VarTemplate@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0VarTemplate@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??1VarTemplate@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern void dtor(global::System.IntPtr __instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getSpecializations@VarTemplate@AST@CppParser@CppSharp@@QAEPAVVarTemplateSpecialization@234@I@Z")]
                    internal static extern global::System.IntPtr GetSpecializations(global::System.IntPtr __instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?addSpecializations@VarTemplate@AST@CppParser@CppSharp@@QAEXAAPAVVarTemplateSpecialization@234@@Z")]
                    internal static extern void AddSpecializations(global::System.IntPtr __instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?clearSpecializations@VarTemplate@AST@CppParser@CppSharp@@QAEXXZ")]
                    internal static extern void ClearSpecializations(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?FindSpecialization@VarTemplate@AST@CppParser@CppSharp@@QAEPAVVarTemplateSpecialization@234@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
                    internal static extern global::System.IntPtr FindSpecialization(global::System.IntPtr __instance, global::System.IntPtr usr);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?FindPartialSpecialization@VarTemplate@AST@CppParser@CppSharp@@QAEPAVVarTemplatePartialSpecialization@234@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
                    internal static extern global::System.IntPtr FindPartialSpecialization(global::System.IntPtr __instance, global::System.IntPtr usr);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getSpecializationsCount@VarTemplate@AST@CppParser@CppSharp@@QAEIXZ")]
                    internal static extern uint GetSpecializationsCount(global::System.IntPtr __instance);
                }

                internal static new global::CppSharp.Parser.AST.VarTemplate __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.VarTemplate(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.VarTemplate __CreateInstance(global::CppSharp.Parser.AST.VarTemplate.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.VarTemplate(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.VarTemplate.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.VarTemplate.__Internal));
                    global::CppSharp.Parser.AST.VarTemplate.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private VarTemplate(global::CppSharp.Parser.AST.VarTemplate.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected VarTemplate(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public VarTemplate()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.VarTemplate.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public VarTemplate(global::CppSharp.Parser.AST.VarTemplate _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.VarTemplate.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Declaration __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor(__Instance, 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.VarTemplateSpecialization GetSpecializations(uint i)
                {
                    var __ret = __Internal.GetSpecializations(__Instance, i);
                    global::CppSharp.Parser.AST.VarTemplateSpecialization __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.VarTemplateSpecialization.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::CppSharp.Parser.AST.VarTemplateSpecialization) global::CppSharp.Parser.AST.VarTemplateSpecialization.NativeToManagedMap[__ret];
                    else __result0 = global::CppSharp.Parser.AST.VarTemplateSpecialization.__CreateInstance(__ret);
                    return __result0;
                }

                public void AddSpecializations(global::CppSharp.Parser.AST.VarTemplateSpecialization s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var ____arg0 = s.__Instance;
                    var __arg0 = new global::System.IntPtr(&____arg0);
                    __Internal.AddSpecializations(__Instance, __arg0);
                }

                public void ClearSpecializations()
                {
                    __Internal.ClearSpecializations(__Instance);
                }

                public global::CppSharp.Parser.AST.VarTemplateSpecialization FindSpecialization(string usr)
                {
                    var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                    global::Std.BasicStringExtensions.Assign(__basicString0, usr);
                    var __arg0 = __basicString0.__Instance;
                    var __ret = __Internal.FindSpecialization(__Instance, __arg0);
                    __basicString0.Dispose();
                    global::CppSharp.Parser.AST.VarTemplateSpecialization __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.VarTemplateSpecialization.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::CppSharp.Parser.AST.VarTemplateSpecialization) global::CppSharp.Parser.AST.VarTemplateSpecialization.NativeToManagedMap[__ret];
                    else __result0 = global::CppSharp.Parser.AST.VarTemplateSpecialization.__CreateInstance(__ret);
                    return __result0;
                }

                public global::CppSharp.Parser.AST.VarTemplatePartialSpecialization FindPartialSpecialization(string usr)
                {
                    var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                    global::Std.BasicStringExtensions.Assign(__basicString0, usr);
                    var __arg0 = __basicString0.__Instance;
                    var __ret = __Internal.FindPartialSpecialization(__Instance, __arg0);
                    __basicString0.Dispose();
                    global::CppSharp.Parser.AST.VarTemplatePartialSpecialization __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.VarTemplatePartialSpecialization.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::CppSharp.Parser.AST.VarTemplatePartialSpecialization) global::CppSharp.Parser.AST.VarTemplatePartialSpecialization.NativeToManagedMap[__ret];
                    else __result0 = global::CppSharp.Parser.AST.VarTemplatePartialSpecialization.__CreateInstance(__ret);
                    return __result0;
                }

                public uint SpecializationsCount
                {
                    get
                    {
                        var __ret = __Internal.GetSpecializationsCount(__Instance);
                        return __ret;
                    }
                }
            }

            public unsafe partial class VarTemplateSpecialization : global::CppSharp.Parser.AST.Variable, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 200)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.DeclarationKind kind;

                    [FieldOffset(4)]
                    internal int maxFieldAlignment;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.AccessSpecifier access;

                    [FieldOffset(12)]
                    internal global::System.IntPtr _namespace;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal location;

                    [FieldOffset(20)]
                    internal int lineNumberStart;

                    [FieldOffset(24)]
                    internal int lineNumberEnd;

                    [FieldOffset(28)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C name;

                    [FieldOffset(52)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C USR;

                    [FieldOffset(76)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C debugText;

                    [FieldOffset(100)]
                    internal byte isIncomplete;

                    [FieldOffset(101)]
                    internal byte isDependent;

                    [FieldOffset(102)]
                    internal byte isImplicit;

                    [FieldOffset(103)]
                    internal byte isInvalid;

                    [FieldOffset(104)]
                    internal byte isDeprecated;

                    [FieldOffset(108)]
                    internal global::System.IntPtr completeDeclaration;

                    [FieldOffset(112)]
                    internal uint definitionOrder;

                    [FieldOffset(116)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_PreprocessedEntity___N_std_S_allocator__S0_ PreprocessedEntities;

                    [FieldOffset(128)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Declaration___N_std_S_allocator__S0_ Redeclarations;

                    [FieldOffset(140)]
                    internal global::System.IntPtr originalPtr;

                    [FieldOffset(144)]
                    internal global::System.IntPtr comment;

                    [FieldOffset(148)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C mangled;

                    [FieldOffset(172)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal qualifiedType;

                    [FieldOffset(180)]
                    internal global::System.IntPtr templatedDecl;

                    [FieldOffset(184)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector____N_CppSharp_N_CppParser_N_AST_S_TemplateArgument___N_std_S_allocator__S0_ Arguments;

                    [FieldOffset(196)]
                    internal global::CppSharp.Parser.AST.TemplateSpecializationKind specializationKind;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0VarTemplateSpecialization@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0VarTemplateSpecialization@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??1VarTemplateSpecialization@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern void dtor(global::System.IntPtr __instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getArguments@VarTemplateSpecialization@AST@CppParser@CppSharp@@QAE?AUTemplateArgument@234@I@Z")]
                    internal static extern void GetArguments(global::System.IntPtr __instance, global::System.IntPtr @return, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?addArguments@VarTemplateSpecialization@AST@CppParser@CppSharp@@QAEXAAUTemplateArgument@234@@Z")]
                    internal static extern void AddArguments(global::System.IntPtr __instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?clearArguments@VarTemplateSpecialization@AST@CppParser@CppSharp@@QAEXXZ")]
                    internal static extern void ClearArguments(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getArgumentsCount@VarTemplateSpecialization@AST@CppParser@CppSharp@@QAEIXZ")]
                    internal static extern uint GetArgumentsCount(global::System.IntPtr __instance);
                }

                internal static new global::CppSharp.Parser.AST.VarTemplateSpecialization __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.VarTemplateSpecialization(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.VarTemplateSpecialization __CreateInstance(global::CppSharp.Parser.AST.VarTemplateSpecialization.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.VarTemplateSpecialization(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.VarTemplateSpecialization.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.VarTemplateSpecialization.__Internal));
                    global::CppSharp.Parser.AST.VarTemplateSpecialization.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private VarTemplateSpecialization(global::CppSharp.Parser.AST.VarTemplateSpecialization.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected VarTemplateSpecialization(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public VarTemplateSpecialization()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.VarTemplateSpecialization.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public VarTemplateSpecialization(global::CppSharp.Parser.AST.VarTemplateSpecialization _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.VarTemplateSpecialization.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Declaration __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor(__Instance, 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.TemplateArgument GetArguments(uint i)
                {
                    var __ret = new global::CppSharp.Parser.AST.TemplateArgument.__Internal();
                    __Internal.GetArguments(__Instance, new IntPtr(&__ret), i);
                    return global::CppSharp.Parser.AST.TemplateArgument.__CreateInstance(__ret);
                }

                public void AddArguments(global::CppSharp.Parser.AST.TemplateArgument s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = s.__Instance;
                    __Internal.AddArguments(__Instance, __arg0);
                }

                public void ClearArguments()
                {
                    __Internal.ClearArguments(__Instance);
                }

                public global::CppSharp.Parser.AST.VarTemplate TemplatedDecl
                {
                    get
                    {
                        global::CppSharp.Parser.AST.VarTemplate __result0;
                        if (((global::CppSharp.Parser.AST.VarTemplateSpecialization.__Internal*) __Instance)->templatedDecl == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.VarTemplate.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.VarTemplateSpecialization.__Internal*) __Instance)->templatedDecl))
                            __result0 = (global::CppSharp.Parser.AST.VarTemplate) global::CppSharp.Parser.AST.VarTemplate.NativeToManagedMap[((global::CppSharp.Parser.AST.VarTemplateSpecialization.__Internal*) __Instance)->templatedDecl];
                        else __result0 = global::CppSharp.Parser.AST.VarTemplate.__CreateInstance(((global::CppSharp.Parser.AST.VarTemplateSpecialization.__Internal*) __Instance)->templatedDecl);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.VarTemplateSpecialization.__Internal*)__Instance)->templatedDecl = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.TemplateSpecializationKind SpecializationKind
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.VarTemplateSpecialization.__Internal*) __Instance)->specializationKind;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.VarTemplateSpecialization.__Internal*)__Instance)->specializationKind = value;
                    }
                }

                public uint ArgumentsCount
                {
                    get
                    {
                        var __ret = __Internal.GetArgumentsCount(__Instance);
                        return __ret;
                    }
                }
            }

            public unsafe partial class VarTemplatePartialSpecialization : global::CppSharp.Parser.AST.VarTemplateSpecialization, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 200)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.DeclarationKind kind;

                    [FieldOffset(4)]
                    internal int maxFieldAlignment;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.AccessSpecifier access;

                    [FieldOffset(12)]
                    internal global::System.IntPtr _namespace;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal location;

                    [FieldOffset(20)]
                    internal int lineNumberStart;

                    [FieldOffset(24)]
                    internal int lineNumberEnd;

                    [FieldOffset(28)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C name;

                    [FieldOffset(52)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C USR;

                    [FieldOffset(76)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C debugText;

                    [FieldOffset(100)]
                    internal byte isIncomplete;

                    [FieldOffset(101)]
                    internal byte isDependent;

                    [FieldOffset(102)]
                    internal byte isImplicit;

                    [FieldOffset(103)]
                    internal byte isInvalid;

                    [FieldOffset(104)]
                    internal byte isDeprecated;

                    [FieldOffset(108)]
                    internal global::System.IntPtr completeDeclaration;

                    [FieldOffset(112)]
                    internal uint definitionOrder;

                    [FieldOffset(116)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_PreprocessedEntity___N_std_S_allocator__S0_ PreprocessedEntities;

                    [FieldOffset(128)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Declaration___N_std_S_allocator__S0_ Redeclarations;

                    [FieldOffset(140)]
                    internal global::System.IntPtr originalPtr;

                    [FieldOffset(144)]
                    internal global::System.IntPtr comment;

                    [FieldOffset(148)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C mangled;

                    [FieldOffset(172)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal qualifiedType;

                    [FieldOffset(180)]
                    internal global::System.IntPtr templatedDecl;

                    [FieldOffset(184)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector____N_CppSharp_N_CppParser_N_AST_S_TemplateArgument___N_std_S_allocator__S0_ Arguments;

                    [FieldOffset(196)]
                    internal global::CppSharp.Parser.AST.TemplateSpecializationKind specializationKind;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0VarTemplatePartialSpecialization@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0VarTemplatePartialSpecialization@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??1VarTemplatePartialSpecialization@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern void dtor(global::System.IntPtr __instance, int delete);
                }

                internal static new global::CppSharp.Parser.AST.VarTemplatePartialSpecialization __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.VarTemplatePartialSpecialization(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.VarTemplatePartialSpecialization __CreateInstance(global::CppSharp.Parser.AST.VarTemplatePartialSpecialization.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.VarTemplatePartialSpecialization(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.VarTemplatePartialSpecialization.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.VarTemplatePartialSpecialization.__Internal));
                    global::CppSharp.Parser.AST.VarTemplatePartialSpecialization.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private VarTemplatePartialSpecialization(global::CppSharp.Parser.AST.VarTemplatePartialSpecialization.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected VarTemplatePartialSpecialization(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public VarTemplatePartialSpecialization()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.VarTemplatePartialSpecialization.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public VarTemplatePartialSpecialization(global::CppSharp.Parser.AST.VarTemplatePartialSpecialization _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.VarTemplatePartialSpecialization.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Declaration __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor(__Instance, 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }
            }

            public unsafe partial class UnresolvedUsingTypename : global::CppSharp.Parser.AST.Declaration, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 148)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.DeclarationKind kind;

                    [FieldOffset(4)]
                    internal int maxFieldAlignment;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.AccessSpecifier access;

                    [FieldOffset(12)]
                    internal global::System.IntPtr _namespace;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal location;

                    [FieldOffset(20)]
                    internal int lineNumberStart;

                    [FieldOffset(24)]
                    internal int lineNumberEnd;

                    [FieldOffset(28)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C name;

                    [FieldOffset(52)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C USR;

                    [FieldOffset(76)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C debugText;

                    [FieldOffset(100)]
                    internal byte isIncomplete;

                    [FieldOffset(101)]
                    internal byte isDependent;

                    [FieldOffset(102)]
                    internal byte isImplicit;

                    [FieldOffset(103)]
                    internal byte isInvalid;

                    [FieldOffset(104)]
                    internal byte isDeprecated;

                    [FieldOffset(108)]
                    internal global::System.IntPtr completeDeclaration;

                    [FieldOffset(112)]
                    internal uint definitionOrder;

                    [FieldOffset(116)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_PreprocessedEntity___N_std_S_allocator__S0_ PreprocessedEntities;

                    [FieldOffset(128)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Declaration___N_std_S_allocator__S0_ Redeclarations;

                    [FieldOffset(140)]
                    internal global::System.IntPtr originalPtr;

                    [FieldOffset(144)]
                    internal global::System.IntPtr comment;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0UnresolvedUsingTypename@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0UnresolvedUsingTypename@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??1UnresolvedUsingTypename@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern void dtor(global::System.IntPtr __instance, int delete);
                }

                internal static new global::CppSharp.Parser.AST.UnresolvedUsingTypename __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.UnresolvedUsingTypename(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.UnresolvedUsingTypename __CreateInstance(global::CppSharp.Parser.AST.UnresolvedUsingTypename.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.UnresolvedUsingTypename(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.UnresolvedUsingTypename.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.UnresolvedUsingTypename.__Internal));
                    global::CppSharp.Parser.AST.UnresolvedUsingTypename.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private UnresolvedUsingTypename(global::CppSharp.Parser.AST.UnresolvedUsingTypename.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected UnresolvedUsingTypename(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public UnresolvedUsingTypename()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.UnresolvedUsingTypename.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public UnresolvedUsingTypename(global::CppSharp.Parser.AST.UnresolvedUsingTypename _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.UnresolvedUsingTypename.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Declaration __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor(__Instance, 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }
            }

            public unsafe partial class Namespace : global::CppSharp.Parser.AST.DeclarationContext, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 272)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.DeclarationKind kind;

                    [FieldOffset(4)]
                    internal int maxFieldAlignment;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.AccessSpecifier access;

                    [FieldOffset(12)]
                    internal global::System.IntPtr _namespace;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal location;

                    [FieldOffset(20)]
                    internal int lineNumberStart;

                    [FieldOffset(24)]
                    internal int lineNumberEnd;

                    [FieldOffset(28)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C name;

                    [FieldOffset(52)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C USR;

                    [FieldOffset(76)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C debugText;

                    [FieldOffset(100)]
                    internal byte isIncomplete;

                    [FieldOffset(101)]
                    internal byte isDependent;

                    [FieldOffset(102)]
                    internal byte isImplicit;

                    [FieldOffset(103)]
                    internal byte isInvalid;

                    [FieldOffset(104)]
                    internal byte isDeprecated;

                    [FieldOffset(108)]
                    internal global::System.IntPtr completeDeclaration;

                    [FieldOffset(112)]
                    internal uint definitionOrder;

                    [FieldOffset(116)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_PreprocessedEntity___N_std_S_allocator__S0_ PreprocessedEntities;

                    [FieldOffset(128)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Declaration___N_std_S_allocator__S0_ Redeclarations;

                    [FieldOffset(140)]
                    internal global::System.IntPtr originalPtr;

                    [FieldOffset(144)]
                    internal global::System.IntPtr comment;

                    [FieldOffset(148)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Namespace___N_std_S_allocator__S0_ Namespaces;

                    [FieldOffset(160)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Enumeration___N_std_S_allocator__S0_ Enums;

                    [FieldOffset(172)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Function___N_std_S_allocator__S0_ Functions;

                    [FieldOffset(184)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Class___N_std_S_allocator__S0_ Classes;

                    [FieldOffset(196)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Template___N_std_S_allocator__S0_ Templates;

                    [FieldOffset(208)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_TypedefDecl___N_std_S_allocator__S0_ Typedefs;

                    [FieldOffset(220)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_TypeAlias___N_std_S_allocator__S0_ TypeAliases;

                    [FieldOffset(232)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Variable___N_std_S_allocator__S0_ Variables;

                    [FieldOffset(244)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Friend___N_std_S_allocator__S0_ Friends;

                    [FieldOffset(256)]
                    internal global::Std.Map.__Internalc__N_std_S_map____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C____N_CppSharp_N_CppParser_N_AST_S_Declaration___N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__S3_ anonymous;

                    [FieldOffset(264)]
                    internal byte isAnonymous;

                    [FieldOffset(268)]
                    internal byte isInline;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0Namespace@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0Namespace@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??1Namespace@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern void dtor(global::System.IntPtr __instance, int delete);
                }

                internal static new global::CppSharp.Parser.AST.Namespace __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.Namespace(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.Namespace __CreateInstance(global::CppSharp.Parser.AST.Namespace.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.Namespace(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.Namespace.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Namespace.__Internal));
                    global::CppSharp.Parser.AST.Namespace.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private Namespace(global::CppSharp.Parser.AST.Namespace.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected Namespace(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public Namespace()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Namespace.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public Namespace(global::CppSharp.Parser.AST.Namespace _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Namespace.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Declaration __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor(__Instance, 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public bool IsInline
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Namespace.__Internal*) __Instance)->isInline != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Namespace.__Internal*)__Instance)->isInline = (byte) (value ? 1 : 0);
                    }
                }
            }

            public unsafe partial class PreprocessedEntity : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 12)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.MacroLocation macroLocation;

                    [FieldOffset(4)]
                    internal global::System.IntPtr originalPtr;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.DeclarationKind kind;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0PreprocessedEntity@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0PreprocessedEntity@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.PreprocessedEntity> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.PreprocessedEntity>();
                protected internal void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                internal static global::CppSharp.Parser.AST.PreprocessedEntity __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.PreprocessedEntity(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.PreprocessedEntity __CreateInstance(global::CppSharp.Parser.AST.PreprocessedEntity.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.PreprocessedEntity(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.PreprocessedEntity.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.PreprocessedEntity.__Internal));
                    *(global::CppSharp.Parser.AST.PreprocessedEntity.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private PreprocessedEntity(global::CppSharp.Parser.AST.PreprocessedEntity.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected PreprocessedEntity(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public PreprocessedEntity()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.PreprocessedEntity.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public PreprocessedEntity(global::CppSharp.Parser.AST.PreprocessedEntity _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.PreprocessedEntity.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.PreprocessedEntity.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.PreprocessedEntity.__Internal*) _0.__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                public virtual void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.PreprocessedEntity __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.MacroLocation MacroLocation
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.PreprocessedEntity.__Internal*) __Instance)->macroLocation;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.PreprocessedEntity.__Internal*)__Instance)->macroLocation = value;
                    }
                }

                public global::System.IntPtr OriginalPtr
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.PreprocessedEntity.__Internal*) __Instance)->originalPtr;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.PreprocessedEntity.__Internal*)__Instance)->originalPtr = (global::System.IntPtr) value;
                    }
                }

                public global::CppSharp.Parser.AST.DeclarationKind Kind
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.PreprocessedEntity.__Internal*) __Instance)->kind;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.PreprocessedEntity.__Internal*)__Instance)->kind = value;
                    }
                }
            }

            public unsafe partial class MacroDefinition : global::CppSharp.Parser.AST.PreprocessedEntity, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 68)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.MacroLocation macroLocation;

                    [FieldOffset(4)]
                    internal global::System.IntPtr originalPtr;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.DeclarationKind kind;

                    [FieldOffset(12)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C name;

                    [FieldOffset(36)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C expression;

                    [FieldOffset(60)]
                    internal int lineNumberStart;

                    [FieldOffset(64)]
                    internal int lineNumberEnd;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0MacroDefinition@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0MacroDefinition@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??1MacroDefinition@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern void dtor(global::System.IntPtr __instance, int delete);
                }

                internal static new global::CppSharp.Parser.AST.MacroDefinition __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.MacroDefinition(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.MacroDefinition __CreateInstance(global::CppSharp.Parser.AST.MacroDefinition.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.MacroDefinition(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.MacroDefinition.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.MacroDefinition.__Internal));
                    global::CppSharp.Parser.AST.MacroDefinition.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private MacroDefinition(global::CppSharp.Parser.AST.MacroDefinition.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected MacroDefinition(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public MacroDefinition()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.MacroDefinition.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public MacroDefinition(global::CppSharp.Parser.AST.MacroDefinition _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.MacroDefinition.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.PreprocessedEntity __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor(__Instance, 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public string Name
                {
                    get
                    {
                        var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.MacroDefinition.__Internal*) __Instance)->name));
                        return global::Std.BasicStringExtensions.Data(__basicStringRet0);
                    }

                    set
                    {
                        global::Std.BasicStringExtensions.__Internal.Assign(new global::System.IntPtr(&((global::CppSharp.Parser.AST.MacroDefinition.__Internal*)__Instance)->name), value);
                    }
                }

                public string Expression
                {
                    get
                    {
                        var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.MacroDefinition.__Internal*) __Instance)->expression));
                        return global::Std.BasicStringExtensions.Data(__basicStringRet0);
                    }

                    set
                    {
                        global::Std.BasicStringExtensions.__Internal.Assign(new global::System.IntPtr(&((global::CppSharp.Parser.AST.MacroDefinition.__Internal*)__Instance)->expression), value);
                    }
                }

                public int LineNumberStart
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.MacroDefinition.__Internal*) __Instance)->lineNumberStart;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.MacroDefinition.__Internal*)__Instance)->lineNumberStart = value;
                    }
                }

                public int LineNumberEnd
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.MacroDefinition.__Internal*) __Instance)->lineNumberEnd;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.MacroDefinition.__Internal*)__Instance)->lineNumberEnd = value;
                    }
                }
            }

            public unsafe partial class MacroExpansion : global::CppSharp.Parser.AST.PreprocessedEntity, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 64)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.MacroLocation macroLocation;

                    [FieldOffset(4)]
                    internal global::System.IntPtr originalPtr;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.DeclarationKind kind;

                    [FieldOffset(12)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C name;

                    [FieldOffset(36)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C text;

                    [FieldOffset(60)]
                    internal global::System.IntPtr definition;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0MacroExpansion@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0MacroExpansion@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??1MacroExpansion@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern void dtor(global::System.IntPtr __instance, int delete);
                }

                internal static new global::CppSharp.Parser.AST.MacroExpansion __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.MacroExpansion(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.MacroExpansion __CreateInstance(global::CppSharp.Parser.AST.MacroExpansion.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.MacroExpansion(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.MacroExpansion.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.MacroExpansion.__Internal));
                    global::CppSharp.Parser.AST.MacroExpansion.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private MacroExpansion(global::CppSharp.Parser.AST.MacroExpansion.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected MacroExpansion(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public MacroExpansion()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.MacroExpansion.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public MacroExpansion(global::CppSharp.Parser.AST.MacroExpansion _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.MacroExpansion.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.PreprocessedEntity __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor(__Instance, 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public string Name
                {
                    get
                    {
                        var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.MacroExpansion.__Internal*) __Instance)->name));
                        return global::Std.BasicStringExtensions.Data(__basicStringRet0);
                    }

                    set
                    {
                        global::Std.BasicStringExtensions.__Internal.Assign(new global::System.IntPtr(&((global::CppSharp.Parser.AST.MacroExpansion.__Internal*)__Instance)->name), value);
                    }
                }

                public string Text
                {
                    get
                    {
                        var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.MacroExpansion.__Internal*) __Instance)->text));
                        return global::Std.BasicStringExtensions.Data(__basicStringRet0);
                    }

                    set
                    {
                        global::Std.BasicStringExtensions.__Internal.Assign(new global::System.IntPtr(&((global::CppSharp.Parser.AST.MacroExpansion.__Internal*)__Instance)->text), value);
                    }
                }

                public global::CppSharp.Parser.AST.MacroDefinition Definition
                {
                    get
                    {
                        global::CppSharp.Parser.AST.MacroDefinition __result0;
                        if (((global::CppSharp.Parser.AST.MacroExpansion.__Internal*) __Instance)->definition == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.MacroDefinition.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.MacroExpansion.__Internal*) __Instance)->definition))
                            __result0 = (global::CppSharp.Parser.AST.MacroDefinition) global::CppSharp.Parser.AST.MacroDefinition.NativeToManagedMap[((global::CppSharp.Parser.AST.MacroExpansion.__Internal*) __Instance)->definition];
                        else __result0 = global::CppSharp.Parser.AST.MacroDefinition.__CreateInstance(((global::CppSharp.Parser.AST.MacroExpansion.__Internal*) __Instance)->definition);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.MacroExpansion.__Internal*)__Instance)->definition = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }
            }

            public unsafe partial class TranslationUnit : global::CppSharp.Parser.AST.Namespace, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 312)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.DeclarationKind kind;

                    [FieldOffset(4)]
                    internal int maxFieldAlignment;

                    [FieldOffset(8)]
                    internal global::CppSharp.Parser.AST.AccessSpecifier access;

                    [FieldOffset(12)]
                    internal global::System.IntPtr _namespace;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal location;

                    [FieldOffset(20)]
                    internal int lineNumberStart;

                    [FieldOffset(24)]
                    internal int lineNumberEnd;

                    [FieldOffset(28)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C name;

                    [FieldOffset(52)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C USR;

                    [FieldOffset(76)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C debugText;

                    [FieldOffset(100)]
                    internal byte isIncomplete;

                    [FieldOffset(101)]
                    internal byte isDependent;

                    [FieldOffset(102)]
                    internal byte isImplicit;

                    [FieldOffset(103)]
                    internal byte isInvalid;

                    [FieldOffset(104)]
                    internal byte isDeprecated;

                    [FieldOffset(108)]
                    internal global::System.IntPtr completeDeclaration;

                    [FieldOffset(112)]
                    internal uint definitionOrder;

                    [FieldOffset(116)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_PreprocessedEntity___N_std_S_allocator__S0_ PreprocessedEntities;

                    [FieldOffset(128)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Declaration___N_std_S_allocator__S0_ Redeclarations;

                    [FieldOffset(140)]
                    internal global::System.IntPtr originalPtr;

                    [FieldOffset(144)]
                    internal global::System.IntPtr comment;

                    [FieldOffset(148)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Namespace___N_std_S_allocator__S0_ Namespaces;

                    [FieldOffset(160)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Enumeration___N_std_S_allocator__S0_ Enums;

                    [FieldOffset(172)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Function___N_std_S_allocator__S0_ Functions;

                    [FieldOffset(184)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Class___N_std_S_allocator__S0_ Classes;

                    [FieldOffset(196)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Template___N_std_S_allocator__S0_ Templates;

                    [FieldOffset(208)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_TypedefDecl___N_std_S_allocator__S0_ Typedefs;

                    [FieldOffset(220)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_TypeAlias___N_std_S_allocator__S0_ TypeAliases;

                    [FieldOffset(232)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Variable___N_std_S_allocator__S0_ Variables;

                    [FieldOffset(244)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Friend___N_std_S_allocator__S0_ Friends;

                    [FieldOffset(256)]
                    internal global::Std.Map.__Internalc__N_std_S_map____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C____N_CppSharp_N_CppParser_N_AST_S_Declaration___N_std_S_less__S0____N_std_S_allocator____N_std_S_pair__1S0__S3_ anonymous;

                    [FieldOffset(264)]
                    internal byte isAnonymous;

                    [FieldOffset(268)]
                    internal byte isInline;

                    [FieldOffset(272)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C fileName;

                    [FieldOffset(296)]
                    internal byte isSystemHeader;

                    [FieldOffset(300)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_MacroDefinition___N_std_S_allocator__S0_ Macros;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0TranslationUnit@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0TranslationUnit@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??1TranslationUnit@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern void dtor(global::System.IntPtr __instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getMacros@TranslationUnit@AST@CppParser@CppSharp@@QAEPAVMacroDefinition@234@I@Z")]
                    internal static extern global::System.IntPtr GetMacros(global::System.IntPtr __instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?addMacros@TranslationUnit@AST@CppParser@CppSharp@@QAEXAAPAVMacroDefinition@234@@Z")]
                    internal static extern void AddMacros(global::System.IntPtr __instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?clearMacros@TranslationUnit@AST@CppParser@CppSharp@@QAEXXZ")]
                    internal static extern void ClearMacros(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getMacrosCount@TranslationUnit@AST@CppParser@CppSharp@@QAEIXZ")]
                    internal static extern uint GetMacrosCount(global::System.IntPtr __instance);
                }

                internal static new global::CppSharp.Parser.AST.TranslationUnit __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.TranslationUnit(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.TranslationUnit __CreateInstance(global::CppSharp.Parser.AST.TranslationUnit.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.TranslationUnit(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.TranslationUnit.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TranslationUnit.__Internal));
                    global::CppSharp.Parser.AST.TranslationUnit.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private TranslationUnit(global::CppSharp.Parser.AST.TranslationUnit.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected TranslationUnit(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public TranslationUnit()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TranslationUnit.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public TranslationUnit(global::CppSharp.Parser.AST.TranslationUnit _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TranslationUnit.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Declaration __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor(__Instance, 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.MacroDefinition GetMacros(uint i)
                {
                    var __ret = __Internal.GetMacros(__Instance, i);
                    global::CppSharp.Parser.AST.MacroDefinition __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.MacroDefinition.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::CppSharp.Parser.AST.MacroDefinition) global::CppSharp.Parser.AST.MacroDefinition.NativeToManagedMap[__ret];
                    else __result0 = global::CppSharp.Parser.AST.MacroDefinition.__CreateInstance(__ret);
                    return __result0;
                }

                public void AddMacros(global::CppSharp.Parser.AST.MacroDefinition s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var ____arg0 = s.__Instance;
                    var __arg0 = new global::System.IntPtr(&____arg0);
                    __Internal.AddMacros(__Instance, __arg0);
                }

                public void ClearMacros()
                {
                    __Internal.ClearMacros(__Instance);
                }

                public string FileName
                {
                    get
                    {
                        var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.TranslationUnit.__Internal*) __Instance)->fileName));
                        return global::Std.BasicStringExtensions.Data(__basicStringRet0);
                    }

                    set
                    {
                        global::Std.BasicStringExtensions.__Internal.Assign(new global::System.IntPtr(&((global::CppSharp.Parser.AST.TranslationUnit.__Internal*)__Instance)->fileName), value);
                    }
                }

                public bool IsSystemHeader
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.TranslationUnit.__Internal*) __Instance)->isSystemHeader != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.TranslationUnit.__Internal*)__Instance)->isSystemHeader = (byte) (value ? 1 : 0);
                    }
                }

                public uint MacrosCount
                {
                    get
                    {
                        var __ret = __Internal.GetMacrosCount(__Instance);
                        return __ret;
                    }
                }
            }

            public unsafe partial class ASTContext : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 12)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_TranslationUnit___N_std_S_allocator__S0_ TranslationUnits;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0ASTContext@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0ASTContext@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??1ASTContext@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern void dtor(global::System.IntPtr __instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?FindOrCreateModule@ASTContext@AST@CppParser@CppSharp@@QAEPAVTranslationUnit@234@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z")]
                    internal static extern global::System.IntPtr FindOrCreateModule(global::System.IntPtr __instance, global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C File);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getTranslationUnits@ASTContext@AST@CppParser@CppSharp@@QAEPAVTranslationUnit@234@I@Z")]
                    internal static extern global::System.IntPtr GetTranslationUnits(global::System.IntPtr __instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?addTranslationUnits@ASTContext@AST@CppParser@CppSharp@@QAEXAAPAVTranslationUnit@234@@Z")]
                    internal static extern void AddTranslationUnits(global::System.IntPtr __instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?clearTranslationUnits@ASTContext@AST@CppParser@CppSharp@@QAEXXZ")]
                    internal static extern void ClearTranslationUnits(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getTranslationUnitsCount@ASTContext@AST@CppParser@CppSharp@@QAEIXZ")]
                    internal static extern uint GetTranslationUnitsCount(global::System.IntPtr __instance);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.ASTContext> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.ASTContext>();
                protected internal void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                internal static global::CppSharp.Parser.AST.ASTContext __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.ASTContext(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.ASTContext __CreateInstance(global::CppSharp.Parser.AST.ASTContext.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.ASTContext(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.ASTContext.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ASTContext.__Internal));
                    global::CppSharp.Parser.AST.ASTContext.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private ASTContext(global::CppSharp.Parser.AST.ASTContext.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected ASTContext(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public ASTContext()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ASTContext.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public ASTContext(global::CppSharp.Parser.AST.ASTContext _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ASTContext.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                public virtual void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.ASTContext __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor(__Instance, 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.TranslationUnit FindOrCreateModule(string File)
                {
                    var __basicString0 = new global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>();
                    global::Std.BasicStringExtensions.Assign(__basicString0, File);
                    var __arg0 = *(global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C*) __basicString0.__Instance;
                    var __ret = __Internal.FindOrCreateModule(__Instance, __arg0);
                    __basicString0.Dispose();
                    global::CppSharp.Parser.AST.TranslationUnit __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.TranslationUnit.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::CppSharp.Parser.AST.TranslationUnit) global::CppSharp.Parser.AST.TranslationUnit.NativeToManagedMap[__ret];
                    else __result0 = global::CppSharp.Parser.AST.TranslationUnit.__CreateInstance(__ret);
                    return __result0;
                }

                public global::CppSharp.Parser.AST.TranslationUnit GetTranslationUnits(uint i)
                {
                    var __ret = __Internal.GetTranslationUnits(__Instance, i);
                    global::CppSharp.Parser.AST.TranslationUnit __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.TranslationUnit.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::CppSharp.Parser.AST.TranslationUnit) global::CppSharp.Parser.AST.TranslationUnit.NativeToManagedMap[__ret];
                    else __result0 = global::CppSharp.Parser.AST.TranslationUnit.__CreateInstance(__ret);
                    return __result0;
                }

                public void AddTranslationUnits(global::CppSharp.Parser.AST.TranslationUnit s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var ____arg0 = s.__Instance;
                    var __arg0 = new global::System.IntPtr(&____arg0);
                    __Internal.AddTranslationUnits(__Instance, __arg0);
                }

                public void ClearTranslationUnits()
                {
                    __Internal.ClearTranslationUnits(__Instance);
                }

                public uint TranslationUnitsCount
                {
                    get
                    {
                        var __ret = __Internal.GetTranslationUnitsCount(__Instance);
                        return __ret;
                    }
                }
            }
        }
    }
}

namespace CppSharp
{
    namespace Parser
    {
        namespace AST
        {
            public enum StmtClass
            {
                NoStmt = 0,
                GCCAsmStmt = 1,
                MSAsmStmt = 2,
                AttributedStmt = 3,
                BreakStmt = 4,
                CXXCatchStmt = 5,
                CXXForRangeStmt = 6,
                CXXTryStmt = 7,
                CapturedStmt = 8,
                CompoundStmt = 9,
                ContinueStmt = 10,
                CoreturnStmt = 11,
                CoroutineBodyStmt = 12,
                DeclStmt = 13,
                DoStmt = 14,
                BinaryConditionalOperator = 15,
                ConditionalOperator = 16,
                AddrLabelExpr = 17,
                ArrayInitIndexExpr = 18,
                ArrayInitLoopExpr = 19,
                ArraySubscriptExpr = 20,
                ArrayTypeTraitExpr = 21,
                AsTypeExpr = 22,
                AtomicExpr = 23,
                BinaryOperator = 24,
                CompoundAssignOperator = 25,
                BlockExpr = 26,
                CXXBindTemporaryExpr = 27,
                CXXBoolLiteralExpr = 28,
                CXXConstructExpr = 29,
                CXXTemporaryObjectExpr = 30,
                CXXDefaultArgExpr = 31,
                CXXDefaultInitExpr = 32,
                CXXDeleteExpr = 33,
                CXXDependentScopeMemberExpr = 34,
                CXXFoldExpr = 35,
                CXXInheritedCtorInitExpr = 36,
                CXXNewExpr = 37,
                CXXNoexceptExpr = 38,
                CXXNullPtrLiteralExpr = 39,
                CXXPseudoDestructorExpr = 40,
                CXXScalarValueInitExpr = 41,
                CXXStdInitializerListExpr = 42,
                CXXThisExpr = 43,
                CXXThrowExpr = 44,
                CXXTypeidExpr = 45,
                CXXUnresolvedConstructExpr = 46,
                CXXUuidofExpr = 47,
                CallExpr = 48,
                CUDAKernelCallExpr = 49,
                CXXMemberCallExpr = 50,
                CXXOperatorCallExpr = 51,
                UserDefinedLiteral = 52,
                CStyleCastExpr = 53,
                CXXFunctionalCastExpr = 54,
                CXXConstCastExpr = 55,
                CXXDynamicCastExpr = 56,
                CXXReinterpretCastExpr = 57,
                CXXStaticCastExpr = 58,
                ImplicitCastExpr = 60,
                CharacterLiteral = 61,
                ChooseExpr = 62,
                CompoundLiteralExpr = 63,
                ConvertVectorExpr = 64,
                CoawaitExpr = 65,
                CoyieldExpr = 66,
                DeclRefExpr = 67,
                DependentCoawaitExpr = 68,
                DependentScopeDeclRefExpr = 69,
                DesignatedInitExpr = 70,
                DesignatedInitUpdateExpr = 71,
                ExpressionTraitExpr = 72,
                ExtVectorElementExpr = 73,
                FixedPointLiteral = 74,
                FloatingLiteral = 75,
                ConstantExpr = 76,
                ExprWithCleanups = 77,
                FunctionParmPackExpr = 78,
                GNUNullExpr = 79,
                GenericSelectionExpr = 80,
                ImaginaryLiteral = 81,
                ImplicitValueInitExpr = 82,
                InitListExpr = 83,
                IntegerLiteral = 84,
                LambdaExpr = 85,
                MSPropertyRefExpr = 86,
                MSPropertySubscriptExpr = 87,
                MaterializeTemporaryExpr = 88,
                MemberExpr = 89,
                NoInitExpr = 90,
                OffsetOfExpr = 107,
                OpaqueValueExpr = 108,
                UnresolvedLookupExpr = 109,
                UnresolvedMemberExpr = 110,
                PackExpansionExpr = 111,
                ParenExpr = 112,
                ParenListExpr = 113,
                PredefinedExpr = 114,
                PseudoObjectExpr = 115,
                ShuffleVectorExpr = 116,
                SizeOfPackExpr = 117,
                StmtExpr = 118,
                StringLiteral = 119,
                SubstNonTypeTemplateParmExpr = 120,
                SubstNonTypeTemplateParmPackExpr = 121,
                TypeTraitExpr = 122,
                TypoExpr = 123,
                UnaryExprOrTypeTraitExpr = 124,
                UnaryOperator = 125,
                VAArgExpr = 126,
                ForStmt = 127,
                GotoStmt = 128,
                IfStmt = 129,
                IndirectGotoStmt = 130,
                LabelStmt = 131,
                MSDependentExistsStmt = 132,
                NullStmt = 133,
                ReturnStmt = 188,
                SEHExceptStmt = 189,
                SEHFinallyStmt = 190,
                SEHLeaveStmt = 191,
                SEHTryStmt = 192,
                CaseStmt = 193,
                DefaultStmt = 194,
                SwitchStmt = 195,
                WhileStmt = 196
            }

            public unsafe partial class Stmt : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 20)]
                public partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0Stmt@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0Stmt@AST@CppParser@CppSharp@@QAE@W4StmtClass@123@@Z")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance, global::CppSharp.Parser.AST.StmtClass klass);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0Stmt@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }

                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.Stmt> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.Stmt>();
                protected internal void*[] __OriginalVTables;

                protected bool __ownsNativeInstance;

                internal static global::CppSharp.Parser.AST.Stmt __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.Stmt(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.Stmt __CreateInstance(global::CppSharp.Parser.AST.Stmt.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.Stmt(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.Stmt.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Stmt.__Internal));
                    *(global::CppSharp.Parser.AST.Stmt.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private Stmt(global::CppSharp.Parser.AST.Stmt.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected Stmt(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public Stmt()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Stmt.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public Stmt(global::CppSharp.Parser.AST.StmtClass klass)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Stmt.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance, klass);
                }

                public Stmt(global::CppSharp.Parser.AST.Stmt _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Stmt.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.Stmt.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.Stmt.__Internal*) _0.__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                public virtual void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Stmt __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public static implicit operator global::CppSharp.Parser.AST.Stmt(global::CppSharp.Parser.AST.StmtClass klass)
                {
                    return new global::CppSharp.Parser.AST.Stmt(klass);
                }

                public global::CppSharp.Parser.AST.StmtClass StmtClass
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Stmt.__Internal*) __Instance)->stmtClass;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Stmt.__Internal*)__Instance)->stmtClass = value;
                    }
                }

                public global::CppSharp.Parser.SourceRange SourceRange
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceRange.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.Stmt.__Internal*) __Instance)->sourceRange));
                    }

                    set
                    {
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                        ((global::CppSharp.Parser.AST.Stmt.__Internal*)__Instance)->sourceRange = *(global::CppSharp.Parser.SourceRange.__Internal*) value.__Instance;
                    }
                }

                public global::CppSharp.Parser.SourceLocation BeginLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.Stmt.__Internal*) __Instance)->beginLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Stmt.__Internal*)__Instance)->beginLoc = value.__Instance;
                    }
                }

                public global::CppSharp.Parser.SourceLocation EndLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.Stmt.__Internal*) __Instance)->endLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Stmt.__Internal*)__Instance)->endLoc = value.__Instance;
                    }
                }
            }

            public unsafe partial class DeclStmt : global::CppSharp.Parser.AST.Stmt, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 40)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Declaration___N_std_S_allocator__S0_ decls;

                    [FieldOffset(32)]
                    internal byte isSingleDecl;

                    [FieldOffset(36)]
                    internal global::System.IntPtr singleDecl;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0DeclStmt@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0DeclStmt@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??1DeclStmt@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern void dtor(global::System.IntPtr __instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getdecls@DeclStmt@AST@CppParser@CppSharp@@QAEPAVDeclaration@234@I@Z")]
                    internal static extern global::System.IntPtr Getdecls(global::System.IntPtr __instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?adddecls@DeclStmt@AST@CppParser@CppSharp@@QAEXAAPAVDeclaration@234@@Z")]
                    internal static extern void Adddecls(global::System.IntPtr __instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?cleardecls@DeclStmt@AST@CppParser@CppSharp@@QAEXXZ")]
                    internal static extern void Cleardecls(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getdeclsCount@DeclStmt@AST@CppParser@CppSharp@@QAEIXZ")]
                    internal static extern uint GetdeclsCount(global::System.IntPtr __instance);
                }

                internal static new global::CppSharp.Parser.AST.DeclStmt __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.DeclStmt(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.DeclStmt __CreateInstance(global::CppSharp.Parser.AST.DeclStmt.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.DeclStmt(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.DeclStmt.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.DeclStmt.__Internal));
                    global::CppSharp.Parser.AST.DeclStmt.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private DeclStmt(global::CppSharp.Parser.AST.DeclStmt.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected DeclStmt(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public DeclStmt()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.DeclStmt.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public DeclStmt(global::CppSharp.Parser.AST.DeclStmt _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.DeclStmt.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Stmt __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor(__Instance, 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.Declaration Getdecls(uint i)
                {
                    var __ret = __Internal.Getdecls(__Instance, i);
                    global::CppSharp.Parser.AST.Declaration __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.Declaration.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::CppSharp.Parser.AST.Declaration) global::CppSharp.Parser.AST.Declaration.NativeToManagedMap[__ret];
                    else __result0 = global::CppSharp.Parser.AST.Declaration.__CreateInstance(__ret);
                    return __result0;
                }

                public void Adddecls(global::CppSharp.Parser.AST.Declaration s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var ____arg0 = s.__Instance;
                    var __arg0 = new global::System.IntPtr(&____arg0);
                    __Internal.Adddecls(__Instance, __arg0);
                }

                public void Cleardecls()
                {
                    __Internal.Cleardecls(__Instance);
                }

                public bool IsSingleDecl
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.DeclStmt.__Internal*) __Instance)->isSingleDecl != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.DeclStmt.__Internal*)__Instance)->isSingleDecl = (byte) (value ? 1 : 0);
                    }
                }

                public global::CppSharp.Parser.AST.Declaration SingleDecl
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Declaration __result0;
                        if (((global::CppSharp.Parser.AST.DeclStmt.__Internal*) __Instance)->singleDecl == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Declaration.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.DeclStmt.__Internal*) __Instance)->singleDecl))
                            __result0 = (global::CppSharp.Parser.AST.Declaration) global::CppSharp.Parser.AST.Declaration.NativeToManagedMap[((global::CppSharp.Parser.AST.DeclStmt.__Internal*) __Instance)->singleDecl];
                        else __result0 = global::CppSharp.Parser.AST.Declaration.__CreateInstance(((global::CppSharp.Parser.AST.DeclStmt.__Internal*) __Instance)->singleDecl);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.DeclStmt.__Internal*)__Instance)->singleDecl = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public uint GetdeclsCount
                {
                    get
                    {
                        var __ret = __Internal.GetdeclsCount(__Instance);
                        return __ret;
                    }
                }
            }

            public unsafe partial class NullStmt : global::CppSharp.Parser.AST.Stmt, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 28)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal semiLoc;

                    [FieldOffset(24)]
                    internal byte hasLeadingEmptyMacro;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0NullStmt@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0NullStmt@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.NullStmt __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.NullStmt(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.NullStmt __CreateInstance(global::CppSharp.Parser.AST.NullStmt.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.NullStmt(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.NullStmt.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.NullStmt.__Internal));
                    *(global::CppSharp.Parser.AST.NullStmt.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private NullStmt(global::CppSharp.Parser.AST.NullStmt.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected NullStmt(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public NullStmt()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.NullStmt.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public NullStmt(global::CppSharp.Parser.AST.NullStmt _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.NullStmt.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.NullStmt.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.NullStmt.__Internal*) _0.__Instance);
                }

                public global::CppSharp.Parser.SourceLocation SemiLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.NullStmt.__Internal*) __Instance)->semiLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.NullStmt.__Internal*)__Instance)->semiLoc = value.__Instance;
                    }
                }

                public bool HasLeadingEmptyMacro
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.NullStmt.__Internal*) __Instance)->hasLeadingEmptyMacro != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.NullStmt.__Internal*)__Instance)->hasLeadingEmptyMacro = (byte) (value ? 1 : 0);
                    }
                }
            }

            public unsafe partial class CompoundStmt : global::CppSharp.Parser.AST.Stmt, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 56)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Stmt___N_std_S_allocator__S0_ body;

                    [FieldOffset(32)]
                    internal byte body_empty;

                    [FieldOffset(36)]
                    internal uint size;

                    [FieldOffset(40)]
                    internal global::System.IntPtr body_front;

                    [FieldOffset(44)]
                    internal global::System.IntPtr body_back;

                    [FieldOffset(48)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal lBracLoc;

                    [FieldOffset(52)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal rBracLoc;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CompoundStmt@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CompoundStmt@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??1CompoundStmt@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern void dtor(global::System.IntPtr __instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getbody@CompoundStmt@AST@CppParser@CppSharp@@QAEPAVStmt@234@I@Z")]
                    internal static extern global::System.IntPtr Getbody(global::System.IntPtr __instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?addbody@CompoundStmt@AST@CppParser@CppSharp@@QAEXAAPAVStmt@234@@Z")]
                    internal static extern void Addbody(global::System.IntPtr __instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?clearbody@CompoundStmt@AST@CppParser@CppSharp@@QAEXXZ")]
                    internal static extern void Clearbody(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getbodyCount@CompoundStmt@AST@CppParser@CppSharp@@QAEIXZ")]
                    internal static extern uint GetbodyCount(global::System.IntPtr __instance);
                }

                internal static new global::CppSharp.Parser.AST.CompoundStmt __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CompoundStmt(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.CompoundStmt __CreateInstance(global::CppSharp.Parser.AST.CompoundStmt.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CompoundStmt(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.CompoundStmt.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CompoundStmt.__Internal));
                    global::CppSharp.Parser.AST.CompoundStmt.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private CompoundStmt(global::CppSharp.Parser.AST.CompoundStmt.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected CompoundStmt(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public CompoundStmt()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CompoundStmt.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public CompoundStmt(global::CppSharp.Parser.AST.CompoundStmt _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CompoundStmt.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Stmt __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor(__Instance, 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.Stmt Getbody(uint i)
                {
                    var __ret = __Internal.Getbody(__Instance, i);
                    global::CppSharp.Parser.AST.Stmt __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.Stmt.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::CppSharp.Parser.AST.Stmt) global::CppSharp.Parser.AST.Stmt.NativeToManagedMap[__ret];
                    else __result0 = global::CppSharp.Parser.AST.Stmt.__CreateInstance(__ret);
                    return __result0;
                }

                public void Addbody(global::CppSharp.Parser.AST.Stmt s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var ____arg0 = s.__Instance;
                    var __arg0 = new global::System.IntPtr(&____arg0);
                    __Internal.Addbody(__Instance, __arg0);
                }

                public void Clearbody()
                {
                    __Internal.Clearbody(__Instance);
                }

                public bool BodyEmpty
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.CompoundStmt.__Internal*) __Instance)->body_empty != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CompoundStmt.__Internal*)__Instance)->body_empty = (byte) (value ? 1 : 0);
                    }
                }

                public uint Size
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.CompoundStmt.__Internal*) __Instance)->size;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CompoundStmt.__Internal*)__Instance)->size = value;
                    }
                }

                public global::CppSharp.Parser.AST.Stmt BodyFront
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Stmt __result0;
                        if (((global::CppSharp.Parser.AST.CompoundStmt.__Internal*) __Instance)->body_front == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Stmt.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.CompoundStmt.__Internal*) __Instance)->body_front))
                            __result0 = (global::CppSharp.Parser.AST.Stmt) global::CppSharp.Parser.AST.Stmt.NativeToManagedMap[((global::CppSharp.Parser.AST.CompoundStmt.__Internal*) __Instance)->body_front];
                        else __result0 = global::CppSharp.Parser.AST.Stmt.__CreateInstance(((global::CppSharp.Parser.AST.CompoundStmt.__Internal*) __Instance)->body_front);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CompoundStmt.__Internal*)__Instance)->body_front = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Stmt BodyBack
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Stmt __result0;
                        if (((global::CppSharp.Parser.AST.CompoundStmt.__Internal*) __Instance)->body_back == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Stmt.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.CompoundStmt.__Internal*) __Instance)->body_back))
                            __result0 = (global::CppSharp.Parser.AST.Stmt) global::CppSharp.Parser.AST.Stmt.NativeToManagedMap[((global::CppSharp.Parser.AST.CompoundStmt.__Internal*) __Instance)->body_back];
                        else __result0 = global::CppSharp.Parser.AST.Stmt.__CreateInstance(((global::CppSharp.Parser.AST.CompoundStmt.__Internal*) __Instance)->body_back);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CompoundStmt.__Internal*)__Instance)->body_back = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.SourceLocation LBracLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.CompoundStmt.__Internal*) __Instance)->lBracLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CompoundStmt.__Internal*)__Instance)->lBracLoc = value.__Instance;
                    }
                }

                public global::CppSharp.Parser.SourceLocation RBracLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.CompoundStmt.__Internal*) __Instance)->rBracLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CompoundStmt.__Internal*)__Instance)->rBracLoc = value.__Instance;
                    }
                }

                public uint GetbodyCount
                {
                    get
                    {
                        var __ret = __Internal.GetbodyCount(__Instance);
                        return __ret;
                    }
                }
            }

            public unsafe partial class SwitchCase : global::CppSharp.Parser.AST.Stmt, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 32)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal keywordLoc;

                    [FieldOffset(24)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal colonLoc;

                    [FieldOffset(28)]
                    internal global::System.IntPtr subStmt;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0SwitchCase@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0SwitchCase@AST@CppParser@CppSharp@@QAE@W4StmtClass@123@@Z")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance, global::CppSharp.Parser.AST.StmtClass klass);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0SwitchCase@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.SwitchCase __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.SwitchCase(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.SwitchCase __CreateInstance(global::CppSharp.Parser.AST.SwitchCase.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.SwitchCase(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.SwitchCase.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.SwitchCase.__Internal));
                    *(global::CppSharp.Parser.AST.SwitchCase.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private SwitchCase(global::CppSharp.Parser.AST.SwitchCase.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected SwitchCase(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public SwitchCase()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.SwitchCase.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public SwitchCase(global::CppSharp.Parser.AST.StmtClass klass)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.SwitchCase.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance, klass);
                }

                public SwitchCase(global::CppSharp.Parser.AST.SwitchCase _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.SwitchCase.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.SwitchCase.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.SwitchCase.__Internal*) _0.__Instance);
                }

                public static implicit operator global::CppSharp.Parser.AST.SwitchCase(global::CppSharp.Parser.AST.StmtClass klass)
                {
                    return new global::CppSharp.Parser.AST.SwitchCase(klass);
                }

                public global::CppSharp.Parser.SourceLocation KeywordLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.SwitchCase.__Internal*) __Instance)->keywordLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.SwitchCase.__Internal*)__Instance)->keywordLoc = value.__Instance;
                    }
                }

                public global::CppSharp.Parser.SourceLocation ColonLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.SwitchCase.__Internal*) __Instance)->colonLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.SwitchCase.__Internal*)__Instance)->colonLoc = value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Stmt SubStmt
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Stmt __result0;
                        if (((global::CppSharp.Parser.AST.SwitchCase.__Internal*) __Instance)->subStmt == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Stmt.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.SwitchCase.__Internal*) __Instance)->subStmt))
                            __result0 = (global::CppSharp.Parser.AST.Stmt) global::CppSharp.Parser.AST.Stmt.NativeToManagedMap[((global::CppSharp.Parser.AST.SwitchCase.__Internal*) __Instance)->subStmt];
                        else __result0 = global::CppSharp.Parser.AST.Stmt.__CreateInstance(((global::CppSharp.Parser.AST.SwitchCase.__Internal*) __Instance)->subStmt);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.SwitchCase.__Internal*)__Instance)->subStmt = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }
            }

            public unsafe partial class CaseStmt : global::CppSharp.Parser.AST.SwitchCase, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 52)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal keywordLoc;

                    [FieldOffset(24)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal colonLoc;

                    [FieldOffset(28)]
                    internal global::System.IntPtr subStmt;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal caseLoc;

                    [FieldOffset(36)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal ellipsisLoc;

                    [FieldOffset(40)]
                    internal global::System.IntPtr lHS;

                    [FieldOffset(44)]
                    internal global::System.IntPtr rHS;

                    [FieldOffset(48)]
                    internal byte caseStmtIsGNURange;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CaseStmt@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CaseStmt@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.CaseStmt __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CaseStmt(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.CaseStmt __CreateInstance(global::CppSharp.Parser.AST.CaseStmt.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CaseStmt(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.CaseStmt.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CaseStmt.__Internal));
                    *(global::CppSharp.Parser.AST.CaseStmt.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private CaseStmt(global::CppSharp.Parser.AST.CaseStmt.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected CaseStmt(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public CaseStmt()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CaseStmt.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public CaseStmt(global::CppSharp.Parser.AST.CaseStmt _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CaseStmt.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.CaseStmt.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.CaseStmt.__Internal*) _0.__Instance);
                }

                public global::CppSharp.Parser.SourceLocation CaseLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.CaseStmt.__Internal*) __Instance)->caseLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CaseStmt.__Internal*)__Instance)->caseLoc = value.__Instance;
                    }
                }

                public global::CppSharp.Parser.SourceLocation EllipsisLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.CaseStmt.__Internal*) __Instance)->ellipsisLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CaseStmt.__Internal*)__Instance)->ellipsisLoc = value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Expr LHS
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.CaseStmt.__Internal*) __Instance)->lHS == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.CaseStmt.__Internal*) __Instance)->lHS))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.CaseStmt.__Internal*) __Instance)->lHS];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.CaseStmt.__Internal*) __Instance)->lHS);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CaseStmt.__Internal*)__Instance)->lHS = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Expr RHS
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.CaseStmt.__Internal*) __Instance)->rHS == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.CaseStmt.__Internal*) __Instance)->rHS))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.CaseStmt.__Internal*) __Instance)->rHS];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.CaseStmt.__Internal*) __Instance)->rHS);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CaseStmt.__Internal*)__Instance)->rHS = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public bool CaseStmtIsGNURange
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.CaseStmt.__Internal*) __Instance)->caseStmtIsGNURange != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CaseStmt.__Internal*)__Instance)->caseStmtIsGNURange = (byte) (value ? 1 : 0);
                    }
                }
            }

            public unsafe partial class DefaultStmt : global::CppSharp.Parser.AST.SwitchCase, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 36)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal keywordLoc;

                    [FieldOffset(24)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal colonLoc;

                    [FieldOffset(28)]
                    internal global::System.IntPtr subStmt;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal defaultLoc;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0DefaultStmt@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0DefaultStmt@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.DefaultStmt __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.DefaultStmt(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.DefaultStmt __CreateInstance(global::CppSharp.Parser.AST.DefaultStmt.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.DefaultStmt(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.DefaultStmt.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.DefaultStmt.__Internal));
                    *(global::CppSharp.Parser.AST.DefaultStmt.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private DefaultStmt(global::CppSharp.Parser.AST.DefaultStmt.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected DefaultStmt(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public DefaultStmt()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.DefaultStmt.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public DefaultStmt(global::CppSharp.Parser.AST.DefaultStmt _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.DefaultStmt.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.DefaultStmt.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.DefaultStmt.__Internal*) _0.__Instance);
                }

                public global::CppSharp.Parser.SourceLocation DefaultLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.DefaultStmt.__Internal*) __Instance)->defaultLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.DefaultStmt.__Internal*)__Instance)->defaultLoc = value.__Instance;
                    }
                }
            }

            public unsafe partial class LabelStmt : global::CppSharp.Parser.AST.Stmt, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 32)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal identLoc;

                    [FieldOffset(24)]
                    internal global::System.IntPtr subStmt;

                    [FieldOffset(28)]
                    internal global::System.IntPtr name;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0LabelStmt@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0LabelStmt@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.LabelStmt __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.LabelStmt(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.LabelStmt __CreateInstance(global::CppSharp.Parser.AST.LabelStmt.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.LabelStmt(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.LabelStmt.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.LabelStmt.__Internal));
                    *(global::CppSharp.Parser.AST.LabelStmt.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private LabelStmt(global::CppSharp.Parser.AST.LabelStmt.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected LabelStmt(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public LabelStmt()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.LabelStmt.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public LabelStmt(global::CppSharp.Parser.AST.LabelStmt _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.LabelStmt.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.LabelStmt.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.LabelStmt.__Internal*) _0.__Instance);
                }

                public global::CppSharp.Parser.SourceLocation IdentLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.LabelStmt.__Internal*) __Instance)->identLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.LabelStmt.__Internal*)__Instance)->identLoc = value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Stmt SubStmt
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Stmt __result0;
                        if (((global::CppSharp.Parser.AST.LabelStmt.__Internal*) __Instance)->subStmt == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Stmt.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.LabelStmt.__Internal*) __Instance)->subStmt))
                            __result0 = (global::CppSharp.Parser.AST.Stmt) global::CppSharp.Parser.AST.Stmt.NativeToManagedMap[((global::CppSharp.Parser.AST.LabelStmt.__Internal*) __Instance)->subStmt];
                        else __result0 = global::CppSharp.Parser.AST.Stmt.__CreateInstance(((global::CppSharp.Parser.AST.LabelStmt.__Internal*) __Instance)->subStmt);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.LabelStmt.__Internal*)__Instance)->subStmt = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public string Name
                {
                    get
                    {
                        if (((global::CppSharp.Parser.AST.LabelStmt.__Internal*) __Instance)->name == global::System.IntPtr.Zero)
                            return default(string);
                        var __retPtr = (byte*) ((global::CppSharp.Parser.AST.LabelStmt.__Internal*) __Instance)->name;
                        int __length = 0;
                        while (*(__retPtr++) != 0) __length += sizeof(byte);
                        return global::System.Text.Encoding.UTF8.GetString((byte*) ((global::CppSharp.Parser.AST.LabelStmt.__Internal*) __Instance)->name, __length);
                    }

                    set
                    {
                        byte[] __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                        fixed (byte* __bytePtr0 = __bytes0)
                        {
                            ((global::CppSharp.Parser.AST.LabelStmt.__Internal*)__Instance)->name = (global::System.IntPtr) new global::System.IntPtr(__bytePtr0);
                        }
                    }
                }
            }

            public unsafe partial class AttributedStmt : global::CppSharp.Parser.AST.Stmt, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 28)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal attrLoc;

                    [FieldOffset(24)]
                    internal global::System.IntPtr subStmt;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0AttributedStmt@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0AttributedStmt@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.AttributedStmt __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.AttributedStmt(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.AttributedStmt __CreateInstance(global::CppSharp.Parser.AST.AttributedStmt.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.AttributedStmt(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.AttributedStmt.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.AttributedStmt.__Internal));
                    *(global::CppSharp.Parser.AST.AttributedStmt.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private AttributedStmt(global::CppSharp.Parser.AST.AttributedStmt.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected AttributedStmt(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public AttributedStmt()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.AttributedStmt.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public AttributedStmt(global::CppSharp.Parser.AST.AttributedStmt _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.AttributedStmt.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.AttributedStmt.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.AttributedStmt.__Internal*) _0.__Instance);
                }

                public global::CppSharp.Parser.SourceLocation AttrLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.AttributedStmt.__Internal*) __Instance)->attrLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.AttributedStmt.__Internal*)__Instance)->attrLoc = value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Stmt SubStmt
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Stmt __result0;
                        if (((global::CppSharp.Parser.AST.AttributedStmt.__Internal*) __Instance)->subStmt == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Stmt.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.AttributedStmt.__Internal*) __Instance)->subStmt))
                            __result0 = (global::CppSharp.Parser.AST.Stmt) global::CppSharp.Parser.AST.Stmt.NativeToManagedMap[((global::CppSharp.Parser.AST.AttributedStmt.__Internal*) __Instance)->subStmt];
                        else __result0 = global::CppSharp.Parser.AST.Stmt.__CreateInstance(((global::CppSharp.Parser.AST.AttributedStmt.__Internal*) __Instance)->subStmt);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.AttributedStmt.__Internal*)__Instance)->subStmt = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }
            }

            public unsafe partial class IfStmt : global::CppSharp.Parser.AST.Stmt, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 56)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::System.IntPtr cond;

                    [FieldOffset(24)]
                    internal global::System.IntPtr then;

                    [FieldOffset(28)]
                    internal global::System.IntPtr _else;

                    [FieldOffset(32)]
                    internal global::System.IntPtr init;

                    [FieldOffset(36)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal ifLoc;

                    [FieldOffset(40)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal elseLoc;

                    [FieldOffset(44)]
                    internal byte _constexpr;

                    [FieldOffset(45)]
                    internal byte hasInitStorage;

                    [FieldOffset(46)]
                    internal byte hasVarStorage;

                    [FieldOffset(47)]
                    internal byte hasElseStorage;

                    [FieldOffset(48)]
                    internal global::System.IntPtr conditionVariableDeclStmt;

                    [FieldOffset(52)]
                    internal byte isObjCAvailabilityCheck;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0IfStmt@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0IfStmt@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.IfStmt __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.IfStmt(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.IfStmt __CreateInstance(global::CppSharp.Parser.AST.IfStmt.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.IfStmt(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.IfStmt.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.IfStmt.__Internal));
                    *(global::CppSharp.Parser.AST.IfStmt.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private IfStmt(global::CppSharp.Parser.AST.IfStmt.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected IfStmt(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public IfStmt()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.IfStmt.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public IfStmt(global::CppSharp.Parser.AST.IfStmt _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.IfStmt.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.IfStmt.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.IfStmt.__Internal*) _0.__Instance);
                }

                public global::CppSharp.Parser.AST.Expr Cond
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.IfStmt.__Internal*) __Instance)->cond == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.IfStmt.__Internal*) __Instance)->cond))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.IfStmt.__Internal*) __Instance)->cond];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.IfStmt.__Internal*) __Instance)->cond);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.IfStmt.__Internal*)__Instance)->cond = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Stmt Then
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Stmt __result0;
                        if (((global::CppSharp.Parser.AST.IfStmt.__Internal*) __Instance)->then == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Stmt.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.IfStmt.__Internal*) __Instance)->then))
                            __result0 = (global::CppSharp.Parser.AST.Stmt) global::CppSharp.Parser.AST.Stmt.NativeToManagedMap[((global::CppSharp.Parser.AST.IfStmt.__Internal*) __Instance)->then];
                        else __result0 = global::CppSharp.Parser.AST.Stmt.__CreateInstance(((global::CppSharp.Parser.AST.IfStmt.__Internal*) __Instance)->then);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.IfStmt.__Internal*)__Instance)->then = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Stmt Else
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Stmt __result0;
                        if (((global::CppSharp.Parser.AST.IfStmt.__Internal*) __Instance)->_else == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Stmt.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.IfStmt.__Internal*) __Instance)->_else))
                            __result0 = (global::CppSharp.Parser.AST.Stmt) global::CppSharp.Parser.AST.Stmt.NativeToManagedMap[((global::CppSharp.Parser.AST.IfStmt.__Internal*) __Instance)->_else];
                        else __result0 = global::CppSharp.Parser.AST.Stmt.__CreateInstance(((global::CppSharp.Parser.AST.IfStmt.__Internal*) __Instance)->_else);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.IfStmt.__Internal*)__Instance)->_else = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Stmt Init
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Stmt __result0;
                        if (((global::CppSharp.Parser.AST.IfStmt.__Internal*) __Instance)->init == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Stmt.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.IfStmt.__Internal*) __Instance)->init))
                            __result0 = (global::CppSharp.Parser.AST.Stmt) global::CppSharp.Parser.AST.Stmt.NativeToManagedMap[((global::CppSharp.Parser.AST.IfStmt.__Internal*) __Instance)->init];
                        else __result0 = global::CppSharp.Parser.AST.Stmt.__CreateInstance(((global::CppSharp.Parser.AST.IfStmt.__Internal*) __Instance)->init);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.IfStmt.__Internal*)__Instance)->init = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.SourceLocation IfLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.IfStmt.__Internal*) __Instance)->ifLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.IfStmt.__Internal*)__Instance)->ifLoc = value.__Instance;
                    }
                }

                public global::CppSharp.Parser.SourceLocation ElseLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.IfStmt.__Internal*) __Instance)->elseLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.IfStmt.__Internal*)__Instance)->elseLoc = value.__Instance;
                    }
                }

                public bool Constexpr
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.IfStmt.__Internal*) __Instance)->_constexpr != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.IfStmt.__Internal*)__Instance)->_constexpr = (byte) (value ? 1 : 0);
                    }
                }

                public bool HasInitStorage
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.IfStmt.__Internal*) __Instance)->hasInitStorage != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.IfStmt.__Internal*)__Instance)->hasInitStorage = (byte) (value ? 1 : 0);
                    }
                }

                public bool HasVarStorage
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.IfStmt.__Internal*) __Instance)->hasVarStorage != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.IfStmt.__Internal*)__Instance)->hasVarStorage = (byte) (value ? 1 : 0);
                    }
                }

                public bool HasElseStorage
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.IfStmt.__Internal*) __Instance)->hasElseStorage != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.IfStmt.__Internal*)__Instance)->hasElseStorage = (byte) (value ? 1 : 0);
                    }
                }

                public global::CppSharp.Parser.AST.DeclStmt ConditionVariableDeclStmt
                {
                    get
                    {
                        global::CppSharp.Parser.AST.DeclStmt __result0;
                        if (((global::CppSharp.Parser.AST.IfStmt.__Internal*) __Instance)->conditionVariableDeclStmt == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.DeclStmt.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.IfStmt.__Internal*) __Instance)->conditionVariableDeclStmt))
                            __result0 = (global::CppSharp.Parser.AST.DeclStmt) global::CppSharp.Parser.AST.DeclStmt.NativeToManagedMap[((global::CppSharp.Parser.AST.IfStmt.__Internal*) __Instance)->conditionVariableDeclStmt];
                        else __result0 = global::CppSharp.Parser.AST.DeclStmt.__CreateInstance(((global::CppSharp.Parser.AST.IfStmt.__Internal*) __Instance)->conditionVariableDeclStmt);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.IfStmt.__Internal*)__Instance)->conditionVariableDeclStmt = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public bool IsObjCAvailabilityCheck
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.IfStmt.__Internal*) __Instance)->isObjCAvailabilityCheck != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.IfStmt.__Internal*)__Instance)->isObjCAvailabilityCheck = (byte) (value ? 1 : 0);
                    }
                }
            }

            public unsafe partial class SwitchStmt : global::CppSharp.Parser.AST.Stmt, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 48)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::System.IntPtr cond;

                    [FieldOffset(24)]
                    internal global::System.IntPtr body;

                    [FieldOffset(28)]
                    internal global::System.IntPtr init;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal switchLoc;

                    [FieldOffset(36)]
                    internal byte hasInitStorage;

                    [FieldOffset(37)]
                    internal byte hasVarStorage;

                    [FieldOffset(40)]
                    internal global::System.IntPtr conditionVariableDeclStmt;

                    [FieldOffset(44)]
                    internal byte isAllEnumCasesCovered;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0SwitchStmt@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0SwitchStmt@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.SwitchStmt __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.SwitchStmt(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.SwitchStmt __CreateInstance(global::CppSharp.Parser.AST.SwitchStmt.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.SwitchStmt(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.SwitchStmt.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.SwitchStmt.__Internal));
                    *(global::CppSharp.Parser.AST.SwitchStmt.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private SwitchStmt(global::CppSharp.Parser.AST.SwitchStmt.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected SwitchStmt(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public SwitchStmt()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.SwitchStmt.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public SwitchStmt(global::CppSharp.Parser.AST.SwitchStmt _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.SwitchStmt.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.SwitchStmt.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.SwitchStmt.__Internal*) _0.__Instance);
                }

                public global::CppSharp.Parser.AST.Expr Cond
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.SwitchStmt.__Internal*) __Instance)->cond == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.SwitchStmt.__Internal*) __Instance)->cond))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.SwitchStmt.__Internal*) __Instance)->cond];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.SwitchStmt.__Internal*) __Instance)->cond);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.SwitchStmt.__Internal*)__Instance)->cond = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Stmt Body
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Stmt __result0;
                        if (((global::CppSharp.Parser.AST.SwitchStmt.__Internal*) __Instance)->body == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Stmt.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.SwitchStmt.__Internal*) __Instance)->body))
                            __result0 = (global::CppSharp.Parser.AST.Stmt) global::CppSharp.Parser.AST.Stmt.NativeToManagedMap[((global::CppSharp.Parser.AST.SwitchStmt.__Internal*) __Instance)->body];
                        else __result0 = global::CppSharp.Parser.AST.Stmt.__CreateInstance(((global::CppSharp.Parser.AST.SwitchStmt.__Internal*) __Instance)->body);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.SwitchStmt.__Internal*)__Instance)->body = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Stmt Init
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Stmt __result0;
                        if (((global::CppSharp.Parser.AST.SwitchStmt.__Internal*) __Instance)->init == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Stmt.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.SwitchStmt.__Internal*) __Instance)->init))
                            __result0 = (global::CppSharp.Parser.AST.Stmt) global::CppSharp.Parser.AST.Stmt.NativeToManagedMap[((global::CppSharp.Parser.AST.SwitchStmt.__Internal*) __Instance)->init];
                        else __result0 = global::CppSharp.Parser.AST.Stmt.__CreateInstance(((global::CppSharp.Parser.AST.SwitchStmt.__Internal*) __Instance)->init);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.SwitchStmt.__Internal*)__Instance)->init = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.SourceLocation SwitchLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.SwitchStmt.__Internal*) __Instance)->switchLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.SwitchStmt.__Internal*)__Instance)->switchLoc = value.__Instance;
                    }
                }

                public bool HasInitStorage
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.SwitchStmt.__Internal*) __Instance)->hasInitStorage != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.SwitchStmt.__Internal*)__Instance)->hasInitStorage = (byte) (value ? 1 : 0);
                    }
                }

                public bool HasVarStorage
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.SwitchStmt.__Internal*) __Instance)->hasVarStorage != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.SwitchStmt.__Internal*)__Instance)->hasVarStorage = (byte) (value ? 1 : 0);
                    }
                }

                public global::CppSharp.Parser.AST.DeclStmt ConditionVariableDeclStmt
                {
                    get
                    {
                        global::CppSharp.Parser.AST.DeclStmt __result0;
                        if (((global::CppSharp.Parser.AST.SwitchStmt.__Internal*) __Instance)->conditionVariableDeclStmt == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.DeclStmt.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.SwitchStmt.__Internal*) __Instance)->conditionVariableDeclStmt))
                            __result0 = (global::CppSharp.Parser.AST.DeclStmt) global::CppSharp.Parser.AST.DeclStmt.NativeToManagedMap[((global::CppSharp.Parser.AST.SwitchStmt.__Internal*) __Instance)->conditionVariableDeclStmt];
                        else __result0 = global::CppSharp.Parser.AST.DeclStmt.__CreateInstance(((global::CppSharp.Parser.AST.SwitchStmt.__Internal*) __Instance)->conditionVariableDeclStmt);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.SwitchStmt.__Internal*)__Instance)->conditionVariableDeclStmt = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public bool IsAllEnumCasesCovered
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.SwitchStmt.__Internal*) __Instance)->isAllEnumCasesCovered != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.SwitchStmt.__Internal*)__Instance)->isAllEnumCasesCovered = (byte) (value ? 1 : 0);
                    }
                }
            }

            public unsafe partial class WhileStmt : global::CppSharp.Parser.AST.Stmt, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 40)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::System.IntPtr cond;

                    [FieldOffset(24)]
                    internal global::System.IntPtr body;

                    [FieldOffset(28)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal whileLoc;

                    [FieldOffset(32)]
                    internal byte hasVarStorage;

                    [FieldOffset(36)]
                    internal global::System.IntPtr conditionVariableDeclStmt;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0WhileStmt@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0WhileStmt@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.WhileStmt __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.WhileStmt(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.WhileStmt __CreateInstance(global::CppSharp.Parser.AST.WhileStmt.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.WhileStmt(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.WhileStmt.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.WhileStmt.__Internal));
                    *(global::CppSharp.Parser.AST.WhileStmt.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private WhileStmt(global::CppSharp.Parser.AST.WhileStmt.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected WhileStmt(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public WhileStmt()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.WhileStmt.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public WhileStmt(global::CppSharp.Parser.AST.WhileStmt _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.WhileStmt.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.WhileStmt.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.WhileStmt.__Internal*) _0.__Instance);
                }

                public global::CppSharp.Parser.AST.Expr Cond
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.WhileStmt.__Internal*) __Instance)->cond == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.WhileStmt.__Internal*) __Instance)->cond))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.WhileStmt.__Internal*) __Instance)->cond];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.WhileStmt.__Internal*) __Instance)->cond);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.WhileStmt.__Internal*)__Instance)->cond = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Stmt Body
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Stmt __result0;
                        if (((global::CppSharp.Parser.AST.WhileStmt.__Internal*) __Instance)->body == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Stmt.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.WhileStmt.__Internal*) __Instance)->body))
                            __result0 = (global::CppSharp.Parser.AST.Stmt) global::CppSharp.Parser.AST.Stmt.NativeToManagedMap[((global::CppSharp.Parser.AST.WhileStmt.__Internal*) __Instance)->body];
                        else __result0 = global::CppSharp.Parser.AST.Stmt.__CreateInstance(((global::CppSharp.Parser.AST.WhileStmt.__Internal*) __Instance)->body);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.WhileStmt.__Internal*)__Instance)->body = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.SourceLocation WhileLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.WhileStmt.__Internal*) __Instance)->whileLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.WhileStmt.__Internal*)__Instance)->whileLoc = value.__Instance;
                    }
                }

                public bool HasVarStorage
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.WhileStmt.__Internal*) __Instance)->hasVarStorage != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.WhileStmt.__Internal*)__Instance)->hasVarStorage = (byte) (value ? 1 : 0);
                    }
                }

                public global::CppSharp.Parser.AST.DeclStmt ConditionVariableDeclStmt
                {
                    get
                    {
                        global::CppSharp.Parser.AST.DeclStmt __result0;
                        if (((global::CppSharp.Parser.AST.WhileStmt.__Internal*) __Instance)->conditionVariableDeclStmt == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.DeclStmt.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.WhileStmt.__Internal*) __Instance)->conditionVariableDeclStmt))
                            __result0 = (global::CppSharp.Parser.AST.DeclStmt) global::CppSharp.Parser.AST.DeclStmt.NativeToManagedMap[((global::CppSharp.Parser.AST.WhileStmt.__Internal*) __Instance)->conditionVariableDeclStmt];
                        else __result0 = global::CppSharp.Parser.AST.DeclStmt.__CreateInstance(((global::CppSharp.Parser.AST.WhileStmt.__Internal*) __Instance)->conditionVariableDeclStmt);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.WhileStmt.__Internal*)__Instance)->conditionVariableDeclStmt = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }
            }

            public unsafe partial class DoStmt : global::CppSharp.Parser.AST.Stmt, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 40)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::System.IntPtr cond;

                    [FieldOffset(24)]
                    internal global::System.IntPtr body;

                    [FieldOffset(28)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal doLoc;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal whileLoc;

                    [FieldOffset(36)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal rParenLoc;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0DoStmt@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0DoStmt@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.DoStmt __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.DoStmt(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.DoStmt __CreateInstance(global::CppSharp.Parser.AST.DoStmt.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.DoStmt(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.DoStmt.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.DoStmt.__Internal));
                    *(global::CppSharp.Parser.AST.DoStmt.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private DoStmt(global::CppSharp.Parser.AST.DoStmt.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected DoStmt(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public DoStmt()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.DoStmt.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public DoStmt(global::CppSharp.Parser.AST.DoStmt _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.DoStmt.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.DoStmt.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.DoStmt.__Internal*) _0.__Instance);
                }

                public global::CppSharp.Parser.AST.Expr Cond
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.DoStmt.__Internal*) __Instance)->cond == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.DoStmt.__Internal*) __Instance)->cond))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.DoStmt.__Internal*) __Instance)->cond];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.DoStmt.__Internal*) __Instance)->cond);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.DoStmt.__Internal*)__Instance)->cond = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Stmt Body
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Stmt __result0;
                        if (((global::CppSharp.Parser.AST.DoStmt.__Internal*) __Instance)->body == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Stmt.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.DoStmt.__Internal*) __Instance)->body))
                            __result0 = (global::CppSharp.Parser.AST.Stmt) global::CppSharp.Parser.AST.Stmt.NativeToManagedMap[((global::CppSharp.Parser.AST.DoStmt.__Internal*) __Instance)->body];
                        else __result0 = global::CppSharp.Parser.AST.Stmt.__CreateInstance(((global::CppSharp.Parser.AST.DoStmt.__Internal*) __Instance)->body);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.DoStmt.__Internal*)__Instance)->body = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.SourceLocation DoLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.DoStmt.__Internal*) __Instance)->doLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.DoStmt.__Internal*)__Instance)->doLoc = value.__Instance;
                    }
                }

                public global::CppSharp.Parser.SourceLocation WhileLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.DoStmt.__Internal*) __Instance)->whileLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.DoStmt.__Internal*)__Instance)->whileLoc = value.__Instance;
                    }
                }

                public global::CppSharp.Parser.SourceLocation RParenLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.DoStmt.__Internal*) __Instance)->rParenLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.DoStmt.__Internal*)__Instance)->rParenLoc = value.__Instance;
                    }
                }
            }

            public unsafe partial class ForStmt : global::CppSharp.Parser.AST.Stmt, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 52)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::System.IntPtr init;

                    [FieldOffset(24)]
                    internal global::System.IntPtr cond;

                    [FieldOffset(28)]
                    internal global::System.IntPtr inc;

                    [FieldOffset(32)]
                    internal global::System.IntPtr body;

                    [FieldOffset(36)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal forLoc;

                    [FieldOffset(40)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal lParenLoc;

                    [FieldOffset(44)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal rParenLoc;

                    [FieldOffset(48)]
                    internal global::System.IntPtr conditionVariableDeclStmt;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0ForStmt@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0ForStmt@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.ForStmt __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.ForStmt(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.ForStmt __CreateInstance(global::CppSharp.Parser.AST.ForStmt.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.ForStmt(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.ForStmt.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ForStmt.__Internal));
                    *(global::CppSharp.Parser.AST.ForStmt.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private ForStmt(global::CppSharp.Parser.AST.ForStmt.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected ForStmt(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public ForStmt()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ForStmt.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public ForStmt(global::CppSharp.Parser.AST.ForStmt _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ForStmt.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.ForStmt.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.ForStmt.__Internal*) _0.__Instance);
                }

                public global::CppSharp.Parser.AST.Stmt Init
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Stmt __result0;
                        if (((global::CppSharp.Parser.AST.ForStmt.__Internal*) __Instance)->init == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Stmt.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.ForStmt.__Internal*) __Instance)->init))
                            __result0 = (global::CppSharp.Parser.AST.Stmt) global::CppSharp.Parser.AST.Stmt.NativeToManagedMap[((global::CppSharp.Parser.AST.ForStmt.__Internal*) __Instance)->init];
                        else __result0 = global::CppSharp.Parser.AST.Stmt.__CreateInstance(((global::CppSharp.Parser.AST.ForStmt.__Internal*) __Instance)->init);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.ForStmt.__Internal*)__Instance)->init = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Expr Cond
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.ForStmt.__Internal*) __Instance)->cond == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.ForStmt.__Internal*) __Instance)->cond))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.ForStmt.__Internal*) __Instance)->cond];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.ForStmt.__Internal*) __Instance)->cond);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.ForStmt.__Internal*)__Instance)->cond = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Expr Inc
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.ForStmt.__Internal*) __Instance)->inc == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.ForStmt.__Internal*) __Instance)->inc))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.ForStmt.__Internal*) __Instance)->inc];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.ForStmt.__Internal*) __Instance)->inc);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.ForStmt.__Internal*)__Instance)->inc = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Stmt Body
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Stmt __result0;
                        if (((global::CppSharp.Parser.AST.ForStmt.__Internal*) __Instance)->body == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Stmt.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.ForStmt.__Internal*) __Instance)->body))
                            __result0 = (global::CppSharp.Parser.AST.Stmt) global::CppSharp.Parser.AST.Stmt.NativeToManagedMap[((global::CppSharp.Parser.AST.ForStmt.__Internal*) __Instance)->body];
                        else __result0 = global::CppSharp.Parser.AST.Stmt.__CreateInstance(((global::CppSharp.Parser.AST.ForStmt.__Internal*) __Instance)->body);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.ForStmt.__Internal*)__Instance)->body = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.SourceLocation ForLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.ForStmt.__Internal*) __Instance)->forLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.ForStmt.__Internal*)__Instance)->forLoc = value.__Instance;
                    }
                }

                public global::CppSharp.Parser.SourceLocation LParenLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.ForStmt.__Internal*) __Instance)->lParenLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.ForStmt.__Internal*)__Instance)->lParenLoc = value.__Instance;
                    }
                }

                public global::CppSharp.Parser.SourceLocation RParenLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.ForStmt.__Internal*) __Instance)->rParenLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.ForStmt.__Internal*)__Instance)->rParenLoc = value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.DeclStmt ConditionVariableDeclStmt
                {
                    get
                    {
                        global::CppSharp.Parser.AST.DeclStmt __result0;
                        if (((global::CppSharp.Parser.AST.ForStmt.__Internal*) __Instance)->conditionVariableDeclStmt == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.DeclStmt.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.ForStmt.__Internal*) __Instance)->conditionVariableDeclStmt))
                            __result0 = (global::CppSharp.Parser.AST.DeclStmt) global::CppSharp.Parser.AST.DeclStmt.NativeToManagedMap[((global::CppSharp.Parser.AST.ForStmt.__Internal*) __Instance)->conditionVariableDeclStmt];
                        else __result0 = global::CppSharp.Parser.AST.DeclStmt.__CreateInstance(((global::CppSharp.Parser.AST.ForStmt.__Internal*) __Instance)->conditionVariableDeclStmt);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.ForStmt.__Internal*)__Instance)->conditionVariableDeclStmt = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }
            }

            public unsafe partial class GotoStmt : global::CppSharp.Parser.AST.Stmt, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 28)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal gotoLoc;

                    [FieldOffset(24)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal labelLoc;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0GotoStmt@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0GotoStmt@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.GotoStmt __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.GotoStmt(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.GotoStmt __CreateInstance(global::CppSharp.Parser.AST.GotoStmt.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.GotoStmt(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.GotoStmt.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.GotoStmt.__Internal));
                    *(global::CppSharp.Parser.AST.GotoStmt.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private GotoStmt(global::CppSharp.Parser.AST.GotoStmt.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected GotoStmt(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public GotoStmt()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.GotoStmt.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public GotoStmt(global::CppSharp.Parser.AST.GotoStmt _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.GotoStmt.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.GotoStmt.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.GotoStmt.__Internal*) _0.__Instance);
                }

                public global::CppSharp.Parser.SourceLocation GotoLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.GotoStmt.__Internal*) __Instance)->gotoLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.GotoStmt.__Internal*)__Instance)->gotoLoc = value.__Instance;
                    }
                }

                public global::CppSharp.Parser.SourceLocation LabelLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.GotoStmt.__Internal*) __Instance)->labelLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.GotoStmt.__Internal*)__Instance)->labelLoc = value.__Instance;
                    }
                }
            }

            public unsafe partial class IndirectGotoStmt : global::CppSharp.Parser.AST.Stmt, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 32)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal gotoLoc;

                    [FieldOffset(24)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal starLoc;

                    [FieldOffset(28)]
                    internal global::System.IntPtr target;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0IndirectGotoStmt@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0IndirectGotoStmt@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.IndirectGotoStmt __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.IndirectGotoStmt(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.IndirectGotoStmt __CreateInstance(global::CppSharp.Parser.AST.IndirectGotoStmt.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.IndirectGotoStmt(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.IndirectGotoStmt.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.IndirectGotoStmt.__Internal));
                    *(global::CppSharp.Parser.AST.IndirectGotoStmt.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private IndirectGotoStmt(global::CppSharp.Parser.AST.IndirectGotoStmt.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected IndirectGotoStmt(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public IndirectGotoStmt()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.IndirectGotoStmt.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public IndirectGotoStmt(global::CppSharp.Parser.AST.IndirectGotoStmt _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.IndirectGotoStmt.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.IndirectGotoStmt.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.IndirectGotoStmt.__Internal*) _0.__Instance);
                }

                public global::CppSharp.Parser.SourceLocation GotoLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.IndirectGotoStmt.__Internal*) __Instance)->gotoLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.IndirectGotoStmt.__Internal*)__Instance)->gotoLoc = value.__Instance;
                    }
                }

                public global::CppSharp.Parser.SourceLocation StarLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.IndirectGotoStmt.__Internal*) __Instance)->starLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.IndirectGotoStmt.__Internal*)__Instance)->starLoc = value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Expr Target
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.IndirectGotoStmt.__Internal*) __Instance)->target == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.IndirectGotoStmt.__Internal*) __Instance)->target))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.IndirectGotoStmt.__Internal*) __Instance)->target];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.IndirectGotoStmt.__Internal*) __Instance)->target);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.IndirectGotoStmt.__Internal*)__Instance)->target = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }
            }

            public unsafe partial class ContinueStmt : global::CppSharp.Parser.AST.Stmt, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 24)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal continueLoc;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0ContinueStmt@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0ContinueStmt@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.ContinueStmt __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.ContinueStmt(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.ContinueStmt __CreateInstance(global::CppSharp.Parser.AST.ContinueStmt.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.ContinueStmt(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.ContinueStmt.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ContinueStmt.__Internal));
                    *(global::CppSharp.Parser.AST.ContinueStmt.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private ContinueStmt(global::CppSharp.Parser.AST.ContinueStmt.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected ContinueStmt(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public ContinueStmt()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ContinueStmt.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public ContinueStmt(global::CppSharp.Parser.AST.ContinueStmt _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ContinueStmt.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.ContinueStmt.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.ContinueStmt.__Internal*) _0.__Instance);
                }

                public global::CppSharp.Parser.SourceLocation ContinueLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.ContinueStmt.__Internal*) __Instance)->continueLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.ContinueStmt.__Internal*)__Instance)->continueLoc = value.__Instance;
                    }
                }
            }

            public unsafe partial class BreakStmt : global::CppSharp.Parser.AST.Stmt, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 24)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal breakLoc;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0BreakStmt@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0BreakStmt@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.BreakStmt __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.BreakStmt(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.BreakStmt __CreateInstance(global::CppSharp.Parser.AST.BreakStmt.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.BreakStmt(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.BreakStmt.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.BreakStmt.__Internal));
                    *(global::CppSharp.Parser.AST.BreakStmt.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private BreakStmt(global::CppSharp.Parser.AST.BreakStmt.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected BreakStmt(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public BreakStmt()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.BreakStmt.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public BreakStmt(global::CppSharp.Parser.AST.BreakStmt _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.BreakStmt.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.BreakStmt.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.BreakStmt.__Internal*) _0.__Instance);
                }

                public global::CppSharp.Parser.SourceLocation BreakLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.BreakStmt.__Internal*) __Instance)->breakLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.BreakStmt.__Internal*)__Instance)->breakLoc = value.__Instance;
                    }
                }
            }

            public unsafe partial class ReturnStmt : global::CppSharp.Parser.AST.Stmt, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 28)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::System.IntPtr retValue;

                    [FieldOffset(24)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal returnLoc;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0ReturnStmt@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0ReturnStmt@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.ReturnStmt __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.ReturnStmt(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.ReturnStmt __CreateInstance(global::CppSharp.Parser.AST.ReturnStmt.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.ReturnStmt(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.ReturnStmt.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ReturnStmt.__Internal));
                    *(global::CppSharp.Parser.AST.ReturnStmt.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private ReturnStmt(global::CppSharp.Parser.AST.ReturnStmt.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected ReturnStmt(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public ReturnStmt()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ReturnStmt.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public ReturnStmt(global::CppSharp.Parser.AST.ReturnStmt _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ReturnStmt.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.ReturnStmt.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.ReturnStmt.__Internal*) _0.__Instance);
                }

                public global::CppSharp.Parser.AST.Expr RetValue
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.ReturnStmt.__Internal*) __Instance)->retValue == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.ReturnStmt.__Internal*) __Instance)->retValue))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.ReturnStmt.__Internal*) __Instance)->retValue];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.ReturnStmt.__Internal*) __Instance)->retValue);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.ReturnStmt.__Internal*)__Instance)->retValue = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.SourceLocation ReturnLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.ReturnStmt.__Internal*) __Instance)->returnLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.ReturnStmt.__Internal*)__Instance)->returnLoc = value.__Instance;
                    }
                }
            }

            public unsafe partial class AsmStmt : global::CppSharp.Parser.AST.Stmt, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 68)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Expr___N_std_S_allocator__S0_ inputs;

                    [FieldOffset(32)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Expr___N_std_S_allocator__S0_ outputs;

                    [FieldOffset(44)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal asmLoc;

                    [FieldOffset(48)]
                    internal byte simple;

                    [FieldOffset(49)]
                    internal byte _volatile;

                    [FieldOffset(52)]
                    internal uint numOutputs;

                    [FieldOffset(56)]
                    internal uint numPlusOperands;

                    [FieldOffset(60)]
                    internal uint numInputs;

                    [FieldOffset(64)]
                    internal uint numClobbers;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0AsmStmt@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0AsmStmt@AST@CppParser@CppSharp@@QAE@W4StmtClass@123@@Z")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance, global::CppSharp.Parser.AST.StmtClass klass);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0AsmStmt@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??1AsmStmt@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern void dtor(global::System.IntPtr __instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getinputs@AsmStmt@AST@CppParser@CppSharp@@QAEPAVExpr@234@I@Z")]
                    internal static extern global::System.IntPtr Getinputs(global::System.IntPtr __instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?addinputs@AsmStmt@AST@CppParser@CppSharp@@QAEXAAPAVExpr@234@@Z")]
                    internal static extern void Addinputs(global::System.IntPtr __instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?clearinputs@AsmStmt@AST@CppParser@CppSharp@@QAEXXZ")]
                    internal static extern void Clearinputs(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getoutputs@AsmStmt@AST@CppParser@CppSharp@@QAEPAVExpr@234@I@Z")]
                    internal static extern global::System.IntPtr Getoutputs(global::System.IntPtr __instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?addoutputs@AsmStmt@AST@CppParser@CppSharp@@QAEXAAPAVExpr@234@@Z")]
                    internal static extern void Addoutputs(global::System.IntPtr __instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?clearoutputs@AsmStmt@AST@CppParser@CppSharp@@QAEXXZ")]
                    internal static extern void Clearoutputs(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getinputsCount@AsmStmt@AST@CppParser@CppSharp@@QAEIXZ")]
                    internal static extern uint GetinputsCount(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getoutputsCount@AsmStmt@AST@CppParser@CppSharp@@QAEIXZ")]
                    internal static extern uint GetoutputsCount(global::System.IntPtr __instance);
                }

                internal static new global::CppSharp.Parser.AST.AsmStmt __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.AsmStmt(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.AsmStmt __CreateInstance(global::CppSharp.Parser.AST.AsmStmt.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.AsmStmt(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.AsmStmt.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.AsmStmt.__Internal));
                    global::CppSharp.Parser.AST.AsmStmt.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private AsmStmt(global::CppSharp.Parser.AST.AsmStmt.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected AsmStmt(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public AsmStmt()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.AsmStmt.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public AsmStmt(global::CppSharp.Parser.AST.StmtClass klass)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.AsmStmt.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance, klass);
                }

                public AsmStmt(global::CppSharp.Parser.AST.AsmStmt _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.AsmStmt.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Stmt __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor(__Instance, 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.Expr Getinputs(uint i)
                {
                    var __ret = __Internal.Getinputs(__Instance, i);
                    global::CppSharp.Parser.AST.Expr __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[__ret];
                    else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(__ret);
                    return __result0;
                }

                public void Addinputs(global::CppSharp.Parser.AST.Expr s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var ____arg0 = s.__Instance;
                    var __arg0 = new global::System.IntPtr(&____arg0);
                    __Internal.Addinputs(__Instance, __arg0);
                }

                public void Clearinputs()
                {
                    __Internal.Clearinputs(__Instance);
                }

                public global::CppSharp.Parser.AST.Expr Getoutputs(uint i)
                {
                    var __ret = __Internal.Getoutputs(__Instance, i);
                    global::CppSharp.Parser.AST.Expr __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[__ret];
                    else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(__ret);
                    return __result0;
                }

                public void Addoutputs(global::CppSharp.Parser.AST.Expr s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var ____arg0 = s.__Instance;
                    var __arg0 = new global::System.IntPtr(&____arg0);
                    __Internal.Addoutputs(__Instance, __arg0);
                }

                public void Clearoutputs()
                {
                    __Internal.Clearoutputs(__Instance);
                }

                public static implicit operator global::CppSharp.Parser.AST.AsmStmt(global::CppSharp.Parser.AST.StmtClass klass)
                {
                    return new global::CppSharp.Parser.AST.AsmStmt(klass);
                }

                public global::CppSharp.Parser.SourceLocation AsmLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.AsmStmt.__Internal*) __Instance)->asmLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.AsmStmt.__Internal*)__Instance)->asmLoc = value.__Instance;
                    }
                }

                public bool Simple
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.AsmStmt.__Internal*) __Instance)->simple != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.AsmStmt.__Internal*)__Instance)->simple = (byte) (value ? 1 : 0);
                    }
                }

                public bool Volatile
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.AsmStmt.__Internal*) __Instance)->_volatile != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.AsmStmt.__Internal*)__Instance)->_volatile = (byte) (value ? 1 : 0);
                    }
                }

                public uint NumOutputs
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.AsmStmt.__Internal*) __Instance)->numOutputs;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.AsmStmt.__Internal*)__Instance)->numOutputs = value;
                    }
                }

                public uint NumPlusOperands
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.AsmStmt.__Internal*) __Instance)->numPlusOperands;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.AsmStmt.__Internal*)__Instance)->numPlusOperands = value;
                    }
                }

                public uint NumInputs
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.AsmStmt.__Internal*) __Instance)->numInputs;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.AsmStmt.__Internal*)__Instance)->numInputs = value;
                    }
                }

                public uint NumClobbers
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.AsmStmt.__Internal*) __Instance)->numClobbers;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.AsmStmt.__Internal*)__Instance)->numClobbers = value;
                    }
                }

                public uint GetinputsCount
                {
                    get
                    {
                        var __ret = __Internal.GetinputsCount(__Instance);
                        return __ret;
                    }
                }

                public uint GetoutputsCount
                {
                    get
                    {
                        var __ret = __Internal.GetoutputsCount(__Instance);
                        return __ret;
                    }
                }
            }

            public unsafe partial class GCCAsmStmt : global::CppSharp.Parser.AST.AsmStmt, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 72)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Expr___N_std_S_allocator__S0_ inputs;

                    [FieldOffset(32)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Expr___N_std_S_allocator__S0_ outputs;

                    [FieldOffset(44)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal asmLoc;

                    [FieldOffset(48)]
                    internal byte simple;

                    [FieldOffset(49)]
                    internal byte _volatile;

                    [FieldOffset(52)]
                    internal uint numOutputs;

                    [FieldOffset(56)]
                    internal uint numPlusOperands;

                    [FieldOffset(60)]
                    internal uint numInputs;

                    [FieldOffset(64)]
                    internal uint numClobbers;

                    [FieldOffset(68)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal rParenLoc;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0GCCAsmStmt@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0GCCAsmStmt@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??1GCCAsmStmt@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern void dtor(global::System.IntPtr __instance, int delete);
                }

                public unsafe partial class AsmStringPiece : IDisposable
                {
                    [StructLayout(LayoutKind.Explicit, Size = 36)]
                    public partial struct __Internal
                    {
                        [FieldOffset(0)]
                        internal byte isString;

                        [FieldOffset(1)]
                        internal byte isOperand;

                        [FieldOffset(4)]
                        internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C @string;

                        [FieldOffset(28)]
                        internal uint operandNo;

                        [FieldOffset(32)]
                        internal sbyte modifier;

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                            EntryPoint="??0AsmStringPiece@GCCAsmStmt@AST@CppParser@CppSharp@@QAE@XZ")]
                        internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                            EntryPoint="??0AsmStringPiece@GCCAsmStmt@AST@CppParser@CppSharp@@QAE@ABV01234@@Z")]
                        internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                            EntryPoint="??1AsmStringPiece@GCCAsmStmt@AST@CppParser@CppSharp@@QAE@XZ")]
                        internal static extern void dtor(global::System.IntPtr __instance, int delete);
                    }

                    public enum Kind
                    {
                        String = 0,
                        Operand = 1
                    }

                    public global::System.IntPtr __Instance { get; protected set; }

                    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.GCCAsmStmt.AsmStringPiece> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.GCCAsmStmt.AsmStringPiece>();
                    protected internal void*[] __OriginalVTables;

                    protected bool __ownsNativeInstance;

                    internal static global::CppSharp.Parser.AST.GCCAsmStmt.AsmStringPiece __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                    {
                        return new global::CppSharp.Parser.AST.GCCAsmStmt.AsmStringPiece(native.ToPointer(), skipVTables);
                    }

                    internal static global::CppSharp.Parser.AST.GCCAsmStmt.AsmStringPiece __CreateInstance(global::CppSharp.Parser.AST.GCCAsmStmt.AsmStringPiece.__Internal native, bool skipVTables = false)
                    {
                        return new global::CppSharp.Parser.AST.GCCAsmStmt.AsmStringPiece(native, skipVTables);
                    }

                    private static void* __CopyValue(global::CppSharp.Parser.AST.GCCAsmStmt.AsmStringPiece.__Internal native)
                    {
                        var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.GCCAsmStmt.AsmStringPiece.__Internal));
                        global::CppSharp.Parser.AST.GCCAsmStmt.AsmStringPiece.__Internal.cctor(ret, new global::System.IntPtr(&native));
                        return ret.ToPointer();
                    }

                    private AsmStringPiece(global::CppSharp.Parser.AST.GCCAsmStmt.AsmStringPiece.__Internal native, bool skipVTables = false)
                        : this(__CopyValue(native), skipVTables)
                    {
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                    }

                    protected AsmStringPiece(void* native, bool skipVTables = false)
                    {
                        if (native == null)
                            return;
                        __Instance = new global::System.IntPtr(native);
                    }

                    public AsmStringPiece()
                    {
                        __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.GCCAsmStmt.AsmStringPiece.__Internal));
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                        __Internal.ctor(__Instance);
                    }

                    public AsmStringPiece(global::CppSharp.Parser.AST.GCCAsmStmt.AsmStringPiece _0)
                    {
                        __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.GCCAsmStmt.AsmStringPiece.__Internal));
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                        if (ReferenceEquals(_0, null))
                            throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                        var __arg0 = _0.__Instance;
                        __Internal.cctor(__Instance, __arg0);
                    }

                    public void Dispose()
                    {
                        Dispose(disposing: true);
                    }

                    public virtual void Dispose(bool disposing)
                    {
                        if (__Instance == IntPtr.Zero)
                            return;
                        global::CppSharp.Parser.AST.GCCAsmStmt.AsmStringPiece __dummy;
                        NativeToManagedMap.TryRemove(__Instance, out __dummy);
                        if (disposing)
                            __Internal.dtor(__Instance, 0);
                        if (__ownsNativeInstance)
                            Marshal.FreeHGlobal(__Instance);
                        __Instance = IntPtr.Zero;
                    }

                    public bool IsString
                    {
                        get
                        {
                            return ((global::CppSharp.Parser.AST.GCCAsmStmt.AsmStringPiece.__Internal*) __Instance)->isString != 0;
                        }

                        set
                        {
                            ((global::CppSharp.Parser.AST.GCCAsmStmt.AsmStringPiece.__Internal*)__Instance)->isString = (byte) (value ? 1 : 0);
                        }
                    }

                    public bool IsOperand
                    {
                        get
                        {
                            return ((global::CppSharp.Parser.AST.GCCAsmStmt.AsmStringPiece.__Internal*) __Instance)->isOperand != 0;
                        }

                        set
                        {
                            ((global::CppSharp.Parser.AST.GCCAsmStmt.AsmStringPiece.__Internal*)__Instance)->isOperand = (byte) (value ? 1 : 0);
                        }
                    }

                    public string String
                    {
                        get
                        {
                            var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.GCCAsmStmt.AsmStringPiece.__Internal*) __Instance)->@string));
                            return global::Std.BasicStringExtensions.Data(__basicStringRet0);
                        }

                        set
                        {
                            global::Std.BasicStringExtensions.__Internal.Assign(new global::System.IntPtr(&((global::CppSharp.Parser.AST.GCCAsmStmt.AsmStringPiece.__Internal*)__Instance)->@string), value);
                        }
                    }

                    public uint OperandNo
                    {
                        get
                        {
                            return ((global::CppSharp.Parser.AST.GCCAsmStmt.AsmStringPiece.__Internal*) __Instance)->operandNo;
                        }

                        set
                        {
                            ((global::CppSharp.Parser.AST.GCCAsmStmt.AsmStringPiece.__Internal*)__Instance)->operandNo = value;
                        }
                    }

                    public sbyte Modifier
                    {
                        get
                        {
                            return ((global::CppSharp.Parser.AST.GCCAsmStmt.AsmStringPiece.__Internal*) __Instance)->modifier;
                        }

                        set
                        {
                            ((global::CppSharp.Parser.AST.GCCAsmStmt.AsmStringPiece.__Internal*)__Instance)->modifier = value;
                        }
                    }
                }

                internal static new global::CppSharp.Parser.AST.GCCAsmStmt __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.GCCAsmStmt(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.GCCAsmStmt __CreateInstance(global::CppSharp.Parser.AST.GCCAsmStmt.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.GCCAsmStmt(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.GCCAsmStmt.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.GCCAsmStmt.__Internal));
                    global::CppSharp.Parser.AST.GCCAsmStmt.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private GCCAsmStmt(global::CppSharp.Parser.AST.GCCAsmStmt.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected GCCAsmStmt(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public GCCAsmStmt()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.GCCAsmStmt.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public GCCAsmStmt(global::CppSharp.Parser.AST.GCCAsmStmt _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.GCCAsmStmt.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Stmt __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor(__Instance, 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.SourceLocation RParenLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.GCCAsmStmt.__Internal*) __Instance)->rParenLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.GCCAsmStmt.__Internal*)__Instance)->rParenLoc = value.__Instance;
                    }
                }
            }

            public unsafe partial class MSAsmStmt : global::CppSharp.Parser.AST.AsmStmt, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 104)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Expr___N_std_S_allocator__S0_ inputs;

                    [FieldOffset(32)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Expr___N_std_S_allocator__S0_ outputs;

                    [FieldOffset(44)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal asmLoc;

                    [FieldOffset(48)]
                    internal byte simple;

                    [FieldOffset(49)]
                    internal byte _volatile;

                    [FieldOffset(52)]
                    internal uint numOutputs;

                    [FieldOffset(56)]
                    internal uint numPlusOperands;

                    [FieldOffset(60)]
                    internal uint numInputs;

                    [FieldOffset(64)]
                    internal uint numClobbers;

                    [FieldOffset(68)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal lBraceLoc;

                    [FieldOffset(72)]
                    internal byte hasBraces;

                    [FieldOffset(76)]
                    internal uint numAsmToks;

                    [FieldOffset(80)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C asmString;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0MSAsmStmt@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0MSAsmStmt@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??1MSAsmStmt@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern void dtor(global::System.IntPtr __instance, int delete);
                }

                internal static new global::CppSharp.Parser.AST.MSAsmStmt __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.MSAsmStmt(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.MSAsmStmt __CreateInstance(global::CppSharp.Parser.AST.MSAsmStmt.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.MSAsmStmt(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.MSAsmStmt.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.MSAsmStmt.__Internal));
                    global::CppSharp.Parser.AST.MSAsmStmt.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private MSAsmStmt(global::CppSharp.Parser.AST.MSAsmStmt.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected MSAsmStmt(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public MSAsmStmt()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.MSAsmStmt.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public MSAsmStmt(global::CppSharp.Parser.AST.MSAsmStmt _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.MSAsmStmt.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Stmt __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor(__Instance, 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.SourceLocation LBraceLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.MSAsmStmt.__Internal*) __Instance)->lBraceLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.MSAsmStmt.__Internal*)__Instance)->lBraceLoc = value.__Instance;
                    }
                }

                public bool HasBraces
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.MSAsmStmt.__Internal*) __Instance)->hasBraces != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.MSAsmStmt.__Internal*)__Instance)->hasBraces = (byte) (value ? 1 : 0);
                    }
                }

                public uint NumAsmToks
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.MSAsmStmt.__Internal*) __Instance)->numAsmToks;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.MSAsmStmt.__Internal*)__Instance)->numAsmToks = value;
                    }
                }

                public string AsmString
                {
                    get
                    {
                        var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.MSAsmStmt.__Internal*) __Instance)->asmString));
                        return global::Std.BasicStringExtensions.Data(__basicStringRet0);
                    }

                    set
                    {
                        global::Std.BasicStringExtensions.__Internal.Assign(new global::System.IntPtr(&((global::CppSharp.Parser.AST.MSAsmStmt.__Internal*)__Instance)->asmString), value);
                    }
                }
            }

            public unsafe partial class SEHExceptStmt : global::CppSharp.Parser.AST.Stmt, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 32)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exceptLoc;

                    [FieldOffset(24)]
                    internal global::System.IntPtr filterExpr;

                    [FieldOffset(28)]
                    internal global::System.IntPtr block;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0SEHExceptStmt@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0SEHExceptStmt@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.SEHExceptStmt __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.SEHExceptStmt(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.SEHExceptStmt __CreateInstance(global::CppSharp.Parser.AST.SEHExceptStmt.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.SEHExceptStmt(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.SEHExceptStmt.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.SEHExceptStmt.__Internal));
                    *(global::CppSharp.Parser.AST.SEHExceptStmt.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private SEHExceptStmt(global::CppSharp.Parser.AST.SEHExceptStmt.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected SEHExceptStmt(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public SEHExceptStmt()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.SEHExceptStmt.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public SEHExceptStmt(global::CppSharp.Parser.AST.SEHExceptStmt _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.SEHExceptStmt.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.SEHExceptStmt.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.SEHExceptStmt.__Internal*) _0.__Instance);
                }

                public global::CppSharp.Parser.SourceLocation ExceptLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.SEHExceptStmt.__Internal*) __Instance)->exceptLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.SEHExceptStmt.__Internal*)__Instance)->exceptLoc = value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Expr FilterExpr
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.SEHExceptStmt.__Internal*) __Instance)->filterExpr == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.SEHExceptStmt.__Internal*) __Instance)->filterExpr))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.SEHExceptStmt.__Internal*) __Instance)->filterExpr];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.SEHExceptStmt.__Internal*) __Instance)->filterExpr);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.SEHExceptStmt.__Internal*)__Instance)->filterExpr = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.CompoundStmt Block
                {
                    get
                    {
                        global::CppSharp.Parser.AST.CompoundStmt __result0;
                        if (((global::CppSharp.Parser.AST.SEHExceptStmt.__Internal*) __Instance)->block == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.CompoundStmt.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.SEHExceptStmt.__Internal*) __Instance)->block))
                            __result0 = (global::CppSharp.Parser.AST.CompoundStmt) global::CppSharp.Parser.AST.CompoundStmt.NativeToManagedMap[((global::CppSharp.Parser.AST.SEHExceptStmt.__Internal*) __Instance)->block];
                        else __result0 = global::CppSharp.Parser.AST.CompoundStmt.__CreateInstance(((global::CppSharp.Parser.AST.SEHExceptStmt.__Internal*) __Instance)->block);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.SEHExceptStmt.__Internal*)__Instance)->block = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }
            }

            public unsafe partial class SEHFinallyStmt : global::CppSharp.Parser.AST.Stmt, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 28)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal finallyLoc;

                    [FieldOffset(24)]
                    internal global::System.IntPtr block;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0SEHFinallyStmt@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0SEHFinallyStmt@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.SEHFinallyStmt __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.SEHFinallyStmt(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.SEHFinallyStmt __CreateInstance(global::CppSharp.Parser.AST.SEHFinallyStmt.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.SEHFinallyStmt(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.SEHFinallyStmt.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.SEHFinallyStmt.__Internal));
                    *(global::CppSharp.Parser.AST.SEHFinallyStmt.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private SEHFinallyStmt(global::CppSharp.Parser.AST.SEHFinallyStmt.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected SEHFinallyStmt(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public SEHFinallyStmt()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.SEHFinallyStmt.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public SEHFinallyStmt(global::CppSharp.Parser.AST.SEHFinallyStmt _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.SEHFinallyStmt.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.SEHFinallyStmt.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.SEHFinallyStmt.__Internal*) _0.__Instance);
                }

                public global::CppSharp.Parser.SourceLocation FinallyLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.SEHFinallyStmt.__Internal*) __Instance)->finallyLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.SEHFinallyStmt.__Internal*)__Instance)->finallyLoc = value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.CompoundStmt Block
                {
                    get
                    {
                        global::CppSharp.Parser.AST.CompoundStmt __result0;
                        if (((global::CppSharp.Parser.AST.SEHFinallyStmt.__Internal*) __Instance)->block == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.CompoundStmt.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.SEHFinallyStmt.__Internal*) __Instance)->block))
                            __result0 = (global::CppSharp.Parser.AST.CompoundStmt) global::CppSharp.Parser.AST.CompoundStmt.NativeToManagedMap[((global::CppSharp.Parser.AST.SEHFinallyStmt.__Internal*) __Instance)->block];
                        else __result0 = global::CppSharp.Parser.AST.CompoundStmt.__CreateInstance(((global::CppSharp.Parser.AST.SEHFinallyStmt.__Internal*) __Instance)->block);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.SEHFinallyStmt.__Internal*)__Instance)->block = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }
            }

            public unsafe partial class SEHTryStmt : global::CppSharp.Parser.AST.Stmt, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 44)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal tryLoc;

                    [FieldOffset(24)]
                    internal byte isCXXTry;

                    [FieldOffset(28)]
                    internal global::System.IntPtr tryBlock;

                    [FieldOffset(32)]
                    internal global::System.IntPtr handler;

                    [FieldOffset(36)]
                    internal global::System.IntPtr exceptHandler;

                    [FieldOffset(40)]
                    internal global::System.IntPtr finallyHandler;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0SEHTryStmt@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0SEHTryStmt@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.SEHTryStmt __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.SEHTryStmt(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.SEHTryStmt __CreateInstance(global::CppSharp.Parser.AST.SEHTryStmt.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.SEHTryStmt(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.SEHTryStmt.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.SEHTryStmt.__Internal));
                    *(global::CppSharp.Parser.AST.SEHTryStmt.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private SEHTryStmt(global::CppSharp.Parser.AST.SEHTryStmt.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected SEHTryStmt(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public SEHTryStmt()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.SEHTryStmt.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public SEHTryStmt(global::CppSharp.Parser.AST.SEHTryStmt _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.SEHTryStmt.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.SEHTryStmt.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.SEHTryStmt.__Internal*) _0.__Instance);
                }

                public global::CppSharp.Parser.SourceLocation TryLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.SEHTryStmt.__Internal*) __Instance)->tryLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.SEHTryStmt.__Internal*)__Instance)->tryLoc = value.__Instance;
                    }
                }

                public bool IsCXXTry
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.SEHTryStmt.__Internal*) __Instance)->isCXXTry != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.SEHTryStmt.__Internal*)__Instance)->isCXXTry = (byte) (value ? 1 : 0);
                    }
                }

                public global::CppSharp.Parser.AST.CompoundStmt TryBlock
                {
                    get
                    {
                        global::CppSharp.Parser.AST.CompoundStmt __result0;
                        if (((global::CppSharp.Parser.AST.SEHTryStmt.__Internal*) __Instance)->tryBlock == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.CompoundStmt.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.SEHTryStmt.__Internal*) __Instance)->tryBlock))
                            __result0 = (global::CppSharp.Parser.AST.CompoundStmt) global::CppSharp.Parser.AST.CompoundStmt.NativeToManagedMap[((global::CppSharp.Parser.AST.SEHTryStmt.__Internal*) __Instance)->tryBlock];
                        else __result0 = global::CppSharp.Parser.AST.CompoundStmt.__CreateInstance(((global::CppSharp.Parser.AST.SEHTryStmt.__Internal*) __Instance)->tryBlock);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.SEHTryStmt.__Internal*)__Instance)->tryBlock = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Stmt Handler
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Stmt __result0;
                        if (((global::CppSharp.Parser.AST.SEHTryStmt.__Internal*) __Instance)->handler == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Stmt.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.SEHTryStmt.__Internal*) __Instance)->handler))
                            __result0 = (global::CppSharp.Parser.AST.Stmt) global::CppSharp.Parser.AST.Stmt.NativeToManagedMap[((global::CppSharp.Parser.AST.SEHTryStmt.__Internal*) __Instance)->handler];
                        else __result0 = global::CppSharp.Parser.AST.Stmt.__CreateInstance(((global::CppSharp.Parser.AST.SEHTryStmt.__Internal*) __Instance)->handler);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.SEHTryStmt.__Internal*)__Instance)->handler = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.SEHExceptStmt ExceptHandler
                {
                    get
                    {
                        global::CppSharp.Parser.AST.SEHExceptStmt __result0;
                        if (((global::CppSharp.Parser.AST.SEHTryStmt.__Internal*) __Instance)->exceptHandler == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.SEHExceptStmt.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.SEHTryStmt.__Internal*) __Instance)->exceptHandler))
                            __result0 = (global::CppSharp.Parser.AST.SEHExceptStmt) global::CppSharp.Parser.AST.SEHExceptStmt.NativeToManagedMap[((global::CppSharp.Parser.AST.SEHTryStmt.__Internal*) __Instance)->exceptHandler];
                        else __result0 = global::CppSharp.Parser.AST.SEHExceptStmt.__CreateInstance(((global::CppSharp.Parser.AST.SEHTryStmt.__Internal*) __Instance)->exceptHandler);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.SEHTryStmt.__Internal*)__Instance)->exceptHandler = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.SEHFinallyStmt FinallyHandler
                {
                    get
                    {
                        global::CppSharp.Parser.AST.SEHFinallyStmt __result0;
                        if (((global::CppSharp.Parser.AST.SEHTryStmt.__Internal*) __Instance)->finallyHandler == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.SEHFinallyStmt.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.SEHTryStmt.__Internal*) __Instance)->finallyHandler))
                            __result0 = (global::CppSharp.Parser.AST.SEHFinallyStmt) global::CppSharp.Parser.AST.SEHFinallyStmt.NativeToManagedMap[((global::CppSharp.Parser.AST.SEHTryStmt.__Internal*) __Instance)->finallyHandler];
                        else __result0 = global::CppSharp.Parser.AST.SEHFinallyStmt.__CreateInstance(((global::CppSharp.Parser.AST.SEHTryStmt.__Internal*) __Instance)->finallyHandler);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.SEHTryStmt.__Internal*)__Instance)->finallyHandler = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }
            }

            public unsafe partial class SEHLeaveStmt : global::CppSharp.Parser.AST.Stmt, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 24)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal leaveLoc;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0SEHLeaveStmt@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0SEHLeaveStmt@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.SEHLeaveStmt __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.SEHLeaveStmt(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.SEHLeaveStmt __CreateInstance(global::CppSharp.Parser.AST.SEHLeaveStmt.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.SEHLeaveStmt(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.SEHLeaveStmt.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.SEHLeaveStmt.__Internal));
                    *(global::CppSharp.Parser.AST.SEHLeaveStmt.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private SEHLeaveStmt(global::CppSharp.Parser.AST.SEHLeaveStmt.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected SEHLeaveStmt(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public SEHLeaveStmt()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.SEHLeaveStmt.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public SEHLeaveStmt(global::CppSharp.Parser.AST.SEHLeaveStmt _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.SEHLeaveStmt.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.SEHLeaveStmt.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.SEHLeaveStmt.__Internal*) _0.__Instance);
                }

                public global::CppSharp.Parser.SourceLocation LeaveLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.SEHLeaveStmt.__Internal*) __Instance)->leaveLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.SEHLeaveStmt.__Internal*)__Instance)->leaveLoc = value.__Instance;
                    }
                }
            }

            public unsafe partial class CapturedStmt : global::CppSharp.Parser.AST.Stmt, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 40)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Expr___N_std_S_allocator__S0_ capture_inits;

                    [FieldOffset(32)]
                    internal global::System.IntPtr capturedStmt;

                    [FieldOffset(36)]
                    internal uint capture_size;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CapturedStmt@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CapturedStmt@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??1CapturedStmt@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern void dtor(global::System.IntPtr __instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getcapture_inits@CapturedStmt@AST@CppParser@CppSharp@@QAEPAVExpr@234@I@Z")]
                    internal static extern global::System.IntPtr GetcaptureInits(global::System.IntPtr __instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?addcapture_inits@CapturedStmt@AST@CppParser@CppSharp@@QAEXAAPAVExpr@234@@Z")]
                    internal static extern void AddcaptureInits(global::System.IntPtr __instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?clearcapture_inits@CapturedStmt@AST@CppParser@CppSharp@@QAEXXZ")]
                    internal static extern void ClearcaptureInits(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getcapture_initsCount@CapturedStmt@AST@CppParser@CppSharp@@QAEIXZ")]
                    internal static extern uint GetcaptureInitsCount(global::System.IntPtr __instance);
                }

                public enum VariableCaptureKind
                {
                    This = 0,
                    ByRef = 1,
                    ByCopy = 2,
                    VLAType = 3
                }

                public unsafe partial class Capture : IDisposable
                {
                    [StructLayout(LayoutKind.Explicit, Size = 12)]
                    public partial struct __Internal
                    {
                        [FieldOffset(0)]
                        internal global::CppSharp.Parser.AST.CapturedStmt.VariableCaptureKind captureKind;

                        [FieldOffset(4)]
                        internal global::CppSharp.Parser.SourceLocation.__Internal location;

                        [FieldOffset(8)]
                        internal byte capturesThis;

                        [FieldOffset(9)]
                        internal byte capturesVariable;

                        [FieldOffset(10)]
                        internal byte capturesVariableByCopy;

                        [FieldOffset(11)]
                        internal byte capturesVariableArrayType;

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                            EntryPoint="??0Capture@CapturedStmt@AST@CppParser@CppSharp@@QAE@XZ")]
                        internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                            EntryPoint="??0Capture@CapturedStmt@AST@CppParser@CppSharp@@QAE@ABV01234@@Z")]
                        internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                    }

                    public global::System.IntPtr __Instance { get; protected set; }

                    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.CapturedStmt.Capture> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.CapturedStmt.Capture>();
                    protected internal void*[] __OriginalVTables;

                    protected bool __ownsNativeInstance;

                    internal static global::CppSharp.Parser.AST.CapturedStmt.Capture __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                    {
                        return new global::CppSharp.Parser.AST.CapturedStmt.Capture(native.ToPointer(), skipVTables);
                    }

                    internal static global::CppSharp.Parser.AST.CapturedStmt.Capture __CreateInstance(global::CppSharp.Parser.AST.CapturedStmt.Capture.__Internal native, bool skipVTables = false)
                    {
                        return new global::CppSharp.Parser.AST.CapturedStmt.Capture(native, skipVTables);
                    }

                    private static void* __CopyValue(global::CppSharp.Parser.AST.CapturedStmt.Capture.__Internal native)
                    {
                        var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CapturedStmt.Capture.__Internal));
                        *(global::CppSharp.Parser.AST.CapturedStmt.Capture.__Internal*) ret = native;
                        return ret.ToPointer();
                    }

                    private Capture(global::CppSharp.Parser.AST.CapturedStmt.Capture.__Internal native, bool skipVTables = false)
                        : this(__CopyValue(native), skipVTables)
                    {
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                    }

                    protected Capture(void* native, bool skipVTables = false)
                    {
                        if (native == null)
                            return;
                        __Instance = new global::System.IntPtr(native);
                    }

                    public Capture()
                    {
                        __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CapturedStmt.Capture.__Internal));
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                        __Internal.ctor(__Instance);
                    }

                    public Capture(global::CppSharp.Parser.AST.CapturedStmt.Capture _0)
                    {
                        __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CapturedStmt.Capture.__Internal));
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                        *((global::CppSharp.Parser.AST.CapturedStmt.Capture.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.CapturedStmt.Capture.__Internal*) _0.__Instance);
                    }

                    public void Dispose()
                    {
                        Dispose(disposing: true);
                    }

                    public virtual void Dispose(bool disposing)
                    {
                        if (__Instance == IntPtr.Zero)
                            return;
                        global::CppSharp.Parser.AST.CapturedStmt.Capture __dummy;
                        NativeToManagedMap.TryRemove(__Instance, out __dummy);
                        if (__ownsNativeInstance)
                            Marshal.FreeHGlobal(__Instance);
                        __Instance = IntPtr.Zero;
                    }

                    public global::CppSharp.Parser.AST.CapturedStmt.VariableCaptureKind CaptureKind
                    {
                        get
                        {
                            return ((global::CppSharp.Parser.AST.CapturedStmt.Capture.__Internal*) __Instance)->captureKind;
                        }

                        set
                        {
                            ((global::CppSharp.Parser.AST.CapturedStmt.Capture.__Internal*)__Instance)->captureKind = value;
                        }
                    }

                    public global::CppSharp.Parser.SourceLocation Location
                    {
                        get
                        {
                            return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.CapturedStmt.Capture.__Internal*) __Instance)->location);
                        }

                        set
                        {
                            ((global::CppSharp.Parser.AST.CapturedStmt.Capture.__Internal*)__Instance)->location = value.__Instance;
                        }
                    }

                    public bool CapturesThis
                    {
                        get
                        {
                            return ((global::CppSharp.Parser.AST.CapturedStmt.Capture.__Internal*) __Instance)->capturesThis != 0;
                        }

                        set
                        {
                            ((global::CppSharp.Parser.AST.CapturedStmt.Capture.__Internal*)__Instance)->capturesThis = (byte) (value ? 1 : 0);
                        }
                    }

                    public bool CapturesVariable
                    {
                        get
                        {
                            return ((global::CppSharp.Parser.AST.CapturedStmt.Capture.__Internal*) __Instance)->capturesVariable != 0;
                        }

                        set
                        {
                            ((global::CppSharp.Parser.AST.CapturedStmt.Capture.__Internal*)__Instance)->capturesVariable = (byte) (value ? 1 : 0);
                        }
                    }

                    public bool CapturesVariableByCopy
                    {
                        get
                        {
                            return ((global::CppSharp.Parser.AST.CapturedStmt.Capture.__Internal*) __Instance)->capturesVariableByCopy != 0;
                        }

                        set
                        {
                            ((global::CppSharp.Parser.AST.CapturedStmt.Capture.__Internal*)__Instance)->capturesVariableByCopy = (byte) (value ? 1 : 0);
                        }
                    }

                    public bool CapturesVariableArrayType
                    {
                        get
                        {
                            return ((global::CppSharp.Parser.AST.CapturedStmt.Capture.__Internal*) __Instance)->capturesVariableArrayType != 0;
                        }

                        set
                        {
                            ((global::CppSharp.Parser.AST.CapturedStmt.Capture.__Internal*)__Instance)->capturesVariableArrayType = (byte) (value ? 1 : 0);
                        }
                    }
                }

                internal static new global::CppSharp.Parser.AST.CapturedStmt __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CapturedStmt(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.CapturedStmt __CreateInstance(global::CppSharp.Parser.AST.CapturedStmt.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CapturedStmt(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.CapturedStmt.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CapturedStmt.__Internal));
                    global::CppSharp.Parser.AST.CapturedStmt.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private CapturedStmt(global::CppSharp.Parser.AST.CapturedStmt.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected CapturedStmt(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public CapturedStmt()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CapturedStmt.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public CapturedStmt(global::CppSharp.Parser.AST.CapturedStmt _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CapturedStmt.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Stmt __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor(__Instance, 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.Expr GetcaptureInits(uint i)
                {
                    var __ret = __Internal.GetcaptureInits(__Instance, i);
                    global::CppSharp.Parser.AST.Expr __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[__ret];
                    else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(__ret);
                    return __result0;
                }

                public void AddcaptureInits(global::CppSharp.Parser.AST.Expr s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var ____arg0 = s.__Instance;
                    var __arg0 = new global::System.IntPtr(&____arg0);
                    __Internal.AddcaptureInits(__Instance, __arg0);
                }

                public void ClearcaptureInits()
                {
                    __Internal.ClearcaptureInits(__Instance);
                }

                public global::CppSharp.Parser.AST.Stmt capturedStmt
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Stmt __result0;
                        if (((global::CppSharp.Parser.AST.CapturedStmt.__Internal*) __Instance)->capturedStmt == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Stmt.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.CapturedStmt.__Internal*) __Instance)->capturedStmt))
                            __result0 = (global::CppSharp.Parser.AST.Stmt) global::CppSharp.Parser.AST.Stmt.NativeToManagedMap[((global::CppSharp.Parser.AST.CapturedStmt.__Internal*) __Instance)->capturedStmt];
                        else __result0 = global::CppSharp.Parser.AST.Stmt.__CreateInstance(((global::CppSharp.Parser.AST.CapturedStmt.__Internal*) __Instance)->capturedStmt);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CapturedStmt.__Internal*)__Instance)->capturedStmt = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public uint CaptureSize
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.CapturedStmt.__Internal*) __Instance)->capture_size;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CapturedStmt.__Internal*)__Instance)->capture_size = value;
                    }
                }

                public uint GetcaptureInitsCount
                {
                    get
                    {
                        var __ret = __Internal.GetcaptureInitsCount(__Instance);
                        return __ret;
                    }
                }
            }

            public unsafe partial class CXXCatchStmt : global::CppSharp.Parser.AST.Stmt, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 36)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal catchLoc;

                    [FieldOffset(24)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal caughtType;

                    [FieldOffset(32)]
                    internal global::System.IntPtr handlerBlock;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CXXCatchStmt@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CXXCatchStmt@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.CXXCatchStmt __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CXXCatchStmt(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.CXXCatchStmt __CreateInstance(global::CppSharp.Parser.AST.CXXCatchStmt.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CXXCatchStmt(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.CXXCatchStmt.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXCatchStmt.__Internal));
                    *(global::CppSharp.Parser.AST.CXXCatchStmt.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private CXXCatchStmt(global::CppSharp.Parser.AST.CXXCatchStmt.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected CXXCatchStmt(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public CXXCatchStmt()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXCatchStmt.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public CXXCatchStmt(global::CppSharp.Parser.AST.CXXCatchStmt _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXCatchStmt.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.CXXCatchStmt.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.CXXCatchStmt.__Internal*) _0.__Instance);
                }

                public global::CppSharp.Parser.SourceLocation CatchLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.CXXCatchStmt.__Internal*) __Instance)->catchLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXCatchStmt.__Internal*)__Instance)->catchLoc = value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.QualifiedType CaughtType
                {
                    get
                    {
                        return global::CppSharp.Parser.AST.QualifiedType.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.CXXCatchStmt.__Internal*) __Instance)->caughtType));
                    }

                    set
                    {
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                        ((global::CppSharp.Parser.AST.CXXCatchStmt.__Internal*)__Instance)->caughtType = *(global::CppSharp.Parser.AST.QualifiedType.__Internal*) value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Stmt HandlerBlock
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Stmt __result0;
                        if (((global::CppSharp.Parser.AST.CXXCatchStmt.__Internal*) __Instance)->handlerBlock == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Stmt.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.CXXCatchStmt.__Internal*) __Instance)->handlerBlock))
                            __result0 = (global::CppSharp.Parser.AST.Stmt) global::CppSharp.Parser.AST.Stmt.NativeToManagedMap[((global::CppSharp.Parser.AST.CXXCatchStmt.__Internal*) __Instance)->handlerBlock];
                        else __result0 = global::CppSharp.Parser.AST.Stmt.__CreateInstance(((global::CppSharp.Parser.AST.CXXCatchStmt.__Internal*) __Instance)->handlerBlock);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXCatchStmt.__Internal*)__Instance)->handlerBlock = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }
            }

            public unsafe partial class CXXTryStmt : global::CppSharp.Parser.AST.Stmt, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 32)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal tryLoc;

                    [FieldOffset(24)]
                    internal global::System.IntPtr tryBlock;

                    [FieldOffset(28)]
                    internal uint numHandlers;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CXXTryStmt@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CXXTryStmt@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.CXXTryStmt __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CXXTryStmt(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.CXXTryStmt __CreateInstance(global::CppSharp.Parser.AST.CXXTryStmt.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CXXTryStmt(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.CXXTryStmt.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXTryStmt.__Internal));
                    *(global::CppSharp.Parser.AST.CXXTryStmt.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private CXXTryStmt(global::CppSharp.Parser.AST.CXXTryStmt.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected CXXTryStmt(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public CXXTryStmt()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXTryStmt.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public CXXTryStmt(global::CppSharp.Parser.AST.CXXTryStmt _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXTryStmt.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.CXXTryStmt.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.CXXTryStmt.__Internal*) _0.__Instance);
                }

                public global::CppSharp.Parser.SourceLocation TryLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.CXXTryStmt.__Internal*) __Instance)->tryLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXTryStmt.__Internal*)__Instance)->tryLoc = value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.CompoundStmt TryBlock
                {
                    get
                    {
                        global::CppSharp.Parser.AST.CompoundStmt __result0;
                        if (((global::CppSharp.Parser.AST.CXXTryStmt.__Internal*) __Instance)->tryBlock == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.CompoundStmt.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.CXXTryStmt.__Internal*) __Instance)->tryBlock))
                            __result0 = (global::CppSharp.Parser.AST.CompoundStmt) global::CppSharp.Parser.AST.CompoundStmt.NativeToManagedMap[((global::CppSharp.Parser.AST.CXXTryStmt.__Internal*) __Instance)->tryBlock];
                        else __result0 = global::CppSharp.Parser.AST.CompoundStmt.__CreateInstance(((global::CppSharp.Parser.AST.CXXTryStmt.__Internal*) __Instance)->tryBlock);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXTryStmt.__Internal*)__Instance)->tryBlock = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public uint NumHandlers
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.CXXTryStmt.__Internal*) __Instance)->numHandlers;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXTryStmt.__Internal*)__Instance)->numHandlers = value;
                    }
                }
            }

            public unsafe partial class CXXForRangeStmt : global::CppSharp.Parser.AST.Stmt, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 72)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::System.IntPtr init;

                    [FieldOffset(24)]
                    internal global::System.IntPtr rangeInit;

                    [FieldOffset(28)]
                    internal global::System.IntPtr cond;

                    [FieldOffset(32)]
                    internal global::System.IntPtr inc;

                    [FieldOffset(36)]
                    internal global::System.IntPtr body;

                    [FieldOffset(40)]
                    internal global::System.IntPtr rangeStmt;

                    [FieldOffset(44)]
                    internal global::System.IntPtr beginStmt;

                    [FieldOffset(48)]
                    internal global::System.IntPtr endStmt;

                    [FieldOffset(52)]
                    internal global::System.IntPtr loopVarStmt;

                    [FieldOffset(56)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal forLoc;

                    [FieldOffset(60)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal coawaitLoc;

                    [FieldOffset(64)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal colonLoc;

                    [FieldOffset(68)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal rParenLoc;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CXXForRangeStmt@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CXXForRangeStmt@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.CXXForRangeStmt __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CXXForRangeStmt(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.CXXForRangeStmt __CreateInstance(global::CppSharp.Parser.AST.CXXForRangeStmt.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CXXForRangeStmt(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.CXXForRangeStmt.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXForRangeStmt.__Internal));
                    *(global::CppSharp.Parser.AST.CXXForRangeStmt.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private CXXForRangeStmt(global::CppSharp.Parser.AST.CXXForRangeStmt.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected CXXForRangeStmt(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public CXXForRangeStmt()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXForRangeStmt.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public CXXForRangeStmt(global::CppSharp.Parser.AST.CXXForRangeStmt _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXForRangeStmt.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.CXXForRangeStmt.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.CXXForRangeStmt.__Internal*) _0.__Instance);
                }

                public global::CppSharp.Parser.AST.Stmt Init
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Stmt __result0;
                        if (((global::CppSharp.Parser.AST.CXXForRangeStmt.__Internal*) __Instance)->init == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Stmt.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.CXXForRangeStmt.__Internal*) __Instance)->init))
                            __result0 = (global::CppSharp.Parser.AST.Stmt) global::CppSharp.Parser.AST.Stmt.NativeToManagedMap[((global::CppSharp.Parser.AST.CXXForRangeStmt.__Internal*) __Instance)->init];
                        else __result0 = global::CppSharp.Parser.AST.Stmt.__CreateInstance(((global::CppSharp.Parser.AST.CXXForRangeStmt.__Internal*) __Instance)->init);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXForRangeStmt.__Internal*)__Instance)->init = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Expr RangeInit
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.CXXForRangeStmt.__Internal*) __Instance)->rangeInit == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.CXXForRangeStmt.__Internal*) __Instance)->rangeInit))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.CXXForRangeStmt.__Internal*) __Instance)->rangeInit];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.CXXForRangeStmt.__Internal*) __Instance)->rangeInit);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXForRangeStmt.__Internal*)__Instance)->rangeInit = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Expr Cond
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.CXXForRangeStmt.__Internal*) __Instance)->cond == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.CXXForRangeStmt.__Internal*) __Instance)->cond))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.CXXForRangeStmt.__Internal*) __Instance)->cond];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.CXXForRangeStmt.__Internal*) __Instance)->cond);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXForRangeStmt.__Internal*)__Instance)->cond = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Expr Inc
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.CXXForRangeStmt.__Internal*) __Instance)->inc == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.CXXForRangeStmt.__Internal*) __Instance)->inc))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.CXXForRangeStmt.__Internal*) __Instance)->inc];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.CXXForRangeStmt.__Internal*) __Instance)->inc);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXForRangeStmt.__Internal*)__Instance)->inc = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Stmt Body
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Stmt __result0;
                        if (((global::CppSharp.Parser.AST.CXXForRangeStmt.__Internal*) __Instance)->body == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Stmt.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.CXXForRangeStmt.__Internal*) __Instance)->body))
                            __result0 = (global::CppSharp.Parser.AST.Stmt) global::CppSharp.Parser.AST.Stmt.NativeToManagedMap[((global::CppSharp.Parser.AST.CXXForRangeStmt.__Internal*) __Instance)->body];
                        else __result0 = global::CppSharp.Parser.AST.Stmt.__CreateInstance(((global::CppSharp.Parser.AST.CXXForRangeStmt.__Internal*) __Instance)->body);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXForRangeStmt.__Internal*)__Instance)->body = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.DeclStmt RangeStmt
                {
                    get
                    {
                        global::CppSharp.Parser.AST.DeclStmt __result0;
                        if (((global::CppSharp.Parser.AST.CXXForRangeStmt.__Internal*) __Instance)->rangeStmt == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.DeclStmt.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.CXXForRangeStmt.__Internal*) __Instance)->rangeStmt))
                            __result0 = (global::CppSharp.Parser.AST.DeclStmt) global::CppSharp.Parser.AST.DeclStmt.NativeToManagedMap[((global::CppSharp.Parser.AST.CXXForRangeStmt.__Internal*) __Instance)->rangeStmt];
                        else __result0 = global::CppSharp.Parser.AST.DeclStmt.__CreateInstance(((global::CppSharp.Parser.AST.CXXForRangeStmt.__Internal*) __Instance)->rangeStmt);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXForRangeStmt.__Internal*)__Instance)->rangeStmt = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.DeclStmt BeginStmt
                {
                    get
                    {
                        global::CppSharp.Parser.AST.DeclStmt __result0;
                        if (((global::CppSharp.Parser.AST.CXXForRangeStmt.__Internal*) __Instance)->beginStmt == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.DeclStmt.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.CXXForRangeStmt.__Internal*) __Instance)->beginStmt))
                            __result0 = (global::CppSharp.Parser.AST.DeclStmt) global::CppSharp.Parser.AST.DeclStmt.NativeToManagedMap[((global::CppSharp.Parser.AST.CXXForRangeStmt.__Internal*) __Instance)->beginStmt];
                        else __result0 = global::CppSharp.Parser.AST.DeclStmt.__CreateInstance(((global::CppSharp.Parser.AST.CXXForRangeStmt.__Internal*) __Instance)->beginStmt);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXForRangeStmt.__Internal*)__Instance)->beginStmt = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.DeclStmt EndStmt
                {
                    get
                    {
                        global::CppSharp.Parser.AST.DeclStmt __result0;
                        if (((global::CppSharp.Parser.AST.CXXForRangeStmt.__Internal*) __Instance)->endStmt == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.DeclStmt.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.CXXForRangeStmt.__Internal*) __Instance)->endStmt))
                            __result0 = (global::CppSharp.Parser.AST.DeclStmt) global::CppSharp.Parser.AST.DeclStmt.NativeToManagedMap[((global::CppSharp.Parser.AST.CXXForRangeStmt.__Internal*) __Instance)->endStmt];
                        else __result0 = global::CppSharp.Parser.AST.DeclStmt.__CreateInstance(((global::CppSharp.Parser.AST.CXXForRangeStmt.__Internal*) __Instance)->endStmt);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXForRangeStmt.__Internal*)__Instance)->endStmt = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.DeclStmt LoopVarStmt
                {
                    get
                    {
                        global::CppSharp.Parser.AST.DeclStmt __result0;
                        if (((global::CppSharp.Parser.AST.CXXForRangeStmt.__Internal*) __Instance)->loopVarStmt == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.DeclStmt.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.CXXForRangeStmt.__Internal*) __Instance)->loopVarStmt))
                            __result0 = (global::CppSharp.Parser.AST.DeclStmt) global::CppSharp.Parser.AST.DeclStmt.NativeToManagedMap[((global::CppSharp.Parser.AST.CXXForRangeStmt.__Internal*) __Instance)->loopVarStmt];
                        else __result0 = global::CppSharp.Parser.AST.DeclStmt.__CreateInstance(((global::CppSharp.Parser.AST.CXXForRangeStmt.__Internal*) __Instance)->loopVarStmt);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXForRangeStmt.__Internal*)__Instance)->loopVarStmt = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.SourceLocation ForLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.CXXForRangeStmt.__Internal*) __Instance)->forLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXForRangeStmt.__Internal*)__Instance)->forLoc = value.__Instance;
                    }
                }

                public global::CppSharp.Parser.SourceLocation CoawaitLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.CXXForRangeStmt.__Internal*) __Instance)->coawaitLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXForRangeStmt.__Internal*)__Instance)->coawaitLoc = value.__Instance;
                    }
                }

                public global::CppSharp.Parser.SourceLocation ColonLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.CXXForRangeStmt.__Internal*) __Instance)->colonLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXForRangeStmt.__Internal*)__Instance)->colonLoc = value.__Instance;
                    }
                }

                public global::CppSharp.Parser.SourceLocation RParenLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.CXXForRangeStmt.__Internal*) __Instance)->rParenLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXForRangeStmt.__Internal*)__Instance)->rParenLoc = value.__Instance;
                    }
                }
            }

            public unsafe partial class MSDependentExistsStmt : global::CppSharp.Parser.AST.Stmt, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 32)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal keywordLoc;

                    [FieldOffset(24)]
                    internal byte isIfExists;

                    [FieldOffset(25)]
                    internal byte isIfNotExists;

                    [FieldOffset(28)]
                    internal global::System.IntPtr subStmt;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0MSDependentExistsStmt@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0MSDependentExistsStmt@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.MSDependentExistsStmt __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.MSDependentExistsStmt(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.MSDependentExistsStmt __CreateInstance(global::CppSharp.Parser.AST.MSDependentExistsStmt.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.MSDependentExistsStmt(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.MSDependentExistsStmt.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.MSDependentExistsStmt.__Internal));
                    *(global::CppSharp.Parser.AST.MSDependentExistsStmt.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private MSDependentExistsStmt(global::CppSharp.Parser.AST.MSDependentExistsStmt.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected MSDependentExistsStmt(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public MSDependentExistsStmt()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.MSDependentExistsStmt.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public MSDependentExistsStmt(global::CppSharp.Parser.AST.MSDependentExistsStmt _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.MSDependentExistsStmt.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.MSDependentExistsStmt.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.MSDependentExistsStmt.__Internal*) _0.__Instance);
                }

                public global::CppSharp.Parser.SourceLocation KeywordLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.MSDependentExistsStmt.__Internal*) __Instance)->keywordLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.MSDependentExistsStmt.__Internal*)__Instance)->keywordLoc = value.__Instance;
                    }
                }

                public bool IsIfExists
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.MSDependentExistsStmt.__Internal*) __Instance)->isIfExists != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.MSDependentExistsStmt.__Internal*)__Instance)->isIfExists = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsIfNotExists
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.MSDependentExistsStmt.__Internal*) __Instance)->isIfNotExists != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.MSDependentExistsStmt.__Internal*)__Instance)->isIfNotExists = (byte) (value ? 1 : 0);
                    }
                }

                public global::CppSharp.Parser.AST.CompoundStmt SubStmt
                {
                    get
                    {
                        global::CppSharp.Parser.AST.CompoundStmt __result0;
                        if (((global::CppSharp.Parser.AST.MSDependentExistsStmt.__Internal*) __Instance)->subStmt == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.CompoundStmt.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.MSDependentExistsStmt.__Internal*) __Instance)->subStmt))
                            __result0 = (global::CppSharp.Parser.AST.CompoundStmt) global::CppSharp.Parser.AST.CompoundStmt.NativeToManagedMap[((global::CppSharp.Parser.AST.MSDependentExistsStmt.__Internal*) __Instance)->subStmt];
                        else __result0 = global::CppSharp.Parser.AST.CompoundStmt.__CreateInstance(((global::CppSharp.Parser.AST.MSDependentExistsStmt.__Internal*) __Instance)->subStmt);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.MSDependentExistsStmt.__Internal*)__Instance)->subStmt = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }
            }

            public unsafe partial class CoroutineBodyStmt : global::CppSharp.Parser.AST.Stmt, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 72)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal byte hasDependentPromiseType;

                    [FieldOffset(24)]
                    internal global::System.IntPtr body;

                    [FieldOffset(28)]
                    internal global::System.IntPtr promiseDeclStmt;

                    [FieldOffset(32)]
                    internal global::System.IntPtr initSuspendStmt;

                    [FieldOffset(36)]
                    internal global::System.IntPtr finalSuspendStmt;

                    [FieldOffset(40)]
                    internal global::System.IntPtr exceptionHandler;

                    [FieldOffset(44)]
                    internal global::System.IntPtr fallthroughHandler;

                    [FieldOffset(48)]
                    internal global::System.IntPtr allocate;

                    [FieldOffset(52)]
                    internal global::System.IntPtr deallocate;

                    [FieldOffset(56)]
                    internal global::System.IntPtr returnValueInit;

                    [FieldOffset(60)]
                    internal global::System.IntPtr resultDecl;

                    [FieldOffset(64)]
                    internal global::System.IntPtr returnStmt;

                    [FieldOffset(68)]
                    internal global::System.IntPtr returnStmtOnAllocFailure;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CoroutineBodyStmt@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CoroutineBodyStmt@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                public enum SubStmt
                {
                    Body = 0,
                    Promise = 1,
                    InitSuspend = 2,
                    FinalSuspend = 3,
                    OnException = 4,
                    OnFallthrough = 5,
                    Allocate = 6,
                    Deallocate = 7,
                    ReturnValue = 8,
                    ResultDecl = 9,
                    ReturnStmt = 10,
                    ReturnStmtOnAllocFailure = 11,
                    FirstParamMove = 12
                }

                public unsafe partial class CtorArgs : IDisposable
                {
                    [StructLayout(LayoutKind.Explicit, Size = 0)]
                    public partial struct __Internal
                    {
                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                            EntryPoint="??0CtorArgs@CoroutineBodyStmt@AST@CppParser@CppSharp@@QAE@XZ")]
                        internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                            EntryPoint="??0CtorArgs@CoroutineBodyStmt@AST@CppParser@CppSharp@@QAE@ABV01234@@Z")]
                        internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                    }

                    public global::System.IntPtr __Instance { get; protected set; }

                    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.CoroutineBodyStmt.CtorArgs> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.CoroutineBodyStmt.CtorArgs>();
                    protected internal void*[] __OriginalVTables;

                    protected bool __ownsNativeInstance;

                    internal static global::CppSharp.Parser.AST.CoroutineBodyStmt.CtorArgs __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                    {
                        return new global::CppSharp.Parser.AST.CoroutineBodyStmt.CtorArgs(native.ToPointer(), skipVTables);
                    }

                    internal static global::CppSharp.Parser.AST.CoroutineBodyStmt.CtorArgs __CreateInstance(global::CppSharp.Parser.AST.CoroutineBodyStmt.CtorArgs.__Internal native, bool skipVTables = false)
                    {
                        return new global::CppSharp.Parser.AST.CoroutineBodyStmt.CtorArgs(native, skipVTables);
                    }

                    private static void* __CopyValue(global::CppSharp.Parser.AST.CoroutineBodyStmt.CtorArgs.__Internal native)
                    {
                        var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CoroutineBodyStmt.CtorArgs.__Internal));
                        *(global::CppSharp.Parser.AST.CoroutineBodyStmt.CtorArgs.__Internal*) ret = native;
                        return ret.ToPointer();
                    }

                    private CtorArgs(global::CppSharp.Parser.AST.CoroutineBodyStmt.CtorArgs.__Internal native, bool skipVTables = false)
                        : this(__CopyValue(native), skipVTables)
                    {
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                    }

                    protected CtorArgs(void* native, bool skipVTables = false)
                    {
                        if (native == null)
                            return;
                        __Instance = new global::System.IntPtr(native);
                    }

                    public CtorArgs()
                    {
                        __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CoroutineBodyStmt.CtorArgs.__Internal));
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                        __Internal.ctor(__Instance);
                    }

                    public CtorArgs(global::CppSharp.Parser.AST.CoroutineBodyStmt.CtorArgs _0)
                    {
                        __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CoroutineBodyStmt.CtorArgs.__Internal));
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                        *((global::CppSharp.Parser.AST.CoroutineBodyStmt.CtorArgs.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.CoroutineBodyStmt.CtorArgs.__Internal*) _0.__Instance);
                    }

                    public void Dispose()
                    {
                        Dispose(disposing: true);
                    }

                    public virtual void Dispose(bool disposing)
                    {
                        if (__Instance == IntPtr.Zero)
                            return;
                        global::CppSharp.Parser.AST.CoroutineBodyStmt.CtorArgs __dummy;
                        NativeToManagedMap.TryRemove(__Instance, out __dummy);
                        if (__ownsNativeInstance)
                            Marshal.FreeHGlobal(__Instance);
                        __Instance = IntPtr.Zero;
                    }
                }

                internal static new global::CppSharp.Parser.AST.CoroutineBodyStmt __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CoroutineBodyStmt(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.CoroutineBodyStmt __CreateInstance(global::CppSharp.Parser.AST.CoroutineBodyStmt.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CoroutineBodyStmt(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.CoroutineBodyStmt.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CoroutineBodyStmt.__Internal));
                    *(global::CppSharp.Parser.AST.CoroutineBodyStmt.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private CoroutineBodyStmt(global::CppSharp.Parser.AST.CoroutineBodyStmt.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected CoroutineBodyStmt(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public CoroutineBodyStmt()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CoroutineBodyStmt.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public CoroutineBodyStmt(global::CppSharp.Parser.AST.CoroutineBodyStmt _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CoroutineBodyStmt.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.CoroutineBodyStmt.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.CoroutineBodyStmt.__Internal*) _0.__Instance);
                }

                public bool HasDependentPromiseType
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.CoroutineBodyStmt.__Internal*) __Instance)->hasDependentPromiseType != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CoroutineBodyStmt.__Internal*)__Instance)->hasDependentPromiseType = (byte) (value ? 1 : 0);
                    }
                }

                public global::CppSharp.Parser.AST.Stmt Body
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Stmt __result0;
                        if (((global::CppSharp.Parser.AST.CoroutineBodyStmt.__Internal*) __Instance)->body == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Stmt.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.CoroutineBodyStmt.__Internal*) __Instance)->body))
                            __result0 = (global::CppSharp.Parser.AST.Stmt) global::CppSharp.Parser.AST.Stmt.NativeToManagedMap[((global::CppSharp.Parser.AST.CoroutineBodyStmt.__Internal*) __Instance)->body];
                        else __result0 = global::CppSharp.Parser.AST.Stmt.__CreateInstance(((global::CppSharp.Parser.AST.CoroutineBodyStmt.__Internal*) __Instance)->body);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CoroutineBodyStmt.__Internal*)__Instance)->body = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Stmt PromiseDeclStmt
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Stmt __result0;
                        if (((global::CppSharp.Parser.AST.CoroutineBodyStmt.__Internal*) __Instance)->promiseDeclStmt == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Stmt.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.CoroutineBodyStmt.__Internal*) __Instance)->promiseDeclStmt))
                            __result0 = (global::CppSharp.Parser.AST.Stmt) global::CppSharp.Parser.AST.Stmt.NativeToManagedMap[((global::CppSharp.Parser.AST.CoroutineBodyStmt.__Internal*) __Instance)->promiseDeclStmt];
                        else __result0 = global::CppSharp.Parser.AST.Stmt.__CreateInstance(((global::CppSharp.Parser.AST.CoroutineBodyStmt.__Internal*) __Instance)->promiseDeclStmt);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CoroutineBodyStmt.__Internal*)__Instance)->promiseDeclStmt = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Stmt InitSuspendStmt
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Stmt __result0;
                        if (((global::CppSharp.Parser.AST.CoroutineBodyStmt.__Internal*) __Instance)->initSuspendStmt == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Stmt.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.CoroutineBodyStmt.__Internal*) __Instance)->initSuspendStmt))
                            __result0 = (global::CppSharp.Parser.AST.Stmt) global::CppSharp.Parser.AST.Stmt.NativeToManagedMap[((global::CppSharp.Parser.AST.CoroutineBodyStmt.__Internal*) __Instance)->initSuspendStmt];
                        else __result0 = global::CppSharp.Parser.AST.Stmt.__CreateInstance(((global::CppSharp.Parser.AST.CoroutineBodyStmt.__Internal*) __Instance)->initSuspendStmt);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CoroutineBodyStmt.__Internal*)__Instance)->initSuspendStmt = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Stmt FinalSuspendStmt
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Stmt __result0;
                        if (((global::CppSharp.Parser.AST.CoroutineBodyStmt.__Internal*) __Instance)->finalSuspendStmt == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Stmt.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.CoroutineBodyStmt.__Internal*) __Instance)->finalSuspendStmt))
                            __result0 = (global::CppSharp.Parser.AST.Stmt) global::CppSharp.Parser.AST.Stmt.NativeToManagedMap[((global::CppSharp.Parser.AST.CoroutineBodyStmt.__Internal*) __Instance)->finalSuspendStmt];
                        else __result0 = global::CppSharp.Parser.AST.Stmt.__CreateInstance(((global::CppSharp.Parser.AST.CoroutineBodyStmt.__Internal*) __Instance)->finalSuspendStmt);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CoroutineBodyStmt.__Internal*)__Instance)->finalSuspendStmt = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Stmt ExceptionHandler
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Stmt __result0;
                        if (((global::CppSharp.Parser.AST.CoroutineBodyStmt.__Internal*) __Instance)->exceptionHandler == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Stmt.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.CoroutineBodyStmt.__Internal*) __Instance)->exceptionHandler))
                            __result0 = (global::CppSharp.Parser.AST.Stmt) global::CppSharp.Parser.AST.Stmt.NativeToManagedMap[((global::CppSharp.Parser.AST.CoroutineBodyStmt.__Internal*) __Instance)->exceptionHandler];
                        else __result0 = global::CppSharp.Parser.AST.Stmt.__CreateInstance(((global::CppSharp.Parser.AST.CoroutineBodyStmt.__Internal*) __Instance)->exceptionHandler);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CoroutineBodyStmt.__Internal*)__Instance)->exceptionHandler = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Stmt FallthroughHandler
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Stmt __result0;
                        if (((global::CppSharp.Parser.AST.CoroutineBodyStmt.__Internal*) __Instance)->fallthroughHandler == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Stmt.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.CoroutineBodyStmt.__Internal*) __Instance)->fallthroughHandler))
                            __result0 = (global::CppSharp.Parser.AST.Stmt) global::CppSharp.Parser.AST.Stmt.NativeToManagedMap[((global::CppSharp.Parser.AST.CoroutineBodyStmt.__Internal*) __Instance)->fallthroughHandler];
                        else __result0 = global::CppSharp.Parser.AST.Stmt.__CreateInstance(((global::CppSharp.Parser.AST.CoroutineBodyStmt.__Internal*) __Instance)->fallthroughHandler);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CoroutineBodyStmt.__Internal*)__Instance)->fallthroughHandler = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Expr Allocate
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.CoroutineBodyStmt.__Internal*) __Instance)->allocate == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.CoroutineBodyStmt.__Internal*) __Instance)->allocate))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.CoroutineBodyStmt.__Internal*) __Instance)->allocate];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.CoroutineBodyStmt.__Internal*) __Instance)->allocate);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CoroutineBodyStmt.__Internal*)__Instance)->allocate = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Expr Deallocate
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.CoroutineBodyStmt.__Internal*) __Instance)->deallocate == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.CoroutineBodyStmt.__Internal*) __Instance)->deallocate))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.CoroutineBodyStmt.__Internal*) __Instance)->deallocate];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.CoroutineBodyStmt.__Internal*) __Instance)->deallocate);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CoroutineBodyStmt.__Internal*)__Instance)->deallocate = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Expr ReturnValueInit
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.CoroutineBodyStmt.__Internal*) __Instance)->returnValueInit == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.CoroutineBodyStmt.__Internal*) __Instance)->returnValueInit))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.CoroutineBodyStmt.__Internal*) __Instance)->returnValueInit];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.CoroutineBodyStmt.__Internal*) __Instance)->returnValueInit);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CoroutineBodyStmt.__Internal*)__Instance)->returnValueInit = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Stmt ResultDecl
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Stmt __result0;
                        if (((global::CppSharp.Parser.AST.CoroutineBodyStmt.__Internal*) __Instance)->resultDecl == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Stmt.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.CoroutineBodyStmt.__Internal*) __Instance)->resultDecl))
                            __result0 = (global::CppSharp.Parser.AST.Stmt) global::CppSharp.Parser.AST.Stmt.NativeToManagedMap[((global::CppSharp.Parser.AST.CoroutineBodyStmt.__Internal*) __Instance)->resultDecl];
                        else __result0 = global::CppSharp.Parser.AST.Stmt.__CreateInstance(((global::CppSharp.Parser.AST.CoroutineBodyStmt.__Internal*) __Instance)->resultDecl);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CoroutineBodyStmt.__Internal*)__Instance)->resultDecl = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Stmt ReturnStmt
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Stmt __result0;
                        if (((global::CppSharp.Parser.AST.CoroutineBodyStmt.__Internal*) __Instance)->returnStmt == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Stmt.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.CoroutineBodyStmt.__Internal*) __Instance)->returnStmt))
                            __result0 = (global::CppSharp.Parser.AST.Stmt) global::CppSharp.Parser.AST.Stmt.NativeToManagedMap[((global::CppSharp.Parser.AST.CoroutineBodyStmt.__Internal*) __Instance)->returnStmt];
                        else __result0 = global::CppSharp.Parser.AST.Stmt.__CreateInstance(((global::CppSharp.Parser.AST.CoroutineBodyStmt.__Internal*) __Instance)->returnStmt);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CoroutineBodyStmt.__Internal*)__Instance)->returnStmt = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Stmt ReturnStmtOnAllocFailure
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Stmt __result0;
                        if (((global::CppSharp.Parser.AST.CoroutineBodyStmt.__Internal*) __Instance)->returnStmtOnAllocFailure == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Stmt.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.CoroutineBodyStmt.__Internal*) __Instance)->returnStmtOnAllocFailure))
                            __result0 = (global::CppSharp.Parser.AST.Stmt) global::CppSharp.Parser.AST.Stmt.NativeToManagedMap[((global::CppSharp.Parser.AST.CoroutineBodyStmt.__Internal*) __Instance)->returnStmtOnAllocFailure];
                        else __result0 = global::CppSharp.Parser.AST.Stmt.__CreateInstance(((global::CppSharp.Parser.AST.CoroutineBodyStmt.__Internal*) __Instance)->returnStmtOnAllocFailure);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CoroutineBodyStmt.__Internal*)__Instance)->returnStmtOnAllocFailure = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }
            }

            public unsafe partial class CoreturnStmt : global::CppSharp.Parser.AST.Stmt, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 36)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal byte isImplicit;

                    [FieldOffset(24)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal keywordLoc;

                    [FieldOffset(28)]
                    internal global::System.IntPtr operand;

                    [FieldOffset(32)]
                    internal global::System.IntPtr promiseCall;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CoreturnStmt@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CoreturnStmt@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                public enum SubStmt
                {
                    Operand = 0,
                    PromiseCall = 1,
                    Count = 2
                }

                internal static new global::CppSharp.Parser.AST.CoreturnStmt __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CoreturnStmt(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.CoreturnStmt __CreateInstance(global::CppSharp.Parser.AST.CoreturnStmt.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CoreturnStmt(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.CoreturnStmt.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CoreturnStmt.__Internal));
                    *(global::CppSharp.Parser.AST.CoreturnStmt.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private CoreturnStmt(global::CppSharp.Parser.AST.CoreturnStmt.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected CoreturnStmt(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public CoreturnStmt()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CoreturnStmt.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public CoreturnStmt(global::CppSharp.Parser.AST.CoreturnStmt _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CoreturnStmt.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.CoreturnStmt.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.CoreturnStmt.__Internal*) _0.__Instance);
                }

                public bool IsImplicit
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.CoreturnStmt.__Internal*) __Instance)->isImplicit != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CoreturnStmt.__Internal*)__Instance)->isImplicit = (byte) (value ? 1 : 0);
                    }
                }

                public global::CppSharp.Parser.SourceLocation KeywordLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.CoreturnStmt.__Internal*) __Instance)->keywordLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CoreturnStmt.__Internal*)__Instance)->keywordLoc = value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Expr Operand
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.CoreturnStmt.__Internal*) __Instance)->operand == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.CoreturnStmt.__Internal*) __Instance)->operand))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.CoreturnStmt.__Internal*) __Instance)->operand];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.CoreturnStmt.__Internal*) __Instance)->operand);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CoreturnStmt.__Internal*)__Instance)->operand = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Expr PromiseCall
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.CoreturnStmt.__Internal*) __Instance)->promiseCall == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.CoreturnStmt.__Internal*) __Instance)->promiseCall))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.CoreturnStmt.__Internal*) __Instance)->promiseCall];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.CoreturnStmt.__Internal*) __Instance)->promiseCall);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CoreturnStmt.__Internal*)__Instance)->promiseCall = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }
            }
        }
    }
}

namespace CppSharp
{
    namespace Parser
    {
        namespace AST
        {
            public enum CastKind
            {
                Dependent = 0,
                BitCast = 1,
                LValueBitCast = 2,
                LValueToRValue = 3,
                NoOp = 4,
                BaseToDerived = 5,
                DerivedToBase = 6,
                UncheckedDerivedToBase = 7,
                Dynamic = 8,
                ToUnion = 9,
                ArrayToPointerDecay = 10,
                FunctionToPointerDecay = 11,
                NullToPointer = 12,
                NullToMemberPointer = 13,
                BaseToDerivedMemberPointer = 14,
                DerivedToBaseMemberPointer = 15,
                MemberPointerToBoolean = 16,
                ReinterpretMemberPointer = 17,
                UserDefinedConversion = 18,
                ConstructorConversion = 19,
                IntegralToPointer = 20,
                PointerToIntegral = 21,
                PointerToBoolean = 22,
                ToVoid = 23,
                VectorSplat = 24,
                IntegralCast = 25,
                IntegralToBoolean = 26,
                IntegralToFloating = 27,
                FixedPointCast = 28,
                FixedPointToBoolean = 29,
                FloatingToIntegral = 30,
                FloatingToBoolean = 31,
                BooleanToSignedIntegral = 32,
                FloatingCast = 33,
                CPointerToObjCPointerCast = 34,
                BlockPointerToObjCPointerCast = 35,
                AnyPointerToBlockPointerCast = 36,
                ObjCObjectLValueCast = 37,
                FloatingRealToComplex = 38,
                FloatingComplexToReal = 39,
                FloatingComplexToBoolean = 40,
                FloatingComplexCast = 41,
                FloatingComplexToIntegralComplex = 42,
                IntegralRealToComplex = 43,
                IntegralComplexToReal = 44,
                IntegralComplexToBoolean = 45,
                IntegralComplexCast = 46,
                IntegralComplexToFloatingComplex = 47,
                ARCProduceObject = 48,
                ARCConsumeObject = 49,
                ARCReclaimReturnedObject = 50,
                ARCExtendBlockObject = 51,
                AtomicToNonAtomic = 52,
                NonAtomicToAtomic = 53,
                CopyAndAutoreleaseBlockObject = 54,
                BuiltinFnToFnPtr = 55,
                ZeroToOCLOpaqueType = 56,
                AddressSpaceConversion = 57,
                IntToOCLSampler = 58
            }

            public enum BinaryOperatorKind
            {
                PtrMemD = 0,
                PtrMemI = 1,
                Mul = 2,
                Div = 3,
                Rem = 4,
                Add = 5,
                Sub = 6,
                Shl = 7,
                Shr = 8,
                Cmp = 9,
                LT = 10,
                GT = 11,
                LE = 12,
                GE = 13,
                EQ = 14,
                NE = 15,
                And = 16,
                Xor = 17,
                Or = 18,
                LAnd = 19,
                LOr = 20,
                Assign = 21,
                MulAssign = 22,
                DivAssign = 23,
                RemAssign = 24,
                AddAssign = 25,
                SubAssign = 26,
                ShlAssign = 27,
                ShrAssign = 28,
                AndAssign = 29,
                XorAssign = 30,
                OrAssign = 31,
                Comma = 32
            }

            public enum UnaryOperatorKind
            {
                PostInc = 0,
                PostDec = 1,
                PreInc = 2,
                PreDec = 3,
                AddrOf = 4,
                Deref = 5,
                Plus = 6,
                Minus = 7,
                Not = 8,
                LNot = 9,
                Real = 10,
                Imag = 11,
                Extension = 12,
                Coawait = 13
            }

            public enum ObjCBridgeCastKind
            {
                Bridge = 0,
                BridgeTransfer = 1,
                BridgeRetained = 2
            }

            public enum OverloadedOperatorKind
            {
                None = 0,
                New = 1,
                Delete = 2,
                ArrayNew = 3,
                ArrayDelete = 4,
                Plus = 5,
                Minus = 6,
                Star = 7,
                Slash = 8,
                Percent = 9,
                Caret = 10,
                Amp = 11,
                Pipe = 12,
                Tilde = 13,
                Exclaim = 14,
                Equal = 15,
                Less = 16,
                Greater = 17,
                PlusEqual = 18,
                MinusEqual = 19,
                StarEqual = 20,
                SlashEqual = 21,
                PercentEqual = 22,
                CaretEqual = 23,
                AmpEqual = 24,
                PipeEqual = 25,
                LessLess = 26,
                GreaterGreater = 27,
                LessLessEqual = 28,
                GreaterGreaterEqual = 29,
                EqualEqual = 30,
                ExclaimEqual = 31,
                LessEqual = 32,
                GreaterEqual = 33,
                Spaceship = 34,
                AmpAmp = 35,
                PipePipe = 36,
                PlusPlus = 37,
                MinusMinus = 38,
                Comma = 39,
                ArrowStar = 40,
                Arrow = 41,
                Call = 42,
                Subscript = 43,
                Conditional = 44,
                Coawait = 45
            }

            public enum UnaryExprOrTypeTrait
            {
                SizeOf = 0,
                AlignOf = 1,
                VecStep = 2,
                OpenMPRequiredSimdAlign = 3,
                PreferredAlignOf = 4
            }

            public unsafe partial class Expr : global::CppSharp.Parser.AST.Stmt, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 56)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0Expr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0Expr@AST@CppParser@CppSharp@@QAE@W4StmtClass@123@@Z")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance, global::CppSharp.Parser.AST.StmtClass klass);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0Expr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                public enum LValueClassification
                {
                    Valid = 0,
                    NotObjectType = 1,
                    IncompleteVoidType = 2,
                    DuplicateVectorComponents = 3,
                    InvalidExpression = 4,
                    InvalidMessageExpression = 5,
                    MemberFunction = 6,
                    SubObjCPropertySetting = 7,
                    ClassTemporary = 8,
                    ArrayTemporary = 9
                }

                public enum IsModifiableLvalueResult
                {
                    Valid = 0,
                    NotObjectType = 1,
                    IncompleteVoidType = 2,
                    DuplicateVectorComponents = 3,
                    InvalidExpression = 4,
                    LValueCast = 5,
                    IncompleteType = 6,
                    ConstQualified = 7,
                    ConstQualifiedField = 8,
                    ConstAddrSpace = 9,
                    ArrayType = 10,
                    NoSetterProperty = 11,
                    MemberFunction = 12,
                    SubObjCPropertySetting = 13,
                    InvalidMessageExpression = 14,
                    ClassTemporary = 15,
                    ArrayTemporary = 16
                }

                public enum SideEffectsKind
                {
                    NoSideEffects = 0,
                    AllowUndefinedBehavior = 1,
                    AllowSideEffects = 2
                }

                public enum ConstExprUsage
                {
                    EvaluateForCodeGen = 0,
                    EvaluateForMangling = 1
                }

                public enum NullPointerConstantKind
                {
                    NotNull = 0,
                    ZeroExpression = 1,
                    ZeroLiteral = 2,
                    CXX11_nullptr = 3,
                    GNUNull = 4
                }

                public enum NullPointerConstantValueDependence
                {
                    NeverValueDependent = 0,
                    ValueDependentIsNull = 1,
                    ValueDependentIsNotNull = 2
                }

                public unsafe partial class Classification : IDisposable
                {
                    [StructLayout(LayoutKind.Explicit, Size = 16)]
                    public partial struct __Internal
                    {
                        [FieldOffset(0)]
                        internal global::CppSharp.Parser.AST.Expr.Classification.Kinds kind;

                        [FieldOffset(4)]
                        internal global::CppSharp.Parser.AST.Expr.Classification.ModifiableType modifiable;

                        [FieldOffset(8)]
                        internal byte isLValue;

                        [FieldOffset(9)]
                        internal byte isXValue;

                        [FieldOffset(10)]
                        internal byte isGLValue;

                        [FieldOffset(11)]
                        internal byte isPRValue;

                        [FieldOffset(12)]
                        internal byte isRValue;

                        [FieldOffset(13)]
                        internal byte isModifiable;

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                            EntryPoint="??0Classification@Expr@AST@CppParser@CppSharp@@QAE@XZ")]
                        internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                            EntryPoint="??0Classification@Expr@AST@CppParser@CppSharp@@QAE@ABV01234@@Z")]
                        internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                    }

                    public enum Kinds
                    {
                        LValue = 0,
                        XValue = 1,
                        Function = 2,
                        Void = 3,
                        AddressableVoid = 4,
                        DuplicateVectorComponents = 5,
                        MemberFunction = 6,
                        SubObjCPropertySetting = 7,
                        ClassTemporary = 8,
                        ArrayTemporary = 9,
                        ObjCMessageRValue = 10,
                        PRValue = 11
                    }

                    public enum ModifiableType
                    {
                        Untested = 0,
                        Modifiable = 1,
                        RValue = 2,
                        Function = 3,
                        LValueCast = 4,
                        NoSetterProperty = 5,
                        ConstQualified = 6,
                        ConstQualifiedField = 7,
                        ConstAddrSpace = 8,
                        ArrayType = 9,
                        IncompleteType = 10
                    }

                    public global::System.IntPtr __Instance { get; protected set; }

                    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.Expr.Classification> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.Expr.Classification>();
                    protected internal void*[] __OriginalVTables;

                    protected bool __ownsNativeInstance;

                    internal static global::CppSharp.Parser.AST.Expr.Classification __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                    {
                        return new global::CppSharp.Parser.AST.Expr.Classification(native.ToPointer(), skipVTables);
                    }

                    internal static global::CppSharp.Parser.AST.Expr.Classification __CreateInstance(global::CppSharp.Parser.AST.Expr.Classification.__Internal native, bool skipVTables = false)
                    {
                        return new global::CppSharp.Parser.AST.Expr.Classification(native, skipVTables);
                    }

                    private static void* __CopyValue(global::CppSharp.Parser.AST.Expr.Classification.__Internal native)
                    {
                        var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Expr.Classification.__Internal));
                        *(global::CppSharp.Parser.AST.Expr.Classification.__Internal*) ret = native;
                        return ret.ToPointer();
                    }

                    private Classification(global::CppSharp.Parser.AST.Expr.Classification.__Internal native, bool skipVTables = false)
                        : this(__CopyValue(native), skipVTables)
                    {
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                    }

                    protected Classification(void* native, bool skipVTables = false)
                    {
                        if (native == null)
                            return;
                        __Instance = new global::System.IntPtr(native);
                    }

                    public Classification()
                    {
                        __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Expr.Classification.__Internal));
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                        __Internal.ctor(__Instance);
                    }

                    public Classification(global::CppSharp.Parser.AST.Expr.Classification _0)
                    {
                        __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Expr.Classification.__Internal));
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                        *((global::CppSharp.Parser.AST.Expr.Classification.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.Expr.Classification.__Internal*) _0.__Instance);
                    }

                    public void Dispose()
                    {
                        Dispose(disposing: true);
                    }

                    public virtual void Dispose(bool disposing)
                    {
                        if (__Instance == IntPtr.Zero)
                            return;
                        global::CppSharp.Parser.AST.Expr.Classification __dummy;
                        NativeToManagedMap.TryRemove(__Instance, out __dummy);
                        if (__ownsNativeInstance)
                            Marshal.FreeHGlobal(__Instance);
                        __Instance = IntPtr.Zero;
                    }

                    public global::CppSharp.Parser.AST.Expr.Classification.Kinds Kind
                    {
                        get
                        {
                            return ((global::CppSharp.Parser.AST.Expr.Classification.__Internal*) __Instance)->kind;
                        }

                        set
                        {
                            ((global::CppSharp.Parser.AST.Expr.Classification.__Internal*)__Instance)->kind = value;
                        }
                    }

                    public global::CppSharp.Parser.AST.Expr.Classification.ModifiableType Modifiable
                    {
                        get
                        {
                            return ((global::CppSharp.Parser.AST.Expr.Classification.__Internal*) __Instance)->modifiable;
                        }

                        set
                        {
                            ((global::CppSharp.Parser.AST.Expr.Classification.__Internal*)__Instance)->modifiable = value;
                        }
                    }

                    public bool IsLValue
                    {
                        get
                        {
                            return ((global::CppSharp.Parser.AST.Expr.Classification.__Internal*) __Instance)->isLValue != 0;
                        }

                        set
                        {
                            ((global::CppSharp.Parser.AST.Expr.Classification.__Internal*)__Instance)->isLValue = (byte) (value ? 1 : 0);
                        }
                    }

                    public bool IsXValue
                    {
                        get
                        {
                            return ((global::CppSharp.Parser.AST.Expr.Classification.__Internal*) __Instance)->isXValue != 0;
                        }

                        set
                        {
                            ((global::CppSharp.Parser.AST.Expr.Classification.__Internal*)__Instance)->isXValue = (byte) (value ? 1 : 0);
                        }
                    }

                    public bool IsGLValue
                    {
                        get
                        {
                            return ((global::CppSharp.Parser.AST.Expr.Classification.__Internal*) __Instance)->isGLValue != 0;
                        }

                        set
                        {
                            ((global::CppSharp.Parser.AST.Expr.Classification.__Internal*)__Instance)->isGLValue = (byte) (value ? 1 : 0);
                        }
                    }

                    public bool IsPRValue
                    {
                        get
                        {
                            return ((global::CppSharp.Parser.AST.Expr.Classification.__Internal*) __Instance)->isPRValue != 0;
                        }

                        set
                        {
                            ((global::CppSharp.Parser.AST.Expr.Classification.__Internal*)__Instance)->isPRValue = (byte) (value ? 1 : 0);
                        }
                    }

                    public bool IsRValue
                    {
                        get
                        {
                            return ((global::CppSharp.Parser.AST.Expr.Classification.__Internal*) __Instance)->isRValue != 0;
                        }

                        set
                        {
                            ((global::CppSharp.Parser.AST.Expr.Classification.__Internal*)__Instance)->isRValue = (byte) (value ? 1 : 0);
                        }
                    }

                    public bool IsModifiable
                    {
                        get
                        {
                            return ((global::CppSharp.Parser.AST.Expr.Classification.__Internal*) __Instance)->isModifiable != 0;
                        }

                        set
                        {
                            ((global::CppSharp.Parser.AST.Expr.Classification.__Internal*)__Instance)->isModifiable = (byte) (value ? 1 : 0);
                        }
                    }
                }

                internal static new global::CppSharp.Parser.AST.Expr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.Expr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.Expr __CreateInstance(global::CppSharp.Parser.AST.Expr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.Expr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.Expr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Expr.__Internal));
                    *(global::CppSharp.Parser.AST.Expr.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private Expr(global::CppSharp.Parser.AST.Expr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected Expr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public Expr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Expr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public Expr(global::CppSharp.Parser.AST.StmtClass klass)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Expr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance, klass);
                }

                public Expr(global::CppSharp.Parser.AST.Expr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.Expr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.Expr.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.Expr.__Internal*) _0.__Instance);
                }

                public static implicit operator global::CppSharp.Parser.AST.Expr(global::CppSharp.Parser.AST.StmtClass klass)
                {
                    return new global::CppSharp.Parser.AST.Expr(klass);
                }

                public global::CppSharp.Parser.AST.QualifiedType Type
                {
                    get
                    {
                        return global::CppSharp.Parser.AST.QualifiedType.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.Expr.__Internal*) __Instance)->type));
                    }

                    set
                    {
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                        ((global::CppSharp.Parser.AST.Expr.__Internal*)__Instance)->type = *(global::CppSharp.Parser.AST.QualifiedType.__Internal*) value.__Instance;
                    }
                }

                public bool ValueDependent
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Expr.__Internal*) __Instance)->valueDependent != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Expr.__Internal*)__Instance)->valueDependent = (byte) (value ? 1 : 0);
                    }
                }

                public bool TypeDependent
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Expr.__Internal*) __Instance)->typeDependent != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Expr.__Internal*)__Instance)->typeDependent = (byte) (value ? 1 : 0);
                    }
                }

                public bool InstantiationDependent
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Expr.__Internal*) __Instance)->instantiationDependent != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Expr.__Internal*)__Instance)->instantiationDependent = (byte) (value ? 1 : 0);
                    }
                }

                public bool ContainsUnexpandedParameterPack
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Expr.__Internal*) __Instance)->containsUnexpandedParameterPack != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Expr.__Internal*)__Instance)->containsUnexpandedParameterPack = (byte) (value ? 1 : 0);
                    }
                }

                public global::CppSharp.Parser.SourceLocation ExprLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.Expr.__Internal*) __Instance)->exprLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Expr.__Internal*)__Instance)->exprLoc = value.__Instance;
                    }
                }

                public bool IsLValue
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Expr.__Internal*) __Instance)->isLValue != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Expr.__Internal*)__Instance)->isLValue = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsRValue
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Expr.__Internal*) __Instance)->isRValue != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Expr.__Internal*)__Instance)->isRValue = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsXValue
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Expr.__Internal*) __Instance)->isXValue != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Expr.__Internal*)__Instance)->isXValue = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsGLValue
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Expr.__Internal*) __Instance)->isGLValue != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Expr.__Internal*)__Instance)->isGLValue = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsOrdinaryOrBitFieldObject
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Expr.__Internal*) __Instance)->isOrdinaryOrBitFieldObject != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Expr.__Internal*)__Instance)->isOrdinaryOrBitFieldObject = (byte) (value ? 1 : 0);
                    }
                }

                public global::CppSharp.Parser.AST.Field SourceBitField
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Field __result0;
                        if (((global::CppSharp.Parser.AST.Expr.__Internal*) __Instance)->sourceBitField == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Field.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.Expr.__Internal*) __Instance)->sourceBitField))
                            __result0 = (global::CppSharp.Parser.AST.Field) global::CppSharp.Parser.AST.Field.NativeToManagedMap[((global::CppSharp.Parser.AST.Expr.__Internal*) __Instance)->sourceBitField];
                        else __result0 = global::CppSharp.Parser.AST.Field.__CreateInstance(((global::CppSharp.Parser.AST.Expr.__Internal*) __Instance)->sourceBitField);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Expr.__Internal*)__Instance)->sourceBitField = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Declaration ReferencedDeclOfCallee
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Declaration __result0;
                        if (((global::CppSharp.Parser.AST.Expr.__Internal*) __Instance)->referencedDeclOfCallee == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Declaration.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.Expr.__Internal*) __Instance)->referencedDeclOfCallee))
                            __result0 = (global::CppSharp.Parser.AST.Declaration) global::CppSharp.Parser.AST.Declaration.NativeToManagedMap[((global::CppSharp.Parser.AST.Expr.__Internal*) __Instance)->referencedDeclOfCallee];
                        else __result0 = global::CppSharp.Parser.AST.Declaration.__CreateInstance(((global::CppSharp.Parser.AST.Expr.__Internal*) __Instance)->referencedDeclOfCallee);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Expr.__Internal*)__Instance)->referencedDeclOfCallee = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public bool HasPlaceholderType
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.Expr.__Internal*) __Instance)->hasPlaceholderType != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.Expr.__Internal*)__Instance)->hasPlaceholderType = (byte) (value ? 1 : 0);
                    }
                }
            }

            public unsafe partial class FullExpr : global::CppSharp.Parser.AST.Expr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 60)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal global::System.IntPtr subExpr;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0FullExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0FullExpr@AST@CppParser@CppSharp@@QAE@W4StmtClass@123@@Z")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance, global::CppSharp.Parser.AST.StmtClass klass);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0FullExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.FullExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.FullExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.FullExpr __CreateInstance(global::CppSharp.Parser.AST.FullExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.FullExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.FullExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.FullExpr.__Internal));
                    *(global::CppSharp.Parser.AST.FullExpr.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private FullExpr(global::CppSharp.Parser.AST.FullExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected FullExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public FullExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.FullExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public FullExpr(global::CppSharp.Parser.AST.StmtClass klass)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.FullExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance, klass);
                }

                public FullExpr(global::CppSharp.Parser.AST.FullExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.FullExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.FullExpr.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.FullExpr.__Internal*) _0.__Instance);
                }

                public static implicit operator global::CppSharp.Parser.AST.FullExpr(global::CppSharp.Parser.AST.StmtClass klass)
                {
                    return new global::CppSharp.Parser.AST.FullExpr(klass);
                }

                public global::CppSharp.Parser.AST.Expr SubExpr
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.FullExpr.__Internal*) __Instance)->subExpr == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.FullExpr.__Internal*) __Instance)->subExpr))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.FullExpr.__Internal*) __Instance)->subExpr];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.FullExpr.__Internal*) __Instance)->subExpr);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.FullExpr.__Internal*)__Instance)->subExpr = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }
            }

            public unsafe partial class ConstantExpr : global::CppSharp.Parser.AST.FullExpr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 60)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal global::System.IntPtr subExpr;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0ConstantExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0ConstantExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.ConstantExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.ConstantExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.ConstantExpr __CreateInstance(global::CppSharp.Parser.AST.ConstantExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.ConstantExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.ConstantExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ConstantExpr.__Internal));
                    *(global::CppSharp.Parser.AST.ConstantExpr.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private ConstantExpr(global::CppSharp.Parser.AST.ConstantExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected ConstantExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public ConstantExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ConstantExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public ConstantExpr(global::CppSharp.Parser.AST.ConstantExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ConstantExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.ConstantExpr.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.ConstantExpr.__Internal*) _0.__Instance);
                }
            }

            public unsafe partial class OpaqueValueExpr : global::CppSharp.Parser.AST.Expr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 68)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal byte isUnique;

                    [FieldOffset(60)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal location;

                    [FieldOffset(64)]
                    internal global::System.IntPtr sourceExpr;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0OpaqueValueExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0OpaqueValueExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.OpaqueValueExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.OpaqueValueExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.OpaqueValueExpr __CreateInstance(global::CppSharp.Parser.AST.OpaqueValueExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.OpaqueValueExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.OpaqueValueExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.OpaqueValueExpr.__Internal));
                    *(global::CppSharp.Parser.AST.OpaqueValueExpr.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private OpaqueValueExpr(global::CppSharp.Parser.AST.OpaqueValueExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected OpaqueValueExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public OpaqueValueExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.OpaqueValueExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public OpaqueValueExpr(global::CppSharp.Parser.AST.OpaqueValueExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.OpaqueValueExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.OpaqueValueExpr.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.OpaqueValueExpr.__Internal*) _0.__Instance);
                }

                public bool IsUnique
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.OpaqueValueExpr.__Internal*) __Instance)->isUnique != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.OpaqueValueExpr.__Internal*)__Instance)->isUnique = (byte) (value ? 1 : 0);
                    }
                }

                public global::CppSharp.Parser.SourceLocation Location
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.OpaqueValueExpr.__Internal*) __Instance)->location);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.OpaqueValueExpr.__Internal*)__Instance)->location = value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Expr SourceExpr
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.OpaqueValueExpr.__Internal*) __Instance)->sourceExpr == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.OpaqueValueExpr.__Internal*) __Instance)->sourceExpr))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.OpaqueValueExpr.__Internal*) __Instance)->sourceExpr];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.OpaqueValueExpr.__Internal*) __Instance)->sourceExpr);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.OpaqueValueExpr.__Internal*)__Instance)->sourceExpr = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }
            }

            public unsafe partial class DeclRefExpr : global::CppSharp.Parser.AST.Expr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 96)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal location;

                    [FieldOffset(60)]
                    internal byte hadMultipleCandidates;

                    [FieldOffset(61)]
                    internal byte hasQualifier;

                    [FieldOffset(64)]
                    internal global::System.IntPtr foundDecl;

                    [FieldOffset(68)]
                    internal byte hasTemplateKWAndArgsInfo;

                    [FieldOffset(72)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal templateKeywordLoc;

                    [FieldOffset(76)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal lAngleLoc;

                    [FieldOffset(80)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal rAngleLoc;

                    [FieldOffset(84)]
                    internal byte hasTemplateKeyword;

                    [FieldOffset(85)]
                    internal byte hasExplicitTemplateArgs;

                    [FieldOffset(88)]
                    internal uint numTemplateArgs;

                    [FieldOffset(92)]
                    internal byte refersToEnclosingVariableOrCapture;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0DeclRefExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0DeclRefExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.DeclRefExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.DeclRefExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.DeclRefExpr __CreateInstance(global::CppSharp.Parser.AST.DeclRefExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.DeclRefExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.DeclRefExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.DeclRefExpr.__Internal));
                    *(global::CppSharp.Parser.AST.DeclRefExpr.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private DeclRefExpr(global::CppSharp.Parser.AST.DeclRefExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected DeclRefExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public DeclRefExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.DeclRefExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public DeclRefExpr(global::CppSharp.Parser.AST.DeclRefExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.DeclRefExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.DeclRefExpr.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.DeclRefExpr.__Internal*) _0.__Instance);
                }

                public global::CppSharp.Parser.SourceLocation Location
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.DeclRefExpr.__Internal*) __Instance)->location);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.DeclRefExpr.__Internal*)__Instance)->location = value.__Instance;
                    }
                }

                public bool HadMultipleCandidates
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.DeclRefExpr.__Internal*) __Instance)->hadMultipleCandidates != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.DeclRefExpr.__Internal*)__Instance)->hadMultipleCandidates = (byte) (value ? 1 : 0);
                    }
                }

                public bool HasQualifier
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.DeclRefExpr.__Internal*) __Instance)->hasQualifier != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.DeclRefExpr.__Internal*)__Instance)->hasQualifier = (byte) (value ? 1 : 0);
                    }
                }

                public global::CppSharp.Parser.AST.Declaration FoundDecl
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Declaration __result0;
                        if (((global::CppSharp.Parser.AST.DeclRefExpr.__Internal*) __Instance)->foundDecl == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Declaration.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.DeclRefExpr.__Internal*) __Instance)->foundDecl))
                            __result0 = (global::CppSharp.Parser.AST.Declaration) global::CppSharp.Parser.AST.Declaration.NativeToManagedMap[((global::CppSharp.Parser.AST.DeclRefExpr.__Internal*) __Instance)->foundDecl];
                        else __result0 = global::CppSharp.Parser.AST.Declaration.__CreateInstance(((global::CppSharp.Parser.AST.DeclRefExpr.__Internal*) __Instance)->foundDecl);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.DeclRefExpr.__Internal*)__Instance)->foundDecl = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public bool HasTemplateKWAndArgsInfo
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.DeclRefExpr.__Internal*) __Instance)->hasTemplateKWAndArgsInfo != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.DeclRefExpr.__Internal*)__Instance)->hasTemplateKWAndArgsInfo = (byte) (value ? 1 : 0);
                    }
                }

                public global::CppSharp.Parser.SourceLocation TemplateKeywordLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.DeclRefExpr.__Internal*) __Instance)->templateKeywordLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.DeclRefExpr.__Internal*)__Instance)->templateKeywordLoc = value.__Instance;
                    }
                }

                public global::CppSharp.Parser.SourceLocation LAngleLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.DeclRefExpr.__Internal*) __Instance)->lAngleLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.DeclRefExpr.__Internal*)__Instance)->lAngleLoc = value.__Instance;
                    }
                }

                public global::CppSharp.Parser.SourceLocation RAngleLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.DeclRefExpr.__Internal*) __Instance)->rAngleLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.DeclRefExpr.__Internal*)__Instance)->rAngleLoc = value.__Instance;
                    }
                }

                public bool HasTemplateKeyword
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.DeclRefExpr.__Internal*) __Instance)->hasTemplateKeyword != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.DeclRefExpr.__Internal*)__Instance)->hasTemplateKeyword = (byte) (value ? 1 : 0);
                    }
                }

                public bool HasExplicitTemplateArgs
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.DeclRefExpr.__Internal*) __Instance)->hasExplicitTemplateArgs != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.DeclRefExpr.__Internal*)__Instance)->hasExplicitTemplateArgs = (byte) (value ? 1 : 0);
                    }
                }

                public uint NumTemplateArgs
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.DeclRefExpr.__Internal*) __Instance)->numTemplateArgs;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.DeclRefExpr.__Internal*)__Instance)->numTemplateArgs = value;
                    }
                }

                public bool RefersToEnclosingVariableOrCapture
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.DeclRefExpr.__Internal*) __Instance)->refersToEnclosingVariableOrCapture != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.DeclRefExpr.__Internal*)__Instance)->refersToEnclosingVariableOrCapture = (byte) (value ? 1 : 0);
                    }
                }
            }

            public unsafe partial class IntegerLiteral : global::CppSharp.Parser.AST.Expr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 72)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal location;

                    [FieldOffset(64)]
                    internal ulong value;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0IntegerLiteral@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0IntegerLiteral@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.IntegerLiteral __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.IntegerLiteral(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.IntegerLiteral __CreateInstance(global::CppSharp.Parser.AST.IntegerLiteral.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.IntegerLiteral(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.IntegerLiteral.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.IntegerLiteral.__Internal));
                    *(global::CppSharp.Parser.AST.IntegerLiteral.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private IntegerLiteral(global::CppSharp.Parser.AST.IntegerLiteral.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected IntegerLiteral(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public IntegerLiteral()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.IntegerLiteral.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public IntegerLiteral(global::CppSharp.Parser.AST.IntegerLiteral _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.IntegerLiteral.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.IntegerLiteral.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.IntegerLiteral.__Internal*) _0.__Instance);
                }

                public global::CppSharp.Parser.SourceLocation Location
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.IntegerLiteral.__Internal*) __Instance)->location);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.IntegerLiteral.__Internal*)__Instance)->location = value.__Instance;
                    }
                }

                public ulong Value
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.IntegerLiteral.__Internal*) __Instance)->value;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.IntegerLiteral.__Internal*)__Instance)->value = value;
                    }
                }
            }

            public unsafe partial class FixedPointLiteral : global::CppSharp.Parser.AST.Expr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 72)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal location;

                    [FieldOffset(64)]
                    internal ulong value;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0FixedPointLiteral@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0FixedPointLiteral@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.FixedPointLiteral __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.FixedPointLiteral(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.FixedPointLiteral __CreateInstance(global::CppSharp.Parser.AST.FixedPointLiteral.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.FixedPointLiteral(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.FixedPointLiteral.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.FixedPointLiteral.__Internal));
                    *(global::CppSharp.Parser.AST.FixedPointLiteral.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private FixedPointLiteral(global::CppSharp.Parser.AST.FixedPointLiteral.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected FixedPointLiteral(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public FixedPointLiteral()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.FixedPointLiteral.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public FixedPointLiteral(global::CppSharp.Parser.AST.FixedPointLiteral _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.FixedPointLiteral.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.FixedPointLiteral.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.FixedPointLiteral.__Internal*) _0.__Instance);
                }

                public global::CppSharp.Parser.SourceLocation Location
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.FixedPointLiteral.__Internal*) __Instance)->location);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.FixedPointLiteral.__Internal*)__Instance)->location = value.__Instance;
                    }
                }

                public ulong Value
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.FixedPointLiteral.__Internal*) __Instance)->value;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.FixedPointLiteral.__Internal*)__Instance)->value = value;
                    }
                }
            }

            public unsafe partial class CharacterLiteral : global::CppSharp.Parser.AST.Expr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 68)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal location;

                    [FieldOffset(60)]
                    internal global::CppSharp.Parser.AST.CharacterLiteral.CharacterKind kind;

                    [FieldOffset(64)]
                    internal uint value;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CharacterLiteral@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CharacterLiteral@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                public enum CharacterKind
                {
                    Ascii = 0,
                    Wide = 1,
                    UTF8 = 2,
                    UTF16 = 3,
                    UTF32 = 4
                }

                internal static new global::CppSharp.Parser.AST.CharacterLiteral __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CharacterLiteral(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.CharacterLiteral __CreateInstance(global::CppSharp.Parser.AST.CharacterLiteral.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CharacterLiteral(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.CharacterLiteral.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CharacterLiteral.__Internal));
                    *(global::CppSharp.Parser.AST.CharacterLiteral.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private CharacterLiteral(global::CppSharp.Parser.AST.CharacterLiteral.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected CharacterLiteral(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public CharacterLiteral()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CharacterLiteral.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public CharacterLiteral(global::CppSharp.Parser.AST.CharacterLiteral _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CharacterLiteral.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.CharacterLiteral.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.CharacterLiteral.__Internal*) _0.__Instance);
                }

                public global::CppSharp.Parser.SourceLocation Location
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.CharacterLiteral.__Internal*) __Instance)->location);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CharacterLiteral.__Internal*)__Instance)->location = value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.CharacterLiteral.CharacterKind Kind
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.CharacterLiteral.__Internal*) __Instance)->kind;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CharacterLiteral.__Internal*)__Instance)->kind = value;
                    }
                }

                public uint Value
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.CharacterLiteral.__Internal*) __Instance)->value;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CharacterLiteral.__Internal*)__Instance)->value = value;
                    }
                }
            }

            public unsafe partial class FloatingLiteral : global::CppSharp.Parser.AST.Expr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 72)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal byte exact;

                    [FieldOffset(60)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal location;

                    [FieldOffset(64)]
                    internal double valueAsApproximateDouble;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0FloatingLiteral@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0FloatingLiteral@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.FloatingLiteral __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.FloatingLiteral(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.FloatingLiteral __CreateInstance(global::CppSharp.Parser.AST.FloatingLiteral.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.FloatingLiteral(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.FloatingLiteral.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.FloatingLiteral.__Internal));
                    *(global::CppSharp.Parser.AST.FloatingLiteral.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private FloatingLiteral(global::CppSharp.Parser.AST.FloatingLiteral.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected FloatingLiteral(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public FloatingLiteral()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.FloatingLiteral.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public FloatingLiteral(global::CppSharp.Parser.AST.FloatingLiteral _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.FloatingLiteral.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.FloatingLiteral.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.FloatingLiteral.__Internal*) _0.__Instance);
                }

                public bool Exact
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.FloatingLiteral.__Internal*) __Instance)->exact != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.FloatingLiteral.__Internal*)__Instance)->exact = (byte) (value ? 1 : 0);
                    }
                }

                public global::CppSharp.Parser.SourceLocation Location
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.FloatingLiteral.__Internal*) __Instance)->location);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.FloatingLiteral.__Internal*)__Instance)->location = value.__Instance;
                    }
                }

                public double ValueAsApproximateDouble
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.FloatingLiteral.__Internal*) __Instance)->valueAsApproximateDouble;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.FloatingLiteral.__Internal*)__Instance)->valueAsApproximateDouble = value;
                    }
                }
            }

            public unsafe partial class ImaginaryLiteral : global::CppSharp.Parser.AST.Expr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 60)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal global::System.IntPtr subExpr;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0ImaginaryLiteral@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0ImaginaryLiteral@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.ImaginaryLiteral __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.ImaginaryLiteral(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.ImaginaryLiteral __CreateInstance(global::CppSharp.Parser.AST.ImaginaryLiteral.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.ImaginaryLiteral(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.ImaginaryLiteral.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ImaginaryLiteral.__Internal));
                    *(global::CppSharp.Parser.AST.ImaginaryLiteral.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private ImaginaryLiteral(global::CppSharp.Parser.AST.ImaginaryLiteral.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected ImaginaryLiteral(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public ImaginaryLiteral()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ImaginaryLiteral.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public ImaginaryLiteral(global::CppSharp.Parser.AST.ImaginaryLiteral _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ImaginaryLiteral.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.ImaginaryLiteral.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.ImaginaryLiteral.__Internal*) _0.__Instance);
                }

                public global::CppSharp.Parser.AST.Expr SubExpr
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.ImaginaryLiteral.__Internal*) __Instance)->subExpr == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.ImaginaryLiteral.__Internal*) __Instance)->subExpr))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.ImaginaryLiteral.__Internal*) __Instance)->subExpr];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.ImaginaryLiteral.__Internal*) __Instance)->subExpr);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.ImaginaryLiteral.__Internal*)__Instance)->subExpr = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }
            }

            public unsafe partial class StringLiteral : global::CppSharp.Parser.AST.Expr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 132)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C @string;

                    [FieldOffset(80)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C bytes;

                    [FieldOffset(104)]
                    internal uint byteLength;

                    [FieldOffset(108)]
                    internal uint length;

                    [FieldOffset(112)]
                    internal uint charByteWidth;

                    [FieldOffset(116)]
                    internal global::CppSharp.Parser.AST.StringLiteral.StringKind kind;

                    [FieldOffset(120)]
                    internal byte isAscii;

                    [FieldOffset(121)]
                    internal byte isWide;

                    [FieldOffset(122)]
                    internal byte isUTF8;

                    [FieldOffset(123)]
                    internal byte isUTF16;

                    [FieldOffset(124)]
                    internal byte isUTF32;

                    [FieldOffset(125)]
                    internal byte isPascal;

                    [FieldOffset(126)]
                    internal byte containsNonAscii;

                    [FieldOffset(127)]
                    internal byte containsNonAsciiOrNull;

                    [FieldOffset(128)]
                    internal uint numConcatenated;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0StringLiteral@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0StringLiteral@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??1StringLiteral@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern void dtor(global::System.IntPtr __instance, int delete);
                }

                public enum StringKind
                {
                    Ascii = 0,
                    Wide = 1,
                    UTF8 = 2,
                    UTF16 = 3,
                    UTF32 = 4
                }

                internal static new global::CppSharp.Parser.AST.StringLiteral __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.StringLiteral(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.StringLiteral __CreateInstance(global::CppSharp.Parser.AST.StringLiteral.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.StringLiteral(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.StringLiteral.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.StringLiteral.__Internal));
                    global::CppSharp.Parser.AST.StringLiteral.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private StringLiteral(global::CppSharp.Parser.AST.StringLiteral.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected StringLiteral(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public StringLiteral()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.StringLiteral.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public StringLiteral(global::CppSharp.Parser.AST.StringLiteral _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.StringLiteral.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Stmt __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor(__Instance, 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public string String
                {
                    get
                    {
                        var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.StringLiteral.__Internal*) __Instance)->@string));
                        return global::Std.BasicStringExtensions.Data(__basicStringRet0);
                    }

                    set
                    {
                        global::Std.BasicStringExtensions.__Internal.Assign(new global::System.IntPtr(&((global::CppSharp.Parser.AST.StringLiteral.__Internal*)__Instance)->@string), value);
                    }
                }

                public string Bytes
                {
                    get
                    {
                        var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.StringLiteral.__Internal*) __Instance)->bytes));
                        return global::Std.BasicStringExtensions.Data(__basicStringRet0);
                    }

                    set
                    {
                        global::Std.BasicStringExtensions.__Internal.Assign(new global::System.IntPtr(&((global::CppSharp.Parser.AST.StringLiteral.__Internal*)__Instance)->bytes), value);
                    }
                }

                public uint ByteLength
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.StringLiteral.__Internal*) __Instance)->byteLength;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.StringLiteral.__Internal*)__Instance)->byteLength = value;
                    }
                }

                public uint Length
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.StringLiteral.__Internal*) __Instance)->length;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.StringLiteral.__Internal*)__Instance)->length = value;
                    }
                }

                public uint CharByteWidth
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.StringLiteral.__Internal*) __Instance)->charByteWidth;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.StringLiteral.__Internal*)__Instance)->charByteWidth = value;
                    }
                }

                public global::CppSharp.Parser.AST.StringLiteral.StringKind Kind
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.StringLiteral.__Internal*) __Instance)->kind;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.StringLiteral.__Internal*)__Instance)->kind = value;
                    }
                }

                public bool IsAscii
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.StringLiteral.__Internal*) __Instance)->isAscii != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.StringLiteral.__Internal*)__Instance)->isAscii = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsWide
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.StringLiteral.__Internal*) __Instance)->isWide != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.StringLiteral.__Internal*)__Instance)->isWide = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsUTF8
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.StringLiteral.__Internal*) __Instance)->isUTF8 != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.StringLiteral.__Internal*)__Instance)->isUTF8 = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsUTF16
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.StringLiteral.__Internal*) __Instance)->isUTF16 != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.StringLiteral.__Internal*)__Instance)->isUTF16 = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsUTF32
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.StringLiteral.__Internal*) __Instance)->isUTF32 != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.StringLiteral.__Internal*)__Instance)->isUTF32 = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsPascal
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.StringLiteral.__Internal*) __Instance)->isPascal != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.StringLiteral.__Internal*)__Instance)->isPascal = (byte) (value ? 1 : 0);
                    }
                }

                public bool ContainsNonAscii
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.StringLiteral.__Internal*) __Instance)->containsNonAscii != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.StringLiteral.__Internal*)__Instance)->containsNonAscii = (byte) (value ? 1 : 0);
                    }
                }

                public bool ContainsNonAsciiOrNull
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.StringLiteral.__Internal*) __Instance)->containsNonAsciiOrNull != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.StringLiteral.__Internal*)__Instance)->containsNonAsciiOrNull = (byte) (value ? 1 : 0);
                    }
                }

                public uint NumConcatenated
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.StringLiteral.__Internal*) __Instance)->numConcatenated;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.StringLiteral.__Internal*)__Instance)->numConcatenated = value;
                    }
                }
            }

            public unsafe partial class PredefinedExpr : global::CppSharp.Parser.AST.Expr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 64)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal location;

                    [FieldOffset(60)]
                    internal global::CppSharp.Parser.AST.PredefinedExpr.IdentKind identKind;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0PredefinedExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0PredefinedExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                public enum IdentKind
                {
                    Func = 0,
                    Function = 1,
                    LFunction = 2,
                    FuncDName = 3,
                    FuncSig = 4,
                    LFuncSig = 5,
                    PrettyFunction = 6,
                    PrettyFunctionNoVirtual = 7
                }

                internal static new global::CppSharp.Parser.AST.PredefinedExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.PredefinedExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.PredefinedExpr __CreateInstance(global::CppSharp.Parser.AST.PredefinedExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.PredefinedExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.PredefinedExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.PredefinedExpr.__Internal));
                    *(global::CppSharp.Parser.AST.PredefinedExpr.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private PredefinedExpr(global::CppSharp.Parser.AST.PredefinedExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected PredefinedExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public PredefinedExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.PredefinedExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public PredefinedExpr(global::CppSharp.Parser.AST.PredefinedExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.PredefinedExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.PredefinedExpr.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.PredefinedExpr.__Internal*) _0.__Instance);
                }

                public global::CppSharp.Parser.SourceLocation Location
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.PredefinedExpr.__Internal*) __Instance)->location);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.PredefinedExpr.__Internal*)__Instance)->location = value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.PredefinedExpr.IdentKind identKind
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.PredefinedExpr.__Internal*) __Instance)->identKind;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.PredefinedExpr.__Internal*)__Instance)->identKind = value;
                    }
                }
            }

            public unsafe partial class ParenExpr : global::CppSharp.Parser.AST.Expr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 68)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal global::System.IntPtr subExpr;

                    [FieldOffset(60)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal lParen;

                    [FieldOffset(64)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal rParen;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0ParenExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0ParenExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.ParenExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.ParenExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.ParenExpr __CreateInstance(global::CppSharp.Parser.AST.ParenExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.ParenExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.ParenExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ParenExpr.__Internal));
                    *(global::CppSharp.Parser.AST.ParenExpr.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private ParenExpr(global::CppSharp.Parser.AST.ParenExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected ParenExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public ParenExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ParenExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public ParenExpr(global::CppSharp.Parser.AST.ParenExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ParenExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.ParenExpr.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.ParenExpr.__Internal*) _0.__Instance);
                }

                public global::CppSharp.Parser.AST.Expr SubExpr
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.ParenExpr.__Internal*) __Instance)->subExpr == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.ParenExpr.__Internal*) __Instance)->subExpr))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.ParenExpr.__Internal*) __Instance)->subExpr];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.ParenExpr.__Internal*) __Instance)->subExpr);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.ParenExpr.__Internal*)__Instance)->subExpr = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.SourceLocation LParen
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.ParenExpr.__Internal*) __Instance)->lParen);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.ParenExpr.__Internal*)__Instance)->lParen = value.__Instance;
                    }
                }

                public global::CppSharp.Parser.SourceLocation RParen
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.ParenExpr.__Internal*) __Instance)->rParen);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.ParenExpr.__Internal*)__Instance)->rParen = value.__Instance;
                    }
                }
            }

            public unsafe partial class UnaryOperator : global::CppSharp.Parser.AST.Expr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 76)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal global::CppSharp.Parser.AST.UnaryOperatorKind opcode;

                    [FieldOffset(60)]
                    internal global::System.IntPtr subExpr;

                    [FieldOffset(64)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal operatorLoc;

                    [FieldOffset(68)]
                    internal byte canOverflow;

                    [FieldOffset(69)]
                    internal byte isPrefix;

                    [FieldOffset(70)]
                    internal byte isPostfix;

                    [FieldOffset(71)]
                    internal byte isIncrementOp;

                    [FieldOffset(72)]
                    internal byte isDecrementOp;

                    [FieldOffset(73)]
                    internal byte isIncrementDecrementOp;

                    [FieldOffset(74)]
                    internal byte isArithmeticOp;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0UnaryOperator@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0UnaryOperator@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.UnaryOperator __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.UnaryOperator(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.UnaryOperator __CreateInstance(global::CppSharp.Parser.AST.UnaryOperator.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.UnaryOperator(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.UnaryOperator.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.UnaryOperator.__Internal));
                    *(global::CppSharp.Parser.AST.UnaryOperator.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private UnaryOperator(global::CppSharp.Parser.AST.UnaryOperator.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected UnaryOperator(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public UnaryOperator()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.UnaryOperator.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public UnaryOperator(global::CppSharp.Parser.AST.UnaryOperator _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.UnaryOperator.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.UnaryOperator.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.UnaryOperator.__Internal*) _0.__Instance);
                }

                public global::CppSharp.Parser.AST.UnaryOperatorKind Opcode
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.UnaryOperator.__Internal*) __Instance)->opcode;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.UnaryOperator.__Internal*)__Instance)->opcode = value;
                    }
                }

                public global::CppSharp.Parser.AST.Expr SubExpr
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.UnaryOperator.__Internal*) __Instance)->subExpr == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.UnaryOperator.__Internal*) __Instance)->subExpr))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.UnaryOperator.__Internal*) __Instance)->subExpr];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.UnaryOperator.__Internal*) __Instance)->subExpr);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.UnaryOperator.__Internal*)__Instance)->subExpr = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.SourceLocation OperatorLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.UnaryOperator.__Internal*) __Instance)->operatorLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.UnaryOperator.__Internal*)__Instance)->operatorLoc = value.__Instance;
                    }
                }

                public bool CanOverflow
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.UnaryOperator.__Internal*) __Instance)->canOverflow != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.UnaryOperator.__Internal*)__Instance)->canOverflow = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsPrefix
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.UnaryOperator.__Internal*) __Instance)->isPrefix != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.UnaryOperator.__Internal*)__Instance)->isPrefix = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsPostfix
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.UnaryOperator.__Internal*) __Instance)->isPostfix != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.UnaryOperator.__Internal*)__Instance)->isPostfix = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsIncrementOp
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.UnaryOperator.__Internal*) __Instance)->isIncrementOp != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.UnaryOperator.__Internal*)__Instance)->isIncrementOp = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsDecrementOp
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.UnaryOperator.__Internal*) __Instance)->isDecrementOp != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.UnaryOperator.__Internal*)__Instance)->isDecrementOp = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsIncrementDecrementOp
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.UnaryOperator.__Internal*) __Instance)->isIncrementDecrementOp != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.UnaryOperator.__Internal*)__Instance)->isIncrementDecrementOp = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsArithmeticOp
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.UnaryOperator.__Internal*) __Instance)->isArithmeticOp != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.UnaryOperator.__Internal*)__Instance)->isArithmeticOp = (byte) (value ? 1 : 0);
                    }
                }
            }

            public unsafe partial class OffsetOfExpr : global::CppSharp.Parser.AST.Expr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 72)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal operatorLoc;

                    [FieldOffset(60)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal rParenLoc;

                    [FieldOffset(64)]
                    internal uint numComponents;

                    [FieldOffset(68)]
                    internal uint numExpressions;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0OffsetOfExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0OffsetOfExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.OffsetOfExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.OffsetOfExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.OffsetOfExpr __CreateInstance(global::CppSharp.Parser.AST.OffsetOfExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.OffsetOfExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.OffsetOfExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.OffsetOfExpr.__Internal));
                    *(global::CppSharp.Parser.AST.OffsetOfExpr.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private OffsetOfExpr(global::CppSharp.Parser.AST.OffsetOfExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected OffsetOfExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public OffsetOfExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.OffsetOfExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public OffsetOfExpr(global::CppSharp.Parser.AST.OffsetOfExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.OffsetOfExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.OffsetOfExpr.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.OffsetOfExpr.__Internal*) _0.__Instance);
                }

                public global::CppSharp.Parser.SourceLocation OperatorLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.OffsetOfExpr.__Internal*) __Instance)->operatorLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.OffsetOfExpr.__Internal*)__Instance)->operatorLoc = value.__Instance;
                    }
                }

                public global::CppSharp.Parser.SourceLocation RParenLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.OffsetOfExpr.__Internal*) __Instance)->rParenLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.OffsetOfExpr.__Internal*)__Instance)->rParenLoc = value.__Instance;
                    }
                }

                public uint NumComponents
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.OffsetOfExpr.__Internal*) __Instance)->numComponents;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.OffsetOfExpr.__Internal*)__Instance)->numComponents = value;
                    }
                }

                public uint NumExpressions
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.OffsetOfExpr.__Internal*) __Instance)->numExpressions;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.OffsetOfExpr.__Internal*)__Instance)->numExpressions = value;
                    }
                }
            }

            public unsafe partial class UnaryExprOrTypeTraitExpr : global::CppSharp.Parser.AST.Expr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 92)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal global::CppSharp.Parser.AST.UnaryExprOrTypeTrait kind;

                    [FieldOffset(60)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal operatorLoc;

                    [FieldOffset(64)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal rParenLoc;

                    [FieldOffset(68)]
                    internal byte isArgumentType;

                    [FieldOffset(72)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal argumentType;

                    [FieldOffset(80)]
                    internal global::System.IntPtr argumentExpr;

                    [FieldOffset(84)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal typeOfArgument;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0UnaryExprOrTypeTraitExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0UnaryExprOrTypeTraitExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.UnaryExprOrTypeTraitExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.UnaryExprOrTypeTraitExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.UnaryExprOrTypeTraitExpr __CreateInstance(global::CppSharp.Parser.AST.UnaryExprOrTypeTraitExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.UnaryExprOrTypeTraitExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.UnaryExprOrTypeTraitExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.UnaryExprOrTypeTraitExpr.__Internal));
                    *(global::CppSharp.Parser.AST.UnaryExprOrTypeTraitExpr.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private UnaryExprOrTypeTraitExpr(global::CppSharp.Parser.AST.UnaryExprOrTypeTraitExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected UnaryExprOrTypeTraitExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public UnaryExprOrTypeTraitExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.UnaryExprOrTypeTraitExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public UnaryExprOrTypeTraitExpr(global::CppSharp.Parser.AST.UnaryExprOrTypeTraitExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.UnaryExprOrTypeTraitExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.UnaryExprOrTypeTraitExpr.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.UnaryExprOrTypeTraitExpr.__Internal*) _0.__Instance);
                }

                public global::CppSharp.Parser.AST.UnaryExprOrTypeTrait Kind
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.UnaryExprOrTypeTraitExpr.__Internal*) __Instance)->kind;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.UnaryExprOrTypeTraitExpr.__Internal*)__Instance)->kind = value;
                    }
                }

                public global::CppSharp.Parser.SourceLocation OperatorLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.UnaryExprOrTypeTraitExpr.__Internal*) __Instance)->operatorLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.UnaryExprOrTypeTraitExpr.__Internal*)__Instance)->operatorLoc = value.__Instance;
                    }
                }

                public global::CppSharp.Parser.SourceLocation RParenLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.UnaryExprOrTypeTraitExpr.__Internal*) __Instance)->rParenLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.UnaryExprOrTypeTraitExpr.__Internal*)__Instance)->rParenLoc = value.__Instance;
                    }
                }

                public bool IsArgumentType
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.UnaryExprOrTypeTraitExpr.__Internal*) __Instance)->isArgumentType != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.UnaryExprOrTypeTraitExpr.__Internal*)__Instance)->isArgumentType = (byte) (value ? 1 : 0);
                    }
                }

                public global::CppSharp.Parser.AST.QualifiedType ArgumentType
                {
                    get
                    {
                        return global::CppSharp.Parser.AST.QualifiedType.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.UnaryExprOrTypeTraitExpr.__Internal*) __Instance)->argumentType));
                    }

                    set
                    {
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                        ((global::CppSharp.Parser.AST.UnaryExprOrTypeTraitExpr.__Internal*)__Instance)->argumentType = *(global::CppSharp.Parser.AST.QualifiedType.__Internal*) value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Expr ArgumentExpr
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.UnaryExprOrTypeTraitExpr.__Internal*) __Instance)->argumentExpr == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.UnaryExprOrTypeTraitExpr.__Internal*) __Instance)->argumentExpr))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.UnaryExprOrTypeTraitExpr.__Internal*) __Instance)->argumentExpr];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.UnaryExprOrTypeTraitExpr.__Internal*) __Instance)->argumentExpr);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.UnaryExprOrTypeTraitExpr.__Internal*)__Instance)->argumentExpr = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.QualifiedType TypeOfArgument
                {
                    get
                    {
                        return global::CppSharp.Parser.AST.QualifiedType.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.UnaryExprOrTypeTraitExpr.__Internal*) __Instance)->typeOfArgument));
                    }

                    set
                    {
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                        ((global::CppSharp.Parser.AST.UnaryExprOrTypeTraitExpr.__Internal*)__Instance)->typeOfArgument = *(global::CppSharp.Parser.AST.QualifiedType.__Internal*) value.__Instance;
                    }
                }
            }

            public unsafe partial class ArraySubscriptExpr : global::CppSharp.Parser.AST.Expr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 76)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal global::System.IntPtr lHS;

                    [FieldOffset(60)]
                    internal global::System.IntPtr rHS;

                    [FieldOffset(64)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal rBracketLoc;

                    [FieldOffset(68)]
                    internal global::System.IntPtr @base;

                    [FieldOffset(72)]
                    internal global::System.IntPtr idx;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0ArraySubscriptExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0ArraySubscriptExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.ArraySubscriptExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.ArraySubscriptExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.ArraySubscriptExpr __CreateInstance(global::CppSharp.Parser.AST.ArraySubscriptExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.ArraySubscriptExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.ArraySubscriptExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ArraySubscriptExpr.__Internal));
                    *(global::CppSharp.Parser.AST.ArraySubscriptExpr.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private ArraySubscriptExpr(global::CppSharp.Parser.AST.ArraySubscriptExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected ArraySubscriptExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public ArraySubscriptExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ArraySubscriptExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public ArraySubscriptExpr(global::CppSharp.Parser.AST.ArraySubscriptExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ArraySubscriptExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.ArraySubscriptExpr.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.ArraySubscriptExpr.__Internal*) _0.__Instance);
                }

                public global::CppSharp.Parser.AST.Expr LHS
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.ArraySubscriptExpr.__Internal*) __Instance)->lHS == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.ArraySubscriptExpr.__Internal*) __Instance)->lHS))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.ArraySubscriptExpr.__Internal*) __Instance)->lHS];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.ArraySubscriptExpr.__Internal*) __Instance)->lHS);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.ArraySubscriptExpr.__Internal*)__Instance)->lHS = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Expr RHS
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.ArraySubscriptExpr.__Internal*) __Instance)->rHS == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.ArraySubscriptExpr.__Internal*) __Instance)->rHS))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.ArraySubscriptExpr.__Internal*) __Instance)->rHS];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.ArraySubscriptExpr.__Internal*) __Instance)->rHS);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.ArraySubscriptExpr.__Internal*)__Instance)->rHS = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.SourceLocation RBracketLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.ArraySubscriptExpr.__Internal*) __Instance)->rBracketLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.ArraySubscriptExpr.__Internal*)__Instance)->rBracketLoc = value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Expr Base
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.ArraySubscriptExpr.__Internal*) __Instance)->@base == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.ArraySubscriptExpr.__Internal*) __Instance)->@base))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.ArraySubscriptExpr.__Internal*) __Instance)->@base];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.ArraySubscriptExpr.__Internal*) __Instance)->@base);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.ArraySubscriptExpr.__Internal*)__Instance)->@base = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Expr Idx
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.ArraySubscriptExpr.__Internal*) __Instance)->idx == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.ArraySubscriptExpr.__Internal*) __Instance)->idx))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.ArraySubscriptExpr.__Internal*) __Instance)->idx];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.ArraySubscriptExpr.__Internal*) __Instance)->idx);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.ArraySubscriptExpr.__Internal*)__Instance)->idx = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }
            }

            public unsafe partial class CallExpr : global::CppSharp.Parser.AST.Expr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 100)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Expr___N_std_S_allocator__S0_ arguments;

                    [FieldOffset(68)]
                    internal global::System.IntPtr callee;

                    [FieldOffset(72)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal rParenLoc;

                    [FieldOffset(76)]
                    internal global::System.IntPtr calleeDecl;

                    [FieldOffset(80)]
                    internal global::System.IntPtr directCallee;

                    [FieldOffset(84)]
                    internal uint numArgs;

                    [FieldOffset(88)]
                    internal uint numCommas;

                    [FieldOffset(92)]
                    internal uint builtinCallee;

                    [FieldOffset(96)]
                    internal byte isCallToStdMove;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CallExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CallExpr@AST@CppParser@CppSharp@@QAE@W4StmtClass@123@@Z")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance, global::CppSharp.Parser.AST.StmtClass klass);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CallExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??1CallExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern void dtor(global::System.IntPtr __instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getarguments@CallExpr@AST@CppParser@CppSharp@@QAEPAVExpr@234@I@Z")]
                    internal static extern global::System.IntPtr Getarguments(global::System.IntPtr __instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?addarguments@CallExpr@AST@CppParser@CppSharp@@QAEXAAPAVExpr@234@@Z")]
                    internal static extern void Addarguments(global::System.IntPtr __instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?cleararguments@CallExpr@AST@CppParser@CppSharp@@QAEXXZ")]
                    internal static extern void Cleararguments(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getargumentsCount@CallExpr@AST@CppParser@CppSharp@@QAEIXZ")]
                    internal static extern uint GetargumentsCount(global::System.IntPtr __instance);
                }

                internal static new global::CppSharp.Parser.AST.CallExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CallExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.CallExpr __CreateInstance(global::CppSharp.Parser.AST.CallExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CallExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.CallExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CallExpr.__Internal));
                    global::CppSharp.Parser.AST.CallExpr.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private CallExpr(global::CppSharp.Parser.AST.CallExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected CallExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public CallExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CallExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public CallExpr(global::CppSharp.Parser.AST.StmtClass klass)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CallExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance, klass);
                }

                public CallExpr(global::CppSharp.Parser.AST.CallExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CallExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Stmt __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor(__Instance, 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.Expr Getarguments(uint i)
                {
                    var __ret = __Internal.Getarguments(__Instance, i);
                    global::CppSharp.Parser.AST.Expr __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[__ret];
                    else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(__ret);
                    return __result0;
                }

                public void Addarguments(global::CppSharp.Parser.AST.Expr s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var ____arg0 = s.__Instance;
                    var __arg0 = new global::System.IntPtr(&____arg0);
                    __Internal.Addarguments(__Instance, __arg0);
                }

                public void Cleararguments()
                {
                    __Internal.Cleararguments(__Instance);
                }

                public static implicit operator global::CppSharp.Parser.AST.CallExpr(global::CppSharp.Parser.AST.StmtClass klass)
                {
                    return new global::CppSharp.Parser.AST.CallExpr(klass);
                }

                public global::CppSharp.Parser.AST.Expr Callee
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.CallExpr.__Internal*) __Instance)->callee == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.CallExpr.__Internal*) __Instance)->callee))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.CallExpr.__Internal*) __Instance)->callee];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.CallExpr.__Internal*) __Instance)->callee);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CallExpr.__Internal*)__Instance)->callee = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.SourceLocation RParenLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.CallExpr.__Internal*) __Instance)->rParenLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CallExpr.__Internal*)__Instance)->rParenLoc = value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Declaration CalleeDecl
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Declaration __result0;
                        if (((global::CppSharp.Parser.AST.CallExpr.__Internal*) __Instance)->calleeDecl == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Declaration.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.CallExpr.__Internal*) __Instance)->calleeDecl))
                            __result0 = (global::CppSharp.Parser.AST.Declaration) global::CppSharp.Parser.AST.Declaration.NativeToManagedMap[((global::CppSharp.Parser.AST.CallExpr.__Internal*) __Instance)->calleeDecl];
                        else __result0 = global::CppSharp.Parser.AST.Declaration.__CreateInstance(((global::CppSharp.Parser.AST.CallExpr.__Internal*) __Instance)->calleeDecl);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CallExpr.__Internal*)__Instance)->calleeDecl = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Function DirectCallee
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Function __result0;
                        if (((global::CppSharp.Parser.AST.CallExpr.__Internal*) __Instance)->directCallee == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Function.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.CallExpr.__Internal*) __Instance)->directCallee))
                            __result0 = (global::CppSharp.Parser.AST.Function) global::CppSharp.Parser.AST.Function.NativeToManagedMap[((global::CppSharp.Parser.AST.CallExpr.__Internal*) __Instance)->directCallee];
                        else __result0 = global::CppSharp.Parser.AST.Function.__CreateInstance(((global::CppSharp.Parser.AST.CallExpr.__Internal*) __Instance)->directCallee);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CallExpr.__Internal*)__Instance)->directCallee = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public uint NumArgs
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.CallExpr.__Internal*) __Instance)->numArgs;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CallExpr.__Internal*)__Instance)->numArgs = value;
                    }
                }

                public uint NumCommas
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.CallExpr.__Internal*) __Instance)->numCommas;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CallExpr.__Internal*)__Instance)->numCommas = value;
                    }
                }

                public uint BuiltinCallee
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.CallExpr.__Internal*) __Instance)->builtinCallee;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CallExpr.__Internal*)__Instance)->builtinCallee = value;
                    }
                }

                public bool IsCallToStdMove
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.CallExpr.__Internal*) __Instance)->isCallToStdMove != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CallExpr.__Internal*)__Instance)->isCallToStdMove = (byte) (value ? 1 : 0);
                    }
                }

                public uint GetargumentsCount
                {
                    get
                    {
                        var __ret = __Internal.GetargumentsCount(__Instance);
                        return __ret;
                    }
                }
            }

            public unsafe partial class MemberExpr : global::CppSharp.Parser.AST.Expr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 100)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal global::System.IntPtr @base;

                    [FieldOffset(60)]
                    internal byte arrow;

                    [FieldOffset(64)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal memberLoc;

                    [FieldOffset(68)]
                    internal byte hadMultipleCandidates;

                    [FieldOffset(69)]
                    internal byte hasQualifier;

                    [FieldOffset(72)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal templateKeywordLoc;

                    [FieldOffset(76)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal lAngleLoc;

                    [FieldOffset(80)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal rAngleLoc;

                    [FieldOffset(84)]
                    internal byte hasTemplateKeyword;

                    [FieldOffset(85)]
                    internal byte hasExplicitTemplateArgs;

                    [FieldOffset(88)]
                    internal uint numTemplateArgs;

                    [FieldOffset(92)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal operatorLoc;

                    [FieldOffset(96)]
                    internal byte isImplicitAccess;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0MemberExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0MemberExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.MemberExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.MemberExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.MemberExpr __CreateInstance(global::CppSharp.Parser.AST.MemberExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.MemberExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.MemberExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.MemberExpr.__Internal));
                    *(global::CppSharp.Parser.AST.MemberExpr.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private MemberExpr(global::CppSharp.Parser.AST.MemberExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected MemberExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public MemberExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.MemberExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public MemberExpr(global::CppSharp.Parser.AST.MemberExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.MemberExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.MemberExpr.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.MemberExpr.__Internal*) _0.__Instance);
                }

                public global::CppSharp.Parser.AST.Expr Base
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.MemberExpr.__Internal*) __Instance)->@base == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.MemberExpr.__Internal*) __Instance)->@base))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.MemberExpr.__Internal*) __Instance)->@base];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.MemberExpr.__Internal*) __Instance)->@base);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.MemberExpr.__Internal*)__Instance)->@base = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public bool Arrow
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.MemberExpr.__Internal*) __Instance)->arrow != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.MemberExpr.__Internal*)__Instance)->arrow = (byte) (value ? 1 : 0);
                    }
                }

                public global::CppSharp.Parser.SourceLocation MemberLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.MemberExpr.__Internal*) __Instance)->memberLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.MemberExpr.__Internal*)__Instance)->memberLoc = value.__Instance;
                    }
                }

                public bool HadMultipleCandidates
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.MemberExpr.__Internal*) __Instance)->hadMultipleCandidates != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.MemberExpr.__Internal*)__Instance)->hadMultipleCandidates = (byte) (value ? 1 : 0);
                    }
                }

                public bool HasQualifier
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.MemberExpr.__Internal*) __Instance)->hasQualifier != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.MemberExpr.__Internal*)__Instance)->hasQualifier = (byte) (value ? 1 : 0);
                    }
                }

                public global::CppSharp.Parser.SourceLocation TemplateKeywordLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.MemberExpr.__Internal*) __Instance)->templateKeywordLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.MemberExpr.__Internal*)__Instance)->templateKeywordLoc = value.__Instance;
                    }
                }

                public global::CppSharp.Parser.SourceLocation LAngleLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.MemberExpr.__Internal*) __Instance)->lAngleLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.MemberExpr.__Internal*)__Instance)->lAngleLoc = value.__Instance;
                    }
                }

                public global::CppSharp.Parser.SourceLocation RAngleLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.MemberExpr.__Internal*) __Instance)->rAngleLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.MemberExpr.__Internal*)__Instance)->rAngleLoc = value.__Instance;
                    }
                }

                public bool HasTemplateKeyword
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.MemberExpr.__Internal*) __Instance)->hasTemplateKeyword != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.MemberExpr.__Internal*)__Instance)->hasTemplateKeyword = (byte) (value ? 1 : 0);
                    }
                }

                public bool HasExplicitTemplateArgs
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.MemberExpr.__Internal*) __Instance)->hasExplicitTemplateArgs != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.MemberExpr.__Internal*)__Instance)->hasExplicitTemplateArgs = (byte) (value ? 1 : 0);
                    }
                }

                public uint NumTemplateArgs
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.MemberExpr.__Internal*) __Instance)->numTemplateArgs;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.MemberExpr.__Internal*)__Instance)->numTemplateArgs = value;
                    }
                }

                public global::CppSharp.Parser.SourceLocation OperatorLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.MemberExpr.__Internal*) __Instance)->operatorLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.MemberExpr.__Internal*)__Instance)->operatorLoc = value.__Instance;
                    }
                }

                public bool IsImplicitAccess
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.MemberExpr.__Internal*) __Instance)->isImplicitAccess != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.MemberExpr.__Internal*)__Instance)->isImplicitAccess = (byte) (value ? 1 : 0);
                    }
                }
            }

            public unsafe partial class CompoundLiteralExpr : global::CppSharp.Parser.AST.Expr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 68)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal global::System.IntPtr initializer;

                    [FieldOffset(60)]
                    internal byte fileScope;

                    [FieldOffset(64)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal lParenLoc;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CompoundLiteralExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CompoundLiteralExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.CompoundLiteralExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CompoundLiteralExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.CompoundLiteralExpr __CreateInstance(global::CppSharp.Parser.AST.CompoundLiteralExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CompoundLiteralExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.CompoundLiteralExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CompoundLiteralExpr.__Internal));
                    *(global::CppSharp.Parser.AST.CompoundLiteralExpr.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private CompoundLiteralExpr(global::CppSharp.Parser.AST.CompoundLiteralExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected CompoundLiteralExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public CompoundLiteralExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CompoundLiteralExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public CompoundLiteralExpr(global::CppSharp.Parser.AST.CompoundLiteralExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CompoundLiteralExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.CompoundLiteralExpr.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.CompoundLiteralExpr.__Internal*) _0.__Instance);
                }

                public global::CppSharp.Parser.AST.Expr Initializer
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.CompoundLiteralExpr.__Internal*) __Instance)->initializer == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.CompoundLiteralExpr.__Internal*) __Instance)->initializer))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.CompoundLiteralExpr.__Internal*) __Instance)->initializer];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.CompoundLiteralExpr.__Internal*) __Instance)->initializer);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CompoundLiteralExpr.__Internal*)__Instance)->initializer = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public bool FileScope
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.CompoundLiteralExpr.__Internal*) __Instance)->fileScope != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CompoundLiteralExpr.__Internal*)__Instance)->fileScope = (byte) (value ? 1 : 0);
                    }
                }

                public global::CppSharp.Parser.SourceLocation LParenLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.CompoundLiteralExpr.__Internal*) __Instance)->lParenLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CompoundLiteralExpr.__Internal*)__Instance)->lParenLoc = value.__Instance;
                    }
                }
            }

            public unsafe partial class CastExpr : global::CppSharp.Parser.AST.Expr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 84)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal global::CppSharp.Parser.AST.CastKind castKind;

                    [FieldOffset(60)]
                    internal global::System.IntPtr subExpr;

                    [FieldOffset(64)]
                    internal global::System.IntPtr castKindName;

                    [FieldOffset(68)]
                    internal global::System.IntPtr subExprAsWritten;

                    [FieldOffset(72)]
                    internal global::System.IntPtr conversionFunction;

                    [FieldOffset(76)]
                    internal byte path_empty;

                    [FieldOffset(80)]
                    internal uint path_size;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CastExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CastExpr@AST@CppParser@CppSharp@@QAE@W4StmtClass@123@@Z")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance, global::CppSharp.Parser.AST.StmtClass klass);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CastExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.CastExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CastExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.CastExpr __CreateInstance(global::CppSharp.Parser.AST.CastExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CastExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.CastExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CastExpr.__Internal));
                    *(global::CppSharp.Parser.AST.CastExpr.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private CastExpr(global::CppSharp.Parser.AST.CastExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected CastExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public CastExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CastExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public CastExpr(global::CppSharp.Parser.AST.StmtClass klass)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CastExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance, klass);
                }

                public CastExpr(global::CppSharp.Parser.AST.CastExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CastExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.CastExpr.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.CastExpr.__Internal*) _0.__Instance);
                }

                public static implicit operator global::CppSharp.Parser.AST.CastExpr(global::CppSharp.Parser.AST.StmtClass klass)
                {
                    return new global::CppSharp.Parser.AST.CastExpr(klass);
                }

                public global::CppSharp.Parser.AST.CastKind CastKind
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.CastExpr.__Internal*) __Instance)->castKind;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CastExpr.__Internal*)__Instance)->castKind = value;
                    }
                }

                public global::CppSharp.Parser.AST.Expr SubExpr
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.CastExpr.__Internal*) __Instance)->subExpr == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.CastExpr.__Internal*) __Instance)->subExpr))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.CastExpr.__Internal*) __Instance)->subExpr];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.CastExpr.__Internal*) __Instance)->subExpr);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CastExpr.__Internal*)__Instance)->subExpr = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public string CastKindName
                {
                    get
                    {
                        if (((global::CppSharp.Parser.AST.CastExpr.__Internal*) __Instance)->castKindName == global::System.IntPtr.Zero)
                            return default(string);
                        var __retPtr = (byte*) ((global::CppSharp.Parser.AST.CastExpr.__Internal*) __Instance)->castKindName;
                        int __length = 0;
                        while (*(__retPtr++) != 0) __length += sizeof(byte);
                        return global::System.Text.Encoding.UTF8.GetString((byte*) ((global::CppSharp.Parser.AST.CastExpr.__Internal*) __Instance)->castKindName, __length);
                    }

                    set
                    {
                        byte[] __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                        fixed (byte* __bytePtr0 = __bytes0)
                        {
                            ((global::CppSharp.Parser.AST.CastExpr.__Internal*)__Instance)->castKindName = (global::System.IntPtr) new global::System.IntPtr(__bytePtr0);
                        }
                    }
                }

                public global::CppSharp.Parser.AST.Expr SubExprAsWritten
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.CastExpr.__Internal*) __Instance)->subExprAsWritten == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.CastExpr.__Internal*) __Instance)->subExprAsWritten))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.CastExpr.__Internal*) __Instance)->subExprAsWritten];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.CastExpr.__Internal*) __Instance)->subExprAsWritten);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CastExpr.__Internal*)__Instance)->subExprAsWritten = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Declaration ConversionFunction
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Declaration __result0;
                        if (((global::CppSharp.Parser.AST.CastExpr.__Internal*) __Instance)->conversionFunction == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Declaration.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.CastExpr.__Internal*) __Instance)->conversionFunction))
                            __result0 = (global::CppSharp.Parser.AST.Declaration) global::CppSharp.Parser.AST.Declaration.NativeToManagedMap[((global::CppSharp.Parser.AST.CastExpr.__Internal*) __Instance)->conversionFunction];
                        else __result0 = global::CppSharp.Parser.AST.Declaration.__CreateInstance(((global::CppSharp.Parser.AST.CastExpr.__Internal*) __Instance)->conversionFunction);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CastExpr.__Internal*)__Instance)->conversionFunction = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public bool PathEmpty
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.CastExpr.__Internal*) __Instance)->path_empty != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CastExpr.__Internal*)__Instance)->path_empty = (byte) (value ? 1 : 0);
                    }
                }

                public uint PathSize
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.CastExpr.__Internal*) __Instance)->path_size;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CastExpr.__Internal*)__Instance)->path_size = value;
                    }
                }
            }

            public unsafe partial class ImplicitCastExpr : global::CppSharp.Parser.AST.CastExpr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 88)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal global::CppSharp.Parser.AST.CastKind castKind;

                    [FieldOffset(60)]
                    internal global::System.IntPtr subExpr;

                    [FieldOffset(64)]
                    internal global::System.IntPtr castKindName;

                    [FieldOffset(68)]
                    internal global::System.IntPtr subExprAsWritten;

                    [FieldOffset(72)]
                    internal global::System.IntPtr conversionFunction;

                    [FieldOffset(76)]
                    internal byte path_empty;

                    [FieldOffset(80)]
                    internal uint path_size;

                    [FieldOffset(84)]
                    internal byte isPartOfExplicitCast;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0ImplicitCastExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0ImplicitCastExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                public enum OnStack_t
                {
                    OnStack = 0
                }

                internal static new global::CppSharp.Parser.AST.ImplicitCastExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.ImplicitCastExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.ImplicitCastExpr __CreateInstance(global::CppSharp.Parser.AST.ImplicitCastExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.ImplicitCastExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.ImplicitCastExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ImplicitCastExpr.__Internal));
                    *(global::CppSharp.Parser.AST.ImplicitCastExpr.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private ImplicitCastExpr(global::CppSharp.Parser.AST.ImplicitCastExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected ImplicitCastExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public ImplicitCastExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ImplicitCastExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public ImplicitCastExpr(global::CppSharp.Parser.AST.ImplicitCastExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ImplicitCastExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.ImplicitCastExpr.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.ImplicitCastExpr.__Internal*) _0.__Instance);
                }

                public bool IsPartOfExplicitCast
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.ImplicitCastExpr.__Internal*) __Instance)->isPartOfExplicitCast != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.ImplicitCastExpr.__Internal*)__Instance)->isPartOfExplicitCast = (byte) (value ? 1 : 0);
                    }
                }
            }

            public unsafe partial class ExplicitCastExpr : global::CppSharp.Parser.AST.CastExpr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 92)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal global::CppSharp.Parser.AST.CastKind castKind;

                    [FieldOffset(60)]
                    internal global::System.IntPtr subExpr;

                    [FieldOffset(64)]
                    internal global::System.IntPtr castKindName;

                    [FieldOffset(68)]
                    internal global::System.IntPtr subExprAsWritten;

                    [FieldOffset(72)]
                    internal global::System.IntPtr conversionFunction;

                    [FieldOffset(76)]
                    internal byte path_empty;

                    [FieldOffset(80)]
                    internal uint path_size;

                    [FieldOffset(84)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal typeAsWritten;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0ExplicitCastExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0ExplicitCastExpr@AST@CppParser@CppSharp@@QAE@W4StmtClass@123@@Z")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance, global::CppSharp.Parser.AST.StmtClass klass);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0ExplicitCastExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.ExplicitCastExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.ExplicitCastExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.ExplicitCastExpr __CreateInstance(global::CppSharp.Parser.AST.ExplicitCastExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.ExplicitCastExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.ExplicitCastExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ExplicitCastExpr.__Internal));
                    *(global::CppSharp.Parser.AST.ExplicitCastExpr.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private ExplicitCastExpr(global::CppSharp.Parser.AST.ExplicitCastExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected ExplicitCastExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public ExplicitCastExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ExplicitCastExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public ExplicitCastExpr(global::CppSharp.Parser.AST.StmtClass klass)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ExplicitCastExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance, klass);
                }

                public ExplicitCastExpr(global::CppSharp.Parser.AST.ExplicitCastExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ExplicitCastExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.ExplicitCastExpr.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.ExplicitCastExpr.__Internal*) _0.__Instance);
                }

                public static implicit operator global::CppSharp.Parser.AST.ExplicitCastExpr(global::CppSharp.Parser.AST.StmtClass klass)
                {
                    return new global::CppSharp.Parser.AST.ExplicitCastExpr(klass);
                }

                public global::CppSharp.Parser.AST.QualifiedType TypeAsWritten
                {
                    get
                    {
                        return global::CppSharp.Parser.AST.QualifiedType.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.ExplicitCastExpr.__Internal*) __Instance)->typeAsWritten));
                    }

                    set
                    {
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                        ((global::CppSharp.Parser.AST.ExplicitCastExpr.__Internal*)__Instance)->typeAsWritten = *(global::CppSharp.Parser.AST.QualifiedType.__Internal*) value.__Instance;
                    }
                }
            }

            public unsafe partial class CStyleCastExpr : global::CppSharp.Parser.AST.ExplicitCastExpr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 100)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal global::CppSharp.Parser.AST.CastKind castKind;

                    [FieldOffset(60)]
                    internal global::System.IntPtr subExpr;

                    [FieldOffset(64)]
                    internal global::System.IntPtr castKindName;

                    [FieldOffset(68)]
                    internal global::System.IntPtr subExprAsWritten;

                    [FieldOffset(72)]
                    internal global::System.IntPtr conversionFunction;

                    [FieldOffset(76)]
                    internal byte path_empty;

                    [FieldOffset(80)]
                    internal uint path_size;

                    [FieldOffset(84)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal typeAsWritten;

                    [FieldOffset(92)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal lParenLoc;

                    [FieldOffset(96)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal rParenLoc;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CStyleCastExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CStyleCastExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.CStyleCastExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CStyleCastExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.CStyleCastExpr __CreateInstance(global::CppSharp.Parser.AST.CStyleCastExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CStyleCastExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.CStyleCastExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CStyleCastExpr.__Internal));
                    *(global::CppSharp.Parser.AST.CStyleCastExpr.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private CStyleCastExpr(global::CppSharp.Parser.AST.CStyleCastExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected CStyleCastExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public CStyleCastExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CStyleCastExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public CStyleCastExpr(global::CppSharp.Parser.AST.CStyleCastExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CStyleCastExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.CStyleCastExpr.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.CStyleCastExpr.__Internal*) _0.__Instance);
                }

                public global::CppSharp.Parser.SourceLocation LParenLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.CStyleCastExpr.__Internal*) __Instance)->lParenLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CStyleCastExpr.__Internal*)__Instance)->lParenLoc = value.__Instance;
                    }
                }

                public global::CppSharp.Parser.SourceLocation RParenLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.CStyleCastExpr.__Internal*) __Instance)->rParenLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CStyleCastExpr.__Internal*)__Instance)->rParenLoc = value.__Instance;
                    }
                }
            }

            public unsafe partial class BinaryOperator : global::CppSharp.Parser.AST.Expr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 112)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal operatorLoc;

                    [FieldOffset(60)]
                    internal global::CppSharp.Parser.AST.BinaryOperatorKind opcode;

                    [FieldOffset(64)]
                    internal global::System.IntPtr lHS;

                    [FieldOffset(68)]
                    internal global::System.IntPtr rHS;

                    [FieldOffset(72)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C opcodeStr;

                    [FieldOffset(96)]
                    internal byte isPtrMemOp;

                    [FieldOffset(97)]
                    internal byte isMultiplicativeOp;

                    [FieldOffset(98)]
                    internal byte isAdditiveOp;

                    [FieldOffset(99)]
                    internal byte isShiftOp;

                    [FieldOffset(100)]
                    internal byte isBitwiseOp;

                    [FieldOffset(101)]
                    internal byte isRelationalOp;

                    [FieldOffset(102)]
                    internal byte isEqualityOp;

                    [FieldOffset(103)]
                    internal byte isComparisonOp;

                    [FieldOffset(104)]
                    internal byte isLogicalOp;

                    [FieldOffset(105)]
                    internal byte isAssignmentOp;

                    [FieldOffset(106)]
                    internal byte isCompoundAssignmentOp;

                    [FieldOffset(107)]
                    internal byte isShiftAssignOp;

                    [FieldOffset(108)]
                    internal byte isFPContractableWithinStatement;

                    [FieldOffset(109)]
                    internal byte isFEnvAccessOn;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0BinaryOperator@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0BinaryOperator@AST@CppParser@CppSharp@@QAE@W4StmtClass@123@@Z")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance, global::CppSharp.Parser.AST.StmtClass klass);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0BinaryOperator@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??1BinaryOperator@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern void dtor(global::System.IntPtr __instance, int delete);
                }

                internal static new global::CppSharp.Parser.AST.BinaryOperator __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.BinaryOperator(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.BinaryOperator __CreateInstance(global::CppSharp.Parser.AST.BinaryOperator.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.BinaryOperator(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.BinaryOperator.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.BinaryOperator.__Internal));
                    global::CppSharp.Parser.AST.BinaryOperator.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private BinaryOperator(global::CppSharp.Parser.AST.BinaryOperator.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected BinaryOperator(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public BinaryOperator()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.BinaryOperator.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public BinaryOperator(global::CppSharp.Parser.AST.StmtClass klass)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.BinaryOperator.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance, klass);
                }

                public BinaryOperator(global::CppSharp.Parser.AST.BinaryOperator _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.BinaryOperator.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Stmt __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor(__Instance, 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public static implicit operator global::CppSharp.Parser.AST.BinaryOperator(global::CppSharp.Parser.AST.StmtClass klass)
                {
                    return new global::CppSharp.Parser.AST.BinaryOperator(klass);
                }

                public global::CppSharp.Parser.SourceLocation OperatorLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.BinaryOperator.__Internal*) __Instance)->operatorLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.BinaryOperator.__Internal*)__Instance)->operatorLoc = value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.BinaryOperatorKind Opcode
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.BinaryOperator.__Internal*) __Instance)->opcode;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.BinaryOperator.__Internal*)__Instance)->opcode = value;
                    }
                }

                public global::CppSharp.Parser.AST.Expr LHS
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.BinaryOperator.__Internal*) __Instance)->lHS == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.BinaryOperator.__Internal*) __Instance)->lHS))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.BinaryOperator.__Internal*) __Instance)->lHS];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.BinaryOperator.__Internal*) __Instance)->lHS);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.BinaryOperator.__Internal*)__Instance)->lHS = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Expr RHS
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.BinaryOperator.__Internal*) __Instance)->rHS == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.BinaryOperator.__Internal*) __Instance)->rHS))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.BinaryOperator.__Internal*) __Instance)->rHS];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.BinaryOperator.__Internal*) __Instance)->rHS);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.BinaryOperator.__Internal*)__Instance)->rHS = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public string OpcodeStr
                {
                    get
                    {
                        var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.BinaryOperator.__Internal*) __Instance)->opcodeStr));
                        return global::Std.BasicStringExtensions.Data(__basicStringRet0);
                    }

                    set
                    {
                        global::Std.BasicStringExtensions.__Internal.Assign(new global::System.IntPtr(&((global::CppSharp.Parser.AST.BinaryOperator.__Internal*)__Instance)->opcodeStr), value);
                    }
                }

                public bool IsPtrMemOp
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.BinaryOperator.__Internal*) __Instance)->isPtrMemOp != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.BinaryOperator.__Internal*)__Instance)->isPtrMemOp = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsMultiplicativeOp
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.BinaryOperator.__Internal*) __Instance)->isMultiplicativeOp != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.BinaryOperator.__Internal*)__Instance)->isMultiplicativeOp = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsAdditiveOp
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.BinaryOperator.__Internal*) __Instance)->isAdditiveOp != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.BinaryOperator.__Internal*)__Instance)->isAdditiveOp = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsShiftOp
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.BinaryOperator.__Internal*) __Instance)->isShiftOp != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.BinaryOperator.__Internal*)__Instance)->isShiftOp = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsBitwiseOp
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.BinaryOperator.__Internal*) __Instance)->isBitwiseOp != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.BinaryOperator.__Internal*)__Instance)->isBitwiseOp = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsRelationalOp
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.BinaryOperator.__Internal*) __Instance)->isRelationalOp != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.BinaryOperator.__Internal*)__Instance)->isRelationalOp = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsEqualityOp
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.BinaryOperator.__Internal*) __Instance)->isEqualityOp != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.BinaryOperator.__Internal*)__Instance)->isEqualityOp = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsComparisonOp
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.BinaryOperator.__Internal*) __Instance)->isComparisonOp != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.BinaryOperator.__Internal*)__Instance)->isComparisonOp = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsLogicalOp
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.BinaryOperator.__Internal*) __Instance)->isLogicalOp != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.BinaryOperator.__Internal*)__Instance)->isLogicalOp = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsAssignmentOp
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.BinaryOperator.__Internal*) __Instance)->isAssignmentOp != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.BinaryOperator.__Internal*)__Instance)->isAssignmentOp = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsCompoundAssignmentOp
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.BinaryOperator.__Internal*) __Instance)->isCompoundAssignmentOp != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.BinaryOperator.__Internal*)__Instance)->isCompoundAssignmentOp = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsShiftAssignOp
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.BinaryOperator.__Internal*) __Instance)->isShiftAssignOp != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.BinaryOperator.__Internal*)__Instance)->isShiftAssignOp = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsFPContractableWithinStatement
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.BinaryOperator.__Internal*) __Instance)->isFPContractableWithinStatement != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.BinaryOperator.__Internal*)__Instance)->isFPContractableWithinStatement = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsFEnvAccessOn
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.BinaryOperator.__Internal*) __Instance)->isFEnvAccessOn != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.BinaryOperator.__Internal*)__Instance)->isFEnvAccessOn = (byte) (value ? 1 : 0);
                    }
                }
            }

            public unsafe partial class CompoundAssignOperator : global::CppSharp.Parser.AST.BinaryOperator, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 128)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal operatorLoc;

                    [FieldOffset(60)]
                    internal global::CppSharp.Parser.AST.BinaryOperatorKind opcode;

                    [FieldOffset(64)]
                    internal global::System.IntPtr lHS;

                    [FieldOffset(68)]
                    internal global::System.IntPtr rHS;

                    [FieldOffset(72)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C opcodeStr;

                    [FieldOffset(96)]
                    internal byte isPtrMemOp;

                    [FieldOffset(97)]
                    internal byte isMultiplicativeOp;

                    [FieldOffset(98)]
                    internal byte isAdditiveOp;

                    [FieldOffset(99)]
                    internal byte isShiftOp;

                    [FieldOffset(100)]
                    internal byte isBitwiseOp;

                    [FieldOffset(101)]
                    internal byte isRelationalOp;

                    [FieldOffset(102)]
                    internal byte isEqualityOp;

                    [FieldOffset(103)]
                    internal byte isComparisonOp;

                    [FieldOffset(104)]
                    internal byte isLogicalOp;

                    [FieldOffset(105)]
                    internal byte isAssignmentOp;

                    [FieldOffset(106)]
                    internal byte isCompoundAssignmentOp;

                    [FieldOffset(107)]
                    internal byte isShiftAssignOp;

                    [FieldOffset(108)]
                    internal byte isFPContractableWithinStatement;

                    [FieldOffset(109)]
                    internal byte isFEnvAccessOn;

                    [FieldOffset(112)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal computationLHSType;

                    [FieldOffset(120)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal computationResultType;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CompoundAssignOperator@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CompoundAssignOperator@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??1CompoundAssignOperator@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern void dtor(global::System.IntPtr __instance, int delete);
                }

                internal static new global::CppSharp.Parser.AST.CompoundAssignOperator __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CompoundAssignOperator(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.CompoundAssignOperator __CreateInstance(global::CppSharp.Parser.AST.CompoundAssignOperator.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CompoundAssignOperator(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.CompoundAssignOperator.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CompoundAssignOperator.__Internal));
                    global::CppSharp.Parser.AST.CompoundAssignOperator.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private CompoundAssignOperator(global::CppSharp.Parser.AST.CompoundAssignOperator.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected CompoundAssignOperator(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public CompoundAssignOperator()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CompoundAssignOperator.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public CompoundAssignOperator(global::CppSharp.Parser.AST.CompoundAssignOperator _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CompoundAssignOperator.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Stmt __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor(__Instance, 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.QualifiedType ComputationLHSType
                {
                    get
                    {
                        return global::CppSharp.Parser.AST.QualifiedType.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.CompoundAssignOperator.__Internal*) __Instance)->computationLHSType));
                    }

                    set
                    {
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                        ((global::CppSharp.Parser.AST.CompoundAssignOperator.__Internal*)__Instance)->computationLHSType = *(global::CppSharp.Parser.AST.QualifiedType.__Internal*) value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.QualifiedType ComputationResultType
                {
                    get
                    {
                        return global::CppSharp.Parser.AST.QualifiedType.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.CompoundAssignOperator.__Internal*) __Instance)->computationResultType));
                    }

                    set
                    {
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                        ((global::CppSharp.Parser.AST.CompoundAssignOperator.__Internal*)__Instance)->computationResultType = *(global::CppSharp.Parser.AST.QualifiedType.__Internal*) value.__Instance;
                    }
                }
            }

            public unsafe partial class AbstractConditionalOperator : global::CppSharp.Parser.AST.Expr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 76)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal global::System.IntPtr cond;

                    [FieldOffset(60)]
                    internal global::System.IntPtr trueExpr;

                    [FieldOffset(64)]
                    internal global::System.IntPtr falseExpr;

                    [FieldOffset(68)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal questionLoc;

                    [FieldOffset(72)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal colonLoc;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0AbstractConditionalOperator@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0AbstractConditionalOperator@AST@CppParser@CppSharp@@QAE@W4StmtClass@123@@Z")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance, global::CppSharp.Parser.AST.StmtClass klass);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0AbstractConditionalOperator@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.AbstractConditionalOperator __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.AbstractConditionalOperator(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.AbstractConditionalOperator __CreateInstance(global::CppSharp.Parser.AST.AbstractConditionalOperator.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.AbstractConditionalOperator(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.AbstractConditionalOperator.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.AbstractConditionalOperator.__Internal));
                    *(global::CppSharp.Parser.AST.AbstractConditionalOperator.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private AbstractConditionalOperator(global::CppSharp.Parser.AST.AbstractConditionalOperator.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected AbstractConditionalOperator(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public AbstractConditionalOperator()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.AbstractConditionalOperator.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public AbstractConditionalOperator(global::CppSharp.Parser.AST.StmtClass klass)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.AbstractConditionalOperator.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance, klass);
                }

                public AbstractConditionalOperator(global::CppSharp.Parser.AST.AbstractConditionalOperator _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.AbstractConditionalOperator.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.AbstractConditionalOperator.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.AbstractConditionalOperator.__Internal*) _0.__Instance);
                }

                public static implicit operator global::CppSharp.Parser.AST.AbstractConditionalOperator(global::CppSharp.Parser.AST.StmtClass klass)
                {
                    return new global::CppSharp.Parser.AST.AbstractConditionalOperator(klass);
                }

                public global::CppSharp.Parser.AST.Expr Cond
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.AbstractConditionalOperator.__Internal*) __Instance)->cond == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.AbstractConditionalOperator.__Internal*) __Instance)->cond))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.AbstractConditionalOperator.__Internal*) __Instance)->cond];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.AbstractConditionalOperator.__Internal*) __Instance)->cond);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.AbstractConditionalOperator.__Internal*)__Instance)->cond = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Expr TrueExpr
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.AbstractConditionalOperator.__Internal*) __Instance)->trueExpr == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.AbstractConditionalOperator.__Internal*) __Instance)->trueExpr))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.AbstractConditionalOperator.__Internal*) __Instance)->trueExpr];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.AbstractConditionalOperator.__Internal*) __Instance)->trueExpr);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.AbstractConditionalOperator.__Internal*)__Instance)->trueExpr = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Expr FalseExpr
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.AbstractConditionalOperator.__Internal*) __Instance)->falseExpr == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.AbstractConditionalOperator.__Internal*) __Instance)->falseExpr))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.AbstractConditionalOperator.__Internal*) __Instance)->falseExpr];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.AbstractConditionalOperator.__Internal*) __Instance)->falseExpr);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.AbstractConditionalOperator.__Internal*)__Instance)->falseExpr = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.SourceLocation QuestionLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.AbstractConditionalOperator.__Internal*) __Instance)->questionLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.AbstractConditionalOperator.__Internal*)__Instance)->questionLoc = value.__Instance;
                    }
                }

                public global::CppSharp.Parser.SourceLocation ColonLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.AbstractConditionalOperator.__Internal*) __Instance)->colonLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.AbstractConditionalOperator.__Internal*)__Instance)->colonLoc = value.__Instance;
                    }
                }
            }

            public unsafe partial class ConditionalOperator : global::CppSharp.Parser.AST.AbstractConditionalOperator, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 84)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal global::System.IntPtr cond;

                    [FieldOffset(60)]
                    internal global::System.IntPtr trueExpr;

                    [FieldOffset(64)]
                    internal global::System.IntPtr falseExpr;

                    [FieldOffset(68)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal questionLoc;

                    [FieldOffset(72)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal colonLoc;

                    [FieldOffset(76)]
                    internal global::System.IntPtr lHS;

                    [FieldOffset(80)]
                    internal global::System.IntPtr rHS;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0ConditionalOperator@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0ConditionalOperator@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.ConditionalOperator __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.ConditionalOperator(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.ConditionalOperator __CreateInstance(global::CppSharp.Parser.AST.ConditionalOperator.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.ConditionalOperator(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.ConditionalOperator.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ConditionalOperator.__Internal));
                    *(global::CppSharp.Parser.AST.ConditionalOperator.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private ConditionalOperator(global::CppSharp.Parser.AST.ConditionalOperator.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected ConditionalOperator(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public ConditionalOperator()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ConditionalOperator.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public ConditionalOperator(global::CppSharp.Parser.AST.ConditionalOperator _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ConditionalOperator.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.ConditionalOperator.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.ConditionalOperator.__Internal*) _0.__Instance);
                }

                public global::CppSharp.Parser.AST.Expr LHS
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.ConditionalOperator.__Internal*) __Instance)->lHS == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.ConditionalOperator.__Internal*) __Instance)->lHS))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.ConditionalOperator.__Internal*) __Instance)->lHS];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.ConditionalOperator.__Internal*) __Instance)->lHS);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.ConditionalOperator.__Internal*)__Instance)->lHS = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Expr RHS
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.ConditionalOperator.__Internal*) __Instance)->rHS == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.ConditionalOperator.__Internal*) __Instance)->rHS))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.ConditionalOperator.__Internal*) __Instance)->rHS];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.ConditionalOperator.__Internal*) __Instance)->rHS);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.ConditionalOperator.__Internal*)__Instance)->rHS = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }
            }

            public unsafe partial class BinaryConditionalOperator : global::CppSharp.Parser.AST.AbstractConditionalOperator, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 84)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal global::System.IntPtr cond;

                    [FieldOffset(60)]
                    internal global::System.IntPtr trueExpr;

                    [FieldOffset(64)]
                    internal global::System.IntPtr falseExpr;

                    [FieldOffset(68)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal questionLoc;

                    [FieldOffset(72)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal colonLoc;

                    [FieldOffset(76)]
                    internal global::System.IntPtr common;

                    [FieldOffset(80)]
                    internal global::System.IntPtr opaqueValue;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0BinaryConditionalOperator@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0BinaryConditionalOperator@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.BinaryConditionalOperator __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.BinaryConditionalOperator(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.BinaryConditionalOperator __CreateInstance(global::CppSharp.Parser.AST.BinaryConditionalOperator.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.BinaryConditionalOperator(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.BinaryConditionalOperator.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.BinaryConditionalOperator.__Internal));
                    *(global::CppSharp.Parser.AST.BinaryConditionalOperator.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private BinaryConditionalOperator(global::CppSharp.Parser.AST.BinaryConditionalOperator.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected BinaryConditionalOperator(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public BinaryConditionalOperator()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.BinaryConditionalOperator.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public BinaryConditionalOperator(global::CppSharp.Parser.AST.BinaryConditionalOperator _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.BinaryConditionalOperator.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.BinaryConditionalOperator.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.BinaryConditionalOperator.__Internal*) _0.__Instance);
                }

                public global::CppSharp.Parser.AST.Expr Common
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.BinaryConditionalOperator.__Internal*) __Instance)->common == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.BinaryConditionalOperator.__Internal*) __Instance)->common))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.BinaryConditionalOperator.__Internal*) __Instance)->common];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.BinaryConditionalOperator.__Internal*) __Instance)->common);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.BinaryConditionalOperator.__Internal*)__Instance)->common = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.OpaqueValueExpr OpaqueValue
                {
                    get
                    {
                        global::CppSharp.Parser.AST.OpaqueValueExpr __result0;
                        if (((global::CppSharp.Parser.AST.BinaryConditionalOperator.__Internal*) __Instance)->opaqueValue == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.OpaqueValueExpr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.BinaryConditionalOperator.__Internal*) __Instance)->opaqueValue))
                            __result0 = (global::CppSharp.Parser.AST.OpaqueValueExpr) global::CppSharp.Parser.AST.OpaqueValueExpr.NativeToManagedMap[((global::CppSharp.Parser.AST.BinaryConditionalOperator.__Internal*) __Instance)->opaqueValue];
                        else __result0 = global::CppSharp.Parser.AST.OpaqueValueExpr.__CreateInstance(((global::CppSharp.Parser.AST.BinaryConditionalOperator.__Internal*) __Instance)->opaqueValue);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.BinaryConditionalOperator.__Internal*)__Instance)->opaqueValue = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }
            }

            public unsafe partial class AddrLabelExpr : global::CppSharp.Parser.AST.Expr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 64)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal ampAmpLoc;

                    [FieldOffset(60)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal labelLoc;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0AddrLabelExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0AddrLabelExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.AddrLabelExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.AddrLabelExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.AddrLabelExpr __CreateInstance(global::CppSharp.Parser.AST.AddrLabelExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.AddrLabelExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.AddrLabelExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.AddrLabelExpr.__Internal));
                    *(global::CppSharp.Parser.AST.AddrLabelExpr.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private AddrLabelExpr(global::CppSharp.Parser.AST.AddrLabelExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected AddrLabelExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public AddrLabelExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.AddrLabelExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public AddrLabelExpr(global::CppSharp.Parser.AST.AddrLabelExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.AddrLabelExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.AddrLabelExpr.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.AddrLabelExpr.__Internal*) _0.__Instance);
                }

                public global::CppSharp.Parser.SourceLocation AmpAmpLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.AddrLabelExpr.__Internal*) __Instance)->ampAmpLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.AddrLabelExpr.__Internal*)__Instance)->ampAmpLoc = value.__Instance;
                    }
                }

                public global::CppSharp.Parser.SourceLocation LabelLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.AddrLabelExpr.__Internal*) __Instance)->labelLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.AddrLabelExpr.__Internal*)__Instance)->labelLoc = value.__Instance;
                    }
                }
            }

            public unsafe partial class StmtExpr : global::CppSharp.Parser.AST.Expr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 68)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal global::System.IntPtr subStmt;

                    [FieldOffset(60)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal lParenLoc;

                    [FieldOffset(64)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal rParenLoc;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0StmtExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0StmtExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.StmtExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.StmtExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.StmtExpr __CreateInstance(global::CppSharp.Parser.AST.StmtExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.StmtExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.StmtExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.StmtExpr.__Internal));
                    *(global::CppSharp.Parser.AST.StmtExpr.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private StmtExpr(global::CppSharp.Parser.AST.StmtExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected StmtExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public StmtExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.StmtExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public StmtExpr(global::CppSharp.Parser.AST.StmtExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.StmtExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.StmtExpr.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.StmtExpr.__Internal*) _0.__Instance);
                }

                public global::CppSharp.Parser.AST.CompoundStmt SubStmt
                {
                    get
                    {
                        global::CppSharp.Parser.AST.CompoundStmt __result0;
                        if (((global::CppSharp.Parser.AST.StmtExpr.__Internal*) __Instance)->subStmt == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.CompoundStmt.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.StmtExpr.__Internal*) __Instance)->subStmt))
                            __result0 = (global::CppSharp.Parser.AST.CompoundStmt) global::CppSharp.Parser.AST.CompoundStmt.NativeToManagedMap[((global::CppSharp.Parser.AST.StmtExpr.__Internal*) __Instance)->subStmt];
                        else __result0 = global::CppSharp.Parser.AST.CompoundStmt.__CreateInstance(((global::CppSharp.Parser.AST.StmtExpr.__Internal*) __Instance)->subStmt);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.StmtExpr.__Internal*)__Instance)->subStmt = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.SourceLocation LParenLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.StmtExpr.__Internal*) __Instance)->lParenLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.StmtExpr.__Internal*)__Instance)->lParenLoc = value.__Instance;
                    }
                }

                public global::CppSharp.Parser.SourceLocation RParenLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.StmtExpr.__Internal*) __Instance)->rParenLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.StmtExpr.__Internal*)__Instance)->rParenLoc = value.__Instance;
                    }
                }
            }

            public unsafe partial class ShuffleVectorExpr : global::CppSharp.Parser.AST.Expr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 68)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal builtinLoc;

                    [FieldOffset(60)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal rParenLoc;

                    [FieldOffset(64)]
                    internal uint numSubExprs;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0ShuffleVectorExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0ShuffleVectorExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.ShuffleVectorExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.ShuffleVectorExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.ShuffleVectorExpr __CreateInstance(global::CppSharp.Parser.AST.ShuffleVectorExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.ShuffleVectorExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.ShuffleVectorExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ShuffleVectorExpr.__Internal));
                    *(global::CppSharp.Parser.AST.ShuffleVectorExpr.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private ShuffleVectorExpr(global::CppSharp.Parser.AST.ShuffleVectorExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected ShuffleVectorExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public ShuffleVectorExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ShuffleVectorExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public ShuffleVectorExpr(global::CppSharp.Parser.AST.ShuffleVectorExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ShuffleVectorExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.ShuffleVectorExpr.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.ShuffleVectorExpr.__Internal*) _0.__Instance);
                }

                public global::CppSharp.Parser.SourceLocation BuiltinLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.ShuffleVectorExpr.__Internal*) __Instance)->builtinLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.ShuffleVectorExpr.__Internal*)__Instance)->builtinLoc = value.__Instance;
                    }
                }

                public global::CppSharp.Parser.SourceLocation RParenLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.ShuffleVectorExpr.__Internal*) __Instance)->rParenLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.ShuffleVectorExpr.__Internal*)__Instance)->rParenLoc = value.__Instance;
                    }
                }

                public uint NumSubExprs
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.ShuffleVectorExpr.__Internal*) __Instance)->numSubExprs;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.ShuffleVectorExpr.__Internal*)__Instance)->numSubExprs = value;
                    }
                }
            }

            public unsafe partial class ConvertVectorExpr : global::CppSharp.Parser.AST.Expr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 68)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal global::System.IntPtr srcExpr;

                    [FieldOffset(60)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal builtinLoc;

                    [FieldOffset(64)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal rParenLoc;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0ConvertVectorExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0ConvertVectorExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.ConvertVectorExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.ConvertVectorExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.ConvertVectorExpr __CreateInstance(global::CppSharp.Parser.AST.ConvertVectorExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.ConvertVectorExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.ConvertVectorExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ConvertVectorExpr.__Internal));
                    *(global::CppSharp.Parser.AST.ConvertVectorExpr.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private ConvertVectorExpr(global::CppSharp.Parser.AST.ConvertVectorExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected ConvertVectorExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public ConvertVectorExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ConvertVectorExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public ConvertVectorExpr(global::CppSharp.Parser.AST.ConvertVectorExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ConvertVectorExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.ConvertVectorExpr.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.ConvertVectorExpr.__Internal*) _0.__Instance);
                }

                public global::CppSharp.Parser.AST.Expr SrcExpr
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.ConvertVectorExpr.__Internal*) __Instance)->srcExpr == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.ConvertVectorExpr.__Internal*) __Instance)->srcExpr))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.ConvertVectorExpr.__Internal*) __Instance)->srcExpr];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.ConvertVectorExpr.__Internal*) __Instance)->srcExpr);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.ConvertVectorExpr.__Internal*)__Instance)->srcExpr = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.SourceLocation BuiltinLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.ConvertVectorExpr.__Internal*) __Instance)->builtinLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.ConvertVectorExpr.__Internal*)__Instance)->builtinLoc = value.__Instance;
                    }
                }

                public global::CppSharp.Parser.SourceLocation RParenLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.ConvertVectorExpr.__Internal*) __Instance)->rParenLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.ConvertVectorExpr.__Internal*)__Instance)->rParenLoc = value.__Instance;
                    }
                }
            }

            public unsafe partial class ChooseExpr : global::CppSharp.Parser.AST.Expr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 88)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal byte isConditionTrue;

                    [FieldOffset(60)]
                    internal global::System.IntPtr cond;

                    [FieldOffset(64)]
                    internal global::System.IntPtr lHS;

                    [FieldOffset(68)]
                    internal global::System.IntPtr rHS;

                    [FieldOffset(72)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal builtinLoc;

                    [FieldOffset(76)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal rParenLoc;

                    [FieldOffset(80)]
                    internal byte isConditionDependent;

                    [FieldOffset(84)]
                    internal global::System.IntPtr chosenSubExpr;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0ChooseExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0ChooseExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.ChooseExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.ChooseExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.ChooseExpr __CreateInstance(global::CppSharp.Parser.AST.ChooseExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.ChooseExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.ChooseExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ChooseExpr.__Internal));
                    *(global::CppSharp.Parser.AST.ChooseExpr.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private ChooseExpr(global::CppSharp.Parser.AST.ChooseExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected ChooseExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public ChooseExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ChooseExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public ChooseExpr(global::CppSharp.Parser.AST.ChooseExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ChooseExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.ChooseExpr.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.ChooseExpr.__Internal*) _0.__Instance);
                }

                public bool IsConditionTrue
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.ChooseExpr.__Internal*) __Instance)->isConditionTrue != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.ChooseExpr.__Internal*)__Instance)->isConditionTrue = (byte) (value ? 1 : 0);
                    }
                }

                public global::CppSharp.Parser.AST.Expr Cond
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.ChooseExpr.__Internal*) __Instance)->cond == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.ChooseExpr.__Internal*) __Instance)->cond))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.ChooseExpr.__Internal*) __Instance)->cond];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.ChooseExpr.__Internal*) __Instance)->cond);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.ChooseExpr.__Internal*)__Instance)->cond = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Expr LHS
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.ChooseExpr.__Internal*) __Instance)->lHS == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.ChooseExpr.__Internal*) __Instance)->lHS))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.ChooseExpr.__Internal*) __Instance)->lHS];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.ChooseExpr.__Internal*) __Instance)->lHS);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.ChooseExpr.__Internal*)__Instance)->lHS = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Expr RHS
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.ChooseExpr.__Internal*) __Instance)->rHS == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.ChooseExpr.__Internal*) __Instance)->rHS))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.ChooseExpr.__Internal*) __Instance)->rHS];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.ChooseExpr.__Internal*) __Instance)->rHS);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.ChooseExpr.__Internal*)__Instance)->rHS = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.SourceLocation BuiltinLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.ChooseExpr.__Internal*) __Instance)->builtinLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.ChooseExpr.__Internal*)__Instance)->builtinLoc = value.__Instance;
                    }
                }

                public global::CppSharp.Parser.SourceLocation RParenLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.ChooseExpr.__Internal*) __Instance)->rParenLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.ChooseExpr.__Internal*)__Instance)->rParenLoc = value.__Instance;
                    }
                }

                public bool IsConditionDependent
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.ChooseExpr.__Internal*) __Instance)->isConditionDependent != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.ChooseExpr.__Internal*)__Instance)->isConditionDependent = (byte) (value ? 1 : 0);
                    }
                }

                public global::CppSharp.Parser.AST.Expr ChosenSubExpr
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.ChooseExpr.__Internal*) __Instance)->chosenSubExpr == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.ChooseExpr.__Internal*) __Instance)->chosenSubExpr))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.ChooseExpr.__Internal*) __Instance)->chosenSubExpr];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.ChooseExpr.__Internal*) __Instance)->chosenSubExpr);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.ChooseExpr.__Internal*)__Instance)->chosenSubExpr = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }
            }

            public unsafe partial class GNUNullExpr : global::CppSharp.Parser.AST.Expr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 60)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal tokenLocation;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0GNUNullExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0GNUNullExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.GNUNullExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.GNUNullExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.GNUNullExpr __CreateInstance(global::CppSharp.Parser.AST.GNUNullExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.GNUNullExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.GNUNullExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.GNUNullExpr.__Internal));
                    *(global::CppSharp.Parser.AST.GNUNullExpr.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private GNUNullExpr(global::CppSharp.Parser.AST.GNUNullExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected GNUNullExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public GNUNullExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.GNUNullExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public GNUNullExpr(global::CppSharp.Parser.AST.GNUNullExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.GNUNullExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.GNUNullExpr.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.GNUNullExpr.__Internal*) _0.__Instance);
                }

                public global::CppSharp.Parser.SourceLocation TokenLocation
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.GNUNullExpr.__Internal*) __Instance)->tokenLocation);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.GNUNullExpr.__Internal*)__Instance)->tokenLocation = value.__Instance;
                    }
                }
            }

            public unsafe partial class VAArgExpr : global::CppSharp.Parser.AST.Expr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 72)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal global::System.IntPtr subExpr;

                    [FieldOffset(60)]
                    internal byte isMicrosoftABI;

                    [FieldOffset(64)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal builtinLoc;

                    [FieldOffset(68)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal rParenLoc;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0VAArgExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0VAArgExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.VAArgExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.VAArgExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.VAArgExpr __CreateInstance(global::CppSharp.Parser.AST.VAArgExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.VAArgExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.VAArgExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.VAArgExpr.__Internal));
                    *(global::CppSharp.Parser.AST.VAArgExpr.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private VAArgExpr(global::CppSharp.Parser.AST.VAArgExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected VAArgExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public VAArgExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.VAArgExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public VAArgExpr(global::CppSharp.Parser.AST.VAArgExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.VAArgExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.VAArgExpr.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.VAArgExpr.__Internal*) _0.__Instance);
                }

                public global::CppSharp.Parser.AST.Expr SubExpr
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.VAArgExpr.__Internal*) __Instance)->subExpr == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.VAArgExpr.__Internal*) __Instance)->subExpr))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.VAArgExpr.__Internal*) __Instance)->subExpr];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.VAArgExpr.__Internal*) __Instance)->subExpr);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.VAArgExpr.__Internal*)__Instance)->subExpr = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public bool IsMicrosoftABI
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.VAArgExpr.__Internal*) __Instance)->isMicrosoftABI != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.VAArgExpr.__Internal*)__Instance)->isMicrosoftABI = (byte) (value ? 1 : 0);
                    }
                }

                public global::CppSharp.Parser.SourceLocation BuiltinLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.VAArgExpr.__Internal*) __Instance)->builtinLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.VAArgExpr.__Internal*)__Instance)->builtinLoc = value.__Instance;
                    }
                }

                public global::CppSharp.Parser.SourceLocation RParenLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.VAArgExpr.__Internal*) __Instance)->rParenLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.VAArgExpr.__Internal*)__Instance)->rParenLoc = value.__Instance;
                    }
                }
            }

            public unsafe partial class InitListExpr : global::CppSharp.Parser.AST.Expr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 92)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal global::System.IntPtr arrayFiller;

                    [FieldOffset(60)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal lBraceLoc;

                    [FieldOffset(64)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal rBraceLoc;

                    [FieldOffset(68)]
                    internal global::System.IntPtr syntacticForm;

                    [FieldOffset(72)]
                    internal uint numInits;

                    [FieldOffset(76)]
                    internal byte hasArrayFiller;

                    [FieldOffset(77)]
                    internal byte isExplicit;

                    [FieldOffset(78)]
                    internal byte isStringLiteralInit;

                    [FieldOffset(79)]
                    internal byte isTransparent;

                    [FieldOffset(80)]
                    internal byte isSemanticForm;

                    [FieldOffset(84)]
                    internal global::System.IntPtr semanticForm;

                    [FieldOffset(88)]
                    internal byte isSyntacticForm;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0InitListExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0InitListExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.InitListExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.InitListExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.InitListExpr __CreateInstance(global::CppSharp.Parser.AST.InitListExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.InitListExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.InitListExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.InitListExpr.__Internal));
                    *(global::CppSharp.Parser.AST.InitListExpr.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private InitListExpr(global::CppSharp.Parser.AST.InitListExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected InitListExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public InitListExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.InitListExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public InitListExpr(global::CppSharp.Parser.AST.InitListExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.InitListExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.InitListExpr.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.InitListExpr.__Internal*) _0.__Instance);
                }

                public global::CppSharp.Parser.AST.Expr ArrayFiller
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.InitListExpr.__Internal*) __Instance)->arrayFiller == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.InitListExpr.__Internal*) __Instance)->arrayFiller))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.InitListExpr.__Internal*) __Instance)->arrayFiller];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.InitListExpr.__Internal*) __Instance)->arrayFiller);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.InitListExpr.__Internal*)__Instance)->arrayFiller = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.SourceLocation LBraceLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.InitListExpr.__Internal*) __Instance)->lBraceLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.InitListExpr.__Internal*)__Instance)->lBraceLoc = value.__Instance;
                    }
                }

                public global::CppSharp.Parser.SourceLocation RBraceLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.InitListExpr.__Internal*) __Instance)->rBraceLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.InitListExpr.__Internal*)__Instance)->rBraceLoc = value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.InitListExpr SyntacticForm
                {
                    get
                    {
                        global::CppSharp.Parser.AST.InitListExpr __result0;
                        if (((global::CppSharp.Parser.AST.InitListExpr.__Internal*) __Instance)->syntacticForm == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.InitListExpr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.InitListExpr.__Internal*) __Instance)->syntacticForm))
                            __result0 = (global::CppSharp.Parser.AST.InitListExpr) global::CppSharp.Parser.AST.InitListExpr.NativeToManagedMap[((global::CppSharp.Parser.AST.InitListExpr.__Internal*) __Instance)->syntacticForm];
                        else __result0 = global::CppSharp.Parser.AST.InitListExpr.__CreateInstance(((global::CppSharp.Parser.AST.InitListExpr.__Internal*) __Instance)->syntacticForm);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.InitListExpr.__Internal*)__Instance)->syntacticForm = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public uint NumInits
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.InitListExpr.__Internal*) __Instance)->numInits;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.InitListExpr.__Internal*)__Instance)->numInits = value;
                    }
                }

                public bool HasArrayFiller
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.InitListExpr.__Internal*) __Instance)->hasArrayFiller != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.InitListExpr.__Internal*)__Instance)->hasArrayFiller = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsExplicit
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.InitListExpr.__Internal*) __Instance)->isExplicit != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.InitListExpr.__Internal*)__Instance)->isExplicit = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsStringLiteralInit
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.InitListExpr.__Internal*) __Instance)->isStringLiteralInit != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.InitListExpr.__Internal*)__Instance)->isStringLiteralInit = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsTransparent
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.InitListExpr.__Internal*) __Instance)->isTransparent != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.InitListExpr.__Internal*)__Instance)->isTransparent = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsSemanticForm
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.InitListExpr.__Internal*) __Instance)->isSemanticForm != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.InitListExpr.__Internal*)__Instance)->isSemanticForm = (byte) (value ? 1 : 0);
                    }
                }

                public global::CppSharp.Parser.AST.InitListExpr SemanticForm
                {
                    get
                    {
                        global::CppSharp.Parser.AST.InitListExpr __result0;
                        if (((global::CppSharp.Parser.AST.InitListExpr.__Internal*) __Instance)->semanticForm == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.InitListExpr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.InitListExpr.__Internal*) __Instance)->semanticForm))
                            __result0 = (global::CppSharp.Parser.AST.InitListExpr) global::CppSharp.Parser.AST.InitListExpr.NativeToManagedMap[((global::CppSharp.Parser.AST.InitListExpr.__Internal*) __Instance)->semanticForm];
                        else __result0 = global::CppSharp.Parser.AST.InitListExpr.__CreateInstance(((global::CppSharp.Parser.AST.InitListExpr.__Internal*) __Instance)->semanticForm);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.InitListExpr.__Internal*)__Instance)->semanticForm = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public bool IsSyntacticForm
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.InitListExpr.__Internal*) __Instance)->isSyntacticForm != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.InitListExpr.__Internal*)__Instance)->isSyntacticForm = (byte) (value ? 1 : 0);
                    }
                }
            }

            public unsafe partial class DesignatedInitExpr : global::CppSharp.Parser.AST.Expr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 84)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal equalOrColonLoc;

                    [FieldOffset(60)]
                    internal global::System.IntPtr init;

                    [FieldOffset(64)]
                    internal uint size;

                    [FieldOffset(68)]
                    internal byte usesGNUSyntax;

                    [FieldOffset(72)]
                    internal uint numSubExprs;

                    [FieldOffset(76)]
                    internal global::CppSharp.Parser.SourceRange.__Internal designatorsSourceRange;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0DesignatedInitExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0DesignatedInitExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                public unsafe partial class Designator : IDisposable
                {
                    [StructLayout(LayoutKind.Explicit, Size = 40)]
                    public partial struct __Internal
                    {
                        [FieldOffset(0)]
                        internal global::System.IntPtr field;

                        [FieldOffset(4)]
                        internal byte isFieldDesignator;

                        [FieldOffset(5)]
                        internal byte isArrayDesignator;

                        [FieldOffset(6)]
                        internal byte isArrayRangeDesignator;

                        [FieldOffset(8)]
                        internal global::CppSharp.Parser.SourceLocation.__Internal dotLoc;

                        [FieldOffset(12)]
                        internal global::CppSharp.Parser.SourceLocation.__Internal fieldLoc;

                        [FieldOffset(16)]
                        internal global::CppSharp.Parser.SourceLocation.__Internal lBracketLoc;

                        [FieldOffset(20)]
                        internal global::CppSharp.Parser.SourceLocation.__Internal rBracketLoc;

                        [FieldOffset(24)]
                        internal global::CppSharp.Parser.SourceLocation.__Internal ellipsisLoc;

                        [FieldOffset(28)]
                        internal uint firstExprIndex;

                        [FieldOffset(32)]
                        internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                            EntryPoint="??0Designator@DesignatedInitExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                        internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                            EntryPoint="??0Designator@DesignatedInitExpr@AST@CppParser@CppSharp@@QAE@ABV01234@@Z")]
                        internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                    }

                    public global::System.IntPtr __Instance { get; protected set; }

                    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.DesignatedInitExpr.Designator> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.DesignatedInitExpr.Designator>();
                    protected internal void*[] __OriginalVTables;

                    protected bool __ownsNativeInstance;

                    internal static global::CppSharp.Parser.AST.DesignatedInitExpr.Designator __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                    {
                        return new global::CppSharp.Parser.AST.DesignatedInitExpr.Designator(native.ToPointer(), skipVTables);
                    }

                    internal static global::CppSharp.Parser.AST.DesignatedInitExpr.Designator __CreateInstance(global::CppSharp.Parser.AST.DesignatedInitExpr.Designator.__Internal native, bool skipVTables = false)
                    {
                        return new global::CppSharp.Parser.AST.DesignatedInitExpr.Designator(native, skipVTables);
                    }

                    private static void* __CopyValue(global::CppSharp.Parser.AST.DesignatedInitExpr.Designator.__Internal native)
                    {
                        var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.DesignatedInitExpr.Designator.__Internal));
                        *(global::CppSharp.Parser.AST.DesignatedInitExpr.Designator.__Internal*) ret = native;
                        return ret.ToPointer();
                    }

                    private Designator(global::CppSharp.Parser.AST.DesignatedInitExpr.Designator.__Internal native, bool skipVTables = false)
                        : this(__CopyValue(native), skipVTables)
                    {
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                    }

                    protected Designator(void* native, bool skipVTables = false)
                    {
                        if (native == null)
                            return;
                        __Instance = new global::System.IntPtr(native);
                    }

                    public Designator()
                    {
                        __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.DesignatedInitExpr.Designator.__Internal));
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                        __Internal.ctor(__Instance);
                    }

                    public Designator(global::CppSharp.Parser.AST.DesignatedInitExpr.Designator _0)
                    {
                        __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.DesignatedInitExpr.Designator.__Internal));
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                        *((global::CppSharp.Parser.AST.DesignatedInitExpr.Designator.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.DesignatedInitExpr.Designator.__Internal*) _0.__Instance);
                    }

                    public void Dispose()
                    {
                        Dispose(disposing: true);
                    }

                    public virtual void Dispose(bool disposing)
                    {
                        if (__Instance == IntPtr.Zero)
                            return;
                        global::CppSharp.Parser.AST.DesignatedInitExpr.Designator __dummy;
                        NativeToManagedMap.TryRemove(__Instance, out __dummy);
                        if (__ownsNativeInstance)
                            Marshal.FreeHGlobal(__Instance);
                        __Instance = IntPtr.Zero;
                    }

                    public global::CppSharp.Parser.AST.Field Field
                    {
                        get
                        {
                            global::CppSharp.Parser.AST.Field __result0;
                            if (((global::CppSharp.Parser.AST.DesignatedInitExpr.Designator.__Internal*) __Instance)->field == IntPtr.Zero) __result0 = null;
                            else if (global::CppSharp.Parser.AST.Field.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.DesignatedInitExpr.Designator.__Internal*) __Instance)->field))
                                __result0 = (global::CppSharp.Parser.AST.Field) global::CppSharp.Parser.AST.Field.NativeToManagedMap[((global::CppSharp.Parser.AST.DesignatedInitExpr.Designator.__Internal*) __Instance)->field];
                            else __result0 = global::CppSharp.Parser.AST.Field.__CreateInstance(((global::CppSharp.Parser.AST.DesignatedInitExpr.Designator.__Internal*) __Instance)->field);
                            return __result0;
                        }

                        set
                        {
                            ((global::CppSharp.Parser.AST.DesignatedInitExpr.Designator.__Internal*)__Instance)->field = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                        }
                    }

                    public bool IsFieldDesignator
                    {
                        get
                        {
                            return ((global::CppSharp.Parser.AST.DesignatedInitExpr.Designator.__Internal*) __Instance)->isFieldDesignator != 0;
                        }

                        set
                        {
                            ((global::CppSharp.Parser.AST.DesignatedInitExpr.Designator.__Internal*)__Instance)->isFieldDesignator = (byte) (value ? 1 : 0);
                        }
                    }

                    public bool IsArrayDesignator
                    {
                        get
                        {
                            return ((global::CppSharp.Parser.AST.DesignatedInitExpr.Designator.__Internal*) __Instance)->isArrayDesignator != 0;
                        }

                        set
                        {
                            ((global::CppSharp.Parser.AST.DesignatedInitExpr.Designator.__Internal*)__Instance)->isArrayDesignator = (byte) (value ? 1 : 0);
                        }
                    }

                    public bool IsArrayRangeDesignator
                    {
                        get
                        {
                            return ((global::CppSharp.Parser.AST.DesignatedInitExpr.Designator.__Internal*) __Instance)->isArrayRangeDesignator != 0;
                        }

                        set
                        {
                            ((global::CppSharp.Parser.AST.DesignatedInitExpr.Designator.__Internal*)__Instance)->isArrayRangeDesignator = (byte) (value ? 1 : 0);
                        }
                    }

                    public global::CppSharp.Parser.SourceLocation DotLoc
                    {
                        get
                        {
                            return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.DesignatedInitExpr.Designator.__Internal*) __Instance)->dotLoc);
                        }

                        set
                        {
                            ((global::CppSharp.Parser.AST.DesignatedInitExpr.Designator.__Internal*)__Instance)->dotLoc = value.__Instance;
                        }
                    }

                    public global::CppSharp.Parser.SourceLocation FieldLoc
                    {
                        get
                        {
                            return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.DesignatedInitExpr.Designator.__Internal*) __Instance)->fieldLoc);
                        }

                        set
                        {
                            ((global::CppSharp.Parser.AST.DesignatedInitExpr.Designator.__Internal*)__Instance)->fieldLoc = value.__Instance;
                        }
                    }

                    public global::CppSharp.Parser.SourceLocation LBracketLoc
                    {
                        get
                        {
                            return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.DesignatedInitExpr.Designator.__Internal*) __Instance)->lBracketLoc);
                        }

                        set
                        {
                            ((global::CppSharp.Parser.AST.DesignatedInitExpr.Designator.__Internal*)__Instance)->lBracketLoc = value.__Instance;
                        }
                    }

                    public global::CppSharp.Parser.SourceLocation RBracketLoc
                    {
                        get
                        {
                            return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.DesignatedInitExpr.Designator.__Internal*) __Instance)->rBracketLoc);
                        }

                        set
                        {
                            ((global::CppSharp.Parser.AST.DesignatedInitExpr.Designator.__Internal*)__Instance)->rBracketLoc = value.__Instance;
                        }
                    }

                    public global::CppSharp.Parser.SourceLocation EllipsisLoc
                    {
                        get
                        {
                            return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.DesignatedInitExpr.Designator.__Internal*) __Instance)->ellipsisLoc);
                        }

                        set
                        {
                            ((global::CppSharp.Parser.AST.DesignatedInitExpr.Designator.__Internal*)__Instance)->ellipsisLoc = value.__Instance;
                        }
                    }

                    public uint FirstExprIndex
                    {
                        get
                        {
                            return ((global::CppSharp.Parser.AST.DesignatedInitExpr.Designator.__Internal*) __Instance)->firstExprIndex;
                        }

                        set
                        {
                            ((global::CppSharp.Parser.AST.DesignatedInitExpr.Designator.__Internal*)__Instance)->firstExprIndex = value;
                        }
                    }

                    public global::CppSharp.Parser.SourceRange SourceRange
                    {
                        get
                        {
                            return global::CppSharp.Parser.SourceRange.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.DesignatedInitExpr.Designator.__Internal*) __Instance)->sourceRange));
                        }

                        set
                        {
                            if (ReferenceEquals(value, null))
                                throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                            ((global::CppSharp.Parser.AST.DesignatedInitExpr.Designator.__Internal*)__Instance)->sourceRange = *(global::CppSharp.Parser.SourceRange.__Internal*) value.__Instance;
                        }
                    }
                }

                public unsafe partial class FieldDesignator : IDisposable
                {
                    [StructLayout(LayoutKind.Explicit, Size = 0)]
                    public partial struct __Internal
                    {
                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                            EntryPoint="??0FieldDesignator@DesignatedInitExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                        internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                            EntryPoint="??0FieldDesignator@DesignatedInitExpr@AST@CppParser@CppSharp@@QAE@ABV01234@@Z")]
                        internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                    }

                    public global::System.IntPtr __Instance { get; protected set; }

                    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.DesignatedInitExpr.FieldDesignator> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.DesignatedInitExpr.FieldDesignator>();
                    protected internal void*[] __OriginalVTables;

                    protected bool __ownsNativeInstance;

                    internal static global::CppSharp.Parser.AST.DesignatedInitExpr.FieldDesignator __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                    {
                        return new global::CppSharp.Parser.AST.DesignatedInitExpr.FieldDesignator(native.ToPointer(), skipVTables);
                    }

                    internal static global::CppSharp.Parser.AST.DesignatedInitExpr.FieldDesignator __CreateInstance(global::CppSharp.Parser.AST.DesignatedInitExpr.FieldDesignator.__Internal native, bool skipVTables = false)
                    {
                        return new global::CppSharp.Parser.AST.DesignatedInitExpr.FieldDesignator(native, skipVTables);
                    }

                    private static void* __CopyValue(global::CppSharp.Parser.AST.DesignatedInitExpr.FieldDesignator.__Internal native)
                    {
                        var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.DesignatedInitExpr.FieldDesignator.__Internal));
                        *(global::CppSharp.Parser.AST.DesignatedInitExpr.FieldDesignator.__Internal*) ret = native;
                        return ret.ToPointer();
                    }

                    private FieldDesignator(global::CppSharp.Parser.AST.DesignatedInitExpr.FieldDesignator.__Internal native, bool skipVTables = false)
                        : this(__CopyValue(native), skipVTables)
                    {
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                    }

                    protected FieldDesignator(void* native, bool skipVTables = false)
                    {
                        if (native == null)
                            return;
                        __Instance = new global::System.IntPtr(native);
                    }

                    public FieldDesignator()
                    {
                        __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.DesignatedInitExpr.FieldDesignator.__Internal));
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                        __Internal.ctor(__Instance);
                    }

                    public FieldDesignator(global::CppSharp.Parser.AST.DesignatedInitExpr.FieldDesignator _0)
                    {
                        __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.DesignatedInitExpr.FieldDesignator.__Internal));
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                        *((global::CppSharp.Parser.AST.DesignatedInitExpr.FieldDesignator.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.DesignatedInitExpr.FieldDesignator.__Internal*) _0.__Instance);
                    }

                    public void Dispose()
                    {
                        Dispose(disposing: true);
                    }

                    public virtual void Dispose(bool disposing)
                    {
                        if (__Instance == IntPtr.Zero)
                            return;
                        global::CppSharp.Parser.AST.DesignatedInitExpr.FieldDesignator __dummy;
                        NativeToManagedMap.TryRemove(__Instance, out __dummy);
                        if (__ownsNativeInstance)
                            Marshal.FreeHGlobal(__Instance);
                        __Instance = IntPtr.Zero;
                    }
                }

                public unsafe partial class ArrayOrRangeDesignator : IDisposable
                {
                    [StructLayout(LayoutKind.Explicit, Size = 0)]
                    public partial struct __Internal
                    {
                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                            EntryPoint="??0ArrayOrRangeDesignator@DesignatedInitExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                        internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                            EntryPoint="??0ArrayOrRangeDesignator@DesignatedInitExpr@AST@CppParser@CppSharp@@QAE@ABV01234@@Z")]
                        internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                    }

                    public global::System.IntPtr __Instance { get; protected set; }

                    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.DesignatedInitExpr.ArrayOrRangeDesignator> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.DesignatedInitExpr.ArrayOrRangeDesignator>();
                    protected internal void*[] __OriginalVTables;

                    protected bool __ownsNativeInstance;

                    internal static global::CppSharp.Parser.AST.DesignatedInitExpr.ArrayOrRangeDesignator __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                    {
                        return new global::CppSharp.Parser.AST.DesignatedInitExpr.ArrayOrRangeDesignator(native.ToPointer(), skipVTables);
                    }

                    internal static global::CppSharp.Parser.AST.DesignatedInitExpr.ArrayOrRangeDesignator __CreateInstance(global::CppSharp.Parser.AST.DesignatedInitExpr.ArrayOrRangeDesignator.__Internal native, bool skipVTables = false)
                    {
                        return new global::CppSharp.Parser.AST.DesignatedInitExpr.ArrayOrRangeDesignator(native, skipVTables);
                    }

                    private static void* __CopyValue(global::CppSharp.Parser.AST.DesignatedInitExpr.ArrayOrRangeDesignator.__Internal native)
                    {
                        var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.DesignatedInitExpr.ArrayOrRangeDesignator.__Internal));
                        *(global::CppSharp.Parser.AST.DesignatedInitExpr.ArrayOrRangeDesignator.__Internal*) ret = native;
                        return ret.ToPointer();
                    }

                    private ArrayOrRangeDesignator(global::CppSharp.Parser.AST.DesignatedInitExpr.ArrayOrRangeDesignator.__Internal native, bool skipVTables = false)
                        : this(__CopyValue(native), skipVTables)
                    {
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                    }

                    protected ArrayOrRangeDesignator(void* native, bool skipVTables = false)
                    {
                        if (native == null)
                            return;
                        __Instance = new global::System.IntPtr(native);
                    }

                    public ArrayOrRangeDesignator()
                    {
                        __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.DesignatedInitExpr.ArrayOrRangeDesignator.__Internal));
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                        __Internal.ctor(__Instance);
                    }

                    public ArrayOrRangeDesignator(global::CppSharp.Parser.AST.DesignatedInitExpr.ArrayOrRangeDesignator _0)
                    {
                        __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.DesignatedInitExpr.ArrayOrRangeDesignator.__Internal));
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                        *((global::CppSharp.Parser.AST.DesignatedInitExpr.ArrayOrRangeDesignator.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.DesignatedInitExpr.ArrayOrRangeDesignator.__Internal*) _0.__Instance);
                    }

                    public void Dispose()
                    {
                        Dispose(disposing: true);
                    }

                    public virtual void Dispose(bool disposing)
                    {
                        if (__Instance == IntPtr.Zero)
                            return;
                        global::CppSharp.Parser.AST.DesignatedInitExpr.ArrayOrRangeDesignator __dummy;
                        NativeToManagedMap.TryRemove(__Instance, out __dummy);
                        if (__ownsNativeInstance)
                            Marshal.FreeHGlobal(__Instance);
                        __Instance = IntPtr.Zero;
                    }
                }

                internal static new global::CppSharp.Parser.AST.DesignatedInitExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.DesignatedInitExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.DesignatedInitExpr __CreateInstance(global::CppSharp.Parser.AST.DesignatedInitExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.DesignatedInitExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.DesignatedInitExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.DesignatedInitExpr.__Internal));
                    *(global::CppSharp.Parser.AST.DesignatedInitExpr.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private DesignatedInitExpr(global::CppSharp.Parser.AST.DesignatedInitExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected DesignatedInitExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public DesignatedInitExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.DesignatedInitExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public DesignatedInitExpr(global::CppSharp.Parser.AST.DesignatedInitExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.DesignatedInitExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.DesignatedInitExpr.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.DesignatedInitExpr.__Internal*) _0.__Instance);
                }

                public global::CppSharp.Parser.SourceLocation EqualOrColonLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.DesignatedInitExpr.__Internal*) __Instance)->equalOrColonLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.DesignatedInitExpr.__Internal*)__Instance)->equalOrColonLoc = value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Expr Init
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.DesignatedInitExpr.__Internal*) __Instance)->init == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.DesignatedInitExpr.__Internal*) __Instance)->init))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.DesignatedInitExpr.__Internal*) __Instance)->init];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.DesignatedInitExpr.__Internal*) __Instance)->init);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.DesignatedInitExpr.__Internal*)__Instance)->init = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public uint Size
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.DesignatedInitExpr.__Internal*) __Instance)->size;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.DesignatedInitExpr.__Internal*)__Instance)->size = value;
                    }
                }

                public bool UsesGNUSyntax
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.DesignatedInitExpr.__Internal*) __Instance)->usesGNUSyntax != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.DesignatedInitExpr.__Internal*)__Instance)->usesGNUSyntax = (byte) (value ? 1 : 0);
                    }
                }

                public uint NumSubExprs
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.DesignatedInitExpr.__Internal*) __Instance)->numSubExprs;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.DesignatedInitExpr.__Internal*)__Instance)->numSubExprs = value;
                    }
                }

                public global::CppSharp.Parser.SourceRange DesignatorsSourceRange
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceRange.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.DesignatedInitExpr.__Internal*) __Instance)->designatorsSourceRange));
                    }

                    set
                    {
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                        ((global::CppSharp.Parser.AST.DesignatedInitExpr.__Internal*)__Instance)->designatorsSourceRange = *(global::CppSharp.Parser.SourceRange.__Internal*) value.__Instance;
                    }
                }
            }

            public unsafe partial class NoInitExpr : global::CppSharp.Parser.AST.Expr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 56)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0NoInitExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0NoInitExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.NoInitExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.NoInitExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.NoInitExpr __CreateInstance(global::CppSharp.Parser.AST.NoInitExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.NoInitExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.NoInitExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.NoInitExpr.__Internal));
                    *(global::CppSharp.Parser.AST.NoInitExpr.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private NoInitExpr(global::CppSharp.Parser.AST.NoInitExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected NoInitExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public NoInitExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.NoInitExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public NoInitExpr(global::CppSharp.Parser.AST.NoInitExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.NoInitExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.NoInitExpr.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.NoInitExpr.__Internal*) _0.__Instance);
                }
            }

            public unsafe partial class DesignatedInitUpdateExpr : global::CppSharp.Parser.AST.Expr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 64)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal global::System.IntPtr @base;

                    [FieldOffset(60)]
                    internal global::System.IntPtr updater;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0DesignatedInitUpdateExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0DesignatedInitUpdateExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.DesignatedInitUpdateExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.DesignatedInitUpdateExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.DesignatedInitUpdateExpr __CreateInstance(global::CppSharp.Parser.AST.DesignatedInitUpdateExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.DesignatedInitUpdateExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.DesignatedInitUpdateExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.DesignatedInitUpdateExpr.__Internal));
                    *(global::CppSharp.Parser.AST.DesignatedInitUpdateExpr.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private DesignatedInitUpdateExpr(global::CppSharp.Parser.AST.DesignatedInitUpdateExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected DesignatedInitUpdateExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public DesignatedInitUpdateExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.DesignatedInitUpdateExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public DesignatedInitUpdateExpr(global::CppSharp.Parser.AST.DesignatedInitUpdateExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.DesignatedInitUpdateExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.DesignatedInitUpdateExpr.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.DesignatedInitUpdateExpr.__Internal*) _0.__Instance);
                }

                public global::CppSharp.Parser.AST.Expr Base
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.DesignatedInitUpdateExpr.__Internal*) __Instance)->@base == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.DesignatedInitUpdateExpr.__Internal*) __Instance)->@base))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.DesignatedInitUpdateExpr.__Internal*) __Instance)->@base];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.DesignatedInitUpdateExpr.__Internal*) __Instance)->@base);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.DesignatedInitUpdateExpr.__Internal*)__Instance)->@base = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.InitListExpr Updater
                {
                    get
                    {
                        global::CppSharp.Parser.AST.InitListExpr __result0;
                        if (((global::CppSharp.Parser.AST.DesignatedInitUpdateExpr.__Internal*) __Instance)->updater == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.InitListExpr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.DesignatedInitUpdateExpr.__Internal*) __Instance)->updater))
                            __result0 = (global::CppSharp.Parser.AST.InitListExpr) global::CppSharp.Parser.AST.InitListExpr.NativeToManagedMap[((global::CppSharp.Parser.AST.DesignatedInitUpdateExpr.__Internal*) __Instance)->updater];
                        else __result0 = global::CppSharp.Parser.AST.InitListExpr.__CreateInstance(((global::CppSharp.Parser.AST.DesignatedInitUpdateExpr.__Internal*) __Instance)->updater);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.DesignatedInitUpdateExpr.__Internal*)__Instance)->updater = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }
            }

            public unsafe partial class ArrayInitLoopExpr : global::CppSharp.Parser.AST.Expr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 64)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal global::System.IntPtr commonExpr;

                    [FieldOffset(60)]
                    internal global::System.IntPtr subExpr;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0ArrayInitLoopExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0ArrayInitLoopExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.ArrayInitLoopExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.ArrayInitLoopExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.ArrayInitLoopExpr __CreateInstance(global::CppSharp.Parser.AST.ArrayInitLoopExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.ArrayInitLoopExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.ArrayInitLoopExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ArrayInitLoopExpr.__Internal));
                    *(global::CppSharp.Parser.AST.ArrayInitLoopExpr.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private ArrayInitLoopExpr(global::CppSharp.Parser.AST.ArrayInitLoopExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected ArrayInitLoopExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public ArrayInitLoopExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ArrayInitLoopExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public ArrayInitLoopExpr(global::CppSharp.Parser.AST.ArrayInitLoopExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ArrayInitLoopExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.ArrayInitLoopExpr.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.ArrayInitLoopExpr.__Internal*) _0.__Instance);
                }

                public global::CppSharp.Parser.AST.OpaqueValueExpr CommonExpr
                {
                    get
                    {
                        global::CppSharp.Parser.AST.OpaqueValueExpr __result0;
                        if (((global::CppSharp.Parser.AST.ArrayInitLoopExpr.__Internal*) __Instance)->commonExpr == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.OpaqueValueExpr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.ArrayInitLoopExpr.__Internal*) __Instance)->commonExpr))
                            __result0 = (global::CppSharp.Parser.AST.OpaqueValueExpr) global::CppSharp.Parser.AST.OpaqueValueExpr.NativeToManagedMap[((global::CppSharp.Parser.AST.ArrayInitLoopExpr.__Internal*) __Instance)->commonExpr];
                        else __result0 = global::CppSharp.Parser.AST.OpaqueValueExpr.__CreateInstance(((global::CppSharp.Parser.AST.ArrayInitLoopExpr.__Internal*) __Instance)->commonExpr);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.ArrayInitLoopExpr.__Internal*)__Instance)->commonExpr = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Expr SubExpr
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.ArrayInitLoopExpr.__Internal*) __Instance)->subExpr == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.ArrayInitLoopExpr.__Internal*) __Instance)->subExpr))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.ArrayInitLoopExpr.__Internal*) __Instance)->subExpr];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.ArrayInitLoopExpr.__Internal*) __Instance)->subExpr);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.ArrayInitLoopExpr.__Internal*)__Instance)->subExpr = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }
            }

            public unsafe partial class ArrayInitIndexExpr : global::CppSharp.Parser.AST.Expr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 56)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0ArrayInitIndexExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0ArrayInitIndexExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.ArrayInitIndexExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.ArrayInitIndexExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.ArrayInitIndexExpr __CreateInstance(global::CppSharp.Parser.AST.ArrayInitIndexExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.ArrayInitIndexExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.ArrayInitIndexExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ArrayInitIndexExpr.__Internal));
                    *(global::CppSharp.Parser.AST.ArrayInitIndexExpr.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private ArrayInitIndexExpr(global::CppSharp.Parser.AST.ArrayInitIndexExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected ArrayInitIndexExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public ArrayInitIndexExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ArrayInitIndexExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public ArrayInitIndexExpr(global::CppSharp.Parser.AST.ArrayInitIndexExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ArrayInitIndexExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.ArrayInitIndexExpr.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.ArrayInitIndexExpr.__Internal*) _0.__Instance);
                }
            }

            public unsafe partial class ImplicitValueInitExpr : global::CppSharp.Parser.AST.Expr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 56)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0ImplicitValueInitExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0ImplicitValueInitExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.ImplicitValueInitExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.ImplicitValueInitExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.ImplicitValueInitExpr __CreateInstance(global::CppSharp.Parser.AST.ImplicitValueInitExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.ImplicitValueInitExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.ImplicitValueInitExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ImplicitValueInitExpr.__Internal));
                    *(global::CppSharp.Parser.AST.ImplicitValueInitExpr.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private ImplicitValueInitExpr(global::CppSharp.Parser.AST.ImplicitValueInitExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected ImplicitValueInitExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public ImplicitValueInitExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ImplicitValueInitExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public ImplicitValueInitExpr(global::CppSharp.Parser.AST.ImplicitValueInitExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ImplicitValueInitExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.ImplicitValueInitExpr.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.ImplicitValueInitExpr.__Internal*) _0.__Instance);
                }
            }

            public unsafe partial class ParenListExpr : global::CppSharp.Parser.AST.Expr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 68)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal uint numExprs;

                    [FieldOffset(60)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal lParenLoc;

                    [FieldOffset(64)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal rParenLoc;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0ParenListExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0ParenListExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.ParenListExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.ParenListExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.ParenListExpr __CreateInstance(global::CppSharp.Parser.AST.ParenListExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.ParenListExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.ParenListExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ParenListExpr.__Internal));
                    *(global::CppSharp.Parser.AST.ParenListExpr.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private ParenListExpr(global::CppSharp.Parser.AST.ParenListExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected ParenListExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public ParenListExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ParenListExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public ParenListExpr(global::CppSharp.Parser.AST.ParenListExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ParenListExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.ParenListExpr.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.ParenListExpr.__Internal*) _0.__Instance);
                }

                public uint NumExprs
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.ParenListExpr.__Internal*) __Instance)->numExprs;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.ParenListExpr.__Internal*)__Instance)->numExprs = value;
                    }
                }

                public global::CppSharp.Parser.SourceLocation LParenLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.ParenListExpr.__Internal*) __Instance)->lParenLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.ParenListExpr.__Internal*)__Instance)->lParenLoc = value.__Instance;
                    }
                }

                public global::CppSharp.Parser.SourceLocation RParenLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.ParenListExpr.__Internal*) __Instance)->rParenLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.ParenListExpr.__Internal*)__Instance)->rParenLoc = value.__Instance;
                    }
                }
            }

            public unsafe partial class GenericSelectionExpr : global::CppSharp.Parser.AST.Expr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 88)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal uint numAssocs;

                    [FieldOffset(60)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal genericLoc;

                    [FieldOffset(64)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal defaultLoc;

                    [FieldOffset(68)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal rParenLoc;

                    [FieldOffset(72)]
                    internal global::System.IntPtr controllingExpr;

                    [FieldOffset(76)]
                    internal byte isResultDependent;

                    [FieldOffset(80)]
                    internal uint resultIndex;

                    [FieldOffset(84)]
                    internal global::System.IntPtr resultExpr;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0GenericSelectionExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0GenericSelectionExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.GenericSelectionExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.GenericSelectionExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.GenericSelectionExpr __CreateInstance(global::CppSharp.Parser.AST.GenericSelectionExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.GenericSelectionExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.GenericSelectionExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.GenericSelectionExpr.__Internal));
                    *(global::CppSharp.Parser.AST.GenericSelectionExpr.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private GenericSelectionExpr(global::CppSharp.Parser.AST.GenericSelectionExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected GenericSelectionExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public GenericSelectionExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.GenericSelectionExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public GenericSelectionExpr(global::CppSharp.Parser.AST.GenericSelectionExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.GenericSelectionExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.GenericSelectionExpr.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.GenericSelectionExpr.__Internal*) _0.__Instance);
                }

                public uint NumAssocs
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.GenericSelectionExpr.__Internal*) __Instance)->numAssocs;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.GenericSelectionExpr.__Internal*)__Instance)->numAssocs = value;
                    }
                }

                public global::CppSharp.Parser.SourceLocation GenericLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.GenericSelectionExpr.__Internal*) __Instance)->genericLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.GenericSelectionExpr.__Internal*)__Instance)->genericLoc = value.__Instance;
                    }
                }

                public global::CppSharp.Parser.SourceLocation DefaultLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.GenericSelectionExpr.__Internal*) __Instance)->defaultLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.GenericSelectionExpr.__Internal*)__Instance)->defaultLoc = value.__Instance;
                    }
                }

                public global::CppSharp.Parser.SourceLocation RParenLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.GenericSelectionExpr.__Internal*) __Instance)->rParenLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.GenericSelectionExpr.__Internal*)__Instance)->rParenLoc = value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Expr ControllingExpr
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.GenericSelectionExpr.__Internal*) __Instance)->controllingExpr == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.GenericSelectionExpr.__Internal*) __Instance)->controllingExpr))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.GenericSelectionExpr.__Internal*) __Instance)->controllingExpr];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.GenericSelectionExpr.__Internal*) __Instance)->controllingExpr);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.GenericSelectionExpr.__Internal*)__Instance)->controllingExpr = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public bool IsResultDependent
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.GenericSelectionExpr.__Internal*) __Instance)->isResultDependent != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.GenericSelectionExpr.__Internal*)__Instance)->isResultDependent = (byte) (value ? 1 : 0);
                    }
                }

                public uint ResultIndex
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.GenericSelectionExpr.__Internal*) __Instance)->resultIndex;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.GenericSelectionExpr.__Internal*)__Instance)->resultIndex = value;
                    }
                }

                public global::CppSharp.Parser.AST.Expr ResultExpr
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.GenericSelectionExpr.__Internal*) __Instance)->resultExpr == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.GenericSelectionExpr.__Internal*) __Instance)->resultExpr))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.GenericSelectionExpr.__Internal*) __Instance)->resultExpr];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.GenericSelectionExpr.__Internal*) __Instance)->resultExpr);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.GenericSelectionExpr.__Internal*)__Instance)->resultExpr = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }
            }

            public unsafe partial class ExtVectorElementExpr : global::CppSharp.Parser.AST.Expr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 72)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal global::System.IntPtr @base;

                    [FieldOffset(60)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal accessorLoc;

                    [FieldOffset(64)]
                    internal uint numElements;

                    [FieldOffset(68)]
                    internal byte containsDuplicateElements;

                    [FieldOffset(69)]
                    internal byte isArrow;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0ExtVectorElementExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0ExtVectorElementExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.ExtVectorElementExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.ExtVectorElementExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.ExtVectorElementExpr __CreateInstance(global::CppSharp.Parser.AST.ExtVectorElementExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.ExtVectorElementExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.ExtVectorElementExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ExtVectorElementExpr.__Internal));
                    *(global::CppSharp.Parser.AST.ExtVectorElementExpr.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private ExtVectorElementExpr(global::CppSharp.Parser.AST.ExtVectorElementExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected ExtVectorElementExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public ExtVectorElementExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ExtVectorElementExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public ExtVectorElementExpr(global::CppSharp.Parser.AST.ExtVectorElementExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ExtVectorElementExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.ExtVectorElementExpr.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.ExtVectorElementExpr.__Internal*) _0.__Instance);
                }

                public global::CppSharp.Parser.AST.Expr Base
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.ExtVectorElementExpr.__Internal*) __Instance)->@base == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.ExtVectorElementExpr.__Internal*) __Instance)->@base))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.ExtVectorElementExpr.__Internal*) __Instance)->@base];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.ExtVectorElementExpr.__Internal*) __Instance)->@base);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.ExtVectorElementExpr.__Internal*)__Instance)->@base = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.SourceLocation AccessorLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.ExtVectorElementExpr.__Internal*) __Instance)->accessorLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.ExtVectorElementExpr.__Internal*)__Instance)->accessorLoc = value.__Instance;
                    }
                }

                public uint NumElements
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.ExtVectorElementExpr.__Internal*) __Instance)->numElements;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.ExtVectorElementExpr.__Internal*)__Instance)->numElements = value;
                    }
                }

                public bool ContainsDuplicateElements
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.ExtVectorElementExpr.__Internal*) __Instance)->containsDuplicateElements != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.ExtVectorElementExpr.__Internal*)__Instance)->containsDuplicateElements = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsArrow
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.ExtVectorElementExpr.__Internal*) __Instance)->isArrow != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.ExtVectorElementExpr.__Internal*)__Instance)->isArrow = (byte) (value ? 1 : 0);
                    }
                }
            }

            public unsafe partial class BlockExpr : global::CppSharp.Parser.AST.Expr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 64)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal caretLocation;

                    [FieldOffset(60)]
                    internal global::System.IntPtr body;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0BlockExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0BlockExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.BlockExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.BlockExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.BlockExpr __CreateInstance(global::CppSharp.Parser.AST.BlockExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.BlockExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.BlockExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.BlockExpr.__Internal));
                    *(global::CppSharp.Parser.AST.BlockExpr.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private BlockExpr(global::CppSharp.Parser.AST.BlockExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected BlockExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public BlockExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.BlockExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public BlockExpr(global::CppSharp.Parser.AST.BlockExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.BlockExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.BlockExpr.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.BlockExpr.__Internal*) _0.__Instance);
                }

                public global::CppSharp.Parser.SourceLocation CaretLocation
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.BlockExpr.__Internal*) __Instance)->caretLocation);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.BlockExpr.__Internal*)__Instance)->caretLocation = value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Stmt Body
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Stmt __result0;
                        if (((global::CppSharp.Parser.AST.BlockExpr.__Internal*) __Instance)->body == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Stmt.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.BlockExpr.__Internal*) __Instance)->body))
                            __result0 = (global::CppSharp.Parser.AST.Stmt) global::CppSharp.Parser.AST.Stmt.NativeToManagedMap[((global::CppSharp.Parser.AST.BlockExpr.__Internal*) __Instance)->body];
                        else __result0 = global::CppSharp.Parser.AST.Stmt.__CreateInstance(((global::CppSharp.Parser.AST.BlockExpr.__Internal*) __Instance)->body);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.BlockExpr.__Internal*)__Instance)->body = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }
            }

            public unsafe partial class AsTypeExpr : global::CppSharp.Parser.AST.Expr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 68)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal global::System.IntPtr srcExpr;

                    [FieldOffset(60)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal builtinLoc;

                    [FieldOffset(64)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal rParenLoc;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0AsTypeExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0AsTypeExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.AsTypeExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.AsTypeExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.AsTypeExpr __CreateInstance(global::CppSharp.Parser.AST.AsTypeExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.AsTypeExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.AsTypeExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.AsTypeExpr.__Internal));
                    *(global::CppSharp.Parser.AST.AsTypeExpr.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private AsTypeExpr(global::CppSharp.Parser.AST.AsTypeExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected AsTypeExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public AsTypeExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.AsTypeExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public AsTypeExpr(global::CppSharp.Parser.AST.AsTypeExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.AsTypeExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.AsTypeExpr.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.AsTypeExpr.__Internal*) _0.__Instance);
                }

                public global::CppSharp.Parser.AST.Expr SrcExpr
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.AsTypeExpr.__Internal*) __Instance)->srcExpr == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.AsTypeExpr.__Internal*) __Instance)->srcExpr))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.AsTypeExpr.__Internal*) __Instance)->srcExpr];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.AsTypeExpr.__Internal*) __Instance)->srcExpr);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.AsTypeExpr.__Internal*)__Instance)->srcExpr = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.SourceLocation BuiltinLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.AsTypeExpr.__Internal*) __Instance)->builtinLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.AsTypeExpr.__Internal*)__Instance)->builtinLoc = value.__Instance;
                    }
                }

                public global::CppSharp.Parser.SourceLocation RParenLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.AsTypeExpr.__Internal*) __Instance)->rParenLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.AsTypeExpr.__Internal*)__Instance)->rParenLoc = value.__Instance;
                    }
                }
            }

            public unsafe partial class PseudoObjectExpr : global::CppSharp.Parser.AST.Expr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 72)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal global::System.IntPtr syntacticForm;

                    [FieldOffset(60)]
                    internal uint resultExprIndex;

                    [FieldOffset(64)]
                    internal global::System.IntPtr resultExpr;

                    [FieldOffset(68)]
                    internal uint numSemanticExprs;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0PseudoObjectExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0PseudoObjectExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.PseudoObjectExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.PseudoObjectExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.PseudoObjectExpr __CreateInstance(global::CppSharp.Parser.AST.PseudoObjectExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.PseudoObjectExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.PseudoObjectExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.PseudoObjectExpr.__Internal));
                    *(global::CppSharp.Parser.AST.PseudoObjectExpr.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private PseudoObjectExpr(global::CppSharp.Parser.AST.PseudoObjectExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected PseudoObjectExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public PseudoObjectExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.PseudoObjectExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public PseudoObjectExpr(global::CppSharp.Parser.AST.PseudoObjectExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.PseudoObjectExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.PseudoObjectExpr.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.PseudoObjectExpr.__Internal*) _0.__Instance);
                }

                public global::CppSharp.Parser.AST.Expr SyntacticForm
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.PseudoObjectExpr.__Internal*) __Instance)->syntacticForm == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.PseudoObjectExpr.__Internal*) __Instance)->syntacticForm))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.PseudoObjectExpr.__Internal*) __Instance)->syntacticForm];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.PseudoObjectExpr.__Internal*) __Instance)->syntacticForm);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.PseudoObjectExpr.__Internal*)__Instance)->syntacticForm = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public uint ResultExprIndex
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.PseudoObjectExpr.__Internal*) __Instance)->resultExprIndex;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.PseudoObjectExpr.__Internal*)__Instance)->resultExprIndex = value;
                    }
                }

                public global::CppSharp.Parser.AST.Expr ResultExpr
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.PseudoObjectExpr.__Internal*) __Instance)->resultExpr == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.PseudoObjectExpr.__Internal*) __Instance)->resultExpr))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.PseudoObjectExpr.__Internal*) __Instance)->resultExpr];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.PseudoObjectExpr.__Internal*) __Instance)->resultExpr);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.PseudoObjectExpr.__Internal*)__Instance)->resultExpr = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public uint NumSemanticExprs
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.PseudoObjectExpr.__Internal*) __Instance)->numSemanticExprs;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.PseudoObjectExpr.__Internal*)__Instance)->numSemanticExprs = value;
                    }
                }
            }

            public unsafe partial class AtomicExpr : global::CppSharp.Parser.AST.Expr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 112)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal global::System.IntPtr ptr;

                    [FieldOffset(60)]
                    internal global::System.IntPtr order;

                    [FieldOffset(64)]
                    internal global::System.IntPtr scope;

                    [FieldOffset(68)]
                    internal global::System.IntPtr val1;

                    [FieldOffset(72)]
                    internal global::System.IntPtr orderFail;

                    [FieldOffset(76)]
                    internal global::System.IntPtr val2;

                    [FieldOffset(80)]
                    internal global::System.IntPtr weak;

                    [FieldOffset(84)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal valueType;

                    [FieldOffset(92)]
                    internal global::CppSharp.Parser.AST.AtomicExpr.AtomicOp op;

                    [FieldOffset(96)]
                    internal uint numSubExprs;

                    [FieldOffset(100)]
                    internal byte isVolatile;

                    [FieldOffset(101)]
                    internal byte isCmpXChg;

                    [FieldOffset(102)]
                    internal byte isOpenCL;

                    [FieldOffset(104)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal builtinLoc;

                    [FieldOffset(108)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal rParenLoc;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0AtomicExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0AtomicExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                public enum AtomicOp
                {
                    C11AtomicInit = 0,
                    C11AtomicLoad = 1,
                    C11AtomicStore = 2,
                    C11AtomicExchange = 3,
                    C11AtomicCompareExchangeStrong = 4,
                    C11AtomicCompareExchangeWeak = 5,
                    C11AtomicFetchAdd = 6,
                    C11AtomicFetchSub = 7,
                    C11AtomicFetchAnd = 8,
                    C11AtomicFetchOr = 9,
                    C11AtomicFetchXor = 10,
                    AtomicLoad = 11,
                    AtomicLoadN = 12,
                    AtomicStore = 13,
                    AtomicStoreN = 14,
                    AtomicExchange = 15,
                    AtomicExchangeN = 16,
                    AtomicCompareExchange = 17,
                    AtomicCompareExchangeN = 18,
                    AtomicFetchAdd = 19,
                    AtomicFetchSub = 20,
                    AtomicFetchAnd = 21,
                    AtomicFetchOr = 22,
                    AtomicFetchXor = 23,
                    AtomicFetchNand = 24,
                    AtomicAddFetch = 25,
                    AtomicSubFetch = 26,
                    AtomicAndFetch = 27,
                    AtomicOrFetch = 28,
                    AtomicXorFetch = 29,
                    AtomicNandFetch = 30,
                    OpenclAtomicInit = 31,
                    OpenclAtomicLoad = 32,
                    OpenclAtomicStore = 33,
                    OpenclAtomicExchange = 34,
                    OpenclAtomicCompareExchangeStrong = 35,
                    OpenclAtomicCompareExchangeWeak = 36,
                    OpenclAtomicFetchAdd = 37,
                    OpenclAtomicFetchSub = 38,
                    OpenclAtomicFetchAnd = 39,
                    OpenclAtomicFetchOr = 40,
                    OpenclAtomicFetchXor = 41,
                    OpenclAtomicFetchMin = 42,
                    OpenclAtomicFetchMax = 43,
                    AtomicFetchMin = 44,
                    AtomicFetchMax = 45
                }

                internal static new global::CppSharp.Parser.AST.AtomicExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.AtomicExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.AtomicExpr __CreateInstance(global::CppSharp.Parser.AST.AtomicExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.AtomicExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.AtomicExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.AtomicExpr.__Internal));
                    *(global::CppSharp.Parser.AST.AtomicExpr.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private AtomicExpr(global::CppSharp.Parser.AST.AtomicExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected AtomicExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public AtomicExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.AtomicExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public AtomicExpr(global::CppSharp.Parser.AST.AtomicExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.AtomicExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.AtomicExpr.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.AtomicExpr.__Internal*) _0.__Instance);
                }

                public global::CppSharp.Parser.AST.Expr Ptr
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.AtomicExpr.__Internal*) __Instance)->ptr == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.AtomicExpr.__Internal*) __Instance)->ptr))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.AtomicExpr.__Internal*) __Instance)->ptr];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.AtomicExpr.__Internal*) __Instance)->ptr);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.AtomicExpr.__Internal*)__Instance)->ptr = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Expr Order
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.AtomicExpr.__Internal*) __Instance)->order == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.AtomicExpr.__Internal*) __Instance)->order))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.AtomicExpr.__Internal*) __Instance)->order];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.AtomicExpr.__Internal*) __Instance)->order);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.AtomicExpr.__Internal*)__Instance)->order = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Expr Scope
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.AtomicExpr.__Internal*) __Instance)->scope == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.AtomicExpr.__Internal*) __Instance)->scope))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.AtomicExpr.__Internal*) __Instance)->scope];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.AtomicExpr.__Internal*) __Instance)->scope);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.AtomicExpr.__Internal*)__Instance)->scope = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Expr Val1
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.AtomicExpr.__Internal*) __Instance)->val1 == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.AtomicExpr.__Internal*) __Instance)->val1))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.AtomicExpr.__Internal*) __Instance)->val1];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.AtomicExpr.__Internal*) __Instance)->val1);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.AtomicExpr.__Internal*)__Instance)->val1 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Expr OrderFail
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.AtomicExpr.__Internal*) __Instance)->orderFail == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.AtomicExpr.__Internal*) __Instance)->orderFail))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.AtomicExpr.__Internal*) __Instance)->orderFail];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.AtomicExpr.__Internal*) __Instance)->orderFail);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.AtomicExpr.__Internal*)__Instance)->orderFail = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Expr Val2
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.AtomicExpr.__Internal*) __Instance)->val2 == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.AtomicExpr.__Internal*) __Instance)->val2))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.AtomicExpr.__Internal*) __Instance)->val2];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.AtomicExpr.__Internal*) __Instance)->val2);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.AtomicExpr.__Internal*)__Instance)->val2 = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Expr Weak
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.AtomicExpr.__Internal*) __Instance)->weak == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.AtomicExpr.__Internal*) __Instance)->weak))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.AtomicExpr.__Internal*) __Instance)->weak];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.AtomicExpr.__Internal*) __Instance)->weak);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.AtomicExpr.__Internal*)__Instance)->weak = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.QualifiedType ValueType
                {
                    get
                    {
                        return global::CppSharp.Parser.AST.QualifiedType.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.AtomicExpr.__Internal*) __Instance)->valueType));
                    }

                    set
                    {
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                        ((global::CppSharp.Parser.AST.AtomicExpr.__Internal*)__Instance)->valueType = *(global::CppSharp.Parser.AST.QualifiedType.__Internal*) value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.AtomicExpr.AtomicOp Op
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.AtomicExpr.__Internal*) __Instance)->op;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.AtomicExpr.__Internal*)__Instance)->op = value;
                    }
                }

                public uint NumSubExprs
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.AtomicExpr.__Internal*) __Instance)->numSubExprs;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.AtomicExpr.__Internal*)__Instance)->numSubExprs = value;
                    }
                }

                public bool IsVolatile
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.AtomicExpr.__Internal*) __Instance)->isVolatile != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.AtomicExpr.__Internal*)__Instance)->isVolatile = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsCmpXChg
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.AtomicExpr.__Internal*) __Instance)->isCmpXChg != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.AtomicExpr.__Internal*)__Instance)->isCmpXChg = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsOpenCL
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.AtomicExpr.__Internal*) __Instance)->isOpenCL != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.AtomicExpr.__Internal*)__Instance)->isOpenCL = (byte) (value ? 1 : 0);
                    }
                }

                public global::CppSharp.Parser.SourceLocation BuiltinLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.AtomicExpr.__Internal*) __Instance)->builtinLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.AtomicExpr.__Internal*)__Instance)->builtinLoc = value.__Instance;
                    }
                }

                public global::CppSharp.Parser.SourceLocation RParenLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.AtomicExpr.__Internal*) __Instance)->rParenLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.AtomicExpr.__Internal*)__Instance)->rParenLoc = value.__Instance;
                    }
                }
            }

            public unsafe partial class TypoExpr : global::CppSharp.Parser.AST.Expr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 56)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0TypoExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0TypoExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.TypoExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.TypoExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.TypoExpr __CreateInstance(global::CppSharp.Parser.AST.TypoExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.TypoExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.TypoExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TypoExpr.__Internal));
                    *(global::CppSharp.Parser.AST.TypoExpr.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private TypoExpr(global::CppSharp.Parser.AST.TypoExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected TypoExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public TypoExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TypoExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public TypoExpr(global::CppSharp.Parser.AST.TypoExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TypoExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.TypoExpr.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.TypoExpr.__Internal*) _0.__Instance);
                }
            }

            public unsafe partial class CXXOperatorCallExpr : global::CppSharp.Parser.AST.CallExpr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 116)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Expr___N_std_S_allocator__S0_ arguments;

                    [FieldOffset(68)]
                    internal global::System.IntPtr callee;

                    [FieldOffset(72)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal rParenLoc;

                    [FieldOffset(76)]
                    internal global::System.IntPtr calleeDecl;

                    [FieldOffset(80)]
                    internal global::System.IntPtr directCallee;

                    [FieldOffset(84)]
                    internal uint numArgs;

                    [FieldOffset(88)]
                    internal uint numCommas;

                    [FieldOffset(92)]
                    internal uint builtinCallee;

                    [FieldOffset(96)]
                    internal byte isCallToStdMove;

                    [FieldOffset(100)]
                    internal global::CppSharp.Parser.AST.OverloadedOperatorKind _operator;

                    [FieldOffset(104)]
                    internal byte isAssignmentOp;

                    [FieldOffset(105)]
                    internal byte isInfixBinaryOp;

                    [FieldOffset(108)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal operatorLoc;

                    [FieldOffset(112)]
                    internal byte isFPContractableWithinStatement;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CXXOperatorCallExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CXXOperatorCallExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??1CXXOperatorCallExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern void dtor(global::System.IntPtr __instance, int delete);
                }

                internal static new global::CppSharp.Parser.AST.CXXOperatorCallExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CXXOperatorCallExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.CXXOperatorCallExpr __CreateInstance(global::CppSharp.Parser.AST.CXXOperatorCallExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CXXOperatorCallExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.CXXOperatorCallExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXOperatorCallExpr.__Internal));
                    global::CppSharp.Parser.AST.CXXOperatorCallExpr.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private CXXOperatorCallExpr(global::CppSharp.Parser.AST.CXXOperatorCallExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected CXXOperatorCallExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public CXXOperatorCallExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXOperatorCallExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public CXXOperatorCallExpr(global::CppSharp.Parser.AST.CXXOperatorCallExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXOperatorCallExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Stmt __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor(__Instance, 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.OverloadedOperatorKind Operator
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.CXXOperatorCallExpr.__Internal*) __Instance)->_operator;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXOperatorCallExpr.__Internal*)__Instance)->_operator = value;
                    }
                }

                public bool IsAssignmentOp
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.CXXOperatorCallExpr.__Internal*) __Instance)->isAssignmentOp != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXOperatorCallExpr.__Internal*)__Instance)->isAssignmentOp = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsInfixBinaryOp
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.CXXOperatorCallExpr.__Internal*) __Instance)->isInfixBinaryOp != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXOperatorCallExpr.__Internal*)__Instance)->isInfixBinaryOp = (byte) (value ? 1 : 0);
                    }
                }

                public global::CppSharp.Parser.SourceLocation OperatorLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.CXXOperatorCallExpr.__Internal*) __Instance)->operatorLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXOperatorCallExpr.__Internal*)__Instance)->operatorLoc = value.__Instance;
                    }
                }

                public bool IsFPContractableWithinStatement
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.CXXOperatorCallExpr.__Internal*) __Instance)->isFPContractableWithinStatement != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXOperatorCallExpr.__Internal*)__Instance)->isFPContractableWithinStatement = (byte) (value ? 1 : 0);
                    }
                }
            }

            public unsafe partial class CXXMemberCallExpr : global::CppSharp.Parser.AST.CallExpr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 108)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Expr___N_std_S_allocator__S0_ arguments;

                    [FieldOffset(68)]
                    internal global::System.IntPtr callee;

                    [FieldOffset(72)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal rParenLoc;

                    [FieldOffset(76)]
                    internal global::System.IntPtr calleeDecl;

                    [FieldOffset(80)]
                    internal global::System.IntPtr directCallee;

                    [FieldOffset(84)]
                    internal uint numArgs;

                    [FieldOffset(88)]
                    internal uint numCommas;

                    [FieldOffset(92)]
                    internal uint builtinCallee;

                    [FieldOffset(96)]
                    internal byte isCallToStdMove;

                    [FieldOffset(100)]
                    internal global::System.IntPtr implicitObjectArgument;

                    [FieldOffset(104)]
                    internal global::System.IntPtr methodDecl;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CXXMemberCallExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CXXMemberCallExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??1CXXMemberCallExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern void dtor(global::System.IntPtr __instance, int delete);
                }

                internal static new global::CppSharp.Parser.AST.CXXMemberCallExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CXXMemberCallExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.CXXMemberCallExpr __CreateInstance(global::CppSharp.Parser.AST.CXXMemberCallExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CXXMemberCallExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.CXXMemberCallExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXMemberCallExpr.__Internal));
                    global::CppSharp.Parser.AST.CXXMemberCallExpr.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private CXXMemberCallExpr(global::CppSharp.Parser.AST.CXXMemberCallExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected CXXMemberCallExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public CXXMemberCallExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXMemberCallExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public CXXMemberCallExpr(global::CppSharp.Parser.AST.CXXMemberCallExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXMemberCallExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Stmt __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor(__Instance, 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.Expr ImplicitObjectArgument
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.CXXMemberCallExpr.__Internal*) __Instance)->implicitObjectArgument == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.CXXMemberCallExpr.__Internal*) __Instance)->implicitObjectArgument))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.CXXMemberCallExpr.__Internal*) __Instance)->implicitObjectArgument];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.CXXMemberCallExpr.__Internal*) __Instance)->implicitObjectArgument);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXMemberCallExpr.__Internal*)__Instance)->implicitObjectArgument = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Method MethodDecl
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Method __result0;
                        if (((global::CppSharp.Parser.AST.CXXMemberCallExpr.__Internal*) __Instance)->methodDecl == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Method.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.CXXMemberCallExpr.__Internal*) __Instance)->methodDecl))
                            __result0 = (global::CppSharp.Parser.AST.Method) global::CppSharp.Parser.AST.Method.NativeToManagedMap[((global::CppSharp.Parser.AST.CXXMemberCallExpr.__Internal*) __Instance)->methodDecl];
                        else __result0 = global::CppSharp.Parser.AST.Method.__CreateInstance(((global::CppSharp.Parser.AST.CXXMemberCallExpr.__Internal*) __Instance)->methodDecl);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXMemberCallExpr.__Internal*)__Instance)->methodDecl = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }
            }

            public unsafe partial class CUDAKernelCallExpr : global::CppSharp.Parser.AST.CallExpr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 104)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Expr___N_std_S_allocator__S0_ arguments;

                    [FieldOffset(68)]
                    internal global::System.IntPtr callee;

                    [FieldOffset(72)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal rParenLoc;

                    [FieldOffset(76)]
                    internal global::System.IntPtr calleeDecl;

                    [FieldOffset(80)]
                    internal global::System.IntPtr directCallee;

                    [FieldOffset(84)]
                    internal uint numArgs;

                    [FieldOffset(88)]
                    internal uint numCommas;

                    [FieldOffset(92)]
                    internal uint builtinCallee;

                    [FieldOffset(96)]
                    internal byte isCallToStdMove;

                    [FieldOffset(100)]
                    internal global::System.IntPtr config;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CUDAKernelCallExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CUDAKernelCallExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??1CUDAKernelCallExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern void dtor(global::System.IntPtr __instance, int delete);
                }

                internal static new global::CppSharp.Parser.AST.CUDAKernelCallExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CUDAKernelCallExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.CUDAKernelCallExpr __CreateInstance(global::CppSharp.Parser.AST.CUDAKernelCallExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CUDAKernelCallExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.CUDAKernelCallExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CUDAKernelCallExpr.__Internal));
                    global::CppSharp.Parser.AST.CUDAKernelCallExpr.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private CUDAKernelCallExpr(global::CppSharp.Parser.AST.CUDAKernelCallExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected CUDAKernelCallExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public CUDAKernelCallExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CUDAKernelCallExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public CUDAKernelCallExpr(global::CppSharp.Parser.AST.CUDAKernelCallExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CUDAKernelCallExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Stmt __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor(__Instance, 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.CallExpr Config
                {
                    get
                    {
                        global::CppSharp.Parser.AST.CallExpr __result0;
                        if (((global::CppSharp.Parser.AST.CUDAKernelCallExpr.__Internal*) __Instance)->config == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.CallExpr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.CUDAKernelCallExpr.__Internal*) __Instance)->config))
                            __result0 = (global::CppSharp.Parser.AST.CallExpr) global::CppSharp.Parser.AST.CallExpr.NativeToManagedMap[((global::CppSharp.Parser.AST.CUDAKernelCallExpr.__Internal*) __Instance)->config];
                        else __result0 = global::CppSharp.Parser.AST.CallExpr.__CreateInstance(((global::CppSharp.Parser.AST.CUDAKernelCallExpr.__Internal*) __Instance)->config);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CUDAKernelCallExpr.__Internal*)__Instance)->config = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }
            }

            public unsafe partial class CXXNamedCastExpr : global::CppSharp.Parser.AST.ExplicitCastExpr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 112)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal global::CppSharp.Parser.AST.CastKind castKind;

                    [FieldOffset(60)]
                    internal global::System.IntPtr subExpr;

                    [FieldOffset(64)]
                    internal global::System.IntPtr castKindName;

                    [FieldOffset(68)]
                    internal global::System.IntPtr subExprAsWritten;

                    [FieldOffset(72)]
                    internal global::System.IntPtr conversionFunction;

                    [FieldOffset(76)]
                    internal byte path_empty;

                    [FieldOffset(80)]
                    internal uint path_size;

                    [FieldOffset(84)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal typeAsWritten;

                    [FieldOffset(92)]
                    internal global::System.IntPtr castName;

                    [FieldOffset(96)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal operatorLoc;

                    [FieldOffset(100)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal rParenLoc;

                    [FieldOffset(104)]
                    internal global::CppSharp.Parser.SourceRange.__Internal angleBrackets;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CXXNamedCastExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CXXNamedCastExpr@AST@CppParser@CppSharp@@QAE@W4StmtClass@123@@Z")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance, global::CppSharp.Parser.AST.StmtClass klass);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CXXNamedCastExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.CXXNamedCastExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CXXNamedCastExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.CXXNamedCastExpr __CreateInstance(global::CppSharp.Parser.AST.CXXNamedCastExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CXXNamedCastExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.CXXNamedCastExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXNamedCastExpr.__Internal));
                    *(global::CppSharp.Parser.AST.CXXNamedCastExpr.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private CXXNamedCastExpr(global::CppSharp.Parser.AST.CXXNamedCastExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected CXXNamedCastExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public CXXNamedCastExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXNamedCastExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public CXXNamedCastExpr(global::CppSharp.Parser.AST.StmtClass klass)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXNamedCastExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance, klass);
                }

                public CXXNamedCastExpr(global::CppSharp.Parser.AST.CXXNamedCastExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXNamedCastExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.CXXNamedCastExpr.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.CXXNamedCastExpr.__Internal*) _0.__Instance);
                }

                public static implicit operator global::CppSharp.Parser.AST.CXXNamedCastExpr(global::CppSharp.Parser.AST.StmtClass klass)
                {
                    return new global::CppSharp.Parser.AST.CXXNamedCastExpr(klass);
                }

                public string CastName
                {
                    get
                    {
                        if (((global::CppSharp.Parser.AST.CXXNamedCastExpr.__Internal*) __Instance)->castName == global::System.IntPtr.Zero)
                            return default(string);
                        var __retPtr = (byte*) ((global::CppSharp.Parser.AST.CXXNamedCastExpr.__Internal*) __Instance)->castName;
                        int __length = 0;
                        while (*(__retPtr++) != 0) __length += sizeof(byte);
                        return global::System.Text.Encoding.UTF8.GetString((byte*) ((global::CppSharp.Parser.AST.CXXNamedCastExpr.__Internal*) __Instance)->castName, __length);
                    }

                    set
                    {
                        byte[] __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                        fixed (byte* __bytePtr0 = __bytes0)
                        {
                            ((global::CppSharp.Parser.AST.CXXNamedCastExpr.__Internal*)__Instance)->castName = (global::System.IntPtr) new global::System.IntPtr(__bytePtr0);
                        }
                    }
                }

                public global::CppSharp.Parser.SourceLocation OperatorLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.CXXNamedCastExpr.__Internal*) __Instance)->operatorLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXNamedCastExpr.__Internal*)__Instance)->operatorLoc = value.__Instance;
                    }
                }

                public global::CppSharp.Parser.SourceLocation RParenLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.CXXNamedCastExpr.__Internal*) __Instance)->rParenLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXNamedCastExpr.__Internal*)__Instance)->rParenLoc = value.__Instance;
                    }
                }

                public global::CppSharp.Parser.SourceRange AngleBrackets
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceRange.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.CXXNamedCastExpr.__Internal*) __Instance)->angleBrackets));
                    }

                    set
                    {
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                        ((global::CppSharp.Parser.AST.CXXNamedCastExpr.__Internal*)__Instance)->angleBrackets = *(global::CppSharp.Parser.SourceRange.__Internal*) value.__Instance;
                    }
                }
            }

            public unsafe partial class CXXStaticCastExpr : global::CppSharp.Parser.AST.CXXNamedCastExpr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 112)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal global::CppSharp.Parser.AST.CastKind castKind;

                    [FieldOffset(60)]
                    internal global::System.IntPtr subExpr;

                    [FieldOffset(64)]
                    internal global::System.IntPtr castKindName;

                    [FieldOffset(68)]
                    internal global::System.IntPtr subExprAsWritten;

                    [FieldOffset(72)]
                    internal global::System.IntPtr conversionFunction;

                    [FieldOffset(76)]
                    internal byte path_empty;

                    [FieldOffset(80)]
                    internal uint path_size;

                    [FieldOffset(84)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal typeAsWritten;

                    [FieldOffset(92)]
                    internal global::System.IntPtr castName;

                    [FieldOffset(96)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal operatorLoc;

                    [FieldOffset(100)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal rParenLoc;

                    [FieldOffset(104)]
                    internal global::CppSharp.Parser.SourceRange.__Internal angleBrackets;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CXXStaticCastExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CXXStaticCastExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.CXXStaticCastExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CXXStaticCastExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.CXXStaticCastExpr __CreateInstance(global::CppSharp.Parser.AST.CXXStaticCastExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CXXStaticCastExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.CXXStaticCastExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXStaticCastExpr.__Internal));
                    *(global::CppSharp.Parser.AST.CXXStaticCastExpr.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private CXXStaticCastExpr(global::CppSharp.Parser.AST.CXXStaticCastExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected CXXStaticCastExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public CXXStaticCastExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXStaticCastExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public CXXStaticCastExpr(global::CppSharp.Parser.AST.CXXStaticCastExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXStaticCastExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.CXXStaticCastExpr.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.CXXStaticCastExpr.__Internal*) _0.__Instance);
                }
            }

            public unsafe partial class CXXDynamicCastExpr : global::CppSharp.Parser.AST.CXXNamedCastExpr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 116)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal global::CppSharp.Parser.AST.CastKind castKind;

                    [FieldOffset(60)]
                    internal global::System.IntPtr subExpr;

                    [FieldOffset(64)]
                    internal global::System.IntPtr castKindName;

                    [FieldOffset(68)]
                    internal global::System.IntPtr subExprAsWritten;

                    [FieldOffset(72)]
                    internal global::System.IntPtr conversionFunction;

                    [FieldOffset(76)]
                    internal byte path_empty;

                    [FieldOffset(80)]
                    internal uint path_size;

                    [FieldOffset(84)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal typeAsWritten;

                    [FieldOffset(92)]
                    internal global::System.IntPtr castName;

                    [FieldOffset(96)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal operatorLoc;

                    [FieldOffset(100)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal rParenLoc;

                    [FieldOffset(104)]
                    internal global::CppSharp.Parser.SourceRange.__Internal angleBrackets;

                    [FieldOffset(112)]
                    internal byte isAlwaysNull;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CXXDynamicCastExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CXXDynamicCastExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.CXXDynamicCastExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CXXDynamicCastExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.CXXDynamicCastExpr __CreateInstance(global::CppSharp.Parser.AST.CXXDynamicCastExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CXXDynamicCastExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.CXXDynamicCastExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXDynamicCastExpr.__Internal));
                    *(global::CppSharp.Parser.AST.CXXDynamicCastExpr.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private CXXDynamicCastExpr(global::CppSharp.Parser.AST.CXXDynamicCastExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected CXXDynamicCastExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public CXXDynamicCastExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXDynamicCastExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public CXXDynamicCastExpr(global::CppSharp.Parser.AST.CXXDynamicCastExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXDynamicCastExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.CXXDynamicCastExpr.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.CXXDynamicCastExpr.__Internal*) _0.__Instance);
                }

                public bool IsAlwaysNull
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.CXXDynamicCastExpr.__Internal*) __Instance)->isAlwaysNull != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXDynamicCastExpr.__Internal*)__Instance)->isAlwaysNull = (byte) (value ? 1 : 0);
                    }
                }
            }

            public unsafe partial class CXXReinterpretCastExpr : global::CppSharp.Parser.AST.CXXNamedCastExpr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 112)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal global::CppSharp.Parser.AST.CastKind castKind;

                    [FieldOffset(60)]
                    internal global::System.IntPtr subExpr;

                    [FieldOffset(64)]
                    internal global::System.IntPtr castKindName;

                    [FieldOffset(68)]
                    internal global::System.IntPtr subExprAsWritten;

                    [FieldOffset(72)]
                    internal global::System.IntPtr conversionFunction;

                    [FieldOffset(76)]
                    internal byte path_empty;

                    [FieldOffset(80)]
                    internal uint path_size;

                    [FieldOffset(84)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal typeAsWritten;

                    [FieldOffset(92)]
                    internal global::System.IntPtr castName;

                    [FieldOffset(96)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal operatorLoc;

                    [FieldOffset(100)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal rParenLoc;

                    [FieldOffset(104)]
                    internal global::CppSharp.Parser.SourceRange.__Internal angleBrackets;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CXXReinterpretCastExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CXXReinterpretCastExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.CXXReinterpretCastExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CXXReinterpretCastExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.CXXReinterpretCastExpr __CreateInstance(global::CppSharp.Parser.AST.CXXReinterpretCastExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CXXReinterpretCastExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.CXXReinterpretCastExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXReinterpretCastExpr.__Internal));
                    *(global::CppSharp.Parser.AST.CXXReinterpretCastExpr.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private CXXReinterpretCastExpr(global::CppSharp.Parser.AST.CXXReinterpretCastExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected CXXReinterpretCastExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public CXXReinterpretCastExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXReinterpretCastExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public CXXReinterpretCastExpr(global::CppSharp.Parser.AST.CXXReinterpretCastExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXReinterpretCastExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.CXXReinterpretCastExpr.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.CXXReinterpretCastExpr.__Internal*) _0.__Instance);
                }
            }

            public unsafe partial class CXXConstCastExpr : global::CppSharp.Parser.AST.CXXNamedCastExpr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 112)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal global::CppSharp.Parser.AST.CastKind castKind;

                    [FieldOffset(60)]
                    internal global::System.IntPtr subExpr;

                    [FieldOffset(64)]
                    internal global::System.IntPtr castKindName;

                    [FieldOffset(68)]
                    internal global::System.IntPtr subExprAsWritten;

                    [FieldOffset(72)]
                    internal global::System.IntPtr conversionFunction;

                    [FieldOffset(76)]
                    internal byte path_empty;

                    [FieldOffset(80)]
                    internal uint path_size;

                    [FieldOffset(84)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal typeAsWritten;

                    [FieldOffset(92)]
                    internal global::System.IntPtr castName;

                    [FieldOffset(96)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal operatorLoc;

                    [FieldOffset(100)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal rParenLoc;

                    [FieldOffset(104)]
                    internal global::CppSharp.Parser.SourceRange.__Internal angleBrackets;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CXXConstCastExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CXXConstCastExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.CXXConstCastExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CXXConstCastExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.CXXConstCastExpr __CreateInstance(global::CppSharp.Parser.AST.CXXConstCastExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CXXConstCastExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.CXXConstCastExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXConstCastExpr.__Internal));
                    *(global::CppSharp.Parser.AST.CXXConstCastExpr.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private CXXConstCastExpr(global::CppSharp.Parser.AST.CXXConstCastExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected CXXConstCastExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public CXXConstCastExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXConstCastExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public CXXConstCastExpr(global::CppSharp.Parser.AST.CXXConstCastExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXConstCastExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.CXXConstCastExpr.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.CXXConstCastExpr.__Internal*) _0.__Instance);
                }
            }

            public unsafe partial class UserDefinedLiteral : global::CppSharp.Parser.AST.CallExpr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 112)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Expr___N_std_S_allocator__S0_ arguments;

                    [FieldOffset(68)]
                    internal global::System.IntPtr callee;

                    [FieldOffset(72)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal rParenLoc;

                    [FieldOffset(76)]
                    internal global::System.IntPtr calleeDecl;

                    [FieldOffset(80)]
                    internal global::System.IntPtr directCallee;

                    [FieldOffset(84)]
                    internal uint numArgs;

                    [FieldOffset(88)]
                    internal uint numCommas;

                    [FieldOffset(92)]
                    internal uint builtinCallee;

                    [FieldOffset(96)]
                    internal byte isCallToStdMove;

                    [FieldOffset(100)]
                    internal global::CppSharp.Parser.AST.UserDefinedLiteral.LiteralOperatorKind literalOperatorKind;

                    [FieldOffset(104)]
                    internal global::System.IntPtr cookedLiteral;

                    [FieldOffset(108)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal uDSuffixLoc;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0UserDefinedLiteral@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0UserDefinedLiteral@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??1UserDefinedLiteral@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern void dtor(global::System.IntPtr __instance, int delete);
                }

                public enum LiteralOperatorKind
                {
                    Raw = 0,
                    Template = 1,
                    Integer = 2,
                    Floating = 3,
                    String = 4,
                    Character = 5
                }

                internal static new global::CppSharp.Parser.AST.UserDefinedLiteral __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.UserDefinedLiteral(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.UserDefinedLiteral __CreateInstance(global::CppSharp.Parser.AST.UserDefinedLiteral.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.UserDefinedLiteral(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.UserDefinedLiteral.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.UserDefinedLiteral.__Internal));
                    global::CppSharp.Parser.AST.UserDefinedLiteral.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private UserDefinedLiteral(global::CppSharp.Parser.AST.UserDefinedLiteral.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected UserDefinedLiteral(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public UserDefinedLiteral()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.UserDefinedLiteral.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public UserDefinedLiteral(global::CppSharp.Parser.AST.UserDefinedLiteral _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.UserDefinedLiteral.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Stmt __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor(__Instance, 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.UserDefinedLiteral.LiteralOperatorKind literalOperatorKind
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.UserDefinedLiteral.__Internal*) __Instance)->literalOperatorKind;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.UserDefinedLiteral.__Internal*)__Instance)->literalOperatorKind = value;
                    }
                }

                public global::CppSharp.Parser.AST.Expr CookedLiteral
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.UserDefinedLiteral.__Internal*) __Instance)->cookedLiteral == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.UserDefinedLiteral.__Internal*) __Instance)->cookedLiteral))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.UserDefinedLiteral.__Internal*) __Instance)->cookedLiteral];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.UserDefinedLiteral.__Internal*) __Instance)->cookedLiteral);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.UserDefinedLiteral.__Internal*)__Instance)->cookedLiteral = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.SourceLocation UDSuffixLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.UserDefinedLiteral.__Internal*) __Instance)->uDSuffixLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.UserDefinedLiteral.__Internal*)__Instance)->uDSuffixLoc = value.__Instance;
                    }
                }
            }

            public unsafe partial class CXXBoolLiteralExpr : global::CppSharp.Parser.AST.Expr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 64)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal byte value;

                    [FieldOffset(60)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal location;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CXXBoolLiteralExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CXXBoolLiteralExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.CXXBoolLiteralExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CXXBoolLiteralExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.CXXBoolLiteralExpr __CreateInstance(global::CppSharp.Parser.AST.CXXBoolLiteralExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CXXBoolLiteralExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.CXXBoolLiteralExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXBoolLiteralExpr.__Internal));
                    *(global::CppSharp.Parser.AST.CXXBoolLiteralExpr.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private CXXBoolLiteralExpr(global::CppSharp.Parser.AST.CXXBoolLiteralExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected CXXBoolLiteralExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public CXXBoolLiteralExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXBoolLiteralExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public CXXBoolLiteralExpr(global::CppSharp.Parser.AST.CXXBoolLiteralExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXBoolLiteralExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.CXXBoolLiteralExpr.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.CXXBoolLiteralExpr.__Internal*) _0.__Instance);
                }

                public bool Value
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.CXXBoolLiteralExpr.__Internal*) __Instance)->value != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXBoolLiteralExpr.__Internal*)__Instance)->value = (byte) (value ? 1 : 0);
                    }
                }

                public global::CppSharp.Parser.SourceLocation Location
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.CXXBoolLiteralExpr.__Internal*) __Instance)->location);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXBoolLiteralExpr.__Internal*)__Instance)->location = value.__Instance;
                    }
                }
            }

            public unsafe partial class CXXNullPtrLiteralExpr : global::CppSharp.Parser.AST.Expr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 60)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal location;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CXXNullPtrLiteralExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CXXNullPtrLiteralExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.CXXNullPtrLiteralExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CXXNullPtrLiteralExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.CXXNullPtrLiteralExpr __CreateInstance(global::CppSharp.Parser.AST.CXXNullPtrLiteralExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CXXNullPtrLiteralExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.CXXNullPtrLiteralExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXNullPtrLiteralExpr.__Internal));
                    *(global::CppSharp.Parser.AST.CXXNullPtrLiteralExpr.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private CXXNullPtrLiteralExpr(global::CppSharp.Parser.AST.CXXNullPtrLiteralExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected CXXNullPtrLiteralExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public CXXNullPtrLiteralExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXNullPtrLiteralExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public CXXNullPtrLiteralExpr(global::CppSharp.Parser.AST.CXXNullPtrLiteralExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXNullPtrLiteralExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.CXXNullPtrLiteralExpr.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.CXXNullPtrLiteralExpr.__Internal*) _0.__Instance);
                }

                public global::CppSharp.Parser.SourceLocation Location
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.CXXNullPtrLiteralExpr.__Internal*) __Instance)->location);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXNullPtrLiteralExpr.__Internal*)__Instance)->location = value.__Instance;
                    }
                }
            }

            public unsafe partial class CXXStdInitializerListExpr : global::CppSharp.Parser.AST.Expr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 60)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal global::System.IntPtr subExpr;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CXXStdInitializerListExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CXXStdInitializerListExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.CXXStdInitializerListExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CXXStdInitializerListExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.CXXStdInitializerListExpr __CreateInstance(global::CppSharp.Parser.AST.CXXStdInitializerListExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CXXStdInitializerListExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.CXXStdInitializerListExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXStdInitializerListExpr.__Internal));
                    *(global::CppSharp.Parser.AST.CXXStdInitializerListExpr.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private CXXStdInitializerListExpr(global::CppSharp.Parser.AST.CXXStdInitializerListExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected CXXStdInitializerListExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public CXXStdInitializerListExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXStdInitializerListExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public CXXStdInitializerListExpr(global::CppSharp.Parser.AST.CXXStdInitializerListExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXStdInitializerListExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.CXXStdInitializerListExpr.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.CXXStdInitializerListExpr.__Internal*) _0.__Instance);
                }

                public global::CppSharp.Parser.AST.Expr SubExpr
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.CXXStdInitializerListExpr.__Internal*) __Instance)->subExpr == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.CXXStdInitializerListExpr.__Internal*) __Instance)->subExpr))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.CXXStdInitializerListExpr.__Internal*) __Instance)->subExpr];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.CXXStdInitializerListExpr.__Internal*) __Instance)->subExpr);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXStdInitializerListExpr.__Internal*)__Instance)->subExpr = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }
            }

            public unsafe partial class CXXTypeidExpr : global::CppSharp.Parser.AST.Expr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 64)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal global::System.IntPtr exprOperand;

                    [FieldOffset(60)]
                    internal byte isPotentiallyEvaluated;

                    [FieldOffset(61)]
                    internal byte isTypeOperand;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CXXTypeidExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CXXTypeidExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.CXXTypeidExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CXXTypeidExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.CXXTypeidExpr __CreateInstance(global::CppSharp.Parser.AST.CXXTypeidExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CXXTypeidExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.CXXTypeidExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXTypeidExpr.__Internal));
                    *(global::CppSharp.Parser.AST.CXXTypeidExpr.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private CXXTypeidExpr(global::CppSharp.Parser.AST.CXXTypeidExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected CXXTypeidExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public CXXTypeidExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXTypeidExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public CXXTypeidExpr(global::CppSharp.Parser.AST.CXXTypeidExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXTypeidExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.CXXTypeidExpr.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.CXXTypeidExpr.__Internal*) _0.__Instance);
                }

                public global::CppSharp.Parser.AST.Expr ExprOperand
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.CXXTypeidExpr.__Internal*) __Instance)->exprOperand == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.CXXTypeidExpr.__Internal*) __Instance)->exprOperand))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.CXXTypeidExpr.__Internal*) __Instance)->exprOperand];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.CXXTypeidExpr.__Internal*) __Instance)->exprOperand);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXTypeidExpr.__Internal*)__Instance)->exprOperand = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public bool IsPotentiallyEvaluated
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.CXXTypeidExpr.__Internal*) __Instance)->isPotentiallyEvaluated != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXTypeidExpr.__Internal*)__Instance)->isPotentiallyEvaluated = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsTypeOperand
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.CXXTypeidExpr.__Internal*) __Instance)->isTypeOperand != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXTypeidExpr.__Internal*)__Instance)->isTypeOperand = (byte) (value ? 1 : 0);
                    }
                }
            }

            public unsafe partial class MSPropertyRefExpr : global::CppSharp.Parser.AST.Expr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 72)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal byte isImplicitAccess;

                    [FieldOffset(60)]
                    internal global::System.IntPtr baseExpr;

                    [FieldOffset(64)]
                    internal byte isArrow;

                    [FieldOffset(68)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal memberLoc;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0MSPropertyRefExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0MSPropertyRefExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.MSPropertyRefExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.MSPropertyRefExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.MSPropertyRefExpr __CreateInstance(global::CppSharp.Parser.AST.MSPropertyRefExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.MSPropertyRefExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.MSPropertyRefExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.MSPropertyRefExpr.__Internal));
                    *(global::CppSharp.Parser.AST.MSPropertyRefExpr.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private MSPropertyRefExpr(global::CppSharp.Parser.AST.MSPropertyRefExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected MSPropertyRefExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public MSPropertyRefExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.MSPropertyRefExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public MSPropertyRefExpr(global::CppSharp.Parser.AST.MSPropertyRefExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.MSPropertyRefExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.MSPropertyRefExpr.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.MSPropertyRefExpr.__Internal*) _0.__Instance);
                }

                public bool IsImplicitAccess
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.MSPropertyRefExpr.__Internal*) __Instance)->isImplicitAccess != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.MSPropertyRefExpr.__Internal*)__Instance)->isImplicitAccess = (byte) (value ? 1 : 0);
                    }
                }

                public global::CppSharp.Parser.AST.Expr BaseExpr
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.MSPropertyRefExpr.__Internal*) __Instance)->baseExpr == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.MSPropertyRefExpr.__Internal*) __Instance)->baseExpr))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.MSPropertyRefExpr.__Internal*) __Instance)->baseExpr];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.MSPropertyRefExpr.__Internal*) __Instance)->baseExpr);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.MSPropertyRefExpr.__Internal*)__Instance)->baseExpr = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public bool IsArrow
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.MSPropertyRefExpr.__Internal*) __Instance)->isArrow != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.MSPropertyRefExpr.__Internal*)__Instance)->isArrow = (byte) (value ? 1 : 0);
                    }
                }

                public global::CppSharp.Parser.SourceLocation MemberLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.MSPropertyRefExpr.__Internal*) __Instance)->memberLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.MSPropertyRefExpr.__Internal*)__Instance)->memberLoc = value.__Instance;
                    }
                }
            }

            public unsafe partial class MSPropertySubscriptExpr : global::CppSharp.Parser.AST.Expr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 68)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal rBracketLoc;

                    [FieldOffset(60)]
                    internal global::System.IntPtr @base;

                    [FieldOffset(64)]
                    internal global::System.IntPtr idx;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0MSPropertySubscriptExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0MSPropertySubscriptExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.MSPropertySubscriptExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.MSPropertySubscriptExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.MSPropertySubscriptExpr __CreateInstance(global::CppSharp.Parser.AST.MSPropertySubscriptExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.MSPropertySubscriptExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.MSPropertySubscriptExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.MSPropertySubscriptExpr.__Internal));
                    *(global::CppSharp.Parser.AST.MSPropertySubscriptExpr.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private MSPropertySubscriptExpr(global::CppSharp.Parser.AST.MSPropertySubscriptExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected MSPropertySubscriptExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public MSPropertySubscriptExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.MSPropertySubscriptExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public MSPropertySubscriptExpr(global::CppSharp.Parser.AST.MSPropertySubscriptExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.MSPropertySubscriptExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.MSPropertySubscriptExpr.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.MSPropertySubscriptExpr.__Internal*) _0.__Instance);
                }

                public global::CppSharp.Parser.SourceLocation RBracketLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.MSPropertySubscriptExpr.__Internal*) __Instance)->rBracketLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.MSPropertySubscriptExpr.__Internal*)__Instance)->rBracketLoc = value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Expr Base
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.MSPropertySubscriptExpr.__Internal*) __Instance)->@base == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.MSPropertySubscriptExpr.__Internal*) __Instance)->@base))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.MSPropertySubscriptExpr.__Internal*) __Instance)->@base];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.MSPropertySubscriptExpr.__Internal*) __Instance)->@base);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.MSPropertySubscriptExpr.__Internal*)__Instance)->@base = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Expr Idx
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.MSPropertySubscriptExpr.__Internal*) __Instance)->idx == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.MSPropertySubscriptExpr.__Internal*) __Instance)->idx))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.MSPropertySubscriptExpr.__Internal*) __Instance)->idx];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.MSPropertySubscriptExpr.__Internal*) __Instance)->idx);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.MSPropertySubscriptExpr.__Internal*)__Instance)->idx = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }
            }

            public unsafe partial class CXXUuidofExpr : global::CppSharp.Parser.AST.Expr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 88)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal global::System.IntPtr exprOperand;

                    [FieldOffset(60)]
                    internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C uuidStr;

                    [FieldOffset(84)]
                    internal byte isTypeOperand;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CXXUuidofExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CXXUuidofExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??1CXXUuidofExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern void dtor(global::System.IntPtr __instance, int delete);
                }

                internal static new global::CppSharp.Parser.AST.CXXUuidofExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CXXUuidofExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.CXXUuidofExpr __CreateInstance(global::CppSharp.Parser.AST.CXXUuidofExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CXXUuidofExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.CXXUuidofExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXUuidofExpr.__Internal));
                    global::CppSharp.Parser.AST.CXXUuidofExpr.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private CXXUuidofExpr(global::CppSharp.Parser.AST.CXXUuidofExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected CXXUuidofExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public CXXUuidofExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXUuidofExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public CXXUuidofExpr(global::CppSharp.Parser.AST.CXXUuidofExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXUuidofExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Stmt __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor(__Instance, 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.Expr ExprOperand
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.CXXUuidofExpr.__Internal*) __Instance)->exprOperand == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.CXXUuidofExpr.__Internal*) __Instance)->exprOperand))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.CXXUuidofExpr.__Internal*) __Instance)->exprOperand];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.CXXUuidofExpr.__Internal*) __Instance)->exprOperand);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXUuidofExpr.__Internal*)__Instance)->exprOperand = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public string UuidStr
                {
                    get
                    {
                        var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.CXXUuidofExpr.__Internal*) __Instance)->uuidStr));
                        return global::Std.BasicStringExtensions.Data(__basicStringRet0);
                    }

                    set
                    {
                        global::Std.BasicStringExtensions.__Internal.Assign(new global::System.IntPtr(&((global::CppSharp.Parser.AST.CXXUuidofExpr.__Internal*)__Instance)->uuidStr), value);
                    }
                }

                public bool IsTypeOperand
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.CXXUuidofExpr.__Internal*) __Instance)->isTypeOperand != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXUuidofExpr.__Internal*)__Instance)->isTypeOperand = (byte) (value ? 1 : 0);
                    }
                }
            }

            public unsafe partial class CXXThisExpr : global::CppSharp.Parser.AST.Expr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 64)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal location;

                    [FieldOffset(60)]
                    internal byte @implicit;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CXXThisExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CXXThisExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.CXXThisExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CXXThisExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.CXXThisExpr __CreateInstance(global::CppSharp.Parser.AST.CXXThisExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CXXThisExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.CXXThisExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXThisExpr.__Internal));
                    *(global::CppSharp.Parser.AST.CXXThisExpr.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private CXXThisExpr(global::CppSharp.Parser.AST.CXXThisExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected CXXThisExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public CXXThisExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXThisExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public CXXThisExpr(global::CppSharp.Parser.AST.CXXThisExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXThisExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.CXXThisExpr.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.CXXThisExpr.__Internal*) _0.__Instance);
                }

                public global::CppSharp.Parser.SourceLocation Location
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.CXXThisExpr.__Internal*) __Instance)->location);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXThisExpr.__Internal*)__Instance)->location = value.__Instance;
                    }
                }

                public bool Implicit
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.CXXThisExpr.__Internal*) __Instance)->@implicit != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXThisExpr.__Internal*)__Instance)->@implicit = (byte) (value ? 1 : 0);
                    }
                }
            }

            public unsafe partial class CXXThrowExpr : global::CppSharp.Parser.AST.Expr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 68)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal global::System.IntPtr subExpr;

                    [FieldOffset(60)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal throwLoc;

                    [FieldOffset(64)]
                    internal byte isThrownVariableInScope;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CXXThrowExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CXXThrowExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.CXXThrowExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CXXThrowExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.CXXThrowExpr __CreateInstance(global::CppSharp.Parser.AST.CXXThrowExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CXXThrowExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.CXXThrowExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXThrowExpr.__Internal));
                    *(global::CppSharp.Parser.AST.CXXThrowExpr.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private CXXThrowExpr(global::CppSharp.Parser.AST.CXXThrowExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected CXXThrowExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public CXXThrowExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXThrowExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public CXXThrowExpr(global::CppSharp.Parser.AST.CXXThrowExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXThrowExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.CXXThrowExpr.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.CXXThrowExpr.__Internal*) _0.__Instance);
                }

                public global::CppSharp.Parser.AST.Expr SubExpr
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.CXXThrowExpr.__Internal*) __Instance)->subExpr == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.CXXThrowExpr.__Internal*) __Instance)->subExpr))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.CXXThrowExpr.__Internal*) __Instance)->subExpr];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.CXXThrowExpr.__Internal*) __Instance)->subExpr);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXThrowExpr.__Internal*)__Instance)->subExpr = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.SourceLocation ThrowLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.CXXThrowExpr.__Internal*) __Instance)->throwLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXThrowExpr.__Internal*)__Instance)->throwLoc = value.__Instance;
                    }
                }

                public bool IsThrownVariableInScope
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.CXXThrowExpr.__Internal*) __Instance)->isThrownVariableInScope != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXThrowExpr.__Internal*)__Instance)->isThrownVariableInScope = (byte) (value ? 1 : 0);
                    }
                }
            }

            public unsafe partial class CXXDefaultArgExpr : global::CppSharp.Parser.AST.Expr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 64)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal global::System.IntPtr expr;

                    [FieldOffset(60)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal usedLocation;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CXXDefaultArgExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CXXDefaultArgExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.CXXDefaultArgExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CXXDefaultArgExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.CXXDefaultArgExpr __CreateInstance(global::CppSharp.Parser.AST.CXXDefaultArgExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CXXDefaultArgExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.CXXDefaultArgExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXDefaultArgExpr.__Internal));
                    *(global::CppSharp.Parser.AST.CXXDefaultArgExpr.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private CXXDefaultArgExpr(global::CppSharp.Parser.AST.CXXDefaultArgExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected CXXDefaultArgExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public CXXDefaultArgExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXDefaultArgExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public CXXDefaultArgExpr(global::CppSharp.Parser.AST.CXXDefaultArgExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXDefaultArgExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.CXXDefaultArgExpr.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.CXXDefaultArgExpr.__Internal*) _0.__Instance);
                }

                public global::CppSharp.Parser.AST.Expr Expr
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.CXXDefaultArgExpr.__Internal*) __Instance)->expr == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.CXXDefaultArgExpr.__Internal*) __Instance)->expr))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.CXXDefaultArgExpr.__Internal*) __Instance)->expr];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.CXXDefaultArgExpr.__Internal*) __Instance)->expr);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXDefaultArgExpr.__Internal*)__Instance)->expr = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.SourceLocation UsedLocation
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.CXXDefaultArgExpr.__Internal*) __Instance)->usedLocation);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXDefaultArgExpr.__Internal*)__Instance)->usedLocation = value.__Instance;
                    }
                }
            }

            public unsafe partial class CXXDefaultInitExpr : global::CppSharp.Parser.AST.Expr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 64)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal global::System.IntPtr field;

                    [FieldOffset(60)]
                    internal global::System.IntPtr expr;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CXXDefaultInitExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CXXDefaultInitExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.CXXDefaultInitExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CXXDefaultInitExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.CXXDefaultInitExpr __CreateInstance(global::CppSharp.Parser.AST.CXXDefaultInitExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CXXDefaultInitExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.CXXDefaultInitExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXDefaultInitExpr.__Internal));
                    *(global::CppSharp.Parser.AST.CXXDefaultInitExpr.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private CXXDefaultInitExpr(global::CppSharp.Parser.AST.CXXDefaultInitExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected CXXDefaultInitExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public CXXDefaultInitExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXDefaultInitExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public CXXDefaultInitExpr(global::CppSharp.Parser.AST.CXXDefaultInitExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXDefaultInitExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.CXXDefaultInitExpr.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.CXXDefaultInitExpr.__Internal*) _0.__Instance);
                }

                public global::CppSharp.Parser.AST.Field Field
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Field __result0;
                        if (((global::CppSharp.Parser.AST.CXXDefaultInitExpr.__Internal*) __Instance)->field == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Field.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.CXXDefaultInitExpr.__Internal*) __Instance)->field))
                            __result0 = (global::CppSharp.Parser.AST.Field) global::CppSharp.Parser.AST.Field.NativeToManagedMap[((global::CppSharp.Parser.AST.CXXDefaultInitExpr.__Internal*) __Instance)->field];
                        else __result0 = global::CppSharp.Parser.AST.Field.__CreateInstance(((global::CppSharp.Parser.AST.CXXDefaultInitExpr.__Internal*) __Instance)->field);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXDefaultInitExpr.__Internal*)__Instance)->field = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Expr Expr
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.CXXDefaultInitExpr.__Internal*) __Instance)->expr == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.CXXDefaultInitExpr.__Internal*) __Instance)->expr))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.CXXDefaultInitExpr.__Internal*) __Instance)->expr];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.CXXDefaultInitExpr.__Internal*) __Instance)->expr);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXDefaultInitExpr.__Internal*)__Instance)->expr = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }
            }

            public unsafe partial class CXXBindTemporaryExpr : global::CppSharp.Parser.AST.Expr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 60)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal global::System.IntPtr subExpr;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CXXBindTemporaryExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CXXBindTemporaryExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.CXXBindTemporaryExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CXXBindTemporaryExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.CXXBindTemporaryExpr __CreateInstance(global::CppSharp.Parser.AST.CXXBindTemporaryExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CXXBindTemporaryExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.CXXBindTemporaryExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXBindTemporaryExpr.__Internal));
                    *(global::CppSharp.Parser.AST.CXXBindTemporaryExpr.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private CXXBindTemporaryExpr(global::CppSharp.Parser.AST.CXXBindTemporaryExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected CXXBindTemporaryExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public CXXBindTemporaryExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXBindTemporaryExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public CXXBindTemporaryExpr(global::CppSharp.Parser.AST.CXXBindTemporaryExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXBindTemporaryExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.CXXBindTemporaryExpr.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.CXXBindTemporaryExpr.__Internal*) _0.__Instance);
                }

                public global::CppSharp.Parser.AST.Expr SubExpr
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.CXXBindTemporaryExpr.__Internal*) __Instance)->subExpr == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.CXXBindTemporaryExpr.__Internal*) __Instance)->subExpr))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.CXXBindTemporaryExpr.__Internal*) __Instance)->subExpr];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.CXXBindTemporaryExpr.__Internal*) __Instance)->subExpr);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXBindTemporaryExpr.__Internal*)__Instance)->subExpr = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }
            }

            public unsafe partial class CXXConstructExpr : global::CppSharp.Parser.AST.Expr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 92)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Expr___N_std_S_allocator__S0_ arguments;

                    [FieldOffset(68)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal location;

                    [FieldOffset(72)]
                    internal byte elidable;

                    [FieldOffset(73)]
                    internal byte hadMultipleCandidates;

                    [FieldOffset(74)]
                    internal byte listInitialization;

                    [FieldOffset(75)]
                    internal byte stdInitListInitialization;

                    [FieldOffset(76)]
                    internal byte requiresZeroInitialization;

                    [FieldOffset(80)]
                    internal global::CppSharp.Parser.SourceRange.__Internal parenOrBraceRange;

                    [FieldOffset(88)]
                    internal uint numArgs;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CXXConstructExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CXXConstructExpr@AST@CppParser@CppSharp@@QAE@W4StmtClass@123@@Z")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance, global::CppSharp.Parser.AST.StmtClass klass);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CXXConstructExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??1CXXConstructExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern void dtor(global::System.IntPtr __instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getarguments@CXXConstructExpr@AST@CppParser@CppSharp@@QAEPAVExpr@234@I@Z")]
                    internal static extern global::System.IntPtr Getarguments(global::System.IntPtr __instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?addarguments@CXXConstructExpr@AST@CppParser@CppSharp@@QAEXAAPAVExpr@234@@Z")]
                    internal static extern void Addarguments(global::System.IntPtr __instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?cleararguments@CXXConstructExpr@AST@CppParser@CppSharp@@QAEXXZ")]
                    internal static extern void Cleararguments(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getargumentsCount@CXXConstructExpr@AST@CppParser@CppSharp@@QAEIXZ")]
                    internal static extern uint GetargumentsCount(global::System.IntPtr __instance);
                }

                public enum ConstructionKind
                {
                    Complete = 0,
                    NonVirtualBase = 1,
                    VirtualBase = 2,
                    Delegating = 3
                }

                internal static new global::CppSharp.Parser.AST.CXXConstructExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CXXConstructExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.CXXConstructExpr __CreateInstance(global::CppSharp.Parser.AST.CXXConstructExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CXXConstructExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.CXXConstructExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXConstructExpr.__Internal));
                    global::CppSharp.Parser.AST.CXXConstructExpr.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private CXXConstructExpr(global::CppSharp.Parser.AST.CXXConstructExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected CXXConstructExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public CXXConstructExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXConstructExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public CXXConstructExpr(global::CppSharp.Parser.AST.StmtClass klass)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXConstructExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance, klass);
                }

                public CXXConstructExpr(global::CppSharp.Parser.AST.CXXConstructExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXConstructExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Stmt __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor(__Instance, 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.Expr Getarguments(uint i)
                {
                    var __ret = __Internal.Getarguments(__Instance, i);
                    global::CppSharp.Parser.AST.Expr __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[__ret];
                    else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(__ret);
                    return __result0;
                }

                public void Addarguments(global::CppSharp.Parser.AST.Expr s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var ____arg0 = s.__Instance;
                    var __arg0 = new global::System.IntPtr(&____arg0);
                    __Internal.Addarguments(__Instance, __arg0);
                }

                public void Cleararguments()
                {
                    __Internal.Cleararguments(__Instance);
                }

                public static implicit operator global::CppSharp.Parser.AST.CXXConstructExpr(global::CppSharp.Parser.AST.StmtClass klass)
                {
                    return new global::CppSharp.Parser.AST.CXXConstructExpr(klass);
                }

                public global::CppSharp.Parser.SourceLocation Location
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.CXXConstructExpr.__Internal*) __Instance)->location);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXConstructExpr.__Internal*)__Instance)->location = value.__Instance;
                    }
                }

                public bool Elidable
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.CXXConstructExpr.__Internal*) __Instance)->elidable != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXConstructExpr.__Internal*)__Instance)->elidable = (byte) (value ? 1 : 0);
                    }
                }

                public bool HadMultipleCandidates
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.CXXConstructExpr.__Internal*) __Instance)->hadMultipleCandidates != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXConstructExpr.__Internal*)__Instance)->hadMultipleCandidates = (byte) (value ? 1 : 0);
                    }
                }

                public bool ListInitialization
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.CXXConstructExpr.__Internal*) __Instance)->listInitialization != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXConstructExpr.__Internal*)__Instance)->listInitialization = (byte) (value ? 1 : 0);
                    }
                }

                public bool StdInitListInitialization
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.CXXConstructExpr.__Internal*) __Instance)->stdInitListInitialization != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXConstructExpr.__Internal*)__Instance)->stdInitListInitialization = (byte) (value ? 1 : 0);
                    }
                }

                public bool RequiresZeroInitialization
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.CXXConstructExpr.__Internal*) __Instance)->requiresZeroInitialization != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXConstructExpr.__Internal*)__Instance)->requiresZeroInitialization = (byte) (value ? 1 : 0);
                    }
                }

                public global::CppSharp.Parser.SourceRange ParenOrBraceRange
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceRange.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.CXXConstructExpr.__Internal*) __Instance)->parenOrBraceRange));
                    }

                    set
                    {
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                        ((global::CppSharp.Parser.AST.CXXConstructExpr.__Internal*)__Instance)->parenOrBraceRange = *(global::CppSharp.Parser.SourceRange.__Internal*) value.__Instance;
                    }
                }

                public uint NumArgs
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.CXXConstructExpr.__Internal*) __Instance)->numArgs;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXConstructExpr.__Internal*)__Instance)->numArgs = value;
                    }
                }

                public uint GetargumentsCount
                {
                    get
                    {
                        var __ret = __Internal.GetargumentsCount(__Instance);
                        return __ret;
                    }
                }
            }

            public unsafe partial class CXXInheritedCtorInitExpr : global::CppSharp.Parser.AST.Expr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 64)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal byte constructsVBase;

                    [FieldOffset(57)]
                    internal byte inheritedFromVBase;

                    [FieldOffset(60)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal location;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CXXInheritedCtorInitExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CXXInheritedCtorInitExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.CXXInheritedCtorInitExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CXXInheritedCtorInitExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.CXXInheritedCtorInitExpr __CreateInstance(global::CppSharp.Parser.AST.CXXInheritedCtorInitExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CXXInheritedCtorInitExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.CXXInheritedCtorInitExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXInheritedCtorInitExpr.__Internal));
                    *(global::CppSharp.Parser.AST.CXXInheritedCtorInitExpr.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private CXXInheritedCtorInitExpr(global::CppSharp.Parser.AST.CXXInheritedCtorInitExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected CXXInheritedCtorInitExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public CXXInheritedCtorInitExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXInheritedCtorInitExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public CXXInheritedCtorInitExpr(global::CppSharp.Parser.AST.CXXInheritedCtorInitExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXInheritedCtorInitExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.CXXInheritedCtorInitExpr.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.CXXInheritedCtorInitExpr.__Internal*) _0.__Instance);
                }

                public bool ConstructsVBase
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.CXXInheritedCtorInitExpr.__Internal*) __Instance)->constructsVBase != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXInheritedCtorInitExpr.__Internal*)__Instance)->constructsVBase = (byte) (value ? 1 : 0);
                    }
                }

                public bool InheritedFromVBase
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.CXXInheritedCtorInitExpr.__Internal*) __Instance)->inheritedFromVBase != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXInheritedCtorInitExpr.__Internal*)__Instance)->inheritedFromVBase = (byte) (value ? 1 : 0);
                    }
                }

                public global::CppSharp.Parser.SourceLocation Location
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.CXXInheritedCtorInitExpr.__Internal*) __Instance)->location);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXInheritedCtorInitExpr.__Internal*)__Instance)->location = value.__Instance;
                    }
                }
            }

            public unsafe partial class CXXFunctionalCastExpr : global::CppSharp.Parser.AST.ExplicitCastExpr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 104)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal global::CppSharp.Parser.AST.CastKind castKind;

                    [FieldOffset(60)]
                    internal global::System.IntPtr subExpr;

                    [FieldOffset(64)]
                    internal global::System.IntPtr castKindName;

                    [FieldOffset(68)]
                    internal global::System.IntPtr subExprAsWritten;

                    [FieldOffset(72)]
                    internal global::System.IntPtr conversionFunction;

                    [FieldOffset(76)]
                    internal byte path_empty;

                    [FieldOffset(80)]
                    internal uint path_size;

                    [FieldOffset(84)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal typeAsWritten;

                    [FieldOffset(92)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal lParenLoc;

                    [FieldOffset(96)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal rParenLoc;

                    [FieldOffset(100)]
                    internal byte isListInitialization;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CXXFunctionalCastExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CXXFunctionalCastExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.CXXFunctionalCastExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CXXFunctionalCastExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.CXXFunctionalCastExpr __CreateInstance(global::CppSharp.Parser.AST.CXXFunctionalCastExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CXXFunctionalCastExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.CXXFunctionalCastExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXFunctionalCastExpr.__Internal));
                    *(global::CppSharp.Parser.AST.CXXFunctionalCastExpr.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private CXXFunctionalCastExpr(global::CppSharp.Parser.AST.CXXFunctionalCastExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected CXXFunctionalCastExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public CXXFunctionalCastExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXFunctionalCastExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public CXXFunctionalCastExpr(global::CppSharp.Parser.AST.CXXFunctionalCastExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXFunctionalCastExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.CXXFunctionalCastExpr.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.CXXFunctionalCastExpr.__Internal*) _0.__Instance);
                }

                public global::CppSharp.Parser.SourceLocation LParenLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.CXXFunctionalCastExpr.__Internal*) __Instance)->lParenLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXFunctionalCastExpr.__Internal*)__Instance)->lParenLoc = value.__Instance;
                    }
                }

                public global::CppSharp.Parser.SourceLocation RParenLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.CXXFunctionalCastExpr.__Internal*) __Instance)->rParenLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXFunctionalCastExpr.__Internal*)__Instance)->rParenLoc = value.__Instance;
                    }
                }

                public bool IsListInitialization
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.CXXFunctionalCastExpr.__Internal*) __Instance)->isListInitialization != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXFunctionalCastExpr.__Internal*)__Instance)->isListInitialization = (byte) (value ? 1 : 0);
                    }
                }
            }

            public unsafe partial class CXXTemporaryObjectExpr : global::CppSharp.Parser.AST.CXXConstructExpr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 92)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Expr___N_std_S_allocator__S0_ arguments;

                    [FieldOffset(68)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal location;

                    [FieldOffset(72)]
                    internal byte elidable;

                    [FieldOffset(73)]
                    internal byte hadMultipleCandidates;

                    [FieldOffset(74)]
                    internal byte listInitialization;

                    [FieldOffset(75)]
                    internal byte stdInitListInitialization;

                    [FieldOffset(76)]
                    internal byte requiresZeroInitialization;

                    [FieldOffset(80)]
                    internal global::CppSharp.Parser.SourceRange.__Internal parenOrBraceRange;

                    [FieldOffset(88)]
                    internal uint numArgs;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CXXTemporaryObjectExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CXXTemporaryObjectExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??1CXXTemporaryObjectExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern void dtor(global::System.IntPtr __instance, int delete);
                }

                internal static new global::CppSharp.Parser.AST.CXXTemporaryObjectExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CXXTemporaryObjectExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.CXXTemporaryObjectExpr __CreateInstance(global::CppSharp.Parser.AST.CXXTemporaryObjectExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CXXTemporaryObjectExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.CXXTemporaryObjectExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXTemporaryObjectExpr.__Internal));
                    global::CppSharp.Parser.AST.CXXTemporaryObjectExpr.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private CXXTemporaryObjectExpr(global::CppSharp.Parser.AST.CXXTemporaryObjectExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected CXXTemporaryObjectExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public CXXTemporaryObjectExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXTemporaryObjectExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public CXXTemporaryObjectExpr(global::CppSharp.Parser.AST.CXXTemporaryObjectExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXTemporaryObjectExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Stmt __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor(__Instance, 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }
            }

            public unsafe partial class LambdaExpr : global::CppSharp.Parser.AST.Expr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 100)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Expr___N_std_S_allocator__S0_ capture_inits;

                    [FieldOffset(68)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal captureDefaultLoc;

                    [FieldOffset(72)]
                    internal uint capture_size;

                    [FieldOffset(76)]
                    internal global::CppSharp.Parser.SourceRange.__Internal introducerRange;

                    [FieldOffset(84)]
                    internal global::System.IntPtr callOperator;

                    [FieldOffset(88)]
                    internal byte isGenericLambda;

                    [FieldOffset(92)]
                    internal global::System.IntPtr body;

                    [FieldOffset(96)]
                    internal byte isMutable;

                    [FieldOffset(97)]
                    internal byte hasExplicitParameters;

                    [FieldOffset(98)]
                    internal byte hasExplicitResultType;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0LambdaExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0LambdaExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??1LambdaExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern void dtor(global::System.IntPtr __instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getcapture_inits@LambdaExpr@AST@CppParser@CppSharp@@QAEPAVExpr@234@I@Z")]
                    internal static extern global::System.IntPtr GetcaptureInits(global::System.IntPtr __instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?addcapture_inits@LambdaExpr@AST@CppParser@CppSharp@@QAEXAAPAVExpr@234@@Z")]
                    internal static extern void AddcaptureInits(global::System.IntPtr __instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?clearcapture_inits@LambdaExpr@AST@CppParser@CppSharp@@QAEXXZ")]
                    internal static extern void ClearcaptureInits(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getcapture_initsCount@LambdaExpr@AST@CppParser@CppSharp@@QAEIXZ")]
                    internal static extern uint GetcaptureInitsCount(global::System.IntPtr __instance);
                }

                internal static new global::CppSharp.Parser.AST.LambdaExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.LambdaExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.LambdaExpr __CreateInstance(global::CppSharp.Parser.AST.LambdaExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.LambdaExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.LambdaExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.LambdaExpr.__Internal));
                    global::CppSharp.Parser.AST.LambdaExpr.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private LambdaExpr(global::CppSharp.Parser.AST.LambdaExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected LambdaExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public LambdaExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.LambdaExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public LambdaExpr(global::CppSharp.Parser.AST.LambdaExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.LambdaExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Stmt __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor(__Instance, 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.Expr GetcaptureInits(uint i)
                {
                    var __ret = __Internal.GetcaptureInits(__Instance, i);
                    global::CppSharp.Parser.AST.Expr __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[__ret];
                    else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(__ret);
                    return __result0;
                }

                public void AddcaptureInits(global::CppSharp.Parser.AST.Expr s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var ____arg0 = s.__Instance;
                    var __arg0 = new global::System.IntPtr(&____arg0);
                    __Internal.AddcaptureInits(__Instance, __arg0);
                }

                public void ClearcaptureInits()
                {
                    __Internal.ClearcaptureInits(__Instance);
                }

                public global::CppSharp.Parser.SourceLocation CaptureDefaultLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.LambdaExpr.__Internal*) __Instance)->captureDefaultLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.LambdaExpr.__Internal*)__Instance)->captureDefaultLoc = value.__Instance;
                    }
                }

                public uint CaptureSize
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.LambdaExpr.__Internal*) __Instance)->capture_size;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.LambdaExpr.__Internal*)__Instance)->capture_size = value;
                    }
                }

                public global::CppSharp.Parser.SourceRange IntroducerRange
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceRange.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.LambdaExpr.__Internal*) __Instance)->introducerRange));
                    }

                    set
                    {
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                        ((global::CppSharp.Parser.AST.LambdaExpr.__Internal*)__Instance)->introducerRange = *(global::CppSharp.Parser.SourceRange.__Internal*) value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Method CallOperator
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Method __result0;
                        if (((global::CppSharp.Parser.AST.LambdaExpr.__Internal*) __Instance)->callOperator == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Method.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.LambdaExpr.__Internal*) __Instance)->callOperator))
                            __result0 = (global::CppSharp.Parser.AST.Method) global::CppSharp.Parser.AST.Method.NativeToManagedMap[((global::CppSharp.Parser.AST.LambdaExpr.__Internal*) __Instance)->callOperator];
                        else __result0 = global::CppSharp.Parser.AST.Method.__CreateInstance(((global::CppSharp.Parser.AST.LambdaExpr.__Internal*) __Instance)->callOperator);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.LambdaExpr.__Internal*)__Instance)->callOperator = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public bool IsGenericLambda
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.LambdaExpr.__Internal*) __Instance)->isGenericLambda != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.LambdaExpr.__Internal*)__Instance)->isGenericLambda = (byte) (value ? 1 : 0);
                    }
                }

                public global::CppSharp.Parser.AST.CompoundStmt Body
                {
                    get
                    {
                        global::CppSharp.Parser.AST.CompoundStmt __result0;
                        if (((global::CppSharp.Parser.AST.LambdaExpr.__Internal*) __Instance)->body == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.CompoundStmt.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.LambdaExpr.__Internal*) __Instance)->body))
                            __result0 = (global::CppSharp.Parser.AST.CompoundStmt) global::CppSharp.Parser.AST.CompoundStmt.NativeToManagedMap[((global::CppSharp.Parser.AST.LambdaExpr.__Internal*) __Instance)->body];
                        else __result0 = global::CppSharp.Parser.AST.CompoundStmt.__CreateInstance(((global::CppSharp.Parser.AST.LambdaExpr.__Internal*) __Instance)->body);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.LambdaExpr.__Internal*)__Instance)->body = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public bool IsMutable
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.LambdaExpr.__Internal*) __Instance)->isMutable != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.LambdaExpr.__Internal*)__Instance)->isMutable = (byte) (value ? 1 : 0);
                    }
                }

                public bool HasExplicitParameters
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.LambdaExpr.__Internal*) __Instance)->hasExplicitParameters != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.LambdaExpr.__Internal*)__Instance)->hasExplicitParameters = (byte) (value ? 1 : 0);
                    }
                }

                public bool HasExplicitResultType
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.LambdaExpr.__Internal*) __Instance)->hasExplicitResultType != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.LambdaExpr.__Internal*)__Instance)->hasExplicitResultType = (byte) (value ? 1 : 0);
                    }
                }

                public uint GetcaptureInitsCount
                {
                    get
                    {
                        var __ret = __Internal.GetcaptureInitsCount(__Instance);
                        return __ret;
                    }
                }
            }

            public unsafe partial class CXXScalarValueInitExpr : global::CppSharp.Parser.AST.Expr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 60)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal rParenLoc;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CXXScalarValueInitExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CXXScalarValueInitExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.CXXScalarValueInitExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CXXScalarValueInitExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.CXXScalarValueInitExpr __CreateInstance(global::CppSharp.Parser.AST.CXXScalarValueInitExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CXXScalarValueInitExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.CXXScalarValueInitExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXScalarValueInitExpr.__Internal));
                    *(global::CppSharp.Parser.AST.CXXScalarValueInitExpr.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private CXXScalarValueInitExpr(global::CppSharp.Parser.AST.CXXScalarValueInitExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected CXXScalarValueInitExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public CXXScalarValueInitExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXScalarValueInitExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public CXXScalarValueInitExpr(global::CppSharp.Parser.AST.CXXScalarValueInitExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXScalarValueInitExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.CXXScalarValueInitExpr.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.CXXScalarValueInitExpr.__Internal*) _0.__Instance);
                }

                public global::CppSharp.Parser.SourceLocation RParenLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.CXXScalarValueInitExpr.__Internal*) __Instance)->rParenLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXScalarValueInitExpr.__Internal*)__Instance)->rParenLoc = value.__Instance;
                    }
                }
            }

            public unsafe partial class CXXNewExpr : global::CppSharp.Parser.AST.Expr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 132)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Expr___N_std_S_allocator__S0_ placement_arguments;

                    [FieldOffset(68)]
                    internal global::System.IntPtr operatorNew;

                    [FieldOffset(72)]
                    internal global::System.IntPtr operatorDelete;

                    [FieldOffset(76)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal allocatedType;

                    [FieldOffset(84)]
                    internal byte isArray;

                    [FieldOffset(88)]
                    internal global::System.IntPtr arraySize;

                    [FieldOffset(92)]
                    internal uint numPlacementArgs;

                    [FieldOffset(96)]
                    internal byte isParenTypeId;

                    [FieldOffset(100)]
                    internal global::CppSharp.Parser.SourceRange.__Internal typeIdParens;

                    [FieldOffset(108)]
                    internal byte isGlobalNew;

                    [FieldOffset(109)]
                    internal byte hasInitializer;

                    [FieldOffset(112)]
                    internal global::CppSharp.Parser.AST.CXXNewExpr.InitializationStyle initializationStyle;

                    [FieldOffset(116)]
                    internal global::System.IntPtr initializer;

                    [FieldOffset(120)]
                    internal global::System.IntPtr constructExpr;

                    [FieldOffset(124)]
                    internal global::CppSharp.Parser.SourceRange.__Internal directInitRange;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CXXNewExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CXXNewExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??1CXXNewExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern void dtor(global::System.IntPtr __instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getplacement_arguments@CXXNewExpr@AST@CppParser@CppSharp@@QAEPAVExpr@234@I@Z")]
                    internal static extern global::System.IntPtr GetplacementArguments(global::System.IntPtr __instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?addplacement_arguments@CXXNewExpr@AST@CppParser@CppSharp@@QAEXAAPAVExpr@234@@Z")]
                    internal static extern void AddplacementArguments(global::System.IntPtr __instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?clearplacement_arguments@CXXNewExpr@AST@CppParser@CppSharp@@QAEXXZ")]
                    internal static extern void ClearplacementArguments(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getplacement_argumentsCount@CXXNewExpr@AST@CppParser@CppSharp@@QAEIXZ")]
                    internal static extern uint GetplacementArgumentsCount(global::System.IntPtr __instance);
                }

                public enum InitializationStyle
                {
                    NoInit = 0,
                    CallInit = 1,
                    ListInit = 2
                }

                internal static new global::CppSharp.Parser.AST.CXXNewExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CXXNewExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.CXXNewExpr __CreateInstance(global::CppSharp.Parser.AST.CXXNewExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CXXNewExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.CXXNewExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXNewExpr.__Internal));
                    global::CppSharp.Parser.AST.CXXNewExpr.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private CXXNewExpr(global::CppSharp.Parser.AST.CXXNewExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected CXXNewExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public CXXNewExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXNewExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public CXXNewExpr(global::CppSharp.Parser.AST.CXXNewExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXNewExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Stmt __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor(__Instance, 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.Expr GetplacementArguments(uint i)
                {
                    var __ret = __Internal.GetplacementArguments(__Instance, i);
                    global::CppSharp.Parser.AST.Expr __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[__ret];
                    else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(__ret);
                    return __result0;
                }

                public void AddplacementArguments(global::CppSharp.Parser.AST.Expr s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var ____arg0 = s.__Instance;
                    var __arg0 = new global::System.IntPtr(&____arg0);
                    __Internal.AddplacementArguments(__Instance, __arg0);
                }

                public void ClearplacementArguments()
                {
                    __Internal.ClearplacementArguments(__Instance);
                }

                public global::CppSharp.Parser.AST.Function OperatorNew
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Function __result0;
                        if (((global::CppSharp.Parser.AST.CXXNewExpr.__Internal*) __Instance)->operatorNew == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Function.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.CXXNewExpr.__Internal*) __Instance)->operatorNew))
                            __result0 = (global::CppSharp.Parser.AST.Function) global::CppSharp.Parser.AST.Function.NativeToManagedMap[((global::CppSharp.Parser.AST.CXXNewExpr.__Internal*) __Instance)->operatorNew];
                        else __result0 = global::CppSharp.Parser.AST.Function.__CreateInstance(((global::CppSharp.Parser.AST.CXXNewExpr.__Internal*) __Instance)->operatorNew);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXNewExpr.__Internal*)__Instance)->operatorNew = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Function OperatorDelete
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Function __result0;
                        if (((global::CppSharp.Parser.AST.CXXNewExpr.__Internal*) __Instance)->operatorDelete == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Function.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.CXXNewExpr.__Internal*) __Instance)->operatorDelete))
                            __result0 = (global::CppSharp.Parser.AST.Function) global::CppSharp.Parser.AST.Function.NativeToManagedMap[((global::CppSharp.Parser.AST.CXXNewExpr.__Internal*) __Instance)->operatorDelete];
                        else __result0 = global::CppSharp.Parser.AST.Function.__CreateInstance(((global::CppSharp.Parser.AST.CXXNewExpr.__Internal*) __Instance)->operatorDelete);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXNewExpr.__Internal*)__Instance)->operatorDelete = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.QualifiedType AllocatedType
                {
                    get
                    {
                        return global::CppSharp.Parser.AST.QualifiedType.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.CXXNewExpr.__Internal*) __Instance)->allocatedType));
                    }

                    set
                    {
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                        ((global::CppSharp.Parser.AST.CXXNewExpr.__Internal*)__Instance)->allocatedType = *(global::CppSharp.Parser.AST.QualifiedType.__Internal*) value.__Instance;
                    }
                }

                public bool IsArray
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.CXXNewExpr.__Internal*) __Instance)->isArray != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXNewExpr.__Internal*)__Instance)->isArray = (byte) (value ? 1 : 0);
                    }
                }

                public global::CppSharp.Parser.AST.Expr ArraySize
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.CXXNewExpr.__Internal*) __Instance)->arraySize == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.CXXNewExpr.__Internal*) __Instance)->arraySize))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.CXXNewExpr.__Internal*) __Instance)->arraySize];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.CXXNewExpr.__Internal*) __Instance)->arraySize);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXNewExpr.__Internal*)__Instance)->arraySize = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public uint NumPlacementArgs
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.CXXNewExpr.__Internal*) __Instance)->numPlacementArgs;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXNewExpr.__Internal*)__Instance)->numPlacementArgs = value;
                    }
                }

                public bool IsParenTypeId
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.CXXNewExpr.__Internal*) __Instance)->isParenTypeId != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXNewExpr.__Internal*)__Instance)->isParenTypeId = (byte) (value ? 1 : 0);
                    }
                }

                public global::CppSharp.Parser.SourceRange TypeIdParens
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceRange.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.CXXNewExpr.__Internal*) __Instance)->typeIdParens));
                    }

                    set
                    {
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                        ((global::CppSharp.Parser.AST.CXXNewExpr.__Internal*)__Instance)->typeIdParens = *(global::CppSharp.Parser.SourceRange.__Internal*) value.__Instance;
                    }
                }

                public bool IsGlobalNew
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.CXXNewExpr.__Internal*) __Instance)->isGlobalNew != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXNewExpr.__Internal*)__Instance)->isGlobalNew = (byte) (value ? 1 : 0);
                    }
                }

                public bool HasInitializer
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.CXXNewExpr.__Internal*) __Instance)->hasInitializer != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXNewExpr.__Internal*)__Instance)->hasInitializer = (byte) (value ? 1 : 0);
                    }
                }

                public global::CppSharp.Parser.AST.CXXNewExpr.InitializationStyle initializationStyle
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.CXXNewExpr.__Internal*) __Instance)->initializationStyle;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXNewExpr.__Internal*)__Instance)->initializationStyle = value;
                    }
                }

                public global::CppSharp.Parser.AST.Expr Initializer
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.CXXNewExpr.__Internal*) __Instance)->initializer == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.CXXNewExpr.__Internal*) __Instance)->initializer))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.CXXNewExpr.__Internal*) __Instance)->initializer];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.CXXNewExpr.__Internal*) __Instance)->initializer);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXNewExpr.__Internal*)__Instance)->initializer = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.CXXConstructExpr ConstructExpr
                {
                    get
                    {
                        global::CppSharp.Parser.AST.CXXConstructExpr __result0;
                        if (((global::CppSharp.Parser.AST.CXXNewExpr.__Internal*) __Instance)->constructExpr == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.CXXConstructExpr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.CXXNewExpr.__Internal*) __Instance)->constructExpr))
                            __result0 = (global::CppSharp.Parser.AST.CXXConstructExpr) global::CppSharp.Parser.AST.CXXConstructExpr.NativeToManagedMap[((global::CppSharp.Parser.AST.CXXNewExpr.__Internal*) __Instance)->constructExpr];
                        else __result0 = global::CppSharp.Parser.AST.CXXConstructExpr.__CreateInstance(((global::CppSharp.Parser.AST.CXXNewExpr.__Internal*) __Instance)->constructExpr);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXNewExpr.__Internal*)__Instance)->constructExpr = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.SourceRange DirectInitRange
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceRange.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.CXXNewExpr.__Internal*) __Instance)->directInitRange));
                    }

                    set
                    {
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                        ((global::CppSharp.Parser.AST.CXXNewExpr.__Internal*)__Instance)->directInitRange = *(global::CppSharp.Parser.SourceRange.__Internal*) value.__Instance;
                    }
                }

                public uint GetplacementArgumentsCount
                {
                    get
                    {
                        var __ret = __Internal.GetplacementArgumentsCount(__Instance);
                        return __ret;
                    }
                }
            }

            public unsafe partial class CXXDeleteExpr : global::CppSharp.Parser.AST.Expr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 76)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal byte isGlobalDelete;

                    [FieldOffset(57)]
                    internal byte isArrayForm;

                    [FieldOffset(58)]
                    internal byte isArrayFormAsWritten;

                    [FieldOffset(60)]
                    internal global::System.IntPtr operatorDelete;

                    [FieldOffset(64)]
                    internal global::System.IntPtr argument;

                    [FieldOffset(68)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal destroyedType;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CXXDeleteExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CXXDeleteExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.CXXDeleteExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CXXDeleteExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.CXXDeleteExpr __CreateInstance(global::CppSharp.Parser.AST.CXXDeleteExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CXXDeleteExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.CXXDeleteExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXDeleteExpr.__Internal));
                    *(global::CppSharp.Parser.AST.CXXDeleteExpr.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private CXXDeleteExpr(global::CppSharp.Parser.AST.CXXDeleteExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected CXXDeleteExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public CXXDeleteExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXDeleteExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public CXXDeleteExpr(global::CppSharp.Parser.AST.CXXDeleteExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXDeleteExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.CXXDeleteExpr.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.CXXDeleteExpr.__Internal*) _0.__Instance);
                }

                public bool IsGlobalDelete
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.CXXDeleteExpr.__Internal*) __Instance)->isGlobalDelete != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXDeleteExpr.__Internal*)__Instance)->isGlobalDelete = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsArrayForm
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.CXXDeleteExpr.__Internal*) __Instance)->isArrayForm != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXDeleteExpr.__Internal*)__Instance)->isArrayForm = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsArrayFormAsWritten
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.CXXDeleteExpr.__Internal*) __Instance)->isArrayFormAsWritten != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXDeleteExpr.__Internal*)__Instance)->isArrayFormAsWritten = (byte) (value ? 1 : 0);
                    }
                }

                public global::CppSharp.Parser.AST.Function OperatorDelete
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Function __result0;
                        if (((global::CppSharp.Parser.AST.CXXDeleteExpr.__Internal*) __Instance)->operatorDelete == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Function.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.CXXDeleteExpr.__Internal*) __Instance)->operatorDelete))
                            __result0 = (global::CppSharp.Parser.AST.Function) global::CppSharp.Parser.AST.Function.NativeToManagedMap[((global::CppSharp.Parser.AST.CXXDeleteExpr.__Internal*) __Instance)->operatorDelete];
                        else __result0 = global::CppSharp.Parser.AST.Function.__CreateInstance(((global::CppSharp.Parser.AST.CXXDeleteExpr.__Internal*) __Instance)->operatorDelete);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXDeleteExpr.__Internal*)__Instance)->operatorDelete = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Expr Argument
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.CXXDeleteExpr.__Internal*) __Instance)->argument == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.CXXDeleteExpr.__Internal*) __Instance)->argument))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.CXXDeleteExpr.__Internal*) __Instance)->argument];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.CXXDeleteExpr.__Internal*) __Instance)->argument);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXDeleteExpr.__Internal*)__Instance)->argument = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.QualifiedType DestroyedType
                {
                    get
                    {
                        return global::CppSharp.Parser.AST.QualifiedType.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.CXXDeleteExpr.__Internal*) __Instance)->destroyedType));
                    }

                    set
                    {
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                        ((global::CppSharp.Parser.AST.CXXDeleteExpr.__Internal*)__Instance)->destroyedType = *(global::CppSharp.Parser.AST.QualifiedType.__Internal*) value.__Instance;
                    }
                }
            }

            public unsafe partial class CXXPseudoDestructorExpr : global::CppSharp.Parser.AST.Expr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 88)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal global::System.IntPtr @base;

                    [FieldOffset(60)]
                    internal byte hasQualifier;

                    [FieldOffset(61)]
                    internal byte isArrow;

                    [FieldOffset(64)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal operatorLoc;

                    [FieldOffset(68)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal colonColonLoc;

                    [FieldOffset(72)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal tildeLoc;

                    [FieldOffset(76)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal destroyedType;

                    [FieldOffset(84)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal destroyedTypeLoc;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CXXPseudoDestructorExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CXXPseudoDestructorExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.CXXPseudoDestructorExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CXXPseudoDestructorExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.CXXPseudoDestructorExpr __CreateInstance(global::CppSharp.Parser.AST.CXXPseudoDestructorExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CXXPseudoDestructorExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.CXXPseudoDestructorExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXPseudoDestructorExpr.__Internal));
                    *(global::CppSharp.Parser.AST.CXXPseudoDestructorExpr.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private CXXPseudoDestructorExpr(global::CppSharp.Parser.AST.CXXPseudoDestructorExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected CXXPseudoDestructorExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public CXXPseudoDestructorExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXPseudoDestructorExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public CXXPseudoDestructorExpr(global::CppSharp.Parser.AST.CXXPseudoDestructorExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXPseudoDestructorExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.CXXPseudoDestructorExpr.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.CXXPseudoDestructorExpr.__Internal*) _0.__Instance);
                }

                public global::CppSharp.Parser.AST.Expr Base
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.CXXPseudoDestructorExpr.__Internal*) __Instance)->@base == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.CXXPseudoDestructorExpr.__Internal*) __Instance)->@base))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.CXXPseudoDestructorExpr.__Internal*) __Instance)->@base];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.CXXPseudoDestructorExpr.__Internal*) __Instance)->@base);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXPseudoDestructorExpr.__Internal*)__Instance)->@base = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public bool HasQualifier
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.CXXPseudoDestructorExpr.__Internal*) __Instance)->hasQualifier != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXPseudoDestructorExpr.__Internal*)__Instance)->hasQualifier = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsArrow
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.CXXPseudoDestructorExpr.__Internal*) __Instance)->isArrow != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXPseudoDestructorExpr.__Internal*)__Instance)->isArrow = (byte) (value ? 1 : 0);
                    }
                }

                public global::CppSharp.Parser.SourceLocation OperatorLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.CXXPseudoDestructorExpr.__Internal*) __Instance)->operatorLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXPseudoDestructorExpr.__Internal*)__Instance)->operatorLoc = value.__Instance;
                    }
                }

                public global::CppSharp.Parser.SourceLocation ColonColonLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.CXXPseudoDestructorExpr.__Internal*) __Instance)->colonColonLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXPseudoDestructorExpr.__Internal*)__Instance)->colonColonLoc = value.__Instance;
                    }
                }

                public global::CppSharp.Parser.SourceLocation TildeLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.CXXPseudoDestructorExpr.__Internal*) __Instance)->tildeLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXPseudoDestructorExpr.__Internal*)__Instance)->tildeLoc = value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.QualifiedType DestroyedType
                {
                    get
                    {
                        return global::CppSharp.Parser.AST.QualifiedType.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.CXXPseudoDestructorExpr.__Internal*) __Instance)->destroyedType));
                    }

                    set
                    {
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                        ((global::CppSharp.Parser.AST.CXXPseudoDestructorExpr.__Internal*)__Instance)->destroyedType = *(global::CppSharp.Parser.AST.QualifiedType.__Internal*) value.__Instance;
                    }
                }

                public global::CppSharp.Parser.SourceLocation DestroyedTypeLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.CXXPseudoDestructorExpr.__Internal*) __Instance)->destroyedTypeLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXPseudoDestructorExpr.__Internal*)__Instance)->destroyedTypeLoc = value.__Instance;
                    }
                }
            }

            public unsafe partial class TypeTraitExpr : global::CppSharp.Parser.AST.Expr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 64)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal byte value;

                    [FieldOffset(60)]
                    internal uint numArgs;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0TypeTraitExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0TypeTraitExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.TypeTraitExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.TypeTraitExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.TypeTraitExpr __CreateInstance(global::CppSharp.Parser.AST.TypeTraitExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.TypeTraitExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.TypeTraitExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TypeTraitExpr.__Internal));
                    *(global::CppSharp.Parser.AST.TypeTraitExpr.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private TypeTraitExpr(global::CppSharp.Parser.AST.TypeTraitExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected TypeTraitExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public TypeTraitExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TypeTraitExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public TypeTraitExpr(global::CppSharp.Parser.AST.TypeTraitExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.TypeTraitExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.TypeTraitExpr.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.TypeTraitExpr.__Internal*) _0.__Instance);
                }

                public bool Value
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.TypeTraitExpr.__Internal*) __Instance)->value != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.TypeTraitExpr.__Internal*)__Instance)->value = (byte) (value ? 1 : 0);
                    }
                }

                public uint NumArgs
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.TypeTraitExpr.__Internal*) __Instance)->numArgs;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.TypeTraitExpr.__Internal*)__Instance)->numArgs = value;
                    }
                }
            }

            public unsafe partial class ArrayTypeTraitExpr : global::CppSharp.Parser.AST.Expr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 80)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal queriedType;

                    [FieldOffset(64)]
                    internal ulong value;

                    [FieldOffset(72)]
                    internal global::System.IntPtr dimensionExpression;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0ArrayTypeTraitExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0ArrayTypeTraitExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.ArrayTypeTraitExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.ArrayTypeTraitExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.ArrayTypeTraitExpr __CreateInstance(global::CppSharp.Parser.AST.ArrayTypeTraitExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.ArrayTypeTraitExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.ArrayTypeTraitExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ArrayTypeTraitExpr.__Internal));
                    *(global::CppSharp.Parser.AST.ArrayTypeTraitExpr.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private ArrayTypeTraitExpr(global::CppSharp.Parser.AST.ArrayTypeTraitExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected ArrayTypeTraitExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public ArrayTypeTraitExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ArrayTypeTraitExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public ArrayTypeTraitExpr(global::CppSharp.Parser.AST.ArrayTypeTraitExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ArrayTypeTraitExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.ArrayTypeTraitExpr.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.ArrayTypeTraitExpr.__Internal*) _0.__Instance);
                }

                public global::CppSharp.Parser.AST.QualifiedType QueriedType
                {
                    get
                    {
                        return global::CppSharp.Parser.AST.QualifiedType.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.ArrayTypeTraitExpr.__Internal*) __Instance)->queriedType));
                    }

                    set
                    {
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                        ((global::CppSharp.Parser.AST.ArrayTypeTraitExpr.__Internal*)__Instance)->queriedType = *(global::CppSharp.Parser.AST.QualifiedType.__Internal*) value.__Instance;
                    }
                }

                public ulong Value
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.ArrayTypeTraitExpr.__Internal*) __Instance)->value;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.ArrayTypeTraitExpr.__Internal*)__Instance)->value = value;
                    }
                }

                public global::CppSharp.Parser.AST.Expr DimensionExpression
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.ArrayTypeTraitExpr.__Internal*) __Instance)->dimensionExpression == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.ArrayTypeTraitExpr.__Internal*) __Instance)->dimensionExpression))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.ArrayTypeTraitExpr.__Internal*) __Instance)->dimensionExpression];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.ArrayTypeTraitExpr.__Internal*) __Instance)->dimensionExpression);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.ArrayTypeTraitExpr.__Internal*)__Instance)->dimensionExpression = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }
            }

            public unsafe partial class ExpressionTraitExpr : global::CppSharp.Parser.AST.Expr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 64)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal global::System.IntPtr queriedExpression;

                    [FieldOffset(60)]
                    internal byte value;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0ExpressionTraitExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0ExpressionTraitExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.ExpressionTraitExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.ExpressionTraitExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.ExpressionTraitExpr __CreateInstance(global::CppSharp.Parser.AST.ExpressionTraitExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.ExpressionTraitExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.ExpressionTraitExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ExpressionTraitExpr.__Internal));
                    *(global::CppSharp.Parser.AST.ExpressionTraitExpr.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private ExpressionTraitExpr(global::CppSharp.Parser.AST.ExpressionTraitExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected ExpressionTraitExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public ExpressionTraitExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ExpressionTraitExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public ExpressionTraitExpr(global::CppSharp.Parser.AST.ExpressionTraitExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ExpressionTraitExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.ExpressionTraitExpr.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.ExpressionTraitExpr.__Internal*) _0.__Instance);
                }

                public global::CppSharp.Parser.AST.Expr QueriedExpression
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.ExpressionTraitExpr.__Internal*) __Instance)->queriedExpression == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.ExpressionTraitExpr.__Internal*) __Instance)->queriedExpression))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.ExpressionTraitExpr.__Internal*) __Instance)->queriedExpression];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.ExpressionTraitExpr.__Internal*) __Instance)->queriedExpression);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.ExpressionTraitExpr.__Internal*)__Instance)->queriedExpression = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public bool Value
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.ExpressionTraitExpr.__Internal*) __Instance)->value != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.ExpressionTraitExpr.__Internal*)__Instance)->value = (byte) (value ? 1 : 0);
                    }
                }
            }

            public unsafe partial class OverloadExpr : global::CppSharp.Parser.AST.Expr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 84)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal uint numDecls;

                    [FieldOffset(60)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal nameLoc;

                    [FieldOffset(64)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal templateKeywordLoc;

                    [FieldOffset(68)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal lAngleLoc;

                    [FieldOffset(72)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal rAngleLoc;

                    [FieldOffset(76)]
                    internal byte hasTemplateKeyword;

                    [FieldOffset(77)]
                    internal byte hasExplicitTemplateArgs;

                    [FieldOffset(80)]
                    internal uint numTemplateArgs;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0OverloadExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0OverloadExpr@AST@CppParser@CppSharp@@QAE@W4StmtClass@123@@Z")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance, global::CppSharp.Parser.AST.StmtClass klass);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0OverloadExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                public unsafe partial class FindResult : IDisposable
                {
                    [StructLayout(LayoutKind.Explicit, Size = 0)]
                    public partial struct __Internal
                    {
                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                            EntryPoint="??0FindResult@OverloadExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                        internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                            EntryPoint="??0FindResult@OverloadExpr@AST@CppParser@CppSharp@@QAE@ABV01234@@Z")]
                        internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                    }

                    public global::System.IntPtr __Instance { get; protected set; }

                    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.OverloadExpr.FindResult> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.OverloadExpr.FindResult>();
                    protected internal void*[] __OriginalVTables;

                    protected bool __ownsNativeInstance;

                    internal static global::CppSharp.Parser.AST.OverloadExpr.FindResult __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                    {
                        return new global::CppSharp.Parser.AST.OverloadExpr.FindResult(native.ToPointer(), skipVTables);
                    }

                    internal static global::CppSharp.Parser.AST.OverloadExpr.FindResult __CreateInstance(global::CppSharp.Parser.AST.OverloadExpr.FindResult.__Internal native, bool skipVTables = false)
                    {
                        return new global::CppSharp.Parser.AST.OverloadExpr.FindResult(native, skipVTables);
                    }

                    private static void* __CopyValue(global::CppSharp.Parser.AST.OverloadExpr.FindResult.__Internal native)
                    {
                        var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.OverloadExpr.FindResult.__Internal));
                        *(global::CppSharp.Parser.AST.OverloadExpr.FindResult.__Internal*) ret = native;
                        return ret.ToPointer();
                    }

                    private FindResult(global::CppSharp.Parser.AST.OverloadExpr.FindResult.__Internal native, bool skipVTables = false)
                        : this(__CopyValue(native), skipVTables)
                    {
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                    }

                    protected FindResult(void* native, bool skipVTables = false)
                    {
                        if (native == null)
                            return;
                        __Instance = new global::System.IntPtr(native);
                    }

                    public FindResult()
                    {
                        __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.OverloadExpr.FindResult.__Internal));
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                        __Internal.ctor(__Instance);
                    }

                    public FindResult(global::CppSharp.Parser.AST.OverloadExpr.FindResult _0)
                    {
                        __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.OverloadExpr.FindResult.__Internal));
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                        *((global::CppSharp.Parser.AST.OverloadExpr.FindResult.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.OverloadExpr.FindResult.__Internal*) _0.__Instance);
                    }

                    public void Dispose()
                    {
                        Dispose(disposing: true);
                    }

                    public virtual void Dispose(bool disposing)
                    {
                        if (__Instance == IntPtr.Zero)
                            return;
                        global::CppSharp.Parser.AST.OverloadExpr.FindResult __dummy;
                        NativeToManagedMap.TryRemove(__Instance, out __dummy);
                        if (__ownsNativeInstance)
                            Marshal.FreeHGlobal(__Instance);
                        __Instance = IntPtr.Zero;
                    }
                }

                internal static new global::CppSharp.Parser.AST.OverloadExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.OverloadExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.OverloadExpr __CreateInstance(global::CppSharp.Parser.AST.OverloadExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.OverloadExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.OverloadExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.OverloadExpr.__Internal));
                    *(global::CppSharp.Parser.AST.OverloadExpr.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private OverloadExpr(global::CppSharp.Parser.AST.OverloadExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected OverloadExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public OverloadExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.OverloadExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public OverloadExpr(global::CppSharp.Parser.AST.StmtClass klass)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.OverloadExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance, klass);
                }

                public OverloadExpr(global::CppSharp.Parser.AST.OverloadExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.OverloadExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.OverloadExpr.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.OverloadExpr.__Internal*) _0.__Instance);
                }

                public static implicit operator global::CppSharp.Parser.AST.OverloadExpr(global::CppSharp.Parser.AST.StmtClass klass)
                {
                    return new global::CppSharp.Parser.AST.OverloadExpr(klass);
                }

                public uint NumDecls
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.OverloadExpr.__Internal*) __Instance)->numDecls;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.OverloadExpr.__Internal*)__Instance)->numDecls = value;
                    }
                }

                public global::CppSharp.Parser.SourceLocation NameLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.OverloadExpr.__Internal*) __Instance)->nameLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.OverloadExpr.__Internal*)__Instance)->nameLoc = value.__Instance;
                    }
                }

                public global::CppSharp.Parser.SourceLocation TemplateKeywordLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.OverloadExpr.__Internal*) __Instance)->templateKeywordLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.OverloadExpr.__Internal*)__Instance)->templateKeywordLoc = value.__Instance;
                    }
                }

                public global::CppSharp.Parser.SourceLocation LAngleLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.OverloadExpr.__Internal*) __Instance)->lAngleLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.OverloadExpr.__Internal*)__Instance)->lAngleLoc = value.__Instance;
                    }
                }

                public global::CppSharp.Parser.SourceLocation RAngleLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.OverloadExpr.__Internal*) __Instance)->rAngleLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.OverloadExpr.__Internal*)__Instance)->rAngleLoc = value.__Instance;
                    }
                }

                public bool HasTemplateKeyword
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.OverloadExpr.__Internal*) __Instance)->hasTemplateKeyword != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.OverloadExpr.__Internal*)__Instance)->hasTemplateKeyword = (byte) (value ? 1 : 0);
                    }
                }

                public bool HasExplicitTemplateArgs
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.OverloadExpr.__Internal*) __Instance)->hasExplicitTemplateArgs != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.OverloadExpr.__Internal*)__Instance)->hasExplicitTemplateArgs = (byte) (value ? 1 : 0);
                    }
                }

                public uint NumTemplateArgs
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.OverloadExpr.__Internal*) __Instance)->numTemplateArgs;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.OverloadExpr.__Internal*)__Instance)->numTemplateArgs = value;
                    }
                }
            }

            public unsafe partial class UnresolvedLookupExpr : global::CppSharp.Parser.AST.OverloadExpr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 88)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal uint numDecls;

                    [FieldOffset(60)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal nameLoc;

                    [FieldOffset(64)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal templateKeywordLoc;

                    [FieldOffset(68)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal lAngleLoc;

                    [FieldOffset(72)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal rAngleLoc;

                    [FieldOffset(76)]
                    internal byte hasTemplateKeyword;

                    [FieldOffset(77)]
                    internal byte hasExplicitTemplateArgs;

                    [FieldOffset(80)]
                    internal uint numTemplateArgs;

                    [FieldOffset(84)]
                    internal byte requiresADL;

                    [FieldOffset(85)]
                    internal byte isOverloaded;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0UnresolvedLookupExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0UnresolvedLookupExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.UnresolvedLookupExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.UnresolvedLookupExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.UnresolvedLookupExpr __CreateInstance(global::CppSharp.Parser.AST.UnresolvedLookupExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.UnresolvedLookupExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.UnresolvedLookupExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.UnresolvedLookupExpr.__Internal));
                    *(global::CppSharp.Parser.AST.UnresolvedLookupExpr.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private UnresolvedLookupExpr(global::CppSharp.Parser.AST.UnresolvedLookupExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected UnresolvedLookupExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public UnresolvedLookupExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.UnresolvedLookupExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public UnresolvedLookupExpr(global::CppSharp.Parser.AST.UnresolvedLookupExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.UnresolvedLookupExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.UnresolvedLookupExpr.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.UnresolvedLookupExpr.__Internal*) _0.__Instance);
                }

                public bool RequiresADL
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.UnresolvedLookupExpr.__Internal*) __Instance)->requiresADL != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.UnresolvedLookupExpr.__Internal*)__Instance)->requiresADL = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsOverloaded
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.UnresolvedLookupExpr.__Internal*) __Instance)->isOverloaded != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.UnresolvedLookupExpr.__Internal*)__Instance)->isOverloaded = (byte) (value ? 1 : 0);
                    }
                }
            }

            public unsafe partial class DependentScopeDeclRefExpr : global::CppSharp.Parser.AST.Expr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 80)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal location;

                    [FieldOffset(60)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal templateKeywordLoc;

                    [FieldOffset(64)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal lAngleLoc;

                    [FieldOffset(68)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal rAngleLoc;

                    [FieldOffset(72)]
                    internal byte hasTemplateKeyword;

                    [FieldOffset(73)]
                    internal byte hasExplicitTemplateArgs;

                    [FieldOffset(76)]
                    internal uint numTemplateArgs;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0DependentScopeDeclRefExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0DependentScopeDeclRefExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.DependentScopeDeclRefExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.DependentScopeDeclRefExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.DependentScopeDeclRefExpr __CreateInstance(global::CppSharp.Parser.AST.DependentScopeDeclRefExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.DependentScopeDeclRefExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.DependentScopeDeclRefExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.DependentScopeDeclRefExpr.__Internal));
                    *(global::CppSharp.Parser.AST.DependentScopeDeclRefExpr.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private DependentScopeDeclRefExpr(global::CppSharp.Parser.AST.DependentScopeDeclRefExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected DependentScopeDeclRefExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public DependentScopeDeclRefExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.DependentScopeDeclRefExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public DependentScopeDeclRefExpr(global::CppSharp.Parser.AST.DependentScopeDeclRefExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.DependentScopeDeclRefExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.DependentScopeDeclRefExpr.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.DependentScopeDeclRefExpr.__Internal*) _0.__Instance);
                }

                public global::CppSharp.Parser.SourceLocation Location
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.DependentScopeDeclRefExpr.__Internal*) __Instance)->location);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.DependentScopeDeclRefExpr.__Internal*)__Instance)->location = value.__Instance;
                    }
                }

                public global::CppSharp.Parser.SourceLocation TemplateKeywordLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.DependentScopeDeclRefExpr.__Internal*) __Instance)->templateKeywordLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.DependentScopeDeclRefExpr.__Internal*)__Instance)->templateKeywordLoc = value.__Instance;
                    }
                }

                public global::CppSharp.Parser.SourceLocation LAngleLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.DependentScopeDeclRefExpr.__Internal*) __Instance)->lAngleLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.DependentScopeDeclRefExpr.__Internal*)__Instance)->lAngleLoc = value.__Instance;
                    }
                }

                public global::CppSharp.Parser.SourceLocation RAngleLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.DependentScopeDeclRefExpr.__Internal*) __Instance)->rAngleLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.DependentScopeDeclRefExpr.__Internal*)__Instance)->rAngleLoc = value.__Instance;
                    }
                }

                public bool HasTemplateKeyword
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.DependentScopeDeclRefExpr.__Internal*) __Instance)->hasTemplateKeyword != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.DependentScopeDeclRefExpr.__Internal*)__Instance)->hasTemplateKeyword = (byte) (value ? 1 : 0);
                    }
                }

                public bool HasExplicitTemplateArgs
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.DependentScopeDeclRefExpr.__Internal*) __Instance)->hasExplicitTemplateArgs != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.DependentScopeDeclRefExpr.__Internal*)__Instance)->hasExplicitTemplateArgs = (byte) (value ? 1 : 0);
                    }
                }

                public uint NumTemplateArgs
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.DependentScopeDeclRefExpr.__Internal*) __Instance)->numTemplateArgs;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.DependentScopeDeclRefExpr.__Internal*)__Instance)->numTemplateArgs = value;
                    }
                }
            }

            public unsafe partial class ExprWithCleanups : global::CppSharp.Parser.AST.FullExpr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 68)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal global::System.IntPtr subExpr;

                    [FieldOffset(60)]
                    internal uint numObjects;

                    [FieldOffset(64)]
                    internal byte cleanupsHaveSideEffects;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0ExprWithCleanups@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0ExprWithCleanups@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.ExprWithCleanups __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.ExprWithCleanups(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.ExprWithCleanups __CreateInstance(global::CppSharp.Parser.AST.ExprWithCleanups.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.ExprWithCleanups(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.ExprWithCleanups.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ExprWithCleanups.__Internal));
                    *(global::CppSharp.Parser.AST.ExprWithCleanups.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private ExprWithCleanups(global::CppSharp.Parser.AST.ExprWithCleanups.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected ExprWithCleanups(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public ExprWithCleanups()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ExprWithCleanups.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public ExprWithCleanups(global::CppSharp.Parser.AST.ExprWithCleanups _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.ExprWithCleanups.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.ExprWithCleanups.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.ExprWithCleanups.__Internal*) _0.__Instance);
                }

                public uint NumObjects
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.ExprWithCleanups.__Internal*) __Instance)->numObjects;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.ExprWithCleanups.__Internal*)__Instance)->numObjects = value;
                    }
                }

                public bool CleanupsHaveSideEffects
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.ExprWithCleanups.__Internal*) __Instance)->cleanupsHaveSideEffects != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.ExprWithCleanups.__Internal*)__Instance)->cleanupsHaveSideEffects = (byte) (value ? 1 : 0);
                    }
                }
            }

            public unsafe partial class CXXUnresolvedConstructExpr : global::CppSharp.Parser.AST.Expr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 92)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal global::Std.Vector.__Internalc__N_std_S_vector_____N_CppSharp_N_CppParser_N_AST_S_Expr___N_std_S_allocator__S0_ arguments;

                    [FieldOffset(68)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal lParenLoc;

                    [FieldOffset(72)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal rParenLoc;

                    [FieldOffset(76)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal typeAsWritten;

                    [FieldOffset(84)]
                    internal byte isListInitialization;

                    [FieldOffset(88)]
                    internal uint arg_size;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CXXUnresolvedConstructExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CXXUnresolvedConstructExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??1CXXUnresolvedConstructExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern void dtor(global::System.IntPtr __instance, int delete);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getarguments@CXXUnresolvedConstructExpr@AST@CppParser@CppSharp@@QAEPAVExpr@234@I@Z")]
                    internal static extern global::System.IntPtr Getarguments(global::System.IntPtr __instance, uint i);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?addarguments@CXXUnresolvedConstructExpr@AST@CppParser@CppSharp@@QAEXAAPAVExpr@234@@Z")]
                    internal static extern void Addarguments(global::System.IntPtr __instance, global::System.IntPtr s);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?cleararguments@CXXUnresolvedConstructExpr@AST@CppParser@CppSharp@@QAEXXZ")]
                    internal static extern void Cleararguments(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="?getargumentsCount@CXXUnresolvedConstructExpr@AST@CppParser@CppSharp@@QAEIXZ")]
                    internal static extern uint GetargumentsCount(global::System.IntPtr __instance);
                }

                internal static new global::CppSharp.Parser.AST.CXXUnresolvedConstructExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CXXUnresolvedConstructExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.CXXUnresolvedConstructExpr __CreateInstance(global::CppSharp.Parser.AST.CXXUnresolvedConstructExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CXXUnresolvedConstructExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.CXXUnresolvedConstructExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXUnresolvedConstructExpr.__Internal));
                    global::CppSharp.Parser.AST.CXXUnresolvedConstructExpr.__Internal.cctor(ret, new global::System.IntPtr(&native));
                    return ret.ToPointer();
                }

                private CXXUnresolvedConstructExpr(global::CppSharp.Parser.AST.CXXUnresolvedConstructExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected CXXUnresolvedConstructExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public CXXUnresolvedConstructExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXUnresolvedConstructExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public CXXUnresolvedConstructExpr(global::CppSharp.Parser.AST.CXXUnresolvedConstructExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXUnresolvedConstructExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    if (ReferenceEquals(_0, null))
                        throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                    var __arg0 = _0.__Instance;
                    __Internal.cctor(__Instance, __arg0);
                }

                public override void Dispose(bool disposing)
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    global::CppSharp.Parser.AST.Stmt __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (disposing)
                        __Internal.dtor(__Instance, 0);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::CppSharp.Parser.AST.Expr Getarguments(uint i)
                {
                    var __ret = __Internal.Getarguments(__Instance, i);
                    global::CppSharp.Parser.AST.Expr __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[__ret];
                    else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(__ret);
                    return __result0;
                }

                public void Addarguments(global::CppSharp.Parser.AST.Expr s)
                {
                    if (ReferenceEquals(s, null))
                        throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                    var ____arg0 = s.__Instance;
                    var __arg0 = new global::System.IntPtr(&____arg0);
                    __Internal.Addarguments(__Instance, __arg0);
                }

                public void Cleararguments()
                {
                    __Internal.Cleararguments(__Instance);
                }

                public global::CppSharp.Parser.SourceLocation LParenLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.CXXUnresolvedConstructExpr.__Internal*) __Instance)->lParenLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXUnresolvedConstructExpr.__Internal*)__Instance)->lParenLoc = value.__Instance;
                    }
                }

                public global::CppSharp.Parser.SourceLocation RParenLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.CXXUnresolvedConstructExpr.__Internal*) __Instance)->rParenLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXUnresolvedConstructExpr.__Internal*)__Instance)->rParenLoc = value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.QualifiedType TypeAsWritten
                {
                    get
                    {
                        return global::CppSharp.Parser.AST.QualifiedType.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.CXXUnresolvedConstructExpr.__Internal*) __Instance)->typeAsWritten));
                    }

                    set
                    {
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                        ((global::CppSharp.Parser.AST.CXXUnresolvedConstructExpr.__Internal*)__Instance)->typeAsWritten = *(global::CppSharp.Parser.AST.QualifiedType.__Internal*) value.__Instance;
                    }
                }

                public bool IsListInitialization
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.CXXUnresolvedConstructExpr.__Internal*) __Instance)->isListInitialization != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXUnresolvedConstructExpr.__Internal*)__Instance)->isListInitialization = (byte) (value ? 1 : 0);
                    }
                }

                public uint ArgSize
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.CXXUnresolvedConstructExpr.__Internal*) __Instance)->arg_size;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXUnresolvedConstructExpr.__Internal*)__Instance)->arg_size = value;
                    }
                }

                public uint GetargumentsCount
                {
                    get
                    {
                        var __ret = __Internal.GetargumentsCount(__Instance);
                        return __ret;
                    }
                }
            }

            public unsafe partial class CXXDependentScopeMemberExpr : global::CppSharp.Parser.AST.Expr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 108)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal byte isImplicitAccess;

                    [FieldOffset(60)]
                    internal global::System.IntPtr @base;

                    [FieldOffset(64)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal baseType;

                    [FieldOffset(72)]
                    internal byte isArrow;

                    [FieldOffset(76)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal operatorLoc;

                    [FieldOffset(80)]
                    internal global::System.IntPtr firstQualifierFoundInScope;

                    [FieldOffset(84)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal memberLoc;

                    [FieldOffset(88)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal templateKeywordLoc;

                    [FieldOffset(92)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal lAngleLoc;

                    [FieldOffset(96)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal rAngleLoc;

                    [FieldOffset(100)]
                    internal byte hasTemplateKeyword;

                    [FieldOffset(101)]
                    internal byte hasExplicitTemplateArgs;

                    [FieldOffset(104)]
                    internal uint numTemplateArgs;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CXXDependentScopeMemberExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CXXDependentScopeMemberExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.CXXDependentScopeMemberExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CXXDependentScopeMemberExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.CXXDependentScopeMemberExpr __CreateInstance(global::CppSharp.Parser.AST.CXXDependentScopeMemberExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CXXDependentScopeMemberExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.CXXDependentScopeMemberExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXDependentScopeMemberExpr.__Internal));
                    *(global::CppSharp.Parser.AST.CXXDependentScopeMemberExpr.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private CXXDependentScopeMemberExpr(global::CppSharp.Parser.AST.CXXDependentScopeMemberExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected CXXDependentScopeMemberExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public CXXDependentScopeMemberExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXDependentScopeMemberExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public CXXDependentScopeMemberExpr(global::CppSharp.Parser.AST.CXXDependentScopeMemberExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXDependentScopeMemberExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.CXXDependentScopeMemberExpr.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.CXXDependentScopeMemberExpr.__Internal*) _0.__Instance);
                }

                public bool IsImplicitAccess
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.CXXDependentScopeMemberExpr.__Internal*) __Instance)->isImplicitAccess != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXDependentScopeMemberExpr.__Internal*)__Instance)->isImplicitAccess = (byte) (value ? 1 : 0);
                    }
                }

                public global::CppSharp.Parser.AST.Expr Base
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.CXXDependentScopeMemberExpr.__Internal*) __Instance)->@base == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.CXXDependentScopeMemberExpr.__Internal*) __Instance)->@base))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.CXXDependentScopeMemberExpr.__Internal*) __Instance)->@base];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.CXXDependentScopeMemberExpr.__Internal*) __Instance)->@base);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXDependentScopeMemberExpr.__Internal*)__Instance)->@base = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.QualifiedType BaseType
                {
                    get
                    {
                        return global::CppSharp.Parser.AST.QualifiedType.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.CXXDependentScopeMemberExpr.__Internal*) __Instance)->baseType));
                    }

                    set
                    {
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                        ((global::CppSharp.Parser.AST.CXXDependentScopeMemberExpr.__Internal*)__Instance)->baseType = *(global::CppSharp.Parser.AST.QualifiedType.__Internal*) value.__Instance;
                    }
                }

                public bool IsArrow
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.CXXDependentScopeMemberExpr.__Internal*) __Instance)->isArrow != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXDependentScopeMemberExpr.__Internal*)__Instance)->isArrow = (byte) (value ? 1 : 0);
                    }
                }

                public global::CppSharp.Parser.SourceLocation OperatorLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.CXXDependentScopeMemberExpr.__Internal*) __Instance)->operatorLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXDependentScopeMemberExpr.__Internal*)__Instance)->operatorLoc = value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Declaration FirstQualifierFoundInScope
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Declaration __result0;
                        if (((global::CppSharp.Parser.AST.CXXDependentScopeMemberExpr.__Internal*) __Instance)->firstQualifierFoundInScope == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Declaration.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.CXXDependentScopeMemberExpr.__Internal*) __Instance)->firstQualifierFoundInScope))
                            __result0 = (global::CppSharp.Parser.AST.Declaration) global::CppSharp.Parser.AST.Declaration.NativeToManagedMap[((global::CppSharp.Parser.AST.CXXDependentScopeMemberExpr.__Internal*) __Instance)->firstQualifierFoundInScope];
                        else __result0 = global::CppSharp.Parser.AST.Declaration.__CreateInstance(((global::CppSharp.Parser.AST.CXXDependentScopeMemberExpr.__Internal*) __Instance)->firstQualifierFoundInScope);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXDependentScopeMemberExpr.__Internal*)__Instance)->firstQualifierFoundInScope = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.SourceLocation MemberLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.CXXDependentScopeMemberExpr.__Internal*) __Instance)->memberLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXDependentScopeMemberExpr.__Internal*)__Instance)->memberLoc = value.__Instance;
                    }
                }

                public global::CppSharp.Parser.SourceLocation TemplateKeywordLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.CXXDependentScopeMemberExpr.__Internal*) __Instance)->templateKeywordLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXDependentScopeMemberExpr.__Internal*)__Instance)->templateKeywordLoc = value.__Instance;
                    }
                }

                public global::CppSharp.Parser.SourceLocation LAngleLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.CXXDependentScopeMemberExpr.__Internal*) __Instance)->lAngleLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXDependentScopeMemberExpr.__Internal*)__Instance)->lAngleLoc = value.__Instance;
                    }
                }

                public global::CppSharp.Parser.SourceLocation RAngleLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.CXXDependentScopeMemberExpr.__Internal*) __Instance)->rAngleLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXDependentScopeMemberExpr.__Internal*)__Instance)->rAngleLoc = value.__Instance;
                    }
                }

                public bool HasTemplateKeyword
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.CXXDependentScopeMemberExpr.__Internal*) __Instance)->hasTemplateKeyword != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXDependentScopeMemberExpr.__Internal*)__Instance)->hasTemplateKeyword = (byte) (value ? 1 : 0);
                    }
                }

                public bool HasExplicitTemplateArgs
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.CXXDependentScopeMemberExpr.__Internal*) __Instance)->hasExplicitTemplateArgs != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXDependentScopeMemberExpr.__Internal*)__Instance)->hasExplicitTemplateArgs = (byte) (value ? 1 : 0);
                    }
                }

                public uint NumTemplateArgs
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.CXXDependentScopeMemberExpr.__Internal*) __Instance)->numTemplateArgs;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXDependentScopeMemberExpr.__Internal*)__Instance)->numTemplateArgs = value;
                    }
                }
            }

            public unsafe partial class UnresolvedMemberExpr : global::CppSharp.Parser.AST.OverloadExpr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 112)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal uint numDecls;

                    [FieldOffset(60)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal nameLoc;

                    [FieldOffset(64)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal templateKeywordLoc;

                    [FieldOffset(68)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal lAngleLoc;

                    [FieldOffset(72)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal rAngleLoc;

                    [FieldOffset(76)]
                    internal byte hasTemplateKeyword;

                    [FieldOffset(77)]
                    internal byte hasExplicitTemplateArgs;

                    [FieldOffset(80)]
                    internal uint numTemplateArgs;

                    [FieldOffset(84)]
                    internal byte isImplicitAccess;

                    [FieldOffset(88)]
                    internal global::System.IntPtr @base;

                    [FieldOffset(92)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal baseType;

                    [FieldOffset(100)]
                    internal byte hasUnresolvedUsing;

                    [FieldOffset(101)]
                    internal byte isArrow;

                    [FieldOffset(104)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal operatorLoc;

                    [FieldOffset(108)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal memberLoc;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0UnresolvedMemberExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0UnresolvedMemberExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.UnresolvedMemberExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.UnresolvedMemberExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.UnresolvedMemberExpr __CreateInstance(global::CppSharp.Parser.AST.UnresolvedMemberExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.UnresolvedMemberExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.UnresolvedMemberExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.UnresolvedMemberExpr.__Internal));
                    *(global::CppSharp.Parser.AST.UnresolvedMemberExpr.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private UnresolvedMemberExpr(global::CppSharp.Parser.AST.UnresolvedMemberExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected UnresolvedMemberExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public UnresolvedMemberExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.UnresolvedMemberExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public UnresolvedMemberExpr(global::CppSharp.Parser.AST.UnresolvedMemberExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.UnresolvedMemberExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.UnresolvedMemberExpr.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.UnresolvedMemberExpr.__Internal*) _0.__Instance);
                }

                public bool IsImplicitAccess
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.UnresolvedMemberExpr.__Internal*) __Instance)->isImplicitAccess != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.UnresolvedMemberExpr.__Internal*)__Instance)->isImplicitAccess = (byte) (value ? 1 : 0);
                    }
                }

                public global::CppSharp.Parser.AST.Expr Base
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.UnresolvedMemberExpr.__Internal*) __Instance)->@base == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.UnresolvedMemberExpr.__Internal*) __Instance)->@base))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.UnresolvedMemberExpr.__Internal*) __Instance)->@base];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.UnresolvedMemberExpr.__Internal*) __Instance)->@base);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.UnresolvedMemberExpr.__Internal*)__Instance)->@base = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.QualifiedType BaseType
                {
                    get
                    {
                        return global::CppSharp.Parser.AST.QualifiedType.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.UnresolvedMemberExpr.__Internal*) __Instance)->baseType));
                    }

                    set
                    {
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                        ((global::CppSharp.Parser.AST.UnresolvedMemberExpr.__Internal*)__Instance)->baseType = *(global::CppSharp.Parser.AST.QualifiedType.__Internal*) value.__Instance;
                    }
                }

                public bool HasUnresolvedUsing
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.UnresolvedMemberExpr.__Internal*) __Instance)->hasUnresolvedUsing != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.UnresolvedMemberExpr.__Internal*)__Instance)->hasUnresolvedUsing = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsArrow
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.UnresolvedMemberExpr.__Internal*) __Instance)->isArrow != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.UnresolvedMemberExpr.__Internal*)__Instance)->isArrow = (byte) (value ? 1 : 0);
                    }
                }

                public global::CppSharp.Parser.SourceLocation OperatorLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.UnresolvedMemberExpr.__Internal*) __Instance)->operatorLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.UnresolvedMemberExpr.__Internal*)__Instance)->operatorLoc = value.__Instance;
                    }
                }

                public global::CppSharp.Parser.SourceLocation MemberLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.UnresolvedMemberExpr.__Internal*) __Instance)->memberLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.UnresolvedMemberExpr.__Internal*)__Instance)->memberLoc = value.__Instance;
                    }
                }
            }

            public unsafe partial class CXXNoexceptExpr : global::CppSharp.Parser.AST.Expr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 64)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal global::System.IntPtr operand;

                    [FieldOffset(60)]
                    internal byte value;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CXXNoexceptExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CXXNoexceptExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.CXXNoexceptExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CXXNoexceptExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.CXXNoexceptExpr __CreateInstance(global::CppSharp.Parser.AST.CXXNoexceptExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CXXNoexceptExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.CXXNoexceptExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXNoexceptExpr.__Internal));
                    *(global::CppSharp.Parser.AST.CXXNoexceptExpr.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private CXXNoexceptExpr(global::CppSharp.Parser.AST.CXXNoexceptExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected CXXNoexceptExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public CXXNoexceptExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXNoexceptExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public CXXNoexceptExpr(global::CppSharp.Parser.AST.CXXNoexceptExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXNoexceptExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.CXXNoexceptExpr.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.CXXNoexceptExpr.__Internal*) _0.__Instance);
                }

                public global::CppSharp.Parser.AST.Expr Operand
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.CXXNoexceptExpr.__Internal*) __Instance)->operand == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.CXXNoexceptExpr.__Internal*) __Instance)->operand))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.CXXNoexceptExpr.__Internal*) __Instance)->operand];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.CXXNoexceptExpr.__Internal*) __Instance)->operand);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXNoexceptExpr.__Internal*)__Instance)->operand = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public bool Value
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.CXXNoexceptExpr.__Internal*) __Instance)->value != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXNoexceptExpr.__Internal*)__Instance)->value = (byte) (value ? 1 : 0);
                    }
                }
            }

            public unsafe partial class PackExpansionExpr : global::CppSharp.Parser.AST.Expr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 64)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal global::System.IntPtr pattern;

                    [FieldOffset(60)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal ellipsisLoc;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0PackExpansionExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0PackExpansionExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.PackExpansionExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.PackExpansionExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.PackExpansionExpr __CreateInstance(global::CppSharp.Parser.AST.PackExpansionExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.PackExpansionExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.PackExpansionExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.PackExpansionExpr.__Internal));
                    *(global::CppSharp.Parser.AST.PackExpansionExpr.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private PackExpansionExpr(global::CppSharp.Parser.AST.PackExpansionExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected PackExpansionExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public PackExpansionExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.PackExpansionExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public PackExpansionExpr(global::CppSharp.Parser.AST.PackExpansionExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.PackExpansionExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.PackExpansionExpr.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.PackExpansionExpr.__Internal*) _0.__Instance);
                }

                public global::CppSharp.Parser.AST.Expr Pattern
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.PackExpansionExpr.__Internal*) __Instance)->pattern == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.PackExpansionExpr.__Internal*) __Instance)->pattern))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.PackExpansionExpr.__Internal*) __Instance)->pattern];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.PackExpansionExpr.__Internal*) __Instance)->pattern);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.PackExpansionExpr.__Internal*)__Instance)->pattern = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.SourceLocation EllipsisLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.PackExpansionExpr.__Internal*) __Instance)->ellipsisLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.PackExpansionExpr.__Internal*)__Instance)->ellipsisLoc = value.__Instance;
                    }
                }
            }

            public unsafe partial class SizeOfPackExpr : global::CppSharp.Parser.AST.Expr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 80)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal operatorLoc;

                    [FieldOffset(60)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal packLoc;

                    [FieldOffset(64)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal rParenLoc;

                    [FieldOffset(68)]
                    internal global::System.IntPtr pack;

                    [FieldOffset(72)]
                    internal uint packLength;

                    [FieldOffset(76)]
                    internal byte isPartiallySubstituted;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0SizeOfPackExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0SizeOfPackExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.SizeOfPackExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.SizeOfPackExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.SizeOfPackExpr __CreateInstance(global::CppSharp.Parser.AST.SizeOfPackExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.SizeOfPackExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.SizeOfPackExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.SizeOfPackExpr.__Internal));
                    *(global::CppSharp.Parser.AST.SizeOfPackExpr.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private SizeOfPackExpr(global::CppSharp.Parser.AST.SizeOfPackExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected SizeOfPackExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public SizeOfPackExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.SizeOfPackExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public SizeOfPackExpr(global::CppSharp.Parser.AST.SizeOfPackExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.SizeOfPackExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.SizeOfPackExpr.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.SizeOfPackExpr.__Internal*) _0.__Instance);
                }

                public global::CppSharp.Parser.SourceLocation OperatorLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.SizeOfPackExpr.__Internal*) __Instance)->operatorLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.SizeOfPackExpr.__Internal*)__Instance)->operatorLoc = value.__Instance;
                    }
                }

                public global::CppSharp.Parser.SourceLocation PackLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.SizeOfPackExpr.__Internal*) __Instance)->packLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.SizeOfPackExpr.__Internal*)__Instance)->packLoc = value.__Instance;
                    }
                }

                public global::CppSharp.Parser.SourceLocation RParenLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.SizeOfPackExpr.__Internal*) __Instance)->rParenLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.SizeOfPackExpr.__Internal*)__Instance)->rParenLoc = value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Declaration Pack
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Declaration __result0;
                        if (((global::CppSharp.Parser.AST.SizeOfPackExpr.__Internal*) __Instance)->pack == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Declaration.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.SizeOfPackExpr.__Internal*) __Instance)->pack))
                            __result0 = (global::CppSharp.Parser.AST.Declaration) global::CppSharp.Parser.AST.Declaration.NativeToManagedMap[((global::CppSharp.Parser.AST.SizeOfPackExpr.__Internal*) __Instance)->pack];
                        else __result0 = global::CppSharp.Parser.AST.Declaration.__CreateInstance(((global::CppSharp.Parser.AST.SizeOfPackExpr.__Internal*) __Instance)->pack);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.SizeOfPackExpr.__Internal*)__Instance)->pack = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public uint PackLength
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.SizeOfPackExpr.__Internal*) __Instance)->packLength;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.SizeOfPackExpr.__Internal*)__Instance)->packLength = value;
                    }
                }

                public bool IsPartiallySubstituted
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.SizeOfPackExpr.__Internal*) __Instance)->isPartiallySubstituted != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.SizeOfPackExpr.__Internal*)__Instance)->isPartiallySubstituted = (byte) (value ? 1 : 0);
                    }
                }
            }

            public unsafe partial class SubstNonTypeTemplateParmExpr : global::CppSharp.Parser.AST.Expr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 64)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal nameLoc;

                    [FieldOffset(60)]
                    internal global::System.IntPtr replacement;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0SubstNonTypeTemplateParmExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0SubstNonTypeTemplateParmExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.SubstNonTypeTemplateParmExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.SubstNonTypeTemplateParmExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.SubstNonTypeTemplateParmExpr __CreateInstance(global::CppSharp.Parser.AST.SubstNonTypeTemplateParmExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.SubstNonTypeTemplateParmExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.SubstNonTypeTemplateParmExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.SubstNonTypeTemplateParmExpr.__Internal));
                    *(global::CppSharp.Parser.AST.SubstNonTypeTemplateParmExpr.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private SubstNonTypeTemplateParmExpr(global::CppSharp.Parser.AST.SubstNonTypeTemplateParmExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected SubstNonTypeTemplateParmExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public SubstNonTypeTemplateParmExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.SubstNonTypeTemplateParmExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public SubstNonTypeTemplateParmExpr(global::CppSharp.Parser.AST.SubstNonTypeTemplateParmExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.SubstNonTypeTemplateParmExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.SubstNonTypeTemplateParmExpr.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.SubstNonTypeTemplateParmExpr.__Internal*) _0.__Instance);
                }

                public global::CppSharp.Parser.SourceLocation NameLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.SubstNonTypeTemplateParmExpr.__Internal*) __Instance)->nameLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.SubstNonTypeTemplateParmExpr.__Internal*)__Instance)->nameLoc = value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Expr Replacement
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.SubstNonTypeTemplateParmExpr.__Internal*) __Instance)->replacement == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.SubstNonTypeTemplateParmExpr.__Internal*) __Instance)->replacement))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.SubstNonTypeTemplateParmExpr.__Internal*) __Instance)->replacement];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.SubstNonTypeTemplateParmExpr.__Internal*) __Instance)->replacement);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.SubstNonTypeTemplateParmExpr.__Internal*)__Instance)->replacement = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }
            }

            public unsafe partial class SubstNonTypeTemplateParmPackExpr : global::CppSharp.Parser.AST.Expr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 80)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal parameterPackLocation;

                    [FieldOffset(60)]
                    internal global::CppSharp.Parser.AST.TemplateArgument.__Internal argumentPack;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0SubstNonTypeTemplateParmPackExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0SubstNonTypeTemplateParmPackExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.SubstNonTypeTemplateParmPackExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.SubstNonTypeTemplateParmPackExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.SubstNonTypeTemplateParmPackExpr __CreateInstance(global::CppSharp.Parser.AST.SubstNonTypeTemplateParmPackExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.SubstNonTypeTemplateParmPackExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.SubstNonTypeTemplateParmPackExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.SubstNonTypeTemplateParmPackExpr.__Internal));
                    *(global::CppSharp.Parser.AST.SubstNonTypeTemplateParmPackExpr.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private SubstNonTypeTemplateParmPackExpr(global::CppSharp.Parser.AST.SubstNonTypeTemplateParmPackExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected SubstNonTypeTemplateParmPackExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public SubstNonTypeTemplateParmPackExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.SubstNonTypeTemplateParmPackExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public SubstNonTypeTemplateParmPackExpr(global::CppSharp.Parser.AST.SubstNonTypeTemplateParmPackExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.SubstNonTypeTemplateParmPackExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.SubstNonTypeTemplateParmPackExpr.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.SubstNonTypeTemplateParmPackExpr.__Internal*) _0.__Instance);
                }

                public global::CppSharp.Parser.SourceLocation ParameterPackLocation
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.SubstNonTypeTemplateParmPackExpr.__Internal*) __Instance)->parameterPackLocation);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.SubstNonTypeTemplateParmPackExpr.__Internal*)__Instance)->parameterPackLocation = value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.TemplateArgument ArgumentPack
                {
                    get
                    {
                        return global::CppSharp.Parser.AST.TemplateArgument.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.AST.SubstNonTypeTemplateParmPackExpr.__Internal*) __Instance)->argumentPack));
                    }

                    set
                    {
                        if (ReferenceEquals(value, null))
                            throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                        ((global::CppSharp.Parser.AST.SubstNonTypeTemplateParmPackExpr.__Internal*)__Instance)->argumentPack = *(global::CppSharp.Parser.AST.TemplateArgument.__Internal*) value.__Instance;
                    }
                }
            }

            public unsafe partial class FunctionParmPackExpr : global::CppSharp.Parser.AST.Expr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 64)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal parameterPackLocation;

                    [FieldOffset(60)]
                    internal uint numExpansions;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0FunctionParmPackExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0FunctionParmPackExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.FunctionParmPackExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.FunctionParmPackExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.FunctionParmPackExpr __CreateInstance(global::CppSharp.Parser.AST.FunctionParmPackExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.FunctionParmPackExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.FunctionParmPackExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.FunctionParmPackExpr.__Internal));
                    *(global::CppSharp.Parser.AST.FunctionParmPackExpr.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private FunctionParmPackExpr(global::CppSharp.Parser.AST.FunctionParmPackExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected FunctionParmPackExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public FunctionParmPackExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.FunctionParmPackExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public FunctionParmPackExpr(global::CppSharp.Parser.AST.FunctionParmPackExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.FunctionParmPackExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.FunctionParmPackExpr.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.FunctionParmPackExpr.__Internal*) _0.__Instance);
                }

                public global::CppSharp.Parser.SourceLocation ParameterPackLocation
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.FunctionParmPackExpr.__Internal*) __Instance)->parameterPackLocation);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.FunctionParmPackExpr.__Internal*)__Instance)->parameterPackLocation = value.__Instance;
                    }
                }

                public uint NumExpansions
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.FunctionParmPackExpr.__Internal*) __Instance)->numExpansions;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.FunctionParmPackExpr.__Internal*)__Instance)->numExpansions = value;
                    }
                }
            }

            public unsafe partial class MaterializeTemporaryExpr : global::CppSharp.Parser.AST.Expr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 72)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal global::System.IntPtr temporary;

                    [FieldOffset(60)]
                    internal global::System.IntPtr TemporaryExpr;

                    [FieldOffset(64)]
                    internal uint manglingNumber;

                    [FieldOffset(68)]
                    internal byte isBoundToLvalueReference;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0MaterializeTemporaryExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0MaterializeTemporaryExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                public unsafe partial class ExtraState : IDisposable
                {
                    [StructLayout(LayoutKind.Explicit, Size = 0)]
                    public partial struct __Internal
                    {
                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                            EntryPoint="??0ExtraState@MaterializeTemporaryExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                        internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                            EntryPoint="??0ExtraState@MaterializeTemporaryExpr@AST@CppParser@CppSharp@@QAE@ABV01234@@Z")]
                        internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                    }

                    public global::System.IntPtr __Instance { get; protected set; }

                    internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.MaterializeTemporaryExpr.ExtraState> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.AST.MaterializeTemporaryExpr.ExtraState>();
                    protected internal void*[] __OriginalVTables;

                    protected bool __ownsNativeInstance;

                    internal static global::CppSharp.Parser.AST.MaterializeTemporaryExpr.ExtraState __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                    {
                        return new global::CppSharp.Parser.AST.MaterializeTemporaryExpr.ExtraState(native.ToPointer(), skipVTables);
                    }

                    internal static global::CppSharp.Parser.AST.MaterializeTemporaryExpr.ExtraState __CreateInstance(global::CppSharp.Parser.AST.MaterializeTemporaryExpr.ExtraState.__Internal native, bool skipVTables = false)
                    {
                        return new global::CppSharp.Parser.AST.MaterializeTemporaryExpr.ExtraState(native, skipVTables);
                    }

                    private static void* __CopyValue(global::CppSharp.Parser.AST.MaterializeTemporaryExpr.ExtraState.__Internal native)
                    {
                        var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.MaterializeTemporaryExpr.ExtraState.__Internal));
                        *(global::CppSharp.Parser.AST.MaterializeTemporaryExpr.ExtraState.__Internal*) ret = native;
                        return ret.ToPointer();
                    }

                    private ExtraState(global::CppSharp.Parser.AST.MaterializeTemporaryExpr.ExtraState.__Internal native, bool skipVTables = false)
                        : this(__CopyValue(native), skipVTables)
                    {
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                    }

                    protected ExtraState(void* native, bool skipVTables = false)
                    {
                        if (native == null)
                            return;
                        __Instance = new global::System.IntPtr(native);
                    }

                    public ExtraState()
                    {
                        __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.MaterializeTemporaryExpr.ExtraState.__Internal));
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                        __Internal.ctor(__Instance);
                    }

                    public ExtraState(global::CppSharp.Parser.AST.MaterializeTemporaryExpr.ExtraState _0)
                    {
                        __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.MaterializeTemporaryExpr.ExtraState.__Internal));
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                        *((global::CppSharp.Parser.AST.MaterializeTemporaryExpr.ExtraState.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.MaterializeTemporaryExpr.ExtraState.__Internal*) _0.__Instance);
                    }

                    public void Dispose()
                    {
                        Dispose(disposing: true);
                    }

                    public virtual void Dispose(bool disposing)
                    {
                        if (__Instance == IntPtr.Zero)
                            return;
                        global::CppSharp.Parser.AST.MaterializeTemporaryExpr.ExtraState __dummy;
                        NativeToManagedMap.TryRemove(__Instance, out __dummy);
                        if (__ownsNativeInstance)
                            Marshal.FreeHGlobal(__Instance);
                        __Instance = IntPtr.Zero;
                    }
                }

                internal static new global::CppSharp.Parser.AST.MaterializeTemporaryExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.MaterializeTemporaryExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.MaterializeTemporaryExpr __CreateInstance(global::CppSharp.Parser.AST.MaterializeTemporaryExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.MaterializeTemporaryExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.MaterializeTemporaryExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.MaterializeTemporaryExpr.__Internal));
                    *(global::CppSharp.Parser.AST.MaterializeTemporaryExpr.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private MaterializeTemporaryExpr(global::CppSharp.Parser.AST.MaterializeTemporaryExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected MaterializeTemporaryExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public MaterializeTemporaryExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.MaterializeTemporaryExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public MaterializeTemporaryExpr(global::CppSharp.Parser.AST.MaterializeTemporaryExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.MaterializeTemporaryExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.MaterializeTemporaryExpr.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.MaterializeTemporaryExpr.__Internal*) _0.__Instance);
                }

                public global::CppSharp.Parser.AST.Stmt Temporary
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Stmt __result0;
                        if (((global::CppSharp.Parser.AST.MaterializeTemporaryExpr.__Internal*) __Instance)->temporary == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Stmt.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.MaterializeTemporaryExpr.__Internal*) __Instance)->temporary))
                            __result0 = (global::CppSharp.Parser.AST.Stmt) global::CppSharp.Parser.AST.Stmt.NativeToManagedMap[((global::CppSharp.Parser.AST.MaterializeTemporaryExpr.__Internal*) __Instance)->temporary];
                        else __result0 = global::CppSharp.Parser.AST.Stmt.__CreateInstance(((global::CppSharp.Parser.AST.MaterializeTemporaryExpr.__Internal*) __Instance)->temporary);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.MaterializeTemporaryExpr.__Internal*)__Instance)->temporary = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Expr TemporaryExpr
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.MaterializeTemporaryExpr.__Internal*) __Instance)->TemporaryExpr == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.MaterializeTemporaryExpr.__Internal*) __Instance)->TemporaryExpr))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.MaterializeTemporaryExpr.__Internal*) __Instance)->TemporaryExpr];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.MaterializeTemporaryExpr.__Internal*) __Instance)->TemporaryExpr);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.MaterializeTemporaryExpr.__Internal*)__Instance)->TemporaryExpr = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public uint ManglingNumber
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.MaterializeTemporaryExpr.__Internal*) __Instance)->manglingNumber;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.MaterializeTemporaryExpr.__Internal*)__Instance)->manglingNumber = value;
                    }
                }

                public bool IsBoundToLvalueReference
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.MaterializeTemporaryExpr.__Internal*) __Instance)->isBoundToLvalueReference != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.MaterializeTemporaryExpr.__Internal*)__Instance)->isBoundToLvalueReference = (byte) (value ? 1 : 0);
                    }
                }
            }

            public unsafe partial class CXXFoldExpr : global::CppSharp.Parser.AST.Expr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 84)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal global::System.IntPtr lHS;

                    [FieldOffset(60)]
                    internal global::System.IntPtr rHS;

                    [FieldOffset(64)]
                    internal byte isRightFold;

                    [FieldOffset(65)]
                    internal byte isLeftFold;

                    [FieldOffset(68)]
                    internal global::System.IntPtr pattern;

                    [FieldOffset(72)]
                    internal global::System.IntPtr init;

                    [FieldOffset(76)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal ellipsisLoc;

                    [FieldOffset(80)]
                    internal global::CppSharp.Parser.AST.BinaryOperatorKind _operator;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CXXFoldExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CXXFoldExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.CXXFoldExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CXXFoldExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.CXXFoldExpr __CreateInstance(global::CppSharp.Parser.AST.CXXFoldExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CXXFoldExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.CXXFoldExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXFoldExpr.__Internal));
                    *(global::CppSharp.Parser.AST.CXXFoldExpr.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private CXXFoldExpr(global::CppSharp.Parser.AST.CXXFoldExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected CXXFoldExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public CXXFoldExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXFoldExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public CXXFoldExpr(global::CppSharp.Parser.AST.CXXFoldExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CXXFoldExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.CXXFoldExpr.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.CXXFoldExpr.__Internal*) _0.__Instance);
                }

                public global::CppSharp.Parser.AST.Expr LHS
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.CXXFoldExpr.__Internal*) __Instance)->lHS == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.CXXFoldExpr.__Internal*) __Instance)->lHS))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.CXXFoldExpr.__Internal*) __Instance)->lHS];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.CXXFoldExpr.__Internal*) __Instance)->lHS);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXFoldExpr.__Internal*)__Instance)->lHS = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Expr RHS
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.CXXFoldExpr.__Internal*) __Instance)->rHS == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.CXXFoldExpr.__Internal*) __Instance)->rHS))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.CXXFoldExpr.__Internal*) __Instance)->rHS];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.CXXFoldExpr.__Internal*) __Instance)->rHS);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXFoldExpr.__Internal*)__Instance)->rHS = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public bool IsRightFold
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.CXXFoldExpr.__Internal*) __Instance)->isRightFold != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXFoldExpr.__Internal*)__Instance)->isRightFold = (byte) (value ? 1 : 0);
                    }
                }

                public bool IsLeftFold
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.CXXFoldExpr.__Internal*) __Instance)->isLeftFold != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXFoldExpr.__Internal*)__Instance)->isLeftFold = (byte) (value ? 1 : 0);
                    }
                }

                public global::CppSharp.Parser.AST.Expr Pattern
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.CXXFoldExpr.__Internal*) __Instance)->pattern == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.CXXFoldExpr.__Internal*) __Instance)->pattern))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.CXXFoldExpr.__Internal*) __Instance)->pattern];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.CXXFoldExpr.__Internal*) __Instance)->pattern);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXFoldExpr.__Internal*)__Instance)->pattern = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Expr Init
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.CXXFoldExpr.__Internal*) __Instance)->init == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.CXXFoldExpr.__Internal*) __Instance)->init))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.CXXFoldExpr.__Internal*) __Instance)->init];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.CXXFoldExpr.__Internal*) __Instance)->init);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXFoldExpr.__Internal*)__Instance)->init = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.SourceLocation EllipsisLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.CXXFoldExpr.__Internal*) __Instance)->ellipsisLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXFoldExpr.__Internal*)__Instance)->ellipsisLoc = value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.BinaryOperatorKind Operator
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.CXXFoldExpr.__Internal*) __Instance)->_operator;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CXXFoldExpr.__Internal*)__Instance)->_operator = value;
                    }
                }
            }

            public unsafe partial class CoroutineSuspendExpr : global::CppSharp.Parser.AST.Expr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 80)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal keywordLoc;

                    [FieldOffset(60)]
                    internal global::System.IntPtr commonExpr;

                    [FieldOffset(64)]
                    internal global::System.IntPtr opaqueValue;

                    [FieldOffset(68)]
                    internal global::System.IntPtr readyExpr;

                    [FieldOffset(72)]
                    internal global::System.IntPtr suspendExpr;

                    [FieldOffset(76)]
                    internal global::System.IntPtr resumeExpr;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CoroutineSuspendExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CoroutineSuspendExpr@AST@CppParser@CppSharp@@QAE@W4StmtClass@123@@Z")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance, global::CppSharp.Parser.AST.StmtClass klass);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CoroutineSuspendExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                public enum SubExpr
                {
                    Common = 0,
                    Ready = 1,
                    Suspend = 2,
                    Resume = 3,
                    Count = 4
                }

                internal static new global::CppSharp.Parser.AST.CoroutineSuspendExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CoroutineSuspendExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.CoroutineSuspendExpr __CreateInstance(global::CppSharp.Parser.AST.CoroutineSuspendExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CoroutineSuspendExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.CoroutineSuspendExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CoroutineSuspendExpr.__Internal));
                    *(global::CppSharp.Parser.AST.CoroutineSuspendExpr.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private CoroutineSuspendExpr(global::CppSharp.Parser.AST.CoroutineSuspendExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected CoroutineSuspendExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public CoroutineSuspendExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CoroutineSuspendExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public CoroutineSuspendExpr(global::CppSharp.Parser.AST.StmtClass klass)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CoroutineSuspendExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance, klass);
                }

                public CoroutineSuspendExpr(global::CppSharp.Parser.AST.CoroutineSuspendExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CoroutineSuspendExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.CoroutineSuspendExpr.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.CoroutineSuspendExpr.__Internal*) _0.__Instance);
                }

                public static implicit operator global::CppSharp.Parser.AST.CoroutineSuspendExpr(global::CppSharp.Parser.AST.StmtClass klass)
                {
                    return new global::CppSharp.Parser.AST.CoroutineSuspendExpr(klass);
                }

                public global::CppSharp.Parser.SourceLocation KeywordLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.CoroutineSuspendExpr.__Internal*) __Instance)->keywordLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CoroutineSuspendExpr.__Internal*)__Instance)->keywordLoc = value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Expr CommonExpr
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.CoroutineSuspendExpr.__Internal*) __Instance)->commonExpr == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.CoroutineSuspendExpr.__Internal*) __Instance)->commonExpr))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.CoroutineSuspendExpr.__Internal*) __Instance)->commonExpr];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.CoroutineSuspendExpr.__Internal*) __Instance)->commonExpr);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CoroutineSuspendExpr.__Internal*)__Instance)->commonExpr = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.OpaqueValueExpr OpaqueValue
                {
                    get
                    {
                        global::CppSharp.Parser.AST.OpaqueValueExpr __result0;
                        if (((global::CppSharp.Parser.AST.CoroutineSuspendExpr.__Internal*) __Instance)->opaqueValue == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.OpaqueValueExpr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.CoroutineSuspendExpr.__Internal*) __Instance)->opaqueValue))
                            __result0 = (global::CppSharp.Parser.AST.OpaqueValueExpr) global::CppSharp.Parser.AST.OpaqueValueExpr.NativeToManagedMap[((global::CppSharp.Parser.AST.CoroutineSuspendExpr.__Internal*) __Instance)->opaqueValue];
                        else __result0 = global::CppSharp.Parser.AST.OpaqueValueExpr.__CreateInstance(((global::CppSharp.Parser.AST.CoroutineSuspendExpr.__Internal*) __Instance)->opaqueValue);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CoroutineSuspendExpr.__Internal*)__Instance)->opaqueValue = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Expr ReadyExpr
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.CoroutineSuspendExpr.__Internal*) __Instance)->readyExpr == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.CoroutineSuspendExpr.__Internal*) __Instance)->readyExpr))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.CoroutineSuspendExpr.__Internal*) __Instance)->readyExpr];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.CoroutineSuspendExpr.__Internal*) __Instance)->readyExpr);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CoroutineSuspendExpr.__Internal*)__Instance)->readyExpr = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Expr SuspendExpr
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.CoroutineSuspendExpr.__Internal*) __Instance)->suspendExpr == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.CoroutineSuspendExpr.__Internal*) __Instance)->suspendExpr))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.CoroutineSuspendExpr.__Internal*) __Instance)->suspendExpr];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.CoroutineSuspendExpr.__Internal*) __Instance)->suspendExpr);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CoroutineSuspendExpr.__Internal*)__Instance)->suspendExpr = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.Expr ResumeExpr
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.CoroutineSuspendExpr.__Internal*) __Instance)->resumeExpr == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.CoroutineSuspendExpr.__Internal*) __Instance)->resumeExpr))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.CoroutineSuspendExpr.__Internal*) __Instance)->resumeExpr];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.CoroutineSuspendExpr.__Internal*) __Instance)->resumeExpr);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CoroutineSuspendExpr.__Internal*)__Instance)->resumeExpr = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }
            }

            public unsafe partial class CoawaitExpr : global::CppSharp.Parser.AST.CoroutineSuspendExpr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 88)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal keywordLoc;

                    [FieldOffset(60)]
                    internal global::System.IntPtr commonExpr;

                    [FieldOffset(64)]
                    internal global::System.IntPtr opaqueValue;

                    [FieldOffset(68)]
                    internal global::System.IntPtr readyExpr;

                    [FieldOffset(72)]
                    internal global::System.IntPtr suspendExpr;

                    [FieldOffset(76)]
                    internal global::System.IntPtr resumeExpr;

                    [FieldOffset(80)]
                    internal byte isImplicit;

                    [FieldOffset(84)]
                    internal global::System.IntPtr operand;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CoawaitExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CoawaitExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.CoawaitExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CoawaitExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.CoawaitExpr __CreateInstance(global::CppSharp.Parser.AST.CoawaitExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CoawaitExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.CoawaitExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CoawaitExpr.__Internal));
                    *(global::CppSharp.Parser.AST.CoawaitExpr.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private CoawaitExpr(global::CppSharp.Parser.AST.CoawaitExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected CoawaitExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public CoawaitExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CoawaitExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public CoawaitExpr(global::CppSharp.Parser.AST.CoawaitExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CoawaitExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.CoawaitExpr.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.CoawaitExpr.__Internal*) _0.__Instance);
                }

                public bool IsImplicit
                {
                    get
                    {
                        return ((global::CppSharp.Parser.AST.CoawaitExpr.__Internal*) __Instance)->isImplicit != 0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CoawaitExpr.__Internal*)__Instance)->isImplicit = (byte) (value ? 1 : 0);
                    }
                }

                public global::CppSharp.Parser.AST.Expr Operand
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.CoawaitExpr.__Internal*) __Instance)->operand == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.CoawaitExpr.__Internal*) __Instance)->operand))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.CoawaitExpr.__Internal*) __Instance)->operand];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.CoawaitExpr.__Internal*) __Instance)->operand);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CoawaitExpr.__Internal*)__Instance)->operand = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }
            }

            public unsafe partial class DependentCoawaitExpr : global::CppSharp.Parser.AST.Expr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 68)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal global::System.IntPtr operand;

                    [FieldOffset(60)]
                    internal global::System.IntPtr operatorCoawaitLookup;

                    [FieldOffset(64)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal keywordLoc;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0DependentCoawaitExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0DependentCoawaitExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.DependentCoawaitExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.DependentCoawaitExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.DependentCoawaitExpr __CreateInstance(global::CppSharp.Parser.AST.DependentCoawaitExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.DependentCoawaitExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.DependentCoawaitExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.DependentCoawaitExpr.__Internal));
                    *(global::CppSharp.Parser.AST.DependentCoawaitExpr.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private DependentCoawaitExpr(global::CppSharp.Parser.AST.DependentCoawaitExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected DependentCoawaitExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public DependentCoawaitExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.DependentCoawaitExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public DependentCoawaitExpr(global::CppSharp.Parser.AST.DependentCoawaitExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.DependentCoawaitExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.DependentCoawaitExpr.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.DependentCoawaitExpr.__Internal*) _0.__Instance);
                }

                public global::CppSharp.Parser.AST.Expr Operand
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.DependentCoawaitExpr.__Internal*) __Instance)->operand == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.DependentCoawaitExpr.__Internal*) __Instance)->operand))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.DependentCoawaitExpr.__Internal*) __Instance)->operand];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.DependentCoawaitExpr.__Internal*) __Instance)->operand);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.DependentCoawaitExpr.__Internal*)__Instance)->operand = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.AST.UnresolvedLookupExpr OperatorCoawaitLookup
                {
                    get
                    {
                        global::CppSharp.Parser.AST.UnresolvedLookupExpr __result0;
                        if (((global::CppSharp.Parser.AST.DependentCoawaitExpr.__Internal*) __Instance)->operatorCoawaitLookup == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.UnresolvedLookupExpr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.DependentCoawaitExpr.__Internal*) __Instance)->operatorCoawaitLookup))
                            __result0 = (global::CppSharp.Parser.AST.UnresolvedLookupExpr) global::CppSharp.Parser.AST.UnresolvedLookupExpr.NativeToManagedMap[((global::CppSharp.Parser.AST.DependentCoawaitExpr.__Internal*) __Instance)->operatorCoawaitLookup];
                        else __result0 = global::CppSharp.Parser.AST.UnresolvedLookupExpr.__CreateInstance(((global::CppSharp.Parser.AST.DependentCoawaitExpr.__Internal*) __Instance)->operatorCoawaitLookup);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.DependentCoawaitExpr.__Internal*)__Instance)->operatorCoawaitLookup = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public global::CppSharp.Parser.SourceLocation KeywordLoc
                {
                    get
                    {
                        return global::CppSharp.Parser.SourceLocation.__CreateInstance(((global::CppSharp.Parser.AST.DependentCoawaitExpr.__Internal*) __Instance)->keywordLoc);
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.DependentCoawaitExpr.__Internal*)__Instance)->keywordLoc = value.__Instance;
                    }
                }
            }

            public unsafe partial class CoyieldExpr : global::CppSharp.Parser.AST.CoroutineSuspendExpr, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 84)]
                public new partial struct __Internal
                {
                    [FieldOffset(0)]
                    internal global::CppSharp.Parser.AST.StmtClass stmtClass;

                    [FieldOffset(4)]
                    internal global::CppSharp.Parser.SourceRange.__Internal sourceRange;

                    [FieldOffset(12)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal beginLoc;

                    [FieldOffset(16)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal endLoc;

                    [FieldOffset(20)]
                    internal global::CppSharp.Parser.AST.QualifiedType.__Internal type;

                    [FieldOffset(28)]
                    internal byte valueDependent;

                    [FieldOffset(29)]
                    internal byte typeDependent;

                    [FieldOffset(30)]
                    internal byte instantiationDependent;

                    [FieldOffset(31)]
                    internal byte containsUnexpandedParameterPack;

                    [FieldOffset(32)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal exprLoc;

                    [FieldOffset(36)]
                    internal byte isLValue;

                    [FieldOffset(37)]
                    internal byte isRValue;

                    [FieldOffset(38)]
                    internal byte isXValue;

                    [FieldOffset(39)]
                    internal byte isGLValue;

                    [FieldOffset(40)]
                    internal byte isOrdinaryOrBitFieldObject;

                    [FieldOffset(44)]
                    internal global::System.IntPtr sourceBitField;

                    [FieldOffset(48)]
                    internal global::System.IntPtr referencedDeclOfCallee;

                    [FieldOffset(52)]
                    internal byte hasPlaceholderType;

                    [FieldOffset(56)]
                    internal global::CppSharp.Parser.SourceLocation.__Internal keywordLoc;

                    [FieldOffset(60)]
                    internal global::System.IntPtr commonExpr;

                    [FieldOffset(64)]
                    internal global::System.IntPtr opaqueValue;

                    [FieldOffset(68)]
                    internal global::System.IntPtr readyExpr;

                    [FieldOffset(72)]
                    internal global::System.IntPtr suspendExpr;

                    [FieldOffset(76)]
                    internal global::System.IntPtr resumeExpr;

                    [FieldOffset(80)]
                    internal global::System.IntPtr operand;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CoyieldExpr@AST@CppParser@CppSharp@@QAE@XZ")]
                    internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                        EntryPoint="??0CoyieldExpr@AST@CppParser@CppSharp@@QAE@ABV0123@@Z")]
                    internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);
                }

                internal static new global::CppSharp.Parser.AST.CoyieldExpr __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CoyieldExpr(native.ToPointer(), skipVTables);
                }

                internal static global::CppSharp.Parser.AST.CoyieldExpr __CreateInstance(global::CppSharp.Parser.AST.CoyieldExpr.__Internal native, bool skipVTables = false)
                {
                    return new global::CppSharp.Parser.AST.CoyieldExpr(native, skipVTables);
                }

                private static void* __CopyValue(global::CppSharp.Parser.AST.CoyieldExpr.__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CoyieldExpr.__Internal));
                    *(global::CppSharp.Parser.AST.CoyieldExpr.__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private CoyieldExpr(global::CppSharp.Parser.AST.CoyieldExpr.__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected CoyieldExpr(void* native, bool skipVTables = false)
                    : base((void*) null)
                {
                    if (native == null)
                        return;
                    __Instance = new global::System.IntPtr(native);
                }

                public CoyieldExpr()
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CoyieldExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public CoyieldExpr(global::CppSharp.Parser.AST.CoyieldExpr _0)
                    : this((void*) null)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.AST.CoyieldExpr.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::CppSharp.Parser.AST.CoyieldExpr.__Internal*) __Instance) = *((global::CppSharp.Parser.AST.CoyieldExpr.__Internal*) _0.__Instance);
                }

                public global::CppSharp.Parser.AST.Expr Operand
                {
                    get
                    {
                        global::CppSharp.Parser.AST.Expr __result0;
                        if (((global::CppSharp.Parser.AST.CoyieldExpr.__Internal*) __Instance)->operand == IntPtr.Zero) __result0 = null;
                        else if (global::CppSharp.Parser.AST.Expr.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.AST.CoyieldExpr.__Internal*) __Instance)->operand))
                            __result0 = (global::CppSharp.Parser.AST.Expr) global::CppSharp.Parser.AST.Expr.NativeToManagedMap[((global::CppSharp.Parser.AST.CoyieldExpr.__Internal*) __Instance)->operand];
                        else __result0 = global::CppSharp.Parser.AST.Expr.__CreateInstance(((global::CppSharp.Parser.AST.CoyieldExpr.__Internal*) __Instance)->operand);
                        return __result0;
                    }

                    set
                    {
                        ((global::CppSharp.Parser.AST.CoyieldExpr.__Internal*)__Instance)->operand = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }
            }
        }
    }
}

namespace CppSharp
{
    namespace Parser
    {
        public enum ParserIntType
        {
            NoInt = 0,
            SignedChar = 1,
            UnsignedChar = 2,
            SignedShort = 3,
            UnsignedShort = 4,
            SignedInt = 5,
            UnsignedInt = 6,
            SignedLong = 7,
            UnsignedLong = 8,
            SignedLongLong = 9,
            UnsignedLongLong = 10
        }

        public unsafe partial class ParserTargetInfo : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 184)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C ABI;

                [FieldOffset(24)]
                internal global::CppSharp.Parser.ParserIntType char16Type;

                [FieldOffset(28)]
                internal global::CppSharp.Parser.ParserIntType char32Type;

                [FieldOffset(32)]
                internal global::CppSharp.Parser.ParserIntType int64Type;

                [FieldOffset(36)]
                internal global::CppSharp.Parser.ParserIntType intMaxType;

                [FieldOffset(40)]
                internal global::CppSharp.Parser.ParserIntType intPtrType;

                [FieldOffset(44)]
                internal global::CppSharp.Parser.ParserIntType sizeType;

                [FieldOffset(48)]
                internal global::CppSharp.Parser.ParserIntType uIntMaxType;

                [FieldOffset(52)]
                internal global::CppSharp.Parser.ParserIntType wCharType;

                [FieldOffset(56)]
                internal global::CppSharp.Parser.ParserIntType wIntType;

                [FieldOffset(60)]
                internal uint boolAlign;

                [FieldOffset(64)]
                internal uint boolWidth;

                [FieldOffset(68)]
                internal uint charAlign;

                [FieldOffset(72)]
                internal uint charWidth;

                [FieldOffset(76)]
                internal uint char16Align;

                [FieldOffset(80)]
                internal uint char16Width;

                [FieldOffset(84)]
                internal uint char32Align;

                [FieldOffset(88)]
                internal uint char32Width;

                [FieldOffset(92)]
                internal uint halfAlign;

                [FieldOffset(96)]
                internal uint halfWidth;

                [FieldOffset(100)]
                internal uint floatAlign;

                [FieldOffset(104)]
                internal uint floatWidth;

                [FieldOffset(108)]
                internal uint doubleAlign;

                [FieldOffset(112)]
                internal uint doubleWidth;

                [FieldOffset(116)]
                internal uint shortAlign;

                [FieldOffset(120)]
                internal uint shortWidth;

                [FieldOffset(124)]
                internal uint intAlign;

                [FieldOffset(128)]
                internal uint intWidth;

                [FieldOffset(132)]
                internal uint intMaxTWidth;

                [FieldOffset(136)]
                internal uint longAlign;

                [FieldOffset(140)]
                internal uint longWidth;

                [FieldOffset(144)]
                internal uint longDoubleAlign;

                [FieldOffset(148)]
                internal uint longDoubleWidth;

                [FieldOffset(152)]
                internal uint longLongAlign;

                [FieldOffset(156)]
                internal uint longLongWidth;

                [FieldOffset(160)]
                internal uint pointerAlign;

                [FieldOffset(164)]
                internal uint pointerWidth;

                [FieldOffset(168)]
                internal uint wCharAlign;

                [FieldOffset(172)]
                internal uint wCharWidth;

                [FieldOffset(176)]
                internal uint float128Align;

                [FieldOffset(180)]
                internal uint float128Width;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="??0ParserTargetInfo@CppParser@CppSharp@@QAE@XZ")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="??0ParserTargetInfo@CppParser@CppSharp@@QAE@ABU012@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="??1ParserTargetInfo@CppParser@CppSharp@@QAE@XZ")]
                internal static extern void dtor(global::System.IntPtr __instance, int delete);
            }

            public global::System.IntPtr __Instance { get; protected set; }

            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.ParserTargetInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.ParserTargetInfo>();
            protected internal void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::CppSharp.Parser.ParserTargetInfo __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::CppSharp.Parser.ParserTargetInfo(native.ToPointer(), skipVTables);
            }

            internal static global::CppSharp.Parser.ParserTargetInfo __CreateInstance(global::CppSharp.Parser.ParserTargetInfo.__Internal native, bool skipVTables = false)
            {
                return new global::CppSharp.Parser.ParserTargetInfo(native, skipVTables);
            }

            private static void* __CopyValue(global::CppSharp.Parser.ParserTargetInfo.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.ParserTargetInfo.__Internal));
                global::CppSharp.Parser.ParserTargetInfo.__Internal.cctor(ret, new global::System.IntPtr(&native));
                return ret.ToPointer();
            }

            private ParserTargetInfo(global::CppSharp.Parser.ParserTargetInfo.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected ParserTargetInfo(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public ParserTargetInfo()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.ParserTargetInfo.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor(__Instance);
            }

            public ParserTargetInfo(global::CppSharp.Parser.ParserTargetInfo _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.ParserTargetInfo.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::CppSharp.Parser.ParserTargetInfo __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (disposing)
                    __Internal.dtor(__Instance, 0);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public string ABI
            {
                get
                {
                    var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->ABI));
                    return global::Std.BasicStringExtensions.Data(__basicStringRet0);
                }

                set
                {
                    global::Std.BasicStringExtensions.__Internal.Assign(new global::System.IntPtr(&((global::CppSharp.Parser.ParserTargetInfo.__Internal*)__Instance)->ABI), value);
                }
            }

            public global::CppSharp.Parser.ParserIntType Char16Type
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->char16Type;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserTargetInfo.__Internal*)__Instance)->char16Type = value;
                }
            }

            public global::CppSharp.Parser.ParserIntType Char32Type
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->char32Type;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserTargetInfo.__Internal*)__Instance)->char32Type = value;
                }
            }

            public global::CppSharp.Parser.ParserIntType Int64Type
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->int64Type;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserTargetInfo.__Internal*)__Instance)->int64Type = value;
                }
            }

            public global::CppSharp.Parser.ParserIntType IntMaxType
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->intMaxType;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserTargetInfo.__Internal*)__Instance)->intMaxType = value;
                }
            }

            public global::CppSharp.Parser.ParserIntType IntPtrType
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->intPtrType;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserTargetInfo.__Internal*)__Instance)->intPtrType = value;
                }
            }

            public global::CppSharp.Parser.ParserIntType SizeType
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->sizeType;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserTargetInfo.__Internal*)__Instance)->sizeType = value;
                }
            }

            public global::CppSharp.Parser.ParserIntType UIntMaxType
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->uIntMaxType;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserTargetInfo.__Internal*)__Instance)->uIntMaxType = value;
                }
            }

            public global::CppSharp.Parser.ParserIntType WCharType
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->wCharType;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserTargetInfo.__Internal*)__Instance)->wCharType = value;
                }
            }

            public global::CppSharp.Parser.ParserIntType WIntType
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->wIntType;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserTargetInfo.__Internal*)__Instance)->wIntType = value;
                }
            }

            public uint BoolAlign
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->boolAlign;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserTargetInfo.__Internal*)__Instance)->boolAlign = value;
                }
            }

            public uint BoolWidth
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->boolWidth;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserTargetInfo.__Internal*)__Instance)->boolWidth = value;
                }
            }

            public uint CharAlign
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->charAlign;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserTargetInfo.__Internal*)__Instance)->charAlign = value;
                }
            }

            public uint CharWidth
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->charWidth;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserTargetInfo.__Internal*)__Instance)->charWidth = value;
                }
            }

            public uint Char16Align
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->char16Align;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserTargetInfo.__Internal*)__Instance)->char16Align = value;
                }
            }

            public uint Char16Width
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->char16Width;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserTargetInfo.__Internal*)__Instance)->char16Width = value;
                }
            }

            public uint Char32Align
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->char32Align;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserTargetInfo.__Internal*)__Instance)->char32Align = value;
                }
            }

            public uint Char32Width
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->char32Width;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserTargetInfo.__Internal*)__Instance)->char32Width = value;
                }
            }

            public uint HalfAlign
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->halfAlign;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserTargetInfo.__Internal*)__Instance)->halfAlign = value;
                }
            }

            public uint HalfWidth
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->halfWidth;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserTargetInfo.__Internal*)__Instance)->halfWidth = value;
                }
            }

            public uint FloatAlign
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->floatAlign;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserTargetInfo.__Internal*)__Instance)->floatAlign = value;
                }
            }

            public uint FloatWidth
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->floatWidth;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserTargetInfo.__Internal*)__Instance)->floatWidth = value;
                }
            }

            public uint DoubleAlign
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->doubleAlign;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserTargetInfo.__Internal*)__Instance)->doubleAlign = value;
                }
            }

            public uint DoubleWidth
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->doubleWidth;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserTargetInfo.__Internal*)__Instance)->doubleWidth = value;
                }
            }

            public uint ShortAlign
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->shortAlign;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserTargetInfo.__Internal*)__Instance)->shortAlign = value;
                }
            }

            public uint ShortWidth
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->shortWidth;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserTargetInfo.__Internal*)__Instance)->shortWidth = value;
                }
            }

            public uint IntAlign
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->intAlign;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserTargetInfo.__Internal*)__Instance)->intAlign = value;
                }
            }

            public uint IntWidth
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->intWidth;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserTargetInfo.__Internal*)__Instance)->intWidth = value;
                }
            }

            public uint IntMaxTWidth
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->intMaxTWidth;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserTargetInfo.__Internal*)__Instance)->intMaxTWidth = value;
                }
            }

            public uint LongAlign
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->longAlign;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserTargetInfo.__Internal*)__Instance)->longAlign = value;
                }
            }

            public uint LongWidth
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->longWidth;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserTargetInfo.__Internal*)__Instance)->longWidth = value;
                }
            }

            public uint LongDoubleAlign
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->longDoubleAlign;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserTargetInfo.__Internal*)__Instance)->longDoubleAlign = value;
                }
            }

            public uint LongDoubleWidth
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->longDoubleWidth;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserTargetInfo.__Internal*)__Instance)->longDoubleWidth = value;
                }
            }

            public uint LongLongAlign
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->longLongAlign;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserTargetInfo.__Internal*)__Instance)->longLongAlign = value;
                }
            }

            public uint LongLongWidth
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->longLongWidth;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserTargetInfo.__Internal*)__Instance)->longLongWidth = value;
                }
            }

            public uint PointerAlign
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->pointerAlign;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserTargetInfo.__Internal*)__Instance)->pointerAlign = value;
                }
            }

            public uint PointerWidth
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->pointerWidth;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserTargetInfo.__Internal*)__Instance)->pointerWidth = value;
                }
            }

            public uint WCharAlign
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->wCharAlign;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserTargetInfo.__Internal*)__Instance)->wCharAlign = value;
                }
            }

            public uint WCharWidth
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->wCharWidth;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserTargetInfo.__Internal*)__Instance)->wCharWidth = value;
                }
            }

            public uint Float128Align
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->float128Align;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserTargetInfo.__Internal*)__Instance)->float128Align = value;
                }
            }

            public uint Float128Width
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserTargetInfo.__Internal*) __Instance)->float128Width;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserTargetInfo.__Internal*)__Instance)->float128Width = value;
                }
            }
        }
    }
}

namespace CppSharp
{
    namespace Parser
    {
        public enum ParserDiagnosticLevel
        {
            Ignored = 0,
            Note = 1,
            Warning = 2,
            Error = 3,
            Fatal = 4
        }

        public enum ParserResultKind
        {
            Success = 0,
            Error = 1,
            FileNotFound = 2
        }

        public enum SourceLocationKind
        {
            Invalid = 0,
            Builtin = 1,
            CommandLine = 2,
            System = 3,
            User = 4
        }

        public unsafe partial class Parser
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct __Internal
            {
            }

            public global::System.IntPtr __Instance { get; protected set; }

            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.Parser> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.Parser>();
            protected internal void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::CppSharp.Parser.Parser __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::CppSharp.Parser.Parser(native.ToPointer(), skipVTables);
            }

            internal static global::CppSharp.Parser.Parser __CreateInstance(global::CppSharp.Parser.Parser.__Internal native, bool skipVTables = false)
            {
                return new global::CppSharp.Parser.Parser(native, skipVTables);
            }

            private static void* __CopyValue(global::CppSharp.Parser.Parser.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.Parser.__Internal));
                *(global::CppSharp.Parser.Parser.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private Parser(global::CppSharp.Parser.Parser.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected Parser(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }
        }

        public unsafe partial class CppParserOptions : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 184)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C___N_std_S_allocator__S0_ Arguments;

                [FieldOffset(12)]
                internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C libraryFile;

                [FieldOffset(36)]
                internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C___N_std_S_allocator__S0_ SourceFiles;

                [FieldOffset(48)]
                internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C___N_std_S_allocator__S0_ IncludeDirs;

                [FieldOffset(60)]
                internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C___N_std_S_allocator__S0_ SystemIncludeDirs;

                [FieldOffset(72)]
                internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C___N_std_S_allocator__S0_ Defines;

                [FieldOffset(84)]
                internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C___N_std_S_allocator__S0_ Undefines;

                [FieldOffset(96)]
                internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C___N_std_S_allocator__S0_ LibraryDirs;

                [FieldOffset(108)]
                internal global::Std.Vector.__Internalc__N_std_S_vector____N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C___N_std_S_allocator__S0_ SupportedStdTypes;

                [FieldOffset(120)]
                internal global::System.IntPtr ASTContext;

                [FieldOffset(124)]
                internal int toolSetToUse;

                [FieldOffset(128)]
                internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C targetTriple;

                [FieldOffset(152)]
                internal byte noStandardIncludes;

                [FieldOffset(153)]
                internal byte noBuiltinIncludes;

                [FieldOffset(154)]
                internal byte microsoftMode;

                [FieldOffset(155)]
                internal byte verbose;

                [FieldOffset(156)]
                internal byte unityBuild;

                [FieldOffset(157)]
                internal byte skipPrivateDeclarations;

                [FieldOffset(158)]
                internal byte skipLayoutInfo;

                [FieldOffset(159)]
                internal byte skipFunctionBodies;

                [FieldOffset(160)]
                internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C clangVersion;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="??0CppParserOptions@CppParser@CppSharp@@QAE@XZ")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="??0CppParserOptions@CppParser@CppSharp@@QAE@ABU012@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="??1CppParserOptions@CppParser@CppSharp@@QAE@XZ")]
                internal static extern void dtor(global::System.IntPtr __instance, int delete);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?getArguments@CppParserOptions@CppParser@CppSharp@@QAEPBDI@Z")]
                internal static extern global::System.IntPtr GetArguments(global::System.IntPtr __instance, uint i);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?addArguments@CppParserOptions@CppParser@CppSharp@@QAEXPBD@Z")]
                internal static extern void AddArguments(global::System.IntPtr __instance, [MarshalAs(UnmanagedType.LPUTF8Str)] string s);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?clearArguments@CppParserOptions@CppParser@CppSharp@@QAEXXZ")]
                internal static extern void ClearArguments(global::System.IntPtr __instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?getSourceFiles@CppParserOptions@CppParser@CppSharp@@QAEPBDI@Z")]
                internal static extern global::System.IntPtr GetSourceFiles(global::System.IntPtr __instance, uint i);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?addSourceFiles@CppParserOptions@CppParser@CppSharp@@QAEXPBD@Z")]
                internal static extern void AddSourceFiles(global::System.IntPtr __instance, [MarshalAs(UnmanagedType.LPUTF8Str)] string s);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?clearSourceFiles@CppParserOptions@CppParser@CppSharp@@QAEXXZ")]
                internal static extern void ClearSourceFiles(global::System.IntPtr __instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?getIncludeDirs@CppParserOptions@CppParser@CppSharp@@QAEPBDI@Z")]
                internal static extern global::System.IntPtr GetIncludeDirs(global::System.IntPtr __instance, uint i);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?addIncludeDirs@CppParserOptions@CppParser@CppSharp@@QAEXPBD@Z")]
                internal static extern void AddIncludeDirs(global::System.IntPtr __instance, [MarshalAs(UnmanagedType.LPUTF8Str)] string s);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?clearIncludeDirs@CppParserOptions@CppParser@CppSharp@@QAEXXZ")]
                internal static extern void ClearIncludeDirs(global::System.IntPtr __instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?getSystemIncludeDirs@CppParserOptions@CppParser@CppSharp@@QAEPBDI@Z")]
                internal static extern global::System.IntPtr GetSystemIncludeDirs(global::System.IntPtr __instance, uint i);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?addSystemIncludeDirs@CppParserOptions@CppParser@CppSharp@@QAEXPBD@Z")]
                internal static extern void AddSystemIncludeDirs(global::System.IntPtr __instance, [MarshalAs(UnmanagedType.LPUTF8Str)] string s);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?clearSystemIncludeDirs@CppParserOptions@CppParser@CppSharp@@QAEXXZ")]
                internal static extern void ClearSystemIncludeDirs(global::System.IntPtr __instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?getDefines@CppParserOptions@CppParser@CppSharp@@QAEPBDI@Z")]
                internal static extern global::System.IntPtr GetDefines(global::System.IntPtr __instance, uint i);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?addDefines@CppParserOptions@CppParser@CppSharp@@QAEXPBD@Z")]
                internal static extern void AddDefines(global::System.IntPtr __instance, [MarshalAs(UnmanagedType.LPUTF8Str)] string s);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?clearDefines@CppParserOptions@CppParser@CppSharp@@QAEXXZ")]
                internal static extern void ClearDefines(global::System.IntPtr __instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?getUndefines@CppParserOptions@CppParser@CppSharp@@QAEPBDI@Z")]
                internal static extern global::System.IntPtr GetUndefines(global::System.IntPtr __instance, uint i);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?addUndefines@CppParserOptions@CppParser@CppSharp@@QAEXPBD@Z")]
                internal static extern void AddUndefines(global::System.IntPtr __instance, [MarshalAs(UnmanagedType.LPUTF8Str)] string s);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?clearUndefines@CppParserOptions@CppParser@CppSharp@@QAEXXZ")]
                internal static extern void ClearUndefines(global::System.IntPtr __instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?getLibraryDirs@CppParserOptions@CppParser@CppSharp@@QAEPBDI@Z")]
                internal static extern global::System.IntPtr GetLibraryDirs(global::System.IntPtr __instance, uint i);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?addLibraryDirs@CppParserOptions@CppParser@CppSharp@@QAEXPBD@Z")]
                internal static extern void AddLibraryDirs(global::System.IntPtr __instance, [MarshalAs(UnmanagedType.LPUTF8Str)] string s);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?clearLibraryDirs@CppParserOptions@CppParser@CppSharp@@QAEXXZ")]
                internal static extern void ClearLibraryDirs(global::System.IntPtr __instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?getSupportedStdTypes@CppParserOptions@CppParser@CppSharp@@QAEPBDI@Z")]
                internal static extern global::System.IntPtr GetSupportedStdTypes(global::System.IntPtr __instance, uint i);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?addSupportedStdTypes@CppParserOptions@CppParser@CppSharp@@QAEXPBD@Z")]
                internal static extern void AddSupportedStdTypes(global::System.IntPtr __instance, [MarshalAs(UnmanagedType.LPUTF8Str)] string s);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?clearSupportedStdTypes@CppParserOptions@CppParser@CppSharp@@QAEXXZ")]
                internal static extern void ClearSupportedStdTypes(global::System.IntPtr __instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?getClangVersion@CppParserOptions@CppParser@CppSharp@@QAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ")]
                internal static extern void GetClangVersion(global::System.IntPtr __instance, global::System.IntPtr @return);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?getArgumentsCount@CppParserOptions@CppParser@CppSharp@@QAEIXZ")]
                internal static extern uint GetArgumentsCount(global::System.IntPtr __instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?getSourceFilesCount@CppParserOptions@CppParser@CppSharp@@QAEIXZ")]
                internal static extern uint GetSourceFilesCount(global::System.IntPtr __instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?getIncludeDirsCount@CppParserOptions@CppParser@CppSharp@@QAEIXZ")]
                internal static extern uint GetIncludeDirsCount(global::System.IntPtr __instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?getSystemIncludeDirsCount@CppParserOptions@CppParser@CppSharp@@QAEIXZ")]
                internal static extern uint GetSystemIncludeDirsCount(global::System.IntPtr __instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?getDefinesCount@CppParserOptions@CppParser@CppSharp@@QAEIXZ")]
                internal static extern uint GetDefinesCount(global::System.IntPtr __instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?getUndefinesCount@CppParserOptions@CppParser@CppSharp@@QAEIXZ")]
                internal static extern uint GetUndefinesCount(global::System.IntPtr __instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?getLibraryDirsCount@CppParserOptions@CppParser@CppSharp@@QAEIXZ")]
                internal static extern uint GetLibraryDirsCount(global::System.IntPtr __instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?getSupportedStdTypesCount@CppParserOptions@CppParser@CppSharp@@QAEIXZ")]
                internal static extern uint GetSupportedStdTypesCount(global::System.IntPtr __instance);
            }

            public global::System.IntPtr __Instance { get; protected set; }

            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.CppParserOptions> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.CppParserOptions>();
            protected internal void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::CppSharp.Parser.CppParserOptions __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::CppSharp.Parser.CppParserOptions(native.ToPointer(), skipVTables);
            }

            internal static global::CppSharp.Parser.CppParserOptions __CreateInstance(global::CppSharp.Parser.CppParserOptions.__Internal native, bool skipVTables = false)
            {
                return new global::CppSharp.Parser.CppParserOptions(native, skipVTables);
            }

            private static void* __CopyValue(global::CppSharp.Parser.CppParserOptions.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.CppParserOptions.__Internal));
                global::CppSharp.Parser.CppParserOptions.__Internal.cctor(ret, new global::System.IntPtr(&native));
                return ret.ToPointer();
            }

            private CppParserOptions(global::CppSharp.Parser.CppParserOptions.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected CppParserOptions(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public CppParserOptions()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.CppParserOptions.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor(__Instance);
            }

            public CppParserOptions(global::CppSharp.Parser.CppParserOptions _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.CppParserOptions.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::CppSharp.Parser.CppParserOptions __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (disposing)
                    __Internal.dtor(__Instance, 0);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public string GetArguments(uint i)
            {
                var __ret = __Internal.GetArguments(__Instance, i);
                if (__ret == global::System.IntPtr.Zero)
                    return default(string);
                var __retPtr = (byte*) __ret;
                int __length = 0;
                while (*(__retPtr++) != 0) __length += sizeof(byte);
                return global::System.Text.Encoding.UTF8.GetString((byte*) __ret, __length);
            }

            public void AddArguments(string s)
            {
                __Internal.AddArguments(__Instance, s);
            }

            public void ClearArguments()
            {
                __Internal.ClearArguments(__Instance);
            }

            public string GetSourceFiles(uint i)
            {
                var __ret = __Internal.GetSourceFiles(__Instance, i);
                if (__ret == global::System.IntPtr.Zero)
                    return default(string);
                var __retPtr = (byte*) __ret;
                int __length = 0;
                while (*(__retPtr++) != 0) __length += sizeof(byte);
                return global::System.Text.Encoding.UTF8.GetString((byte*) __ret, __length);
            }

            public void AddSourceFiles(string s)
            {
                __Internal.AddSourceFiles(__Instance, s);
            }

            public void ClearSourceFiles()
            {
                __Internal.ClearSourceFiles(__Instance);
            }

            public string GetIncludeDirs(uint i)
            {
                var __ret = __Internal.GetIncludeDirs(__Instance, i);
                if (__ret == global::System.IntPtr.Zero)
                    return default(string);
                var __retPtr = (byte*) __ret;
                int __length = 0;
                while (*(__retPtr++) != 0) __length += sizeof(byte);
                return global::System.Text.Encoding.UTF8.GetString((byte*) __ret, __length);
            }

            public void AddIncludeDirs(string s)
            {
                __Internal.AddIncludeDirs(__Instance, s);
            }

            public void ClearIncludeDirs()
            {
                __Internal.ClearIncludeDirs(__Instance);
            }

            public string GetSystemIncludeDirs(uint i)
            {
                var __ret = __Internal.GetSystemIncludeDirs(__Instance, i);
                if (__ret == global::System.IntPtr.Zero)
                    return default(string);
                var __retPtr = (byte*) __ret;
                int __length = 0;
                while (*(__retPtr++) != 0) __length += sizeof(byte);
                return global::System.Text.Encoding.UTF8.GetString((byte*) __ret, __length);
            }

            public void AddSystemIncludeDirs(string s)
            {
                __Internal.AddSystemIncludeDirs(__Instance, s);
            }

            public void ClearSystemIncludeDirs()
            {
                __Internal.ClearSystemIncludeDirs(__Instance);
            }

            public string GetDefines(uint i)
            {
                var __ret = __Internal.GetDefines(__Instance, i);
                if (__ret == global::System.IntPtr.Zero)
                    return default(string);
                var __retPtr = (byte*) __ret;
                int __length = 0;
                while (*(__retPtr++) != 0) __length += sizeof(byte);
                return global::System.Text.Encoding.UTF8.GetString((byte*) __ret, __length);
            }

            public void AddDefines(string s)
            {
                __Internal.AddDefines(__Instance, s);
            }

            public void ClearDefines()
            {
                __Internal.ClearDefines(__Instance);
            }

            public string GetUndefines(uint i)
            {
                var __ret = __Internal.GetUndefines(__Instance, i);
                if (__ret == global::System.IntPtr.Zero)
                    return default(string);
                var __retPtr = (byte*) __ret;
                int __length = 0;
                while (*(__retPtr++) != 0) __length += sizeof(byte);
                return global::System.Text.Encoding.UTF8.GetString((byte*) __ret, __length);
            }

            public void AddUndefines(string s)
            {
                __Internal.AddUndefines(__Instance, s);
            }

            public void ClearUndefines()
            {
                __Internal.ClearUndefines(__Instance);
            }

            public string GetLibraryDirs(uint i)
            {
                var __ret = __Internal.GetLibraryDirs(__Instance, i);
                if (__ret == global::System.IntPtr.Zero)
                    return default(string);
                var __retPtr = (byte*) __ret;
                int __length = 0;
                while (*(__retPtr++) != 0) __length += sizeof(byte);
                return global::System.Text.Encoding.UTF8.GetString((byte*) __ret, __length);
            }

            public void AddLibraryDirs(string s)
            {
                __Internal.AddLibraryDirs(__Instance, s);
            }

            public void ClearLibraryDirs()
            {
                __Internal.ClearLibraryDirs(__Instance);
            }

            public string GetSupportedStdTypes(uint i)
            {
                var __ret = __Internal.GetSupportedStdTypes(__Instance, i);
                if (__ret == global::System.IntPtr.Zero)
                    return default(string);
                var __retPtr = (byte*) __ret;
                int __length = 0;
                while (*(__retPtr++) != 0) __length += sizeof(byte);
                return global::System.Text.Encoding.UTF8.GetString((byte*) __ret, __length);
            }

            public void AddSupportedStdTypes(string s)
            {
                __Internal.AddSupportedStdTypes(__Instance, s);
            }

            public void ClearSupportedStdTypes()
            {
                __Internal.ClearSupportedStdTypes(__Instance);
            }

            public string LibraryFile
            {
                get
                {
                    var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.CppParserOptions.__Internal*) __Instance)->libraryFile));
                    return global::Std.BasicStringExtensions.Data(__basicStringRet0);
                }

                set
                {
                    global::Std.BasicStringExtensions.__Internal.Assign(new global::System.IntPtr(&((global::CppSharp.Parser.CppParserOptions.__Internal*)__Instance)->libraryFile), value);
                }
            }

            public global::CppSharp.Parser.AST.ASTContext ASTContext
            {
                get
                {
                    global::CppSharp.Parser.AST.ASTContext __result0;
                    if (((global::CppSharp.Parser.CppParserOptions.__Internal*) __Instance)->ASTContext == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.ASTContext.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.CppParserOptions.__Internal*) __Instance)->ASTContext))
                        __result0 = (global::CppSharp.Parser.AST.ASTContext) global::CppSharp.Parser.AST.ASTContext.NativeToManagedMap[((global::CppSharp.Parser.CppParserOptions.__Internal*) __Instance)->ASTContext];
                    else __result0 = global::CppSharp.Parser.AST.ASTContext.__CreateInstance(((global::CppSharp.Parser.CppParserOptions.__Internal*) __Instance)->ASTContext);
                    return __result0;
                }

                set
                {
                    ((global::CppSharp.Parser.CppParserOptions.__Internal*)__Instance)->ASTContext = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                }
            }

            public int ToolSetToUse
            {
                get
                {
                    return ((global::CppSharp.Parser.CppParserOptions.__Internal*) __Instance)->toolSetToUse;
                }

                set
                {
                    ((global::CppSharp.Parser.CppParserOptions.__Internal*)__Instance)->toolSetToUse = value;
                }
            }

            public string TargetTriple
            {
                get
                {
                    var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.CppParserOptions.__Internal*) __Instance)->targetTriple));
                    return global::Std.BasicStringExtensions.Data(__basicStringRet0);
                }

                set
                {
                    global::Std.BasicStringExtensions.__Internal.Assign(new global::System.IntPtr(&((global::CppSharp.Parser.CppParserOptions.__Internal*)__Instance)->targetTriple), value);
                }
            }

            public bool NoStandardIncludes
            {
                get
                {
                    return ((global::CppSharp.Parser.CppParserOptions.__Internal*) __Instance)->noStandardIncludes != 0;
                }

                set
                {
                    ((global::CppSharp.Parser.CppParserOptions.__Internal*)__Instance)->noStandardIncludes = (byte) (value ? 1 : 0);
                }
            }

            public bool NoBuiltinIncludes
            {
                get
                {
                    return ((global::CppSharp.Parser.CppParserOptions.__Internal*) __Instance)->noBuiltinIncludes != 0;
                }

                set
                {
                    ((global::CppSharp.Parser.CppParserOptions.__Internal*)__Instance)->noBuiltinIncludes = (byte) (value ? 1 : 0);
                }
            }

            public bool MicrosoftMode
            {
                get
                {
                    return ((global::CppSharp.Parser.CppParserOptions.__Internal*) __Instance)->microsoftMode != 0;
                }

                set
                {
                    ((global::CppSharp.Parser.CppParserOptions.__Internal*)__Instance)->microsoftMode = (byte) (value ? 1 : 0);
                }
            }

            public bool Verbose
            {
                get
                {
                    return ((global::CppSharp.Parser.CppParserOptions.__Internal*) __Instance)->verbose != 0;
                }

                set
                {
                    ((global::CppSharp.Parser.CppParserOptions.__Internal*)__Instance)->verbose = (byte) (value ? 1 : 0);
                }
            }

            public bool UnityBuild
            {
                get
                {
                    return ((global::CppSharp.Parser.CppParserOptions.__Internal*) __Instance)->unityBuild != 0;
                }

                set
                {
                    ((global::CppSharp.Parser.CppParserOptions.__Internal*)__Instance)->unityBuild = (byte) (value ? 1 : 0);
                }
            }

            public bool SkipPrivateDeclarations
            {
                get
                {
                    return ((global::CppSharp.Parser.CppParserOptions.__Internal*) __Instance)->skipPrivateDeclarations != 0;
                }

                set
                {
                    ((global::CppSharp.Parser.CppParserOptions.__Internal*)__Instance)->skipPrivateDeclarations = (byte) (value ? 1 : 0);
                }
            }

            public bool SkipLayoutInfo
            {
                get
                {
                    return ((global::CppSharp.Parser.CppParserOptions.__Internal*) __Instance)->skipLayoutInfo != 0;
                }

                set
                {
                    ((global::CppSharp.Parser.CppParserOptions.__Internal*)__Instance)->skipLayoutInfo = (byte) (value ? 1 : 0);
                }
            }

            public bool SkipFunctionBodies
            {
                get
                {
                    return ((global::CppSharp.Parser.CppParserOptions.__Internal*) __Instance)->skipFunctionBodies != 0;
                }

                set
                {
                    ((global::CppSharp.Parser.CppParserOptions.__Internal*)__Instance)->skipFunctionBodies = (byte) (value ? 1 : 0);
                }
            }

            public string ClangVersion
            {
                get
                {
                    var __ret = new global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C();
                    __Internal.GetClangVersion(__Instance, new IntPtr(&__ret));
                    var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new global::System.IntPtr(&__ret));
                    var __retString0 = global::Std.BasicStringExtensions.Data(__basicStringRet0);
                    __basicStringRet0.Dispose();
                    return __retString0;
                }
            }

            public uint ArgumentsCount
            {
                get
                {
                    var __ret = __Internal.GetArgumentsCount(__Instance);
                    return __ret;
                }
            }

            public uint SourceFilesCount
            {
                get
                {
                    var __ret = __Internal.GetSourceFilesCount(__Instance);
                    return __ret;
                }
            }

            public uint IncludeDirsCount
            {
                get
                {
                    var __ret = __Internal.GetIncludeDirsCount(__Instance);
                    return __ret;
                }
            }

            public uint SystemIncludeDirsCount
            {
                get
                {
                    var __ret = __Internal.GetSystemIncludeDirsCount(__Instance);
                    return __ret;
                }
            }

            public uint DefinesCount
            {
                get
                {
                    var __ret = __Internal.GetDefinesCount(__Instance);
                    return __ret;
                }
            }

            public uint UndefinesCount
            {
                get
                {
                    var __ret = __Internal.GetUndefinesCount(__Instance);
                    return __ret;
                }
            }

            public uint LibraryDirsCount
            {
                get
                {
                    var __ret = __Internal.GetLibraryDirsCount(__Instance);
                    return __ret;
                }
            }

            public uint SupportedStdTypesCount
            {
                get
                {
                    var __ret = __Internal.GetSupportedStdTypesCount(__Instance);
                    return __ret;
                }
            }
        }

        public unsafe partial class ParserDiagnostic : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 60)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C fileName;

                [FieldOffset(24)]
                internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C message;

                [FieldOffset(48)]
                internal global::CppSharp.Parser.ParserDiagnosticLevel level;

                [FieldOffset(52)]
                internal int lineNumber;

                [FieldOffset(56)]
                internal int columnNumber;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="??0ParserDiagnostic@CppParser@CppSharp@@QAE@XZ")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="??0ParserDiagnostic@CppParser@CppSharp@@QAE@ABU012@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="??1ParserDiagnostic@CppParser@CppSharp@@QAE@XZ")]
                internal static extern void dtor(global::System.IntPtr __instance, int delete);
            }

            public global::System.IntPtr __Instance { get; protected set; }

            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.ParserDiagnostic> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.ParserDiagnostic>();
            protected internal void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::CppSharp.Parser.ParserDiagnostic __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::CppSharp.Parser.ParserDiagnostic(native.ToPointer(), skipVTables);
            }

            internal static global::CppSharp.Parser.ParserDiagnostic __CreateInstance(global::CppSharp.Parser.ParserDiagnostic.__Internal native, bool skipVTables = false)
            {
                return new global::CppSharp.Parser.ParserDiagnostic(native, skipVTables);
            }

            private static void* __CopyValue(global::CppSharp.Parser.ParserDiagnostic.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.ParserDiagnostic.__Internal));
                global::CppSharp.Parser.ParserDiagnostic.__Internal.cctor(ret, new global::System.IntPtr(&native));
                return ret.ToPointer();
            }

            private ParserDiagnostic(global::CppSharp.Parser.ParserDiagnostic.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected ParserDiagnostic(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public ParserDiagnostic()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.ParserDiagnostic.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor(__Instance);
            }

            public ParserDiagnostic(global::CppSharp.Parser.ParserDiagnostic _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.ParserDiagnostic.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::CppSharp.Parser.ParserDiagnostic __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (disposing)
                    __Internal.dtor(__Instance, 0);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public string FileName
            {
                get
                {
                    var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.ParserDiagnostic.__Internal*) __Instance)->fileName));
                    return global::Std.BasicStringExtensions.Data(__basicStringRet0);
                }

                set
                {
                    global::Std.BasicStringExtensions.__Internal.Assign(new global::System.IntPtr(&((global::CppSharp.Parser.ParserDiagnostic.__Internal*)__Instance)->fileName), value);
                }
            }

            public string Message
            {
                get
                {
                    var __basicStringRet0 = global::Std.BasicString<sbyte, global::Std.CharTraits<sbyte>, global::Std.Allocator<sbyte>>.__CreateInstance(new global::System.IntPtr(&((global::CppSharp.Parser.ParserDiagnostic.__Internal*) __Instance)->message));
                    return global::Std.BasicStringExtensions.Data(__basicStringRet0);
                }

                set
                {
                    global::Std.BasicStringExtensions.__Internal.Assign(new global::System.IntPtr(&((global::CppSharp.Parser.ParserDiagnostic.__Internal*)__Instance)->message), value);
                }
            }

            public global::CppSharp.Parser.ParserDiagnosticLevel Level
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserDiagnostic.__Internal*) __Instance)->level;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserDiagnostic.__Internal*)__Instance)->level = value;
                }
            }

            public int LineNumber
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserDiagnostic.__Internal*) __Instance)->lineNumber;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserDiagnostic.__Internal*)__Instance)->lineNumber = value;
                }
            }

            public int ColumnNumber
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserDiagnostic.__Internal*) __Instance)->columnNumber;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserDiagnostic.__Internal*)__Instance)->columnNumber = value;
                }
            }
        }

        public unsafe partial class ParserResult : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 24)]
            public partial struct __Internal
            {
                [FieldOffset(0)]
                internal global::CppSharp.Parser.ParserResultKind kind;

                [FieldOffset(4)]
                internal global::Std.Vector.__Internalc__N_std_S_vector____N_CppSharp_N_CppParser_S_ParserDiagnostic___N_std_S_allocator__S0_ Diagnostics;

                [FieldOffset(16)]
                internal global::System.IntPtr library;

                [FieldOffset(20)]
                internal global::System.IntPtr targetInfo;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="??0ParserResult@CppParser@CppSharp@@QAE@XZ")]
                internal static extern global::System.IntPtr ctor(global::System.IntPtr __instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="??0ParserResult@CppParser@CppSharp@@QAE@ABU012@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="??1ParserResult@CppParser@CppSharp@@QAE@XZ")]
                internal static extern void dtor(global::System.IntPtr __instance, int delete);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?getDiagnostics@ParserResult@CppParser@CppSharp@@QAE?AUParserDiagnostic@23@I@Z")]
                internal static extern void GetDiagnostics(global::System.IntPtr __instance, global::System.IntPtr @return, uint i);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?addDiagnostics@ParserResult@CppParser@CppSharp@@QAEXAAUParserDiagnostic@23@@Z")]
                internal static extern void AddDiagnostics(global::System.IntPtr __instance, global::System.IntPtr s);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?clearDiagnostics@ParserResult@CppParser@CppSharp@@QAEXXZ")]
                internal static extern void ClearDiagnostics(global::System.IntPtr __instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="?getDiagnosticsCount@ParserResult@CppParser@CppSharp@@QAEIXZ")]
                internal static extern uint GetDiagnosticsCount(global::System.IntPtr __instance);
            }

            public global::System.IntPtr __Instance { get; protected set; }

            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.ParserResult> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.ParserResult>();
            protected internal void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::CppSharp.Parser.ParserResult __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::CppSharp.Parser.ParserResult(native.ToPointer(), skipVTables);
            }

            internal static global::CppSharp.Parser.ParserResult __CreateInstance(global::CppSharp.Parser.ParserResult.__Internal native, bool skipVTables = false)
            {
                return new global::CppSharp.Parser.ParserResult(native, skipVTables);
            }

            private static void* __CopyValue(global::CppSharp.Parser.ParserResult.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.ParserResult.__Internal));
                global::CppSharp.Parser.ParserResult.__Internal.cctor(ret, new global::System.IntPtr(&native));
                return ret.ToPointer();
            }

            private ParserResult(global::CppSharp.Parser.ParserResult.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected ParserResult(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public ParserResult()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.ParserResult.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor(__Instance);
            }

            public ParserResult(global::CppSharp.Parser.ParserResult _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.ParserResult.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::CppSharp.Parser.ParserResult __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (disposing)
                    __Internal.dtor(__Instance, 0);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public global::CppSharp.Parser.ParserDiagnostic GetDiagnostics(uint i)
            {
                var __ret = new global::CppSharp.Parser.ParserDiagnostic.__Internal();
                __Internal.GetDiagnostics(__Instance, new IntPtr(&__ret), i);
                return global::CppSharp.Parser.ParserDiagnostic.__CreateInstance(__ret);
            }

            public void AddDiagnostics(global::CppSharp.Parser.ParserDiagnostic s)
            {
                if (ReferenceEquals(s, null))
                    throw new global::System.ArgumentNullException("s", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = s.__Instance;
                __Internal.AddDiagnostics(__Instance, __arg0);
            }

            public void ClearDiagnostics()
            {
                __Internal.ClearDiagnostics(__Instance);
            }

            public global::CppSharp.Parser.ParserResultKind Kind
            {
                get
                {
                    return ((global::CppSharp.Parser.ParserResult.__Internal*) __Instance)->kind;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserResult.__Internal*)__Instance)->kind = value;
                }
            }

            public global::CppSharp.Parser.AST.NativeLibrary Library
            {
                get
                {
                    global::CppSharp.Parser.AST.NativeLibrary __result0;
                    if (((global::CppSharp.Parser.ParserResult.__Internal*) __Instance)->library == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.AST.NativeLibrary.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.ParserResult.__Internal*) __Instance)->library))
                        __result0 = (global::CppSharp.Parser.AST.NativeLibrary) global::CppSharp.Parser.AST.NativeLibrary.NativeToManagedMap[((global::CppSharp.Parser.ParserResult.__Internal*) __Instance)->library];
                    else __result0 = global::CppSharp.Parser.AST.NativeLibrary.__CreateInstance(((global::CppSharp.Parser.ParserResult.__Internal*) __Instance)->library);
                    return __result0;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserResult.__Internal*)__Instance)->library = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                }
            }

            public global::CppSharp.Parser.ParserTargetInfo TargetInfo
            {
                get
                {
                    global::CppSharp.Parser.ParserTargetInfo __result0;
                    if (((global::CppSharp.Parser.ParserResult.__Internal*) __Instance)->targetInfo == IntPtr.Zero) __result0 = null;
                    else if (global::CppSharp.Parser.ParserTargetInfo.NativeToManagedMap.ContainsKey(((global::CppSharp.Parser.ParserResult.__Internal*) __Instance)->targetInfo))
                        __result0 = (global::CppSharp.Parser.ParserTargetInfo) global::CppSharp.Parser.ParserTargetInfo.NativeToManagedMap[((global::CppSharp.Parser.ParserResult.__Internal*) __Instance)->targetInfo];
                    else __result0 = global::CppSharp.Parser.ParserTargetInfo.__CreateInstance(((global::CppSharp.Parser.ParserResult.__Internal*) __Instance)->targetInfo);
                    return __result0;
                }

                set
                {
                    ((global::CppSharp.Parser.ParserResult.__Internal*)__Instance)->targetInfo = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                }
            }

            public uint DiagnosticsCount
            {
                get
                {
                    var __ret = __Internal.GetDiagnosticsCount(__Instance);
                    return __ret;
                }
            }
        }

        public unsafe partial class ClangParser : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct __Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.ThisCall,
                    EntryPoint="??0ClangParser@CppParser@CppSharp@@QAE@ABV012@@Z")]
                internal static extern global::System.IntPtr cctor(global::System.IntPtr __instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?ParseHeader@ClangParser@CppParser@CppSharp@@SAPAUParserResult@23@PAUCppParserOptions@23@@Z")]
                internal static extern global::System.IntPtr ParseHeader(global::System.IntPtr Opts);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp.CppParser.dll", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="?ParseLibrary@ClangParser@CppParser@CppSharp@@SAPAUParserResult@23@PAUCppParserOptions@23@@Z")]
                internal static extern global::System.IntPtr ParseLibrary(global::System.IntPtr Opts);
            }

            public global::System.IntPtr __Instance { get; protected set; }

            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.ClangParser> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::CppSharp.Parser.ClangParser>();
            protected internal void*[] __OriginalVTables;

            protected bool __ownsNativeInstance;

            internal static global::CppSharp.Parser.ClangParser __CreateInstance(global::System.IntPtr native, bool skipVTables = false)
            {
                return new global::CppSharp.Parser.ClangParser(native.ToPointer(), skipVTables);
            }

            internal static global::CppSharp.Parser.ClangParser __CreateInstance(global::CppSharp.Parser.ClangParser.__Internal native, bool skipVTables = false)
            {
                return new global::CppSharp.Parser.ClangParser(native, skipVTables);
            }

            private static void* __CopyValue(global::CppSharp.Parser.ClangParser.__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.ClangParser.__Internal));
                *(global::CppSharp.Parser.ClangParser.__Internal*) ret = native;
                return ret.ToPointer();
            }

            private ClangParser(global::CppSharp.Parser.ClangParser.__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected ClangParser(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new global::System.IntPtr(native);
            }

            public ClangParser()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.ClangParser.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            public ClangParser(global::CppSharp.Parser.ClangParser _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::CppSharp.Parser.ClangParser.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::CppSharp.Parser.ClangParser.__Internal*) __Instance) = *((global::CppSharp.Parser.ClangParser.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            public virtual void Dispose(bool disposing)
            {
                if (__Instance == IntPtr.Zero)
                    return;
                global::CppSharp.Parser.ClangParser __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public static global::CppSharp.Parser.ParserResult ParseHeader(global::CppSharp.Parser.CppParserOptions Opts)
            {
                var __arg0 = ReferenceEquals(Opts, null) ? global::System.IntPtr.Zero : Opts.__Instance;
                var __ret = __Internal.ParseHeader(__arg0);
                global::CppSharp.Parser.ParserResult __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::CppSharp.Parser.ParserResult.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::CppSharp.Parser.ParserResult) global::CppSharp.Parser.ParserResult.NativeToManagedMap[__ret];
                else __result0 = global::CppSharp.Parser.ParserResult.__CreateInstance(__ret);
                return __result0;
            }

            public static global::CppSharp.Parser.ParserResult ParseLibrary(global::CppSharp.Parser.CppParserOptions Opts)
            {
                var __arg0 = ReferenceEquals(Opts, null) ? global::System.IntPtr.Zero : Opts.__Instance;
                var __ret = __Internal.ParseLibrary(__arg0);
                global::CppSharp.Parser.ParserResult __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (global::CppSharp.Parser.ParserResult.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (global::CppSharp.Parser.ParserResult) global::CppSharp.Parser.ParserResult.NativeToManagedMap[__ret];
                else __result0 = global::CppSharp.Parser.ParserResult.__CreateInstance(__ret);
                return __result0;
            }
        }
    }
}

namespace Std
{
    namespace Pair
    {
        [StructLayout(LayoutKind.Explicit, Size = 28)]
        public unsafe partial struct __Internalc__N_std_S_pair__1__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C____N_CppSharp_N_CppParser_N_AST_S_Declaration
        {
            [FieldOffset(0)]
            internal global::Std.BasicString.__Internalc__N_std_S_basic_string__C___N_std_S_char_traits__C___N_std_S_allocator__C first;

            [FieldOffset(24)]
            internal global::System.IntPtr second;
        }
    }
}
