// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------

#pragma once

#include "Sources.h"
#include "Types.h"
#include <string>

namespace CppSharp::CppParser::AST {

class Expr;
class Stmt;
class LabelStmt;
class EvaluatedStmt;
class CompoundStmt;
enum class OverloadedOperatorKind;

class Decl;
class UsingDirectiveDecl;
class FriendDecl;
class ConstructorUsingShadowDecl;
class LinkageSpecDecl;
class NamedDecl;
class NamespaceDecl;
class TemplateDecl;
class ClassTemplateDecl;
class VarTemplateDecl;
class TypeAliasTemplateDecl;
class FunctionDecl;
class FunctionTemplateDecl;
class CXXMethodDecl;
class CXXConstructorDecl;
class CXXDestructorDecl;
class BaseUsingDecl;

/// <summary>Lists the kind of concrete classes of Decl.</summary>
enum class DeclarationKind
{
    AccessSpec = 0,
    Block = 1,
    Captured = 2,
    ClassScopeFunctionSpecialization = 3,
    Empty = 4,
    Export = 5,
    ExternCContext = 6,
    FileScopeAsm = 7,
    Friend = 8,
    FriendTemplate = 9,
    ImplicitConceptSpecialization = 10,
    Import = 11,
    LifetimeExtendedTemporary = 12,
    LinkageSpec = 13,
    Using = 14,
    UsingEnum = 15,
    HLSLBuffer = 16,
    Label = 17,
    Namespace = 18,
    NamespaceAlias = 19,
    BuiltinTemplate = 28,
    Concept = 29,
    ClassTemplate = 30,
    FunctionTemplate = 31,
    TypeAliasTemplate = 32,
    VarTemplate = 33,
    TemplateTemplateParm = 34,
    Enum = 35,
    Record = 36,
    CXXRecord = 37,
    ClassTemplateSpecialization = 38,
    ClassTemplatePartialSpecialization = 39,
    TemplateTypeParm = 40,
    TypeAlias = 42,
    Typedef = 43,
    UnresolvedUsingTypename = 44,
    UnresolvedUsingIfExists = 45,
    UsingDirective = 46,
    UsingPack = 47,
    UsingShadow = 48,
    ConstructorUsingShadow = 49,
    Binding = 50,
    Field = 51,
    Function = 54,
    CXXDeductionGuide = 55,
    CXXMethod = 56,
    CXXConstructor = 57,
    CXXConversion = 58,
    CXXDestructor = 59,
    MSProperty = 60,
    NonTypeTemplateParm = 61,
    Var = 62,
    Decomposition = 63,
    ImplicitParam = 64,
    ParmVar = 66,
    VarTemplateSpecialization = 67,
    VarTemplatePartialSpecialization = 68,
    EnumConstant = 69,
    IndirectField = 70,
    MSGuid = 71,
    TemplateParamObject = 74,
    UnnamedGlobalConstant = 75,
    UnresolvedUsingValue = 76,
    PragmaComment = 81,
    PragmaDetectMismatch = 82,
    RequiresExprBody = 83,
    StaticAssert = 84,
    TopLevelStmt = 85,
    TranslationUnit = 86,
};

enum class MultiVersionKind
{
    None = 0,
    Target = 1,
    CPUSpecific = 2,
    CPUDispatch = 3,
    TargetClones = 4,
    TargetVersion = 5
};

/// <summary>Define the meaning of possible values of the kind in ExplicitSpecifier.</summary>
enum class ExplicitSpecKind : unsigned int
{
    ResolvedFalse = 0,
    ResolvedTrue = 1,
    Unresolved = 2
};

class CS_API ExplicitSpecifier
{
public:
    ExplicitSpecifier();
    ExplicitSpecKind kind;
    Expr* expr;
    bool isSpecified;
    bool isExplicit;
    bool isInvalid;
};

class CS_API InheritedConstructor
{
public:
    InheritedConstructor();
    ConstructorUsingShadowDecl* shadowDecl;
    CXXConstructorDecl* constructor;
};

/// <summary>
/// <para>A C++ access specifier (public, private, protected), plus the</para>
/// <para>special value &quot;none&quot; which means different things in different contexts.</para>
/// </summary>
enum class AccessSpecifier
{
    Public = 0,
    Protected = 1,
    Private = 2,
    None = 3
};

/// <summary>Storage classes.</summary>
enum class StorageClass
{
    None = 0,
    Extern = 1,
    Static = 2,
    PrivateExtern = 3,
    Auto = 4,
    Register = 5
};

/// <summary>Thread storage-class-specifier.</summary>
enum class ThreadStorageClassSpecifier
{
    Unspecified = 0,
    /// <summary>GNU __thread.</summary>
    Thread = 1,
    /// <summary>
    /// <para>C++11 thread_local. Implies 'static' at block scope, but not at</para>
    /// <para>class scope.</para>
    /// </summary>
    ThreadLocal = 2,
    /// <summary>
    /// <para>C11 _Thread_local. Must be combined with either 'static' or 'extern'</para>
    /// <para>if used at block scope.</para>
    /// </summary>
    ThreadLocal = 3
};

/// <summary>
/// <para>Describes the kind of template specialization that a</para>
/// <para>particular template specialization declaration represents.</para>
/// </summary>
enum class TemplateSpecializationKind
{
    /// <summary>
    /// <para>This template specialization was formed from a template-id but</para>
    /// <para>has not yet been declared, defined, or instantiated.</para>
    /// </summary>
    Undeclared = 0,
    /// <summary>
    /// <para>This template specialization was implicitly instantiated from a</para>
    /// <para>template. (C++ [temp.inst]).</para>
    /// </summary>
    ImplicitInstantiation = 1,
    /// <summary>
    /// <para>This template specialization was declared or defined by an</para>
    /// <para>explicit specialization (C++ [temp.expl.spec]) or partial</para>
    /// <para>specialization (C++ [temp.class.spec]).</para>
    /// </summary>
    ExplicitSpecialization = 2,
    /// <summary>
    /// <para>This template specialization was instantiated from a template</para>
    /// <para>due to an explicit instantiation declaration request</para>
    /// <para>(C++11 [temp.explicit]).</para>
    /// </summary>
    ExplicitInstantiationDeclaration = 3,
    /// <summary>
    /// <para>This template specialization was instantiated from a template</para>
    /// <para>due to an explicit instantiation definition request</para>
    /// <para>(C++ [temp.explicit]).</para>
    /// </summary>
    ExplicitInstantiationDefinition = 4
};

/// <summary>Kinds of BuiltinTemplateDecl.</summary>
enum class BuiltinTemplateKind
{
    /// <summary>This names the __make_integer_seq BuiltinTemplateDecl.</summary>
    BTK__make_integer_seq = 0,
    /// <summary>This names the __type_pack_element BuiltinTemplateDecl.</summary>
    BTK__type_pack_element = 1
};

/// <summary>In-class initialization styles for non-static data members.</summary>
enum class InClassInitStyle
{
    /// <summary>No in-class initializer.</summary>
    NoInit = 0,
    /// <summary>Copy initialization.</summary>
    CopyInit = 1,
    /// <summary>Direct list-initialization.</summary>
    ListInit = 2
};

/// <summary>Define the kind of constexpr specifier.</summary>
enum class ConstexprSpecKind
{
    Unspecified = 0,
    Constexpr = 1,
    Consteval = 2,
    Constinit = 3
};

/// <summary>
/// <para>Describes the different kinds of linkage</para>
/// <para>(C++ [basic.link], C99 6.2.2) that an entity may have.</para>
/// </summary>
enum class Linkage : unsigned char
{
    /// <summary>
    /// <para>No linkage, which means that the entity is unique and</para>
    /// <para>can only be referred to from within its scope.</para>
    /// </summary>
    NoLinkage = 0,
    /// <summary>
    /// <para>Internal linkage, which indicates that the entity can</para>
    /// <para>be referred to from within the translation unit (but not other</para>
    /// <para>translation units).</para>
    /// </summary>
    InternalLinkage = 1,
    /// <summary>External linkage within a unique namespace.</summary>
    /// <remarks>
    /// <para>From the language perspective, these entities have external</para>
    /// <para>linkage. However, since they reside in an anonymous namespace,</para>
    /// <para>their names are unique to this translation unit, which is</para>
    /// <para>equivalent to having internal linkage from the code-generation</para>
    /// <para>point of view.</para>
    /// </remarks>
    UniqueExternalLinkage = 2,
    /// <summary>
    /// <para>No linkage according to the standard, but is visible from other</para>
    /// <para>translation units because of types defined in a inline function.</para>
    /// </summary>
    VisibleNoLinkage = 3,
    /// <summary>
    /// <para>Module linkage, which indicates that the entity can be referred</para>
    /// <para>to from other translation units within the same module, and indirectly</para>
    /// <para>from arbitrary other translation units through inline functions and</para>
    /// <para>templates in the module interface.</para>
    /// </summary>
    ModuleLinkage = 4,
    /// <summary>
    /// <para>External linkage, which indicates that the entity can</para>
    /// <para>be referred to from other translation units.</para>
    /// </summary>
    ExternalLinkage = 5
};

/// <summary>
/// <para>Describes the different kinds of language linkage</para>
/// <para>(C++ [dcl.link]) that an entity may have.</para>
/// </summary>
enum class LanguageLinkage
{
    CLanguageLinkage = 0,
    CXXLanguageLinkage = 1,
    NoLanguageLinkage = 2
};

/// <summary>
/// <para>Describes the different kinds of visibility that a declaration</para>
/// <para>may have.</para>
/// </summary>
/// <remarks>
/// <para>Visibility determines how a declaration interacts with the dynamic</para>
/// <para>linker.  It may also affect whether the symbol can be found by runtime</para>
/// <para>symbol lookup APIs.</para>
/// <para>Visibility is not described in any language standard and</para>
/// <para>(nonetheless) sometimes has odd behavior.  Not all platforms</para>
/// <para>support all visibility kinds.</para>
/// </remarks>
enum class Visibility
{
    /// <summary>
    /// <para>Objects with &quot;hidden&quot; visibility are not seen by the dynamic</para>
    /// <para>linker.</para>
    /// </summary>
    HiddenVisibility = 0,
    /// <summary>
    /// <para>Objects with &quot;protected&quot; visibility are seen by the dynamic</para>
    /// <para>linker but always dynamically resolve to an object within this</para>
    /// <para>shared object.</para>
    /// </summary>
    ProtectedVisibility = 1,
    /// <summary>
    /// <para>Objects with &quot;default&quot; visibility are seen by the dynamic linker</para>
    /// <para>and act like normal objects.</para>
    /// </summary>
    DefaultVisibility = 2
};

class CS_API LinkageInfo
{
public:
    LinkageInfo();
    Linkage linkage;
    Visibility visibility;
    bool isVisibilityExplicit;
};

enum class PragmaMSCommentKind
{
    Unknown = 0,
    Linker = 1,
    Lib = 2,
    Compiler = 3,
    ExeStr = 4,
    User = 5
};

/// <summary>The various types of exception specifications that exist in C++11.</summary>
enum class ExceptionSpecificationType
{
    /// <summary>no exception specification</summary>
    None = 0,
    /// <summary>throw()</summary>
    DynamicNone = 1,
    /// <summary>throw(T1, T2)</summary>
    Dynamic = 2,
    /// <summary>Microsoft throw(...) extension</summary>
    MSAny = 3,
    /// <summary>Microsoft __declspec(nothrow) extension</summary>
    NoThrow = 4,
    /// <summary>noexcept</summary>
    BasicNoexcept = 5,
    /// <summary>noexcept(expression), value-dependent</summary>
    DependentNoexcept = 6,
    /// <summary>noexcept(expression), evals to 'false'</summary>
    NoexceptFalse = 7,
    /// <summary>noexcept(expression), evals to 'true'</summary>
    NoexceptTrue = 8,
    /// <summary>not evaluated yet, for special member function</summary>
    Unevaluated = 9,
    /// <summary>not instantiated yet</summary>
    Uninstantiated = 10,
    /// <summary>not parsed yet</summary>
    Unparsed = 11
};

class CS_API DeclContext
{
public:
    DeclContext();
    VECTOR(Decl*, decls)
    VECTOR(Decl*, noload_decls)
    VECTOR(all_lookups_iterator*, lookups)
    VECTOR(all_lookups_iterator*, noload_lookups)
    VECTOR(UsingDirectiveDecl*, using_directives)
    VECTOR(ddiag_iterator*, ddiags)
    bool hasValidDeclKind;
    DeclarationKind declKind;
    bool isClosure;
    BlockDecl* innermostBlockDecl;
    bool isObjCContainer;
    bool isFunctionOrMethod;
    bool isLookupContext;
    bool isFileContext;
    bool isTranslationUnit;
    bool isRecord;
    bool isNamespace;
    bool isStdNamespace;
    bool isInlineNamespace;
    bool isDependentContext;
    bool isTransparentContext;
    bool isExternCContext;
    LinkageSpecDecl* externCContext;
    bool isExternCXXContext;
    bool hasExternalLexicalStorage;
    bool hasExternalVisibleStorage;
};

class CS_API Redeclarable
{
public:
    Redeclarable();
    VECTOR(Decl*, redecls)
    Decl* previousDecl;
    bool isFirstDecl;
};

class CS_API Mergeable
{
public:
    Mergeable();
    bool isFirstDecl;
};

class CS_API MemberSpecializationInfo
{
public:
    MemberSpecializationInfo();
    NamedDecl* instantiatedFrom;
    TemplateSpecializationKind templateSpecializationKind;
    bool isExplicitSpecialization;
    SourceLocation pointOfInstantiation;
};

class CS_API FunctionTemplateSpecializationInfo
{
public:
    FunctionTemplateSpecializationInfo();
    FunctionDecl* function;
    FunctionTemplateDecl* _template;
    TemplateSpecializationKind templateSpecializationKind;
    bool isExplicitSpecialization;
    bool isExplicitInstantiationOrSpecialization;
    SourceLocation pointOfInstantiation;
    MemberSpecializationInfo* memberSpecializationInfo;
};

class CS_API DependentFunctionTemplateSpecializationInfo
{
public:
    DependentFunctionTemplateSpecializationInfo();
    unsigned int numTemplates;
    TemplateArgumentLoc* templateArgs;
    unsigned int numTemplateArgs;
    ArrayRef<TemplateArgumentLoc> arguments;
    SourceLocation lAngleLoc;
    SourceLocation rAngleLoc;
};

class CS_API ASTTemplateArgumentListInfo
{
public:
    ASTTemplateArgumentListInfo();
    SourceLocation lAngleLoc;
    SourceLocation rAngleLoc;
    TemplateArgumentLoc* templateArgs;
    unsigned int numTemplateArgs;
    ArrayRef<TemplateArgumentLoc> arguments;
};

class CS_API TemplateParmPosition
{
public:
    TemplateParmPosition();
    unsigned int depth;
    unsigned int position;
    unsigned int index;
};

/// <summary>Only used by CXXDeductionGuideDecl.</summary>
enum class DeductionCandidate : unsigned char
{
    Normal = 0,
    Copy = 1,
    Aggregate = 2
};

/// <summary>
/// <para>The kind of C++11 ref-qualifier associated with a function type.</para>
/// <para>This determines whether a member function's &quot;this&quot; object can be an</para>
/// <para>lvalue, rvalue, or neither.</para>
/// </summary>
enum class RefQualifierKind
{
    /// <summary>No ref-qualifier was provided.</summary>
    None = 0,
    /// <summary>An lvalue ref-qualifier was provided (</summary>
    LValue = 1,
    /// <summary>An rvalue ref-qualifier was provided (</summary>
    RValue = 2
};

class CS_API Qualifiers
{
public:
    enum class TQ
    {
        Const = 1,
        Restrict = 2,
        Volatile = 4,
        CVRMask = 7
    };

    enum class GC
    {
        GCNone = 0,
        Weak = 1,
        Strong = 2
    };

    enum class ObjCLifetime
    {
        /// <summary>There is no lifetime qualification on this type.</summary>
        None = 0,
        /// <summary>
        /// <para>This object can be modified without requiring retains or</para>
        /// <para>releases.</para>
        /// </summary>
        ExplicitNone = 1,
        /// <summary>
        /// <para>Assigning into this object requires the old value to be</para>
        /// <para>released and the new value to be retained.  The timing of the</para>
        /// <para>release of the old value is inexact: it may be moved to</para>
        /// <para>immediately after the last known point where the value is</para>
        /// <para>live.</para>
        /// </summary>
        Strong = 2,
        /// <summary>Reading or writing from this object requires a barrier call.</summary>
        Weak = 3,
        /// <summary>Assigning into this object requires a lifetime extension.</summary>
        Autoreleasing = 4
    };

    Qualifiers();
    unsigned int asOpaqueValue;
    bool hasConst;
    bool hasOnlyConst;
    Qualifiers withConst;
    bool hasVolatile;
    bool hasOnlyVolatile;
    Qualifiers withVolatile;
    bool hasRestrict;
    bool hasOnlyRestrict;
    Qualifiers withRestrict;
    bool hasCVRQualifiers;
    unsigned int cVRQualifiers;
    unsigned int cVRUQualifiers;
    bool hasUnaligned;
    bool hasObjCGCAttr;
    GC objCGCAttr;
    Qualifiers withoutObjCGCAttr;
    Qualifiers withoutObjCLifetime;
    Qualifiers withoutAddressSpace;
    bool hasObjCLifetime;
    ObjCLifetime objCLifetime;
    bool hasNonTrivialObjCLifetime;
    bool hasStrongOrWeakObjCLifetime;
    bool hasAddressSpace;
    LangAS addressSpace;
    bool hasTargetSpecificAddressSpace;
    unsigned int addressSpaceAttributePrintValue;
    bool hasFastQualifiers;
    unsigned int fastQualifiers;
    bool hasNonFastQualifiers;
    Qualifiers nonFastQualifiers;
    bool hasQualifiers;
    bool empty;
    std::string asString;
};

class CS_API Decl
{
public:
    /// <summary>
    /// <para>The kind of ownership a declaration has, for visibility purposes.</para>
    /// <para>This enumeration is designed such that higher values represent higher</para>
    /// <para>levels of name hiding.</para>
    /// </summary>
    enum class ModuleOwnershipKind : unsigned int
    {
        /// <summary>This declaration is not owned by a module.</summary>
        Unowned = 0,
        /// <summary>
        /// <para>This declaration has an owning module, but is globally visible</para>
        /// <para>(typically because its owning module is visible and we know that</para>
        /// <para>modules cannot later become hidden in this compilation).</para>
        /// <para>After serialization and deserialization, this will be converted</para>
        /// <para>to VisibleWhenImported.</para>
        /// </summary>
        Visible = 1,
        /// <summary>
        /// <para>This declaration has an owning module, and is visible when that</para>
        /// <para>module is imported.</para>
        /// </summary>
        VisibleWhenImported = 2,
        /// <summary>
        /// <para>This declaration has an owning module, and is visible to lookups</para>
        /// <para>that occurs within that module. And it is reachable in other module</para>
        /// <para>when the owning module is transitively imported.</para>
        /// </summary>
        ReachableWhenImported = 3,
        /// <summary>
        /// <para>This declaration has an owning module, but is only visible to</para>
        /// <para>lookups that occur within that module.</para>
        /// <para>The discarded declarations in global module fragment belongs</para>
        /// <para>to this group too.</para>
        /// </summary>
        ModulePrivate = 4
    };

    /// <summary>
    /// <para>IdentifierNamespace - The different namespaces in which</para>
    /// <para>declarations may appear.  According to C99 6.2.3, there are</para>
    /// <para>four namespaces, labels, tags, members and ordinary</para>
    /// <para>identifiers.  C++ describes lookup completely differently:</para>
    /// <para>certain lookups merely &quot;ignore&quot; certain kinds of declarations,</para>
    /// <para>usually based on whether the declaration is of a type, etc.</para>
    /// </summary>
    /// <remarks>
    /// <para>These are meant as bitmasks, so that searches in</para>
    /// <para>C++ can look into the &quot;tag&quot; namespace during ordinary lookup.</para>
    /// <para>Decl currently provides 15 bits of IDNS bits.</para>
    /// </remarks>
    enum class IdentifierNamespace
    {
        /// <summary>Labels, declared with 'x:' and referenced with 'goto x'.</summary>
        Label = 1,
        /// <summary>
        /// <para>Tags, declared with 'struct foo;' and referenced with</para>
        /// <para>'struct foo'.  All tags are also types.  This is what</para>
        /// <para>elaborated-type-specifiers look for in C.</para>
        /// <para>This also contains names that conflict with tags in the</para>
        /// <para>same scope but that are otherwise ordinary names (non-type</para>
        /// <para>template parameters and indirect field declarations).</para>
        /// </summary>
        Tag = 2,
        /// <summary>
        /// <para>Types, declared with 'struct foo', typedefs, etc.</para>
        /// <para>This is what elaborated-type-specifiers look for in C++,</para>
        /// <para>but note that it's ill-formed to find a non-tag.</para>
        /// </summary>
        Type = 4,
        /// <summary>
        /// <para>Members, declared with object declarations within tag</para>
        /// <para>definitions.  In C, these can only be found by &quot;qualified&quot;</para>
        /// <para>lookup in member expressions.  In C++, they're found by</para>
        /// <para>normal lookup.</para>
        /// </summary>
        Member = 8,
        /// <summary>
        /// <para>Namespaces, declared with 'namespace foo {}'.</para>
        /// <para>Lookup for nested-name-specifiers find these.</para>
        /// </summary>
        Namespace = 16,
        /// <summary>
        /// <para>Ordinary names.  In C, everything that's not a label, tag,</para>
        /// <para>member, or function-local extern ends up here.</para>
        /// </summary>
        Ordinary = 32,
        /// <summary>Objective C@protocol.</summary>
        ObjCProtocol = 64,
        /// <summary>
        /// <para>This declaration is a friend function.  A friend function</para>
        /// <para>declaration is always in this namespace but may also be in</para>
        /// <para>IDNS_Ordinary if it was previously declared.</para>
        /// </summary>
        OrdinaryFriend = 128,
        /// <summary>
        /// <para>This declaration is a friend class.  A friend class</para>
        /// <para>declaration is always in this namespace but may also be in</para>
        /// <para>IDNS_Tag|IDNS_Type if it was previously declared.</para>
        /// </summary>
        TagFriend = 256,
        /// <summary>
        /// <para>This declaration is a using declaration.  A using declaration</para>
        /// <para>*introduces* a number of other declarations into the current</para>
        /// <para>scope, and those declarations use the IDNS of their targets,</para>
        /// <para>but the actual using declarations go in this namespace.</para>
        /// </summary>
        Using = 512,
        /// <summary>
        /// <para>This declaration is a C++ operator declared in a non-class</para>
        /// <para>context.  All such operators are also in IDNS_Ordinary.</para>
        /// <para>C++ lexical operator lookup looks for these.</para>
        /// </summary>
        NonMemberOperator = 1024,
        /// <summary>
        /// <para>This declaration is a function-local extern declaration of a</para>
        /// <para>variable or function. This may also be IDNS_Ordinary if it</para>
        /// <para>has been declared outside any function. These act mostly like</para>
        /// <para>invisible friend declarations, but are also visible to unqualified</para>
        /// <para>lookup within the scope of the declaring function.</para>
        /// </summary>
        LocalExtern = 2048,
        /// <summary>This declaration is an OpenMP user defined reduction construction.</summary>
        OMPReduction = 4096,
        /// <summary>This declaration is an OpenMP user defined mapper.</summary>
        OMPMapper = 8192
    };

    /// <summary>
    /// <para>ObjCDeclQualifier - 'Qualifiers' written next to the return and</para>
    /// <para>parameter types in method declarations.  Other than remembering</para>
    /// <para>them and mangling them into the method's signature string, these</para>
    /// <para>are ignored by the compiler; they are consumed by certain</para>
    /// <para>remote-messaging frameworks.</para>
    /// </summary>
    /// <remarks>
    /// <para>in, inout, and out are mutually exclusive and apply only to</para>
    /// <para>method parameters.  bycopy and byref are mutually exclusive and</para>
    /// <para>apply only to method parameters (?).  oneway applies only to</para>
    /// <para>results.  All of these expect their corresponding parameter to</para>
    /// <para>have a particular type.  None of this is currently enforced by</para>
    /// <para>clang.</para>
    /// <para>This should be kept in sync with ObjCDeclSpec::ObjCDeclQualifier.</para>
    /// </remarks>
    enum class ObjCDeclQualifier
    {
        TQ_None = 0,
        TQ_In = 1,
        TQ_Inout = 2,
        TQ_Out = 4,
        TQ_Bycopy = 8,
        TQ_Byref = 16,
        TQ_Oneway = 32,
        /// <summary>
        /// <para>The nullability qualifier is set when the nullability of the</para>
        /// <para>result or parameter was expressed via a context-sensitive</para>
        /// <para>keyword.</para>
        /// </summary>
        TQ_CSNullability = 64
    };

    enum class FriendObjectKind
    {
        /// <summary>Not a friend object.</summary>
        None = 0,
        /// <summary>A friend of a previously-declared entity.</summary>
        Declared = 1,
        /// <summary>A friend of a previously-undeclared entity.</summary>
        Undeclared = 2
    };

    Decl();
    VECTOR(Decl*, redecls)
    SourceRange sourceRange;
    bool isOutOfLine;
    bool hasBody;
    Stmt* body;
    SourceLocation location;
    DeclarationKind kind;
    bool isInAnonymousNamespace;
    bool isInStdNamespace;
    bool isFileContextDecl;
    AccessSpecifier access;
    AccessSpecifier accessUnsafe;
    bool hasAttrs;
    AttrVec& attrs;
    T* attr;
    bool hasAttr;
    unsigned int maxAlignment;
    bool invalidDecl;
    bool implicit;
    bool referenced;
    bool isThisDeclarationReferenced;
    bool topLevelDeclInObjCContainer;
    ExternalSourceSymbolAttr* externalSourceSymbolAttr;
    bool isInExportDeclContext;
    bool hasDefiningAttr;
    Attr* definingAttr;
    bool isWeakImported;
    bool isFromASTFile;
    unsigned int globalID;
    bool isUnconditionallyVisible;
    bool isReachable;
    unsigned int identifierNamespace;
    bool hasTagIdentifierNamespace;
    bool isTemplated;
    unsigned int templateDepth;
    bool isDefinedOutsideFunctionOrMethod;
    bool isInLocalScopeForInstantiation;
    bool isCanonicalDecl;
    bool isFirstDecl;
    SourceLocation bodyRBrace;
    bool isTemplateParameter;
    bool isTemplateParameterPack;
    bool isParameterPack;
    bool isTemplateDecl;
    bool isFunctionOrFunctionTemplate;
    TemplateDecl* describedTemplate;
    VECTOR(NamedDecl*, describedTemplateParams)
    bool isLocalExternDecl;
    FriendObjectKind friendObjectKind;
    int64_t iD;
    bool isFunctionPointerType;
};

class CS_API TranslationUnitDecl : public Decl, public DeclContext, public Redeclarable<TranslationUnitDecl>
{
public:
    TranslationUnitDecl();
    NamespaceDecl* anonymousNamespace;
};

class CS_API PragmaCommentDecl : public Decl
{
public:
    PragmaCommentDecl();
    PragmaMSCommentKind commentKind;
    std::string arg;
};

class CS_API PragmaDetectMismatchDecl : public Decl
{
public:
    PragmaDetectMismatchDecl();
    std::string name;
    std::string value;
};

class CS_API ExternCContextDecl : public Decl, public DeclContext
{
public:
    ExternCContextDecl();
};

class CS_API NamedDecl : public Decl
{
public:
    /// <summary>Kinds of explicit visibility.</summary>
    enum class ExplicitVisibilityKind
    {
        /// <summary>
        /// <para>Do an LV computation for, ultimately, a type.</para>
        /// <para>Visibility may be restricted by type visibility settings and</para>
        /// <para>the visibility of template arguments.</para>
        /// </summary>
        VisibilityForType = 0,
        /// <summary>
        /// <para>Do an LV computation for, ultimately, a non-type declaration.</para>
        /// <para>Visibility may be restricted by value visibility settings and</para>
        /// <para>the visibility of template arguments.</para>
        /// </summary>
        VisibilityForValue = 1
    };

    NamedDecl();
    IdentifierInfo* identifier;
    std::string name;
    std::string nameAsString;
    DeclarationName declName;
    std::string qualifiedNameAsString;
    bool hasLinkage;
    bool isCXXClassMember;
    bool isCXXInstanceMember;
    Linkage linkageInternal;
    Linkage formalLinkage;
    bool hasExternalFormalLinkage;
    bool isExternallyVisible;
    bool isExternallyDeclarable;
    Visibility visibility;
    LinkageInfo linkageAndVisibility;
    bool isLinkageValid;
    bool hasLinkageBeenComputed;
    ObjCStringFormatFamily objCFStringFormattingFamily;
};

class CS_API LabelDecl : public NamedDecl
{
public:
    LabelDecl();
    LabelStmt* stmt;
    bool isGnuLocal;
    bool isMSAsmLabel;
    bool isResolvedMSAsmLabel;
    std::string mSAsmLabel;
};

class CS_API NamespaceDecl : public NamedDecl, public DeclContext, public Redeclarable<NamespaceDecl>
{
public:
    enum class Flags : unsigned int
    {
        F_Inline = 1,
        F_Nested = 2
    };

    NamespaceDecl();
    bool isAnonymousNamespace;
    bool isInline;
    bool nested;
    bool isOriginalNamespace;
    NamespaceDecl* anonymousNamespace;
    SourceLocation rBraceLoc;
};

class CS_API ValueDecl : public NamedDecl
{
public:
    ValueDecl();
    QualifiedType type;
    bool isWeak;
    bool isInitCapture;
};

class CS_API DeclaratorDecl : public ValueDecl
{
public:
    DeclaratorDecl();
    TypeSourceInfo* typeSourceInfo;
    SourceLocation innerLocStart;
    SourceLocation outerLocStart;
    NestedNameSpecifier* qualifier;
    NestedNameSpecifierLoc qualifierLoc;
    Expr* trailingRequiresClause;
    unsigned int numTemplateParameterLists;
    SourceLocation typeSpecStartLoc;
    SourceLocation typeSpecEndLoc;
};

class CS_API VarDecl : public DeclaratorDecl, public Redeclarable<VarDecl>
{
public:
    /// <summary>Initialization styles.</summary>
    enum class InitializationStyle
    {
        /// <summary>C-style initialization with assignment</summary>
        CInit = 0,
        /// <summary>Call-style initialization (C++98)</summary>
        CallInit = 1,
        /// <summary>Direct list-initialization (C++11)</summary>
        ListInit = 2,
        /// <summary>Parenthesized list-initialization (C++20)</summary>
        ParenListInit = 3
    };

    /// <summary>Kinds of thread-local storage.</summary>
    enum class TLSKind
    {
        /// <summary>Not a TLS variable.</summary>
        None = 0,
        /// <summary>TLS with a known-constant initializer.</summary>
        Static = 1,
        /// <summary>TLS with a dynamic initializer.</summary>
        Dynamic = 2
    };

    enum class DefaultArgKind
    {
        None = 0,
        Unparsed = 1,
        Uninstantiated = 2,
        Normal = 3
    };

    enum class DefinitionKind
    {
        /// <summary>This declaration is only a declaration.</summary>
        DeclarationOnly = 0,
        /// <summary>This declaration is a tentative definition.</summary>
        TentativeDefinition = 1,
        /// <summary>This declaration is definitely a definition.</summary>
        Definition = 2
    };

    VarDecl();
    StorageClass storageClass;
    ThreadStorageClassSpecifier tSCSpec;
    TLSKind tLSKind;
    bool hasLocalStorage;
    bool isStaticLocal;
    bool hasExternalStorage;
    bool hasGlobalStorage;
    StorageDuration storageDuration;
    LanguageLinkage languageLinkage;
    bool isExternC;
    bool isInExternCContext;
    bool isInExternCXXContext;
    bool isLocalVarDecl;
    bool isLocalVarDeclOrParm;
    bool isFunctionOrMethodVarDecl;
    bool isStaticDataMember;
    DefinitionKind isThisDeclarationADefinition;
    DefinitionKind hasDefinition;
    bool isFileVarDecl;
    Expr* anyInitializer;
    bool hasInit;
    Expr* init;
    Stmt** initAddress;
    EvaluatedStmt* ensureEvaluatedStmt;
    EvaluatedStmt* evaluatedStmt;
    APValue* evaluatedValue;
    bool hasConstantInitialization;
    InitializationStyle initStyle;
    bool isDirectInit;
    bool isThisDeclarationADemotedDefinition;
    bool exceptionVariable;
    bool nRVOVariable;
    bool cXXForRangeDecl;
    bool objCForDecl;
    bool aRCPseudoStrong;
    bool isInline;
    bool isInlineSpecified;
    bool _constexpr;
    bool initCapture;
    bool isParameterPack;
    bool previousDeclInSameBlockScope;
    bool isEscapingByref;
    bool isNonEscapingByref;
    bool hasDependentAlignment;
    VarDecl* templateInstantiationPattern;
    VarDecl* instantiatedFromStaticDataMember;
    TemplateSpecializationKind templateSpecializationKind;
    TemplateSpecializationKind templateSpecializationKindForInstantiation;
    SourceLocation pointOfInstantiation;
    MemberSpecializationInfo* memberSpecializationInfo;
    VarTemplateDecl* describedVarTemplate;
    bool isKnownToBeDefined;
};

class CS_API ImplicitParamDecl : public VarDecl
{
public:
    /// <summary>
    /// <para>Defines the kind of the implicit parameter: is this an implicit parameter</para>
    /// <para>with pointer to 'this', 'self', '_cmd', virtual table pointers, captured</para>
    /// <para>context or something else.</para>
    /// </summary>
    enum class ImplicitParamKind : unsigned int
    {
        /// <summary>Parameter for Objective-C 'self' argument</summary>
        ObjCSelf = 0,
        /// <summary>Parameter for Objective-C '_cmd' argument</summary>
        ObjCCmd = 1,
        /// <summary>Parameter for C++ 'this' argument</summary>
        CXXThis = 2,
        /// <summary>Parameter for C++ virtual table pointers</summary>
        CXXVTT = 3,
        /// <summary>Parameter for captured context</summary>
        CapturedContext = 4,
        /// <summary>Parameter for Thread private variable</summary>
        ThreadPrivateVar = 5,
        /// <summary>Other implicit parameter</summary>
        Other = 6
    };

    ImplicitParamDecl();
    ImplicitParamKind parameterKind;
};

class CS_API ParmVarDecl : public VarDecl
{
public:
    ParmVarDecl();
    bool isObjCMethodParameter;
    bool isDestroyedInCallee;
    unsigned int functionScopeDepth;
    unsigned int functionScopeIndex;
    ObjCDeclQualifier objCDeclQualifier;
    bool kNRPromoted;
    Expr* defaultArg;
    SourceRange defaultArgRange;
    Expr* uninstantiatedDefaultArg;
    bool hasDefaultArg;
    bool hasUnparsedDefaultArg;
    bool hasUninstantiatedDefaultArg;
    bool hasInheritedDefaultArg;
    QualifiedType originalType;
};

class CS_API FunctionDecl : public DeclaratorDecl, public DeclContext, public Redeclarable<FunctionDecl>
{
public:
    /// <summary>The kind of templated function a FunctionDecl can be.</summary>
    enum class TemplatedKind
    {
        NonTemplate = 0,
        FunctionTemplate = 1,
        MemberSpecialization = 2,
        FunctionTemplateSpecialization = 3,
        DependentFunctionTemplateSpecialization = 4,
        DependentNonTemplate = 5
    };

    class CS_API DefaultedFunctionInfo
    {
    public:
        DefaultedFunctionInfo();
        ArrayRef<DeclAccessPair> unqualifiedLookups;
    };

    FunctionDecl();
    DeclarationNameInfo nameInfo;
    SourceLocation ellipsisLoc;
    bool hasTrivialBody;
    bool isDefined;
    bool isThisDeclarationADefinition;
    bool isThisDeclarationInstantiatedFromAFriendDefinition;
    DefaultedFunctionInfo* defaultedFunctionInfo;
    bool isVariadic;
    bool virtualAsWritten;
    bool pure;
    bool lateTemplateParsed;
    bool trivial;
    bool trivialForCall;
    bool defaulted;
    bool explicitlyDefaulted;
    SourceLocation defaultLoc;
    bool isUserProvided;
    bool ineligibleOrNotSelected;
    bool hasImplicitReturnZero;
    bool hasPrototype;
    bool hasWrittenPrototype;
    bool hasInheritedPrototype;
    bool isConstexpr;
    ConstexprSpecKind constexprKind;
    bool isConstexprSpecified;
    bool isConsteval;
    bool bodyContainsImmediateEscalatingExpressions;
    bool isImmediateEscalating;
    bool isImmediateFunction;
    bool instantiationIsPending;
    bool usesSEHTry;
    bool isDeleted;
    bool deletedAsWritten;
    bool isMain;
    bool isMSVCRTEntryPoint;
    bool isReservedGlobalPlacementOperator;
    bool isInlineBuiltinDeclaration;
    bool isDestroyingOperatorDelete;
    LanguageLinkage languageLinkage;
    bool isExternC;
    bool isInExternCContext;
    bool isInExternCXXContext;
    bool isGlobal;
    bool isNoReturn;
    bool hasSkippedBody;
    bool willHaveBody;
    bool isMultiVersion;
    bool friendConstraintRefersToEnclosingTemplate;
    bool isMemberLikeConstrainedFriend;
    MultiVersionKind multiVersionKind;
    bool isCPUDispatchMultiVersion;
    bool isCPUSpecificMultiVersion;
    bool isTargetMultiVersion;
    bool isTargetClonesMultiVersion;
    unsigned int numParams;
    unsigned int minRequiredArguments;
    bool hasOneParamOrDefaultArgs;
    QualifiedType returnType;
    SourceRange returnTypeSourceRange;
    SourceRange parametersSourceRange;
    QualifiedType declaredReturnType;
    ExceptionSpecificationType exceptionSpecType;
    SourceRange exceptionSpecSourceRange;
    QualifiedType callResultType;
    StorageClass storageClass;
    bool inlineSpecified;
    bool usesFPIntrin;
    bool isInlined;
    bool isInlineDefinitionExternallyVisible;
    bool isMSExternInline;
    bool isStatic;
    bool isOverloadedOperator;
    OverloadedOperatorKind overloadedOperator;
    IdentifierInfo* literalIdentifier;
    FunctionDecl* instantiatedFromMemberFunction;
    TemplatedKind templatedKind;
    MemberSpecializationInfo* memberSpecializationInfo;
    FunctionDecl* instantiatedFromDecl;
    FunctionTemplateDecl* describedFunctionTemplate;
    bool isFunctionTemplateSpecialization;
    FunctionTemplateSpecializationInfo* templateSpecializationInfo;
    bool isImplicitlyInstantiable;
    bool isTemplateInstantiation;
    FunctionTemplateDecl* primaryTemplate;
    VECTOR(TemplateArgument*, templateSpecializationArgs)
    ASTTemplateArgumentListInfo* templateSpecializationArgsAsWritten;
    DependentFunctionTemplateSpecializationInfo* dependentSpecializationInfo;
    TemplateSpecializationKind templateSpecializationKind;
    TemplateSpecializationKind templateSpecializationKindForInstantiation;
    SourceLocation pointOfInstantiation;
    unsigned int memoryFunctionKind;
};

class CS_API FieldDecl : public DeclaratorDecl, public Mergeable<FieldDecl>
{
public:
    /// <summary>The kinds of value we can store in StorageKind.</summary>
    /// <remarks>
    /// <para>Note that this is compatible with InClassInitStyle except for</para>
    /// <para>ISK_CapturedVLAType.</para>
    /// </remarks>
    enum class InitStorageKind
    {
        /// <summary>
        /// <para>If the pointer is null, there's nothing special.  Otherwise,</para>
        /// <para>this is a bitfield and the pointer is the Expr* storing the</para>
        /// <para>bit-width.</para>
        /// </summary>
        NoInit = 0,
        /// <summary>
        /// <para>The pointer is an (optional due to delayed parsing) Expr*</para>
        /// <para>holding the copy-initializer.</para>
        /// </summary>
        InClassCopyInit = 1,
        /// <summary>
        /// <para>The pointer is an (optional due to delayed parsing) Expr*</para>
        /// <para>holding the list-initializer.</para>
        /// </summary>
        InClassListInit = 2,
        /// <summary>
        /// <para>The pointer is a VariableArrayType* that's been captured;</para>
        /// <para>the enclosing context is a lambda or captured statement.</para>
        /// </summary>
        CapturedVLAType = 3
    };

    FieldDecl();
    unsigned int fieldIndex;
    bool isMutable;
    bool isBitField;
    bool isUnnamedBitfield;
    bool isAnonymousStructOrUnion;
    Expr* bitWidth;
    bool isPotentiallyOverlapping;
    InClassInitStyle inClassInitStyle;
    bool hasInClassInitializer;
    bool hasNonNullInClassInitializer;
    Expr* inClassInitializer;
    bool hasCapturedVLAType;
    VariableArrayType* capturedVLAType;
};

class CS_API EnumConstantDecl : public ValueDecl, public Mergeable<EnumConstantDecl>
{
public:
    EnumConstantDecl();
    Expr* initExpr;
    APSInt& initVal;
};

class CS_API IndirectFieldDecl : public ValueDecl, public Mergeable<IndirectFieldDecl>
{
public:
    IndirectFieldDecl();
    ArrayRef<NamedDecl*> chain;
    unsigned int chainingSize;
    FieldDecl* anonField;
    VarDecl* varDecl;
};

class CS_API TypeDecl : public NamedDecl
{
public:
    TypeDecl();
    Type* typeForDecl;
};

class CS_API TypedefNameDecl : public TypeDecl, public Redeclarable<TypedefNameDecl>
{
public:
    TypedefNameDecl();
    bool isModed;
    TypeSourceInfo* typeSourceInfo;
    QualifiedType underlyingType;
    bool isTransparentTag;
};

class CS_API TypedefDecl : public TypedefNameDecl
{
public:
    TypedefDecl();
};

class CS_API TypeAliasDecl : public TypedefNameDecl
{
public:
    TypeAliasDecl();
    TypeAliasTemplateDecl* describedAliasTemplate;
};

class CS_API TagDecl : public TypeDecl, public DeclContext, public Redeclarable<TagDecl>
{
public:
    TagDecl();
    bool beingDefined;
    bool mayHaveOutOfDateDef;
    SourceRange braceRange;
    SourceLocation innerLocStart;
    SourceLocation outerLocStart;
    bool isThisDeclarationADefinition;
    bool completeDefinition;
    bool completeDefinitionRequired;
    bool embeddedInDeclarator;
    bool freeStanding;
    bool isDependentType;
    bool isThisDeclarationADemotedDefinition;
    TagDecl* definition;
    std::string kindName;
    TagKind tagKind;
    bool isStruct;
    bool isInterface;
    bool isClass;
    bool isUnion;
    bool isEnum;
    bool hasNameForLinkage;
    TypedefNameDecl* typedefNameForAnonDecl;
    NestedNameSpecifier* qualifier;
    NestedNameSpecifierLoc qualifierLoc;
    unsigned int numTemplateParameterLists;
};

class CS_API EnumDecl : public TagDecl
{
public:
    EnumDecl();
    VECTOR(EnumConstantDecl*, enumerators)
    bool scoped;
    bool scopedUsingClassTag;
    bool fixed;
    EnumDecl* definition;
    QualifiedType promotionType;
    QualifiedType integerType;
    TypeSourceInfo* integerTypeSourceInfo;
    SourceRange integerTypeRange;
    unsigned int numPositiveBits;
    unsigned int numNegativeBits;
    unsigned int oDRHash;
    bool isComplete;
    bool isClosed;
    bool isClosedFlag;
    bool isClosedNonFlag;
    EnumDecl* templateInstantiationPattern;
    EnumDecl* instantiatedFromMemberEnum;
    TemplateSpecializationKind templateSpecializationKind;
    MemberSpecializationInfo* memberSpecializationInfo;
};

class CS_API RecordDecl : public TagDecl
{
public:
    /// <summary>
    /// <para>Enum that represents the different ways arguments are passed to and</para>
    /// <para>returned from function calls. This takes into account the target-specific</para>
    /// <para>and version-specific rules along with the rules determined by the</para>
    /// <para>language.</para>
    /// </summary>
    enum class ArgPassingKind : unsigned int
    {
        /// <summary>The argument of this type can be passed directly in registers.</summary>
        CanPassInRegs = 0,
        /// <summary>
        /// <para>The argument of this type cannot be passed directly in registers.</para>
        /// <para>Records containing this type as a subobject are not forced to be passed</para>
        /// <para>indirectly. This value is used only in C++. This value is required by</para>
        /// <para>C++ because, in uncommon situations, it is possible for a class to have</para>
        /// <para>only trivial copy/move constructors even when one of its subobjects has</para>
        /// <para>a non-trivial copy/move constructor (if e.g. the corresponding copy/move</para>
        /// <para>constructor in the derived class is deleted).</para>
        /// </summary>
        CannotPassInRegs = 1,
        /// <summary>
        /// <para>The argument of this type cannot be passed directly in registers.</para>
        /// <para>Records containing this type as a subobject are forced to be passed</para>
        /// <para>indirectly.</para>
        /// </summary>
        CanNeverPassInRegs = 2
    };

    RecordDecl();
    VECTOR(FieldDecl*, fields)
    bool hasFlexibleArrayMember;
    bool anonymousStructOrUnion;
    bool hasObjectMember;
    bool hasVolatileMember;
    bool hasLoadedFieldsFromExternalStorage;
    bool nonTrivialToPrimitiveDefaultInitialize;
    bool nonTrivialToPrimitiveCopy;
    bool nonTrivialToPrimitiveDestroy;
    bool hasNonTrivialToPrimitiveDefaultInitializeCUnion;
    bool hasNonTrivialToPrimitiveDestructCUnion;
    bool hasNonTrivialToPrimitiveCopyCUnion;
    ArgPassingKind argPassingRestrictions;
    bool paramDestroyedInCallee;
    bool isRandomized;
    bool isInjectedClassName;
    bool isLambda;
    bool isCapturedRecord;
    RecordDecl* definition;
    bool isOrContainsUnion;
    FieldDecl* findFirstNamedDataMember;
    unsigned int oDRHash;
};

class CS_API FileScopeAsmDecl : public Decl
{
public:
    FileScopeAsmDecl();
    SourceLocation asmLoc;
    SourceLocation rParenLoc;
    StringLiteral* asmString;
};

class CS_API TopLevelStmtDecl : public Decl
{
public:
    TopLevelStmtDecl();
    Stmt* stmt;
    bool semiMissing;
};

class CS_API BlockDecl : public Decl, public DeclContext
{
public:
    class CS_API Capture
    {
    public:
        Capture();
        VarDecl* variable;
        bool isByRef;
        bool isEscapingByref;
        bool isNonEscapingByref;
        bool isNested;
        bool hasCopyExpr;
        Expr* copyExpr;
    };

    BlockDecl();
    SourceLocation caretLocation;
    bool isVariadic;
    CompoundStmt* compoundBody;
    TypeSourceInfo* signatureAsWritten;
    unsigned int numParams;
    bool hasCaptures;
    unsigned int numCaptures;
    ArrayRef<Capture> captures;
    bool capturesCXXThis;
    bool blockMissingReturnType;
    bool isConversionFromLambda;
    bool doesNotEscape;
    bool canAvoidCopyToHeap;
    unsigned int blockManglingNumber;
    Decl* blockManglingContextDecl;
};

class CS_API CapturedDecl : public Decl, public DeclContext
{
public:
    CapturedDecl();
    bool nothrow;
    unsigned int numParams;
    ImplicitParamDecl* contextParam;
    unsigned int contextParamPosition;
};

class CS_API ImportDecl : public Decl
{
public:
    ImportDecl();
    Module* importedModule;
    ArrayRef<SourceLocation> identifierLocs;
};

class CS_API ExportDecl : public Decl, public DeclContext
{
public:
    ExportDecl();
    SourceLocation exportLoc;
    SourceLocation rBraceLoc;
    bool hasBraces;
};

class CS_API EmptyDecl : public Decl
{
public:
    EmptyDecl();
};

class CS_API HLSLBufferDecl : public NamedDecl, public DeclContext
{
public:
    HLSLBufferDecl();
    SourceLocation locStart;
    SourceLocation lBraceLoc;
    SourceLocation rBraceLoc;
    bool isCBuffer;
};

class CS_API AccessSpecDecl : public Decl
{
public:
    AccessSpecDecl();
    SourceLocation accessSpecifierLoc;
    SourceLocation colonLoc;
};

class CS_API CXXRecordDecl : public RecordDecl
{
public:
    /// <summary>Values used in DefinitionData fields to represent special members.</summary>
    enum class SpecialMemberFlags
    {
        DefaultConstructor = 1,
        CopyConstructor = 2,
        MoveConstructor = 4,
        CopyAssignment = 8,
        MoveAssignment = 16,
        Destructor = 32,
        All = 63
    };

    enum class LambdaDependencyKind
    {
        Unknown = 0,
        AlwaysDependent = 1,
        NeverDependent = 2
    };

    class CS_API LambdaNumbering
    {
    public:
        LambdaNumbering();
    };

    CXXRecordDecl();
    VECTOR(CXXMethodDecl*, methods)
    VECTOR(CXXConstructorDecl*, ctors)
    VECTOR(FriendDecl*, friends)
    CXXRecordDecl* definition;
    bool hasDefinition;
    bool isDynamicClass;
    bool mayBeDynamicClass;
    bool mayBeNonDynamicClass;
    bool isParsingBaseSpecifiers;
    unsigned int oDRHash;
    unsigned int numBases;
    unsigned int numVBases;
    bool hasAnyDependentBases;
    bool hasFriends;
    bool defaultedCopyConstructorIsDeleted;
    bool defaultedMoveConstructorIsDeleted;
    bool defaultedDestructorIsDeleted;
    bool hasSimpleCopyConstructor;
    bool hasSimpleMoveConstructor;
    bool hasSimpleCopyAssignment;
    bool hasSimpleMoveAssignment;
    bool hasSimpleDestructor;
    bool hasDefaultConstructor;
    bool needsImplicitDefaultConstructor;
    bool hasUserDeclaredConstructor;
    bool hasUserProvidedDefaultConstructor;
    bool hasUserDeclaredCopyConstructor;
    bool needsImplicitCopyConstructor;
    bool needsOverloadResolutionForCopyConstructor;
    bool implicitCopyConstructorHasConstParam;
    bool hasCopyConstructorWithConstParam;
    bool hasUserDeclaredMoveOperation;
    bool hasUserDeclaredMoveConstructor;
    bool hasMoveConstructor;
    bool needsImplicitMoveConstructor;
    bool needsOverloadResolutionForMoveConstructor;
    bool hasUserDeclaredCopyAssignment;
    bool needsImplicitCopyAssignment;
    bool needsOverloadResolutionForCopyAssignment;
    bool implicitCopyAssignmentHasConstParam;
    bool hasCopyAssignmentWithConstParam;
    bool hasUserDeclaredMoveAssignment;
    bool hasMoveAssignment;
    bool needsImplicitMoveAssignment;
    bool needsOverloadResolutionForMoveAssignment;
    bool hasUserDeclaredDestructor;
    bool needsImplicitDestructor;
    bool needsOverloadResolutionForDestructor;
    bool isLambda;
    bool isGenericLambda;
    bool lambdaIsDefaultConstructibleAndAssignable;
    CXXMethodDecl* lambdaCallOperator;
    FunctionTemplateDecl* dependentLambdaCallOperator;
    CXXMethodDecl* lambdaStaticInvoker;
    VECTOR(NamedDecl*, genericLambdaTemplateParameterList)
    ArrayRef<NamedDecl*> lambdaExplicitTemplateParameters;
    LambdaCaptureDefault lambdaCaptureDefault;
    bool isAggregate;
    bool hasInClassInitializer;
    bool hasUninitializedReferenceMember;
    bool isPOD;
    bool isCLike;
    bool isEmpty;
    bool hasInitMethod;
    bool hasPrivateFields;
    bool hasProtectedFields;
    bool hasDirectFields;
    bool isPolymorphic;
    bool isAbstract;
    bool isStandardLayout;
    bool isCXX11StandardLayout;
    bool hasMutableFields;
    bool hasVariantMembers;
    bool hasTrivialDefaultConstructor;
    bool hasNonTrivialDefaultConstructor;
    bool hasConstexprNonCopyMoveConstructor;
    bool defaultedDefaultConstructorIsConstexpr;
    bool hasConstexprDefaultConstructor;
    bool hasTrivialCopyConstructor;
    bool hasTrivialCopyConstructorForCall;
    bool hasNonTrivialCopyConstructor;
    bool hasNonTrivialCopyConstructorForCall;
    bool hasTrivialMoveConstructor;
    bool hasTrivialMoveConstructorForCall;
    bool hasNonTrivialMoveConstructor;
    bool hasNonTrivialMoveConstructorForCall;
    bool hasTrivialCopyAssignment;
    bool hasNonTrivialCopyAssignment;
    bool hasTrivialMoveAssignment;
    bool hasNonTrivialMoveAssignment;
    bool defaultedDestructorIsConstexpr;
    bool hasConstexprDestructor;
    bool hasTrivialDestructor;
    bool hasTrivialDestructorForCall;
    bool hasNonTrivialDestructor;
    bool hasNonTrivialDestructorForCall;
    bool hasIrrelevantDestructor;
    bool hasNonLiteralTypeFieldsOrBases;
    bool hasInheritedConstructor;
    bool hasInheritedAssignment;
    bool isTriviallyCopyable;
    bool isTrivial;
    bool isLiteral;
    bool isStructural;
    CXXRecordDecl* instantiatedFromMemberClass;
    MemberSpecializationInfo* memberSpecializationInfo;
    ClassTemplateDecl* describedClassTemplate;
    TemplateSpecializationKind templateSpecializationKind;
    CXXDestructorDecl* destructor;
    bool isAnyDestructorNoReturn;
    bool mayBeAbstract;
    bool isEffectivelyFinal;
    unsigned int lambdaManglingNumber;
    bool hasKnownLambdaInternalLinkage;
    Decl* lambdaContextDecl;
    unsigned int lambdaIndexInContext;
    LambdaNumbering lambdaNumbering;
    unsigned int deviceLambdaManglingNumber;
    MSInheritanceModel mSInheritanceModel;
    bool nullFieldOffsetIsZero;
    MSVtorDispMode mSVtorDispMode;
    bool isDependentLambda;
    bool isNeverDependentLambda;
    unsigned int lambdaDependencyKind;
    TypeSourceInfo* lambdaTypeInfo;
    bool isInterfaceLike;
};

class CS_API CXXDeductionGuideDecl : public FunctionDecl
{
public:
    CXXDeductionGuideDecl();
    bool isExplicit;
    TemplateDecl* deducedTemplate;
    CXXConstructorDecl* correspondingConstructor;
    DeductionCandidate deductionCandidateKind;
};

class CS_API RequiresExprBodyDecl : public Decl, public DeclContext
{
public:
    RequiresExprBodyDecl();
};

class CS_API CXXMethodDecl : public FunctionDecl
{
public:
    CXXMethodDecl();
    VECTOR(const clang::CXXMethodDecl*, overridden_methods)
    bool isStatic;
    bool isInstance;
    bool isConst;
    bool isVolatile;
    bool isVirtual;
    bool isCopyAssignmentOperator;
    bool isMoveAssignmentOperator;
    unsigned int size_overridden_methods;
    QualifiedType thisType;
    QualifiedType thisObjectType;
    Qualifiers methodQualifiers;
    RefQualifierKind refQualifier;
    bool hasInlineBody;
    bool isLambdaStaticInvoker;
};

class CS_API CXXConstructorDecl : public CXXMethodDecl
{
public:
    enum class TrailingAllocKind
    {
        TAKInheritsConstructor = 1,
        TAKHasTailExplicit = 2
    };

    CXXConstructorDecl();
    ExplicitSpecifier explicitSpecifier;
    bool isExplicit;
    unsigned int numCtorInitializers;
    bool isDelegatingConstructor;
    CXXConstructorDecl* targetConstructor;
    bool isDefaultConstructor;
    bool isCopyConstructor;
    bool isMoveConstructor;
    bool isCopyOrMoveConstructor;
    bool isSpecializationCopyingObject;
    bool inheritingConstructor;
    InheritedConstructor inheritedConstructor;
};

class CS_API CXXDestructorDecl : public CXXMethodDecl
{
public:
    CXXDestructorDecl();
    FunctionDecl* operatorDelete;
    Expr* operatorDeleteThisArg;
};

class CS_API CXXConversionDecl : public CXXMethodDecl
{
public:
    CXXConversionDecl();
    ExplicitSpecifier explicitSpecifier;
    bool isExplicit;
    QualifiedType conversionType;
    bool isLambdaToBlockPointerConversion;
};

class CS_API LinkageSpecDecl : public Decl, public DeclContext
{
public:
    /// <summary>Represents the language in a linkage specification.</summary>
    /// <remarks>
    /// <para>The values are part of the serialization ABI for</para>
    /// <para>ASTs and cannot be changed without altering that ABI.</para>
    /// </remarks>
    enum class LanguageIDs
    {
        lang_c = 1,
        lang_cxx = 2
    };

    LinkageSpecDecl();
    LanguageIDs language;
    bool hasBraces;
    SourceLocation externLoc;
    SourceLocation rBraceLoc;
};

class CS_API UsingDirectiveDecl : public NamedDecl
{
public:
    UsingDirectiveDecl();
    NestedNameSpecifierLoc qualifierLoc;
    NestedNameSpecifier* qualifier;
    SourceLocation usingLoc;
    SourceLocation namespaceKeyLocation;
    SourceLocation identLocation;
};

class CS_API NamespaceAliasDecl : public NamedDecl, public Redeclarable<NamespaceAliasDecl>
{
public:
    NamespaceAliasDecl();
    NestedNameSpecifierLoc qualifierLoc;
    NestedNameSpecifier* qualifier;
    SourceLocation aliasLoc;
    SourceLocation namespaceLoc;
    SourceLocation targetNameLoc;
    NamedDecl* aliasedNamespace;
};

class CS_API LifetimeExtendedTemporaryDecl : public Decl, public Mergeable<LifetimeExtendedTemporaryDecl>
{
public:
    LifetimeExtendedTemporaryDecl();
    StorageDuration storageDuration;
    unsigned int manglingNumber;
    APValue* value;
};

class CS_API UsingShadowDecl : public NamedDecl, public Redeclarable<UsingShadowDecl>
{
public:
    UsingShadowDecl();
    NamedDecl* targetDecl;
    BaseUsingDecl* introducer;
    UsingShadowDecl* nextUsingShadowDecl;
};

class CS_API BaseUsingDecl : public NamedDecl
{
public:
    class CS_API shadow_iterator
    {
    public:
        shadow_iterator();
    };

    BaseUsingDecl();
    VECTOR(BaseUsingDecl::shadow_iterator*, shadows)
};

class CS_API UsingDecl : public BaseUsingDecl, public Mergeable<UsingDecl>
{
public:
    UsingDecl();
    SourceLocation usingLoc;
    NestedNameSpecifierLoc qualifierLoc;
    NestedNameSpecifier* qualifier;
    DeclarationNameInfo nameInfo;
    bool isAccessDeclaration;
    bool hasTypename;
};

class CS_API ConstructorUsingShadowDecl : public UsingShadowDecl
{
public:
    ConstructorUsingShadowDecl();
    UsingDecl* introducer;
    ConstructorUsingShadowDecl* nominatedBaseClassShadowDecl;
    ConstructorUsingShadowDecl* constructedBaseClassShadowDecl;
    CXXRecordDecl* nominatedBaseClass;
    CXXRecordDecl* constructedBaseClass;
    bool constructsVirtualBase;
};

class CS_API UsingEnumDecl : public BaseUsingDecl, public Mergeable<UsingEnumDecl>
{
public:
    UsingEnumDecl();
    SourceLocation usingLoc;
    SourceLocation enumLoc;
    NestedNameSpecifier* qualifier;
    NestedNameSpecifierLoc qualifierLoc;
    TypeSourceInfo* enumType;
    EnumDecl* enumDecl;
};

class CS_API UsingPackDecl : public NamedDecl, public Mergeable<UsingPackDecl>
{
public:
    UsingPackDecl();
    NamedDecl* instantiatedFromUsingDecl;
    ArrayRef<NamedDecl*> expansions;
};

class CS_API UnresolvedUsingValueDecl : public ValueDecl, public Mergeable<UnresolvedUsingValueDecl>
{
public:
    UnresolvedUsingValueDecl();
    SourceLocation usingLoc;
    bool isAccessDeclaration;
    NestedNameSpecifierLoc qualifierLoc;
    NestedNameSpecifier* qualifier;
    DeclarationNameInfo nameInfo;
    bool isPackExpansion;
    SourceLocation ellipsisLoc;
};

class CS_API UnresolvedUsingTypenameDecl : public TypeDecl, public Mergeable<UnresolvedUsingTypenameDecl>
{
public:
    UnresolvedUsingTypenameDecl();
    SourceLocation usingLoc;
    SourceLocation typenameLoc;
    NestedNameSpecifierLoc qualifierLoc;
    NestedNameSpecifier* qualifier;
    DeclarationNameInfo nameInfo;
    bool isPackExpansion;
    SourceLocation ellipsisLoc;
};

class CS_API UnresolvedUsingIfExistsDecl : public NamedDecl
{
public:
    UnresolvedUsingIfExistsDecl();
};

class CS_API StaticAssertDecl : public Decl
{
public:
    StaticAssertDecl();
    bool isFailed;
    SourceLocation rParenLoc;
};

class CS_API BindingDecl : public ValueDecl
{
public:
    BindingDecl();
    Expr* binding;
    ValueDecl* decomposedDecl;
    VarDecl* holdingVar;
};

class CS_API DecompositionDecl : public VarDecl
{
public:
    DecompositionDecl();
    ArrayRef<BindingDecl*> bindings;
};

class CS_API MSPropertyDecl : public DeclaratorDecl
{
public:
    MSPropertyDecl();
    bool hasGetter;
    IdentifierInfo* getterId;
    bool hasSetter;
    IdentifierInfo* setterId;
};

class CS_API MSGuidDecl : public ValueDecl, public Mergeable<MSGuidDecl>
{
public:
    MSGuidDecl();
    Parts parts;
    APValue& asAPValue;
};

class CS_API UnnamedGlobalConstantDecl : public ValueDecl, public Mergeable<UnnamedGlobalConstantDecl>
{
public:
    UnnamedGlobalConstantDecl();
    APValue& value;
};

class CS_API TemplateDecl : public NamedDecl
{
public:
    TemplateDecl();
    VECTOR(NamedDecl*, templateParameters)
    bool hasAssociatedConstraints;
    NamedDecl* templatedDecl;
    bool isTypeAlias;
};

class CS_API RedeclarableTemplateDecl : public TemplateDecl, public Redeclarable<RedeclarableTemplateDecl>
{
public:
    class CS_API SpecEntryTraits
    {
    public:
        SpecEntryTraits();
    };

    RedeclarableTemplateDecl();
    bool isMemberSpecialization;
    RedeclarableTemplateDecl* instantiatedFromMemberTemplate;
    ArrayRef<TemplateArgument> injectedTemplateArgs;
};

class CS_API FunctionTemplateDecl : public RedeclarableTemplateDecl
{
public:
    FunctionTemplateDecl();
    FunctionDecl* templatedDecl;
    bool isThisDeclarationADefinition;
    FunctionTemplateDecl* instantiatedFromMemberTemplate;
    bool isAbbreviated;
};

class CS_API TemplateTypeParmDecl : public TypeDecl
{
public:
    TemplateTypeParmDecl();
    DefArgStorage& defaultArgStorage;
    bool hasDefaultArgument;
    QualifiedType defaultArgument;
    TypeSourceInfo* defaultArgumentInfo;
    SourceLocation defaultArgumentLoc;
    bool defaultArgumentWasInherited;
    unsigned int depth;
    unsigned int index;
    bool isParameterPack;
    bool isPackExpansion;
    bool isExpandedParameterPack;
    unsigned int numExpansionParameters;
    TypeConstraint* typeConstraint;
    bool hasTypeConstraint;
};

class CS_API NonTypeTemplateParmDecl : public DeclaratorDecl, protected TemplateParmPosition
{
public:
    NonTypeTemplateParmDecl();
    DefArgStorage& defaultArgStorage;
    bool hasDefaultArgument;
    Expr* defaultArgument;
    SourceLocation defaultArgumentLoc;
    bool defaultArgumentWasInherited;
    bool isParameterPack;
    bool isPackExpansion;
    bool isExpandedParameterPack;
    unsigned int numExpansionTypes;
    Expr* placeholderTypeConstraint;
    bool hasPlaceholderTypeConstraint;
};

class CS_API TemplateTemplateParmDecl : public TemplateDecl, protected TemplateParmPosition
{
public:
    TemplateTemplateParmDecl();
    bool isParameterPack;
    bool isPackExpansion;
    bool isExpandedParameterPack;
    unsigned int numExpansionTemplateParameters;
    DefArgStorage& defaultArgStorage;
    bool hasDefaultArgument;
    TemplateArgumentLoc& defaultArgument;
    SourceLocation defaultArgumentLoc;
    bool defaultArgumentWasInherited;
};

class CS_API BuiltinTemplateDecl : public TemplateDecl
{
public:
    BuiltinTemplateDecl();
    BuiltinTemplateKind builtinTemplateKind;
};

class CS_API ClassTemplateSpecializationDecl : public CXXRecordDecl
{
public:
    ClassTemplateSpecializationDecl();
    ClassTemplateSpecializationDecl* mostRecentDecl;
    ClassTemplateDecl* specializedTemplate;
    VECTOR(TemplateArgument*, templateArgs)
    TemplateSpecializationKind specializationKind;
    bool isExplicitSpecialization;
    bool isClassScopeExplicitSpecialization;
    bool isExplicitInstantiationOrSpecialization;
    SourceLocation pointOfInstantiation;
    PointerUnion<> instantiatedFrom;
    PointerUnion<> specializedTemplateOrPartial;
    VECTOR(TemplateArgument*, templateInstantiationArgs)
    TypeSourceInfo* typeAsWritten;
    SourceLocation externLoc;
    SourceLocation templateKeywordLoc;
};

class CS_API ClassTemplatePartialSpecializationDecl : public ClassTemplateSpecializationDecl
{
public:
    ClassTemplatePartialSpecializationDecl();
    ClassTemplatePartialSpecializationDecl* mostRecentDecl;
    VECTOR(NamedDecl*, templateParameters)
    bool hasAssociatedConstraints;
    ASTTemplateArgumentListInfo* templateArgsAsWritten;
    ClassTemplatePartialSpecializationDecl* instantiatedFromMember;
    ClassTemplatePartialSpecializationDecl* instantiatedFromMemberTemplate;
    bool isMemberSpecialization;
    QualifiedType injectedSpecializationType;
};

class CS_API ClassTemplateDecl : public RedeclarableTemplateDecl
{
public:
    ClassTemplateDecl();
    CXXRecordDecl* templatedDecl;
    bool isThisDeclarationADefinition;
    ClassTemplateDecl* instantiatedFromMemberTemplate;
    QualifiedType injectedClassNameSpecialization;
};

class CS_API FriendTemplateDecl : public Decl
{
public:
    FriendTemplateDecl();
    TypeSourceInfo* friendType;
    NamedDecl* friendDecl;
    SourceLocation friendLoc;
    unsigned int numTemplateParameters;
};

class CS_API TypeAliasTemplateDecl : public RedeclarableTemplateDecl
{
public:
    TypeAliasTemplateDecl();
    TypeAliasDecl* templatedDecl;
    TypeAliasTemplateDecl* instantiatedFromMemberTemplate;
};

class CS_API ClassScopeFunctionSpecializationDecl : public Decl
{
public:
    ClassScopeFunctionSpecializationDecl();
    CXXMethodDecl* specialization;
    bool hasExplicitTemplateArgs;
    ASTTemplateArgumentListInfo* templateArgsAsWritten;
};

class CS_API VarTemplateSpecializationDecl : public VarDecl
{
public:
    VarTemplateSpecializationDecl();
    VarTemplateSpecializationDecl* mostRecentDecl;
    VarTemplateDecl* specializedTemplate;
    VECTOR(TemplateArgument*, templateArgs)
    ASTTemplateArgumentListInfo* templateArgsInfo;
    TemplateSpecializationKind specializationKind;
    bool isExplicitSpecialization;
    bool isClassScopeExplicitSpecialization;
    bool isExplicitInstantiationOrSpecialization;
    SourceLocation pointOfInstantiation;
    PointerUnion<> instantiatedFrom;
    PointerUnion<> specializedTemplateOrPartial;
    VECTOR(TemplateArgument*, templateInstantiationArgs)
    TypeSourceInfo* typeAsWritten;
    SourceLocation externLoc;
    SourceLocation templateKeywordLoc;
};

class CS_API VarTemplatePartialSpecializationDecl : public VarTemplateSpecializationDecl
{
public:
    VarTemplatePartialSpecializationDecl();
    VarTemplatePartialSpecializationDecl* mostRecentDecl;
    VECTOR(NamedDecl*, templateParameters)
    ASTTemplateArgumentListInfo* templateArgsAsWritten;
    bool hasAssociatedConstraints;
    VarTemplatePartialSpecializationDecl* instantiatedFromMember;
    bool isMemberSpecialization;
};

class CS_API VarTemplateDecl : public RedeclarableTemplateDecl
{
public:
    VarTemplateDecl();
    VarDecl* templatedDecl;
    bool isThisDeclarationADefinition;
    VarTemplateDecl* definition;
    VarTemplateDecl* instantiatedFromMemberTemplate;
};

class CS_API ConceptDecl : public TemplateDecl, public Mergeable<ConceptDecl>
{
public:
    ConceptDecl();
    Expr* constraintExpr;
    bool isTypeConcept;
};

class CS_API ImplicitConceptSpecializationDecl : public Decl
{
public:
    ImplicitConceptSpecializationDecl();
    ArrayRef<TemplateArgument> templateArguments;
};

class CS_API TemplateParamObjectDecl : public ValueDecl, public Mergeable<TemplateParamObjectDecl>
{
public:
    TemplateParamObjectDecl();
    APValue& value;
};

}
