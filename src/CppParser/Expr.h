// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------

#pragma once

#include "Stmt.h"
#include <optional>

namespace CppSharp::CppParser::AST {

class Field;
class Method;
class Function;
class FunctionTemplate;

/// <summary>CastKind - The kind of operation required for a conversion.</summary>
enum class CastKind
{
    Dependent = 0,
    BitCast = 1,
    LValueBitCast = 2,
    LValueToRValueBitCast = 3,
    LValueToRValue = 4,
    NoOp = 5,
    BaseToDerived = 6,
    DerivedToBase = 7,
    UncheckedDerivedToBase = 8,
    Dynamic = 9,
    ToUnion = 10,
    ArrayToPointerDecay = 11,
    FunctionToPointerDecay = 12,
    NullToPointer = 13,
    NullToMemberPointer = 14,
    BaseToDerivedMemberPointer = 15,
    DerivedToBaseMemberPointer = 16,
    MemberPointerToBoolean = 17,
    ReinterpretMemberPointer = 18,
    UserDefinedConversion = 19,
    ConstructorConversion = 20,
    IntegralToPointer = 21,
    PointerToIntegral = 22,
    PointerToBoolean = 23,
    ToVoid = 24,
    MatrixCast = 25,
    VectorSplat = 26,
    IntegralCast = 27,
    IntegralToBoolean = 28,
    IntegralToFloating = 29,
    FloatingToFixedPoint = 30,
    FixedPointToFloating = 31,
    FixedPointCast = 32,
    FixedPointToIntegral = 33,
    IntegralToFixedPoint = 34,
    FixedPointToBoolean = 35,
    FloatingToIntegral = 36,
    FloatingToBoolean = 37,
    BooleanToSignedIntegral = 38,
    FloatingCast = 39,
    CPointerToObjCPointerCast = 40,
    BlockPointerToObjCPointerCast = 41,
    AnyPointerToBlockPointerCast = 42,
    ObjCObjectLValueCast = 43,
    FloatingRealToComplex = 44,
    FloatingComplexToReal = 45,
    FloatingComplexToBoolean = 46,
    FloatingComplexCast = 47,
    FloatingComplexToIntegralComplex = 48,
    IntegralRealToComplex = 49,
    IntegralComplexToReal = 50,
    IntegralComplexToBoolean = 51,
    IntegralComplexCast = 52,
    IntegralComplexToFloatingComplex = 53,
    ARCProduceObject = 54,
    ARCConsumeObject = 55,
    ARCReclaimReturnedObject = 56,
    ARCExtendBlockObject = 57,
    AtomicToNonAtomic = 58,
    NonAtomicToAtomic = 59,
    CopyAndAutoreleaseBlockObject = 60,
    BuiltinFnToFnPtr = 61,
    ZeroToOCLOpaqueType = 62,
    AddressSpaceConversion = 63,
    IntToOCLSampler = 64
};

enum class UnaryOperatorKind
{
    PostInc = 0,
    PostDec = 1,
    PreInc = 2,
    PreDec = 3,
    AddrOf = 4,
    Deref = 5,
    Plus = 6,
    Minus = 7,
    Not = 8,
    LNot = 9,
    Real = 10,
    Imag = 11,
    Extension = 12,
    Coawait = 13
};

enum class BinaryOperatorKind
{
    PtrMemD = 0,
    PtrMemI = 1,
    Mul = 2,
    Div = 3,
    Rem = 4,
    Add = 5,
    Sub = 6,
    Shl = 7,
    Shr = 8,
    Cmp = 9,
    LT = 10,
    GT = 11,
    LE = 12,
    GE = 13,
    EQ = 14,
    NE = 15,
    And = 16,
    Xor = 17,
    Or = 18,
    LAnd = 19,
    LOr = 20,
    Assign = 21,
    MulAssign = 22,
    DivAssign = 23,
    RemAssign = 24,
    AddAssign = 25,
    SubAssign = 26,
    ShlAssign = 27,
    ShrAssign = 28,
    AndAssign = 29,
    XorAssign = 30,
    OrAssign = 31,
    Comma = 32
};

/// <summary>The kind of bridging performed by the Objective-C bridge cast.</summary>
enum class ObjCBridgeCastKind
{
    /// <summary>
    /// <para>Bridging via __bridge, which does nothing but reinterpret</para>
    /// <para>the bits.</para>
    /// </summary>
    Bridge = 0,
    /// <summary>
    /// <para>Bridging via __bridge_transfer, which transfers ownership of an</para>
    /// <para>Objective-C pointer into ARC.</para>
    /// </summary>
    BridgeTransfer = 1,
    /// <summary>
    /// <para>Bridging via __bridge_retain, which makes an ARC object available</para>
    /// <para>as a +1 C pointer.</para>
    /// </summary>
    BridgeRetained = 2
};

/// <summary>
/// <para>Enumeration specifying the different kinds of C++ overloaded</para>
/// <para>operators.</para>
/// </summary>
enum class OverloadedOperatorKind
{
    /// <summary>Not an overloaded operator</summary>
    None = 0,
    New = 1,
    Delete = 2,
    ArrayNew = 3,
    ArrayDelete = 4,
    Plus = 5,
    Minus = 6,
    Star = 7,
    Slash = 8,
    Percent = 9,
    Caret = 10,
    Amp = 11,
    Pipe = 12,
    Tilde = 13,
    Exclaim = 14,
    Equal = 15,
    Less = 16,
    Greater = 17,
    PlusEqual = 18,
    MinusEqual = 19,
    StarEqual = 20,
    SlashEqual = 21,
    PercentEqual = 22,
    CaretEqual = 23,
    AmpEqual = 24,
    PipeEqual = 25,
    LessLess = 26,
    GreaterGreater = 27,
    LessLessEqual = 28,
    GreaterGreaterEqual = 29,
    EqualEqual = 30,
    ExclaimEqual = 31,
    LessEqual = 32,
    GreaterEqual = 33,
    Spaceship = 34,
    AmpAmp = 35,
    PipePipe = 36,
    PlusPlus = 37,
    MinusMinus = 38,
    Comma = 39,
    ArrowStar = 40,
    Arrow = 41,
    Call = 42,
    Subscript = 43,
    Conditional = 44,
    Coawait = 45,
};

/// <summary>Names for the &quot;expression or type&quot; traits.</summary>
enum class UnaryExprOrTypeTrait
{
    SizeOf = 0,
    AlignOf = 1,
    PreferredAlignOf = 2,
    VecStep = 3,
    OpenMPRequiredSimdAlign = 4,
    Last = 4
};

/// <summary>The reason why a DeclRefExpr does not constitute an odr-use.</summary>
enum class NonOdrUseReason
{
    /// <summary>This is an odr-use.</summary>
    None = 0,
    /// <summary>This name appears in an unevaluated operand.</summary>
    Unevaluated = 1,
    /// <summary>
    /// <para>This name appears as a potential result of an lvalue-to-rvalue</para>
    /// <para>conversion that is a constant expression.</para>
    /// </summary>
    Constant = 2,
    /// <summary>
    /// <para>This name appears as a potential result of a discarded value</para>
    /// <para>expression.</para>
    /// </summary>
    Discarded = 3
};

enum class ExprDependence : unsigned char
{
    UnexpandedPack = 1,
    Instantiation = 2,
    Type = 4,
    Value = 8,
    Error = 16,
    None = 0,
    All = 31,
    TypeValue = 12,
    TypeInstantiation = 6,
    ValueInstantiation = 10,
    TypeValueInstantiation = 14,
    ErrorDependent = 26,
    LLVM_BITMASK_LARGEST_ENUMERATOR = 16
};

/// <summary>@{</summary>
enum class FloatSemantics
{
    IEEEhalf = 0,
    BFloat = 1,
    IEEEsingle = 2,
    IEEEdouble = 3,
    IEEEquad = 4,
    PPCDoubleDouble = 5,
    Float8E5M2 = 6,
    Float8E5M2FNUZ = 7,
    Float8E4M3FN = 8,
    Float8E4M3FNUZ = 9,
    Float8E4M3B11FNUZ = 10,
    FloatTF32 = 11,
    X87DoubleExtended = 12,
    MaxSemantics = 12
};

class CS_API Expr : public ValueStmt
{
public:
    enum class LValueClassification
    {
        Valid = 0,
        NotObjectType = 1,
        IncompleteVoidType = 2,
        DuplicateVectorComponents = 3,
        InvalidExpression = 4,
        InvalidMessageExpression = 5,
        MemberFunction = 6,
        SubObjCPropertySetting = 7,
        ClassTemporary = 8,
        ArrayTemporary = 9
    };

    enum class isModifiableLvalueResult
    {
        Valid = 0,
        NotObjectType = 1,
        IncompleteVoidType = 2,
        DuplicateVectorComponents = 3,
        InvalidExpression = 4,
        LValueCast = 5,
        IncompleteType = 6,
        ConstQualified = 7,
        ConstQualifiedField = 8,
        ConstAddrSpace = 9,
        ArrayType = 10,
        NoSetterProperty = 11,
        MemberFunction = 12,
        SubObjCPropertySetting = 13,
        InvalidMessageExpression = 14,
        ClassTemporary = 15,
        ArrayTemporary = 16
    };

    enum class SideEffectsKind
    {
        /// <summary>Strictly evaluate the expression.</summary>
        NoSideEffects = 0,
        /// <summary>
        /// <para>Allow UB that we can give a value, but not</para>
        /// <para>arbitrary unmodeled side effects.</para>
        /// </summary>
        AllowUndefinedBehavior = 1,
        /// <summary>Allow any unmodeled side effect.</summary>
        AllowSideEffects = 2
    };

    enum class ConstantExprKind
    {
        /// <summary>
        /// <para>An integer constant expression (an array bound, enumerator, case value,</para>
        /// <para>bit-field width, or similar) or similar.</para>
        /// </summary>
        Normal = 0,
        /// <summary>
        /// <para>A non-class template argument. Such a value is only used for mangling,</para>
        /// <para>not for code generation, so can refer to dllimported functions.</para>
        /// </summary>
        NonClassTemplateArgument = 1,
        /// <summary>A class template argument. Such a value is used for code generation.</summary>
        ClassTemplateArgument = 2,
        /// <summary>
        /// <para>An immediate invocation. The destruction of the end result of this</para>
        /// <para>evaluation is not part of the evaluation, but all other temporaries</para>
        /// <para>are destroyed.</para>
        /// </summary>
        ImmediateInvocation = 3
    };

    /// <summary>
    /// <para>Enumeration used to describe the kind of Null pointer constant</para>
    /// <para>returned from</para>
    /// </summary>
    enum class NullPointerConstantKind
    {
        /// <summary>Expression is not a Null pointer constant.</summary>
        NotNull = 0,
        /// <summary>
        /// <para>Expression is a Null pointer constant built from a zero integer</para>
        /// <para>expression that is not a simple, possibly parenthesized, zero literal.</para>
        /// <para>C++ Core Issue 903 will classify these expressions as &quot;not pointers&quot;</para>
        /// <para>once it is adopted.</para>
        /// <para>http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#903</para>
        /// </summary>
        ZeroExpression = 1,
        /// <summary>Expression is a Null pointer constant built from a literal zero.</summary>
        ZeroLiteral = 2,
        /// <summary>Expression is a C++11 nullptr.</summary>
        CXX11_nullptr = 3,
        /// <summary>Expression is a GNU-style __null constant.</summary>
        GNUNull = 4
    };

    /// <summary>Enumeration used to describe howshould cope with value-dependent expressions.</summary>
    enum class NullPointerConstantValueDependence
    {
        /// <summary>Specifies that the expression should never be value-dependent.</summary>
        NeverValueDependent = 0,
        /// <summary>
        /// <para>Specifies that a value-dependent expression of integral or</para>
        /// <para>dependent type should be considered a null pointer constant.</para>
        /// </summary>
        ValueDependentIsNull = 1,
        /// <summary>
        /// <para>Specifies that a value-dependent expression should be considered</para>
        /// <para>to never be a null pointer constant.</para>
        /// </summary>
        ValueDependentIsNotNull = 2
    };

    class CS_API Classification
    {
    public:
        /// <summary>The various classification results. Most of these mean prvalue.</summary>
        enum class Kinds
        {
            LValue = 0,
            XValue = 1,
            Function = 2,
            Void = 3,
            AddressableVoid = 4,
            DuplicateVectorComponents = 5,
            MemberFunction = 6,
            SubObjCPropertySetting = 7,
            ClassTemporary = 8,
            ArrayTemporary = 9,
            ObjCMessageRValue = 10,
            PRValue = 11
        };

        /// <summary>The results of modification testing.</summary>
        enum class ModifiableType
        {
            Untested = 0,
            Modifiable = 1,
            RValue = 2,
            Function = 3,
            LValueCast = 4,
            NoSetterProperty = 5,
            ConstQualified = 6,
            ConstQualifiedField = 7,
            ConstAddrSpace = 8,
            ArrayType = 9,
            IncompleteType = 10
        };

        Classification();
        Kinds kind;
        ModifiableType modifiable;
        bool isLValue;
        bool isXValue;
        bool isGLValue;
        bool isPRValue;
        bool isRValue;
        bool isModifiable;
    };

    Expr();
    Expr(StmtClass klass);
    ExprDependence dependence;
    QualifiedType type;
    bool isValueDependent;
    bool isTypeDependent;
    bool isInstantiationDependent;
    bool containsUnexpandedParameterPack;
    bool containsErrors;
    SourceLocation exprLoc;
    bool isReadIfDiscardedInCPlusPlus11;
    bool isLValue;
    bool isPRValue;
    bool isXValue;
    bool isGLValue;
    bool isOrdinaryOrBitFieldObject;
    bool refersToMatrixElement;
    bool hasPlaceholderType;
};

class CS_API FullExpr : public Expr
{
public:
    FullExpr();
    FullExpr(StmtClass klass);
    Expr* subExpr;
};

class CS_API ConstantExpr : public FullExpr
{
public:
    /// <summary>Describes the kind of result that can be tail-allocated.</summary>
    enum class ResultStorageKind
    {
        None = 0,
        Int64 = 1,
        APValue = 2
    };

    ConstantExpr();
    ResultStorageKind resultStorageKind;
    bool isImmediateInvocation;
    bool hasAPValueResult;
};

class CS_API OpaqueValueExpr : public Expr
{
public:
    OpaqueValueExpr();
    SourceLocation location;
    SourceLocation exprLoc;
    Expr* sourceExpr;
    bool isUnique;
};

class CS_API DeclRefExpr : public Expr
{
public:
    DeclRefExpr();
    SourceLocation location;
    bool hasQualifier;
    bool hasTemplateKWAndArgsInfo;
    SourceLocation templateKeywordLoc;
    SourceLocation lAngleLoc;
    SourceLocation rAngleLoc;
    bool hasTemplateKeyword;
    bool hasExplicitTemplateArgs;
    unsigned int numTemplateArgs;
    bool hadMultipleCandidates;
    NonOdrUseReason isNonOdrUse;
    bool refersToEnclosingVariableOrCapture;
    bool isImmediateEscalating;
};

class CS_API IntegerLiteral : public Expr
{
public:
    IntegerLiteral();
    SourceLocation location;
    unsigned long long value;
};

class CS_API FixedPointLiteral : public Expr
{
public:
    FixedPointLiteral();
    SourceLocation location;
    unsigned int scale;
    unsigned long long value;
};

class CS_API CharacterLiteral : public Expr
{
public:
    enum class CharacterKind
    {
        Ascii = 0,
        Wide = 1,
        UTF8 = 2,
        UTF16 = 3,
        UTF32 = 4
    };

    CharacterLiteral();
    SourceLocation location;
    CharacterKind kind;
    unsigned int value;
};

class CS_API FloatingLiteral : public Expr
{
public:
    FloatingLiteral();
    FloatSemantics rawSemantics;
    bool exact;
    double valueAsApproximateDouble;
    SourceLocation location;
};

class CS_API ImaginaryLiteral : public Expr
{
public:
    ImaginaryLiteral();
    Expr* subExpr;
};

class CS_API StringLiteral : public Expr
{
public:
    /// <summary>StringLiteral is followed by several trailing objects. They are in order:</summary>
    /// <remarks>
    /// <para>* A single unsigned storing the length in characters of this string. The</para>
    /// <para>length in bytes is this length times the width of a single character.</para>
    /// <para>Always present and stored as a trailing objects because storing it in</para>
    /// <para>StringLiteral would increase the size of StringLiteral by sizeof(void *)</para>
    /// <para>due to alignment requirements. If you add some data to StringLiteral,</para>
    /// <para>consider moving it inside StringLiteral.</para>
    /// <para>* An array of getNumConcatenated() SourceLocation, one for each of the</para>
    /// <para>token this string is made of.</para>
    /// <para>* An array of getByteLength() char used to store the string data.</para>
    /// </remarks>
    enum class StringKind
    {
        Ordinary = 0,
        Wide = 1,
        UTF8 = 2,
        UTF16 = 3,
        UTF32 = 4,
        Unevaluated = 5
    };

    StringLiteral();
    std::string string;
    std::string bytes;
    unsigned int byteLength;
    unsigned int length;
    unsigned int charByteWidth;
    StringKind kind;
    bool isOrdinary;
    bool isWide;
    bool isUTF8;
    bool isUTF16;
    bool isUTF32;
    bool isUnevaluated;
    bool isPascal;
    bool containsNonAscii;
    bool containsNonAsciiOrNull;
    unsigned int numConcatenated;
};

class CS_API PredefinedExpr : public Expr
{
public:
    enum class IdentKind
    {
        Func = 0,
        Function = 1,
        LFunction = 2,
        FuncDName = 3,
        FuncSig = 4,
        LFuncSig = 5,
        PrettyFunction = 6,
        /// <summary>
        /// <para>The same as PrettyFunction, except that the</para>
        /// <para>'virtual' keyword is omitted for virtual member functions.</para>
        /// </summary>
        PrettyFunctionNoVirtual = 7
    };

    PredefinedExpr();
    IdentKind identKind;
    bool isTransparent;
    SourceLocation location;
    std::string identKindName;
};

class CS_API SYCLUniqueStableNameExpr : public Expr
{
public:
    SYCLUniqueStableNameExpr();
    SourceLocation location;
    SourceLocation lParenLocation;
    SourceLocation rParenLocation;
};

class CS_API ParenExpr : public Expr
{
public:
    ParenExpr();
    Expr* subExpr;
    SourceLocation lParen;
    SourceLocation rParen;
};

class CS_API UnaryOperator : public Expr
{
public:
    UnaryOperator();
    UnaryOperatorKind opcode;
    Expr* subExpr;
    SourceLocation operatorLoc;
    bool canOverflow;
    bool isPrefix;
    bool isPostfix;
    bool isIncrementOp;
    bool isDecrementOp;
    bool isIncrementDecrementOp;
    bool isArithmeticOp;
    SourceLocation exprLoc;
    bool hasStoredFPFeatures;
};

class CS_API OffsetOfExpr : public Expr
{
public:
    OffsetOfExpr();
    SourceLocation operatorLoc;
    SourceLocation rParenLoc;
    unsigned int numComponents;
    unsigned int numExpressions;
};

class CS_API UnaryExprOrTypeTraitExpr : public Expr
{
public:
    UnaryExprOrTypeTraitExpr();
    UnaryExprOrTypeTrait kind;
    bool isArgumentType;
    QualifiedType argumentType;
    QualifiedType typeOfArgument;
    SourceLocation operatorLoc;
    SourceLocation rParenLoc;
};

class CS_API ArraySubscriptExpr : public Expr
{
public:
    ArraySubscriptExpr();
    Expr* lHS;
    Expr* rHS;
    SourceLocation rBracketLoc;
    SourceLocation exprLoc;
};

class CS_API MatrixSubscriptExpr : public Expr
{
public:
    MatrixSubscriptExpr();
    bool isIncomplete;
    Expr* base;
    Expr* rowIdx;
    Expr* columnIdx;
    SourceLocation exprLoc;
    SourceLocation rBracketLoc;
};

class CS_API CallExpr : public Expr
{
public:
    enum class ADLCallKind : unsigned char
    {
        NotADL = 0,
        UsesADL = 1
    };

    CallExpr();
    CallExpr(StmtClass klass);
    VECTOR(Expr*, arguments)
    Expr* callee;
    ADLCallKind aDLCallKind;
    bool usesADL;
    bool hasStoredFPFeatures;
    unsigned int numArgs;
    unsigned int builtinCallee;
    SourceLocation rParenLoc;
    bool isCallToStdMove;
};

class CS_API MemberExpr : public Expr
{
public:
    MemberExpr();
    Expr* base;
    bool hasQualifier;
    SourceLocation templateKeywordLoc;
    SourceLocation lAngleLoc;
    SourceLocation rAngleLoc;
    bool hasTemplateKeyword;
    bool hasExplicitTemplateArgs;
    unsigned int numTemplateArgs;
    SourceLocation operatorLoc;
    bool arrow;
    SourceLocation memberLoc;
    SourceLocation exprLoc;
    bool isImplicitAccess;
    bool hadMultipleCandidates;
    NonOdrUseReason isNonOdrUse;
};

class CS_API CompoundLiteralExpr : public Expr
{
public:
    CompoundLiteralExpr();
    Expr* initializer;
    bool fileScope;
    SourceLocation lParenLoc;
};

class CS_API CastExpr : public Expr
{
public:
    CastExpr();
    CastExpr(StmtClass klass);
    CastKind castKind;
    const char* castKindName;
    Expr* subExpr;
    Declaration* conversionFunction;
    bool path_empty;
    unsigned int path_size;
    bool hasStoredFPFeatures;
};

class CS_API ImplicitCastExpr : public CastExpr
{
public:
    enum class OnStack_t
    {
        OnStack = 0
    };

    ImplicitCastExpr();
    bool isPartOfExplicitCast;
};

class CS_API ExplicitCastExpr : public CastExpr
{
public:
    ExplicitCastExpr();
    ExplicitCastExpr(StmtClass klass);
    QualifiedType typeAsWritten;
};

class CS_API CStyleCastExpr : public ExplicitCastExpr
{
public:
    CStyleCastExpr();
    SourceLocation lParenLoc;
    SourceLocation rParenLoc;
};

class CS_API BinaryOperator : public Expr
{
public:
    BinaryOperator();
    BinaryOperator(StmtClass klass);
    SourceLocation exprLoc;
    SourceLocation operatorLoc;
    BinaryOperatorKind opcode;
    Expr* lHS;
    Expr* rHS;
    std::string opcodeStr;
    bool isPtrMemOp;
    bool isMultiplicativeOp;
    bool isAdditiveOp;
    bool isShiftOp;
    bool isBitwiseOp;
    bool isRelationalOp;
    bool isEqualityOp;
    bool isComparisonOp;
    bool isCommaOp;
    bool isLogicalOp;
    bool isAssignmentOp;
    bool isCompoundAssignmentOp;
    bool isShiftAssignOp;
    bool hasStoredFPFeatures;
};

class CS_API CompoundAssignOperator : public BinaryOperator
{
public:
    CompoundAssignOperator();
    QualifiedType computationLHSType;
    QualifiedType computationResultType;
};

class CS_API AbstractConditionalOperator : public Expr
{
public:
    AbstractConditionalOperator();
    AbstractConditionalOperator(StmtClass klass);
    Expr* cond;
    Expr* trueExpr;
    Expr* falseExpr;
    SourceLocation questionLoc;
    SourceLocation colonLoc;
};

class CS_API ConditionalOperator : public AbstractConditionalOperator
{
public:
    ConditionalOperator();
    Expr* cond;
    Expr* trueExpr;
    Expr* falseExpr;
    Expr* lHS;
    Expr* rHS;
};

class CS_API BinaryConditionalOperator : public AbstractConditionalOperator
{
public:
    BinaryConditionalOperator();
    Expr* common;
    OpaqueValueExpr* opaqueValue;
    Expr* cond;
    Expr* trueExpr;
    Expr* falseExpr;
};

class CS_API AddrLabelExpr : public Expr
{
public:
    AddrLabelExpr();
    SourceLocation ampAmpLoc;
    SourceLocation labelLoc;
};

class CS_API StmtExpr : public Expr
{
public:
    StmtExpr();
    CompoundStmt* subStmt;
    SourceLocation lParenLoc;
    SourceLocation rParenLoc;
    unsigned int templateDepth;
};

class CS_API ShuffleVectorExpr : public Expr
{
public:
    ShuffleVectorExpr();
    SourceLocation builtinLoc;
    SourceLocation rParenLoc;
    unsigned int numSubExprs;
};

class CS_API ConvertVectorExpr : public Expr
{
public:
    ConvertVectorExpr();
    Expr* srcExpr;
    SourceLocation builtinLoc;
    SourceLocation rParenLoc;
};

class CS_API ChooseExpr : public Expr
{
public:
    ChooseExpr();
    bool isConditionTrue;
    bool isConditionDependent;
    Expr* chosenSubExpr;
    Expr* cond;
    Expr* lHS;
    Expr* rHS;
    SourceLocation builtinLoc;
    SourceLocation rParenLoc;
};

class CS_API GNUNullExpr : public Expr
{
public:
    GNUNullExpr();
    SourceLocation tokenLocation;
};

class CS_API VAArgExpr : public Expr
{
public:
    VAArgExpr();
    Expr* subExpr;
    bool isMicrosoftABI;
    SourceLocation builtinLoc;
    SourceLocation rParenLoc;
};

class CS_API SourceLocExpr : public Expr
{
public:
    enum class IdentKind
    {
        Function = 0,
        FuncSig = 1,
        File = 2,
        FileName = 3,
        Line = 4,
        Column = 5,
        SourceLocStruct = 6
    };

    SourceLocExpr();
    std::string builtinStr;
    IdentKind identKind;
    bool isIntType;
    SourceLocation location;
};

class CS_API InitListExpr : public Expr
{
public:
    InitListExpr();
    unsigned int numInits;
    Expr* arrayFiller;
    bool hasArrayFiller;
    bool hasDesignatedInit;
    bool isExplicit;
    bool isStringLiteralInit;
    bool isTransparent;
    SourceLocation lBraceLoc;
    SourceLocation rBraceLoc;
    bool isSemanticForm;
    InitListExpr* semanticForm;
    bool isSyntacticForm;
    InitListExpr* syntacticForm;
};

class CS_API DesignatedInitExpr : public Expr
{
public:
    class CS_API Designator
    {
    public:
        /// <summary>The kind of designator this describes.</summary>
        enum class DesignatorKind
        {
            FieldDesignator = 0,
            ArrayDesignator = 1,
            ArrayRangeDesignator = 2
        };

        class CS_API FieldDesignatorInfo
        {
        public:
            FieldDesignatorInfo();
        };

        class CS_API ArrayOrRangeDesignatorInfo
        {
        public:
            ArrayOrRangeDesignatorInfo();
        };

        Designator();
        bool isFieldDesignator;
        bool isArrayDesignator;
        bool isArrayRangeDesignator;
        Field* fieldDecl;
        SourceLocation dotLoc;
        SourceLocation fieldLoc;
        unsigned int arrayIndex;
        SourceLocation lBracketLoc;
        SourceLocation ellipsisLoc;
        SourceLocation rBracketLoc;
        SourceRange sourceRange;
    };

    DesignatedInitExpr();
    unsigned int size;
    SourceLocation equalOrColonLoc;
    bool isDirectInit;
    bool usesGNUSyntax;
    Expr* init;
    unsigned int numSubExprs;
    SourceRange designatorsSourceRange;
};

class CS_API NoInitExpr : public Expr
{
public:
    NoInitExpr();
};

class CS_API DesignatedInitUpdateExpr : public Expr
{
public:
    DesignatedInitUpdateExpr();
    Expr* base;
    InitListExpr* updater;
};

class CS_API ArrayInitLoopExpr : public Expr
{
public:
    ArrayInitLoopExpr();
    OpaqueValueExpr* commonExpr;
    Expr* subExpr;
};

class CS_API ArrayInitIndexExpr : public Expr
{
public:
    ArrayInitIndexExpr();
};

class CS_API ImplicitValueInitExpr : public Expr
{
public:
    ImplicitValueInitExpr();
};

class CS_API ParenListExpr : public Expr
{
public:
    ParenListExpr();
    unsigned int numExprs;
    SourceLocation lParenLoc;
    SourceLocation rParenLoc;
};

class CS_API GenericSelectionExpr : public Expr
{
public:
    GenericSelectionExpr();
    unsigned int numAssocs;
    unsigned int resultIndex;
    bool isResultDependent;
    bool isExprPredicate;
    bool isTypePredicate;
    SourceLocation genericLoc;
    SourceLocation defaultLoc;
    SourceLocation rParenLoc;
};

class CS_API ExtVectorElementExpr : public Expr
{
public:
    ExtVectorElementExpr();
    Expr* base;
    SourceLocation accessorLoc;
    unsigned int numElements;
    bool containsDuplicateElements;
    bool isArrow;
};

class CS_API BlockExpr : public Expr
{
public:
    BlockExpr();
    SourceLocation caretLocation;
};

class CS_API AsTypeExpr : public Expr
{
public:
    AsTypeExpr();
    Expr* srcExpr;
    SourceLocation builtinLoc;
    SourceLocation rParenLoc;
};

class CS_API PseudoObjectExpr : public Expr
{
public:
    PseudoObjectExpr();
    unsigned int resultExprIndex;
    unsigned int numSemanticExprs;
    SourceLocation exprLoc;
};

class CS_API AtomicExpr : public Expr
{
public:
    enum class AtomicOp
    {
        C11AtomicInit = 0,
        C11AtomicLoad = 1,
        C11AtomicStore = 2,
        C11AtomicExchange = 3,
        C11AtomicCompareExchangeStrong = 4,
        C11AtomicCompareExchangeWeak = 5,
        C11AtomicFetchAdd = 6,
        C11AtomicFetchSub = 7,
        C11AtomicFetchAnd = 8,
        C11AtomicFetchOr = 9,
        C11AtomicFetchXor = 10,
        C11AtomicFetchNand = 11,
        C11AtomicFetchMax = 12,
        C11AtomicFetchMin = 13,
        AtomicLoad = 14,
        AtomicLoadN = 15,
        AtomicStore = 16,
        AtomicStoreN = 17,
        AtomicExchange = 18,
        AtomicExchangeN = 19,
        AtomicCompareExchange = 20,
        AtomicCompareExchangeN = 21,
        AtomicFetchAdd = 22,
        AtomicFetchSub = 23,
        AtomicFetchAnd = 24,
        AtomicFetchOr = 25,
        AtomicFetchXor = 26,
        AtomicFetchNand = 27,
        AtomicAddFetch = 28,
        AtomicSubFetch = 29,
        AtomicAndFetch = 30,
        AtomicOrFetch = 31,
        AtomicXorFetch = 32,
        AtomicMaxFetch = 33,
        AtomicMinFetch = 34,
        AtomicNandFetch = 35,
        OpenclAtomicInit = 36,
        OpenclAtomicLoad = 37,
        OpenclAtomicStore = 38,
        OpenclAtomicExchange = 39,
        OpenclAtomicCompareExchangeStrong = 40,
        OpenclAtomicCompareExchangeWeak = 41,
        OpenclAtomicFetchAdd = 42,
        OpenclAtomicFetchSub = 43,
        OpenclAtomicFetchAnd = 44,
        OpenclAtomicFetchOr = 45,
        OpenclAtomicFetchXor = 46,
        OpenclAtomicFetchMin = 47,
        OpenclAtomicFetchMax = 48,
        AtomicFetchMin = 49,
        AtomicFetchMax = 50,
        HipAtomicLoad = 51,
        HipAtomicStore = 52,
        HipAtomicCompareExchangeWeak = 53,
        HipAtomicCompareExchangeStrong = 54,
        HipAtomicExchange = 55,
        HipAtomicFetchAdd = 56,
        HipAtomicFetchSub = 57,
        HipAtomicFetchAnd = 58,
        HipAtomicFetchOr = 59,
        HipAtomicFetchXor = 60,
        HipAtomicFetchMin = 61,
        HipAtomicFetchMax = 62,
    };

    AtomicExpr();
    Expr* ptr;
    Expr* order;
    Expr* scope;
    Expr* val1;
    Expr* orderFail;
    Expr* val2;
    Expr* weak;
    QualifiedType valueType;
    AtomicOp op;
    unsigned int numSubExprs;
    bool isVolatile;
    bool isCmpXChg;
    bool isOpenCL;
    SourceLocation builtinLoc;
    SourceLocation rParenLoc;
};

class CS_API TypoExpr : public Expr
{
public:
    TypoExpr();
};

class CS_API RecoveryExpr : public Expr
{
public:
    RecoveryExpr();
};

class CS_API CXXOperatorCallExpr : public CallExpr
{
public:
    CXXOperatorCallExpr();
    OverloadedOperatorKind _operator;
    bool isAssignmentOp;
    bool isComparisonOp;
    bool isInfixBinaryOp;
    SourceLocation operatorLoc;
    SourceLocation exprLoc;
    SourceRange sourceRange;
};

class CS_API CXXMemberCallExpr : public CallExpr
{
public:
    CXXMemberCallExpr();
    Expr* implicitObjectArgument;
    QualifiedType objectType;
    Method* methodDecl;
    SourceLocation exprLoc;
};

class CS_API CUDAKernelCallExpr : public CallExpr
{
public:
    CUDAKernelCallExpr();
};

class CS_API CXXRewrittenBinaryOperator : public Expr
{
public:
    CXXRewrittenBinaryOperator();
    bool isReversed;
    BinaryOperatorKind _operator;
    BinaryOperatorKind opcode;
    std::string opcodeStr;
    bool isComparisonOp;
    bool isAssignmentOp;
    Expr* lHS;
    Expr* rHS;
    SourceLocation operatorLoc;
    SourceLocation exprLoc;
    SourceRange sourceRange;
};

class CS_API CXXNamedCastExpr : public ExplicitCastExpr
{
public:
    CXXNamedCastExpr();
    CXXNamedCastExpr(StmtClass klass);
    const char* castName;
    SourceLocation operatorLoc;
    SourceLocation rParenLoc;
    SourceRange angleBrackets;
};

class CS_API CXXStaticCastExpr : public CXXNamedCastExpr
{
public:
    CXXStaticCastExpr();
};

class CS_API CXXDynamicCastExpr : public CXXNamedCastExpr
{
public:
    CXXDynamicCastExpr();
    bool isAlwaysNull;
};

class CS_API CXXReinterpretCastExpr : public CXXNamedCastExpr
{
public:
    CXXReinterpretCastExpr();
};

class CS_API CXXConstCastExpr : public CXXNamedCastExpr
{
public:
    CXXConstCastExpr();
};

class CS_API CXXAddrspaceCastExpr : public CXXNamedCastExpr
{
public:
    CXXAddrspaceCastExpr();
};

class CS_API UserDefinedLiteral : public CallExpr
{
public:
    /// <summary>The kind of literal operator which is invoked.</summary>
    enum class LiteralOperatorKind
    {
        /// <summary>Raw form: operator &quot;&quot; X (const char *)</summary>
        Raw = 0,
        /// <summary>Raw form: operator &quot;&quot; X...&gt; ()</summary>
        Template = 1,
        /// <summary>operator &quot;&quot; X (unsigned long long)</summary>
        Integer = 2,
        /// <summary>operator &quot;&quot; X (long double)</summary>
        Floating = 3,
        /// <summary>operator &quot;&quot; X (const CharT *, size_t)</summary>
        String = 4,
        /// <summary>operator &quot;&quot; X (CharT)</summary>
        Character = 5
    };

    UserDefinedLiteral();
    LiteralOperatorKind literalOperatorKind;
    SourceLocation uDSuffixLoc;
};

class CS_API CXXBoolLiteralExpr : public Expr
{
public:
    CXXBoolLiteralExpr();
    bool value;
    SourceLocation location;
};

class CS_API CXXNullPtrLiteralExpr : public Expr
{
public:
    CXXNullPtrLiteralExpr();
    SourceLocation location;
};

class CS_API CXXStdInitializerListExpr : public Expr
{
public:
    CXXStdInitializerListExpr();
    SourceRange sourceRange;
};

class CS_API CXXTypeidExpr : public Expr
{
public:
    CXXTypeidExpr();
    bool isPotentiallyEvaluated;
    bool isTypeOperand;
    Expr* exprOperand;
    SourceRange sourceRange;
};

class CS_API MSPropertyRefExpr : public Expr
{
public:
    MSPropertyRefExpr();
    SourceRange sourceRange;
    bool isImplicitAccess;
    Expr* baseExpr;
    bool isArrow;
    SourceLocation memberLoc;
};

class CS_API MSPropertySubscriptExpr : public Expr
{
public:
    MSPropertySubscriptExpr();
    SourceLocation rBracketLoc;
    SourceLocation exprLoc;
};

class CS_API CXXUuidofExpr : public Expr
{
public:
    CXXUuidofExpr();
    bool isTypeOperand;
    Expr* exprOperand;
    std::string guidDecl;
    SourceRange sourceRange;
};

class CS_API CXXThisExpr : public Expr
{
public:
    CXXThisExpr();
    SourceLocation location;
    bool implicit;
};

class CS_API CXXThrowExpr : public Expr
{
public:
    CXXThrowExpr();
    SourceLocation throwLoc;
    bool isThrownVariableInScope;
};

class CS_API CXXDefaultArgExpr : public Expr
{
public:
    CXXDefaultArgExpr();
    bool hasRewrittenInit;
    SourceLocation usedLocation;
    SourceLocation exprLoc;
};

class CS_API CXXDefaultInitExpr : public Expr
{
public:
    CXXDefaultInitExpr();
    bool hasRewrittenInit;
    SourceLocation usedLocation;
};

class CS_API CXXBindTemporaryExpr : public Expr
{
public:
    CXXBindTemporaryExpr();
    Expr* subExpr;
};

class CS_API CXXConstructExpr : public Expr
{
public:
    enum class ConstructionKind
    {
        Complete = 0,
        NonVirtualBase = 1,
        VirtualBase = 2,
        Delegating = 3
    };

    CXXConstructExpr();
    CXXConstructExpr(StmtClass klass);
    VECTOR(Expr*, arguments)
    SourceLocation location;
    bool elidable;
    bool hadMultipleCandidates;
    bool listInitialization;
    bool stdInitListInitialization;
    bool requiresZeroInitialization;
    unsigned int numArgs;
    bool isImmediateEscalating;
    SourceRange parenOrBraceRange;
};

class CS_API CXXInheritedCtorInitExpr : public Expr
{
public:
    CXXInheritedCtorInitExpr();
    bool constructsVBase;
    bool inheritedFromVBase;
    SourceLocation location;
};

class CS_API CXXFunctionalCastExpr : public ExplicitCastExpr
{
public:
    CXXFunctionalCastExpr();
    SourceLocation lParenLoc;
    SourceLocation rParenLoc;
    bool isListInitialization;
};

class CS_API CXXTemporaryObjectExpr : public CXXConstructExpr
{
public:
    CXXTemporaryObjectExpr();
};

class CS_API LambdaExpr : public Expr
{
public:
    LambdaExpr();
    VECTOR(Expr*, capture_inits)
    SourceLocation captureDefaultLoc;
    unsigned int capture_size;
    SourceRange introducerRange;
    Method* callOperator;
    FunctionTemplate* dependentCallOperator;
    Expr* trailingRequiresClause;
    bool isGenericLambda;
    Stmt* body;
    bool isMutable;
    bool hasExplicitParameters;
    bool hasExplicitResultType;
};

class CS_API CXXScalarValueInitExpr : public Expr
{
public:
    CXXScalarValueInitExpr();
    SourceLocation rParenLoc;
};

class CS_API CXXNewExpr : public Expr
{
public:
    enum class InitializationStyle
    {
        /// <summary>New-expression has no initializer as written.</summary>
        NoInit = 0,
        /// <summary>New-expression has a C++98 paren-delimited initializer.</summary>
        CallInit = 1,
        /// <summary>New-expression has a C++11 list-initializer.</summary>
        ListInit = 2
    };

    CXXNewExpr();
    VECTOR(Expr*, placement_arguments)
    QualifiedType allocatedType;
    Function* operatorNew;
    Function* operatorDelete;
    bool isArray;
    unsigned int numPlacementArgs;
    bool isParenTypeId;
    SourceRange typeIdParens;
    bool isGlobalNew;
    bool hasInitializer;
    InitializationStyle initializationStyle;
    CXXConstructExpr* constructExpr;
    SourceRange directInitRange;
    SourceRange sourceRange;
};

class CS_API CXXDeleteExpr : public Expr
{
public:
    CXXDeleteExpr();
    bool isGlobalDelete;
    bool isArrayForm;
    bool isArrayFormAsWritten;
    Function* operatorDelete;
    QualifiedType destroyedType;
};

class CS_API CXXPseudoDestructorExpr : public Expr
{
public:
    CXXPseudoDestructorExpr();
    Expr* base;
    bool hasQualifier;
    bool isArrow;
    SourceLocation operatorLoc;
    SourceLocation colonColonLoc;
    SourceLocation tildeLoc;
    QualifiedType destroyedType;
    SourceLocation destroyedTypeLoc;
};

class CS_API TypeTraitExpr : public Expr
{
public:
    TypeTraitExpr();
    bool value;
    unsigned int numArgs;
};

class CS_API ArrayTypeTraitExpr : public Expr
{
public:
    ArrayTypeTraitExpr();
    QualifiedType queriedType;
    uint64_t value;
    Expr* dimensionExpression;
};

class CS_API ExpressionTraitExpr : public Expr
{
public:
    ExpressionTraitExpr();
    Expr* queriedExpression;
    bool value;
};

class CS_API OverloadExpr : public Expr
{
public:
    class CS_API FindResult
    {
    public:
        FindResult();
    };

    OverloadExpr();
    OverloadExpr(StmtClass klass);
    unsigned int numDecls;
    SourceLocation nameLoc;
    SourceLocation templateKeywordLoc;
    SourceLocation lAngleLoc;
    SourceLocation rAngleLoc;
    bool hasTemplateKeyword;
    bool hasExplicitTemplateArgs;
    unsigned int numTemplateArgs;
};

class CS_API UnresolvedLookupExpr : public OverloadExpr
{
public:
    UnresolvedLookupExpr();
    bool requiresADL;
    bool isOverloaded;
};

class CS_API DependentScopeDeclRefExpr : public Expr
{
public:
    DependentScopeDeclRefExpr();
    SourceLocation location;
    SourceLocation templateKeywordLoc;
    SourceLocation lAngleLoc;
    SourceLocation rAngleLoc;
    bool hasTemplateKeyword;
    bool hasExplicitTemplateArgs;
    unsigned int numTemplateArgs;
};

class CS_API ExprWithCleanups : public FullExpr
{
public:
    ExprWithCleanups();
    unsigned int numObjects;
    bool cleanupsHaveSideEffects;
};

class CS_API CXXUnresolvedConstructExpr : public Expr
{
public:
    CXXUnresolvedConstructExpr();
    VECTOR(Expr*, arguments)
    QualifiedType typeAsWritten;
    SourceLocation lParenLoc;
    SourceLocation rParenLoc;
    bool isListInitialization;
    unsigned int numArgs;
};

class CS_API CXXDependentScopeMemberExpr : public Expr
{
public:
    CXXDependentScopeMemberExpr();
    bool isImplicitAccess;
    Expr* base;
    QualifiedType baseType;
    bool isArrow;
    SourceLocation operatorLoc;
    Declaration* firstQualifierFoundInScope;
    SourceLocation memberLoc;
    SourceLocation templateKeywordLoc;
    SourceLocation lAngleLoc;
    SourceLocation rAngleLoc;
    bool hasTemplateKeyword;
    bool hasExplicitTemplateArgs;
    unsigned int numTemplateArgs;
};

class CS_API UnresolvedMemberExpr : public OverloadExpr
{
public:
    UnresolvedMemberExpr();
    bool isImplicitAccess;
    QualifiedType baseType;
    bool hasUnresolvedUsing;
    bool isArrow;
    SourceLocation operatorLoc;
    SourceLocation memberLoc;
    SourceLocation exprLoc;
};

class CS_API CXXNoexceptExpr : public Expr
{
public:
    CXXNoexceptExpr();
    Expr* operand;
    SourceRange sourceRange;
    bool value;
};

class CS_API PackExpansionExpr : public Expr
{
public:
    PackExpansionExpr();
    SourceLocation ellipsisLoc;
    std::optional<unsigned int> numExpansions;
};

class CS_API SizeOfPackExpr : public Expr
{
public:
    SizeOfPackExpr();
    SourceLocation operatorLoc;
    SourceLocation packLoc;
    SourceLocation rParenLoc;
    Declaration* pack;
    unsigned int packLength;
    bool isPartiallySubstituted;
};

class CS_API SubstNonTypeTemplateParmExpr : public Expr
{
public:
    SubstNonTypeTemplateParmExpr();
    SourceLocation nameLoc;
    Expr* replacement;
    Declaration* associatedDecl;
    unsigned int index;
    std::optional<unsigned int> packIndex;
    bool isReferenceParameter;
};

class CS_API SubstNonTypeTemplateParmPackExpr : public Expr
{
public:
    SubstNonTypeTemplateParmPackExpr();
    Declaration* associatedDecl;
    unsigned int index;
    SourceLocation parameterPackLocation;
    TemplateArgument argumentPack;
};

class CS_API FunctionParmPackExpr : public Expr
{
public:
    FunctionParmPackExpr();
    SourceLocation parameterPackLocation;
    unsigned int numExpansions;
};

class CS_API MaterializeTemporaryExpr : public Expr
{
public:
    MaterializeTemporaryExpr();
    Expr* subExpr;
    unsigned int manglingNumber;
    bool isBoundToLvalueReference;
};

class CS_API CXXFoldExpr : public Expr
{
public:
    enum class SubExpr
    {
        Callee = 0,
        LHS = 1,
        RHS = 2,
        Count = 3
    };

    CXXFoldExpr();
    UnresolvedLookupExpr* callee;
    Expr* lHS;
    Expr* rHS;
    bool isRightFold;
    bool isLeftFold;
    Expr* pattern;
    Expr* init;
    SourceLocation lParenLoc;
    SourceLocation rParenLoc;
    SourceLocation ellipsisLoc;
    BinaryOperatorKind _operator;
    std::optional<unsigned int> numExpansions;
};

class CS_API CXXParenListInitExpr : public Expr
{
public:
    CXXParenListInitExpr();
    SourceLocation initLoc;
    SourceRange sourceRange;
    Expr* arrayFiller;
};

class CS_API CoroutineSuspendExpr : public Expr
{
public:
    enum class SubExpr
    {
        Operand = 0,
        Common = 1,
        Ready = 2,
        Suspend = 3,
        Resume = 4,
        Count = 5
    };

    CoroutineSuspendExpr();
    CoroutineSuspendExpr(StmtClass klass);
    Expr* commonExpr;
    OpaqueValueExpr* opaqueValue;
    Expr* readyExpr;
    Expr* suspendExpr;
    Expr* resumeExpr;
    Expr* operand;
    SourceLocation keywordLoc;
};

class CS_API CoawaitExpr : public CoroutineSuspendExpr
{
public:
    CoawaitExpr();
    bool isImplicit;
};

class CS_API DependentCoawaitExpr : public Expr
{
public:
    DependentCoawaitExpr();
    Expr* operand;
    UnresolvedLookupExpr* operatorCoawaitLookup;
    SourceLocation keywordLoc;
};

class CS_API CoyieldExpr : public CoroutineSuspendExpr
{
public:
    CoyieldExpr();
};

class CS_API BuiltinBitCastExpr : public ExplicitCastExpr
{
public:
    BuiltinBitCastExpr();
};

}
