// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------

#pragma once

#include "Sources.h"
#include "Types.h"

namespace CppSharp::CppParser::AST {

class Expr;
class Declaration;

enum class StmtClass
{
    NoStmt = 0,
    GCCAsmStmt = 1,
    MSAsmStmt = 2,
    BreakStmt = 3,
    CXXCatchStmt = 4,
    CXXForRangeStmt = 5,
    CXXTryStmt = 6,
    CapturedStmt = 7,
    CompoundStmt = 8,
    ContinueStmt = 9,
    CoreturnStmt = 10,
    CoroutineBodyStmt = 11,
    DeclStmt = 12,
    DoStmt = 13,
    ForStmt = 14,
    GotoStmt = 15,
    IfStmt = 16,
    IndirectGotoStmt = 17,
    MSDependentExistsStmt = 18,
    NullStmt = 19,
    ReturnStmt = 99,
    SEHExceptStmt = 100,
    SEHFinallyStmt = 101,
    SEHLeaveStmt = 102,
    SEHTryStmt = 103,
    CaseStmt = 104,
    DefaultStmt = 105,
    SwitchStmt = 106,
    AttributedStmt = 107,
    BinaryConditionalOperator = 108,
    ConditionalOperator = 109,
    AddrLabelExpr = 110,
    ArrayInitIndexExpr = 111,
    ArrayInitLoopExpr = 112,
    ArraySubscriptExpr = 113,
    ArrayTypeTraitExpr = 114,
    AsTypeExpr = 115,
    AtomicExpr = 116,
    BinaryOperator = 117,
    CompoundAssignOperator = 118,
    BlockExpr = 119,
    CXXBindTemporaryExpr = 120,
    CXXBoolLiteralExpr = 121,
    CXXConstructExpr = 122,
    CXXTemporaryObjectExpr = 123,
    CXXDefaultArgExpr = 124,
    CXXDefaultInitExpr = 125,
    CXXDeleteExpr = 126,
    CXXDependentScopeMemberExpr = 127,
    CXXFoldExpr = 128,
    CXXInheritedCtorInitExpr = 129,
    CXXNewExpr = 130,
    CXXNoexceptExpr = 131,
    CXXNullPtrLiteralExpr = 132,
    CXXParenListInitExpr = 133,
    CXXPseudoDestructorExpr = 134,
    CXXRewrittenBinaryOperator = 135,
    CXXScalarValueInitExpr = 136,
    CXXStdInitializerListExpr = 137,
    CXXThisExpr = 138,
    CXXThrowExpr = 139,
    CXXTypeidExpr = 140,
    CXXUnresolvedConstructExpr = 141,
    CXXUuidofExpr = 142,
    CallExpr = 143,
    CUDAKernelCallExpr = 144,
    CXXMemberCallExpr = 145,
    CXXOperatorCallExpr = 146,
    UserDefinedLiteral = 147,
    BuiltinBitCastExpr = 148,
    CStyleCastExpr = 149,
    CXXFunctionalCastExpr = 150,
    CXXAddrspaceCastExpr = 151,
    CXXConstCastExpr = 152,
    CXXDynamicCastExpr = 153,
    CXXReinterpretCastExpr = 154,
    CXXStaticCastExpr = 155,
    ImplicitCastExpr = 157,
    CharacterLiteral = 158,
    ChooseExpr = 159,
    CompoundLiteralExpr = 160,
    ConceptSpecializationExpr = 161,
    ConvertVectorExpr = 162,
    CoawaitExpr = 163,
    CoyieldExpr = 164,
    DeclRefExpr = 165,
    DependentCoawaitExpr = 166,
    DependentScopeDeclRefExpr = 167,
    DesignatedInitExpr = 168,
    DesignatedInitUpdateExpr = 169,
    ExpressionTraitExpr = 170,
    ExtVectorElementExpr = 171,
    FixedPointLiteral = 172,
    FloatingLiteral = 173,
    ConstantExpr = 174,
    ExprWithCleanups = 175,
    FunctionParmPackExpr = 176,
    GNUNullExpr = 177,
    GenericSelectionExpr = 178,
    ImaginaryLiteral = 179,
    ImplicitValueInitExpr = 180,
    InitListExpr = 181,
    IntegerLiteral = 182,
    LambdaExpr = 183,
    MSPropertyRefExpr = 184,
    MSPropertySubscriptExpr = 185,
    MaterializeTemporaryExpr = 186,
    MatrixSubscriptExpr = 187,
    MemberExpr = 188,
    NoInitExpr = 189,
    OffsetOfExpr = 208,
    OpaqueValueExpr = 209,
    UnresolvedLookupExpr = 210,
    UnresolvedMemberExpr = 211,
    PackExpansionExpr = 212,
    ParenExpr = 213,
    ParenListExpr = 214,
    PredefinedExpr = 215,
    PseudoObjectExpr = 216,
    RecoveryExpr = 217,
    RequiresExpr = 218,
    SYCLUniqueStableNameExpr = 219,
    ShuffleVectorExpr = 220,
    SizeOfPackExpr = 221,
    SourceLocExpr = 222,
    StmtExpr = 223,
    StringLiteral = 224,
    SubstNonTypeTemplateParmExpr = 225,
    SubstNonTypeTemplateParmPackExpr = 226,
    TypeTraitExpr = 227,
    TypoExpr = 228,
    UnaryExprOrTypeTraitExpr = 229,
    UnaryOperator = 230,
    VAArgExpr = 231,
    LabelStmt = 232,
    WhileStmt = 233,
};

/// <summary>
/// <para>In an if statement, this denotes whether the statement is</para>
/// <para>a constexpr or consteval if statement.</para>
/// </summary>
enum class IfStatementKind : unsigned int
{
    Ordinary = 0,
    Constexpr = 1,
    ConstevalNonNegated = 2,
    ConstevalNegated = 3
};

class CS_API Stmt
{
public:
    /// <summary>The likelihood of a branch being taken.</summary>
    enum class Likelihood
    {
        /// <summary>Branch has the [[unlikely]] attribute.</summary>
        Unlikely = -1,
        /// <summary>
        /// <para>No attribute set or branches of the IfStmt have</para>
        /// <para>the same attribute.</para>
        /// </summary>
        None = 0,
        /// <summary>Branch has the [[likely]] attribute.</summary>
        Likely = 1
    };

    Stmt();
    Stmt(StmtClass klass);
    StmtClass stmtClass;
    SourceRange sourceRange;
    SourceLocation beginLoc;
    SourceLocation endLoc;
};

class CS_API DeclStmt : public Stmt
{
public:
    DeclStmt();
    VECTOR(Declaration*, decls)
    bool isSingleDecl;
};

class CS_API NullStmt : public Stmt
{
public:
    NullStmt();
    SourceLocation semiLoc;
    bool hasLeadingEmptyMacro;
};

class CS_API CompoundStmt : public Stmt
{
public:
    CompoundStmt();
    VECTOR(Stmt*, body)
    bool body_empty;
    unsigned int size;
    bool hasStoredFPFeatures;
    SourceLocation lBracLoc;
    SourceLocation rBracLoc;
};

class CS_API SwitchCase : public Stmt
{
public:
    SwitchCase();
    SwitchCase(StmtClass klass);
    SourceLocation keywordLoc;
    SourceLocation colonLoc;
};

class CS_API CaseStmt : public SwitchCase
{
public:
    CaseStmt();
    bool caseStmtIsGNURange;
    SourceLocation caseLoc;
    SourceLocation ellipsisLoc;
    Expr* lHS;
    Expr* rHS;
    Stmt* subStmt;
};

class CS_API DefaultStmt : public SwitchCase
{
public:
    DefaultStmt();
    Stmt* subStmt;
    SourceLocation defaultLoc;
};

class CS_API ValueStmt : public Stmt
{
public:
    ValueStmt();
    ValueStmt(StmtClass klass);
};

class CS_API LabelStmt : public ValueStmt
{
public:
    LabelStmt();
    SourceLocation identLoc;
    const char* name;
    Stmt* subStmt;
    bool sideEntry;
};

class CS_API AttributedStmt : public ValueStmt
{
public:
    AttributedStmt();
    SourceLocation attrLoc;
};

class CS_API IfStmt : public Stmt
{
public:
    IfStmt();
    bool hasInitStorage;
    bool hasVarStorage;
    bool hasElseStorage;
    Expr* cond;
    Stmt* then;
    Stmt* _else;
    DeclStmt* conditionVariableDeclStmt;
    Stmt* init;
    SourceLocation ifLoc;
    SourceLocation elseLoc;
    bool isConsteval;
    bool isNonNegatedConsteval;
    bool isNegatedConsteval;
    bool isConstexpr;
    IfStatementKind statementKind;
    bool isObjCAvailabilityCheck;
    SourceLocation lParenLoc;
    SourceLocation rParenLoc;
};

class CS_API SwitchStmt : public Stmt
{
public:
    SwitchStmt();
    bool hasInitStorage;
    bool hasVarStorage;
    Expr* cond;
    Stmt* body;
    Stmt* init;
    DeclStmt* conditionVariableDeclStmt;
    SourceLocation switchLoc;
    SourceLocation lParenLoc;
    SourceLocation rParenLoc;
    bool isAllEnumCasesCovered;
};

class CS_API WhileStmt : public Stmt
{
public:
    WhileStmt();
    bool hasVarStorage;
    Expr* cond;
    Stmt* body;
    DeclStmt* conditionVariableDeclStmt;
    SourceLocation whileLoc;
    SourceLocation lParenLoc;
    SourceLocation rParenLoc;
};

class CS_API DoStmt : public Stmt
{
public:
    DoStmt();
    Expr* cond;
    Stmt* body;
    SourceLocation doLoc;
    SourceLocation whileLoc;
    SourceLocation rParenLoc;
};

class CS_API ForStmt : public Stmt
{
public:
    ForStmt();
    Stmt* init;
    DeclStmt* conditionVariableDeclStmt;
    Expr* cond;
    Expr* inc;
    Stmt* body;
    SourceLocation forLoc;
    SourceLocation lParenLoc;
    SourceLocation rParenLoc;
};

class CS_API GotoStmt : public Stmt
{
public:
    GotoStmt();
    SourceLocation gotoLoc;
    SourceLocation labelLoc;
};

class CS_API IndirectGotoStmt : public Stmt
{
public:
    IndirectGotoStmt();
    SourceLocation gotoLoc;
    SourceLocation starLoc;
    Expr* target;
};

class CS_API ContinueStmt : public Stmt
{
public:
    ContinueStmt();
    SourceLocation continueLoc;
};

class CS_API BreakStmt : public Stmt
{
public:
    BreakStmt();
    SourceLocation breakLoc;
};

class CS_API ReturnStmt : public Stmt
{
public:
    ReturnStmt();
    Expr* retValue;
    SourceLocation returnLoc;
};

class CS_API AsmStmt : public Stmt
{
public:
    AsmStmt();
    AsmStmt(StmtClass klass);
    VECTOR(Expr*, inputs)
    VECTOR(Expr*, outputs)
    SourceLocation asmLoc;
    bool simple;
    bool _volatile;
    unsigned int numOutputs;
    unsigned int numPlusOperands;
    unsigned int numInputs;
    unsigned int numClobbers;
};

class StringLiteral;
class AddrLabelExpr;

class CS_API GCCAsmStmt : public AsmStmt
{
public:
    class CS_API AsmStringPiece
    {
    public:
        enum class Kind
        {
            String = 0,
            Operand = 1
        };

        AsmStringPiece();
        bool isString;
        bool isOperand;
        std::string string;
        unsigned int operandNo;
        char modifier;
    };

    GCCAsmStmt();
    VECTOR(AddrLabelExpr*, labels)
    SourceLocation rParenLoc;
    bool isAsmGoto;
    unsigned int numLabels;
};

class CS_API MSAsmStmt : public AsmStmt
{
public:
    MSAsmStmt();
    SourceLocation lBraceLoc;
    bool hasBraces;
    unsigned int numAsmToks;
    std::string asmString;
};

class CS_API SEHExceptStmt : public Stmt
{
public:
    SEHExceptStmt();
    SourceLocation exceptLoc;
    Expr* filterExpr;
    CompoundStmt* block;
};

class CS_API SEHFinallyStmt : public Stmt
{
public:
    SEHFinallyStmt();
    SourceLocation finallyLoc;
    CompoundStmt* block;
};

class CS_API SEHTryStmt : public Stmt
{
public:
    SEHTryStmt();
    SourceLocation tryLoc;
    bool isCXXTry;
    CompoundStmt* tryBlock;
    Stmt* handler;
    SEHExceptStmt* exceptHandler;
    SEHFinallyStmt* finallyHandler;
};

class CS_API SEHLeaveStmt : public Stmt
{
public:
    SEHLeaveStmt();
    SourceLocation leaveLoc;
};

class CS_API CapturedStmt : public Stmt
{
public:
    /// <summary>
    /// <para>The different capture forms: by 'this', by reference, capture for</para>
    /// <para>variable-length array type etc.</para>
    /// </summary>
    enum class VariableCaptureKind
    {
        This = 0,
        ByRef = 1,
        ByCopy = 2,
        VLAType = 3
    };

    class CS_API Capture
    {
    public:
        Capture();
        VariableCaptureKind captureKind;
        SourceLocation location;
        bool capturesThis;
        bool capturesVariable;
        bool capturesVariableByCopy;
        bool capturesVariableArrayType;
    };

    CapturedStmt();
    VECTOR(Expr*, capture_inits)
    unsigned int capture_size;
    SourceRange sourceRange;
};

class CS_API CXXCatchStmt : public Stmt
{
public:
    CXXCatchStmt();
    SourceLocation catchLoc;
    QualifiedType caughtType;
    Stmt* handlerBlock;
};

class CS_API CXXTryStmt : public Stmt
{
public:
    CXXTryStmt();
    SourceLocation tryLoc;
    unsigned int numHandlers;
};

class CS_API CXXForRangeStmt : public Stmt
{
public:
    CXXForRangeStmt();
    Stmt* init;
    Expr* rangeInit;
    Expr* cond;
    Expr* inc;
    Stmt* body;
    SourceLocation forLoc;
    SourceLocation coawaitLoc;
    SourceLocation colonLoc;
    SourceLocation rParenLoc;
};

class CS_API MSDependentExistsStmt : public Stmt
{
public:
    MSDependentExistsStmt();
    SourceLocation keywordLoc;
    bool isIfExists;
    bool isIfNotExists;
    CompoundStmt* subStmt;
};

class CS_API CoroutineBodyStmt : public Stmt
{
public:
    enum class SubStmt
    {
        /// <summary>The body of the coroutine.</summary>
        Body = 0,
        /// <summary>The promise statement.</summary>
        Promise = 1,
        /// <summary>The initial suspend statement, run before the body.</summary>
        InitSuspend = 2,
        /// <summary>The final suspend statement, run after the body.</summary>
        FinalSuspend = 3,
        /// <summary>Handler for exceptions thrown in the body.</summary>
        OnException = 4,
        /// <summary>Handler for control flow falling off the body.</summary>
        OnFallthrough = 5,
        /// <summary>Coroutine frame memory allocation.</summary>
        Allocate = 6,
        /// <summary>Coroutine frame memory deallocation.</summary>
        Deallocate = 7,
        /// <summary>Declaration holding the result of get_return_object.</summary>
        ResultDecl = 8,
        /// <summary>Return value for thunk function: p.get_return_object().</summary>
        ReturnValue = 9,
        /// <summary>Return statement for the thunk function.</summary>
        ReturnStmt = 10,
        /// <summary>Return statement if allocation failed.</summary>
        ReturnStmtOnAllocFailure = 11,
        /// <summary>First offset for move construction of parameter copies.</summary>
        FirstParamMove = 12
    };

    class CS_API CtorArgs
    {
    public:
        CtorArgs();
    };

    CoroutineBodyStmt();
    VECTOR(Stmt*, childrenExclBody)
    bool hasDependentPromiseType;
    CompoundStmt* body;
    Stmt* promiseDeclStmt;
    Stmt* initSuspendStmt;
    Stmt* finalSuspendStmt;
    Stmt* exceptionHandler;
    Stmt* fallthroughHandler;
    Expr* allocate;
    Expr* deallocate;
    Stmt* resultDecl;
    Expr* returnValueInit;
    Expr* returnValue;
    Stmt* returnStmt;
    Stmt* returnStmtOnAllocFailure;
};

class CS_API CoreturnStmt : public Stmt
{
public:
    enum class SubStmt
    {
        Operand = 0,
        PromiseCall = 1,
        Count = 2
    };

    CoreturnStmt();
    SourceLocation keywordLoc;
    Expr* operand;
    Expr* promiseCall;
    bool isImplicit;
};

}
