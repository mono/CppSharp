// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------

#pragma once

#include "Sources.h"
#include "Types.h"

namespace CppSharp { namespace CppParser { namespace AST {

class Expr;
class Declaration;

enum class StmtClass
{
    NoStmt = 0,
    GCCAsmStmt = 1,
    MSAsmStmt = 2,
    AttributedStmt = 3,
    BreakStmt = 4,
    CXXCatchStmt = 5,
    CXXForRangeStmt = 6,
    CXXTryStmt = 7,
    CapturedStmt = 8,
    CompoundStmt = 9,
    ContinueStmt = 10,
    CoreturnStmt = 11,
    CoroutineBodyStmt = 12,
    DeclStmt = 13,
    DoStmt = 14,
    BinaryConditionalOperator = 15,
    ConditionalOperator = 16,
    AddrLabelExpr = 17,
    ArrayInitIndexExpr = 18,
    ArrayInitLoopExpr = 19,
    ArraySubscriptExpr = 20,
    ArrayTypeTraitExpr = 21,
    AsTypeExpr = 22,
    AtomicExpr = 23,
    BinaryOperator = 24,
    CompoundAssignOperator = 25,
    BlockExpr = 26,
    CXXBindTemporaryExpr = 27,
    CXXBoolLiteralExpr = 28,
    CXXConstructExpr = 29,
    CXXTemporaryObjectExpr = 30,
    CXXDefaultArgExpr = 31,
    CXXDefaultInitExpr = 32,
    CXXDeleteExpr = 33,
    CXXDependentScopeMemberExpr = 34,
    CXXFoldExpr = 35,
    CXXInheritedCtorInitExpr = 36,
    CXXNewExpr = 37,
    CXXNoexceptExpr = 38,
    CXXNullPtrLiteralExpr = 39,
    CXXPseudoDestructorExpr = 40,
    CXXScalarValueInitExpr = 41,
    CXXStdInitializerListExpr = 42,
    CXXThisExpr = 43,
    CXXThrowExpr = 44,
    CXXTypeidExpr = 45,
    CXXUnresolvedConstructExpr = 46,
    CXXUuidofExpr = 47,
    CallExpr = 48,
    CUDAKernelCallExpr = 49,
    CXXMemberCallExpr = 50,
    CXXOperatorCallExpr = 51,
    UserDefinedLiteral = 52,
    CStyleCastExpr = 53,
    CXXFunctionalCastExpr = 54,
    CXXConstCastExpr = 55,
    CXXDynamicCastExpr = 56,
    CXXReinterpretCastExpr = 57,
    CXXStaticCastExpr = 58,
    ImplicitCastExpr = 60,
    CharacterLiteral = 61,
    ChooseExpr = 62,
    CompoundLiteralExpr = 63,
    ConvertVectorExpr = 64,
    CoawaitExpr = 65,
    CoyieldExpr = 66,
    DeclRefExpr = 67,
    DependentCoawaitExpr = 68,
    DependentScopeDeclRefExpr = 69,
    DesignatedInitExpr = 70,
    DesignatedInitUpdateExpr = 71,
    ExpressionTraitExpr = 72,
    ExtVectorElementExpr = 73,
    FixedPointLiteral = 74,
    FloatingLiteral = 75,
    ConstantExpr = 76,
    ExprWithCleanups = 77,
    FunctionParmPackExpr = 78,
    GNUNullExpr = 79,
    GenericSelectionExpr = 80,
    ImaginaryLiteral = 81,
    ImplicitValueInitExpr = 82,
    InitListExpr = 83,
    IntegerLiteral = 84,
    LambdaExpr = 85,
    MSPropertyRefExpr = 86,
    MSPropertySubscriptExpr = 87,
    MaterializeTemporaryExpr = 88,
    MemberExpr = 89,
    NoInitExpr = 90,
    OffsetOfExpr = 107,
    OpaqueValueExpr = 108,
    UnresolvedLookupExpr = 109,
    UnresolvedMemberExpr = 110,
    PackExpansionExpr = 111,
    ParenExpr = 112,
    ParenListExpr = 113,
    PredefinedExpr = 114,
    PseudoObjectExpr = 115,
    ShuffleVectorExpr = 116,
    SizeOfPackExpr = 117,
    StmtExpr = 118,
    StringLiteral = 119,
    SubstNonTypeTemplateParmExpr = 120,
    SubstNonTypeTemplateParmPackExpr = 121,
    TypeTraitExpr = 122,
    TypoExpr = 123,
    UnaryExprOrTypeTraitExpr = 124,
    UnaryOperator = 125,
    VAArgExpr = 126,
    ForStmt = 127,
    GotoStmt = 128,
    IfStmt = 129,
    IndirectGotoStmt = 130,
    LabelStmt = 131,
    MSDependentExistsStmt = 132,
    NullStmt = 133,
    ReturnStmt = 188,
    SEHExceptStmt = 189,
    SEHFinallyStmt = 190,
    SEHLeaveStmt = 191,
    SEHTryStmt = 192,
    CaseStmt = 193,
    DefaultStmt = 194,
    SwitchStmt = 195,
    WhileStmt = 196,

};

class CS_API Stmt
{
public:
    Stmt();
    Stmt(StmtClass klass);
    StmtClass stmtClass;
    SourceRange sourceRange;
    SourceLocation endLoc;
    Stmt* stripLabelLikeStatements;
};

class CS_API DeclStmt : public Stmt
{
public:
    DeclStmt();
    VECTOR(Declaration*, decls)
    bool isSingleDecl;
    Declaration* singleDecl;
};

class CS_API NullStmt : public Stmt
{
public:
    NullStmt();
    SourceLocation semiLoc;
    bool hasLeadingEmptyMacro;
};

class CS_API CompoundStmt : public Stmt
{
public:
    CompoundStmt();
    VECTOR(Stmt*, body)
    bool body_empty;
    unsigned int size;
    Stmt* body_front;
    Stmt* body_back;
    SourceLocation lBracLoc;
    SourceLocation rBracLoc;
};

class CS_API SwitchCase : public Stmt
{
public:
    SwitchCase();
    SwitchCase(StmtClass klass);
    SourceLocation keywordLoc;
    SourceLocation colonLoc;
    Stmt* subStmt;
};

class CS_API CaseStmt : public SwitchCase
{
public:
    CaseStmt();
    SourceLocation caseLoc;
    SourceLocation ellipsisLoc;
    Expr* lHS;
    Expr* rHS;
    bool caseStmtIsGNURange;
};

class CS_API DefaultStmt : public SwitchCase
{
public:
    DefaultStmt();
    SourceLocation defaultLoc;
};

class CS_API LabelStmt : public Stmt
{
public:
    LabelStmt();
    SourceLocation identLoc;
    Stmt* subStmt;
    const char* name;
};

class CS_API AttributedStmt : public Stmt
{
public:
    AttributedStmt();
    SourceLocation attrLoc;
    Stmt* subStmt;
};

class CS_API IfStmt : public Stmt
{
public:
    IfStmt();
    Expr* cond;
    Stmt* then;
    Stmt* _else;
    Stmt* init;
    SourceLocation ifLoc;
    SourceLocation elseLoc;
    bool _constexpr;
    bool hasInitStorage;
    bool hasVarStorage;
    bool hasElseStorage;
    DeclStmt* conditionVariableDeclStmt;
    bool isObjCAvailabilityCheck;
};

class CS_API SwitchStmt : public Stmt
{
public:
    SwitchStmt();
    Expr* cond;
    Stmt* body;
    Stmt* init;
    SourceLocation switchLoc;
    bool hasInitStorage;
    bool hasVarStorage;
    DeclStmt* conditionVariableDeclStmt;
    bool isAllEnumCasesCovered;
};

class CS_API WhileStmt : public Stmt
{
public:
    WhileStmt();
    Expr* cond;
    Stmt* body;
    SourceLocation whileLoc;
    bool hasVarStorage;
    DeclStmt* conditionVariableDeclStmt;
};

class CS_API DoStmt : public Stmt
{
public:
    DoStmt();
    Expr* cond;
    Stmt* body;
    SourceLocation doLoc;
    SourceLocation whileLoc;
    SourceLocation rParenLoc;
};

class CS_API ForStmt : public Stmt
{
public:
    ForStmt();
    Stmt* init;
    Expr* cond;
    Expr* inc;
    Stmt* body;
    SourceLocation forLoc;
    SourceLocation lParenLoc;
    SourceLocation rParenLoc;
    DeclStmt* conditionVariableDeclStmt;
};

class CS_API GotoStmt : public Stmt
{
public:
    GotoStmt();
    SourceLocation gotoLoc;
    SourceLocation labelLoc;
};

class CS_API IndirectGotoStmt : public Stmt
{
public:
    IndirectGotoStmt();
    SourceLocation gotoLoc;
    SourceLocation starLoc;
    Expr* target;
};

class CS_API ContinueStmt : public Stmt
{
public:
    ContinueStmt();
    SourceLocation continueLoc;
};

class CS_API BreakStmt : public Stmt
{
public:
    BreakStmt();
    SourceLocation breakLoc;
};

class CS_API ReturnStmt : public Stmt
{
public:
    ReturnStmt();
    Expr* retValue;
    SourceLocation returnLoc;
};

class CS_API AsmStmt : public Stmt
{
public:
    AsmStmt();
    AsmStmt(StmtClass klass);
    VECTOR(Expr*, inputs)
    VECTOR(Expr*, outputs)
    SourceLocation asmLoc;
    bool simple;
    bool _volatile;
    unsigned int numOutputs;
    unsigned int numPlusOperands;
    unsigned int numInputs;
    unsigned int numClobbers;
};

class StringLiteral;

class CS_API GCCAsmStmt : public AsmStmt
{
public:
    class CS_API AsmStringPiece
    {
    public:
        enum class Kind
        {
            String = 0,
            Operand = 1
        };

        AsmStringPiece();
        bool isString;
        bool isOperand;
        std::string string;
        unsigned int operandNo;
        char modifier;
    };

    GCCAsmStmt();
    SourceLocation rParenLoc;
};

class CS_API MSAsmStmt : public AsmStmt
{
public:
    MSAsmStmt();
    SourceLocation lBraceLoc;
    bool hasBraces;
    unsigned int numAsmToks;
    std::string asmString;
};

class CS_API SEHExceptStmt : public Stmt
{
public:
    SEHExceptStmt();
    SourceLocation exceptLoc;
    Expr* filterExpr;
    CompoundStmt* block;
};

class CS_API SEHFinallyStmt : public Stmt
{
public:
    SEHFinallyStmt();
    SourceLocation finallyLoc;
    CompoundStmt* block;
};

class CS_API SEHTryStmt : public Stmt
{
public:
    SEHTryStmt();
    SourceLocation tryLoc;
    bool isCXXTry;
    CompoundStmt* tryBlock;
    Stmt* handler;
    SEHExceptStmt* exceptHandler;
    SEHFinallyStmt* finallyHandler;
};

class CS_API SEHLeaveStmt : public Stmt
{
public:
    SEHLeaveStmt();
    SourceLocation leaveLoc;
};

class CS_API CapturedStmt : public Stmt
{
public:
    enum class VariableCaptureKind
    {
        This = 0,
        ByRef = 1,
        ByCopy = 2,
        VLAType = 3
    };

    class CS_API Capture
    {
    public:
        Capture();
        VariableCaptureKind captureKind;
        SourceLocation location;
        bool capturesThis;
        bool capturesVariable;
        bool capturesVariableByCopy;
        bool capturesVariableArrayType;
    };

    CapturedStmt();
    VECTOR(Expr*, capture_inits)
    Stmt* capturedStmt;
    unsigned int capture_size;
};

class CS_API CXXCatchStmt : public Stmt
{
public:
    CXXCatchStmt();
    SourceLocation catchLoc;
    QualifiedType caughtType;
    Stmt* handlerBlock;
};

class CS_API CXXTryStmt : public Stmt
{
public:
    CXXTryStmt();
    SourceLocation tryLoc;
    CompoundStmt* tryBlock;
    unsigned int numHandlers;
};

class CS_API CXXForRangeStmt : public Stmt
{
public:
    CXXForRangeStmt();
    Stmt* init;
    Expr* rangeInit;
    Expr* cond;
    Expr* inc;
    Stmt* body;
    DeclStmt* rangeStmt;
    DeclStmt* beginStmt;
    DeclStmt* endStmt;
    DeclStmt* loopVarStmt;
    SourceLocation forLoc;
    SourceLocation coawaitLoc;
    SourceLocation colonLoc;
    SourceLocation rParenLoc;
};

class CS_API MSDependentExistsStmt : public Stmt
{
public:
    MSDependentExistsStmt();
    SourceLocation keywordLoc;
    bool isIfExists;
    bool isIfNotExists;
    CompoundStmt* subStmt;
};

class CS_API CoroutineBodyStmt : public Stmt
{
public:
    enum class SubStmt
    {
        Body = 0,
        Promise = 1,
        InitSuspend = 2,
        FinalSuspend = 3,
        OnException = 4,
        OnFallthrough = 5,
        Allocate = 6,
        Deallocate = 7,
        ReturnValue = 8,
        ResultDecl = 9,
        ReturnStmt = 10,
        ReturnStmtOnAllocFailure = 11,
        FirstParamMove = 12
    };

    class CS_API CtorArgs
    {
    public:
        CtorArgs();
    };

    CoroutineBodyStmt();
    bool hasDependentPromiseType;
    Stmt* body;
    Stmt* promiseDeclStmt;
    Stmt* initSuspendStmt;
    Stmt* finalSuspendStmt;
    Stmt* exceptionHandler;
    Stmt* fallthroughHandler;
    Expr* allocate;
    Expr* deallocate;
    Expr* returnValueInit;
    Stmt* resultDecl;
    Stmt* returnStmt;
    Stmt* returnStmtOnAllocFailure;
};

class CS_API CoreturnStmt : public Stmt
{
public:
    enum class SubStmt
    {
        Operand = 0,
        PromiseCall = 1,
        Count = 2
    };

    CoreturnStmt();
    bool isImplicit;
    SourceLocation keywordLoc;
    Expr* operand;
    Expr* promiseCall;
};

} } }
