//----------------------------------------------------------------------------
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
//----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace CppSharp
{
    namespace llvm
    {
        /// <summary>
        /// <para>ArrayRef - Represent a constant reference to an array (0 or more
        /// elements consecutively in memory), i.e. a start pointer and a length. It
        /// allows various APIs to take consecutive elements easily and
        /// conveniently.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// ArrayRef - Represent a constant reference to an array (0 or
        /// more elements</para>
        /// <para>  /// consecutively in memory), i.e. a start pointer and a
        /// length.  It allows</para>
        /// <para>  /// various APIs to take consecutive elements easily and
        /// conveniently.</para>
        /// <para>  ///</para>
        /// <para>  /// This class does not own the underlying data, it is expected
        /// to be used in</para>
        /// <para>  /// situations where the data resides in some other buffer,
        /// whose lifetime</para>
        /// <para>  /// extends past that of the ArrayRef. For this reason, it is
        /// not in general</para>
        /// <para>  /// safe to store an ArrayRef.</para>
        /// <para>  ///</para>
        /// <para>  /// This is intended to be trivially copyable, so it should be
        /// passed by</para>
        /// <para>  /// value.</para>
        /// </remarks>
        public unsafe partial class ArrayRef
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr Data;

                [FieldOffset(0)]
                public uint Length;
            }

            /// <summary>
            /// <para>A dummy &quot;optional&quot; type that is only created by
            /// implicit conversion from a reference to T.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief A dummy &quot;optional&quot; type that is only created
            /// by implicit</para>
            /// <para>    /// conversion from a reference to T.</para>
            /// <para>    ///</para>
            /// <para>    /// This type must *only* be used in a function argument or
            /// as a copy of</para>
            /// <para>    /// a function argument, as otherwise it will hold a pointer
            /// to a temporary</para>
            /// <para>    /// past that temporaries' lifetime.</para>
            /// </remarks>
            internal unsafe partial class TRefOrNothing
            {
                [StructLayout(LayoutKind.Explicit, Size = 0)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public global::System.IntPtr TPtr;
                }
            }
        }

        /// <summary>
        /// <para>MutableArrayRef - Represent a mutable reference to an array (0 or
        /// more elements consecutively in memory), i.e. a start pointer and a length.
        /// It allows various APIs to take and modify consecutive elements easily and
        /// conveniently.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// MutableArrayRef - Represent a mutable reference to an array
        /// (0 or more</para>
        /// <para>  /// elements consecutively in memory), i.e. a start pointer and
        /// a length.  It</para>
        /// <para>  /// allows various APIs to take and modify consecutive elements
        /// easily and</para>
        /// <para>  /// conveniently.</para>
        /// <para>  ///</para>
        /// <para>  /// This class does not own the underlying data, it is expected
        /// to be used in</para>
        /// <para>  /// situations where the data resides in some other buffer,
        /// whose lifetime</para>
        /// <para>  /// extends past that of the MutableArrayRef. For this reason,
        /// it is not in</para>
        /// <para>  /// general safe to store a MutableArrayRef.</para>
        /// <para>  ///</para>
        /// <para>  /// This is intended to be trivially copyable, so it should be
        /// passed by</para>
        /// <para>  /// value.</para>
        /// </remarks>
        public unsafe partial class MutableArrayRef
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct Internal
            {
            }
        }
    }
}
