//----------------------------------------------------------------------------
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
//----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace CppSharp
{
    namespace llvm
    {
        /// <summary>
        /// <para>SmallPtrSet - This class implements a set which is optimized for
        /// holding SmallSize or less elements. This internally rounds up SmallSize to
        /// the next power of two if it is not already a power of two. See the comments
        /// above SmallPtrSetImplBase for details of the algorithm.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// SmallPtrSet - This class implements a set which is optimized
        /// for holding</para>
        /// <para>/// SmallSize or less elements.  This internally rounds up
        /// SmallSize to the next</para>
        /// <para>/// power of two if it is not already a power of two.  See the
        /// comments above</para>
        /// <para>/// SmallPtrSetImplBase for details of the algorithm.</para>
        /// </remarks>
        public unsafe partial class SmallPtrSet
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct Internal
            {
            }
        }

        /// <summary>
        /// <para>A templated base class for SmallPtrSet which provides the
        /// typesafe interface that is common across all small sizes.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief A templated base class for \c SmallPtrSet which
        /// provides the</para>
        /// <para>/// typesafe interface that is common across all small
        /// sizes.</para>
        /// <para>///</para>
        /// <para>/// This is particularly useful for passing around between
        /// interface boundaries</para>
        /// <para>/// to avoid encoding a particular small size in the interface
        /// boundary.</para>
        /// </remarks>
        public unsafe partial class SmallPtrSetImpl
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                public void** SmallArray;

                [FieldOffset(4)]
                public void** CurArray;

                [FieldOffset(8)]
                public uint CurArraySize;

                [FieldOffset(12)]
                public uint NumElements;

                [FieldOffset(16)]
                public uint NumTombstones;
            }
        }

        /// <summary>
        /// <para>SmallPtrSetIterator - This implements a const_iterator for
        /// SmallPtrSet.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// SmallPtrSetIterator - This implements a const_iterator for
        /// SmallPtrSet.</para>
        /// </remarks>
        public unsafe partial class SmallPtrSetIterator
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                public void** Bucket;

                [FieldOffset(4)]
                public void** End;
            }
        }

        /// <summary>
        /// <para>RoundUpToPowerOfTwoH - If N is not a power of two, increase it.
        /// This is a helper template used to implement RoundUpToPowerOfTwo.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// RoundUpToPowerOfTwoH - If N is not a power of two, increase
        /// it.  This is a</para>
        /// <para>/// helper template used to implement RoundUpToPowerOfTwo.</para>
        /// </remarks>
        public unsafe static partial class RoundUpToPowerOfTwoH
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct Internal
            {
            }
        }

        /// <summary>
        /// <para>SmallPtrSetImplBase - This is the common code shared among all
        /// the SmallPtrSet&lt;&gt;'s, which is almost everything. SmallPtrSet has two
        /// modes, one for small and one for large sets.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// SmallPtrSetImplBase - This is the common code shared among
        /// all the</para>
        /// <para>/// SmallPtrSet&lt;&gt;'s, which is almost everything.
        /// SmallPtrSet has two modes, one</para>
        /// <para>/// for small and one for large sets.</para>
        /// <para>///</para>
        /// <para>/// Small sets use an array of pointers allocated in the
        /// SmallPtrSet object,</para>
        /// <para>/// which is treated as a simple array of pointers.  When a
        /// pointer is added to</para>
        /// <para>/// the set, the array is scanned to see if the element already
        /// exists, if not</para>
        /// <para>/// the element is 'pushed back' onto the array.  If we run out
        /// of space in the</para>
        /// <para>/// array, we grow into the 'large set' case.  SmallSet should be
        /// used when the</para>
        /// <para>/// sets are often small.  In this case, no memory allocation is
        /// used, and only</para>
        /// <para>/// light-weight and cache-efficient scanning is used.</para>
        /// <para>///</para>
        /// <para>/// Large sets use a classic exponentially-probed hash table.
        /// Empty buckets are</para>
        /// <para>/// represented with an illegal pointer value (-1) to allow null
        /// pointers to be</para>
        /// <para>/// inserted.  Tombstones are represented with another illegal
        /// pointer value</para>
        /// <para>/// (-2), to allow deletion.  The hash table is resized when the
        /// table is 3/4 or</para>
        /// <para>/// more.  When this happens, the table is doubled in
        /// size.</para>
        /// <para>///</para>
        /// </remarks>
        public unsafe partial class SmallPtrSetImplBase : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 20)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public void** SmallArray;

                [FieldOffset(4)]
                public void** CurArray;

                [FieldOffset(8)]
                public uint CurArraySize;

                [FieldOffset(12)]
                public uint NumElements;

                [FieldOffset(16)]
                public uint NumTombstones;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm19SmallPtrSetImplBaseC2EPPKvRKS0_")]
                internal static extern void ctor_0(global::System.IntPtr instance, void** SmallStorage, global::System.IntPtr that);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm19SmallPtrSetImplBaseC2EPPKvjOS0_")]
                internal static extern void ctor_1(global::System.IntPtr instance, void** SmallStorage, uint SmallSize, global::System.IntPtr that);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm19SmallPtrSetImplBaseC2EPPKvj")]
                internal static extern void ctor_2(global::System.IntPtr instance, void** SmallStorage, uint SmallSize);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm19SmallPtrSetImplBaseC2ERKS0_")]
                internal static extern void cctor_3(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm19SmallPtrSetImplBaseD2Ev")]
                internal static extern void dtor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm19SmallPtrSetImplBase5emptyEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool empty_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm19SmallPtrSetImplBase4sizeEv")]
                internal static extern uint size_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm19SmallPtrSetImplBase5clearEv")]
                internal static extern void clear_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm19SmallPtrSetImplBase18getTombstoneMarkerEv")]
                internal static extern global::System.IntPtr getTombstoneMarker_0();

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm19SmallPtrSetImplBase14getEmptyMarkerEv")]
                internal static extern global::System.IntPtr getEmptyMarker_0();

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm19SmallPtrSetImplBase9erase_impEPKv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool erase_imp_0(global::System.IntPtr instance, global::System.IntPtr Ptr);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm19SmallPtrSetImplBase9count_impEPKv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool count_imp_0(global::System.IntPtr instance, global::System.IntPtr Ptr);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm19SmallPtrSetImplBase4swapERS0_")]
                internal static extern void swap_0(global::System.IntPtr instance, global::System.IntPtr RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm19SmallPtrSetImplBase8CopyFromERKS0_")]
                internal static extern void CopyFrom_0(global::System.IntPtr instance, global::System.IntPtr RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm19SmallPtrSetImplBase8MoveFromEjOS0_")]
                internal static extern void MoveFrom_0(global::System.IntPtr instance, uint SmallSize, global::System.IntPtr RHS);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, SmallPtrSetImplBase> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, SmallPtrSetImplBase>();

            private readonly bool __ownsNativeInstance;

            public static SmallPtrSetImplBase __CreateInstance(global::System.IntPtr native)
            {
                return new SmallPtrSetImplBase((SmallPtrSetImplBase.Internal*) native);
            }

            public static SmallPtrSetImplBase __CreateInstance(SmallPtrSetImplBase.Internal native)
            {
                return new SmallPtrSetImplBase(native);
            }

            private static SmallPtrSetImplBase.Internal* __CopyValue(SmallPtrSetImplBase.Internal native)
            {
                var ret = (SmallPtrSetImplBase.Internal*) Marshal.AllocHGlobal(20);
                *ret = native;
                return ret;
            }

            private SmallPtrSetImplBase(SmallPtrSetImplBase.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected SmallPtrSetImplBase(SmallPtrSetImplBase.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            protected SmallPtrSetImplBase(void** SmallStorage, llvm.SmallPtrSetImplBase that)
            {
                __Instance = Marshal.AllocHGlobal(20);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = SmallStorage;
                var arg1 = ReferenceEquals(that, null) ? global::System.IntPtr.Zero : that.__Instance;
                Internal.ctor_0(__Instance, arg0, arg1);
            }

            protected SmallPtrSetImplBase(void** SmallStorage, uint SmallSize, llvm.SmallPtrSetImplBase that)
            {
                __Instance = Marshal.AllocHGlobal(20);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = SmallStorage;
                var arg2 = ReferenceEquals(that, null) ? global::System.IntPtr.Zero : that.__Instance;
                Internal.ctor_1(__Instance, arg0, SmallSize, arg2);
            }

            protected SmallPtrSetImplBase(void** SmallStorage, uint SmallSize)
            {
                __Instance = Marshal.AllocHGlobal(20);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = SmallStorage;
                Internal.ctor_2(__Instance, arg0, SmallSize);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                llvm.SmallPtrSetImplBase __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance || force)
                    Internal.dtor_0(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public bool empty()
            {
                var __ret = Internal.empty_0(__Instance);
                return __ret;
            }

            public uint size()
            {
                var __ret = Internal.size_0(__Instance);
                return __ret;
            }

            public void clear()
            {
                Internal.clear_0(__Instance);
            }

            /// <summary>
            /// <para>erase_imp - If the set contains the specified pointer, remove it
            /// and return true, otherwise return false. This is hidden from the client so
            /// that the derived class can check that the right type of pointer is passed
            /// in.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// erase_imp - If the set contains the specified pointer, remove
            /// it and</para>
            /// <para>  /// return true, otherwise return false.  This is hidden from
            /// the client so</para>
            /// <para>  /// that the derived class can check that the right type of
            /// pointer is passed</para>
            /// <para>  /// in.</para>
            /// </remarks>
            protected bool erase_imp(global::System.IntPtr Ptr)
            {
                var arg0 = Ptr;
                var __ret = Internal.erase_imp_0(__Instance, arg0);
                return __ret;
            }

            protected bool count_imp(global::System.IntPtr Ptr)
            {
                var arg0 = Ptr;
                var __ret = Internal.count_imp_0(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>swap - Swaps the elements of two sets. Note: This method assumes
            /// that both sets have the same small size.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// swap - Swaps the elements of two sets.</para>
            /// <para>  /// Note: This method assumes that both sets have the same
            /// small size.</para>
            /// </remarks>
            protected void swap(llvm.SmallPtrSetImplBase RHS)
            {
                var arg0 = ReferenceEquals(RHS, null) ? global::System.IntPtr.Zero : RHS.__Instance;
                Internal.swap_0(__Instance, arg0);
            }

            protected void CopyFrom(llvm.SmallPtrSetImplBase RHS)
            {
                var arg0 = ReferenceEquals(RHS, null) ? global::System.IntPtr.Zero : RHS.__Instance;
                Internal.CopyFrom_0(__Instance, arg0);
            }

            protected void MoveFrom(uint SmallSize, llvm.SmallPtrSetImplBase RHS)
            {
                var arg1 = ReferenceEquals(RHS, null) ? global::System.IntPtr.Zero : RHS.__Instance;
                Internal.MoveFrom_0(__Instance, SmallSize, arg1);
            }

            protected static global::System.IntPtr getTombstoneMarker()
            {
                var __ret = Internal.getTombstoneMarker_0();
                return __ret;
            }

            protected static global::System.IntPtr getEmptyMarker()
            {
                var __ret = Internal.getEmptyMarker_0();
                return __ret;
            }

            protected void** SmallArray
            {
                get
                {
                    return ((Internal*) __Instance)->SmallArray;
                }

                set
                {
                    ((Internal*) __Instance)->SmallArray = value;
                }
            }

            protected void** CurArray
            {
                get
                {
                    return ((Internal*) __Instance)->CurArray;
                }

                set
                {
                    ((Internal*) __Instance)->CurArray = value;
                }
            }

            protected uint CurArraySize
            {
                get
                {
                    return ((Internal*) __Instance)->CurArraySize;
                }

                set
                {
                    ((Internal*) __Instance)->CurArraySize = value;
                }
            }

            protected uint NumElements
            {
                get
                {
                    return ((Internal*) __Instance)->NumElements;
                }

                set
                {
                    ((Internal*) __Instance)->NumElements = value;
                }
            }

            protected uint NumTombstones
            {
                get
                {
                    return ((Internal*) __Instance)->NumTombstones;
                }

                set
                {
                    ((Internal*) __Instance)->NumTombstones = value;
                }
            }
        }

        /// <summary>
        /// <para>SmallPtrSetIteratorImpl - This is the common base class shared
        /// between all instances of SmallPtrSetIterator.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// SmallPtrSetIteratorImpl - This is the common base class
        /// shared between all</para>
        /// <para>/// instances of SmallPtrSetIterator.</para>
        /// </remarks>
        public unsafe partial class SmallPtrSetIteratorImpl : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 8)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public void** Bucket;

                [FieldOffset(4)]
                public void** End;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm23SmallPtrSetIteratorImplC2EPKPKvS4_")]
                internal static extern void ctor_0(global::System.IntPtr instance, void** BP, void** E);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm23SmallPtrSetIteratorImplC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm23SmallPtrSetIteratorImpleqERKS0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorEqualEqual_0(global::System.IntPtr instance, global::System.IntPtr RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm23SmallPtrSetIteratorImplneERKS0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorExclaimEqual_0(global::System.IntPtr instance, global::System.IntPtr RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm23SmallPtrSetIteratorImpl17AdvanceIfNotValidEv")]
                internal static extern void AdvanceIfNotValid_0(global::System.IntPtr instance);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, SmallPtrSetIteratorImpl> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, SmallPtrSetIteratorImpl>();

            private readonly bool __ownsNativeInstance;

            public static SmallPtrSetIteratorImpl __CreateInstance(global::System.IntPtr native)
            {
                return new SmallPtrSetIteratorImpl((SmallPtrSetIteratorImpl.Internal*) native);
            }

            public static SmallPtrSetIteratorImpl __CreateInstance(SmallPtrSetIteratorImpl.Internal native)
            {
                return new SmallPtrSetIteratorImpl(native);
            }

            private static SmallPtrSetIteratorImpl.Internal* __CopyValue(SmallPtrSetIteratorImpl.Internal native)
            {
                var ret = (SmallPtrSetIteratorImpl.Internal*) Marshal.AllocHGlobal(8);
                *ret = native;
                return ret;
            }

            private SmallPtrSetIteratorImpl(SmallPtrSetIteratorImpl.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected SmallPtrSetIteratorImpl(SmallPtrSetIteratorImpl.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public SmallPtrSetIteratorImpl(void** BP, void** E)
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = BP;
                var arg1 = E;
                Internal.ctor_0(__Instance, arg0, arg1);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                llvm.SmallPtrSetIteratorImpl __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public static bool operator ==(llvm.SmallPtrSetIteratorImpl __op, llvm.SmallPtrSetIteratorImpl RHS)
            {
                bool __opNull = ReferenceEquals(__op, null);
                bool RHSNull = ReferenceEquals(RHS, null);
                if (__opNull || RHSNull)
                    return __opNull && RHSNull;
                var arg0 = __op.__Instance;
                var arg1 = RHS.__Instance;
                var __ret = Internal.OperatorEqualEqual_0(arg0, arg1);
                return __ret;
            }

            public override bool Equals(object obj)
            {
                return this == obj as SmallPtrSetIteratorImpl;
            }

            public static bool operator !=(llvm.SmallPtrSetIteratorImpl __op, llvm.SmallPtrSetIteratorImpl RHS)
            {
                var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
                var arg1 = ReferenceEquals(RHS, null) ? global::System.IntPtr.Zero : RHS.__Instance;
                var __ret = Internal.OperatorExclaimEqual_0(arg0, arg1);
                return __ret;
            }

            /// <summary>
            /// <para>AdvanceIfNotValid - If the current bucket isn't valid, advance to
            /// a bucket that is. This is guaranteed to stop because the end() bucket is
            /// marked valid.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// AdvanceIfNotValid - If the current bucket isn't valid,
            /// advance to a bucket</para>
            /// <para>  /// that is.   This is guaranteed to stop because the end()
            /// bucket is marked</para>
            /// <para>  /// valid.</para>
            /// </remarks>
            protected void AdvanceIfNotValid()
            {
                Internal.AdvanceIfNotValid_0(__Instance);
            }

            protected void** Bucket
            {
                get
                {
                    return ((Internal*) __Instance)->Bucket;
                }

                set
                {
                    ((Internal*) __Instance)->Bucket = value;
                }
            }

            protected void** End
            {
                get
                {
                    return ((Internal*) __Instance)->End;
                }

                set
                {
                    ((Internal*) __Instance)->End = value;
                }
            }
        }
    }

    namespace std
    {
    }
}
