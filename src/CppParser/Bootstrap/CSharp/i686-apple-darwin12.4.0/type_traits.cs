//----------------------------------------------------------------------------
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
//----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace CppSharp
{
    namespace llvm
    {
        /// <summary>
        /// <para>isPodLike - This is a type trait that is used to determine
        /// whether a given type can be copied around with memcpy instead of running
        /// ctors etc.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// isPodLike - This is a type trait that is used to determine
        /// whether a given</para>
        /// <para>/// type can be copied around with memcpy instead of running
        /// ctors etc.</para>
        /// </remarks>
        public unsafe static partial class isPodLike
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct Internal
            {
            }
        }

        /// <summary>
        /// <para>Metafunction that determines whether the given type is either an
        /// integral type or an enumeration type.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief Metafunction that determines whether the given type is
        /// either an</para>
        /// <para>/// integral type or an enumeration type.</para>
        /// <para>///</para>
        /// <para>/// Note that this accepts potentially more integral types than
        /// is_integral</para>
        /// <para>/// because it is based on merely being convertible implicitly to
        /// an integral</para>
        /// <para>/// type.</para>
        /// </remarks>
        public unsafe static partial class is_integral_or_enum
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct Internal
            {
            }
        }

        /// <summary>
        /// <para>If T is a pointer, just return it. If it is not, return
        /// T&amp;.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief If T is a pointer, just return it. If it is not,
        /// return T&amp;.</para>
        /// </remarks>
        public unsafe static partial class add_lvalue_reference_if_not_pointer
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct Internal
            {
            }
        }

        /// <summary>
        /// <para>If T is a pointer to X, return a pointer to const X. If it is
        /// not, return const T.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief If T is a pointer to X, return a pointer to const X.
        /// If it is not,</para>
        /// <para>/// return const T.</para>
        /// </remarks>
        public unsafe static partial class add_const_past_pointer
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct Internal
            {
            }
        }
    }
}
