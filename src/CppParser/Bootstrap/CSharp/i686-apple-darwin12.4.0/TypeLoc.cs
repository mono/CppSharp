//----------------------------------------------------------------------------
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
//----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace CppSharp
{
    namespace clang
    {
        /// <summary>
        /// <para>A metaprogramming base class for TypeLoc classes which correspond
        /// to a particular Type subclass. It is accepted for a single TypeLoc class to
        /// correspond to multiple Type classes.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// A metaprogramming base class for TypeLoc classes which
        /// correspond</para>
        /// <para>/// to a particular Type subclass.  It is accepted for a
        /// single</para>
        /// <para>/// TypeLoc class to correspond to multiple Type classes.</para>
        /// <para>///</para>
        /// <para>/// \tparam Base a class from which to derive</para>
        /// <para>/// \tparam Derived the class deriving from this one</para>
        /// <para>/// \tparam TypeClass the concrete Type subclass associated with
        /// this</para>
        /// <para>///   location type</para>
        /// <para>/// \tparam LocalData the structure type of local location data
        /// for</para>
        /// <para>///   this type</para>
        /// <para>///</para>
        /// <para>/// TypeLocs with non-constant amounts of local data should
        /// override</para>
        /// <para>/// getExtraLocalDataSize(); getExtraLocalData() will then point
        /// to</para>
        /// <para>/// this extra memory.</para>
        /// <para>///</para>
        /// <para>/// TypeLocs with an inner type should define</para>
        /// <para>///   QualType getInnerType() const</para>
        /// <para>/// and getInnerTypeLoc() will then point to this inner
        /// type's</para>
        /// <para>/// location data.</para>
        /// <para>///</para>
        /// <para>/// A word about hierarchies: this template is not designed to
        /// be</para>
        /// <para>/// derived from multiple times in a hierarchy.  It is also
        /// not</para>
        /// <para>/// designed to be used for classes where subtypes might
        /// provide</para>
        /// <para>/// different amounts of source information.  It should be
        /// subclassed</para>
        /// <para>/// only at the deepest portion of the hierarchy where all
        /// children</para>
        /// <para>/// have identical source information; if that's an abstract
        /// type,</para>
        /// <para>/// then further descendents should inherit from</para>
        /// <para>/// InheritingConcreteTypeLoc instead.</para>
        /// </remarks>
        public unsafe partial class ConcreteTypeLoc
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct Internal
            {
            }

            protected internal unsafe partial class HasNoInnerType
            {
                [StructLayout(LayoutKind.Explicit, Size = 0)]
                public partial struct Internal
                {
                }
            }
        }

        /// <summary>
        /// <para>A metaprogramming class designed for concrete subtypes of
        /// abstract types where all subtypes share equivalently-structured source
        /// information. See the note on ConcreteTypeLoc.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// A metaprogramming class designed for concrete subtypes of
        /// abstract</para>
        /// <para>/// types where all subtypes share equivalently-structured
        /// source</para>
        /// <para>/// information.  See the note on ConcreteTypeLoc.</para>
        /// </remarks>
        public unsafe partial class InheritingConcreteTypeLoc
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct Internal
            {
            }
        }

        /// <summary>
        /// <para>A base class for</para>
        /// </summary>
        /// <remarks>
        /// <para>/// A base class for</para>
        /// </remarks>
        public unsafe partial class PointerLikeTypeLoc
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct Internal
            {
            }
        }

        public unsafe partial class TypeofLikeTypeLoc
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct Internal
            {
            }
        }

        /// <summary>
        /// <para>Base wrapper for a particular &quot;section&quot; of type source
        /// info.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief Base wrapper for a particular &quot;section&quot; of
        /// type source info.</para>
        /// <para>///</para>
        /// <para>/// A client should use the TypeLoc subclasses through
        /// castAs()/getAs()</para>
        /// <para>/// in order to get at the actual information.</para>
        /// </remarks>
        public unsafe partial class TypeLoc : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 8)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr Ty;

                [FieldOffset(4)]
                public global::System.IntPtr Data;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang7TypeLocC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang7TypeLocC2ENS_8QualTypeEPv")]
                internal static extern void ctor_1(global::System.IntPtr instance, clang.QualType.Internal ty, global::System.IntPtr opaqueData);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang7TypeLocC2EPKNS_4TypeEPv")]
                internal static extern void ctor_2(global::System.IntPtr instance, global::System.IntPtr ty, global::System.IntPtr opaqueData);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang7TypeLocC2ERKS0_")]
                internal static extern void cctor_3(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7TypeLoc15getTypeLocClassEv")]
                internal static extern clang.TypeLoc.TypeLocClass getTypeLocClass_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7TypeLoc6isNullEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isNull_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7TypeLoccvbEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorConversion_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang7TypeLoc22getFullDataSizeForTypeENS_8QualTypeE")]
                internal static extern uint getFullDataSizeForType_0(clang.QualType.Internal Ty);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang7TypeLoc24getLocalAlignmentForTypeENS_8QualTypeE")]
                internal static extern uint getLocalAlignmentForType_0(clang.QualType.Internal Ty);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7TypeLoc7getTypeEv")]
                internal static extern clang.QualType.Internal getType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7TypeLoc10getTypePtrEv")]
                internal static extern global::System.IntPtr getTypePtr_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7TypeLoc13getOpaqueDataEv")]
                internal static extern global::System.IntPtr getOpaqueData_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7TypeLoc11getBeginLocEv")]
                internal static extern clang.SourceLocation.Internal getBeginLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7TypeLoc9getEndLocEv")]
                internal static extern clang.SourceLocation.Internal getEndLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7TypeLoc14getSourceRangeEv")]
                internal static extern clang.SourceRange.Internal getSourceRange_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7TypeLoc11getLocStartEv")]
                internal static extern clang.SourceLocation.Internal getLocStart_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7TypeLoc9getLocEndEv")]
                internal static extern clang.SourceLocation.Internal getLocEnd_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7TypeLoc19getLocalSourceRangeEv")]
                internal static extern clang.SourceRange.Internal getLocalSourceRange_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7TypeLoc15getFullDataSizeEv")]
                internal static extern uint getFullDataSize_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7TypeLoc14getNextTypeLocEv")]
                internal static extern clang.TypeLoc.Internal getNextTypeLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7TypeLoc17getUnqualifiedLocEv")]
                internal static extern clang.UnqualTypeLoc.Internal getUnqualifiedLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7TypeLoc12IgnoreParensEv")]
                internal static extern clang.TypeLoc.Internal IgnoreParens_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7TypeLoc10initializeERNS_10ASTContextENS_14SourceLocationE")]
                internal static extern void initialize_0(global::System.IntPtr instance, global::System.IntPtr Context, clang.SourceLocation.Internal Loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7TypeLoc18initializeFullCopyES0_")]
                internal static extern void initializeFullCopy_0(global::System.IntPtr instance, clang.TypeLoc.Internal Other);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7TypeLoc18initializeFullCopyES0_j")]
                internal static extern void initializeFullCopy_1(global::System.IntPtr instance, clang.TypeLoc.Internal Other, uint Size);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clangeqERKNS_7TypeLocES2_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorEqualEqual_0(global::System.IntPtr LHS, global::System.IntPtr RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clangneERKNS_7TypeLocES2_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorExclaimEqual_0(global::System.IntPtr LHS, global::System.IntPtr RHS);
            }

            /// <summary>
            /// <para>The kinds of TypeLocs. Equivalent to the Type::TypeClass enum,
            /// except it also defines a Qualified enum that corresponds to the
            /// QualifiedLoc class.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// The kinds of TypeLocs.  Equivalent to the Type::TypeClass
            /// enum,</para>
            /// <para>  /// except it also defines a Qualified enum that corresponds to
            /// the</para>
            /// <para>  /// QualifiedLoc class.</para>
            /// </remarks>
            public enum TypeLocClass : uint
            {
                Builtin = 0,
                Complex = 1,
                Pointer = 2,
                BlockPointer = 3,
                LValueReference = 4,
                RValueReference = 5,
                MemberPointer = 6,
                ConstantArray = 7,
                IncompleteArray = 8,
                VariableArray = 9,
                DependentSizedArray = 10,
                DependentSizedExtVector = 11,
                Vector = 12,
                ExtVector = 13,
                FunctionProto = 14,
                FunctionNoProto = 15,
                UnresolvedUsing = 16,
                Paren = 17,
                Typedef = 18,
                Adjusted = 19,
                Decayed = 20,
                TypeOfExpr = 21,
                TypeOf = 22,
                Decltype = 23,
                UnaryTransform = 24,
                Record = 25,
                Enum = 26,
                Elaborated = 27,
                Attributed = 28,
                TemplateTypeParm = 29,
                SubstTemplateTypeParm = 30,
                SubstTemplateTypeParmPack = 31,
                TemplateSpecialization = 32,
                Auto = 33,
                InjectedClassName = 34,
                DependentName = 35,
                DependentTemplateSpecialization = 36,
                PackExpansion = 37,
                ObjCObject = 38,
                ObjCInterface = 39,
                ObjCObjectPointer = 40,
                Atomic = 41,
                Qualified = 42
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, TypeLoc> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, TypeLoc>();

            private readonly bool __ownsNativeInstance;

            public static TypeLoc __CreateInstance(global::System.IntPtr native)
            {
                return new TypeLoc((TypeLoc.Internal*) native);
            }

            public static TypeLoc __CreateInstance(TypeLoc.Internal native)
            {
                return new TypeLoc(native);
            }

            private static TypeLoc.Internal* __CopyValue(TypeLoc.Internal native)
            {
                var ret = (TypeLoc.Internal*) Marshal.AllocHGlobal(8);
                *ret = native;
                return ret;
            }

            private TypeLoc(TypeLoc.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected TypeLoc(TypeLoc.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public TypeLoc()
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public TypeLoc(clang.QualType ty, global::System.IntPtr opaqueData)
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(ty, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (ty.__Instance);
                var arg1 = opaqueData;
                Internal.ctor_1(__Instance, arg0, arg1);
            }

            public TypeLoc(clang.Type ty, global::System.IntPtr opaqueData)
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(ty, null) ? global::System.IntPtr.Zero : ty.__Instance;
                var arg1 = opaqueData;
                Internal.ctor_2(__Instance, arg0, arg1);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.TypeLoc __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.TypeLoc.TypeLocClass getTypeLocClass()
            {
                var __ret = Internal.getTypeLocClass_0(__Instance);
                return __ret;
            }

            public bool isNull()
            {
                var __ret = Internal.isNull_0(__Instance);
                return __ret;
            }

            public static implicit operator bool(clang.TypeLoc __op)
            {
                var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
                var __ret = Internal.OperatorConversion_0(arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Get the type for which this source info wrapper provides
            /// information.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Get the type for which this source info wrapper
            /// provides</para>
            /// <para>  /// information.</para>
            /// </remarks>
            public clang.QualType getType()
            {
                var __ret = Internal.getType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            public clang.Type getTypePtr()
            {
                var __ret = Internal.getTypePtr_0(__Instance);
                clang.Type __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Type.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Type) clang.Type.NativeToManagedMap[__ret];
                else __result0 = clang.Type.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Get the pointer where source information is stored.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Get the pointer where source information is
            /// stored.</para>
            /// </remarks>
            public global::System.IntPtr getOpaqueData()
            {
                var __ret = Internal.getOpaqueData_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Get the begin source location.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Get the begin source location.</para>
            /// </remarks>
            public clang.SourceLocation getBeginLoc()
            {
                var __ret = Internal.getBeginLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Get the end source location.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Get the end source location.</para>
            /// </remarks>
            public clang.SourceLocation getEndLoc()
            {
                var __ret = Internal.getEndLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Get the full source range.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Get the full source range.</para>
            /// </remarks>
            public clang.SourceRange getSourceRange()
            {
                var __ret = Internal.getSourceRange_0(__Instance);
                return clang.SourceRange.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLocStart()
            {
                var __ret = Internal.getLocStart_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLocEnd()
            {
                var __ret = Internal.getLocEnd_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Get the local source range.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Get the local source range.</para>
            /// </remarks>
            public clang.SourceRange getLocalSourceRange()
            {
                var __ret = Internal.getLocalSourceRange_0(__Instance);
                return clang.SourceRange.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Returns the size of the type source info data block.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Returns the size of the type source info data
            /// block.</para>
            /// </remarks>
            public uint getFullDataSize()
            {
                var __ret = Internal.getFullDataSize_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Get the next TypeLoc pointed by this TypeLoc, e.g for
            /// &quot;int*&quot; the TypeLoc is a PointerLoc and next TypeLoc is for
            /// &quot;int&quot;.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Get the next TypeLoc pointed by this TypeLoc, e.g for
            /// &quot;int*&quot; the</para>
            /// <para>  /// TypeLoc is a PointerLoc and next TypeLoc is for
            /// &quot;int&quot;.</para>
            /// </remarks>
            public clang.TypeLoc getNextTypeLoc()
            {
                var __ret = Internal.getNextTypeLoc_0(__Instance);
                return clang.TypeLoc.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Skips past any qualifiers, if this is qualified.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Skips past any qualifiers, if this is
            /// qualified.</para>
            /// </remarks>
            public clang.UnqualTypeLoc getUnqualifiedLoc()
            {
                var __ret = Internal.getUnqualifiedLoc_0(__Instance);
                return clang.UnqualTypeLoc.__CreateInstance(__ret);
            }

            public clang.TypeLoc IgnoreParens()
            {
                var __ret = Internal.IgnoreParens_0(__Instance);
                return clang.TypeLoc.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Initializes this to state that every location in this type is the
            /// given location.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Initializes this to state that every location in
            /// this</para>
            /// <para>  /// type is the given location.</para>
            /// <para>  ///</para>
            /// <para>  /// This method exists to provide a simple transition for code
            /// that</para>
            /// <para>  /// relies on location-less types.</para>
            /// </remarks>
            public void initialize(clang.ASTContext Context, clang.SourceLocation Loc)
            {
                var arg0 = ReferenceEquals(Context, null) ? global::System.IntPtr.Zero : Context.__Instance;
                var arg1 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                Internal.initialize_0(__Instance, arg0, arg1);
            }

            /// <summary>
            /// <para>Initializes this by copying its information from another TypeLoc
            /// of the same type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Initializes this by copying its information from
            /// another</para>
            /// <para>  /// TypeLoc of the same type.</para>
            /// </remarks>
            public void initializeFullCopy(clang.TypeLoc Other)
            {
                var arg0 = ReferenceEquals(Other, null) ? new clang.TypeLoc.Internal() : *(clang.TypeLoc.Internal*) (Other.__Instance);
                Internal.initializeFullCopy_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>Initializes this by copying its information from another TypeLoc
            /// of the same type. The given size must be the full data size.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Initializes this by copying its information from
            /// another</para>
            /// <para>  /// TypeLoc of the same type.  The given size must be the full
            /// data</para>
            /// <para>  /// size.</para>
            /// </remarks>
            public void initializeFullCopy(clang.TypeLoc Other, uint Size)
            {
                var arg0 = ReferenceEquals(Other, null) ? new clang.TypeLoc.Internal() : *(clang.TypeLoc.Internal*) (Other.__Instance);
                Internal.initializeFullCopy_1(__Instance, arg0, Size);
            }

            /// <summary>
            /// <para>Returns the size of type source info data block for the given
            /// type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Returns the size of type source info data block for
            /// the given type.</para>
            /// </remarks>
            public static uint getFullDataSizeForType(clang.QualType Ty)
            {
                var arg0 = ReferenceEquals(Ty, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (Ty.__Instance);
                var __ret = Internal.getFullDataSizeForType_0(arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Returns the alignment of type source info data block for the
            /// given type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Returns the alignment of type source info data block
            /// for</para>
            /// <para>  /// the given type.</para>
            /// </remarks>
            public static uint getLocalAlignmentForType(clang.QualType Ty)
            {
                var arg0 = ReferenceEquals(Ty, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (Ty.__Instance);
                var __ret = Internal.getLocalAlignmentForType_0(arg0);
                return __ret;
            }

            public static bool operator ==(clang.TypeLoc LHS, clang.TypeLoc RHS)
            {
                bool LHSNull = ReferenceEquals(LHS, null);
                bool RHSNull = ReferenceEquals(RHS, null);
                if (LHSNull || RHSNull)
                    return LHSNull && RHSNull;
                var arg0 = LHS.__Instance;
                var arg1 = RHS.__Instance;
                var __ret = Internal.OperatorEqualEqual_0(arg0, arg1);
                return __ret;
            }

            public override bool Equals(object obj)
            {
                return this == obj as TypeLoc;
            }

            public static bool operator !=(clang.TypeLoc LHS, clang.TypeLoc RHS)
            {
                var arg0 = ReferenceEquals(LHS, null) ? global::System.IntPtr.Zero : LHS.__Instance;
                var arg1 = ReferenceEquals(RHS, null) ? global::System.IntPtr.Zero : RHS.__Instance;
                var __ret = Internal.OperatorExclaimEqual_0(arg0, arg1);
                return __ret;
            }

            protected global::System.IntPtr Ty
            {
                get
                {
                    return ((Internal*) __Instance)->Ty;
                }

                set
                {
                    ((Internal*) __Instance)->Ty = value;
                }
            }

            protected global::System.IntPtr Data
            {
                get
                {
                    return ((Internal*) __Instance)->Data;
                }

                set
                {
                    ((Internal*) __Instance)->Data = value;
                }
            }
        }

        /// <summary>
        /// <para>Wrapper of type source information for a type with no direct
        /// qualifiers.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief Wrapper of type source information for a type
        /// with</para>
        /// <para>/// no direct qualifiers.</para>
        /// </remarks>
        public unsafe partial class UnqualTypeLoc : clang.TypeLoc, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 8)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr Ty;

                [FieldOffset(4)]
                public global::System.IntPtr Data;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13UnqualTypeLocC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13UnqualTypeLocC2EPKNS_4TypeEPv")]
                internal static extern void ctor_1(global::System.IntPtr instance, global::System.IntPtr Ty, global::System.IntPtr Data);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13UnqualTypeLocC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13UnqualTypeLoc10getTypePtrEv")]
                internal static extern global::System.IntPtr getTypePtr_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13UnqualTypeLoc15getTypeLocClassEv")]
                internal static extern clang.TypeLoc.TypeLocClass getTypeLocClass_0(global::System.IntPtr instance);
            }

            private readonly bool __ownsNativeInstance;

            public static new UnqualTypeLoc __CreateInstance(global::System.IntPtr native)
            {
                return new UnqualTypeLoc((UnqualTypeLoc.Internal*) native);
            }

            public static UnqualTypeLoc __CreateInstance(UnqualTypeLoc.Internal native)
            {
                return new UnqualTypeLoc(native);
            }

            private static UnqualTypeLoc.Internal* __CopyValue(UnqualTypeLoc.Internal native)
            {
                var ret = (UnqualTypeLoc.Internal*) Marshal.AllocHGlobal(8);
                *ret = native;
                return ret;
            }

            private UnqualTypeLoc(UnqualTypeLoc.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected UnqualTypeLoc(UnqualTypeLoc.Internal* native, bool isInternalImpl = false)
                : base((clang.TypeLoc.Internal*) native)
            {
            }

            public UnqualTypeLoc()
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public UnqualTypeLoc(clang.Type Ty, global::System.IntPtr Data)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(Ty, null) ? global::System.IntPtr.Zero : Ty.__Instance;
                var arg1 = Data;
                Internal.ctor_1(__Instance, arg0, arg1);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.TypeLoc __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.Type getTypePtr()
            {
                var __ret = Internal.getTypePtr_0(__Instance);
                clang.Type __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Type.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Type) clang.Type.NativeToManagedMap[__ret];
                else __result0 = clang.Type.__CreateInstance(__ret);
                return __result0;
            }

            public clang.TypeLoc.TypeLocClass getTypeLocClass()
            {
                var __ret = Internal.getTypeLocClass_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Wrapper of type source information for a type with non-trivial
        /// direct qualifiers.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief Wrapper of type source information for a type
        /// with</para>
        /// <para>/// non-trivial direct qualifiers.</para>
        /// <para>///</para>
        /// <para>/// Currently, we intentionally do not provide source location
        /// for</para>
        /// <para>/// type qualifiers.</para>
        /// </remarks>
        public unsafe partial class QualifiedTypeLoc : clang.TypeLoc, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 8)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr Ty;

                [FieldOffset(4)]
                public global::System.IntPtr Data;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16QualifiedTypeLocC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16QualifiedTypeLocC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang16QualifiedTypeLoc19getLocalSourceRangeEv")]
                internal static extern clang.SourceRange.Internal getLocalSourceRange_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang16QualifiedTypeLoc17getUnqualifiedLocEv")]
                internal static extern clang.UnqualTypeLoc.Internal getUnqualifiedLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16QualifiedTypeLoc15initializeLocalERNS_10ASTContextENS_14SourceLocationE")]
                internal static extern void initializeLocal_0(global::System.IntPtr instance, global::System.IntPtr Context, clang.SourceLocation.Internal Loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang16QualifiedTypeLoc14getNextTypeLocEv")]
                internal static extern clang.TypeLoc.Internal getNextTypeLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang16QualifiedTypeLoc16getLocalDataSizeEv")]
                internal static extern uint getLocalDataSize_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang16QualifiedTypeLoc21getLocalDataAlignmentEv")]
                internal static extern uint getLocalDataAlignment_0(global::System.IntPtr instance);
            }

            private readonly bool __ownsNativeInstance;

            public static new QualifiedTypeLoc __CreateInstance(global::System.IntPtr native)
            {
                return new QualifiedTypeLoc((QualifiedTypeLoc.Internal*) native);
            }

            public static QualifiedTypeLoc __CreateInstance(QualifiedTypeLoc.Internal native)
            {
                return new QualifiedTypeLoc(native);
            }

            private static QualifiedTypeLoc.Internal* __CopyValue(QualifiedTypeLoc.Internal native)
            {
                var ret = (QualifiedTypeLoc.Internal*) Marshal.AllocHGlobal(8);
                *ret = native;
                return ret;
            }

            private QualifiedTypeLoc(QualifiedTypeLoc.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected QualifiedTypeLoc(QualifiedTypeLoc.Internal* native, bool isInternalImpl = false)
                : base((clang.TypeLoc.Internal*) native)
            {
            }

            public QualifiedTypeLoc()
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.TypeLoc __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.SourceRange getLocalSourceRange()
            {
                var __ret = Internal.getLocalSourceRange_0(__Instance);
                return clang.SourceRange.__CreateInstance(__ret);
            }

            public clang.UnqualTypeLoc getUnqualifiedLoc()
            {
                var __ret = Internal.getUnqualifiedLoc_0(__Instance);
                return clang.UnqualTypeLoc.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Initializes the local data of this type source info block to
            /// provide no information.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Initializes the local data of this type source info block
            /// to</para>
            /// <para>  /// provide no information.</para>
            /// </remarks>
            public void initializeLocal(clang.ASTContext Context, clang.SourceLocation Loc)
            {
                var arg0 = ReferenceEquals(Context, null) ? global::System.IntPtr.Zero : Context.__Instance;
                var arg1 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                Internal.initializeLocal_0(__Instance, arg0, arg1);
            }

            public clang.TypeLoc getNextTypeLoc()
            {
                var __ret = Internal.getNextTypeLoc_0(__Instance);
                return clang.TypeLoc.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Returns the size of the type source info data block that is
            /// specific to this type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Returns the size of the type source info data block
            /// that is</para>
            /// <para>  /// specific to this type.</para>
            /// </remarks>
            public uint getLocalDataSize()
            {
                var __ret = Internal.getLocalDataSize_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Returns the alignment of the type source info data block that is
            /// specific to this type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Returns the alignment of the type source info data
            /// block that is</para>
            /// <para>  /// specific to this type.</para>
            /// </remarks>
            public uint getLocalDataAlignment()
            {
                var __ret = Internal.getLocalDataAlignment_0(__Instance);
                return __ret;
            }
        }

        public unsafe partial class TypeSpecLocInfo : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 4)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public clang.SourceLocation.Internal NameLoc;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang15TypeSpecLocInfoC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang15TypeSpecLocInfoC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, TypeSpecLocInfo> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, TypeSpecLocInfo>();

            private readonly bool __ownsNativeInstance;

            public static TypeSpecLocInfo __CreateInstance(global::System.IntPtr native)
            {
                return new TypeSpecLocInfo((TypeSpecLocInfo.Internal*) native);
            }

            public static TypeSpecLocInfo __CreateInstance(TypeSpecLocInfo.Internal native)
            {
                return new TypeSpecLocInfo(native);
            }

            private static TypeSpecLocInfo.Internal* __CopyValue(TypeSpecLocInfo.Internal native)
            {
                var ret = (TypeSpecLocInfo.Internal*) Marshal.AllocHGlobal(4);
                *ret = native;
                return ret;
            }

            private TypeSpecLocInfo(TypeSpecLocInfo.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected TypeSpecLocInfo(TypeSpecLocInfo.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public TypeSpecLocInfo()
            {
                __Instance = Marshal.AllocHGlobal(4);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.TypeSpecLocInfo __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.SourceLocation NameLoc
            {
                get
                {
                    return clang.SourceLocation.__CreateInstance(((Internal*) __Instance)->NameLoc);
                }

                set
                {
                    ((Internal*) __Instance)->NameLoc = ReferenceEquals(value, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (value.__Instance);
                }
            }
        }

        /// <summary>
        /// <para>A reasonable base class for TypeLocs that correspond to types
        /// that are written as a type-specifier.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief A reasonable base class for TypeLocs that correspond
        /// to</para>
        /// <para>/// types that are written as a type-specifier.</para>
        /// </remarks>
        public unsafe partial class TypeSpecTypeLoc : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang15TypeSpecTypeLocC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang15TypeSpecTypeLocC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang15TypeSpecTypeLoc10getNameLocEv")]
                internal static extern clang.SourceLocation.Internal getNameLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang15TypeSpecTypeLoc10setNameLocENS_14SourceLocationE")]
                internal static extern void setNameLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal Loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang15TypeSpecTypeLoc19getLocalSourceRangeEv")]
                internal static extern clang.SourceRange.Internal getLocalSourceRange_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang15TypeSpecTypeLoc15initializeLocalERNS_10ASTContextENS_14SourceLocationE")]
                internal static extern void initializeLocal_0(global::System.IntPtr instance, global::System.IntPtr Context, clang.SourceLocation.Internal Loc);
            }

            [Flags]
            public enum LocalData : uint
            {
                LocalDataSize = 4,
                LocalDataAlignment = 4
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, TypeSpecTypeLoc> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, TypeSpecTypeLoc>();

            private readonly bool __ownsNativeInstance;

            public static TypeSpecTypeLoc __CreateInstance(global::System.IntPtr native)
            {
                return new TypeSpecTypeLoc((TypeSpecTypeLoc.Internal*) native);
            }

            public static TypeSpecTypeLoc __CreateInstance(TypeSpecTypeLoc.Internal native)
            {
                return new TypeSpecTypeLoc(native);
            }

            private static TypeSpecTypeLoc.Internal* __CopyValue(TypeSpecTypeLoc.Internal native)
            {
                var ret = (TypeSpecTypeLoc.Internal*) Marshal.AllocHGlobal(0);
                *ret = native;
                return ret;
            }

            private TypeSpecTypeLoc(TypeSpecTypeLoc.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected TypeSpecTypeLoc(TypeSpecTypeLoc.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public TypeSpecTypeLoc()
            {
                __Instance = Marshal.AllocHGlobal(0);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.TypeSpecTypeLoc __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.SourceLocation getNameLoc()
            {
                var __ret = Internal.getNameLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setNameLoc(clang.SourceLocation Loc)
            {
                var arg0 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                Internal.setNameLoc_0(__Instance, arg0);
            }

            public clang.SourceRange getLocalSourceRange()
            {
                var __ret = Internal.getLocalSourceRange_0(__Instance);
                return clang.SourceRange.__CreateInstance(__ret);
            }

            public void initializeLocal(clang.ASTContext Context, clang.SourceLocation Loc)
            {
                var arg0 = ReferenceEquals(Context, null) ? global::System.IntPtr.Zero : Context.__Instance;
                var arg1 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                Internal.initializeLocal_0(__Instance, arg0, arg1);
            }
        }

        public unsafe partial class BuiltinLocInfo : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 4)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public clang.SourceLocation.Internal BuiltinLoc;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14BuiltinLocInfoC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14BuiltinLocInfoC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, BuiltinLocInfo> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, BuiltinLocInfo>();

            private readonly bool __ownsNativeInstance;

            public static BuiltinLocInfo __CreateInstance(global::System.IntPtr native)
            {
                return new BuiltinLocInfo((BuiltinLocInfo.Internal*) native);
            }

            public static BuiltinLocInfo __CreateInstance(BuiltinLocInfo.Internal native)
            {
                return new BuiltinLocInfo(native);
            }

            private static BuiltinLocInfo.Internal* __CopyValue(BuiltinLocInfo.Internal native)
            {
                var ret = (BuiltinLocInfo.Internal*) Marshal.AllocHGlobal(4);
                *ret = native;
                return ret;
            }

            private BuiltinLocInfo(BuiltinLocInfo.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected BuiltinLocInfo(BuiltinLocInfo.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public BuiltinLocInfo()
            {
                __Instance = Marshal.AllocHGlobal(4);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.BuiltinLocInfo __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.SourceLocation BuiltinLoc
            {
                get
                {
                    return clang.SourceLocation.__CreateInstance(((Internal*) __Instance)->BuiltinLoc);
                }

                set
                {
                    ((Internal*) __Instance)->BuiltinLoc = ReferenceEquals(value, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (value.__Instance);
                }
            }
        }

        /// <summary>
        /// <para>Wrapper for source info for builtin types.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief Wrapper for source info for builtin types.</para>
        /// </remarks>
        public unsafe partial class BuiltinTypeLoc : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14BuiltinTypeLocC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14BuiltinTypeLocC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14BuiltinTypeLoc13getBuiltinLocEv")]
                internal static extern clang.SourceLocation.Internal getBuiltinLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14BuiltinTypeLoc13setBuiltinLocENS_14SourceLocationE")]
                internal static extern void setBuiltinLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal Loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14BuiltinTypeLoc10getNameLocEv")]
                internal static extern clang.SourceLocation.Internal getNameLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14BuiltinTypeLoc22getWrittenBuiltinSpecsEv")]
                internal static extern global::System.IntPtr getWrittenBuiltinSpecs_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14BuiltinTypeLoc19needsExtraLocalDataEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool needsExtraLocalData_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14BuiltinTypeLoc21getExtraLocalDataSizeEv")]
                internal static extern uint getExtraLocalDataSize_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14BuiltinTypeLoc26getExtraLocalDataAlignmentEv")]
                internal static extern uint getExtraLocalDataAlignment_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14BuiltinTypeLoc19getLocalSourceRangeEv")]
                internal static extern clang.SourceRange.Internal getLocalSourceRange_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14BuiltinTypeLoc18getWrittenSignSpecEv")]
                internal static extern clang.TypeSpecifierSign getWrittenSignSpec_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14BuiltinTypeLoc18hasWrittenSignSpecEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasWrittenSignSpec_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14BuiltinTypeLoc18setWrittenSignSpecENS_17TypeSpecifierSignE")]
                internal static extern void setWrittenSignSpec_0(global::System.IntPtr instance, clang.TypeSpecifierSign written);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14BuiltinTypeLoc19getWrittenWidthSpecEv")]
                internal static extern clang.TypeSpecifierWidth getWrittenWidthSpec_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14BuiltinTypeLoc19hasWrittenWidthSpecEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasWrittenWidthSpec_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14BuiltinTypeLoc19setWrittenWidthSpecENS_18TypeSpecifierWidthE")]
                internal static extern void setWrittenWidthSpec_0(global::System.IntPtr instance, clang.TypeSpecifierWidth written);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14BuiltinTypeLoc18getWrittenTypeSpecEv")]
                internal static extern clang.TypeSpecifierType getWrittenTypeSpec_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14BuiltinTypeLoc18hasWrittenTypeSpecEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasWrittenTypeSpec_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14BuiltinTypeLoc18setWrittenTypeSpecENS_17TypeSpecifierTypeE")]
                internal static extern void setWrittenTypeSpec_0(global::System.IntPtr instance, clang.TypeSpecifierType written);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14BuiltinTypeLoc11hasModeAttrEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasModeAttr_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14BuiltinTypeLoc11setModeAttrEb")]
                internal static extern void setModeAttr_0(global::System.IntPtr instance, bool written);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14BuiltinTypeLoc15initializeLocalERNS_10ASTContextENS_14SourceLocationE")]
                internal static extern void initializeLocal_0(global::System.IntPtr instance, global::System.IntPtr Context, clang.SourceLocation.Internal Loc);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, BuiltinTypeLoc> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, BuiltinTypeLoc>();

            private readonly bool __ownsNativeInstance;

            public static BuiltinTypeLoc __CreateInstance(global::System.IntPtr native)
            {
                return new BuiltinTypeLoc((BuiltinTypeLoc.Internal*) native);
            }

            public static BuiltinTypeLoc __CreateInstance(BuiltinTypeLoc.Internal native)
            {
                return new BuiltinTypeLoc(native);
            }

            private static BuiltinTypeLoc.Internal* __CopyValue(BuiltinTypeLoc.Internal native)
            {
                var ret = (BuiltinTypeLoc.Internal*) Marshal.AllocHGlobal(0);
                *ret = native;
                return ret;
            }

            private BuiltinTypeLoc(BuiltinTypeLoc.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected BuiltinTypeLoc(BuiltinTypeLoc.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public BuiltinTypeLoc()
            {
                __Instance = Marshal.AllocHGlobal(0);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.BuiltinTypeLoc __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.SourceLocation getBuiltinLoc()
            {
                var __ret = Internal.getBuiltinLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setBuiltinLoc(clang.SourceLocation Loc)
            {
                var arg0 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                Internal.setBuiltinLoc_0(__Instance, arg0);
            }

            public clang.SourceLocation getNameLoc()
            {
                var __ret = Internal.getNameLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.WrittenBuiltinSpecs getWrittenBuiltinSpecs()
            {
                var __ret = Internal.getWrittenBuiltinSpecs_0(__Instance);
                clang.WrittenBuiltinSpecs __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.WrittenBuiltinSpecs.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.WrittenBuiltinSpecs) clang.WrittenBuiltinSpecs.NativeToManagedMap[__ret];
                else __result0 = clang.WrittenBuiltinSpecs.__CreateInstance(__ret);
                return __result0;
            }

            public bool needsExtraLocalData()
            {
                var __ret = Internal.needsExtraLocalData_0(__Instance);
                return __ret;
            }

            public uint getExtraLocalDataSize()
            {
                var __ret = Internal.getExtraLocalDataSize_0(__Instance);
                return __ret;
            }

            public uint getExtraLocalDataAlignment()
            {
                var __ret = Internal.getExtraLocalDataAlignment_0(__Instance);
                return __ret;
            }

            public clang.SourceRange getLocalSourceRange()
            {
                var __ret = Internal.getLocalSourceRange_0(__Instance);
                return clang.SourceRange.__CreateInstance(__ret);
            }

            public clang.TypeSpecifierSign getWrittenSignSpec()
            {
                var __ret = Internal.getWrittenSignSpec_0(__Instance);
                return __ret;
            }

            public bool hasWrittenSignSpec()
            {
                var __ret = Internal.hasWrittenSignSpec_0(__Instance);
                return __ret;
            }

            public void setWrittenSignSpec(clang.TypeSpecifierSign written)
            {
                var arg0 = written;
                Internal.setWrittenSignSpec_0(__Instance, arg0);
            }

            public clang.TypeSpecifierWidth getWrittenWidthSpec()
            {
                var __ret = Internal.getWrittenWidthSpec_0(__Instance);
                return __ret;
            }

            public bool hasWrittenWidthSpec()
            {
                var __ret = Internal.hasWrittenWidthSpec_0(__Instance);
                return __ret;
            }

            public void setWrittenWidthSpec(clang.TypeSpecifierWidth written)
            {
                var arg0 = written;
                Internal.setWrittenWidthSpec_0(__Instance, arg0);
            }

            public clang.TypeSpecifierType getWrittenTypeSpec()
            {
                var __ret = Internal.getWrittenTypeSpec_0(__Instance);
                return __ret;
            }

            public bool hasWrittenTypeSpec()
            {
                var __ret = Internal.hasWrittenTypeSpec_0(__Instance);
                return __ret;
            }

            public void setWrittenTypeSpec(clang.TypeSpecifierType written)
            {
                var arg0 = written;
                Internal.setWrittenTypeSpec_0(__Instance, arg0);
            }

            public bool hasModeAttr()
            {
                var __ret = Internal.hasModeAttr_0(__Instance);
                return __ret;
            }

            public void setModeAttr(bool written)
            {
                Internal.setModeAttr_0(__Instance, written);
            }

            public void initializeLocal(clang.ASTContext Context, clang.SourceLocation Loc)
            {
                var arg0 = ReferenceEquals(Context, null) ? global::System.IntPtr.Zero : Context.__Instance;
                var arg1 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                Internal.initializeLocal_0(__Instance, arg0, arg1);
            }
        }

        /// <summary>
        /// <para>Wrapper for source info for typedefs.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief Wrapper for source info for typedefs.</para>
        /// </remarks>
        public unsafe partial class TypedefTypeLoc : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14TypedefTypeLocC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14TypedefTypeLocC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14TypedefTypeLoc18getTypedefNameDeclEv")]
                internal static extern global::System.IntPtr getTypedefNameDecl_0(global::System.IntPtr instance);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, TypedefTypeLoc> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, TypedefTypeLoc>();

            private readonly bool __ownsNativeInstance;

            public static TypedefTypeLoc __CreateInstance(global::System.IntPtr native)
            {
                return new TypedefTypeLoc((TypedefTypeLoc.Internal*) native);
            }

            public static TypedefTypeLoc __CreateInstance(TypedefTypeLoc.Internal native)
            {
                return new TypedefTypeLoc(native);
            }

            private static TypedefTypeLoc.Internal* __CopyValue(TypedefTypeLoc.Internal native)
            {
                var ret = (TypedefTypeLoc.Internal*) Marshal.AllocHGlobal(0);
                *ret = native;
                return ret;
            }

            private TypedefTypeLoc(TypedefTypeLoc.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected TypedefTypeLoc(TypedefTypeLoc.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public TypedefTypeLoc()
            {
                __Instance = Marshal.AllocHGlobal(0);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.TypedefTypeLoc __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.TypedefNameDecl getTypedefNameDecl()
            {
                var __ret = Internal.getTypedefNameDecl_0(__Instance);
                clang.TypedefNameDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.TypedefNameDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.TypedefNameDecl) clang.TypedefNameDecl.NativeToManagedMap[__ret];
                else clang.TypedefNameDecl.NativeToManagedMap[__ret] = __result0 = (clang.TypedefNameDecl) clang.TypedefNameDecl.__CreateInstance(__ret);
                return __result0;
            }
        }

        /// <summary>
        /// <para>Wrapper for source info for injected class names of class
        /// templates.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief Wrapper for source info for injected class names of
        /// class</para>
        /// <para>/// templates.</para>
        /// </remarks>
        public unsafe partial class InjectedClassNameTypeLoc : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang24InjectedClassNameTypeLocC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang24InjectedClassNameTypeLocC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, InjectedClassNameTypeLoc> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, InjectedClassNameTypeLoc>();

            private readonly bool __ownsNativeInstance;

            public static InjectedClassNameTypeLoc __CreateInstance(global::System.IntPtr native)
            {
                return new InjectedClassNameTypeLoc((InjectedClassNameTypeLoc.Internal*) native);
            }

            public static InjectedClassNameTypeLoc __CreateInstance(InjectedClassNameTypeLoc.Internal native)
            {
                return new InjectedClassNameTypeLoc(native);
            }

            private static InjectedClassNameTypeLoc.Internal* __CopyValue(InjectedClassNameTypeLoc.Internal native)
            {
                var ret = (InjectedClassNameTypeLoc.Internal*) Marshal.AllocHGlobal(0);
                *ret = native;
                return ret;
            }

            private InjectedClassNameTypeLoc(InjectedClassNameTypeLoc.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected InjectedClassNameTypeLoc(InjectedClassNameTypeLoc.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public InjectedClassNameTypeLoc()
            {
                __Instance = Marshal.AllocHGlobal(0);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.InjectedClassNameTypeLoc __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Wrapper for source info for unresolved typename using
        /// decls.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief Wrapper for source info for unresolved typename using
        /// decls.</para>
        /// </remarks>
        public unsafe partial class UnresolvedUsingTypeLoc : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang22UnresolvedUsingTypeLocC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang22UnresolvedUsingTypeLocC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, UnresolvedUsingTypeLoc> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, UnresolvedUsingTypeLoc>();

            private readonly bool __ownsNativeInstance;

            public static UnresolvedUsingTypeLoc __CreateInstance(global::System.IntPtr native)
            {
                return new UnresolvedUsingTypeLoc((UnresolvedUsingTypeLoc.Internal*) native);
            }

            public static UnresolvedUsingTypeLoc __CreateInstance(UnresolvedUsingTypeLoc.Internal native)
            {
                return new UnresolvedUsingTypeLoc(native);
            }

            private static UnresolvedUsingTypeLoc.Internal* __CopyValue(UnresolvedUsingTypeLoc.Internal native)
            {
                var ret = (UnresolvedUsingTypeLoc.Internal*) Marshal.AllocHGlobal(0);
                *ret = native;
                return ret;
            }

            private UnresolvedUsingTypeLoc(UnresolvedUsingTypeLoc.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected UnresolvedUsingTypeLoc(UnresolvedUsingTypeLoc.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public UnresolvedUsingTypeLoc()
            {
                __Instance = Marshal.AllocHGlobal(0);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.UnresolvedUsingTypeLoc __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Wrapper for source info for tag types. Note that this only
        /// records source info for the name itself; a type written 'struct foo' should
        /// be represented as an ElaboratedTypeLoc. We currently only do that when C++
        /// is enabled because of the expense of creating an ElaboratedType node for so
        /// many type references in C.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief Wrapper for source info for tag types.  Note that this
        /// only</para>
        /// <para>/// records source info for the name itself; a type written
        /// 'struct foo'</para>
        /// <para>/// should be represented as an ElaboratedTypeLoc.  We
        /// currently</para>
        /// <para>/// only do that when C++ is enabled because of the expense
        /// of</para>
        /// <para>/// creating an ElaboratedType node for so many type references
        /// in C.</para>
        /// </remarks>
        public unsafe partial class TagTypeLoc : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10TagTypeLocC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10TagTypeLocC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10TagTypeLoc7getDeclEv")]
                internal static extern global::System.IntPtr getDecl_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10TagTypeLoc12isDefinitionEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isDefinition_0(global::System.IntPtr instance);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, TagTypeLoc> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, TagTypeLoc>();

            private readonly bool __ownsNativeInstance;

            public static TagTypeLoc __CreateInstance(global::System.IntPtr native)
            {
                return new TagTypeLoc((TagTypeLoc.Internal*) native);
            }

            public static TagTypeLoc __CreateInstance(TagTypeLoc.Internal native)
            {
                return new TagTypeLoc(native);
            }

            private static TagTypeLoc.Internal* __CopyValue(TagTypeLoc.Internal native)
            {
                var ret = (TagTypeLoc.Internal*) Marshal.AllocHGlobal(0);
                *ret = native;
                return ret;
            }

            private TagTypeLoc(TagTypeLoc.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected TagTypeLoc(TagTypeLoc.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public TagTypeLoc()
            {
                __Instance = Marshal.AllocHGlobal(0);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.TagTypeLoc __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.TagDecl getDecl()
            {
                var __ret = Internal.getDecl_0(__Instance);
                clang.TagDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.TagDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.TagDecl) clang.TagDecl.NativeToManagedMap[__ret];
                else clang.TagDecl.NativeToManagedMap[__ret] = __result0 = (clang.TagDecl) clang.TagDecl.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>True if the tag was defined in this type specifier.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief True if the tag was defined in this type
            /// specifier.</para>
            /// </remarks>
            public bool isDefinition()
            {
                var __ret = Internal.isDefinition_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Wrapper for source info for record types.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief Wrapper for source info for record types.</para>
        /// </remarks>
        public unsafe partial class RecordTypeLoc : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13RecordTypeLocC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13RecordTypeLocC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13RecordTypeLoc7getDeclEv")]
                internal static extern global::System.IntPtr getDecl_0(global::System.IntPtr instance);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, RecordTypeLoc> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, RecordTypeLoc>();

            private readonly bool __ownsNativeInstance;

            public static RecordTypeLoc __CreateInstance(global::System.IntPtr native)
            {
                return new RecordTypeLoc((RecordTypeLoc.Internal*) native);
            }

            public static RecordTypeLoc __CreateInstance(RecordTypeLoc.Internal native)
            {
                return new RecordTypeLoc(native);
            }

            private static RecordTypeLoc.Internal* __CopyValue(RecordTypeLoc.Internal native)
            {
                var ret = (RecordTypeLoc.Internal*) Marshal.AllocHGlobal(0);
                *ret = native;
                return ret;
            }

            private RecordTypeLoc(RecordTypeLoc.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected RecordTypeLoc(RecordTypeLoc.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public RecordTypeLoc()
            {
                __Instance = Marshal.AllocHGlobal(0);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.RecordTypeLoc __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.RecordDecl getDecl()
            {
                var __ret = Internal.getDecl_0(__Instance);
                clang.RecordDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.RecordDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.RecordDecl) clang.RecordDecl.NativeToManagedMap[__ret];
                else clang.RecordDecl.NativeToManagedMap[__ret] = __result0 = (clang.RecordDecl) clang.RecordDecl.__CreateInstance(__ret);
                return __result0;
            }
        }

        /// <summary>
        /// <para>Wrapper for source info for enum types.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief Wrapper for source info for enum types.</para>
        /// </remarks>
        public unsafe partial class EnumTypeLoc : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11EnumTypeLocC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11EnumTypeLocC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11EnumTypeLoc7getDeclEv")]
                internal static extern global::System.IntPtr getDecl_0(global::System.IntPtr instance);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, EnumTypeLoc> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, EnumTypeLoc>();

            private readonly bool __ownsNativeInstance;

            public static EnumTypeLoc __CreateInstance(global::System.IntPtr native)
            {
                return new EnumTypeLoc((EnumTypeLoc.Internal*) native);
            }

            public static EnumTypeLoc __CreateInstance(EnumTypeLoc.Internal native)
            {
                return new EnumTypeLoc(native);
            }

            private static EnumTypeLoc.Internal* __CopyValue(EnumTypeLoc.Internal native)
            {
                var ret = (EnumTypeLoc.Internal*) Marshal.AllocHGlobal(0);
                *ret = native;
                return ret;
            }

            private EnumTypeLoc(EnumTypeLoc.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected EnumTypeLoc(EnumTypeLoc.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public EnumTypeLoc()
            {
                __Instance = Marshal.AllocHGlobal(0);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.EnumTypeLoc __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.EnumDecl getDecl()
            {
                var __ret = Internal.getDecl_0(__Instance);
                clang.EnumDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.EnumDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.EnumDecl) clang.EnumDecl.NativeToManagedMap[__ret];
                else clang.EnumDecl.NativeToManagedMap[__ret] = __result0 = (clang.EnumDecl) clang.EnumDecl.__CreateInstance(__ret);
                return __result0;
            }
        }

        /// <summary>
        /// <para>Wrapper for template type parameters.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief Wrapper for template type parameters.</para>
        /// </remarks>
        public unsafe partial class TemplateTypeParmTypeLoc : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang23TemplateTypeParmTypeLocC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang23TemplateTypeParmTypeLocC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, TemplateTypeParmTypeLoc> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, TemplateTypeParmTypeLoc>();

            private readonly bool __ownsNativeInstance;

            public static TemplateTypeParmTypeLoc __CreateInstance(global::System.IntPtr native)
            {
                return new TemplateTypeParmTypeLoc((TemplateTypeParmTypeLoc.Internal*) native);
            }

            public static TemplateTypeParmTypeLoc __CreateInstance(TemplateTypeParmTypeLoc.Internal native)
            {
                return new TemplateTypeParmTypeLoc(native);
            }

            private static TemplateTypeParmTypeLoc.Internal* __CopyValue(TemplateTypeParmTypeLoc.Internal native)
            {
                var ret = (TemplateTypeParmTypeLoc.Internal*) Marshal.AllocHGlobal(0);
                *ret = native;
                return ret;
            }

            private TemplateTypeParmTypeLoc(TemplateTypeParmTypeLoc.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected TemplateTypeParmTypeLoc(TemplateTypeParmTypeLoc.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public TemplateTypeParmTypeLoc()
            {
                __Instance = Marshal.AllocHGlobal(0);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.TemplateTypeParmTypeLoc __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Wrapper for substituted template type parameters.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief Wrapper for substituted template type
        /// parameters.</para>
        /// </remarks>
        public unsafe partial class SubstTemplateTypeParmTypeLoc : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang28SubstTemplateTypeParmTypeLocC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang28SubstTemplateTypeParmTypeLocC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, SubstTemplateTypeParmTypeLoc> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, SubstTemplateTypeParmTypeLoc>();

            private readonly bool __ownsNativeInstance;

            public static SubstTemplateTypeParmTypeLoc __CreateInstance(global::System.IntPtr native)
            {
                return new SubstTemplateTypeParmTypeLoc((SubstTemplateTypeParmTypeLoc.Internal*) native);
            }

            public static SubstTemplateTypeParmTypeLoc __CreateInstance(SubstTemplateTypeParmTypeLoc.Internal native)
            {
                return new SubstTemplateTypeParmTypeLoc(native);
            }

            private static SubstTemplateTypeParmTypeLoc.Internal* __CopyValue(SubstTemplateTypeParmTypeLoc.Internal native)
            {
                var ret = (SubstTemplateTypeParmTypeLoc.Internal*) Marshal.AllocHGlobal(0);
                *ret = native;
                return ret;
            }

            private SubstTemplateTypeParmTypeLoc(SubstTemplateTypeParmTypeLoc.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected SubstTemplateTypeParmTypeLoc(SubstTemplateTypeParmTypeLoc.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public SubstTemplateTypeParmTypeLoc()
            {
                __Instance = Marshal.AllocHGlobal(0);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.SubstTemplateTypeParmTypeLoc __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>Wrapper for substituted template type parameters.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief Wrapper for substituted template type
        /// parameters.</para>
        /// </remarks>
        public unsafe partial class SubstTemplateTypeParmPackTypeLoc : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang32SubstTemplateTypeParmPackTypeLocC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang32SubstTemplateTypeParmPackTypeLocC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, SubstTemplateTypeParmPackTypeLoc> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, SubstTemplateTypeParmPackTypeLoc>();

            private readonly bool __ownsNativeInstance;

            public static SubstTemplateTypeParmPackTypeLoc __CreateInstance(global::System.IntPtr native)
            {
                return new SubstTemplateTypeParmPackTypeLoc((SubstTemplateTypeParmPackTypeLoc.Internal*) native);
            }

            public static SubstTemplateTypeParmPackTypeLoc __CreateInstance(SubstTemplateTypeParmPackTypeLoc.Internal native)
            {
                return new SubstTemplateTypeParmPackTypeLoc(native);
            }

            private static SubstTemplateTypeParmPackTypeLoc.Internal* __CopyValue(SubstTemplateTypeParmPackTypeLoc.Internal native)
            {
                var ret = (SubstTemplateTypeParmPackTypeLoc.Internal*) Marshal.AllocHGlobal(0);
                *ret = native;
                return ret;
            }

            private SubstTemplateTypeParmPackTypeLoc(SubstTemplateTypeParmPackTypeLoc.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected SubstTemplateTypeParmPackTypeLoc(SubstTemplateTypeParmPackTypeLoc.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public SubstTemplateTypeParmPackTypeLoc()
            {
                __Instance = Marshal.AllocHGlobal(0);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.SubstTemplateTypeParmPackTypeLoc __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }
        }

        public unsafe partial class AttributedLocInfo : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                internal clang.AttributedLocInfo._.Internal __;

                [FieldOffset(4)]
                public clang.SourceRange.Internal OperandParens;

                [FieldOffset(12)]
                public clang.SourceLocation.Internal AttrLoc;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17AttributedLocInfoC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17AttributedLocInfoC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
            }

            public unsafe partial struct _
            {
                [StructLayout(LayoutKind.Explicit, Size = 4)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public global::System.IntPtr ExprOperand;

                    [FieldOffset(0)]
                    public uint EnumOperandLoc;
                }
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, AttributedLocInfo> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, AttributedLocInfo>();

            private readonly bool __ownsNativeInstance;

            public static AttributedLocInfo __CreateInstance(global::System.IntPtr native)
            {
                return new AttributedLocInfo((AttributedLocInfo.Internal*) native);
            }

            public static AttributedLocInfo __CreateInstance(AttributedLocInfo.Internal native)
            {
                return new AttributedLocInfo(native);
            }

            private static AttributedLocInfo.Internal* __CopyValue(AttributedLocInfo.Internal native)
            {
                var ret = (AttributedLocInfo.Internal*) Marshal.AllocHGlobal(16);
                *ret = native;
                return ret;
            }

            private AttributedLocInfo(AttributedLocInfo.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected AttributedLocInfo(AttributedLocInfo.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public AttributedLocInfo()
            {
                __Instance = Marshal.AllocHGlobal(16);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.AttributedLocInfo __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.SourceRange OperandParens
            {
                get
                {
                    return clang.SourceRange.__CreateInstance(((Internal*) __Instance)->OperandParens);
                }

                set
                {
                    ((Internal*) __Instance)->OperandParens = ReferenceEquals(value, null) ? new clang.SourceRange.Internal() : *(clang.SourceRange.Internal*) (value.__Instance);
                }
            }

            public clang.SourceLocation AttrLoc
            {
                get
                {
                    return clang.SourceLocation.__CreateInstance(((Internal*) __Instance)->AttrLoc);
                }

                set
                {
                    ((Internal*) __Instance)->AttrLoc = ReferenceEquals(value, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (value.__Instance);
                }
            }
        }

        /// <summary>
        /// <para>Type source information for an attributed type.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief Type source information for an attributed type.</para>
        /// </remarks>
        public unsafe partial class AttributedTypeLoc : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17AttributedTypeLocC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17AttributedTypeLocC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17AttributedTypeLoc11getAttrKindEv")]
                internal static extern clang.AttributedType.Kind getAttrKind_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17AttributedTypeLoc18hasAttrExprOperandEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasAttrExprOperand_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17AttributedTypeLoc18hasAttrEnumOperandEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasAttrEnumOperand_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17AttributedTypeLoc14hasAttrOperandEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasAttrOperand_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17AttributedTypeLoc14getModifiedLocEv")]
                internal static extern clang.TypeLoc.Internal getModifiedLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17AttributedTypeLoc14getAttrNameLocEv")]
                internal static extern clang.SourceLocation.Internal getAttrNameLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17AttributedTypeLoc14setAttrNameLocENS_14SourceLocationE")]
                internal static extern void setAttrNameLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17AttributedTypeLoc21getAttrEnumOperandLocEv")]
                internal static extern clang.SourceLocation.Internal getAttrEnumOperandLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17AttributedTypeLoc21setAttrEnumOperandLocENS_14SourceLocationE")]
                internal static extern void setAttrEnumOperandLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17AttributedTypeLoc25getAttrOperandParensRangeEv")]
                internal static extern clang.SourceRange.Internal getAttrOperandParensRange_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17AttributedTypeLoc25setAttrOperandParensRangeENS_11SourceRangeE")]
                internal static extern void setAttrOperandParensRange_0(global::System.IntPtr instance, clang.SourceRange.Internal range);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17AttributedTypeLoc19getLocalSourceRangeEv")]
                internal static extern clang.SourceRange.Internal getLocalSourceRange_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17AttributedTypeLoc15initializeLocalERNS_10ASTContextENS_14SourceLocationE")]
                internal static extern void initializeLocal_0(global::System.IntPtr instance, global::System.IntPtr Context, clang.SourceLocation.Internal loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17AttributedTypeLoc12getInnerTypeEv")]
                internal static extern clang.QualType.Internal getInnerType_0(global::System.IntPtr instance);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, AttributedTypeLoc> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, AttributedTypeLoc>();

            private readonly bool __ownsNativeInstance;

            public static AttributedTypeLoc __CreateInstance(global::System.IntPtr native)
            {
                return new AttributedTypeLoc((AttributedTypeLoc.Internal*) native);
            }

            public static AttributedTypeLoc __CreateInstance(AttributedTypeLoc.Internal native)
            {
                return new AttributedTypeLoc(native);
            }

            private static AttributedTypeLoc.Internal* __CopyValue(AttributedTypeLoc.Internal native)
            {
                var ret = (AttributedTypeLoc.Internal*) Marshal.AllocHGlobal(0);
                *ret = native;
                return ret;
            }

            private AttributedTypeLoc(AttributedTypeLoc.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected AttributedTypeLoc(AttributedTypeLoc.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public AttributedTypeLoc()
            {
                __Instance = Marshal.AllocHGlobal(0);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.AttributedTypeLoc __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.AttributedType.Kind getAttrKind()
            {
                var __ret = Internal.getAttrKind_0(__Instance);
                return __ret;
            }

            public bool hasAttrExprOperand()
            {
                var __ret = Internal.hasAttrExprOperand_0(__Instance);
                return __ret;
            }

            public bool hasAttrEnumOperand()
            {
                var __ret = Internal.hasAttrEnumOperand_0(__Instance);
                return __ret;
            }

            public bool hasAttrOperand()
            {
                var __ret = Internal.hasAttrOperand_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>The modified type, which is generally canonically different from
            /// the attribute type. int main(int, char**) __attribute__((noreturn)) ~~~
            /// ~~~~~~~~~~~~~</para>
            /// </summary>
            /// <remarks>
            /// <para>/// The modified type, which is generally canonically different
            /// from</para>
            /// <para>  /// the attribute type.</para>
            /// <para>  ///    int main(int, char**) __attribute__((noreturn))</para>
            /// <para>  ///    ~~~     ~~~~~~~~~~~~~</para>
            /// </remarks>
            public clang.TypeLoc getModifiedLoc()
            {
                var __ret = Internal.getModifiedLoc_0(__Instance);
                return clang.TypeLoc.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>The location of the attribute name, i.e.
            /// __attribute__((regparm(1000))) ^~~~~~~</para>
            /// </summary>
            /// <remarks>
            /// <para>/// The location of the attribute name, i.e.</para>
            /// <para>  ///    __attribute__((regparm(1000)))</para>
            /// <para>  ///                   ^~~~~~~</para>
            /// </remarks>
            public clang.SourceLocation getAttrNameLoc()
            {
                var __ret = Internal.getAttrNameLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setAttrNameLoc(clang.SourceLocation loc)
            {
                var arg0 = ReferenceEquals(loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (loc.__Instance);
                Internal.setAttrNameLoc_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>The location of the attribute's enumerated operand, if it has
            /// one. void * __attribute__((objc_gc(weak))) ^~~~</para>
            /// </summary>
            /// <remarks>
            /// <para>/// The location of the attribute's enumerated operand, if it has
            /// one.</para>
            /// <para>  ///    void * __attribute__((objc_gc(weak)))</para>
            /// <para>  ///                                  ^~~~</para>
            /// </remarks>
            public clang.SourceLocation getAttrEnumOperandLoc()
            {
                var __ret = Internal.getAttrEnumOperandLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setAttrEnumOperandLoc(clang.SourceLocation loc)
            {
                var arg0 = ReferenceEquals(loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (loc.__Instance);
                Internal.setAttrEnumOperandLoc_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>The location of the parentheses around the operand, if there is
            /// an operand. void * __attribute__((objc_gc(weak))) ^ ^</para>
            /// </summary>
            /// <remarks>
            /// <para>/// The location of the parentheses around the operand, if there
            /// is</para>
            /// <para>  /// an operand.</para>
            /// <para>  ///    void * __attribute__((objc_gc(weak)))</para>
            /// <para>  ///                                 ^    ^</para>
            /// </remarks>
            public clang.SourceRange getAttrOperandParensRange()
            {
                var __ret = Internal.getAttrOperandParensRange_0(__Instance);
                return clang.SourceRange.__CreateInstance(__ret);
            }

            public void setAttrOperandParensRange(clang.SourceRange range)
            {
                var arg0 = ReferenceEquals(range, null) ? new clang.SourceRange.Internal() : *(clang.SourceRange.Internal*) (range.__Instance);
                Internal.setAttrOperandParensRange_0(__Instance, arg0);
            }

            public clang.SourceRange getLocalSourceRange()
            {
                var __ret = Internal.getLocalSourceRange_0(__Instance);
                return clang.SourceRange.__CreateInstance(__ret);
            }

            public void initializeLocal(clang.ASTContext Context, clang.SourceLocation loc)
            {
                var arg0 = ReferenceEquals(Context, null) ? global::System.IntPtr.Zero : Context.__Instance;
                var arg1 = ReferenceEquals(loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (loc.__Instance);
                Internal.initializeLocal_0(__Instance, arg0, arg1);
            }

            public clang.QualType getInnerType()
            {
                var __ret = Internal.getInnerType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }
        }

        public unsafe partial class ObjCProtocolListLocInfo : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 12)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public clang.SourceLocation.Internal LAngleLoc;

                [FieldOffset(4)]
                public clang.SourceLocation.Internal RAngleLoc;

                [FieldOffset(8)]
                public bool HasBaseTypeAsWritten;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang23ObjCProtocolListLocInfoC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang23ObjCProtocolListLocInfoC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ObjCProtocolListLocInfo> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ObjCProtocolListLocInfo>();

            private readonly bool __ownsNativeInstance;

            public static ObjCProtocolListLocInfo __CreateInstance(global::System.IntPtr native)
            {
                return new ObjCProtocolListLocInfo((ObjCProtocolListLocInfo.Internal*) native);
            }

            public static ObjCProtocolListLocInfo __CreateInstance(ObjCProtocolListLocInfo.Internal native)
            {
                return new ObjCProtocolListLocInfo(native);
            }

            private static ObjCProtocolListLocInfo.Internal* __CopyValue(ObjCProtocolListLocInfo.Internal native)
            {
                var ret = (ObjCProtocolListLocInfo.Internal*) Marshal.AllocHGlobal(12);
                *ret = native;
                return ret;
            }

            private ObjCProtocolListLocInfo(ObjCProtocolListLocInfo.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected ObjCProtocolListLocInfo(ObjCProtocolListLocInfo.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public ObjCProtocolListLocInfo()
            {
                __Instance = Marshal.AllocHGlobal(12);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.ObjCProtocolListLocInfo __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.SourceLocation LAngleLoc
            {
                get
                {
                    return clang.SourceLocation.__CreateInstance(((Internal*) __Instance)->LAngleLoc);
                }

                set
                {
                    ((Internal*) __Instance)->LAngleLoc = ReferenceEquals(value, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (value.__Instance);
                }
            }

            public clang.SourceLocation RAngleLoc
            {
                get
                {
                    return clang.SourceLocation.__CreateInstance(((Internal*) __Instance)->RAngleLoc);
                }

                set
                {
                    ((Internal*) __Instance)->RAngleLoc = ReferenceEquals(value, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (value.__Instance);
                }
            }

            public bool HasBaseTypeAsWritten
            {
                get
                {
                    return ((Internal*) __Instance)->HasBaseTypeAsWritten;
                }

                set
                {
                    ((Internal*) __Instance)->HasBaseTypeAsWritten = value;
                }
            }
        }

        public unsafe partial class ObjCObjectTypeLoc : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17ObjCObjectTypeLocC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17ObjCObjectTypeLocC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17ObjCObjectTypeLoc12getLAngleLocEv")]
                internal static extern clang.SourceLocation.Internal getLAngleLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17ObjCObjectTypeLoc12setLAngleLocENS_14SourceLocationE")]
                internal static extern void setLAngleLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal Loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17ObjCObjectTypeLoc12getRAngleLocEv")]
                internal static extern clang.SourceLocation.Internal getRAngleLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17ObjCObjectTypeLoc12setRAngleLocENS_14SourceLocationE")]
                internal static extern void setRAngleLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal Loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17ObjCObjectTypeLoc15getNumProtocolsEv")]
                internal static extern uint getNumProtocols_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17ObjCObjectTypeLoc14getProtocolLocEj")]
                internal static extern clang.SourceLocation.Internal getProtocolLoc_0(global::System.IntPtr instance, uint i);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17ObjCObjectTypeLoc14setProtocolLocEjNS_14SourceLocationE")]
                internal static extern void setProtocolLoc_0(global::System.IntPtr instance, uint i, clang.SourceLocation.Internal Loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17ObjCObjectTypeLoc20hasBaseTypeAsWrittenEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasBaseTypeAsWritten_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17ObjCObjectTypeLoc23setHasBaseTypeAsWrittenEb")]
                internal static extern void setHasBaseTypeAsWritten_0(global::System.IntPtr instance, bool HasBaseType);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17ObjCObjectTypeLoc10getBaseLocEv")]
                internal static extern clang.TypeLoc.Internal getBaseLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17ObjCObjectTypeLoc19getLocalSourceRangeEv")]
                internal static extern clang.SourceRange.Internal getLocalSourceRange_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17ObjCObjectTypeLoc15initializeLocalERNS_10ASTContextENS_14SourceLocationE")]
                internal static extern void initializeLocal_0(global::System.IntPtr instance, global::System.IntPtr Context, clang.SourceLocation.Internal Loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17ObjCObjectTypeLoc21getExtraLocalDataSizeEv")]
                internal static extern uint getExtraLocalDataSize_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17ObjCObjectTypeLoc26getExtraLocalDataAlignmentEv")]
                internal static extern uint getExtraLocalDataAlignment_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17ObjCObjectTypeLoc12getInnerTypeEv")]
                internal static extern clang.QualType.Internal getInnerType_0(global::System.IntPtr instance);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ObjCObjectTypeLoc> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ObjCObjectTypeLoc>();

            private readonly bool __ownsNativeInstance;

            public static ObjCObjectTypeLoc __CreateInstance(global::System.IntPtr native)
            {
                return new ObjCObjectTypeLoc((ObjCObjectTypeLoc.Internal*) native);
            }

            public static ObjCObjectTypeLoc __CreateInstance(ObjCObjectTypeLoc.Internal native)
            {
                return new ObjCObjectTypeLoc(native);
            }

            private static ObjCObjectTypeLoc.Internal* __CopyValue(ObjCObjectTypeLoc.Internal native)
            {
                var ret = (ObjCObjectTypeLoc.Internal*) Marshal.AllocHGlobal(0);
                *ret = native;
                return ret;
            }

            private ObjCObjectTypeLoc(ObjCObjectTypeLoc.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected ObjCObjectTypeLoc(ObjCObjectTypeLoc.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public ObjCObjectTypeLoc()
            {
                __Instance = Marshal.AllocHGlobal(0);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.ObjCObjectTypeLoc __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.SourceLocation getLAngleLoc()
            {
                var __ret = Internal.getLAngleLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setLAngleLoc(clang.SourceLocation Loc)
            {
                var arg0 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                Internal.setLAngleLoc_0(__Instance, arg0);
            }

            public clang.SourceLocation getRAngleLoc()
            {
                var __ret = Internal.getRAngleLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setRAngleLoc(clang.SourceLocation Loc)
            {
                var arg0 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                Internal.setRAngleLoc_0(__Instance, arg0);
            }

            public uint getNumProtocols()
            {
                var __ret = Internal.getNumProtocols_0(__Instance);
                return __ret;
            }

            public clang.SourceLocation getProtocolLoc(uint i)
            {
                var __ret = Internal.getProtocolLoc_0(__Instance, i);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setProtocolLoc(uint i, clang.SourceLocation Loc)
            {
                var arg1 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                Internal.setProtocolLoc_0(__Instance, i, arg1);
            }

            public bool hasBaseTypeAsWritten()
            {
                var __ret = Internal.hasBaseTypeAsWritten_0(__Instance);
                return __ret;
            }

            public void setHasBaseTypeAsWritten(bool HasBaseType)
            {
                Internal.setHasBaseTypeAsWritten_0(__Instance, HasBaseType);
            }

            public clang.TypeLoc getBaseLoc()
            {
                var __ret = Internal.getBaseLoc_0(__Instance);
                return clang.TypeLoc.__CreateInstance(__ret);
            }

            public clang.SourceRange getLocalSourceRange()
            {
                var __ret = Internal.getLocalSourceRange_0(__Instance);
                return clang.SourceRange.__CreateInstance(__ret);
            }

            public void initializeLocal(clang.ASTContext Context, clang.SourceLocation Loc)
            {
                var arg0 = ReferenceEquals(Context, null) ? global::System.IntPtr.Zero : Context.__Instance;
                var arg1 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                Internal.initializeLocal_0(__Instance, arg0, arg1);
            }

            public uint getExtraLocalDataSize()
            {
                var __ret = Internal.getExtraLocalDataSize_0(__Instance);
                return __ret;
            }

            public uint getExtraLocalDataAlignment()
            {
                var __ret = Internal.getExtraLocalDataAlignment_0(__Instance);
                return __ret;
            }

            public clang.QualType getInnerType()
            {
                var __ret = Internal.getInnerType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }
        }

        public unsafe partial class ObjCInterfaceLocInfo : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 8)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public clang.SourceLocation.Internal NameLoc;

                [FieldOffset(4)]
                public clang.SourceLocation.Internal NameEndLoc;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang20ObjCInterfaceLocInfoC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang20ObjCInterfaceLocInfoC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ObjCInterfaceLocInfo> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ObjCInterfaceLocInfo>();

            private readonly bool __ownsNativeInstance;

            public static ObjCInterfaceLocInfo __CreateInstance(global::System.IntPtr native)
            {
                return new ObjCInterfaceLocInfo((ObjCInterfaceLocInfo.Internal*) native);
            }

            public static ObjCInterfaceLocInfo __CreateInstance(ObjCInterfaceLocInfo.Internal native)
            {
                return new ObjCInterfaceLocInfo(native);
            }

            private static ObjCInterfaceLocInfo.Internal* __CopyValue(ObjCInterfaceLocInfo.Internal native)
            {
                var ret = (ObjCInterfaceLocInfo.Internal*) Marshal.AllocHGlobal(8);
                *ret = native;
                return ret;
            }

            private ObjCInterfaceLocInfo(ObjCInterfaceLocInfo.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected ObjCInterfaceLocInfo(ObjCInterfaceLocInfo.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public ObjCInterfaceLocInfo()
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.ObjCInterfaceLocInfo __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.SourceLocation NameLoc
            {
                get
                {
                    return clang.SourceLocation.__CreateInstance(((Internal*) __Instance)->NameLoc);
                }

                set
                {
                    ((Internal*) __Instance)->NameLoc = ReferenceEquals(value, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (value.__Instance);
                }
            }

            public clang.SourceLocation NameEndLoc
            {
                get
                {
                    return clang.SourceLocation.__CreateInstance(((Internal*) __Instance)->NameEndLoc);
                }

                set
                {
                    ((Internal*) __Instance)->NameEndLoc = ReferenceEquals(value, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (value.__Instance);
                }
            }
        }

        /// <summary>
        /// <para>Wrapper for source info for ObjC interfaces.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief Wrapper for source info for ObjC interfaces.</para>
        /// </remarks>
        public unsafe partial class ObjCInterfaceTypeLoc : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang20ObjCInterfaceTypeLocC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang20ObjCInterfaceTypeLocC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang20ObjCInterfaceTypeLoc10getNameLocEv")]
                internal static extern clang.SourceLocation.Internal getNameLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang20ObjCInterfaceTypeLoc10setNameLocENS_14SourceLocationE")]
                internal static extern void setNameLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal Loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang20ObjCInterfaceTypeLoc19getLocalSourceRangeEv")]
                internal static extern clang.SourceRange.Internal getLocalSourceRange_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang20ObjCInterfaceTypeLoc13getNameEndLocEv")]
                internal static extern clang.SourceLocation.Internal getNameEndLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang20ObjCInterfaceTypeLoc13setNameEndLocENS_14SourceLocationE")]
                internal static extern void setNameEndLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal Loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang20ObjCInterfaceTypeLoc15initializeLocalERNS_10ASTContextENS_14SourceLocationE")]
                internal static extern void initializeLocal_0(global::System.IntPtr instance, global::System.IntPtr Context, clang.SourceLocation.Internal Loc);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ObjCInterfaceTypeLoc> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ObjCInterfaceTypeLoc>();

            private readonly bool __ownsNativeInstance;

            public static ObjCInterfaceTypeLoc __CreateInstance(global::System.IntPtr native)
            {
                return new ObjCInterfaceTypeLoc((ObjCInterfaceTypeLoc.Internal*) native);
            }

            public static ObjCInterfaceTypeLoc __CreateInstance(ObjCInterfaceTypeLoc.Internal native)
            {
                return new ObjCInterfaceTypeLoc(native);
            }

            private static ObjCInterfaceTypeLoc.Internal* __CopyValue(ObjCInterfaceTypeLoc.Internal native)
            {
                var ret = (ObjCInterfaceTypeLoc.Internal*) Marshal.AllocHGlobal(0);
                *ret = native;
                return ret;
            }

            private ObjCInterfaceTypeLoc(ObjCInterfaceTypeLoc.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected ObjCInterfaceTypeLoc(ObjCInterfaceTypeLoc.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public ObjCInterfaceTypeLoc()
            {
                __Instance = Marshal.AllocHGlobal(0);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.ObjCInterfaceTypeLoc __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.SourceLocation getNameLoc()
            {
                var __ret = Internal.getNameLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setNameLoc(clang.SourceLocation Loc)
            {
                var arg0 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                Internal.setNameLoc_0(__Instance, arg0);
            }

            public clang.SourceRange getLocalSourceRange()
            {
                var __ret = Internal.getLocalSourceRange_0(__Instance);
                return clang.SourceRange.__CreateInstance(__ret);
            }

            public clang.SourceLocation getNameEndLoc()
            {
                var __ret = Internal.getNameEndLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setNameEndLoc(clang.SourceLocation Loc)
            {
                var arg0 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                Internal.setNameEndLoc_0(__Instance, arg0);
            }

            public void initializeLocal(clang.ASTContext Context, clang.SourceLocation Loc)
            {
                var arg0 = ReferenceEquals(Context, null) ? global::System.IntPtr.Zero : Context.__Instance;
                var arg1 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                Internal.initializeLocal_0(__Instance, arg0, arg1);
            }
        }

        public unsafe partial class ParenLocInfo : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 8)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public clang.SourceLocation.Internal LParenLoc;

                [FieldOffset(4)]
                public clang.SourceLocation.Internal RParenLoc;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12ParenLocInfoC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12ParenLocInfoC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ParenLocInfo> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ParenLocInfo>();

            private readonly bool __ownsNativeInstance;

            public static ParenLocInfo __CreateInstance(global::System.IntPtr native)
            {
                return new ParenLocInfo((ParenLocInfo.Internal*) native);
            }

            public static ParenLocInfo __CreateInstance(ParenLocInfo.Internal native)
            {
                return new ParenLocInfo(native);
            }

            private static ParenLocInfo.Internal* __CopyValue(ParenLocInfo.Internal native)
            {
                var ret = (ParenLocInfo.Internal*) Marshal.AllocHGlobal(8);
                *ret = native;
                return ret;
            }

            private ParenLocInfo(ParenLocInfo.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected ParenLocInfo(ParenLocInfo.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public ParenLocInfo()
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.ParenLocInfo __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.SourceLocation LParenLoc
            {
                get
                {
                    return clang.SourceLocation.__CreateInstance(((Internal*) __Instance)->LParenLoc);
                }

                set
                {
                    ((Internal*) __Instance)->LParenLoc = ReferenceEquals(value, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (value.__Instance);
                }
            }

            public clang.SourceLocation RParenLoc
            {
                get
                {
                    return clang.SourceLocation.__CreateInstance(((Internal*) __Instance)->RParenLoc);
                }

                set
                {
                    ((Internal*) __Instance)->RParenLoc = ReferenceEquals(value, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (value.__Instance);
                }
            }
        }

        public unsafe partial class ParenTypeLoc : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12ParenTypeLocC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12ParenTypeLocC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12ParenTypeLoc12getLParenLocEv")]
                internal static extern clang.SourceLocation.Internal getLParenLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12ParenTypeLoc12getRParenLocEv")]
                internal static extern clang.SourceLocation.Internal getRParenLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12ParenTypeLoc12setLParenLocENS_14SourceLocationE")]
                internal static extern void setLParenLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal Loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12ParenTypeLoc12setRParenLocENS_14SourceLocationE")]
                internal static extern void setRParenLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal Loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12ParenTypeLoc19getLocalSourceRangeEv")]
                internal static extern clang.SourceRange.Internal getLocalSourceRange_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12ParenTypeLoc15initializeLocalERNS_10ASTContextENS_14SourceLocationE")]
                internal static extern void initializeLocal_0(global::System.IntPtr instance, global::System.IntPtr Context, clang.SourceLocation.Internal Loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12ParenTypeLoc11getInnerLocEv")]
                internal static extern clang.TypeLoc.Internal getInnerLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12ParenTypeLoc12getInnerTypeEv")]
                internal static extern clang.QualType.Internal getInnerType_0(global::System.IntPtr instance);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ParenTypeLoc> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ParenTypeLoc>();

            private readonly bool __ownsNativeInstance;

            public static ParenTypeLoc __CreateInstance(global::System.IntPtr native)
            {
                return new ParenTypeLoc((ParenTypeLoc.Internal*) native);
            }

            public static ParenTypeLoc __CreateInstance(ParenTypeLoc.Internal native)
            {
                return new ParenTypeLoc(native);
            }

            private static ParenTypeLoc.Internal* __CopyValue(ParenTypeLoc.Internal native)
            {
                var ret = (ParenTypeLoc.Internal*) Marshal.AllocHGlobal(0);
                *ret = native;
                return ret;
            }

            private ParenTypeLoc(ParenTypeLoc.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected ParenTypeLoc(ParenTypeLoc.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public ParenTypeLoc()
            {
                __Instance = Marshal.AllocHGlobal(0);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.ParenTypeLoc __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.SourceLocation getLParenLoc()
            {
                var __ret = Internal.getLParenLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getRParenLoc()
            {
                var __ret = Internal.getRParenLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setLParenLoc(clang.SourceLocation Loc)
            {
                var arg0 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                Internal.setLParenLoc_0(__Instance, arg0);
            }

            public void setRParenLoc(clang.SourceLocation Loc)
            {
                var arg0 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                Internal.setRParenLoc_0(__Instance, arg0);
            }

            public clang.SourceRange getLocalSourceRange()
            {
                var __ret = Internal.getLocalSourceRange_0(__Instance);
                return clang.SourceRange.__CreateInstance(__ret);
            }

            public void initializeLocal(clang.ASTContext Context, clang.SourceLocation Loc)
            {
                var arg0 = ReferenceEquals(Context, null) ? global::System.IntPtr.Zero : Context.__Instance;
                var arg1 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                Internal.initializeLocal_0(__Instance, arg0, arg1);
            }

            public clang.TypeLoc getInnerLoc()
            {
                var __ret = Internal.getInnerLoc_0(__Instance);
                return clang.TypeLoc.__CreateInstance(__ret);
            }

            public clang.QualType getInnerType()
            {
                var __ret = Internal.getInnerType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }
        }

        public unsafe partial class AdjustedLocInfo : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang15AdjustedLocInfoC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, AdjustedLocInfo> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, AdjustedLocInfo>();

            private readonly bool __ownsNativeInstance;

            public static AdjustedLocInfo __CreateInstance(global::System.IntPtr native)
            {
                return new AdjustedLocInfo((AdjustedLocInfo.Internal*) native);
            }

            public static AdjustedLocInfo __CreateInstance(AdjustedLocInfo.Internal native)
            {
                return new AdjustedLocInfo(native);
            }

            private static AdjustedLocInfo.Internal* __CopyValue(AdjustedLocInfo.Internal native)
            {
                var ret = (AdjustedLocInfo.Internal*) Marshal.AllocHGlobal(0);
                *ret = native;
                return ret;
            }

            private AdjustedLocInfo(AdjustedLocInfo.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected AdjustedLocInfo(AdjustedLocInfo.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public AdjustedLocInfo()
            {
                __Instance = Marshal.AllocHGlobal(0);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.AdjustedLocInfo __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }
        }

        public unsafe partial class AdjustedTypeLoc : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang15AdjustedTypeLocC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang15AdjustedTypeLocC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang15AdjustedTypeLoc14getOriginalLocEv")]
                internal static extern clang.TypeLoc.Internal getOriginalLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang15AdjustedTypeLoc15initializeLocalERNS_10ASTContextENS_14SourceLocationE")]
                internal static extern void initializeLocal_0(global::System.IntPtr instance, global::System.IntPtr Context, clang.SourceLocation.Internal Loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang15AdjustedTypeLoc12getInnerTypeEv")]
                internal static extern clang.QualType.Internal getInnerType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang15AdjustedTypeLoc19getLocalSourceRangeEv")]
                internal static extern clang.SourceRange.Internal getLocalSourceRange_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang15AdjustedTypeLoc16getLocalDataSizeEv")]
                internal static extern uint getLocalDataSize_0(global::System.IntPtr instance);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, AdjustedTypeLoc> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, AdjustedTypeLoc>();

            private readonly bool __ownsNativeInstance;

            public static AdjustedTypeLoc __CreateInstance(global::System.IntPtr native)
            {
                return new AdjustedTypeLoc((AdjustedTypeLoc.Internal*) native);
            }

            public static AdjustedTypeLoc __CreateInstance(AdjustedTypeLoc.Internal native)
            {
                return new AdjustedTypeLoc(native);
            }

            private static AdjustedTypeLoc.Internal* __CopyValue(AdjustedTypeLoc.Internal native)
            {
                var ret = (AdjustedTypeLoc.Internal*) Marshal.AllocHGlobal(0);
                *ret = native;
                return ret;
            }

            private AdjustedTypeLoc(AdjustedTypeLoc.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected AdjustedTypeLoc(AdjustedTypeLoc.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public AdjustedTypeLoc()
            {
                __Instance = Marshal.AllocHGlobal(0);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.AdjustedTypeLoc __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.TypeLoc getOriginalLoc()
            {
                var __ret = Internal.getOriginalLoc_0(__Instance);
                return clang.TypeLoc.__CreateInstance(__ret);
            }

            public void initializeLocal(clang.ASTContext Context, clang.SourceLocation Loc)
            {
                var arg0 = ReferenceEquals(Context, null) ? global::System.IntPtr.Zero : Context.__Instance;
                var arg1 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                Internal.initializeLocal_0(__Instance, arg0, arg1);
            }

            public clang.QualType getInnerType()
            {
                var __ret = Internal.getInnerType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            public clang.SourceRange getLocalSourceRange()
            {
                var __ret = Internal.getLocalSourceRange_0(__Instance);
                return clang.SourceRange.__CreateInstance(__ret);
            }

            public uint getLocalDataSize()
            {
                var __ret = Internal.getLocalDataSize_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Wrapper for source info for pointers decayed from arrays and
        /// functions.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief Wrapper for source info for pointers decayed from
        /// arrays and</para>
        /// <para>/// functions.</para>
        /// </remarks>
        public unsafe partial class DecayedTypeLoc : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14DecayedTypeLocC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14DecayedTypeLocC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, DecayedTypeLoc> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, DecayedTypeLoc>();

            private readonly bool __ownsNativeInstance;

            public static DecayedTypeLoc __CreateInstance(global::System.IntPtr native)
            {
                return new DecayedTypeLoc((DecayedTypeLoc.Internal*) native);
            }

            public static DecayedTypeLoc __CreateInstance(DecayedTypeLoc.Internal native)
            {
                return new DecayedTypeLoc(native);
            }

            private static DecayedTypeLoc.Internal* __CopyValue(DecayedTypeLoc.Internal native)
            {
                var ret = (DecayedTypeLoc.Internal*) Marshal.AllocHGlobal(0);
                *ret = native;
                return ret;
            }

            private DecayedTypeLoc(DecayedTypeLoc.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected DecayedTypeLoc(DecayedTypeLoc.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public DecayedTypeLoc()
            {
                __Instance = Marshal.AllocHGlobal(0);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.DecayedTypeLoc __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }
        }

        public unsafe partial class PointerLikeLocInfo : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 4)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public clang.SourceLocation.Internal StarLoc;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang18PointerLikeLocInfoC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang18PointerLikeLocInfoC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, PointerLikeLocInfo> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, PointerLikeLocInfo>();

            private readonly bool __ownsNativeInstance;

            public static PointerLikeLocInfo __CreateInstance(global::System.IntPtr native)
            {
                return new PointerLikeLocInfo((PointerLikeLocInfo.Internal*) native);
            }

            public static PointerLikeLocInfo __CreateInstance(PointerLikeLocInfo.Internal native)
            {
                return new PointerLikeLocInfo(native);
            }

            private static PointerLikeLocInfo.Internal* __CopyValue(PointerLikeLocInfo.Internal native)
            {
                var ret = (PointerLikeLocInfo.Internal*) Marshal.AllocHGlobal(4);
                *ret = native;
                return ret;
            }

            private PointerLikeLocInfo(PointerLikeLocInfo.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected PointerLikeLocInfo(PointerLikeLocInfo.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public PointerLikeLocInfo()
            {
                __Instance = Marshal.AllocHGlobal(4);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.PointerLikeLocInfo __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.SourceLocation StarLoc
            {
                get
                {
                    return clang.SourceLocation.__CreateInstance(((Internal*) __Instance)->StarLoc);
                }

                set
                {
                    ((Internal*) __Instance)->StarLoc = ReferenceEquals(value, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (value.__Instance);
                }
            }
        }

        /// <summary>
        /// <para>Wrapper for source info for pointers.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief Wrapper for source info for pointers.</para>
        /// </remarks>
        public unsafe partial class PointerTypeLoc : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14PointerTypeLocC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14PointerTypeLocC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14PointerTypeLoc10getStarLocEv")]
                internal static extern clang.SourceLocation.Internal getStarLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14PointerTypeLoc10setStarLocENS_14SourceLocationE")]
                internal static extern void setStarLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal Loc);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, PointerTypeLoc> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, PointerTypeLoc>();

            private readonly bool __ownsNativeInstance;

            public static PointerTypeLoc __CreateInstance(global::System.IntPtr native)
            {
                return new PointerTypeLoc((PointerTypeLoc.Internal*) native);
            }

            public static PointerTypeLoc __CreateInstance(PointerTypeLoc.Internal native)
            {
                return new PointerTypeLoc(native);
            }

            private static PointerTypeLoc.Internal* __CopyValue(PointerTypeLoc.Internal native)
            {
                var ret = (PointerTypeLoc.Internal*) Marshal.AllocHGlobal(0);
                *ret = native;
                return ret;
            }

            private PointerTypeLoc(PointerTypeLoc.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected PointerTypeLoc(PointerTypeLoc.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public PointerTypeLoc()
            {
                __Instance = Marshal.AllocHGlobal(0);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.PointerTypeLoc __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.SourceLocation getStarLoc()
            {
                var __ret = Internal.getStarLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setStarLoc(clang.SourceLocation Loc)
            {
                var arg0 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                Internal.setStarLoc_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>Wrapper for source info for block pointers.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief Wrapper for source info for block pointers.</para>
        /// </remarks>
        public unsafe partial class BlockPointerTypeLoc : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang19BlockPointerTypeLocC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang19BlockPointerTypeLocC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang19BlockPointerTypeLoc11getCaretLocEv")]
                internal static extern clang.SourceLocation.Internal getCaretLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang19BlockPointerTypeLoc11setCaretLocENS_14SourceLocationE")]
                internal static extern void setCaretLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal Loc);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, BlockPointerTypeLoc> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, BlockPointerTypeLoc>();

            private readonly bool __ownsNativeInstance;

            public static BlockPointerTypeLoc __CreateInstance(global::System.IntPtr native)
            {
                return new BlockPointerTypeLoc((BlockPointerTypeLoc.Internal*) native);
            }

            public static BlockPointerTypeLoc __CreateInstance(BlockPointerTypeLoc.Internal native)
            {
                return new BlockPointerTypeLoc(native);
            }

            private static BlockPointerTypeLoc.Internal* __CopyValue(BlockPointerTypeLoc.Internal native)
            {
                var ret = (BlockPointerTypeLoc.Internal*) Marshal.AllocHGlobal(0);
                *ret = native;
                return ret;
            }

            private BlockPointerTypeLoc(BlockPointerTypeLoc.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected BlockPointerTypeLoc(BlockPointerTypeLoc.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public BlockPointerTypeLoc()
            {
                __Instance = Marshal.AllocHGlobal(0);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.BlockPointerTypeLoc __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.SourceLocation getCaretLoc()
            {
                var __ret = Internal.getCaretLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setCaretLoc(clang.SourceLocation Loc)
            {
                var arg0 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                Internal.setCaretLoc_0(__Instance, arg0);
            }
        }

        public unsafe partial class MemberPointerLocInfo : clang.PointerLikeLocInfo, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 8)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                public clang.SourceLocation.Internal StarLoc;

                [FieldOffset(4)]
                public global::System.IntPtr ClassTInfo;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang20MemberPointerLocInfoC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang20MemberPointerLocInfoC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
            }

            private readonly bool __ownsNativeInstance;

            public static new MemberPointerLocInfo __CreateInstance(global::System.IntPtr native)
            {
                return new MemberPointerLocInfo((MemberPointerLocInfo.Internal*) native);
            }

            public static MemberPointerLocInfo __CreateInstance(MemberPointerLocInfo.Internal native)
            {
                return new MemberPointerLocInfo(native);
            }

            private static MemberPointerLocInfo.Internal* __CopyValue(MemberPointerLocInfo.Internal native)
            {
                var ret = (MemberPointerLocInfo.Internal*) Marshal.AllocHGlobal(8);
                *ret = native;
                return ret;
            }

            private MemberPointerLocInfo(MemberPointerLocInfo.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected MemberPointerLocInfo(MemberPointerLocInfo.Internal* native, bool isInternalImpl = false)
                : base((clang.PointerLikeLocInfo.Internal*) native)
            {
            }

            public MemberPointerLocInfo()
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.PointerLikeLocInfo __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.TypeSourceInfo ClassTInfo
            {
                get
                {
                    clang.TypeSourceInfo __result0;
                    if (((Internal*) __Instance)->ClassTInfo == IntPtr.Zero) __result0 = null;
                    else if (clang.TypeSourceInfo.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->ClassTInfo))
                        __result0 = (clang.TypeSourceInfo) clang.TypeSourceInfo.NativeToManagedMap[((Internal*) __Instance)->ClassTInfo];
                    else __result0 = clang.TypeSourceInfo.__CreateInstance(((Internal*) __Instance)->ClassTInfo);
                    return __result0;
                }

                set
                {
                    ((Internal*) __Instance)->ClassTInfo = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                }
            }
        }

        /// <summary>
        /// <para>Wrapper for source info for member pointers.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief Wrapper for source info for member pointers.</para>
        /// </remarks>
        public unsafe partial class MemberPointerTypeLoc : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang20MemberPointerTypeLocC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang20MemberPointerTypeLocC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang20MemberPointerTypeLoc10getStarLocEv")]
                internal static extern clang.SourceLocation.Internal getStarLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang20MemberPointerTypeLoc10setStarLocENS_14SourceLocationE")]
                internal static extern void setStarLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal Loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang20MemberPointerTypeLoc8getClassEv")]
                internal static extern global::System.IntPtr getClass_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang20MemberPointerTypeLoc13getClassTInfoEv")]
                internal static extern global::System.IntPtr getClassTInfo_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang20MemberPointerTypeLoc13setClassTInfoEPNS_14TypeSourceInfoE")]
                internal static extern void setClassTInfo_0(global::System.IntPtr instance, global::System.IntPtr TI);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang20MemberPointerTypeLoc15initializeLocalERNS_10ASTContextENS_14SourceLocationE")]
                internal static extern void initializeLocal_0(global::System.IntPtr instance, global::System.IntPtr Context, clang.SourceLocation.Internal Loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang20MemberPointerTypeLoc19getLocalSourceRangeEv")]
                internal static extern clang.SourceRange.Internal getLocalSourceRange_0(global::System.IntPtr instance);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, MemberPointerTypeLoc> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, MemberPointerTypeLoc>();

            private readonly bool __ownsNativeInstance;

            public static MemberPointerTypeLoc __CreateInstance(global::System.IntPtr native)
            {
                return new MemberPointerTypeLoc((MemberPointerTypeLoc.Internal*) native);
            }

            public static MemberPointerTypeLoc __CreateInstance(MemberPointerTypeLoc.Internal native)
            {
                return new MemberPointerTypeLoc(native);
            }

            private static MemberPointerTypeLoc.Internal* __CopyValue(MemberPointerTypeLoc.Internal native)
            {
                var ret = (MemberPointerTypeLoc.Internal*) Marshal.AllocHGlobal(0);
                *ret = native;
                return ret;
            }

            private MemberPointerTypeLoc(MemberPointerTypeLoc.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected MemberPointerTypeLoc(MemberPointerTypeLoc.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public MemberPointerTypeLoc()
            {
                __Instance = Marshal.AllocHGlobal(0);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.MemberPointerTypeLoc __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.SourceLocation getStarLoc()
            {
                var __ret = Internal.getStarLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setStarLoc(clang.SourceLocation Loc)
            {
                var arg0 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                Internal.setStarLoc_0(__Instance, arg0);
            }

            public clang.Type getClass()
            {
                var __ret = Internal.getClass_0(__Instance);
                clang.Type __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Type.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Type) clang.Type.NativeToManagedMap[__ret];
                else __result0 = clang.Type.__CreateInstance(__ret);
                return __result0;
            }

            public clang.TypeSourceInfo getClassTInfo()
            {
                var __ret = Internal.getClassTInfo_0(__Instance);
                clang.TypeSourceInfo __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.TypeSourceInfo.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.TypeSourceInfo) clang.TypeSourceInfo.NativeToManagedMap[__ret];
                else __result0 = clang.TypeSourceInfo.__CreateInstance(__ret);
                return __result0;
            }

            public void setClassTInfo(clang.TypeSourceInfo TI)
            {
                var arg0 = ReferenceEquals(TI, null) ? global::System.IntPtr.Zero : TI.__Instance;
                Internal.setClassTInfo_0(__Instance, arg0);
            }

            public void initializeLocal(clang.ASTContext Context, clang.SourceLocation Loc)
            {
                var arg0 = ReferenceEquals(Context, null) ? global::System.IntPtr.Zero : Context.__Instance;
                var arg1 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                Internal.initializeLocal_0(__Instance, arg0, arg1);
            }

            public clang.SourceRange getLocalSourceRange()
            {
                var __ret = Internal.getLocalSourceRange_0(__Instance);
                return clang.SourceRange.__CreateInstance(__ret);
            }
        }

        /// <summary>
        /// <para>Wraps an ObjCPointerType with source location information.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// Wraps an ObjCPointerType with source location
        /// information.</para>
        /// </remarks>
        public unsafe partial class ObjCObjectPointerTypeLoc : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang24ObjCObjectPointerTypeLocC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang24ObjCObjectPointerTypeLocC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang24ObjCObjectPointerTypeLoc10getStarLocEv")]
                internal static extern clang.SourceLocation.Internal getStarLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang24ObjCObjectPointerTypeLoc10setStarLocENS_14SourceLocationE")]
                internal static extern void setStarLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal Loc);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ObjCObjectPointerTypeLoc> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ObjCObjectPointerTypeLoc>();

            private readonly bool __ownsNativeInstance;

            public static ObjCObjectPointerTypeLoc __CreateInstance(global::System.IntPtr native)
            {
                return new ObjCObjectPointerTypeLoc((ObjCObjectPointerTypeLoc.Internal*) native);
            }

            public static ObjCObjectPointerTypeLoc __CreateInstance(ObjCObjectPointerTypeLoc.Internal native)
            {
                return new ObjCObjectPointerTypeLoc(native);
            }

            private static ObjCObjectPointerTypeLoc.Internal* __CopyValue(ObjCObjectPointerTypeLoc.Internal native)
            {
                var ret = (ObjCObjectPointerTypeLoc.Internal*) Marshal.AllocHGlobal(0);
                *ret = native;
                return ret;
            }

            private ObjCObjectPointerTypeLoc(ObjCObjectPointerTypeLoc.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected ObjCObjectPointerTypeLoc(ObjCObjectPointerTypeLoc.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public ObjCObjectPointerTypeLoc()
            {
                __Instance = Marshal.AllocHGlobal(0);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.ObjCObjectPointerTypeLoc __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.SourceLocation getStarLoc()
            {
                var __ret = Internal.getStarLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setStarLoc(clang.SourceLocation Loc)
            {
                var arg0 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                Internal.setStarLoc_0(__Instance, arg0);
            }
        }

        public unsafe partial class ReferenceTypeLoc : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16ReferenceTypeLocC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16ReferenceTypeLocC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang16ReferenceTypeLoc12getInnerTypeEv")]
                internal static extern clang.QualType.Internal getInnerType_0(global::System.IntPtr instance);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ReferenceTypeLoc> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ReferenceTypeLoc>();

            private readonly bool __ownsNativeInstance;

            public static ReferenceTypeLoc __CreateInstance(global::System.IntPtr native)
            {
                return new ReferenceTypeLoc((ReferenceTypeLoc.Internal*) native);
            }

            public static ReferenceTypeLoc __CreateInstance(ReferenceTypeLoc.Internal native)
            {
                return new ReferenceTypeLoc(native);
            }

            private static ReferenceTypeLoc.Internal* __CopyValue(ReferenceTypeLoc.Internal native)
            {
                var ret = (ReferenceTypeLoc.Internal*) Marshal.AllocHGlobal(0);
                *ret = native;
                return ret;
            }

            private ReferenceTypeLoc(ReferenceTypeLoc.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected ReferenceTypeLoc(ReferenceTypeLoc.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public ReferenceTypeLoc()
            {
                __Instance = Marshal.AllocHGlobal(0);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.ReferenceTypeLoc __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.QualType getInnerType()
            {
                var __ret = Internal.getInnerType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }
        }

        public unsafe partial class LValueReferenceTypeLoc : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang22LValueReferenceTypeLocC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang22LValueReferenceTypeLocC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang22LValueReferenceTypeLoc9getAmpLocEv")]
                internal static extern clang.SourceLocation.Internal getAmpLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang22LValueReferenceTypeLoc9setAmpLocENS_14SourceLocationE")]
                internal static extern void setAmpLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal Loc);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, LValueReferenceTypeLoc> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, LValueReferenceTypeLoc>();

            private readonly bool __ownsNativeInstance;

            public static LValueReferenceTypeLoc __CreateInstance(global::System.IntPtr native)
            {
                return new LValueReferenceTypeLoc((LValueReferenceTypeLoc.Internal*) native);
            }

            public static LValueReferenceTypeLoc __CreateInstance(LValueReferenceTypeLoc.Internal native)
            {
                return new LValueReferenceTypeLoc(native);
            }

            private static LValueReferenceTypeLoc.Internal* __CopyValue(LValueReferenceTypeLoc.Internal native)
            {
                var ret = (LValueReferenceTypeLoc.Internal*) Marshal.AllocHGlobal(0);
                *ret = native;
                return ret;
            }

            private LValueReferenceTypeLoc(LValueReferenceTypeLoc.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected LValueReferenceTypeLoc(LValueReferenceTypeLoc.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public LValueReferenceTypeLoc()
            {
                __Instance = Marshal.AllocHGlobal(0);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.LValueReferenceTypeLoc __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.SourceLocation getAmpLoc()
            {
                var __ret = Internal.getAmpLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setAmpLoc(clang.SourceLocation Loc)
            {
                var arg0 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                Internal.setAmpLoc_0(__Instance, arg0);
            }
        }

        public unsafe partial class RValueReferenceTypeLoc : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang22RValueReferenceTypeLocC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang22RValueReferenceTypeLocC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang22RValueReferenceTypeLoc12getAmpAmpLocEv")]
                internal static extern clang.SourceLocation.Internal getAmpAmpLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang22RValueReferenceTypeLoc12setAmpAmpLocENS_14SourceLocationE")]
                internal static extern void setAmpAmpLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal Loc);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, RValueReferenceTypeLoc> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, RValueReferenceTypeLoc>();

            private readonly bool __ownsNativeInstance;

            public static RValueReferenceTypeLoc __CreateInstance(global::System.IntPtr native)
            {
                return new RValueReferenceTypeLoc((RValueReferenceTypeLoc.Internal*) native);
            }

            public static RValueReferenceTypeLoc __CreateInstance(RValueReferenceTypeLoc.Internal native)
            {
                return new RValueReferenceTypeLoc(native);
            }

            private static RValueReferenceTypeLoc.Internal* __CopyValue(RValueReferenceTypeLoc.Internal native)
            {
                var ret = (RValueReferenceTypeLoc.Internal*) Marshal.AllocHGlobal(0);
                *ret = native;
                return ret;
            }

            private RValueReferenceTypeLoc(RValueReferenceTypeLoc.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected RValueReferenceTypeLoc(RValueReferenceTypeLoc.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public RValueReferenceTypeLoc()
            {
                __Instance = Marshal.AllocHGlobal(0);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.RValueReferenceTypeLoc __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.SourceLocation getAmpAmpLoc()
            {
                var __ret = Internal.getAmpAmpLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setAmpAmpLoc(clang.SourceLocation Loc)
            {
                var arg0 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                Internal.setAmpAmpLoc_0(__Instance, arg0);
            }
        }

        public unsafe partial class FunctionLocInfo : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public clang.SourceLocation.Internal LocalRangeBegin;

                [FieldOffset(4)]
                public clang.SourceLocation.Internal LParenLoc;

                [FieldOffset(8)]
                public clang.SourceLocation.Internal RParenLoc;

                [FieldOffset(12)]
                public clang.SourceLocation.Internal LocalRangeEnd;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang15FunctionLocInfoC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang15FunctionLocInfoC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, FunctionLocInfo> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, FunctionLocInfo>();

            private readonly bool __ownsNativeInstance;

            public static FunctionLocInfo __CreateInstance(global::System.IntPtr native)
            {
                return new FunctionLocInfo((FunctionLocInfo.Internal*) native);
            }

            public static FunctionLocInfo __CreateInstance(FunctionLocInfo.Internal native)
            {
                return new FunctionLocInfo(native);
            }

            private static FunctionLocInfo.Internal* __CopyValue(FunctionLocInfo.Internal native)
            {
                var ret = (FunctionLocInfo.Internal*) Marshal.AllocHGlobal(16);
                *ret = native;
                return ret;
            }

            private FunctionLocInfo(FunctionLocInfo.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected FunctionLocInfo(FunctionLocInfo.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public FunctionLocInfo()
            {
                __Instance = Marshal.AllocHGlobal(16);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.FunctionLocInfo __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.SourceLocation LocalRangeBegin
            {
                get
                {
                    return clang.SourceLocation.__CreateInstance(((Internal*) __Instance)->LocalRangeBegin);
                }

                set
                {
                    ((Internal*) __Instance)->LocalRangeBegin = ReferenceEquals(value, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (value.__Instance);
                }
            }

            public clang.SourceLocation LParenLoc
            {
                get
                {
                    return clang.SourceLocation.__CreateInstance(((Internal*) __Instance)->LParenLoc);
                }

                set
                {
                    ((Internal*) __Instance)->LParenLoc = ReferenceEquals(value, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (value.__Instance);
                }
            }

            public clang.SourceLocation RParenLoc
            {
                get
                {
                    return clang.SourceLocation.__CreateInstance(((Internal*) __Instance)->RParenLoc);
                }

                set
                {
                    ((Internal*) __Instance)->RParenLoc = ReferenceEquals(value, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (value.__Instance);
                }
            }

            public clang.SourceLocation LocalRangeEnd
            {
                get
                {
                    return clang.SourceLocation.__CreateInstance(((Internal*) __Instance)->LocalRangeEnd);
                }

                set
                {
                    ((Internal*) __Instance)->LocalRangeEnd = ReferenceEquals(value, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (value.__Instance);
                }
            }
        }

        /// <summary>
        /// <para>Wrapper for source info for functions.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief Wrapper for source info for functions.</para>
        /// </remarks>
        public unsafe partial class FunctionTypeLoc : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang15FunctionTypeLocC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang15FunctionTypeLocC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang15FunctionTypeLoc18getLocalRangeBeginEv")]
                internal static extern clang.SourceLocation.Internal getLocalRangeBegin_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang15FunctionTypeLoc18setLocalRangeBeginENS_14SourceLocationE")]
                internal static extern void setLocalRangeBegin_0(global::System.IntPtr instance, clang.SourceLocation.Internal L);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang15FunctionTypeLoc16getLocalRangeEndEv")]
                internal static extern clang.SourceLocation.Internal getLocalRangeEnd_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang15FunctionTypeLoc16setLocalRangeEndENS_14SourceLocationE")]
                internal static extern void setLocalRangeEnd_0(global::System.IntPtr instance, clang.SourceLocation.Internal L);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang15FunctionTypeLoc12getLParenLocEv")]
                internal static extern clang.SourceLocation.Internal getLParenLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang15FunctionTypeLoc12setLParenLocENS_14SourceLocationE")]
                internal static extern void setLParenLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal Loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang15FunctionTypeLoc12getRParenLocEv")]
                internal static extern clang.SourceLocation.Internal getRParenLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang15FunctionTypeLoc12setRParenLocENS_14SourceLocationE")]
                internal static extern void setRParenLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal Loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang15FunctionTypeLoc14getParensRangeEv")]
                internal static extern clang.SourceRange.Internal getParensRange_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang15FunctionTypeLoc12getParmArrayEv")]
                internal static extern global::System.IntPtr getParmArray_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang15FunctionTypeLoc12getNumParamsEv")]
                internal static extern uint getNumParams_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang15FunctionTypeLoc8getParamEj")]
                internal static extern global::System.IntPtr getParam_0(global::System.IntPtr instance, uint i);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang15FunctionTypeLoc8setParamEjPNS_11ParmVarDeclE")]
                internal static extern void setParam_0(global::System.IntPtr instance, uint i, global::System.IntPtr VD);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang15FunctionTypeLoc12getReturnLocEv")]
                internal static extern clang.TypeLoc.Internal getReturnLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang15FunctionTypeLoc19getLocalSourceRangeEv")]
                internal static extern clang.SourceRange.Internal getLocalSourceRange_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang15FunctionTypeLoc15initializeLocalERNS_10ASTContextENS_14SourceLocationE")]
                internal static extern void initializeLocal_0(global::System.IntPtr instance, global::System.IntPtr Context, clang.SourceLocation.Internal Loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang15FunctionTypeLoc21getExtraLocalDataSizeEv")]
                internal static extern uint getExtraLocalDataSize_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang15FunctionTypeLoc26getExtraLocalDataAlignmentEv")]
                internal static extern uint getExtraLocalDataAlignment_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang15FunctionTypeLoc12getInnerTypeEv")]
                internal static extern clang.QualType.Internal getInnerType_0(global::System.IntPtr instance);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, FunctionTypeLoc> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, FunctionTypeLoc>();

            private readonly bool __ownsNativeInstance;

            public static FunctionTypeLoc __CreateInstance(global::System.IntPtr native)
            {
                return new FunctionTypeLoc((FunctionTypeLoc.Internal*) native);
            }

            public static FunctionTypeLoc __CreateInstance(FunctionTypeLoc.Internal native)
            {
                return new FunctionTypeLoc(native);
            }

            private static FunctionTypeLoc.Internal* __CopyValue(FunctionTypeLoc.Internal native)
            {
                var ret = (FunctionTypeLoc.Internal*) Marshal.AllocHGlobal(0);
                *ret = native;
                return ret;
            }

            private FunctionTypeLoc(FunctionTypeLoc.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected FunctionTypeLoc(FunctionTypeLoc.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public FunctionTypeLoc()
            {
                __Instance = Marshal.AllocHGlobal(0);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.FunctionTypeLoc __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.SourceLocation getLocalRangeBegin()
            {
                var __ret = Internal.getLocalRangeBegin_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setLocalRangeBegin(clang.SourceLocation L)
            {
                var arg0 = ReferenceEquals(L, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (L.__Instance);
                Internal.setLocalRangeBegin_0(__Instance, arg0);
            }

            public clang.SourceLocation getLocalRangeEnd()
            {
                var __ret = Internal.getLocalRangeEnd_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setLocalRangeEnd(clang.SourceLocation L)
            {
                var arg0 = ReferenceEquals(L, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (L.__Instance);
                Internal.setLocalRangeEnd_0(__Instance, arg0);
            }

            public clang.SourceLocation getLParenLoc()
            {
                var __ret = Internal.getLParenLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setLParenLoc(clang.SourceLocation Loc)
            {
                var arg0 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                Internal.setLParenLoc_0(__Instance, arg0);
            }

            public clang.SourceLocation getRParenLoc()
            {
                var __ret = Internal.getRParenLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setRParenLoc(clang.SourceLocation Loc)
            {
                var arg0 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                Internal.setRParenLoc_0(__Instance, arg0);
            }

            public clang.SourceRange getParensRange()
            {
                var __ret = Internal.getParensRange_0(__Instance);
                return clang.SourceRange.__CreateInstance(__ret);
            }

            public clang.ParmVarDecl getParmArray()
            {
                var __ret = Internal.getParmArray_0(__Instance);
                clang.ParmVarDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.ParmVarDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.ParmVarDecl) clang.ParmVarDecl.NativeToManagedMap[__ret];
                else clang.ParmVarDecl.NativeToManagedMap[__ret] = __result0 = (clang.ParmVarDecl) clang.ParmVarDecl.__CreateInstance(__ret);
                return __result0;
            }

            public uint getNumParams()
            {
                var __ret = Internal.getNumParams_0(__Instance);
                return __ret;
            }

            public clang.ParmVarDecl getParam(uint i)
            {
                var __ret = Internal.getParam_0(__Instance, i);
                clang.ParmVarDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.ParmVarDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.ParmVarDecl) clang.ParmVarDecl.NativeToManagedMap[__ret];
                else clang.ParmVarDecl.NativeToManagedMap[__ret] = __result0 = (clang.ParmVarDecl) clang.ParmVarDecl.__CreateInstance(__ret);
                return __result0;
            }

            public void setParam(uint i, clang.ParmVarDecl VD)
            {
                var arg1 = ReferenceEquals(VD, null) ? global::System.IntPtr.Zero : VD.__Instance;
                Internal.setParam_0(__Instance, i, arg1);
            }

            public clang.TypeLoc getReturnLoc()
            {
                var __ret = Internal.getReturnLoc_0(__Instance);
                return clang.TypeLoc.__CreateInstance(__ret);
            }

            public clang.SourceRange getLocalSourceRange()
            {
                var __ret = Internal.getLocalSourceRange_0(__Instance);
                return clang.SourceRange.__CreateInstance(__ret);
            }

            public void initializeLocal(clang.ASTContext Context, clang.SourceLocation Loc)
            {
                var arg0 = ReferenceEquals(Context, null) ? global::System.IntPtr.Zero : Context.__Instance;
                var arg1 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                Internal.initializeLocal_0(__Instance, arg0, arg1);
            }

            /// <summary>
            /// <para>Returns the size of the type source info data block that is
            /// specific to this type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Returns the size of the type source info data block
            /// that is</para>
            /// <para>  /// specific to this type.</para>
            /// </remarks>
            public uint getExtraLocalDataSize()
            {
                var __ret = Internal.getExtraLocalDataSize_0(__Instance);
                return __ret;
            }

            public uint getExtraLocalDataAlignment()
            {
                var __ret = Internal.getExtraLocalDataAlignment_0(__Instance);
                return __ret;
            }

            public clang.QualType getInnerType()
            {
                var __ret = Internal.getInnerType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }
        }

        public unsafe partial class FunctionProtoTypeLoc : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang20FunctionProtoTypeLocC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang20FunctionProtoTypeLocC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, FunctionProtoTypeLoc> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, FunctionProtoTypeLoc>();

            private readonly bool __ownsNativeInstance;

            public static FunctionProtoTypeLoc __CreateInstance(global::System.IntPtr native)
            {
                return new FunctionProtoTypeLoc((FunctionProtoTypeLoc.Internal*) native);
            }

            public static FunctionProtoTypeLoc __CreateInstance(FunctionProtoTypeLoc.Internal native)
            {
                return new FunctionProtoTypeLoc(native);
            }

            private static FunctionProtoTypeLoc.Internal* __CopyValue(FunctionProtoTypeLoc.Internal native)
            {
                var ret = (FunctionProtoTypeLoc.Internal*) Marshal.AllocHGlobal(0);
                *ret = native;
                return ret;
            }

            private FunctionProtoTypeLoc(FunctionProtoTypeLoc.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected FunctionProtoTypeLoc(FunctionProtoTypeLoc.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public FunctionProtoTypeLoc()
            {
                __Instance = Marshal.AllocHGlobal(0);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.FunctionProtoTypeLoc __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }
        }

        public unsafe partial class FunctionNoProtoTypeLoc : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang22FunctionNoProtoTypeLocC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang22FunctionNoProtoTypeLocC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, FunctionNoProtoTypeLoc> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, FunctionNoProtoTypeLoc>();

            private readonly bool __ownsNativeInstance;

            public static FunctionNoProtoTypeLoc __CreateInstance(global::System.IntPtr native)
            {
                return new FunctionNoProtoTypeLoc((FunctionNoProtoTypeLoc.Internal*) native);
            }

            public static FunctionNoProtoTypeLoc __CreateInstance(FunctionNoProtoTypeLoc.Internal native)
            {
                return new FunctionNoProtoTypeLoc(native);
            }

            private static FunctionNoProtoTypeLoc.Internal* __CopyValue(FunctionNoProtoTypeLoc.Internal native)
            {
                var ret = (FunctionNoProtoTypeLoc.Internal*) Marshal.AllocHGlobal(0);
                *ret = native;
                return ret;
            }

            private FunctionNoProtoTypeLoc(FunctionNoProtoTypeLoc.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected FunctionNoProtoTypeLoc(FunctionNoProtoTypeLoc.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public FunctionNoProtoTypeLoc()
            {
                __Instance = Marshal.AllocHGlobal(0);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.FunctionNoProtoTypeLoc __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }
        }

        public unsafe partial class ArrayLocInfo : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 12)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public clang.SourceLocation.Internal LBracketLoc;

                [FieldOffset(4)]
                public clang.SourceLocation.Internal RBracketLoc;

                [FieldOffset(8)]
                public global::System.IntPtr Size;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12ArrayLocInfoC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12ArrayLocInfoC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ArrayLocInfo> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ArrayLocInfo>();

            private readonly bool __ownsNativeInstance;

            public static ArrayLocInfo __CreateInstance(global::System.IntPtr native)
            {
                return new ArrayLocInfo((ArrayLocInfo.Internal*) native);
            }

            public static ArrayLocInfo __CreateInstance(ArrayLocInfo.Internal native)
            {
                return new ArrayLocInfo(native);
            }

            private static ArrayLocInfo.Internal* __CopyValue(ArrayLocInfo.Internal native)
            {
                var ret = (ArrayLocInfo.Internal*) Marshal.AllocHGlobal(12);
                *ret = native;
                return ret;
            }

            private ArrayLocInfo(ArrayLocInfo.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected ArrayLocInfo(ArrayLocInfo.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public ArrayLocInfo()
            {
                __Instance = Marshal.AllocHGlobal(12);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.ArrayLocInfo __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.SourceLocation LBracketLoc
            {
                get
                {
                    return clang.SourceLocation.__CreateInstance(((Internal*) __Instance)->LBracketLoc);
                }

                set
                {
                    ((Internal*) __Instance)->LBracketLoc = ReferenceEquals(value, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (value.__Instance);
                }
            }

            public clang.SourceLocation RBracketLoc
            {
                get
                {
                    return clang.SourceLocation.__CreateInstance(((Internal*) __Instance)->RBracketLoc);
                }

                set
                {
                    ((Internal*) __Instance)->RBracketLoc = ReferenceEquals(value, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (value.__Instance);
                }
            }
        }

        /// <summary>
        /// <para>Wrapper for source info for arrays.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief Wrapper for source info for arrays.</para>
        /// </remarks>
        public unsafe partial class ArrayTypeLoc : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12ArrayTypeLocC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12ArrayTypeLocC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12ArrayTypeLoc14getLBracketLocEv")]
                internal static extern clang.SourceLocation.Internal getLBracketLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12ArrayTypeLoc14setLBracketLocENS_14SourceLocationE")]
                internal static extern void setLBracketLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal Loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12ArrayTypeLoc14getRBracketLocEv")]
                internal static extern clang.SourceLocation.Internal getRBracketLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12ArrayTypeLoc14setRBracketLocENS_14SourceLocationE")]
                internal static extern void setRBracketLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal Loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12ArrayTypeLoc16getBracketsRangeEv")]
                internal static extern clang.SourceRange.Internal getBracketsRange_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12ArrayTypeLoc13getElementLocEv")]
                internal static extern clang.TypeLoc.Internal getElementLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12ArrayTypeLoc19getLocalSourceRangeEv")]
                internal static extern clang.SourceRange.Internal getLocalSourceRange_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12ArrayTypeLoc15initializeLocalERNS_10ASTContextENS_14SourceLocationE")]
                internal static extern void initializeLocal_0(global::System.IntPtr instance, global::System.IntPtr Context, clang.SourceLocation.Internal Loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12ArrayTypeLoc12getInnerTypeEv")]
                internal static extern clang.QualType.Internal getInnerType_0(global::System.IntPtr instance);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ArrayTypeLoc> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ArrayTypeLoc>();

            private readonly bool __ownsNativeInstance;

            public static ArrayTypeLoc __CreateInstance(global::System.IntPtr native)
            {
                return new ArrayTypeLoc((ArrayTypeLoc.Internal*) native);
            }

            public static ArrayTypeLoc __CreateInstance(ArrayTypeLoc.Internal native)
            {
                return new ArrayTypeLoc(native);
            }

            private static ArrayTypeLoc.Internal* __CopyValue(ArrayTypeLoc.Internal native)
            {
                var ret = (ArrayTypeLoc.Internal*) Marshal.AllocHGlobal(0);
                *ret = native;
                return ret;
            }

            private ArrayTypeLoc(ArrayTypeLoc.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected ArrayTypeLoc(ArrayTypeLoc.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public ArrayTypeLoc()
            {
                __Instance = Marshal.AllocHGlobal(0);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.ArrayTypeLoc __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.SourceLocation getLBracketLoc()
            {
                var __ret = Internal.getLBracketLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setLBracketLoc(clang.SourceLocation Loc)
            {
                var arg0 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                Internal.setLBracketLoc_0(__Instance, arg0);
            }

            public clang.SourceLocation getRBracketLoc()
            {
                var __ret = Internal.getRBracketLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setRBracketLoc(clang.SourceLocation Loc)
            {
                var arg0 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                Internal.setRBracketLoc_0(__Instance, arg0);
            }

            public clang.SourceRange getBracketsRange()
            {
                var __ret = Internal.getBracketsRange_0(__Instance);
                return clang.SourceRange.__CreateInstance(__ret);
            }

            public clang.TypeLoc getElementLoc()
            {
                var __ret = Internal.getElementLoc_0(__Instance);
                return clang.TypeLoc.__CreateInstance(__ret);
            }

            public clang.SourceRange getLocalSourceRange()
            {
                var __ret = Internal.getLocalSourceRange_0(__Instance);
                return clang.SourceRange.__CreateInstance(__ret);
            }

            public void initializeLocal(clang.ASTContext Context, clang.SourceLocation Loc)
            {
                var arg0 = ReferenceEquals(Context, null) ? global::System.IntPtr.Zero : Context.__Instance;
                var arg1 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                Internal.initializeLocal_0(__Instance, arg0, arg1);
            }

            public clang.QualType getInnerType()
            {
                var __ret = Internal.getInnerType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }
        }

        public unsafe partial class ConstantArrayTypeLoc : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang20ConstantArrayTypeLocC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang20ConstantArrayTypeLocC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ConstantArrayTypeLoc> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ConstantArrayTypeLoc>();

            private readonly bool __ownsNativeInstance;

            public static ConstantArrayTypeLoc __CreateInstance(global::System.IntPtr native)
            {
                return new ConstantArrayTypeLoc((ConstantArrayTypeLoc.Internal*) native);
            }

            public static ConstantArrayTypeLoc __CreateInstance(ConstantArrayTypeLoc.Internal native)
            {
                return new ConstantArrayTypeLoc(native);
            }

            private static ConstantArrayTypeLoc.Internal* __CopyValue(ConstantArrayTypeLoc.Internal native)
            {
                var ret = (ConstantArrayTypeLoc.Internal*) Marshal.AllocHGlobal(0);
                *ret = native;
                return ret;
            }

            private ConstantArrayTypeLoc(ConstantArrayTypeLoc.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected ConstantArrayTypeLoc(ConstantArrayTypeLoc.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public ConstantArrayTypeLoc()
            {
                __Instance = Marshal.AllocHGlobal(0);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.ConstantArrayTypeLoc __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }
        }

        public unsafe partial class IncompleteArrayTypeLoc : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang22IncompleteArrayTypeLocC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang22IncompleteArrayTypeLocC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, IncompleteArrayTypeLoc> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, IncompleteArrayTypeLoc>();

            private readonly bool __ownsNativeInstance;

            public static IncompleteArrayTypeLoc __CreateInstance(global::System.IntPtr native)
            {
                return new IncompleteArrayTypeLoc((IncompleteArrayTypeLoc.Internal*) native);
            }

            public static IncompleteArrayTypeLoc __CreateInstance(IncompleteArrayTypeLoc.Internal native)
            {
                return new IncompleteArrayTypeLoc(native);
            }

            private static IncompleteArrayTypeLoc.Internal* __CopyValue(IncompleteArrayTypeLoc.Internal native)
            {
                var ret = (IncompleteArrayTypeLoc.Internal*) Marshal.AllocHGlobal(0);
                *ret = native;
                return ret;
            }

            private IncompleteArrayTypeLoc(IncompleteArrayTypeLoc.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected IncompleteArrayTypeLoc(IncompleteArrayTypeLoc.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public IncompleteArrayTypeLoc()
            {
                __Instance = Marshal.AllocHGlobal(0);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.IncompleteArrayTypeLoc __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }
        }

        public unsafe partial class DependentSizedArrayTypeLoc : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang26DependentSizedArrayTypeLocC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang26DependentSizedArrayTypeLocC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, DependentSizedArrayTypeLoc> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, DependentSizedArrayTypeLoc>();

            private readonly bool __ownsNativeInstance;

            public static DependentSizedArrayTypeLoc __CreateInstance(global::System.IntPtr native)
            {
                return new DependentSizedArrayTypeLoc((DependentSizedArrayTypeLoc.Internal*) native);
            }

            public static DependentSizedArrayTypeLoc __CreateInstance(DependentSizedArrayTypeLoc.Internal native)
            {
                return new DependentSizedArrayTypeLoc(native);
            }

            private static DependentSizedArrayTypeLoc.Internal* __CopyValue(DependentSizedArrayTypeLoc.Internal native)
            {
                var ret = (DependentSizedArrayTypeLoc.Internal*) Marshal.AllocHGlobal(0);
                *ret = native;
                return ret;
            }

            private DependentSizedArrayTypeLoc(DependentSizedArrayTypeLoc.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected DependentSizedArrayTypeLoc(DependentSizedArrayTypeLoc.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public DependentSizedArrayTypeLoc()
            {
                __Instance = Marshal.AllocHGlobal(0);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.DependentSizedArrayTypeLoc __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }
        }

        public unsafe partial class VariableArrayTypeLoc : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang20VariableArrayTypeLocC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang20VariableArrayTypeLocC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, VariableArrayTypeLoc> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, VariableArrayTypeLoc>();

            private readonly bool __ownsNativeInstance;

            public static VariableArrayTypeLoc __CreateInstance(global::System.IntPtr native)
            {
                return new VariableArrayTypeLoc((VariableArrayTypeLoc.Internal*) native);
            }

            public static VariableArrayTypeLoc __CreateInstance(VariableArrayTypeLoc.Internal native)
            {
                return new VariableArrayTypeLoc(native);
            }

            private static VariableArrayTypeLoc.Internal* __CopyValue(VariableArrayTypeLoc.Internal native)
            {
                var ret = (VariableArrayTypeLoc.Internal*) Marshal.AllocHGlobal(0);
                *ret = native;
                return ret;
            }

            private VariableArrayTypeLoc(VariableArrayTypeLoc.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected VariableArrayTypeLoc(VariableArrayTypeLoc.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public VariableArrayTypeLoc()
            {
                __Instance = Marshal.AllocHGlobal(0);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.VariableArrayTypeLoc __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }
        }

        public unsafe partial class TemplateNameLocInfo : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 4)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public clang.SourceLocation.Internal NameLoc;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang19TemplateNameLocInfoC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang19TemplateNameLocInfoC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, TemplateNameLocInfo> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, TemplateNameLocInfo>();

            private readonly bool __ownsNativeInstance;

            public static TemplateNameLocInfo __CreateInstance(global::System.IntPtr native)
            {
                return new TemplateNameLocInfo((TemplateNameLocInfo.Internal*) native);
            }

            public static TemplateNameLocInfo __CreateInstance(TemplateNameLocInfo.Internal native)
            {
                return new TemplateNameLocInfo(native);
            }

            private static TemplateNameLocInfo.Internal* __CopyValue(TemplateNameLocInfo.Internal native)
            {
                var ret = (TemplateNameLocInfo.Internal*) Marshal.AllocHGlobal(4);
                *ret = native;
                return ret;
            }

            private TemplateNameLocInfo(TemplateNameLocInfo.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected TemplateNameLocInfo(TemplateNameLocInfo.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public TemplateNameLocInfo()
            {
                __Instance = Marshal.AllocHGlobal(4);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.TemplateNameLocInfo __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.SourceLocation NameLoc
            {
                get
                {
                    return clang.SourceLocation.__CreateInstance(((Internal*) __Instance)->NameLoc);
                }

                set
                {
                    ((Internal*) __Instance)->NameLoc = ReferenceEquals(value, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (value.__Instance);
                }
            }
        }

        public unsafe partial class TemplateSpecializationLocInfo : clang.TemplateNameLocInfo, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                public clang.SourceLocation.Internal NameLoc;

                [FieldOffset(4)]
                public clang.SourceLocation.Internal TemplateKWLoc;

                [FieldOffset(8)]
                public clang.SourceLocation.Internal LAngleLoc;

                [FieldOffset(12)]
                public clang.SourceLocation.Internal RAngleLoc;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang29TemplateSpecializationLocInfoC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang29TemplateSpecializationLocInfoC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
            }

            private readonly bool __ownsNativeInstance;

            public static new TemplateSpecializationLocInfo __CreateInstance(global::System.IntPtr native)
            {
                return new TemplateSpecializationLocInfo((TemplateSpecializationLocInfo.Internal*) native);
            }

            public static TemplateSpecializationLocInfo __CreateInstance(TemplateSpecializationLocInfo.Internal native)
            {
                return new TemplateSpecializationLocInfo(native);
            }

            private static TemplateSpecializationLocInfo.Internal* __CopyValue(TemplateSpecializationLocInfo.Internal native)
            {
                var ret = (TemplateSpecializationLocInfo.Internal*) Marshal.AllocHGlobal(16);
                *ret = native;
                return ret;
            }

            private TemplateSpecializationLocInfo(TemplateSpecializationLocInfo.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected TemplateSpecializationLocInfo(TemplateSpecializationLocInfo.Internal* native, bool isInternalImpl = false)
                : base((clang.TemplateNameLocInfo.Internal*) native)
            {
            }

            public TemplateSpecializationLocInfo()
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(16);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.TemplateNameLocInfo __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.SourceLocation TemplateKWLoc
            {
                get
                {
                    return clang.SourceLocation.__CreateInstance(((Internal*) __Instance)->TemplateKWLoc);
                }

                set
                {
                    ((Internal*) __Instance)->TemplateKWLoc = ReferenceEquals(value, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (value.__Instance);
                }
            }

            public clang.SourceLocation LAngleLoc
            {
                get
                {
                    return clang.SourceLocation.__CreateInstance(((Internal*) __Instance)->LAngleLoc);
                }

                set
                {
                    ((Internal*) __Instance)->LAngleLoc = ReferenceEquals(value, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (value.__Instance);
                }
            }

            public clang.SourceLocation RAngleLoc
            {
                get
                {
                    return clang.SourceLocation.__CreateInstance(((Internal*) __Instance)->RAngleLoc);
                }

                set
                {
                    ((Internal*) __Instance)->RAngleLoc = ReferenceEquals(value, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (value.__Instance);
                }
            }
        }

        public unsafe partial class TemplateSpecializationTypeLoc : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang29TemplateSpecializationTypeLocC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang29TemplateSpecializationTypeLocC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang29TemplateSpecializationTypeLoc21getTemplateKeywordLocEv")]
                internal static extern clang.SourceLocation.Internal getTemplateKeywordLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang29TemplateSpecializationTypeLoc21setTemplateKeywordLocENS_14SourceLocationE")]
                internal static extern void setTemplateKeywordLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal Loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang29TemplateSpecializationTypeLoc12getLAngleLocEv")]
                internal static extern clang.SourceLocation.Internal getLAngleLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang29TemplateSpecializationTypeLoc12setLAngleLocENS_14SourceLocationE")]
                internal static extern void setLAngleLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal Loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang29TemplateSpecializationTypeLoc12getRAngleLocEv")]
                internal static extern clang.SourceLocation.Internal getRAngleLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang29TemplateSpecializationTypeLoc12setRAngleLocENS_14SourceLocationE")]
                internal static extern void setRAngleLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal Loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang29TemplateSpecializationTypeLoc10getNumArgsEv")]
                internal static extern uint getNumArgs_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang29TemplateSpecializationTypeLoc13setArgLocInfoEjNS_23TemplateArgumentLocInfoE")]
                internal static extern void setArgLocInfo_0(global::System.IntPtr instance, uint i, clang.TemplateArgumentLocInfo.Internal AI);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang29TemplateSpecializationTypeLoc13getArgLocInfoEj")]
                internal static extern void getArgLocInfo_0(global::System.IntPtr @return, global::System.IntPtr instance, uint i);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang29TemplateSpecializationTypeLoc9getArgLocEj")]
                internal static extern void getArgLoc_0(global::System.IntPtr @return, global::System.IntPtr instance, uint i);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang29TemplateSpecializationTypeLoc18getTemplateNameLocEv")]
                internal static extern clang.SourceLocation.Internal getTemplateNameLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang29TemplateSpecializationTypeLoc18setTemplateNameLocENS_14SourceLocationE")]
                internal static extern void setTemplateNameLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal Loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang29TemplateSpecializationTypeLoc4copyES0_")]
                internal static extern void copy_0(global::System.IntPtr instance, clang.TemplateSpecializationTypeLoc.Internal Loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang29TemplateSpecializationTypeLoc19getLocalSourceRangeEv")]
                internal static extern clang.SourceRange.Internal getLocalSourceRange_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang29TemplateSpecializationTypeLoc15initializeLocalERNS_10ASTContextENS_14SourceLocationE")]
                internal static extern void initializeLocal_0(global::System.IntPtr instance, global::System.IntPtr Context, clang.SourceLocation.Internal Loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang29TemplateSpecializationTypeLoc17initializeArgLocsERNS_10ASTContextEjPKNS_16TemplateArgumentEPNS_23TemplateArgumentLocInfoENS_14SourceLocationE")]
                internal static extern void initializeArgLocs_0(global::System.IntPtr Context, uint NumArgs, global::System.IntPtr Args, global::System.IntPtr ArgInfos, clang.SourceLocation.Internal Loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang29TemplateSpecializationTypeLoc21getExtraLocalDataSizeEv")]
                internal static extern uint getExtraLocalDataSize_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang29TemplateSpecializationTypeLoc26getExtraLocalDataAlignmentEv")]
                internal static extern uint getExtraLocalDataAlignment_0(global::System.IntPtr instance);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, TemplateSpecializationTypeLoc> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, TemplateSpecializationTypeLoc>();

            private readonly bool __ownsNativeInstance;

            public static TemplateSpecializationTypeLoc __CreateInstance(global::System.IntPtr native)
            {
                return new TemplateSpecializationTypeLoc((TemplateSpecializationTypeLoc.Internal*) native);
            }

            public static TemplateSpecializationTypeLoc __CreateInstance(TemplateSpecializationTypeLoc.Internal native)
            {
                return new TemplateSpecializationTypeLoc(native);
            }

            private static TemplateSpecializationTypeLoc.Internal* __CopyValue(TemplateSpecializationTypeLoc.Internal native)
            {
                var ret = (TemplateSpecializationTypeLoc.Internal*) Marshal.AllocHGlobal(0);
                *ret = native;
                return ret;
            }

            private TemplateSpecializationTypeLoc(TemplateSpecializationTypeLoc.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected TemplateSpecializationTypeLoc(TemplateSpecializationTypeLoc.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public TemplateSpecializationTypeLoc()
            {
                __Instance = Marshal.AllocHGlobal(0);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.TemplateSpecializationTypeLoc __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.SourceLocation getTemplateKeywordLoc()
            {
                var __ret = Internal.getTemplateKeywordLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setTemplateKeywordLoc(clang.SourceLocation Loc)
            {
                var arg0 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                Internal.setTemplateKeywordLoc_0(__Instance, arg0);
            }

            public clang.SourceLocation getLAngleLoc()
            {
                var __ret = Internal.getLAngleLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setLAngleLoc(clang.SourceLocation Loc)
            {
                var arg0 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                Internal.setLAngleLoc_0(__Instance, arg0);
            }

            public clang.SourceLocation getRAngleLoc()
            {
                var __ret = Internal.getRAngleLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setRAngleLoc(clang.SourceLocation Loc)
            {
                var arg0 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                Internal.setRAngleLoc_0(__Instance, arg0);
            }

            public uint getNumArgs()
            {
                var __ret = Internal.getNumArgs_0(__Instance);
                return __ret;
            }

            public void setArgLocInfo(uint i, clang.TemplateArgumentLocInfo AI)
            {
                var arg1 = ReferenceEquals(AI, null) ? new clang.TemplateArgumentLocInfo.Internal() : *(clang.TemplateArgumentLocInfo.Internal*) (AI.__Instance);
                Internal.setArgLocInfo_0(__Instance, i, arg1);
            }

            public clang.TemplateArgumentLocInfo getArgLocInfo(uint i)
            {
                var __ret = new clang.TemplateArgumentLocInfo.Internal();
                Internal.getArgLocInfo_0(new IntPtr(&__ret), __Instance, i);
                return clang.TemplateArgumentLocInfo.__CreateInstance(__ret);
            }

            public clang.TemplateArgumentLoc getArgLoc(uint i)
            {
                var __ret = new clang.TemplateArgumentLoc.Internal();
                Internal.getArgLoc_0(new IntPtr(&__ret), __Instance, i);
                return clang.TemplateArgumentLoc.__CreateInstance(__ret);
            }

            public clang.SourceLocation getTemplateNameLoc()
            {
                var __ret = Internal.getTemplateNameLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setTemplateNameLoc(clang.SourceLocation Loc)
            {
                var arg0 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                Internal.setTemplateNameLoc_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>- Copy the location information from the given info.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief - Copy the location information from the given
            /// info.</para>
            /// </remarks>
            public void copy(clang.TemplateSpecializationTypeLoc Loc)
            {
                var arg0 = ReferenceEquals(Loc, null) ? new clang.TemplateSpecializationTypeLoc.Internal() : *(clang.TemplateSpecializationTypeLoc.Internal*) (Loc.__Instance);
                Internal.copy_0(__Instance, arg0);
            }

            public clang.SourceRange getLocalSourceRange()
            {
                var __ret = Internal.getLocalSourceRange_0(__Instance);
                return clang.SourceRange.__CreateInstance(__ret);
            }

            public void initializeLocal(clang.ASTContext Context, clang.SourceLocation Loc)
            {
                var arg0 = ReferenceEquals(Context, null) ? global::System.IntPtr.Zero : Context.__Instance;
                var arg1 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                Internal.initializeLocal_0(__Instance, arg0, arg1);
            }

            public uint getExtraLocalDataSize()
            {
                var __ret = Internal.getExtraLocalDataSize_0(__Instance);
                return __ret;
            }

            public uint getExtraLocalDataAlignment()
            {
                var __ret = Internal.getExtraLocalDataAlignment_0(__Instance);
                return __ret;
            }

            public static void initializeArgLocs(clang.ASTContext Context, uint NumArgs, clang.TemplateArgument Args, clang.TemplateArgumentLocInfo ArgInfos, clang.SourceLocation Loc)
            {
                var arg0 = ReferenceEquals(Context, null) ? global::System.IntPtr.Zero : Context.__Instance;
                var arg2 = ReferenceEquals(Args, null) ? global::System.IntPtr.Zero : Args.__Instance;
                var arg3 = ReferenceEquals(ArgInfos, null) ? global::System.IntPtr.Zero : ArgInfos.__Instance;
                var arg4 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                Internal.initializeArgLocs_0(arg0, NumArgs, arg2, arg3, arg4);
            }
        }

        public unsafe partial class VectorTypeLoc : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13VectorTypeLocC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13VectorTypeLocC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, VectorTypeLoc> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, VectorTypeLoc>();

            private readonly bool __ownsNativeInstance;

            public static VectorTypeLoc __CreateInstance(global::System.IntPtr native)
            {
                return new VectorTypeLoc((VectorTypeLoc.Internal*) native);
            }

            public static VectorTypeLoc __CreateInstance(VectorTypeLoc.Internal native)
            {
                return new VectorTypeLoc(native);
            }

            private static VectorTypeLoc.Internal* __CopyValue(VectorTypeLoc.Internal native)
            {
                var ret = (VectorTypeLoc.Internal*) Marshal.AllocHGlobal(0);
                *ret = native;
                return ret;
            }

            private VectorTypeLoc(VectorTypeLoc.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected VectorTypeLoc(VectorTypeLoc.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public VectorTypeLoc()
            {
                __Instance = Marshal.AllocHGlobal(0);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.VectorTypeLoc __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }
        }

        public unsafe partial class ExtVectorTypeLoc : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16ExtVectorTypeLocC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16ExtVectorTypeLocC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ExtVectorTypeLoc> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ExtVectorTypeLoc>();

            private readonly bool __ownsNativeInstance;

            public static ExtVectorTypeLoc __CreateInstance(global::System.IntPtr native)
            {
                return new ExtVectorTypeLoc((ExtVectorTypeLoc.Internal*) native);
            }

            public static ExtVectorTypeLoc __CreateInstance(ExtVectorTypeLoc.Internal native)
            {
                return new ExtVectorTypeLoc(native);
            }

            private static ExtVectorTypeLoc.Internal* __CopyValue(ExtVectorTypeLoc.Internal native)
            {
                var ret = (ExtVectorTypeLoc.Internal*) Marshal.AllocHGlobal(0);
                *ret = native;
                return ret;
            }

            private ExtVectorTypeLoc(ExtVectorTypeLoc.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected ExtVectorTypeLoc(ExtVectorTypeLoc.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public ExtVectorTypeLoc()
            {
                __Instance = Marshal.AllocHGlobal(0);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.ExtVectorTypeLoc __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }
        }

        public unsafe partial class DependentSizedExtVectorTypeLoc : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang30DependentSizedExtVectorTypeLocC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang30DependentSizedExtVectorTypeLocC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, DependentSizedExtVectorTypeLoc> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, DependentSizedExtVectorTypeLoc>();

            private readonly bool __ownsNativeInstance;

            public static DependentSizedExtVectorTypeLoc __CreateInstance(global::System.IntPtr native)
            {
                return new DependentSizedExtVectorTypeLoc((DependentSizedExtVectorTypeLoc.Internal*) native);
            }

            public static DependentSizedExtVectorTypeLoc __CreateInstance(DependentSizedExtVectorTypeLoc.Internal native)
            {
                return new DependentSizedExtVectorTypeLoc(native);
            }

            private static DependentSizedExtVectorTypeLoc.Internal* __CopyValue(DependentSizedExtVectorTypeLoc.Internal native)
            {
                var ret = (DependentSizedExtVectorTypeLoc.Internal*) Marshal.AllocHGlobal(0);
                *ret = native;
                return ret;
            }

            private DependentSizedExtVectorTypeLoc(DependentSizedExtVectorTypeLoc.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected DependentSizedExtVectorTypeLoc(DependentSizedExtVectorTypeLoc.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public DependentSizedExtVectorTypeLoc()
            {
                __Instance = Marshal.AllocHGlobal(0);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.DependentSizedExtVectorTypeLoc __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }
        }

        public unsafe partial class ComplexTypeLoc : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14ComplexTypeLocC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14ComplexTypeLocC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ComplexTypeLoc> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ComplexTypeLoc>();

            private readonly bool __ownsNativeInstance;

            public static ComplexTypeLoc __CreateInstance(global::System.IntPtr native)
            {
                return new ComplexTypeLoc((ComplexTypeLoc.Internal*) native);
            }

            public static ComplexTypeLoc __CreateInstance(ComplexTypeLoc.Internal native)
            {
                return new ComplexTypeLoc(native);
            }

            private static ComplexTypeLoc.Internal* __CopyValue(ComplexTypeLoc.Internal native)
            {
                var ret = (ComplexTypeLoc.Internal*) Marshal.AllocHGlobal(0);
                *ret = native;
                return ret;
            }

            private ComplexTypeLoc(ComplexTypeLoc.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected ComplexTypeLoc(ComplexTypeLoc.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public ComplexTypeLoc()
            {
                __Instance = Marshal.AllocHGlobal(0);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.ComplexTypeLoc __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }
        }

        public unsafe partial class TypeofLocInfo : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 12)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public clang.SourceLocation.Internal TypeofLoc;

                [FieldOffset(4)]
                public clang.SourceLocation.Internal LParenLoc;

                [FieldOffset(8)]
                public clang.SourceLocation.Internal RParenLoc;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13TypeofLocInfoC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13TypeofLocInfoC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, TypeofLocInfo> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, TypeofLocInfo>();

            private readonly bool __ownsNativeInstance;

            public static TypeofLocInfo __CreateInstance(global::System.IntPtr native)
            {
                return new TypeofLocInfo((TypeofLocInfo.Internal*) native);
            }

            public static TypeofLocInfo __CreateInstance(TypeofLocInfo.Internal native)
            {
                return new TypeofLocInfo(native);
            }

            private static TypeofLocInfo.Internal* __CopyValue(TypeofLocInfo.Internal native)
            {
                var ret = (TypeofLocInfo.Internal*) Marshal.AllocHGlobal(12);
                *ret = native;
                return ret;
            }

            private TypeofLocInfo(TypeofLocInfo.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected TypeofLocInfo(TypeofLocInfo.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public TypeofLocInfo()
            {
                __Instance = Marshal.AllocHGlobal(12);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.TypeofLocInfo __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.SourceLocation TypeofLoc
            {
                get
                {
                    return clang.SourceLocation.__CreateInstance(((Internal*) __Instance)->TypeofLoc);
                }

                set
                {
                    ((Internal*) __Instance)->TypeofLoc = ReferenceEquals(value, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (value.__Instance);
                }
            }

            public clang.SourceLocation LParenLoc
            {
                get
                {
                    return clang.SourceLocation.__CreateInstance(((Internal*) __Instance)->LParenLoc);
                }

                set
                {
                    ((Internal*) __Instance)->LParenLoc = ReferenceEquals(value, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (value.__Instance);
                }
            }

            public clang.SourceLocation RParenLoc
            {
                get
                {
                    return clang.SourceLocation.__CreateInstance(((Internal*) __Instance)->RParenLoc);
                }

                set
                {
                    ((Internal*) __Instance)->RParenLoc = ReferenceEquals(value, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (value.__Instance);
                }
            }
        }

        public unsafe partial class TypeOfExprTypeLocInfo : clang.TypeofLocInfo, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 12)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                public clang.SourceLocation.Internal TypeofLoc;

                [FieldOffset(4)]
                public clang.SourceLocation.Internal LParenLoc;

                [FieldOffset(8)]
                public clang.SourceLocation.Internal RParenLoc;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang21TypeOfExprTypeLocInfoC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang21TypeOfExprTypeLocInfoC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
            }

            private readonly bool __ownsNativeInstance;

            public static new TypeOfExprTypeLocInfo __CreateInstance(global::System.IntPtr native)
            {
                return new TypeOfExprTypeLocInfo((TypeOfExprTypeLocInfo.Internal*) native);
            }

            public static TypeOfExprTypeLocInfo __CreateInstance(TypeOfExprTypeLocInfo.Internal native)
            {
                return new TypeOfExprTypeLocInfo(native);
            }

            private static TypeOfExprTypeLocInfo.Internal* __CopyValue(TypeOfExprTypeLocInfo.Internal native)
            {
                var ret = (TypeOfExprTypeLocInfo.Internal*) Marshal.AllocHGlobal(12);
                *ret = native;
                return ret;
            }

            private TypeOfExprTypeLocInfo(TypeOfExprTypeLocInfo.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected TypeOfExprTypeLocInfo(TypeOfExprTypeLocInfo.Internal* native, bool isInternalImpl = false)
                : base((clang.TypeofLocInfo.Internal*) native)
            {
            }

            public TypeOfExprTypeLocInfo()
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(12);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.TypeofLocInfo __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }
        }

        public unsafe partial class TypeOfTypeLocInfo : clang.TypeofLocInfo, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                public clang.SourceLocation.Internal TypeofLoc;

                [FieldOffset(4)]
                public clang.SourceLocation.Internal LParenLoc;

                [FieldOffset(8)]
                public clang.SourceLocation.Internal RParenLoc;

                [FieldOffset(12)]
                public global::System.IntPtr UnderlyingTInfo;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17TypeOfTypeLocInfoC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17TypeOfTypeLocInfoC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
            }

            private readonly bool __ownsNativeInstance;

            public static new TypeOfTypeLocInfo __CreateInstance(global::System.IntPtr native)
            {
                return new TypeOfTypeLocInfo((TypeOfTypeLocInfo.Internal*) native);
            }

            public static TypeOfTypeLocInfo __CreateInstance(TypeOfTypeLocInfo.Internal native)
            {
                return new TypeOfTypeLocInfo(native);
            }

            private static TypeOfTypeLocInfo.Internal* __CopyValue(TypeOfTypeLocInfo.Internal native)
            {
                var ret = (TypeOfTypeLocInfo.Internal*) Marshal.AllocHGlobal(16);
                *ret = native;
                return ret;
            }

            private TypeOfTypeLocInfo(TypeOfTypeLocInfo.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected TypeOfTypeLocInfo(TypeOfTypeLocInfo.Internal* native, bool isInternalImpl = false)
                : base((clang.TypeofLocInfo.Internal*) native)
            {
            }

            public TypeOfTypeLocInfo()
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(16);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.TypeofLocInfo __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.TypeSourceInfo UnderlyingTInfo
            {
                get
                {
                    clang.TypeSourceInfo __result0;
                    if (((Internal*) __Instance)->UnderlyingTInfo == IntPtr.Zero) __result0 = null;
                    else if (clang.TypeSourceInfo.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->UnderlyingTInfo))
                        __result0 = (clang.TypeSourceInfo) clang.TypeSourceInfo.NativeToManagedMap[((Internal*) __Instance)->UnderlyingTInfo];
                    else __result0 = clang.TypeSourceInfo.__CreateInstance(((Internal*) __Instance)->UnderlyingTInfo);
                    return __result0;
                }

                set
                {
                    ((Internal*) __Instance)->UnderlyingTInfo = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                }
            }
        }

        public unsafe partial class TypeOfExprTypeLoc : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17TypeOfExprTypeLocC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17TypeOfExprTypeLocC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17TypeOfExprTypeLoc19getLocalSourceRangeEv")]
                internal static extern clang.SourceRange.Internal getLocalSourceRange_0(global::System.IntPtr instance);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, TypeOfExprTypeLoc> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, TypeOfExprTypeLoc>();

            private readonly bool __ownsNativeInstance;

            public static TypeOfExprTypeLoc __CreateInstance(global::System.IntPtr native)
            {
                return new TypeOfExprTypeLoc((TypeOfExprTypeLoc.Internal*) native);
            }

            public static TypeOfExprTypeLoc __CreateInstance(TypeOfExprTypeLoc.Internal native)
            {
                return new TypeOfExprTypeLoc(native);
            }

            private static TypeOfExprTypeLoc.Internal* __CopyValue(TypeOfExprTypeLoc.Internal native)
            {
                var ret = (TypeOfExprTypeLoc.Internal*) Marshal.AllocHGlobal(0);
                *ret = native;
                return ret;
            }

            private TypeOfExprTypeLoc(TypeOfExprTypeLoc.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected TypeOfExprTypeLoc(TypeOfExprTypeLoc.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public TypeOfExprTypeLoc()
            {
                __Instance = Marshal.AllocHGlobal(0);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.TypeOfExprTypeLoc __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.SourceRange getLocalSourceRange()
            {
                var __ret = Internal.getLocalSourceRange_0(__Instance);
                return clang.SourceRange.__CreateInstance(__ret);
            }
        }

        public unsafe partial class TypeOfTypeLoc : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13TypeOfTypeLocC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13TypeOfTypeLocC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13TypeOfTypeLoc17getUnderlyingTypeEv")]
                internal static extern clang.QualType.Internal getUnderlyingType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13TypeOfTypeLoc18getUnderlyingTInfoEv")]
                internal static extern global::System.IntPtr getUnderlyingTInfo_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13TypeOfTypeLoc18setUnderlyingTInfoEPNS_14TypeSourceInfoE")]
                internal static extern void setUnderlyingTInfo_0(global::System.IntPtr instance, global::System.IntPtr TI);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13TypeOfTypeLoc15initializeLocalERNS_10ASTContextENS_14SourceLocationE")]
                internal static extern void initializeLocal_0(global::System.IntPtr instance, global::System.IntPtr Context, clang.SourceLocation.Internal Loc);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, TypeOfTypeLoc> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, TypeOfTypeLoc>();

            private readonly bool __ownsNativeInstance;

            public static TypeOfTypeLoc __CreateInstance(global::System.IntPtr native)
            {
                return new TypeOfTypeLoc((TypeOfTypeLoc.Internal*) native);
            }

            public static TypeOfTypeLoc __CreateInstance(TypeOfTypeLoc.Internal native)
            {
                return new TypeOfTypeLoc(native);
            }

            private static TypeOfTypeLoc.Internal* __CopyValue(TypeOfTypeLoc.Internal native)
            {
                var ret = (TypeOfTypeLoc.Internal*) Marshal.AllocHGlobal(0);
                *ret = native;
                return ret;
            }

            private TypeOfTypeLoc(TypeOfTypeLoc.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected TypeOfTypeLoc(TypeOfTypeLoc.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public TypeOfTypeLoc()
            {
                __Instance = Marshal.AllocHGlobal(0);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.TypeOfTypeLoc __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.QualType getUnderlyingType()
            {
                var __ret = Internal.getUnderlyingType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            public clang.TypeSourceInfo getUnderlyingTInfo()
            {
                var __ret = Internal.getUnderlyingTInfo_0(__Instance);
                clang.TypeSourceInfo __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.TypeSourceInfo.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.TypeSourceInfo) clang.TypeSourceInfo.NativeToManagedMap[__ret];
                else __result0 = clang.TypeSourceInfo.__CreateInstance(__ret);
                return __result0;
            }

            public void setUnderlyingTInfo(clang.TypeSourceInfo TI)
            {
                var arg0 = ReferenceEquals(TI, null) ? global::System.IntPtr.Zero : TI.__Instance;
                Internal.setUnderlyingTInfo_0(__Instance, arg0);
            }

            public void initializeLocal(clang.ASTContext Context, clang.SourceLocation Loc)
            {
                var arg0 = ReferenceEquals(Context, null) ? global::System.IntPtr.Zero : Context.__Instance;
                var arg1 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                Internal.initializeLocal_0(__Instance, arg0, arg1);
            }
        }

        public unsafe partial class DecltypeTypeLoc : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang15DecltypeTypeLocC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang15DecltypeTypeLocC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, DecltypeTypeLoc> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, DecltypeTypeLoc>();

            private readonly bool __ownsNativeInstance;

            public static DecltypeTypeLoc __CreateInstance(global::System.IntPtr native)
            {
                return new DecltypeTypeLoc((DecltypeTypeLoc.Internal*) native);
            }

            public static DecltypeTypeLoc __CreateInstance(DecltypeTypeLoc.Internal native)
            {
                return new DecltypeTypeLoc(native);
            }

            private static DecltypeTypeLoc.Internal* __CopyValue(DecltypeTypeLoc.Internal native)
            {
                var ret = (DecltypeTypeLoc.Internal*) Marshal.AllocHGlobal(0);
                *ret = native;
                return ret;
            }

            private DecltypeTypeLoc(DecltypeTypeLoc.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected DecltypeTypeLoc(DecltypeTypeLoc.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public DecltypeTypeLoc()
            {
                __Instance = Marshal.AllocHGlobal(0);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.DecltypeTypeLoc __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }
        }

        public unsafe partial class UnaryTransformTypeLocInfo : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public clang.SourceLocation.Internal KWLoc;

                [FieldOffset(4)]
                public clang.SourceLocation.Internal LParenLoc;

                [FieldOffset(8)]
                public clang.SourceLocation.Internal RParenLoc;

                [FieldOffset(12)]
                public global::System.IntPtr UnderlyingTInfo;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang25UnaryTransformTypeLocInfoC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang25UnaryTransformTypeLocInfoC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, UnaryTransformTypeLocInfo> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, UnaryTransformTypeLocInfo>();

            private readonly bool __ownsNativeInstance;

            public static UnaryTransformTypeLocInfo __CreateInstance(global::System.IntPtr native)
            {
                return new UnaryTransformTypeLocInfo((UnaryTransformTypeLocInfo.Internal*) native);
            }

            public static UnaryTransformTypeLocInfo __CreateInstance(UnaryTransformTypeLocInfo.Internal native)
            {
                return new UnaryTransformTypeLocInfo(native);
            }

            private static UnaryTransformTypeLocInfo.Internal* __CopyValue(UnaryTransformTypeLocInfo.Internal native)
            {
                var ret = (UnaryTransformTypeLocInfo.Internal*) Marshal.AllocHGlobal(16);
                *ret = native;
                return ret;
            }

            private UnaryTransformTypeLocInfo(UnaryTransformTypeLocInfo.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected UnaryTransformTypeLocInfo(UnaryTransformTypeLocInfo.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public UnaryTransformTypeLocInfo()
            {
                __Instance = Marshal.AllocHGlobal(16);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.UnaryTransformTypeLocInfo __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.SourceLocation KWLoc
            {
                get
                {
                    return clang.SourceLocation.__CreateInstance(((Internal*) __Instance)->KWLoc);
                }

                set
                {
                    ((Internal*) __Instance)->KWLoc = ReferenceEquals(value, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (value.__Instance);
                }
            }

            public clang.SourceLocation LParenLoc
            {
                get
                {
                    return clang.SourceLocation.__CreateInstance(((Internal*) __Instance)->LParenLoc);
                }

                set
                {
                    ((Internal*) __Instance)->LParenLoc = ReferenceEquals(value, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (value.__Instance);
                }
            }

            public clang.SourceLocation RParenLoc
            {
                get
                {
                    return clang.SourceLocation.__CreateInstance(((Internal*) __Instance)->RParenLoc);
                }

                set
                {
                    ((Internal*) __Instance)->RParenLoc = ReferenceEquals(value, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (value.__Instance);
                }
            }

            public clang.TypeSourceInfo UnderlyingTInfo
            {
                get
                {
                    clang.TypeSourceInfo __result0;
                    if (((Internal*) __Instance)->UnderlyingTInfo == IntPtr.Zero) __result0 = null;
                    else if (clang.TypeSourceInfo.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->UnderlyingTInfo))
                        __result0 = (clang.TypeSourceInfo) clang.TypeSourceInfo.NativeToManagedMap[((Internal*) __Instance)->UnderlyingTInfo];
                    else __result0 = clang.TypeSourceInfo.__CreateInstance(((Internal*) __Instance)->UnderlyingTInfo);
                    return __result0;
                }

                set
                {
                    ((Internal*) __Instance)->UnderlyingTInfo = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                }
            }
        }

        public unsafe partial class UnaryTransformTypeLoc : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang21UnaryTransformTypeLocC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang21UnaryTransformTypeLocC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang21UnaryTransformTypeLoc8getKWLocEv")]
                internal static extern clang.SourceLocation.Internal getKWLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang21UnaryTransformTypeLoc8setKWLocENS_14SourceLocationE")]
                internal static extern void setKWLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal Loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang21UnaryTransformTypeLoc12getLParenLocEv")]
                internal static extern clang.SourceLocation.Internal getLParenLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang21UnaryTransformTypeLoc12setLParenLocENS_14SourceLocationE")]
                internal static extern void setLParenLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal Loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang21UnaryTransformTypeLoc12getRParenLocEv")]
                internal static extern clang.SourceLocation.Internal getRParenLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang21UnaryTransformTypeLoc12setRParenLocENS_14SourceLocationE")]
                internal static extern void setRParenLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal Loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang21UnaryTransformTypeLoc18getUnderlyingTInfoEv")]
                internal static extern global::System.IntPtr getUnderlyingTInfo_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang21UnaryTransformTypeLoc18setUnderlyingTInfoEPNS_14TypeSourceInfoE")]
                internal static extern void setUnderlyingTInfo_0(global::System.IntPtr instance, global::System.IntPtr TInfo);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang21UnaryTransformTypeLoc19getLocalSourceRangeEv")]
                internal static extern clang.SourceRange.Internal getLocalSourceRange_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang21UnaryTransformTypeLoc14getParensRangeEv")]
                internal static extern clang.SourceRange.Internal getParensRange_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang21UnaryTransformTypeLoc14setParensRangeENS_11SourceRangeE")]
                internal static extern void setParensRange_0(global::System.IntPtr instance, clang.SourceRange.Internal Range);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang21UnaryTransformTypeLoc15initializeLocalERNS_10ASTContextENS_14SourceLocationE")]
                internal static extern void initializeLocal_0(global::System.IntPtr instance, global::System.IntPtr Context, clang.SourceLocation.Internal Loc);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, UnaryTransformTypeLoc> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, UnaryTransformTypeLoc>();

            private readonly bool __ownsNativeInstance;

            public static UnaryTransformTypeLoc __CreateInstance(global::System.IntPtr native)
            {
                return new UnaryTransformTypeLoc((UnaryTransformTypeLoc.Internal*) native);
            }

            public static UnaryTransformTypeLoc __CreateInstance(UnaryTransformTypeLoc.Internal native)
            {
                return new UnaryTransformTypeLoc(native);
            }

            private static UnaryTransformTypeLoc.Internal* __CopyValue(UnaryTransformTypeLoc.Internal native)
            {
                var ret = (UnaryTransformTypeLoc.Internal*) Marshal.AllocHGlobal(0);
                *ret = native;
                return ret;
            }

            private UnaryTransformTypeLoc(UnaryTransformTypeLoc.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected UnaryTransformTypeLoc(UnaryTransformTypeLoc.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public UnaryTransformTypeLoc()
            {
                __Instance = Marshal.AllocHGlobal(0);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.UnaryTransformTypeLoc __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.SourceLocation getKWLoc()
            {
                var __ret = Internal.getKWLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setKWLoc(clang.SourceLocation Loc)
            {
                var arg0 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                Internal.setKWLoc_0(__Instance, arg0);
            }

            public clang.SourceLocation getLParenLoc()
            {
                var __ret = Internal.getLParenLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setLParenLoc(clang.SourceLocation Loc)
            {
                var arg0 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                Internal.setLParenLoc_0(__Instance, arg0);
            }

            public clang.SourceLocation getRParenLoc()
            {
                var __ret = Internal.getRParenLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setRParenLoc(clang.SourceLocation Loc)
            {
                var arg0 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                Internal.setRParenLoc_0(__Instance, arg0);
            }

            public clang.TypeSourceInfo getUnderlyingTInfo()
            {
                var __ret = Internal.getUnderlyingTInfo_0(__Instance);
                clang.TypeSourceInfo __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.TypeSourceInfo.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.TypeSourceInfo) clang.TypeSourceInfo.NativeToManagedMap[__ret];
                else __result0 = clang.TypeSourceInfo.__CreateInstance(__ret);
                return __result0;
            }

            public void setUnderlyingTInfo(clang.TypeSourceInfo TInfo)
            {
                var arg0 = ReferenceEquals(TInfo, null) ? global::System.IntPtr.Zero : TInfo.__Instance;
                Internal.setUnderlyingTInfo_0(__Instance, arg0);
            }

            public clang.SourceRange getLocalSourceRange()
            {
                var __ret = Internal.getLocalSourceRange_0(__Instance);
                return clang.SourceRange.__CreateInstance(__ret);
            }

            public clang.SourceRange getParensRange()
            {
                var __ret = Internal.getParensRange_0(__Instance);
                return clang.SourceRange.__CreateInstance(__ret);
            }

            public void setParensRange(clang.SourceRange Range)
            {
                var arg0 = ReferenceEquals(Range, null) ? new clang.SourceRange.Internal() : *(clang.SourceRange.Internal*) (Range.__Instance);
                Internal.setParensRange_0(__Instance, arg0);
            }

            public void initializeLocal(clang.ASTContext Context, clang.SourceLocation Loc)
            {
                var arg0 = ReferenceEquals(Context, null) ? global::System.IntPtr.Zero : Context.__Instance;
                var arg1 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                Internal.initializeLocal_0(__Instance, arg0, arg1);
            }
        }

        public unsafe partial class AutoTypeLoc : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11AutoTypeLocC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11AutoTypeLocC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, AutoTypeLoc> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, AutoTypeLoc>();

            private readonly bool __ownsNativeInstance;

            public static AutoTypeLoc __CreateInstance(global::System.IntPtr native)
            {
                return new AutoTypeLoc((AutoTypeLoc.Internal*) native);
            }

            public static AutoTypeLoc __CreateInstance(AutoTypeLoc.Internal native)
            {
                return new AutoTypeLoc(native);
            }

            private static AutoTypeLoc.Internal* __CopyValue(AutoTypeLoc.Internal native)
            {
                var ret = (AutoTypeLoc.Internal*) Marshal.AllocHGlobal(0);
                *ret = native;
                return ret;
            }

            private AutoTypeLoc(AutoTypeLoc.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected AutoTypeLoc(AutoTypeLoc.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public AutoTypeLoc()
            {
                __Instance = Marshal.AllocHGlobal(0);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.AutoTypeLoc __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }
        }

        public unsafe partial class ElaboratedLocInfo : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 8)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public clang.SourceLocation.Internal ElaboratedKWLoc;

                [FieldOffset(4)]
                public global::System.IntPtr QualifierData;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17ElaboratedLocInfoC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17ElaboratedLocInfoC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ElaboratedLocInfo> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ElaboratedLocInfo>();

            private readonly bool __ownsNativeInstance;

            public static ElaboratedLocInfo __CreateInstance(global::System.IntPtr native)
            {
                return new ElaboratedLocInfo((ElaboratedLocInfo.Internal*) native);
            }

            public static ElaboratedLocInfo __CreateInstance(ElaboratedLocInfo.Internal native)
            {
                return new ElaboratedLocInfo(native);
            }

            private static ElaboratedLocInfo.Internal* __CopyValue(ElaboratedLocInfo.Internal native)
            {
                var ret = (ElaboratedLocInfo.Internal*) Marshal.AllocHGlobal(8);
                *ret = native;
                return ret;
            }

            private ElaboratedLocInfo(ElaboratedLocInfo.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected ElaboratedLocInfo(ElaboratedLocInfo.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public ElaboratedLocInfo()
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.ElaboratedLocInfo __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.SourceLocation ElaboratedKWLoc
            {
                get
                {
                    return clang.SourceLocation.__CreateInstance(((Internal*) __Instance)->ElaboratedKWLoc);
                }

                set
                {
                    ((Internal*) __Instance)->ElaboratedKWLoc = ReferenceEquals(value, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (value.__Instance);
                }
            }

            public global::System.IntPtr QualifierData
            {
                get
                {
                    return ((Internal*) __Instance)->QualifierData;
                }

                set
                {
                    ((Internal*) __Instance)->QualifierData = value;
                }
            }
        }

        public unsafe partial class ElaboratedTypeLoc : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17ElaboratedTypeLocC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17ElaboratedTypeLocC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17ElaboratedTypeLoc23getElaboratedKeywordLocEv")]
                internal static extern clang.SourceLocation.Internal getElaboratedKeywordLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17ElaboratedTypeLoc23setElaboratedKeywordLocENS_14SourceLocationE")]
                internal static extern void setElaboratedKeywordLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal Loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17ElaboratedTypeLoc15getQualifierLocEv")]
                internal static extern clang.NestedNameSpecifierLoc.Internal getQualifierLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17ElaboratedTypeLoc15setQualifierLocENS_22NestedNameSpecifierLocE")]
                internal static extern void setQualifierLoc_0(global::System.IntPtr instance, clang.NestedNameSpecifierLoc.Internal QualifierLoc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17ElaboratedTypeLoc19getLocalSourceRangeEv")]
                internal static extern clang.SourceRange.Internal getLocalSourceRange_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17ElaboratedTypeLoc15initializeLocalERNS_10ASTContextENS_14SourceLocationE")]
                internal static extern void initializeLocal_0(global::System.IntPtr instance, global::System.IntPtr Context, clang.SourceLocation.Internal Loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17ElaboratedTypeLoc15getNamedTypeLocEv")]
                internal static extern clang.TypeLoc.Internal getNamedTypeLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17ElaboratedTypeLoc12getInnerTypeEv")]
                internal static extern clang.QualType.Internal getInnerType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17ElaboratedTypeLoc4copyES0_")]
                internal static extern void copy_0(global::System.IntPtr instance, clang.ElaboratedTypeLoc.Internal Loc);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ElaboratedTypeLoc> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ElaboratedTypeLoc>();

            private readonly bool __ownsNativeInstance;

            public static ElaboratedTypeLoc __CreateInstance(global::System.IntPtr native)
            {
                return new ElaboratedTypeLoc((ElaboratedTypeLoc.Internal*) native);
            }

            public static ElaboratedTypeLoc __CreateInstance(ElaboratedTypeLoc.Internal native)
            {
                return new ElaboratedTypeLoc(native);
            }

            private static ElaboratedTypeLoc.Internal* __CopyValue(ElaboratedTypeLoc.Internal native)
            {
                var ret = (ElaboratedTypeLoc.Internal*) Marshal.AllocHGlobal(0);
                *ret = native;
                return ret;
            }

            private ElaboratedTypeLoc(ElaboratedTypeLoc.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected ElaboratedTypeLoc(ElaboratedTypeLoc.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public ElaboratedTypeLoc()
            {
                __Instance = Marshal.AllocHGlobal(0);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.ElaboratedTypeLoc __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.SourceLocation getElaboratedKeywordLoc()
            {
                var __ret = Internal.getElaboratedKeywordLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setElaboratedKeywordLoc(clang.SourceLocation Loc)
            {
                var arg0 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                Internal.setElaboratedKeywordLoc_0(__Instance, arg0);
            }

            public clang.NestedNameSpecifierLoc getQualifierLoc()
            {
                var __ret = Internal.getQualifierLoc_0(__Instance);
                return clang.NestedNameSpecifierLoc.__CreateInstance(__ret);
            }

            public void setQualifierLoc(clang.NestedNameSpecifierLoc QualifierLoc)
            {
                var arg0 = ReferenceEquals(QualifierLoc, null) ? new clang.NestedNameSpecifierLoc.Internal() : *(clang.NestedNameSpecifierLoc.Internal*) (QualifierLoc.__Instance);
                Internal.setQualifierLoc_0(__Instance, arg0);
            }

            public clang.SourceRange getLocalSourceRange()
            {
                var __ret = Internal.getLocalSourceRange_0(__Instance);
                return clang.SourceRange.__CreateInstance(__ret);
            }

            public void initializeLocal(clang.ASTContext Context, clang.SourceLocation Loc)
            {
                var arg0 = ReferenceEquals(Context, null) ? global::System.IntPtr.Zero : Context.__Instance;
                var arg1 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                Internal.initializeLocal_0(__Instance, arg0, arg1);
            }

            public clang.TypeLoc getNamedTypeLoc()
            {
                var __ret = Internal.getNamedTypeLoc_0(__Instance);
                return clang.TypeLoc.__CreateInstance(__ret);
            }

            public clang.QualType getInnerType()
            {
                var __ret = Internal.getInnerType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            public void copy(clang.ElaboratedTypeLoc Loc)
            {
                var arg0 = ReferenceEquals(Loc, null) ? new clang.ElaboratedTypeLoc.Internal() : *(clang.ElaboratedTypeLoc.Internal*) (Loc.__Instance);
                Internal.copy_0(__Instance, arg0);
            }
        }

        public unsafe partial class DependentNameLocInfo : clang.ElaboratedLocInfo, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 12)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                public clang.SourceLocation.Internal ElaboratedKWLoc;

                [FieldOffset(4)]
                public global::System.IntPtr QualifierData;

                [FieldOffset(8)]
                public clang.SourceLocation.Internal NameLoc;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang20DependentNameLocInfoC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang20DependentNameLocInfoC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
            }

            private readonly bool __ownsNativeInstance;

            public static new DependentNameLocInfo __CreateInstance(global::System.IntPtr native)
            {
                return new DependentNameLocInfo((DependentNameLocInfo.Internal*) native);
            }

            public static DependentNameLocInfo __CreateInstance(DependentNameLocInfo.Internal native)
            {
                return new DependentNameLocInfo(native);
            }

            private static DependentNameLocInfo.Internal* __CopyValue(DependentNameLocInfo.Internal native)
            {
                var ret = (DependentNameLocInfo.Internal*) Marshal.AllocHGlobal(12);
                *ret = native;
                return ret;
            }

            private DependentNameLocInfo(DependentNameLocInfo.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected DependentNameLocInfo(DependentNameLocInfo.Internal* native, bool isInternalImpl = false)
                : base((clang.ElaboratedLocInfo.Internal*) native)
            {
            }

            public DependentNameLocInfo()
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(12);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.ElaboratedLocInfo __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.SourceLocation NameLoc
            {
                get
                {
                    return clang.SourceLocation.__CreateInstance(((Internal*) __Instance)->NameLoc);
                }

                set
                {
                    ((Internal*) __Instance)->NameLoc = ReferenceEquals(value, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (value.__Instance);
                }
            }
        }

        public unsafe partial class DependentNameTypeLoc : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang20DependentNameTypeLocC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang20DependentNameTypeLocC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang20DependentNameTypeLoc23getElaboratedKeywordLocEv")]
                internal static extern clang.SourceLocation.Internal getElaboratedKeywordLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang20DependentNameTypeLoc23setElaboratedKeywordLocENS_14SourceLocationE")]
                internal static extern void setElaboratedKeywordLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal Loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang20DependentNameTypeLoc15getQualifierLocEv")]
                internal static extern clang.NestedNameSpecifierLoc.Internal getQualifierLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang20DependentNameTypeLoc15setQualifierLocENS_22NestedNameSpecifierLocE")]
                internal static extern void setQualifierLoc_0(global::System.IntPtr instance, clang.NestedNameSpecifierLoc.Internal QualifierLoc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang20DependentNameTypeLoc10getNameLocEv")]
                internal static extern clang.SourceLocation.Internal getNameLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang20DependentNameTypeLoc10setNameLocENS_14SourceLocationE")]
                internal static extern void setNameLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal Loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang20DependentNameTypeLoc19getLocalSourceRangeEv")]
                internal static extern clang.SourceRange.Internal getLocalSourceRange_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang20DependentNameTypeLoc4copyES0_")]
                internal static extern void copy_0(global::System.IntPtr instance, clang.DependentNameTypeLoc.Internal Loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang20DependentNameTypeLoc15initializeLocalERNS_10ASTContextENS_14SourceLocationE")]
                internal static extern void initializeLocal_0(global::System.IntPtr instance, global::System.IntPtr Context, clang.SourceLocation.Internal Loc);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, DependentNameTypeLoc> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, DependentNameTypeLoc>();

            private readonly bool __ownsNativeInstance;

            public static DependentNameTypeLoc __CreateInstance(global::System.IntPtr native)
            {
                return new DependentNameTypeLoc((DependentNameTypeLoc.Internal*) native);
            }

            public static DependentNameTypeLoc __CreateInstance(DependentNameTypeLoc.Internal native)
            {
                return new DependentNameTypeLoc(native);
            }

            private static DependentNameTypeLoc.Internal* __CopyValue(DependentNameTypeLoc.Internal native)
            {
                var ret = (DependentNameTypeLoc.Internal*) Marshal.AllocHGlobal(0);
                *ret = native;
                return ret;
            }

            private DependentNameTypeLoc(DependentNameTypeLoc.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected DependentNameTypeLoc(DependentNameTypeLoc.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public DependentNameTypeLoc()
            {
                __Instance = Marshal.AllocHGlobal(0);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.DependentNameTypeLoc __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.SourceLocation getElaboratedKeywordLoc()
            {
                var __ret = Internal.getElaboratedKeywordLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setElaboratedKeywordLoc(clang.SourceLocation Loc)
            {
                var arg0 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                Internal.setElaboratedKeywordLoc_0(__Instance, arg0);
            }

            public clang.NestedNameSpecifierLoc getQualifierLoc()
            {
                var __ret = Internal.getQualifierLoc_0(__Instance);
                return clang.NestedNameSpecifierLoc.__CreateInstance(__ret);
            }

            public void setQualifierLoc(clang.NestedNameSpecifierLoc QualifierLoc)
            {
                var arg0 = ReferenceEquals(QualifierLoc, null) ? new clang.NestedNameSpecifierLoc.Internal() : *(clang.NestedNameSpecifierLoc.Internal*) (QualifierLoc.__Instance);
                Internal.setQualifierLoc_0(__Instance, arg0);
            }

            public clang.SourceLocation getNameLoc()
            {
                var __ret = Internal.getNameLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setNameLoc(clang.SourceLocation Loc)
            {
                var arg0 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                Internal.setNameLoc_0(__Instance, arg0);
            }

            public clang.SourceRange getLocalSourceRange()
            {
                var __ret = Internal.getLocalSourceRange_0(__Instance);
                return clang.SourceRange.__CreateInstance(__ret);
            }

            public void copy(clang.DependentNameTypeLoc Loc)
            {
                var arg0 = ReferenceEquals(Loc, null) ? new clang.DependentNameTypeLoc.Internal() : *(clang.DependentNameTypeLoc.Internal*) (Loc.__Instance);
                Internal.copy_0(__Instance, arg0);
            }

            public void initializeLocal(clang.ASTContext Context, clang.SourceLocation Loc)
            {
                var arg0 = ReferenceEquals(Context, null) ? global::System.IntPtr.Zero : Context.__Instance;
                var arg1 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                Internal.initializeLocal_0(__Instance, arg0, arg1);
            }
        }

        public unsafe partial class DependentTemplateSpecializationLocInfo : clang.DependentNameLocInfo, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 24)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                public clang.SourceLocation.Internal ElaboratedKWLoc;

                [FieldOffset(4)]
                public global::System.IntPtr QualifierData;

                [FieldOffset(8)]
                public clang.SourceLocation.Internal NameLoc;

                [FieldOffset(12)]
                public clang.SourceLocation.Internal TemplateKWLoc;

                [FieldOffset(16)]
                public clang.SourceLocation.Internal LAngleLoc;

                [FieldOffset(20)]
                public clang.SourceLocation.Internal RAngleLoc;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang38DependentTemplateSpecializationLocInfoC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang38DependentTemplateSpecializationLocInfoC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
            }

            private readonly bool __ownsNativeInstance;

            public static new DependentTemplateSpecializationLocInfo __CreateInstance(global::System.IntPtr native)
            {
                return new DependentTemplateSpecializationLocInfo((DependentTemplateSpecializationLocInfo.Internal*) native);
            }

            public static DependentTemplateSpecializationLocInfo __CreateInstance(DependentTemplateSpecializationLocInfo.Internal native)
            {
                return new DependentTemplateSpecializationLocInfo(native);
            }

            private static DependentTemplateSpecializationLocInfo.Internal* __CopyValue(DependentTemplateSpecializationLocInfo.Internal native)
            {
                var ret = (DependentTemplateSpecializationLocInfo.Internal*) Marshal.AllocHGlobal(24);
                *ret = native;
                return ret;
            }

            private DependentTemplateSpecializationLocInfo(DependentTemplateSpecializationLocInfo.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected DependentTemplateSpecializationLocInfo(DependentTemplateSpecializationLocInfo.Internal* native, bool isInternalImpl = false)
                : base((clang.DependentNameLocInfo.Internal*) native)
            {
            }

            public DependentTemplateSpecializationLocInfo()
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(24);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.ElaboratedLocInfo __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.SourceLocation TemplateKWLoc
            {
                get
                {
                    return clang.SourceLocation.__CreateInstance(((Internal*) __Instance)->TemplateKWLoc);
                }

                set
                {
                    ((Internal*) __Instance)->TemplateKWLoc = ReferenceEquals(value, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (value.__Instance);
                }
            }

            public clang.SourceLocation LAngleLoc
            {
                get
                {
                    return clang.SourceLocation.__CreateInstance(((Internal*) __Instance)->LAngleLoc);
                }

                set
                {
                    ((Internal*) __Instance)->LAngleLoc = ReferenceEquals(value, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (value.__Instance);
                }
            }

            public clang.SourceLocation RAngleLoc
            {
                get
                {
                    return clang.SourceLocation.__CreateInstance(((Internal*) __Instance)->RAngleLoc);
                }

                set
                {
                    ((Internal*) __Instance)->RAngleLoc = ReferenceEquals(value, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (value.__Instance);
                }
            }
        }

        public unsafe partial class DependentTemplateSpecializationTypeLoc : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang38DependentTemplateSpecializationTypeLocC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang38DependentTemplateSpecializationTypeLocC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang38DependentTemplateSpecializationTypeLoc23getElaboratedKeywordLocEv")]
                internal static extern clang.SourceLocation.Internal getElaboratedKeywordLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang38DependentTemplateSpecializationTypeLoc23setElaboratedKeywordLocENS_14SourceLocationE")]
                internal static extern void setElaboratedKeywordLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal Loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang38DependentTemplateSpecializationTypeLoc15getQualifierLocEv")]
                internal static extern clang.NestedNameSpecifierLoc.Internal getQualifierLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang38DependentTemplateSpecializationTypeLoc15setQualifierLocENS_22NestedNameSpecifierLocE")]
                internal static extern void setQualifierLoc_0(global::System.IntPtr instance, clang.NestedNameSpecifierLoc.Internal QualifierLoc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang38DependentTemplateSpecializationTypeLoc21getTemplateKeywordLocEv")]
                internal static extern clang.SourceLocation.Internal getTemplateKeywordLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang38DependentTemplateSpecializationTypeLoc21setTemplateKeywordLocENS_14SourceLocationE")]
                internal static extern void setTemplateKeywordLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal Loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang38DependentTemplateSpecializationTypeLoc18getTemplateNameLocEv")]
                internal static extern clang.SourceLocation.Internal getTemplateNameLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang38DependentTemplateSpecializationTypeLoc18setTemplateNameLocENS_14SourceLocationE")]
                internal static extern void setTemplateNameLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal Loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang38DependentTemplateSpecializationTypeLoc12getLAngleLocEv")]
                internal static extern clang.SourceLocation.Internal getLAngleLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang38DependentTemplateSpecializationTypeLoc12setLAngleLocENS_14SourceLocationE")]
                internal static extern void setLAngleLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal Loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang38DependentTemplateSpecializationTypeLoc12getRAngleLocEv")]
                internal static extern clang.SourceLocation.Internal getRAngleLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang38DependentTemplateSpecializationTypeLoc12setRAngleLocENS_14SourceLocationE")]
                internal static extern void setRAngleLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal Loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang38DependentTemplateSpecializationTypeLoc10getNumArgsEv")]
                internal static extern uint getNumArgs_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang38DependentTemplateSpecializationTypeLoc13setArgLocInfoEjNS_23TemplateArgumentLocInfoE")]
                internal static extern void setArgLocInfo_0(global::System.IntPtr instance, uint i, clang.TemplateArgumentLocInfo.Internal AI);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang38DependentTemplateSpecializationTypeLoc13getArgLocInfoEj")]
                internal static extern void getArgLocInfo_0(global::System.IntPtr @return, global::System.IntPtr instance, uint i);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang38DependentTemplateSpecializationTypeLoc9getArgLocEj")]
                internal static extern void getArgLoc_0(global::System.IntPtr @return, global::System.IntPtr instance, uint i);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang38DependentTemplateSpecializationTypeLoc19getLocalSourceRangeEv")]
                internal static extern clang.SourceRange.Internal getLocalSourceRange_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang38DependentTemplateSpecializationTypeLoc4copyES0_")]
                internal static extern void copy_0(global::System.IntPtr instance, clang.DependentTemplateSpecializationTypeLoc.Internal Loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang38DependentTemplateSpecializationTypeLoc15initializeLocalERNS_10ASTContextENS_14SourceLocationE")]
                internal static extern void initializeLocal_0(global::System.IntPtr instance, global::System.IntPtr Context, clang.SourceLocation.Internal Loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang38DependentTemplateSpecializationTypeLoc21getExtraLocalDataSizeEv")]
                internal static extern uint getExtraLocalDataSize_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang38DependentTemplateSpecializationTypeLoc26getExtraLocalDataAlignmentEv")]
                internal static extern uint getExtraLocalDataAlignment_0(global::System.IntPtr instance);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, DependentTemplateSpecializationTypeLoc> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, DependentTemplateSpecializationTypeLoc>();

            private readonly bool __ownsNativeInstance;

            public static DependentTemplateSpecializationTypeLoc __CreateInstance(global::System.IntPtr native)
            {
                return new DependentTemplateSpecializationTypeLoc((DependentTemplateSpecializationTypeLoc.Internal*) native);
            }

            public static DependentTemplateSpecializationTypeLoc __CreateInstance(DependentTemplateSpecializationTypeLoc.Internal native)
            {
                return new DependentTemplateSpecializationTypeLoc(native);
            }

            private static DependentTemplateSpecializationTypeLoc.Internal* __CopyValue(DependentTemplateSpecializationTypeLoc.Internal native)
            {
                var ret = (DependentTemplateSpecializationTypeLoc.Internal*) Marshal.AllocHGlobal(0);
                *ret = native;
                return ret;
            }

            private DependentTemplateSpecializationTypeLoc(DependentTemplateSpecializationTypeLoc.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected DependentTemplateSpecializationTypeLoc(DependentTemplateSpecializationTypeLoc.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public DependentTemplateSpecializationTypeLoc()
            {
                __Instance = Marshal.AllocHGlobal(0);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.DependentTemplateSpecializationTypeLoc __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.SourceLocation getElaboratedKeywordLoc()
            {
                var __ret = Internal.getElaboratedKeywordLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setElaboratedKeywordLoc(clang.SourceLocation Loc)
            {
                var arg0 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                Internal.setElaboratedKeywordLoc_0(__Instance, arg0);
            }

            public clang.NestedNameSpecifierLoc getQualifierLoc()
            {
                var __ret = Internal.getQualifierLoc_0(__Instance);
                return clang.NestedNameSpecifierLoc.__CreateInstance(__ret);
            }

            public void setQualifierLoc(clang.NestedNameSpecifierLoc QualifierLoc)
            {
                var arg0 = ReferenceEquals(QualifierLoc, null) ? new clang.NestedNameSpecifierLoc.Internal() : *(clang.NestedNameSpecifierLoc.Internal*) (QualifierLoc.__Instance);
                Internal.setQualifierLoc_0(__Instance, arg0);
            }

            public clang.SourceLocation getTemplateKeywordLoc()
            {
                var __ret = Internal.getTemplateKeywordLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setTemplateKeywordLoc(clang.SourceLocation Loc)
            {
                var arg0 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                Internal.setTemplateKeywordLoc_0(__Instance, arg0);
            }

            public clang.SourceLocation getTemplateNameLoc()
            {
                var __ret = Internal.getTemplateNameLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setTemplateNameLoc(clang.SourceLocation Loc)
            {
                var arg0 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                Internal.setTemplateNameLoc_0(__Instance, arg0);
            }

            public clang.SourceLocation getLAngleLoc()
            {
                var __ret = Internal.getLAngleLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setLAngleLoc(clang.SourceLocation Loc)
            {
                var arg0 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                Internal.setLAngleLoc_0(__Instance, arg0);
            }

            public clang.SourceLocation getRAngleLoc()
            {
                var __ret = Internal.getRAngleLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setRAngleLoc(clang.SourceLocation Loc)
            {
                var arg0 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                Internal.setRAngleLoc_0(__Instance, arg0);
            }

            public uint getNumArgs()
            {
                var __ret = Internal.getNumArgs_0(__Instance);
                return __ret;
            }

            public void setArgLocInfo(uint i, clang.TemplateArgumentLocInfo AI)
            {
                var arg1 = ReferenceEquals(AI, null) ? new clang.TemplateArgumentLocInfo.Internal() : *(clang.TemplateArgumentLocInfo.Internal*) (AI.__Instance);
                Internal.setArgLocInfo_0(__Instance, i, arg1);
            }

            public clang.TemplateArgumentLocInfo getArgLocInfo(uint i)
            {
                var __ret = new clang.TemplateArgumentLocInfo.Internal();
                Internal.getArgLocInfo_0(new IntPtr(&__ret), __Instance, i);
                return clang.TemplateArgumentLocInfo.__CreateInstance(__ret);
            }

            public clang.TemplateArgumentLoc getArgLoc(uint i)
            {
                var __ret = new clang.TemplateArgumentLoc.Internal();
                Internal.getArgLoc_0(new IntPtr(&__ret), __Instance, i);
                return clang.TemplateArgumentLoc.__CreateInstance(__ret);
            }

            public clang.SourceRange getLocalSourceRange()
            {
                var __ret = Internal.getLocalSourceRange_0(__Instance);
                return clang.SourceRange.__CreateInstance(__ret);
            }

            public void copy(clang.DependentTemplateSpecializationTypeLoc Loc)
            {
                var arg0 = ReferenceEquals(Loc, null) ? new clang.DependentTemplateSpecializationTypeLoc.Internal() : *(clang.DependentTemplateSpecializationTypeLoc.Internal*) (Loc.__Instance);
                Internal.copy_0(__Instance, arg0);
            }

            public void initializeLocal(clang.ASTContext Context, clang.SourceLocation Loc)
            {
                var arg0 = ReferenceEquals(Context, null) ? global::System.IntPtr.Zero : Context.__Instance;
                var arg1 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                Internal.initializeLocal_0(__Instance, arg0, arg1);
            }

            public uint getExtraLocalDataSize()
            {
                var __ret = Internal.getExtraLocalDataSize_0(__Instance);
                return __ret;
            }

            public uint getExtraLocalDataAlignment()
            {
                var __ret = Internal.getExtraLocalDataAlignment_0(__Instance);
                return __ret;
            }
        }

        public unsafe partial class PackExpansionTypeLocInfo : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 4)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public clang.SourceLocation.Internal EllipsisLoc;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang24PackExpansionTypeLocInfoC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang24PackExpansionTypeLocInfoC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, PackExpansionTypeLocInfo> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, PackExpansionTypeLocInfo>();

            private readonly bool __ownsNativeInstance;

            public static PackExpansionTypeLocInfo __CreateInstance(global::System.IntPtr native)
            {
                return new PackExpansionTypeLocInfo((PackExpansionTypeLocInfo.Internal*) native);
            }

            public static PackExpansionTypeLocInfo __CreateInstance(PackExpansionTypeLocInfo.Internal native)
            {
                return new PackExpansionTypeLocInfo(native);
            }

            private static PackExpansionTypeLocInfo.Internal* __CopyValue(PackExpansionTypeLocInfo.Internal native)
            {
                var ret = (PackExpansionTypeLocInfo.Internal*) Marshal.AllocHGlobal(4);
                *ret = native;
                return ret;
            }

            private PackExpansionTypeLocInfo(PackExpansionTypeLocInfo.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected PackExpansionTypeLocInfo(PackExpansionTypeLocInfo.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public PackExpansionTypeLocInfo()
            {
                __Instance = Marshal.AllocHGlobal(4);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.PackExpansionTypeLocInfo __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.SourceLocation EllipsisLoc
            {
                get
                {
                    return clang.SourceLocation.__CreateInstance(((Internal*) __Instance)->EllipsisLoc);
                }

                set
                {
                    ((Internal*) __Instance)->EllipsisLoc = ReferenceEquals(value, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (value.__Instance);
                }
            }
        }

        public unsafe partial class PackExpansionTypeLoc : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang20PackExpansionTypeLocC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang20PackExpansionTypeLocC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang20PackExpansionTypeLoc14getEllipsisLocEv")]
                internal static extern clang.SourceLocation.Internal getEllipsisLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang20PackExpansionTypeLoc14setEllipsisLocENS_14SourceLocationE")]
                internal static extern void setEllipsisLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal Loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang20PackExpansionTypeLoc19getLocalSourceRangeEv")]
                internal static extern clang.SourceRange.Internal getLocalSourceRange_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang20PackExpansionTypeLoc15initializeLocalERNS_10ASTContextENS_14SourceLocationE")]
                internal static extern void initializeLocal_0(global::System.IntPtr instance, global::System.IntPtr Context, clang.SourceLocation.Internal Loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang20PackExpansionTypeLoc13getPatternLocEv")]
                internal static extern clang.TypeLoc.Internal getPatternLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang20PackExpansionTypeLoc12getInnerTypeEv")]
                internal static extern clang.QualType.Internal getInnerType_0(global::System.IntPtr instance);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, PackExpansionTypeLoc> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, PackExpansionTypeLoc>();

            private readonly bool __ownsNativeInstance;

            public static PackExpansionTypeLoc __CreateInstance(global::System.IntPtr native)
            {
                return new PackExpansionTypeLoc((PackExpansionTypeLoc.Internal*) native);
            }

            public static PackExpansionTypeLoc __CreateInstance(PackExpansionTypeLoc.Internal native)
            {
                return new PackExpansionTypeLoc(native);
            }

            private static PackExpansionTypeLoc.Internal* __CopyValue(PackExpansionTypeLoc.Internal native)
            {
                var ret = (PackExpansionTypeLoc.Internal*) Marshal.AllocHGlobal(0);
                *ret = native;
                return ret;
            }

            private PackExpansionTypeLoc(PackExpansionTypeLoc.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected PackExpansionTypeLoc(PackExpansionTypeLoc.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public PackExpansionTypeLoc()
            {
                __Instance = Marshal.AllocHGlobal(0);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.PackExpansionTypeLoc __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.SourceLocation getEllipsisLoc()
            {
                var __ret = Internal.getEllipsisLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setEllipsisLoc(clang.SourceLocation Loc)
            {
                var arg0 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                Internal.setEllipsisLoc_0(__Instance, arg0);
            }

            public clang.SourceRange getLocalSourceRange()
            {
                var __ret = Internal.getLocalSourceRange_0(__Instance);
                return clang.SourceRange.__CreateInstance(__ret);
            }

            public void initializeLocal(clang.ASTContext Context, clang.SourceLocation Loc)
            {
                var arg0 = ReferenceEquals(Context, null) ? global::System.IntPtr.Zero : Context.__Instance;
                var arg1 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                Internal.initializeLocal_0(__Instance, arg0, arg1);
            }

            public clang.TypeLoc getPatternLoc()
            {
                var __ret = Internal.getPatternLoc_0(__Instance);
                return clang.TypeLoc.__CreateInstance(__ret);
            }

            public clang.QualType getInnerType()
            {
                var __ret = Internal.getInnerType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }
        }

        public unsafe partial class AtomicTypeLocInfo : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 12)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public clang.SourceLocation.Internal KWLoc;

                [FieldOffset(4)]
                public clang.SourceLocation.Internal LParenLoc;

                [FieldOffset(8)]
                public clang.SourceLocation.Internal RParenLoc;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17AtomicTypeLocInfoC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17AtomicTypeLocInfoC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, AtomicTypeLocInfo> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, AtomicTypeLocInfo>();

            private readonly bool __ownsNativeInstance;

            public static AtomicTypeLocInfo __CreateInstance(global::System.IntPtr native)
            {
                return new AtomicTypeLocInfo((AtomicTypeLocInfo.Internal*) native);
            }

            public static AtomicTypeLocInfo __CreateInstance(AtomicTypeLocInfo.Internal native)
            {
                return new AtomicTypeLocInfo(native);
            }

            private static AtomicTypeLocInfo.Internal* __CopyValue(AtomicTypeLocInfo.Internal native)
            {
                var ret = (AtomicTypeLocInfo.Internal*) Marshal.AllocHGlobal(12);
                *ret = native;
                return ret;
            }

            private AtomicTypeLocInfo(AtomicTypeLocInfo.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected AtomicTypeLocInfo(AtomicTypeLocInfo.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public AtomicTypeLocInfo()
            {
                __Instance = Marshal.AllocHGlobal(12);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.AtomicTypeLocInfo __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.SourceLocation KWLoc
            {
                get
                {
                    return clang.SourceLocation.__CreateInstance(((Internal*) __Instance)->KWLoc);
                }

                set
                {
                    ((Internal*) __Instance)->KWLoc = ReferenceEquals(value, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (value.__Instance);
                }
            }

            public clang.SourceLocation LParenLoc
            {
                get
                {
                    return clang.SourceLocation.__CreateInstance(((Internal*) __Instance)->LParenLoc);
                }

                set
                {
                    ((Internal*) __Instance)->LParenLoc = ReferenceEquals(value, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (value.__Instance);
                }
            }

            public clang.SourceLocation RParenLoc
            {
                get
                {
                    return clang.SourceLocation.__CreateInstance(((Internal*) __Instance)->RParenLoc);
                }

                set
                {
                    ((Internal*) __Instance)->RParenLoc = ReferenceEquals(value, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (value.__Instance);
                }
            }
        }

        public unsafe partial class AtomicTypeLoc : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13AtomicTypeLocC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13AtomicTypeLocC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13AtomicTypeLoc11getValueLocEv")]
                internal static extern clang.TypeLoc.Internal getValueLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13AtomicTypeLoc19getLocalSourceRangeEv")]
                internal static extern clang.SourceRange.Internal getLocalSourceRange_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13AtomicTypeLoc8getKWLocEv")]
                internal static extern clang.SourceLocation.Internal getKWLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13AtomicTypeLoc8setKWLocENS_14SourceLocationE")]
                internal static extern void setKWLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal Loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13AtomicTypeLoc12getLParenLocEv")]
                internal static extern clang.SourceLocation.Internal getLParenLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13AtomicTypeLoc12setLParenLocENS_14SourceLocationE")]
                internal static extern void setLParenLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal Loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13AtomicTypeLoc12getRParenLocEv")]
                internal static extern clang.SourceLocation.Internal getRParenLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13AtomicTypeLoc12setRParenLocENS_14SourceLocationE")]
                internal static extern void setRParenLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal Loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13AtomicTypeLoc14getParensRangeEv")]
                internal static extern clang.SourceRange.Internal getParensRange_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13AtomicTypeLoc14setParensRangeENS_11SourceRangeE")]
                internal static extern void setParensRange_0(global::System.IntPtr instance, clang.SourceRange.Internal Range);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13AtomicTypeLoc15initializeLocalERNS_10ASTContextENS_14SourceLocationE")]
                internal static extern void initializeLocal_0(global::System.IntPtr instance, global::System.IntPtr Context, clang.SourceLocation.Internal Loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13AtomicTypeLoc12getInnerTypeEv")]
                internal static extern clang.QualType.Internal getInnerType_0(global::System.IntPtr instance);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, AtomicTypeLoc> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, AtomicTypeLoc>();

            private readonly bool __ownsNativeInstance;

            public static AtomicTypeLoc __CreateInstance(global::System.IntPtr native)
            {
                return new AtomicTypeLoc((AtomicTypeLoc.Internal*) native);
            }

            public static AtomicTypeLoc __CreateInstance(AtomicTypeLoc.Internal native)
            {
                return new AtomicTypeLoc(native);
            }

            private static AtomicTypeLoc.Internal* __CopyValue(AtomicTypeLoc.Internal native)
            {
                var ret = (AtomicTypeLoc.Internal*) Marshal.AllocHGlobal(0);
                *ret = native;
                return ret;
            }

            private AtomicTypeLoc(AtomicTypeLoc.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected AtomicTypeLoc(AtomicTypeLoc.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public AtomicTypeLoc()
            {
                __Instance = Marshal.AllocHGlobal(0);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.AtomicTypeLoc __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.TypeLoc getValueLoc()
            {
                var __ret = Internal.getValueLoc_0(__Instance);
                return clang.TypeLoc.__CreateInstance(__ret);
            }

            public clang.SourceRange getLocalSourceRange()
            {
                var __ret = Internal.getLocalSourceRange_0(__Instance);
                return clang.SourceRange.__CreateInstance(__ret);
            }

            public clang.SourceLocation getKWLoc()
            {
                var __ret = Internal.getKWLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setKWLoc(clang.SourceLocation Loc)
            {
                var arg0 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                Internal.setKWLoc_0(__Instance, arg0);
            }

            public clang.SourceLocation getLParenLoc()
            {
                var __ret = Internal.getLParenLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setLParenLoc(clang.SourceLocation Loc)
            {
                var arg0 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                Internal.setLParenLoc_0(__Instance, arg0);
            }

            public clang.SourceLocation getRParenLoc()
            {
                var __ret = Internal.getRParenLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setRParenLoc(clang.SourceLocation Loc)
            {
                var arg0 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                Internal.setRParenLoc_0(__Instance, arg0);
            }

            public clang.SourceRange getParensRange()
            {
                var __ret = Internal.getParensRange_0(__Instance);
                return clang.SourceRange.__CreateInstance(__ret);
            }

            public void setParensRange(clang.SourceRange Range)
            {
                var arg0 = ReferenceEquals(Range, null) ? new clang.SourceRange.Internal() : *(clang.SourceRange.Internal*) (Range.__Instance);
                Internal.setParensRange_0(__Instance, arg0);
            }

            public void initializeLocal(clang.ASTContext Context, clang.SourceLocation Loc)
            {
                var arg0 = ReferenceEquals(Context, null) ? global::System.IntPtr.Zero : Context.__Instance;
                var arg1 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                Internal.initializeLocal_0(__Instance, arg0, arg1);
            }

            public clang.QualType getInnerType()
            {
                var __ret = Internal.getInnerType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }
        }
    }
}
