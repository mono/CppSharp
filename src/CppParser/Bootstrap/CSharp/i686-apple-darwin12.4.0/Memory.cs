//----------------------------------------------------------------------------
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
//----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace CppSharp
{
    namespace llvm
    {
        namespace sys
        {
            /// <summary>
            /// <para>Memory block abstraction.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// This class encapsulates the notion of a memory block which
            /// has an address</para>
            /// <para>  /// and a size. It is used by the Memory class (a friend) as
            /// the result of</para>
            /// <para>  /// various memory allocation operations.</para>
            /// <para>  /// @see Memory</para>
            /// <para>  /// @brief Memory block abstraction.</para>
            /// </remarks>
            public unsafe partial class MemoryBlock : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 8)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public global::System.IntPtr Address;

                    [FieldOffset(4)]
                    public uint Size;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN4llvm3sys11MemoryBlockC2Ev")]
                    internal static extern void ctor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN4llvm3sys11MemoryBlockC2EPvm")]
                    internal static extern void ctor_1(global::System.IntPtr instance, global::System.IntPtr addr, uint size);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN4llvm3sys11MemoryBlockC2ERKS1_")]
                    internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK4llvm3sys11MemoryBlock4baseEv")]
                    internal static extern global::System.IntPtr @base_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK4llvm3sys11MemoryBlock4sizeEv")]
                    internal static extern uint size_0(global::System.IntPtr instance);
                }

                public global::System.IntPtr __Instance { get; protected set; }
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, MemoryBlock> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, MemoryBlock>();

                private readonly bool __ownsNativeInstance;

                public static MemoryBlock __CreateInstance(global::System.IntPtr native)
                {
                    return new MemoryBlock((MemoryBlock.Internal*) native);
                }

                public static MemoryBlock __CreateInstance(MemoryBlock.Internal native)
                {
                    return new MemoryBlock(native);
                }

                private static MemoryBlock.Internal* __CopyValue(MemoryBlock.Internal native)
                {
                    var ret = (MemoryBlock.Internal*) Marshal.AllocHGlobal(8);
                    *ret = native;
                    return ret;
                }

                private MemoryBlock(MemoryBlock.Internal native)
                    : this(__CopyValue(native))
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected MemoryBlock(MemoryBlock.Internal* native, bool isInternalImpl = false)
                {
                    __Instance = new global::System.IntPtr(native);
                }

                public MemoryBlock()
                {
                    __Instance = Marshal.AllocHGlobal(8);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_0(__Instance);
                }

                public MemoryBlock(global::System.IntPtr addr, uint size)
                {
                    __Instance = Marshal.AllocHGlobal(8);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    var arg0 = addr;
                    var arg1 = size;
                    Internal.ctor_1(__Instance, arg0, arg1);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    DestroyNativeInstance(false);
                }

                public virtual void DestroyNativeInstance()
                {
                    DestroyNativeInstance(true);
                }

                private void DestroyNativeInstance(bool force)
                {
                    llvm.sys.MemoryBlock __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public global::System.IntPtr @base()
                {
                    var __ret = Internal.@base_0(__Instance);
                    return __ret;
                }

                public uint size()
                {
                    var __ret = Internal.size_0(__Instance);
                    return __ret;
                }
            }

            /// <summary>
            /// <para>An abstraction for memory operations.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// This class provides various memory handling functions that
            /// manipulate</para>
            /// <para>  /// MemoryBlock instances.</para>
            /// <para>  /// @since 1.4</para>
            /// <para>  /// @brief An abstraction for memory operations.</para>
            /// </remarks>
            public unsafe partial class Memory : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 0)]
                public partial struct Internal
                {
                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN4llvm3sys6MemoryC2ERKS1_")]
                    internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN4llvm3sys6Memory20allocateMappedMemoryEmPKNS0_11MemoryBlockEjRNSt3__110error_codeE")]
                    internal static extern llvm.sys.MemoryBlock.Internal allocateMappedMemory_0(uint NumBytes, global::System.IntPtr NearBlock, uint Flags, global::System.IntPtr EC);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN4llvm3sys6Memory19releaseMappedMemoryERNS0_11MemoryBlockE")]
                    internal static extern std.__1.error_code.Internal releaseMappedMemory_0(global::System.IntPtr Block);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN4llvm3sys6Memory19protectMappedMemoryERKNS0_11MemoryBlockEj")]
                    internal static extern std.__1.error_code.Internal protectMappedMemory_0(global::System.IntPtr Block, uint Flags);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN4llvm3sys6Memory26InvalidateInstructionCacheEPKvm")]
                    internal static extern void InvalidateInstructionCache_0(global::System.IntPtr Addr, uint Len);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN4llvm3sys6Memory18setRangeExecutableEPKvm")]
                    [return: MarshalAsAttribute(UnmanagedType.I1)]
                    internal static extern bool setRangeExecutable_0(global::System.IntPtr Addr, uint Size);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN4llvm3sys6Memory16setRangeWritableEPKvm")]
                    [return: MarshalAsAttribute(UnmanagedType.I1)]
                    internal static extern bool setRangeWritable_0(global::System.IntPtr Addr, uint Size);
                }

                [Flags]
                public enum ProtectionFlags : uint
                {
                    MF_READ = 0x1000000,
                    MF_WRITE = 0x2000000,
                    MF_EXEC = 0x4000000
                }

                public global::System.IntPtr __Instance { get; protected set; }
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, Memory> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, Memory>();

                private readonly bool __ownsNativeInstance;

                public static Memory __CreateInstance(global::System.IntPtr native)
                {
                    return new Memory((Memory.Internal*) native);
                }

                public static Memory __CreateInstance(Memory.Internal native)
                {
                    return new Memory(native);
                }

                private static Memory.Internal* __CopyValue(Memory.Internal native)
                {
                    var ret = (Memory.Internal*) Marshal.AllocHGlobal(0);
                    *ret = native;
                    return ret;
                }

                private Memory(Memory.Internal native)
                    : this(__CopyValue(native))
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected Memory(Memory.Internal* native, bool isInternalImpl = false)
                {
                    __Instance = new global::System.IntPtr(native);
                }

                public Memory()
                {
                    __Instance = Marshal.AllocHGlobal(0);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    DestroyNativeInstance(false);
                }

                public virtual void DestroyNativeInstance()
                {
                    DestroyNativeInstance(true);
                }

                private void DestroyNativeInstance(bool force)
                {
                    llvm.sys.Memory __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                /// <summary>
                /// <para>Allocate mapped memory.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// This method allocates a block of memory that is suitable for
                /// loading</para>
                /// <para>    /// dynamically generated code (e.g. JIT). An attempt to
                /// allocate</para>
                /// <para>    /// \p NumBytes bytes of virtual memory is made.</para>
                /// <para>    /// \p NearBlock may point to an existing allocation in which
                /// case</para>
                /// <para>    /// an attempt is made to allocate more memory near the
                /// existing block.</para>
                /// <para>    /// The actual allocated address is not guaranteed to be near
                /// the requested</para>
                /// <para>    /// address.</para>
                /// <para>    /// \p Flags is used to set the initial protection flags for
                /// the block</para>
                /// <para>    /// of the memory.</para>
                /// <para>    /// \p EC [out] returns an object describing any error that
                /// occurs.</para>
                /// <para>    ///</para>
                /// <para>    /// This method may allocate more than the number of bytes
                /// requested.  The</para>
                /// <para>    /// actual number of bytes allocated is indicated in the
                /// returned</para>
                /// <para>    /// MemoryBlock.</para>
                /// <para>    ///</para>
                /// <para>    /// The start of the allocated block must be aligned with
                /// the</para>
                /// <para>    /// system allocation granularity (64K on Windows, page size
                /// on Linux).</para>
                /// <para>    /// If the address following \p NearBlock is not so aligned,
                /// it will be</para>
                /// <para>    /// rounded up to the next allocation granularity
                /// boundary.</para>
                /// <para>    ///</para>
                /// <para>    /// \r a non-null MemoryBlock if the function was successful,
                /// </para>
                /// <para>    /// otherwise a null MemoryBlock is with \p EC describing the
                /// error.</para>
                /// <para>    ///</para>
                /// <para>    /// @brief Allocate mapped memory.</para>
                /// </remarks>
                public static llvm.sys.MemoryBlock allocateMappedMemory(uint NumBytes, llvm.sys.MemoryBlock NearBlock, uint Flags, std.__1.error_code EC)
                {
                    var arg0 = NumBytes;
                    var arg1 = ReferenceEquals(NearBlock, null) ? global::System.IntPtr.Zero : NearBlock.__Instance;
                    var arg3 = ReferenceEquals(EC, null) ? global::System.IntPtr.Zero : EC.__Instance;
                    var __ret = Internal.allocateMappedMemory_0(arg0, arg1, Flags, arg3);
                    return llvm.sys.MemoryBlock.__CreateInstance(__ret);
                }

                /// <summary>
                /// <para>Release mapped memory.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// This method releases a block of memory that was allocated
                /// with the</para>
                /// <para>    /// allocateMappedMemory method. It should not be used to
                /// release any</para>
                /// <para>    /// memory block allocated any other way.</para>
                /// <para>    /// \p Block describes the memory to be released.</para>
                /// <para>    ///</para>
                /// <para>    /// \r error_success if the function was successful, or an
                /// error_code</para>
                /// <para>    /// describing the failure if an error occurred.</para>
                /// <para>    /// </para>
                /// <para>    /// @brief Release mapped memory.</para>
                /// </remarks>
                public static std.__1.error_code releaseMappedMemory(llvm.sys.MemoryBlock Block)
                {
                    var arg0 = ReferenceEquals(Block, null) ? global::System.IntPtr.Zero : Block.__Instance;
                    var __ret = Internal.releaseMappedMemory_0(arg0);
                    return std.__1.error_code.__CreateInstance(__ret);
                }

                /// <summary>
                /// <para>Set memory protection state.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// This method sets the protection flags for a block of memory
                /// to the</para>
                /// <para>    /// state specified by /p Flags.  The behavior is not
                /// specified if the</para>
                /// <para>    /// memory was not allocated using the allocateMappedMemory
                /// method.</para>
                /// <para>    /// \p Block describes the memory block to be
                /// protected.</para>
                /// <para>    /// \p Flags specifies the new protection state to be
                /// assigned to the block.</para>
                /// <para>    /// \p ErrMsg [out] returns a string describing any error
                /// that occurred.</para>
                /// <para>    ///</para>
                /// <para>    /// If \p Flags is MF_WRITE, the actual behavior
                /// varies</para>
                /// <para>    /// with the operating system (i.e. MF_READ | MF_WRITE on
                /// Windows) and the</para>
                /// <para>    /// target architecture (i.e. MF_WRITE -&gt; MF_READ |
                /// MF_WRITE on i386).</para>
                /// <para>    ///</para>
                /// <para>    /// \r error_success if the function was successful, or an
                /// error_code</para>
                /// <para>    /// describing the failure if an error occurred.</para>
                /// <para>    ///</para>
                /// <para>    /// @brief Set memory protection state.</para>
                /// </remarks>
                public static std.__1.error_code protectMappedMemory(llvm.sys.MemoryBlock Block, uint Flags)
                {
                    var arg0 = ReferenceEquals(Block, null) ? global::System.IntPtr.Zero : Block.__Instance;
                    var __ret = Internal.protectMappedMemory_0(arg0, Flags);
                    return std.__1.error_code.__CreateInstance(__ret);
                }

                /// <summary>
                /// <para>InvalidateInstructionCache - Before the JIT can run a block of
                /// code that has been emitted it must invalidate the instruction cache on some
                /// platforms.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// InvalidateInstructionCache - Before the JIT can run a block
                /// of code</para>
                /// <para>    /// that has been emitted it must invalidate the instruction
                /// cache on some</para>
                /// <para>    /// platforms.</para>
                /// </remarks>
                public static void InvalidateInstructionCache(global::System.IntPtr Addr, uint Len)
                {
                    var arg0 = Addr;
                    var arg1 = Len;
                    Internal.InvalidateInstructionCache_0(arg0, arg1);
                }

                /// <summary>
                /// <para>setRangeExecutable - Mark the page containing a range of
                /// addresses as executable.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// setRangeExecutable - Mark the page containing a range of
                /// addresses</para>
                /// <para>    /// as executable.</para>
                /// </remarks>
                public static bool setRangeExecutable(global::System.IntPtr Addr, uint Size)
                {
                    var arg0 = Addr;
                    var arg1 = Size;
                    var __ret = Internal.setRangeExecutable_0(arg0, arg1);
                    return __ret;
                }

                /// <summary>
                /// <para>setRangeWritable - Mark the page containing a range of addresses
                /// as writable.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// setRangeWritable - Mark the page containing a range of
                /// addresses</para>
                /// <para>    /// as writable.</para>
                /// </remarks>
                public static bool setRangeWritable(global::System.IntPtr Addr, uint Size)
                {
                    var arg0 = Addr;
                    var arg1 = Size;
                    var __ret = Internal.setRangeWritable_0(arg0, arg1);
                    return __ret;
                }
            }
        }
    }
}
