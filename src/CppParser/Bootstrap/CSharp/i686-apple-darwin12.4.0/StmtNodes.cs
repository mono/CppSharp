//----------------------------------------------------------------------------
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
//----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace CppSharp
{
    namespace clang
    {
        namespace ast_type_traits
        {
            /// <summary>
            /// <para>Kind identifier.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Kind identifier.</para>
            /// <para>///</para>
            /// <para>/// It can be constructed from any node kind and allows for
            /// runtime type</para>
            /// <para>/// hierarchy checks.</para>
            /// <para>/// Use getFromNodeKind&lt;T&gt;() to construct them.</para>
            /// </remarks>
            public unsafe partial class ASTNodeKind : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 4)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public clang.ast_type_traits.ASTNodeKind.NodeKindId KindId;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang15ast_type_traits11ASTNodeKindC2Ev")]
                    internal static extern void ctor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang15ast_type_traits11ASTNodeKindC2ERKS1_")]
                    internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang15ast_type_traits11ASTNodeKind11getFromNodeERKNS_4DeclE")]
                    internal static extern clang.ast_type_traits.ASTNodeKind.Internal getFromNode_0(global::System.IntPtr D);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang15ast_type_traits11ASTNodeKind11getFromNodeERKNS_4StmtE")]
                    internal static extern clang.ast_type_traits.ASTNodeKind.Internal getFromNode_1(global::System.IntPtr S);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang15ast_type_traits11ASTNodeKind11getFromNodeERKNS_4TypeE")]
                    internal static extern clang.ast_type_traits.ASTNodeKind.Internal getFromNode_2(global::System.IntPtr T);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang15ast_type_traits11ASTNodeKind6isSameES1_")]
                    [return: MarshalAsAttribute(UnmanagedType.I1)]
                    internal static extern bool isSame_0(global::System.IntPtr instance, clang.ast_type_traits.ASTNodeKind.Internal Other);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang15ast_type_traits11ASTNodeKind6isNoneEv")]
                    [return: MarshalAsAttribute(UnmanagedType.I1)]
                    internal static extern bool isNone_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang15ast_type_traits11ASTNodeKind8isBaseOfES1_Pj")]
                    [return: MarshalAsAttribute(UnmanagedType.I1)]
                    internal static extern bool isBaseOf_0(global::System.IntPtr instance, clang.ast_type_traits.ASTNodeKind.Internal Other, uint* Distance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang15ast_type_traits11ASTNodeKind11asStringRefEv")]
                    internal static extern llvm.StringRef.Internal asStringRef_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang15ast_type_traits11ASTNodeKindltERKS1_")]
                    [return: MarshalAsAttribute(UnmanagedType.I1)]
                    internal static extern bool OperatorLess_0(global::System.IntPtr instance, global::System.IntPtr Other);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang15ast_type_traits11ASTNodeKind18getMostDerivedTypeES1_S1_")]
                    internal static extern clang.ast_type_traits.ASTNodeKind.Internal getMostDerivedType_0(clang.ast_type_traits.ASTNodeKind.Internal Kind1, clang.ast_type_traits.ASTNodeKind.Internal Kind2);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang15ast_type_traits11ASTNodeKind28getMostDerivedCommonAncestorES1_S1_")]
                    internal static extern clang.ast_type_traits.ASTNodeKind.Internal getMostDerivedCommonAncestor_0(clang.ast_type_traits.ASTNodeKind.Internal Kind1, clang.ast_type_traits.ASTNodeKind.Internal Kind2);
                }

                /// <summary>
                /// <para>Hooks for using ASTNodeKind as a key in a DenseMap.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Hooks for using ASTNodeKind as a key in a
                /// DenseMap.</para>
                /// </remarks>
                public unsafe partial class DenseMapInfo : IDisposable
                {
                    [StructLayout(LayoutKind.Explicit, Size = 0)]
                    public partial struct Internal
                    {
                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZN5clang15ast_type_traits11ASTNodeKind12DenseMapInfoC2ERKS2_")]
                        internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZN5clang15ast_type_traits11ASTNodeKind12DenseMapInfo11getEmptyKeyEv")]
                        internal static extern clang.ast_type_traits.ASTNodeKind.Internal getEmptyKey_0();

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZN5clang15ast_type_traits11ASTNodeKind12DenseMapInfo15getTombstoneKeyEv")]
                        internal static extern clang.ast_type_traits.ASTNodeKind.Internal getTombstoneKey_0();

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZN5clang15ast_type_traits11ASTNodeKind12DenseMapInfo12getHashValueERKS1_")]
                        internal static extern uint getHashValue_0(global::System.IntPtr Val);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZN5clang15ast_type_traits11ASTNodeKind12DenseMapInfo7isEqualERKS1_S4_")]
                        [return: MarshalAsAttribute(UnmanagedType.I1)]
                        internal static extern bool isEqual_0(global::System.IntPtr LHS, global::System.IntPtr RHS);
                    }

                    public global::System.IntPtr __Instance { get; protected set; }
                    public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, DenseMapInfo> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, DenseMapInfo>();

                    private bool __ownsNativeInstance;

                    public static DenseMapInfo __CreateInstance(global::System.IntPtr native, bool ownsNativeInstance = false)
                    {
                        return new DenseMapInfo((DenseMapInfo.Internal*) native) { __ownsNativeInstance = ownsNativeInstance };
                    }

                    public static DenseMapInfo __CreateInstance(DenseMapInfo.Internal native)
                    {
                        return new DenseMapInfo(native);
                    }

                    private static DenseMapInfo.Internal* __CopyValue(DenseMapInfo.Internal native)
                    {
                        var ret = (DenseMapInfo.Internal*) Marshal.AllocHGlobal(0);
                        *ret = native;
                        return ret;
                    }

                    private DenseMapInfo(DenseMapInfo.Internal native)
                        : this(__CopyValue(native))
                    {
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                    }

                    protected DenseMapInfo(DenseMapInfo.Internal* native, bool isInternalImpl = false)
                    {
                        __Instance = new global::System.IntPtr(native);
                    }

                    public DenseMapInfo()
                    {
                        __Instance = Marshal.AllocHGlobal(0);
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                    }

                    public void Dispose()
                    {
                        Dispose(disposing: true);
                    }

                    protected virtual void Dispose(bool disposing)
                    {
                        DestroyNativeInstance(false);
                    }

                    public virtual void DestroyNativeInstance()
                    {
                        DestroyNativeInstance(true);
                    }

                    private void DestroyNativeInstance(bool force)
                    {
                        clang.ast_type_traits.ASTNodeKind.DenseMapInfo __dummy;
                        NativeToManagedMap.TryRemove(__Instance, out __dummy);
                        if (__ownsNativeInstance)
                            Marshal.FreeHGlobal(__Instance);
                    }

                    public static clang.ast_type_traits.ASTNodeKind getEmptyKey()
                    {
                        var __ret = Internal.getEmptyKey_0();
                        return clang.ast_type_traits.ASTNodeKind.__CreateInstance(__ret);
                    }

                    public static clang.ast_type_traits.ASTNodeKind getTombstoneKey()
                    {
                        var __ret = Internal.getTombstoneKey_0();
                        return clang.ast_type_traits.ASTNodeKind.__CreateInstance(__ret);
                    }

                    public static uint getHashValue(clang.ast_type_traits.ASTNodeKind Val)
                    {
                        var arg0 = ReferenceEquals(Val, null) ? global::System.IntPtr.Zero : Val.__Instance;
                        var __ret = Internal.getHashValue_0(arg0);
                        return __ret;
                    }

                    public static bool isEqual(clang.ast_type_traits.ASTNodeKind LHS, clang.ast_type_traits.ASTNodeKind RHS)
                    {
                        var arg0 = ReferenceEquals(LHS, null) ? global::System.IntPtr.Zero : LHS.__Instance;
                        var arg1 = ReferenceEquals(RHS, null) ? global::System.IntPtr.Zero : RHS.__Instance;
                        var __ret = Internal.isEqual_0(arg0, arg1);
                        return __ret;
                    }
                }

                /// <summary>
                /// <para>Helper meta-function to convert a kind T to its enum
                /// value.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Helper meta-function to convert a kind T to its enum
                /// value.</para>
                /// <para>  ///</para>
                /// <para>  /// This struct is specialized below for all known
                /// kinds.</para>
                /// </remarks>
                public unsafe partial class KindToKindId
                {
                    [StructLayout(LayoutKind.Explicit, Size = 0)]
                    public partial struct Internal
                    {
                    }
                }

                /// <summary>
                /// <para>Per kind info.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Per kind info.</para>
                /// </remarks>
                internal unsafe partial class KindInfo
                {
                    [StructLayout(LayoutKind.Explicit, Size = 8)]
                    public partial struct Internal
                    {
                        [FieldOffset(0)]
                        public clang.ast_type_traits.ASTNodeKind.NodeKindId ParentId;

                        [FieldOffset(4)]
                        public global::System.IntPtr Name;
                    }
                }

                public global::System.IntPtr __Instance { get; protected set; }
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ASTNodeKind> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ASTNodeKind>();

                private bool __ownsNativeInstance;

                public static ASTNodeKind __CreateInstance(global::System.IntPtr native, bool ownsNativeInstance = false)
                {
                    return new ASTNodeKind((ASTNodeKind.Internal*) native) { __ownsNativeInstance = ownsNativeInstance };
                }

                public static ASTNodeKind __CreateInstance(ASTNodeKind.Internal native)
                {
                    return new ASTNodeKind(native);
                }

                private static ASTNodeKind.Internal* __CopyValue(ASTNodeKind.Internal native)
                {
                    var ret = (ASTNodeKind.Internal*) Marshal.AllocHGlobal(4);
                    *ret = native;
                    return ret;
                }

                private ASTNodeKind(ASTNodeKind.Internal native)
                    : this(__CopyValue(native))
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected ASTNodeKind(ASTNodeKind.Internal* native, bool isInternalImpl = false)
                {
                    __Instance = new global::System.IntPtr(native);
                }

                /// <summary>
                /// <para>Empty identifier. It matches nothing.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Empty identifier. It matches nothing.</para>
                /// </remarks>
                public ASTNodeKind()
                {
                    __Instance = Marshal.AllocHGlobal(4);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_0(__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    DestroyNativeInstance(false);
                }

                public virtual void DestroyNativeInstance()
                {
                    DestroyNativeInstance(true);
                }

                private void DestroyNativeInstance(bool force)
                {
                    clang.ast_type_traits.ASTNodeKind __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                /// <summary>
                /// <para>Returns true if this and Other represent the same kind.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Returns \c true if \c this and \c Other represent the
                /// same kind.</para>
                /// </remarks>
                public bool isSame(clang.ast_type_traits.ASTNodeKind Other)
                {
                    var arg0 = ReferenceEquals(Other, null) ? new clang.ast_type_traits.ASTNodeKind.Internal() : *(clang.ast_type_traits.ASTNodeKind.Internal*) (Other.__Instance);
                    var __ret = Internal.isSame_0(__Instance, arg0);
                    return __ret;
                }

                /// <summary>
                /// <para>Returns true only for the default ASTNodeKind()</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Returns \c true only for the default \c
                /// ASTNodeKind()</para>
                /// </remarks>
                public bool isNone()
                {
                    var __ret = Internal.isNone_0(__Instance);
                    return __ret;
                }

                /// <summary>
                /// <para>Returns true if this is a base kind of (or same as) Other.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Returns \c true if \c this is a base kind of (or same
                /// as) \c Other.</para>
                /// <para>  /// \param Distance If non-null, used to return the distance
                /// between \c this</para>
                /// <para>  /// and \c Other in the class hierarchy.</para>
                /// </remarks>
                public bool isBaseOf(clang.ast_type_traits.ASTNodeKind Other, ref uint Distance)
                {
                    var arg0 = ReferenceEquals(Other, null) ? new clang.ast_type_traits.ASTNodeKind.Internal() : *(clang.ast_type_traits.ASTNodeKind.Internal*) (Other.__Instance);
                    fixed (uint* arg1 = &Distance)
                    {
                        var __ret = Internal.isBaseOf_0(__Instance, arg0, arg1);
                        return __ret;
                    }
                }

                /// <summary>
                /// <para>String representation of the kind.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief String representation of the kind.</para>
                /// </remarks>
                public llvm.StringRef asStringRef()
                {
                    var __ret = Internal.asStringRef_0(__Instance);
                    return llvm.StringRef.__CreateInstance(__ret);
                }

                public static bool operator >(clang.ast_type_traits.ASTNodeKind __op, clang.ast_type_traits.ASTNodeKind Other)
                {
                    return !(__op < Other);
                }

                /// <summary>
                /// <para>Strict weak ordering for ASTNodeKind.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Strict weak ordering for ASTNodeKind.</para>
                /// </remarks>
                public static bool operator <(clang.ast_type_traits.ASTNodeKind __op, clang.ast_type_traits.ASTNodeKind Other)
                {
                    var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
                    var arg1 = ReferenceEquals(Other, null) ? global::System.IntPtr.Zero : Other.__Instance;
                    var __ret = Internal.OperatorLess_0(arg0, arg1);
                    return __ret;
                }

                /// <summary>
                /// <para>Construct an identifier for the dynamic type of the node</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \{</para>
                /// <para>  /// \brief Construct an identifier for the dynamic type of the
                /// node</para>
                /// </remarks>
                public static clang.ast_type_traits.ASTNodeKind getFromNode(clang.Decl D)
                {
                    var arg0 = ReferenceEquals(D, null) ? global::System.IntPtr.Zero : D.__Instance;
                    var __ret = Internal.getFromNode_0(arg0);
                    return clang.ast_type_traits.ASTNodeKind.__CreateInstance(__ret);
                }

                public static clang.ast_type_traits.ASTNodeKind getFromNode(clang.Stmt S)
                {
                    var arg0 = ReferenceEquals(S, null) ? global::System.IntPtr.Zero : S.__Instance;
                    var __ret = Internal.getFromNode_1(arg0);
                    return clang.ast_type_traits.ASTNodeKind.__CreateInstance(__ret);
                }

                public static clang.ast_type_traits.ASTNodeKind getFromNode(clang.Type T)
                {
                    var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                    var __ret = Internal.getFromNode_2(arg0);
                    return clang.ast_type_traits.ASTNodeKind.__CreateInstance(__ret);
                }

                /// <summary>
                /// <para>Return the most derived type between Kind1 and Kind2.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Return the most derived type between \p Kind1 and \p
                /// Kind2.</para>
                /// <para>  ///</para>
                /// <para>  /// Return ASTNodeKind() if they are not related.</para>
                /// </remarks>
                public static clang.ast_type_traits.ASTNodeKind getMostDerivedType(clang.ast_type_traits.ASTNodeKind Kind1, clang.ast_type_traits.ASTNodeKind Kind2)
                {
                    var arg0 = ReferenceEquals(Kind1, null) ? new clang.ast_type_traits.ASTNodeKind.Internal() : *(clang.ast_type_traits.ASTNodeKind.Internal*) (Kind1.__Instance);
                    var arg1 = ReferenceEquals(Kind2, null) ? new clang.ast_type_traits.ASTNodeKind.Internal() : *(clang.ast_type_traits.ASTNodeKind.Internal*) (Kind2.__Instance);
                    var __ret = Internal.getMostDerivedType_0(arg0, arg1);
                    return clang.ast_type_traits.ASTNodeKind.__CreateInstance(__ret);
                }

                /// <summary>
                /// <para>Return the most derived common ancestor between Kind1 and
                /// Kind2.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Return the most derived common ancestor between Kind1
                /// and Kind2.</para>
                /// <para>  ///</para>
                /// <para>  /// Return ASTNodeKind() if they are not related.</para>
                /// </remarks>
                public static clang.ast_type_traits.ASTNodeKind getMostDerivedCommonAncestor(clang.ast_type_traits.ASTNodeKind Kind1, clang.ast_type_traits.ASTNodeKind Kind2)
                {
                    var arg0 = ReferenceEquals(Kind1, null) ? new clang.ast_type_traits.ASTNodeKind.Internal() : *(clang.ast_type_traits.ASTNodeKind.Internal*) (Kind1.__Instance);
                    var arg1 = ReferenceEquals(Kind2, null) ? new clang.ast_type_traits.ASTNodeKind.Internal() : *(clang.ast_type_traits.ASTNodeKind.Internal*) (Kind2.__Instance);
                    var __ret = Internal.getMostDerivedCommonAncestor_0(arg0, arg1);
                    return clang.ast_type_traits.ASTNodeKind.__CreateInstance(__ret);
                }
            }

            /// <summary>
            /// <para>A dynamically typed AST node container.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief A dynamically typed AST node container.</para>
            /// <para>///</para>
            /// <para>/// Stores an AST node in a type safe way. This allows writing
            /// code that</para>
            /// <para>/// works with different kinds of AST nodes, despite the fact
            /// that they don't</para>
            /// <para>/// have a common base class.</para>
            /// <para>///</para>
            /// <para>/// Use \c create(Node) to create a \c DynTypedNode from an AST
            /// node,</para>
            /// <para>/// and \c get&lt;T&gt;() to retrieve the node as type T if the
            /// types match.</para>
            /// <para>///</para>
            /// <para>/// See \c ASTNodeKind for which node base types are currently
            /// supported;</para>
            /// <para>/// You can create DynTypedNodes for all nodes in the inheritance
            /// hierarchy of</para>
            /// <para>/// the supported base types.</para>
            /// </remarks>
            public unsafe partial class DynTypedNode : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 28)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public clang.ast_type_traits.ASTNodeKind.Internal NodeKind;

                    [FieldOffset(4)]
                    public global::System.IntPtr MemoizationData;

                    [FieldOffset(8)]
                    internal llvm.AlignedCharArrayUnion.Internal Storage;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang15ast_type_traits12DynTypedNodeC2Ev")]
                    internal static extern void ctor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang15ast_type_traits12DynTypedNodeC2ERKS1_")]
                    internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang15ast_type_traits12DynTypedNode11getNodeKindEv")]
                    internal static extern clang.ast_type_traits.ASTNodeKind.Internal getNodeKind_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang15ast_type_traits12DynTypedNode18getMemoizationDataEv")]
                    internal static extern global::System.IntPtr getMemoizationData_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang15ast_type_traits12DynTypedNode5printERN4llvm11raw_ostreamERKNS_14PrintingPolicyE")]
                    internal static extern void print_0(global::System.IntPtr instance, global::System.IntPtr OS, global::System.IntPtr PP);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang15ast_type_traits12DynTypedNode4dumpERN4llvm11raw_ostreamERNS_13SourceManagerE")]
                    internal static extern void dump_0(global::System.IntPtr instance, global::System.IntPtr OS, global::System.IntPtr SM);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang15ast_type_traits12DynTypedNode14getSourceRangeEv")]
                    internal static extern clang.SourceRange.Internal getSourceRange_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang15ast_type_traits12DynTypedNodeltERKS1_")]
                    [return: MarshalAsAttribute(UnmanagedType.I1)]
                    internal static extern bool OperatorLess_0(global::System.IntPtr instance, global::System.IntPtr Other);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang15ast_type_traits12DynTypedNodeeqERKS1_")]
                    [return: MarshalAsAttribute(UnmanagedType.I1)]
                    internal static extern bool OperatorEqualEqual_0(global::System.IntPtr instance, global::System.IntPtr Other);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang15ast_type_traits12DynTypedNodeneERKS1_")]
                    [return: MarshalAsAttribute(UnmanagedType.I1)]
                    internal static extern bool OperatorExclaimEqual_0(global::System.IntPtr instance, global::System.IntPtr Other);
                }

                /// <summary>
                /// <para>Converter that uses dyn_cast&lt;T&gt; from a stored
                /// BaseT*.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Converter that uses dyn_cast&lt;T&gt; from a stored
                /// BaseT*.</para>
                /// </remarks>
                public unsafe partial class DynCastPtrConverter
                {
                    [StructLayout(LayoutKind.Explicit, Size = 0)]
                    public partial struct Internal
                    {
                    }
                }

                /// <summary>
                /// <para>Converter that stores T* (by pointer).</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Converter that stores T* (by pointer).</para>
                /// </remarks>
                public unsafe partial class PtrConverter
                {
                    [StructLayout(LayoutKind.Explicit, Size = 0)]
                    public partial struct Internal
                    {
                    }
                }

                /// <summary>
                /// <para>Converter that stores T (by value).</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Converter that stores T (by value).</para>
                /// </remarks>
                public unsafe partial class ValueConverter
                {
                    [StructLayout(LayoutKind.Explicit, Size = 0)]
                    public partial struct Internal
                    {
                    }
                }

                public global::System.IntPtr __Instance { get; protected set; }
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, DynTypedNode> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, DynTypedNode>();

                private bool __ownsNativeInstance;

                public static DynTypedNode __CreateInstance(global::System.IntPtr native, bool ownsNativeInstance = false)
                {
                    return new DynTypedNode((DynTypedNode.Internal*) native) { __ownsNativeInstance = ownsNativeInstance };
                }

                public static DynTypedNode __CreateInstance(DynTypedNode.Internal native)
                {
                    return new DynTypedNode(native);
                }

                private static DynTypedNode.Internal* __CopyValue(DynTypedNode.Internal native)
                {
                    var ret = (DynTypedNode.Internal*) Marshal.AllocHGlobal(28);
                    *ret = native;
                    return ret;
                }

                private DynTypedNode(DynTypedNode.Internal native)
                    : this(__CopyValue(native))
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected DynTypedNode(DynTypedNode.Internal* native, bool isInternalImpl = false)
                {
                    __Instance = new global::System.IntPtr(native);
                }

                public DynTypedNode()
                {
                    __Instance = Marshal.AllocHGlobal(28);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_0(__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    DestroyNativeInstance(false);
                }

                public virtual void DestroyNativeInstance()
                {
                    DestroyNativeInstance(true);
                }

                private void DestroyNativeInstance(bool force)
                {
                    clang.ast_type_traits.DynTypedNode __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public clang.ast_type_traits.ASTNodeKind getNodeKind()
                {
                    var __ret = Internal.getNodeKind_0(__Instance);
                    return clang.ast_type_traits.ASTNodeKind.__CreateInstance(__ret);
                }

                /// <summary>
                /// <para>Returns a pointer that identifies the stored AST node.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Returns a pointer that identifies the stored AST
                /// node.</para>
                /// <para>  ///</para>
                /// <para>  /// Note that this is not supported by all AST nodes. For AST
                /// nodes</para>
                /// <para>  /// that don't have a pointer-defined identity inside the AST,
                /// this</para>
                /// <para>  /// method returns NULL.</para>
                /// </remarks>
                public global::System.IntPtr getMemoizationData()
                {
                    var __ret = Internal.getMemoizationData_0(__Instance);
                    return __ret;
                }

                /// <summary>
                /// <para>Prints the node to the given output stream.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Prints the node to the given output stream.</para>
                /// </remarks>
                public void print(llvm.raw_ostream OS, clang.PrintingPolicy PP)
                {
                    var arg0 = ReferenceEquals(OS, null) ? global::System.IntPtr.Zero : OS.__Instance;
                    var arg1 = ReferenceEquals(PP, null) ? global::System.IntPtr.Zero : PP.__Instance;
                    Internal.print_0(__Instance, arg0, arg1);
                }

                /// <summary>
                /// <para>Dumps the node to the given output stream.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Dumps the node to the given output stream.</para>
                /// </remarks>
                public void dump(llvm.raw_ostream OS, clang.SourceManager SM)
                {
                    var arg0 = ReferenceEquals(OS, null) ? global::System.IntPtr.Zero : OS.__Instance;
                    var arg1 = ReferenceEquals(SM, null) ? global::System.IntPtr.Zero : SM.__Instance;
                    Internal.dump_0(__Instance, arg0, arg1);
                }

                /// <summary>
                /// <para>For nodes which represent textual entities in the source code,
                /// return their SourceRange. For all other nodes, return SourceRange().</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief For nodes which represent textual entities in the
                /// source code,</para>
                /// <para>  /// return their SourceRange.  For all other nodes, return
                /// SourceRange().</para>
                /// </remarks>
                public clang.SourceRange getSourceRange()
                {
                    var __ret = Internal.getSourceRange_0(__Instance);
                    return clang.SourceRange.__CreateInstance(__ret);
                }

                public static bool operator >(clang.ast_type_traits.DynTypedNode __op, clang.ast_type_traits.DynTypedNode Other)
                {
                    return !(__op < Other);
                }

                /// <summary>
                /// <para>Imposes an order on DynTypedNode.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// @{</para>
                /// <para>  /// \brief Imposes an order on \c DynTypedNode.</para>
                /// <para>  ///</para>
                /// <para>  /// Supports comparison of nodes that support
                /// memoization.</para>
                /// <para>  /// FIXME: Implement comparsion for other node types
                /// (currently</para>
                /// <para>  /// only Stmt, Decl, Type and NestedNameSpecifier return
                /// memoization data).</para>
                /// </remarks>
                public static bool operator <(clang.ast_type_traits.DynTypedNode __op, clang.ast_type_traits.DynTypedNode Other)
                {
                    var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
                    var arg1 = ReferenceEquals(Other, null) ? global::System.IntPtr.Zero : Other.__Instance;
                    var __ret = Internal.OperatorLess_0(arg0, arg1);
                    return __ret;
                }

                public static bool operator ==(clang.ast_type_traits.DynTypedNode __op, clang.ast_type_traits.DynTypedNode Other)
                {
                    bool __opNull = ReferenceEquals(__op, null);
                    bool OtherNull = ReferenceEquals(Other, null);
                    if (__opNull || OtherNull)
                        return __opNull && OtherNull;
                    var arg0 = __op.__Instance;
                    var arg1 = Other.__Instance;
                    var __ret = Internal.OperatorEqualEqual_0(arg0, arg1);
                    return __ret;
                }

                public override bool Equals(object obj)
                {
                    return this == obj as DynTypedNode;
                }

                public static bool operator !=(clang.ast_type_traits.DynTypedNode __op, clang.ast_type_traits.DynTypedNode Other)
                {
                    var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
                    var arg1 = ReferenceEquals(Other, null) ? global::System.IntPtr.Zero : Other.__Instance;
                    var __ret = Internal.OperatorExclaimEqual_0(arg0, arg1);
                    return __ret;
                }
            }
        }
    }
}
