//----------------------------------------------------------------------------
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
//----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace CppSharp
{
    namespace clang
    {
        /// <summary>
        /// <para>CastKind - The kind of operation required for a
        /// conversion.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// CastKind - The kind of operation required for a
        /// conversion.</para>
        /// </remarks>
        public enum CastKind : uint
        {
            /// <summary>CK_Dependent - A conversion which cannot yet be analyzed because either the expression or target type is dependent. These are created only for explicit casts; dependent ASTs aren't required to even approximately type-check. (T*) malloc(sizeof(T)) reinterpret_cast<intptr_t>(A<T>::alloc());</summary>
            CK_Dependent = 0,
            /// <summary>CK_BitCast - A conversion which causes a bit pattern of one type to be reinterpreted as a bit pattern of another type. Generally the operands must have equivalent size and unrelated types.</summary>
            CK_BitCast = 1,
            /// <summary>CK_LValueBitCast - A conversion which reinterprets the address of an l-value as an l-value of a different kind. Used for reinterpret_casts of l-value expressions to reference types. bool b; reinterpret_cast<char&>(b) = 'a';</summary>
            CK_LValueBitCast = 2,
            /// <summary>CK_LValueToRValue - A conversion which causes the extraction of an r-value from the operand gl-value. The result of an r-value conversion is always unqualified.</summary>
            CK_LValueToRValue = 3,
            /// <summary>CK_NoOp - A conversion which does not affect the type other than (possibly) adding qualifiers. int -> int char** -> const char * const *</summary>
            CK_NoOp = 4,
            /// <summary>CK_BaseToDerived - A conversion from a C++ class pointer/reference to a derived class pointer/reference. B *b = static_cast<B*>(a);</summary>
            CK_BaseToDerived = 5,
            /// <summary>CK_DerivedToBase - A conversion from a C++ class pointer to a base class pointer. A *a = new B();</summary>
            CK_DerivedToBase = 6,
            /// <summary>CK_UncheckedDerivedToBase - A conversion from a C++ class pointer/reference to a base class that can assume that the derived pointer is not null. const A &a = B(); b->method_from_a();</summary>
            CK_UncheckedDerivedToBase = 7,
            /// <summary>CK_Dynamic - A C++ dynamic_cast.</summary>
            CK_Dynamic = 8,
            /// <summary>CK_ToUnion - The GCC cast-to-union extension. int -> union { int x; float y; } float -> union { int x; float y; }</summary>
            CK_ToUnion = 9,
            /// <summary>CK_ArrayToPointerDecay - Array to pointer decay. int[10] -> int* char[5][6] -> char(*)[6]</summary>
            CK_ArrayToPointerDecay = 10,
            /// <summary>CK_FunctionToPointerDecay - Function to pointer decay. void(int) -> void(*)(int)</summary>
            CK_FunctionToPointerDecay = 11,
            /// <summary>CK_NullToPointer - Null pointer constant to pointer, ObjC pointer, or block pointer. (void*) 0 void (^block)() = 0;</summary>
            CK_NullToPointer = 12,
            /// <summary>CK_NullToMemberPointer - Null pointer constant to member pointer. int A::*mptr = 0; int (A::*fptr)(int) = nullptr;</summary>
            CK_NullToMemberPointer = 13,
            /// <summary>CK_BaseToDerivedMemberPointer - Member pointer in base class to member pointer in derived class. int B::*mptr = &A::member;</summary>
            CK_BaseToDerivedMemberPointer = 14,
            /// <summary>CK_DerivedToBaseMemberPointer - Member pointer in derived class to member pointer in base class. int A::*mptr = static_cast<int A::*>(&B::member);</summary>
            CK_DerivedToBaseMemberPointer = 15,
            /// <summary>CK_MemberPointerToBoolean - Member pointer to boolean. A check against the null member pointer.</summary>
            CK_MemberPointerToBoolean = 16,
            /// <summary>CK_ReinterpretMemberPointer - Reinterpret a member pointer as a different kind of member pointer. C++ forbids this from crossing between function and object types, but otherwise does not restrict it. However, the only operation that is permitted on a "punned" member pointer is casting it back to the original type, which is required to be a lossless operation (although many ABIs do not guarantee this on all possible intermediate types).</summary>
            CK_ReinterpretMemberPointer = 17,
            /// <summary>CK_UserDefinedConversion - Conversion using a user defined type conversion function. struct A { operator int(); }; int i = int(A());</summary>
            CK_UserDefinedConversion = 18,
            /// <summary>CK_ConstructorConversion - Conversion by constructor. struct A { A(int); }; A a = A(10);</summary>
            CK_ConstructorConversion = 19,
            /// <summary>CK_IntegralToPointer - Integral to pointer. A special kind of reinterpreting conversion. Applies to normal, ObjC, and block pointers. (char*) 0x1001aab0 reinterpret_cast<int*>(0)</summary>
            CK_IntegralToPointer = 20,
            /// <summary>CK_PointerToIntegral - Pointer to integral. A special kind of reinterpreting conversion. Applies to normal, ObjC, and block pointers. (intptr_t) "help!"</summary>
            CK_PointerToIntegral = 21,
            /// <summary>CK_PointerToBoolean - Pointer to boolean conversion. A check against null. Applies to normal, ObjC, and block pointers.</summary>
            CK_PointerToBoolean = 22,
            /// <summary>CK_ToVoid - Cast to void, discarding the computed value. (void) malloc(2048)</summary>
            CK_ToVoid = 23,
            /// <summary>CK_VectorSplat - A conversion from an arithmetic type to a vector of that element type. Fills all elements ("splats") with the source value. __attribute__((ext_vector_type(4))) int v = 5;</summary>
            CK_VectorSplat = 24,
            /// <summary>CK_IntegralCast - A cast between integral types (other than to boolean). Variously a bitcast, a truncation, a sign-extension, or a zero-extension. long l = 5; (unsigned) i</summary>
            CK_IntegralCast = 25,
            /// <summary>CK_IntegralToBoolean - Integral to boolean. A check against zero. (bool) i</summary>
            CK_IntegralToBoolean = 26,
            /// <summary>CK_IntegralToFloating - Integral to floating point. float f = i;</summary>
            CK_IntegralToFloating = 27,
            /// <summary>CK_FloatingToIntegral - Floating point to integral. Rounds towards zero, discarding any fractional component. (int) f</summary>
            CK_FloatingToIntegral = 28,
            /// <summary>CK_FloatingToBoolean - Floating point to boolean. (bool) f</summary>
            CK_FloatingToBoolean = 29,
            /// <summary>CK_FloatingCast - Casting between floating types of different size. (double) f (float) ld</summary>
            CK_FloatingCast = 30,
            /// <summary>CK_CPointerToObjCPointerCast - Casting a C pointer kind to an Objective-C pointer.</summary>
            CK_CPointerToObjCPointerCast = 31,
            /// <summary>CK_BlockPointerToObjCPointerCast - Casting a block pointer to an ObjC pointer.</summary>
            CK_BlockPointerToObjCPointerCast = 32,
            /// <summary>CK_AnyPointerToBlockPointerCast - Casting any non-block pointer to a block pointer. Block-to-block casts are bitcasts.</summary>
            CK_AnyPointerToBlockPointerCast = 33,
            /// <summary>Converting between two Objective-C object types, which can occur when performing reference binding to an Objective-C object.</summary>
            CK_ObjCObjectLValueCast = 34,
            /// <summary>A conversion of a floating point real to a floating point complex of the original type. Injects the value as the real component with a zero imaginary component. float -> _Complex float</summary>
            CK_FloatingRealToComplex = 35,
            /// <summary>Converts a floating point complex to floating point real of the source's element type. Just discards the imaginary component. _Complex long double -> long double</summary>
            CK_FloatingComplexToReal = 36,
            /// <summary>Converts a floating point complex to bool by comparing against 0+0i.</summary>
            CK_FloatingComplexToBoolean = 37,
            /// <summary>Converts between different floating point complex types. _Complex float -> _Complex double</summary>
            CK_FloatingComplexCast = 38,
            /// <summary>Converts from a floating complex to an integral complex. _Complex float -> _Complex int</summary>
            CK_FloatingComplexToIntegralComplex = 39,
            /// <summary>Converts from an integral real to an integral complex whose element type matches the source. Injects the value as the real component with a zero imaginary component. long -> _Complex long</summary>
            CK_IntegralRealToComplex = 40,
            /// <summary>Converts an integral complex to an integral real of the source's element type by discarding the imaginary component. _Complex short -> short</summary>
            CK_IntegralComplexToReal = 41,
            /// <summary>Converts an integral complex to bool by comparing against 0+0i.</summary>
            CK_IntegralComplexToBoolean = 42,
            /// <summary>Converts between different integral complex types. _Complex char -> _Complex long long _Complex unsigned int -> _Complex signed int</summary>
            CK_IntegralComplexCast = 43,
            /// <summary>Converts from an integral complex to a floating complex. _Complex unsigned -> _Complex float</summary>
            CK_IntegralComplexToFloatingComplex = 44,
            /// <summary>[ARC] Produces a retainable object pointer so that it may be consumed, e.g. by being passed to a consuming parameter. Calls objc_retain.</summary>
            CK_ARCProduceObject = 45,
            /// <summary>[ARC] Consumes a retainable object pointer that has just been produced, e.g. as the return value of a retaining call. Enters a cleanup to call objc_release at some indefinite time.</summary>
            CK_ARCConsumeObject = 46,
            /// <summary>[ARC] Reclaim a retainable object pointer object that may have been produced and autoreleased as part of a function return sequence.</summary>
            CK_ARCReclaimReturnedObject = 47,
            /// <summary>[ARC] Causes a value of block type to be copied to the heap, if it is not already there. A number of other operations in ARC cause blocks to be copied; this is for cases where that would not otherwise be guaranteed, such as when casting to a non-block pointer type.</summary>
            CK_ARCExtendBlockObject = 48,
            /// <summary>Converts from _Atomic(T) to T.</summary>
            CK_AtomicToNonAtomic = 49,
            /// <summary>Converts from T to _Atomic(T).</summary>
            CK_NonAtomicToAtomic = 50,
            /// <summary>Causes a block literal to by copied to the heap and then autoreleased.</summary>
            CK_CopyAndAutoreleaseBlockObject = 51,
            CK_BuiltinFnToFnPtr = 52,
            CK_ZeroToOCLEvent = 53,
            CK_AddressSpaceConversion = 54
        }

        public enum BinaryOperatorKind : uint
        {
            BO_PtrMemD = 0,
            BO_PtrMemI = 1,
            BO_Mul = 2,
            BO_Div = 3,
            BO_Rem = 4,
            BO_Add = 5,
            BO_Sub = 6,
            BO_Shl = 7,
            BO_Shr = 8,
            BO_LT = 9,
            BO_GT = 10,
            BO_LE = 11,
            BO_GE = 12,
            BO_EQ = 13,
            BO_NE = 14,
            BO_And = 15,
            BO_Xor = 16,
            BO_Or = 17,
            BO_LAnd = 18,
            BO_LOr = 19,
            BO_Assign = 20,
            BO_MulAssign = 21,
            BO_DivAssign = 22,
            BO_RemAssign = 23,
            BO_AddAssign = 24,
            BO_SubAssign = 25,
            BO_ShlAssign = 26,
            BO_ShrAssign = 27,
            BO_AndAssign = 28,
            BO_XorAssign = 29,
            BO_OrAssign = 30,
            BO_Comma = 31
        }

        public enum UnaryOperatorKind : uint
        {
            UO_PostInc = 0,
            UO_PostDec = 1,
            UO_PreInc = 2,
            UO_PreDec = 3,
            UO_AddrOf = 4,
            UO_Deref = 5,
            UO_Plus = 6,
            UO_Minus = 7,
            UO_Not = 8,
            UO_LNot = 9,
            UO_Real = 10,
            UO_Imag = 11,
            UO_Extension = 12
        }

        /// <summary>
        /// <para>The kind of bridging performed by the Objective-C bridge
        /// cast.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief The kind of bridging performed by the Objective-C
        /// bridge cast.</para>
        /// </remarks>
        public enum ObjCBridgeCastKind : uint
        {
            /// <summary>Bridging via __bridge, which does nothing but reinterpret the bits.</summary>
            OBC_Bridge = 0,
            /// <summary>Bridging via __bridge_transfer, which transfers ownership of an Objective-C pointer into ARC.</summary>
            OBC_BridgeTransfer = 1,
            /// <summary>Bridging via __bridge_retain, which makes an ARC object available as a +1 C pointer.</summary>
            OBC_BridgeRetained = 2
        }
    }
}
