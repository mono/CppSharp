//----------------------------------------------------------------------------
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
//----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace CppSharp
{
    namespace clang
    {
        /// <summary>
        /// <para>A family of Objective-C methods.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief A family of Objective-C methods. </para>
        /// <para>///</para>
        /// <para>/// These families have no inherent meaning in the language, but
        /// are</para>
        /// <para>/// nonetheless central enough in the existing implementations
        /// to</para>
        /// <para>/// merit direct AST support.  While, in theory, arbitrary
        /// methods can</para>
        /// <para>/// be considered to form families, we focus here on the
        /// methods</para>
        /// <para>/// involving allocation and retain-count management, as these
        /// are the</para>
        /// <para>/// most &quot;core&quot; and the most likely to be useful to
        /// diverse clients</para>
        /// <para>/// without extra information.</para>
        /// <para>///</para>
        /// <para>/// Both selectors and actual method declarations may be
        /// classified</para>
        /// <para>/// into families.  Method families may impose additional
        /// restrictions</para>
        /// <para>/// beyond their selector name; for example, a method called
        /// '_init'</para>
        /// <para>/// that returns void is not considered to be in the 'init'
        /// family</para>
        /// <para>/// (but would be if it returned 'id').  It is also possible
        /// to</para>
        /// <para>/// explicitly change or remove a method's family.  Therefore
        /// the</para>
        /// <para>/// method's family should be considered the single source of
        /// truth.</para>
        /// </remarks>
        public enum ObjCMethodFamily : uint
        {
            /// <summary>No particular method family.</summary>
            OMF_None = 0,
            /// <summary>No particular method family.</summary>
            OMF_alloc = 1,
            /// <summary>No particular method family.</summary>
            OMF_copy = 2,
            /// <summary>No particular method family.</summary>
            OMF_init = 3,
            /// <summary>No particular method family.</summary>
            OMF_mutableCopy = 4,
            /// <summary>No particular method family.</summary>
            OMF_new = 5,
            /// <summary>No particular method family.</summary>
            OMF_autorelease = 6,
            /// <summary>No particular method family.</summary>
            OMF_dealloc = 7,
            /// <summary>No particular method family.</summary>
            OMF_finalize = 8,
            /// <summary>No particular method family.</summary>
            OMF_release = 9,
            /// <summary>No particular method family.</summary>
            OMF_retain = 10,
            /// <summary>No particular method family.</summary>
            OMF_retainCount = 11,
            /// <summary>No particular method family.</summary>
            OMF_self = 12,
            /// <summary>No particular method family.</summary>
            OMF_initialize = 13,
            /// <summary>No particular method family.</summary>
            OMF_performSelector = 14
        }

        public enum ObjCStringFormatFamily : uint
        {
            SFF_None = 0,
            SFF_NSString = 1,
            SFF_CFString = 2
        }

        /// <summary>
        /// <para>A family of Objective-C methods.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief A family of Objective-C methods.</para>
        /// <para>///</para>
        /// <para>/// These are family of methods whose result type is initially
        /// 'id', but</para>
        /// <para>/// but are candidate for the result type to be changed to
        /// 'instancetype'.</para>
        /// </remarks>
        public enum ObjCInstanceTypeFamily : uint
        {
            OIT_None = 0,
            OIT_Array = 1,
            OIT_Dictionary = 2,
            OIT_Singleton = 3,
            OIT_Init = 4,
            OIT_ReturnsSelf = 5
        }

        /// <summary>
        /// <para>Enough bits to store any enumerator in ObjCMethodFamily or
        /// InvalidObjCMethodFamily.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// Enough bits to store any enumerator in ObjCMethodFamily
        /// or</para>
        /// <para>/// InvalidObjCMethodFamily.</para>
        /// </remarks>
        [Flags]
        public enum ObjCMethodFamilyBitWidth : uint
        {
            ObjCMethodFamilyBitWidth = 4
        }

        /// <summary>
        /// <para>An invalid value of ObjCMethodFamily.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief An invalid value of ObjCMethodFamily.</para>
        /// </remarks>
        public enum InvalidObjCMethodFamily : uint
        {
            InvalidObjCMethodFamily = 15
        }

        /// <summary>
        /// <para>One of these records is kept for each identifier that is lexed.
        /// This contains information about whether the token was #define'd, is a
        /// language keyword, or if it is a front-end token of some sort (e.g. a
        /// variable or function name). The preprocessor keeps this information in a
        /// set, and all tok::identifier tokens have a pointer to one of these.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// One of these records is kept for each identifier that</para>
        /// <para>/// is lexed.  This contains information about whether the token
        /// was \#define'd,</para>
        /// <para>/// is a language keyword, or if it is a front-end token of some
        /// sort (e.g. a</para>
        /// <para>/// variable or function name).  The preprocessor keeps this
        /// information in a</para>
        /// <para>/// set, and all tok::identifier tokens have a pointer to one of
        /// these.</para>
        /// </remarks>
        public unsafe partial class IdentifierInfo : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 12)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public uint TokenID;

                [FieldOffset(1)]
                public uint ObjCOrBuiltinID;

                [FieldOffset(2)]
                public bool HasMacro;

                [FieldOffset(2)]
                public bool HadMacro;

                [FieldOffset(2)]
                public bool IsExtension;

                [FieldOffset(2)]
                public bool IsCXX11CompatKeyword;

                [FieldOffset(3)]
                public bool IsPoisoned;

                [FieldOffset(3)]
                public bool IsCPPOperatorKeyword;

                [FieldOffset(3)]
                public bool NeedsHandleIdentifier;

                [FieldOffset(3)]
                public bool IsFromAST;

                [FieldOffset(3)]
                public bool ChangedAfterLoad;

                [FieldOffset(3)]
                public bool RevertedTokenID;

                [FieldOffset(3)]
                public bool OutOfDate;

                [FieldOffset(3)]
                public bool IsModulesImport;

                [FieldOffset(4)]
                public global::System.IntPtr FETokenInfo;

                [FieldOffset(8)]
                public global::System.IntPtr Entry;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14IdentifierInfoC2Ev")]
                internal static extern void ctor_1(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14IdentifierInfo12getNameStartEv")]
                internal static extern global::System.IntPtr getNameStart_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14IdentifierInfo9getLengthEv")]
                internal static extern uint getLength_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14IdentifierInfo7getNameEv")]
                internal static extern llvm.StringRef.Internal getName_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14IdentifierInfo18hasMacroDefinitionEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasMacroDefinition_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14IdentifierInfo21setHasMacroDefinitionEb")]
                internal static extern void setHasMacroDefinition_0(global::System.IntPtr instance, bool Val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14IdentifierInfo18hadMacroDefinitionEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hadMacroDefinition_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14IdentifierInfo10getTokenIDEv")]
                internal static extern clang.tok.TokenKind getTokenID_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14IdentifierInfo30hasRevertedTokenIDToIdentifierEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasRevertedTokenIDToIdentifier_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14IdentifierInfo25RevertTokenIDToIdentifierEv")]
                internal static extern void RevertTokenIDToIdentifier_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14IdentifierInfo14getPPKeywordIDEv")]
                internal static extern clang.tok.PPKeywordKind getPPKeywordID_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14IdentifierInfo16getObjCKeywordIDEv")]
                internal static extern clang.tok.ObjCKeywordKind getObjCKeywordID_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14IdentifierInfo16setObjCKeywordIDENS_3tok15ObjCKeywordKindE")]
                internal static extern void setObjCKeywordID_0(global::System.IntPtr instance, clang.tok.ObjCKeywordKind ID);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14IdentifierInfo12getBuiltinIDEv")]
                internal static extern uint getBuiltinID_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14IdentifierInfo12setBuiltinIDEj")]
                internal static extern void setBuiltinID_0(global::System.IntPtr instance, uint ID);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14IdentifierInfo18getObjCOrBuiltinIDEv")]
                internal static extern uint getObjCOrBuiltinID_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14IdentifierInfo18setObjCOrBuiltinIDEj")]
                internal static extern void setObjCOrBuiltinID_0(global::System.IntPtr instance, uint ID);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14IdentifierInfo16isExtensionTokenEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isExtensionToken_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14IdentifierInfo19setIsExtensionTokenEb")]
                internal static extern void setIsExtensionToken_0(global::System.IntPtr instance, bool Val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14IdentifierInfo20isCXX11CompatKeywordEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isCXX11CompatKeyword_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14IdentifierInfo23setIsCXX11CompatKeywordEb")]
                internal static extern void setIsCXX11CompatKeyword_0(global::System.IntPtr instance, bool Val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14IdentifierInfo13setIsPoisonedEb")]
                internal static extern void setIsPoisoned_0(global::System.IntPtr instance, bool Value);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14IdentifierInfo10isPoisonedEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isPoisoned_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14IdentifierInfo29setIsCPlusPlusOperatorKeywordEb")]
                internal static extern void setIsCPlusPlusOperatorKeyword_0(global::System.IntPtr instance, bool Val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14IdentifierInfo26isCPlusPlusOperatorKeywordEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isCPlusPlusOperatorKeyword_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14IdentifierInfo9isKeywordERKNS_11LangOptionsE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isKeyword_0(global::System.IntPtr instance, global::System.IntPtr LangOpts);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14IdentifierInfo14setFETokenInfoEPv")]
                internal static extern void setFETokenInfo_0(global::System.IntPtr instance, global::System.IntPtr T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14IdentifierInfo22isHandleIdentifierCaseEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isHandleIdentifierCase_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14IdentifierInfo9isFromASTEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isFromAST_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14IdentifierInfo12setIsFromASTEv")]
                internal static extern void setIsFromAST_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14IdentifierInfo30hasChangedSinceDeserializationEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasChangedSinceDeserialization_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14IdentifierInfo30setChangedSinceDeserializationEv")]
                internal static extern void setChangedSinceDeserialization_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14IdentifierInfo11isOutOfDateEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isOutOfDate_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14IdentifierInfo12setOutOfDateEb")]
                internal static extern void setOutOfDate_0(global::System.IntPtr instance, bool OOD);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14IdentifierInfo15isModulesImportEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isModulesImport_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14IdentifierInfo16setModulesImportEb")]
                internal static extern void setModulesImport_0(global::System.IntPtr instance, bool I);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, IdentifierInfo> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, IdentifierInfo>();

            private readonly bool __ownsNativeInstance;

            public static IdentifierInfo __CreateInstance(global::System.IntPtr native)
            {
                return new IdentifierInfo((IdentifierInfo.Internal*) native);
            }

            public static IdentifierInfo __CreateInstance(IdentifierInfo.Internal native)
            {
                return new IdentifierInfo(native);
            }

            private static IdentifierInfo.Internal* __CopyValue(IdentifierInfo.Internal native)
            {
                var ret = (IdentifierInfo.Internal*) Marshal.AllocHGlobal(12);
                *ret = native;
                return ret;
            }

            private IdentifierInfo(IdentifierInfo.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected IdentifierInfo(IdentifierInfo.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public IdentifierInfo()
            {
                __Instance = Marshal.AllocHGlobal(12);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_1(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.IdentifierInfo __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            /// <summary>
            /// <para>Return the beginning of the actual null-terminated string for
            /// this identifier.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the beginning of the actual null-terminated
            /// string for this</para>
            /// <para>  /// identifier.</para>
            /// <para>  ///</para>
            /// </remarks>
            public string getNameStart()
            {
                var __ret = Internal.getNameStart_0(__Instance);
                return Marshal.PtrToStringAnsi(__ret);
            }

            /// <summary>
            /// <para>Efficiently return the length of this identifier info.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Efficiently return the length of this identifier
            /// info.</para>
            /// <para>  ///</para>
            /// </remarks>
            public uint getLength()
            {
                var __ret = Internal.getLength_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Return the actual identifier string.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the actual identifier string.</para>
            /// </remarks>
            public llvm.StringRef getName()
            {
                var __ret = Internal.getName_0(__Instance);
                return llvm.StringRef.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Return true if this identifier is #defined to some other
            /// value.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return true if this identifier is \#defined to some
            /// other value.</para>
            /// </remarks>
            public bool hasMacroDefinition()
            {
                var __ret = Internal.hasMacroDefinition_0(__Instance);
                return __ret;
            }

            public void setHasMacroDefinition(bool Val)
            {
                Internal.setHasMacroDefinition_0(__Instance, Val);
            }

            /// <summary>
            /// <para>Returns true if this identifier was #defined to some value at any
            /// moment. In this case there should be an entry for the identifier in the
            /// macro history table in Preprocessor.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Returns true if this identifier was \#defined to some
            /// value at any</para>
            /// <para>  /// moment. In this case there should be an entry for the
            /// identifier in the</para>
            /// <para>  /// macro history table in Preprocessor.</para>
            /// </remarks>
            public bool hadMacroDefinition()
            {
                var __ret = Internal.hadMacroDefinition_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>If this is a source-language token (e.g. 'for'), this API can be
            /// used to cause the lexer to map identifiers to source-language
            /// tokens.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// If this is a source-language token (e.g. 'for'), this
            /// API</para>
            /// <para>  /// can be used to cause the lexer to map identifiers to
            /// source-language</para>
            /// <para>  /// tokens.</para>
            /// </remarks>
            public clang.tok.TokenKind getTokenID()
            {
                var __ret = Internal.getTokenID_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>True if RevertTokenIDToIdentifier() was called.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief True if RevertTokenIDToIdentifier() was called.</para>
            /// </remarks>
            public bool hasRevertedTokenIDToIdentifier()
            {
                var __ret = Internal.hasRevertedTokenIDToIdentifier_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Revert TokenID to tok::identifier; used for GNU libstdc++ 4.2
            /// compatibility.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Revert TokenID to tok::identifier; used for GNU
            /// libstdc++ 4.2</para>
            /// <para>  /// compatibility.</para>
            /// <para>  ///</para>
            /// <para>  /// TokenID is normally read-only but there are 2 instances
            /// where we revert it</para>
            /// <para>  /// to tok::identifier for libstdc++ 4.2. Keep track of when
            /// this happens</para>
            /// <para>  /// using this method so we can inform serialization about
            /// it.</para>
            /// </remarks>
            public void RevertTokenIDToIdentifier()
            {
                Internal.RevertTokenIDToIdentifier_0(__Instance);
            }

            /// <summary>
            /// <para>Return the preprocessor keyword ID for this identifier.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the preprocessor keyword ID for this
            /// identifier.</para>
            /// <para>  ///</para>
            /// <para>  /// For example, &quot;define&quot; will return
            /// tok::pp_define.</para>
            /// </remarks>
            public clang.tok.PPKeywordKind getPPKeywordID()
            {
                var __ret = Internal.getPPKeywordID_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Return the Objective-C keyword ID for the this identifier.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the Objective-C keyword ID for the this
            /// identifier.</para>
            /// <para>  ///</para>
            /// <para>  /// For example, 'class' will return tok::objc_class if ObjC is
            /// enabled.</para>
            /// </remarks>
            public clang.tok.ObjCKeywordKind getObjCKeywordID()
            {
                var __ret = Internal.getObjCKeywordID_0(__Instance);
                return __ret;
            }

            public void setObjCKeywordID(clang.tok.ObjCKeywordKind ID)
            {
                var arg0 = ID;
                Internal.setObjCKeywordID_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>Return a value indicating whether this is a builtin
            /// function.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return a value indicating whether this is a builtin
            /// function.</para>
            /// <para>  ///</para>
            /// <para>  /// 0 is not-built-in.  1 is
            /// builtin-for-some-nonprimary-target.</para>
            /// <para>  /// 2+ are specific builtin functions.</para>
            /// </remarks>
            public uint getBuiltinID()
            {
                var __ret = Internal.getBuiltinID_0(__Instance);
                return __ret;
            }

            public void setBuiltinID(uint ID)
            {
                Internal.setBuiltinID_0(__Instance, ID);
            }

            public uint getObjCOrBuiltinID()
            {
                var __ret = Internal.getObjCOrBuiltinID_0(__Instance);
                return __ret;
            }

            public void setObjCOrBuiltinID(uint ID)
            {
                Internal.setObjCOrBuiltinID_0(__Instance, ID);
            }

            /// <summary>
            /// <para>get/setExtension - Initialize information about whether or not
            /// this language token is an extension. This controls extension warnings, and
            /// is only valid if a custom token ID is set.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// get/setExtension - Initialize information about whether or
            /// not this</para>
            /// <para>  /// language token is an extension.  This controls extension
            /// warnings, and is</para>
            /// <para>  /// only valid if a custom token ID is set.</para>
            /// </remarks>
            public bool isExtensionToken()
            {
                var __ret = Internal.isExtensionToken_0(__Instance);
                return __ret;
            }

            public void setIsExtensionToken(bool Val)
            {
                Internal.setIsExtensionToken_0(__Instance, Val);
            }

            /// <summary>
            /// <para>is/setIsCXX11CompatKeyword - Initialize information about whether
            /// or not this language token is a keyword in C++11. This controls
            /// compatibility warnings, and is only true when not parsing C++11. Once a
            /// compatibility problem has been diagnosed with this keyword, the flag will
            /// be cleared.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// is/setIsCXX11CompatKeyword - Initialize information about
            /// whether or not</para>
            /// <para>  /// this language token is a keyword in C++11. This controls
            /// compatibility</para>
            /// <para>  /// warnings, and is only true when not parsing C++11. Once a
            /// compatibility</para>
            /// <para>  /// problem has been diagnosed with this keyword, the flag will
            /// be cleared.</para>
            /// </remarks>
            public bool isCXX11CompatKeyword()
            {
                var __ret = Internal.isCXX11CompatKeyword_0(__Instance);
                return __ret;
            }

            public void setIsCXX11CompatKeyword(bool Val)
            {
                Internal.setIsCXX11CompatKeyword_0(__Instance, Val);
            }

            /// <summary>
            /// <para>setIsPoisoned - Mark this identifier as poisoned. After
            /// poisoning, the Preprocessor will emit an error every time this token is
            /// used.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// setIsPoisoned - Mark this identifier as poisoned.  After
            /// poisoning, the</para>
            /// <para>  /// Preprocessor will emit an error every time this token is
            /// used.</para>
            /// </remarks>
            public void setIsPoisoned(bool Value)
            {
                Internal.setIsPoisoned_0(__Instance, Value);
            }

            /// <summary>
            /// <para>Return true if this token has been poisoned.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return true if this token has been poisoned.</para>
            /// </remarks>
            public bool isPoisoned()
            {
                var __ret = Internal.isPoisoned_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>isCPlusPlusOperatorKeyword/setIsCPlusPlusOperatorKeyword controls
            /// whether this identifier is a C++ alternate representation of an
            /// operator.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// isCPlusPlusOperatorKeyword/setIsCPlusPlusOperatorKeyword
            /// controls whether</para>
            /// <para>  /// this identifier is a C++ alternate representation of an
            /// operator.</para>
            /// </remarks>
            public void setIsCPlusPlusOperatorKeyword(bool Val)
            {
                Internal.setIsCPlusPlusOperatorKeyword_0(__Instance, Val);
            }

            public bool isCPlusPlusOperatorKeyword()
            {
                var __ret = Internal.isCPlusPlusOperatorKeyword_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Return true if this token is a keyword in the specified
            /// language.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return true if this token is a keyword in the
            /// specified language.</para>
            /// </remarks>
            public bool isKeyword(clang.LangOptions LangOpts)
            {
                var arg0 = ReferenceEquals(LangOpts, null) ? global::System.IntPtr.Zero : LangOpts.__Instance;
                var __ret = Internal.isKeyword_0(__Instance, arg0);
                return __ret;
            }

            public void setFETokenInfo(global::System.IntPtr T)
            {
                var arg0 = T;
                Internal.setFETokenInfo_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>Return true if the Preprocessor::HandleIdentifier must be called
            /// on a token of this identifier.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return true if the Preprocessor::HandleIdentifier must
            /// be called</para>
            /// <para>  /// on a token of this identifier.</para>
            /// <para>  ///</para>
            /// <para>  /// If this returns false, we know that HandleIdentifier will
            /// not affect</para>
            /// <para>  /// the token.</para>
            /// </remarks>
            public bool isHandleIdentifierCase()
            {
                var __ret = Internal.isHandleIdentifierCase_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Return true if the identifier in its current state was loaded
            /// from an AST file.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return true if the identifier in its current state was
            /// loaded</para>
            /// <para>  /// from an AST file.</para>
            /// </remarks>
            public bool isFromAST()
            {
                var __ret = Internal.isFromAST_0(__Instance);
                return __ret;
            }

            public void setIsFromAST()
            {
                Internal.setIsFromAST_0(__Instance);
            }

            /// <summary>
            /// <para>Determine whether this identifier has changed since it was loaded
            /// from an AST file.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine whether this identifier has changed since it
            /// was loaded</para>
            /// <para>  /// from an AST file.</para>
            /// </remarks>
            public bool hasChangedSinceDeserialization()
            {
                var __ret = Internal.hasChangedSinceDeserialization_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Note that this identifier has changed since it was loaded from an
            /// AST file.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Note that this identifier has changed since it was
            /// loaded from</para>
            /// <para>  /// an AST file.</para>
            /// </remarks>
            public void setChangedSinceDeserialization()
            {
                Internal.setChangedSinceDeserialization_0(__Instance);
            }

            /// <summary>
            /// <para>Determine whether the information for this identifier is out of
            /// date with respect to the external source.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine whether the information for this identifier
            /// is out of</para>
            /// <para>  /// date with respect to the external source.</para>
            /// </remarks>
            public bool isOutOfDate()
            {
                var __ret = Internal.isOutOfDate_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Set whether the information for this identifier is out of date
            /// with respect to the external source.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Set whether the information for this identifier is out
            /// of</para>
            /// <para>  /// date with respect to the external source.</para>
            /// </remarks>
            public void setOutOfDate(bool OOD)
            {
                Internal.setOutOfDate_0(__Instance, OOD);
            }

            /// <summary>
            /// <para>Determine whether this is the contextual keyword import.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine whether this is the contextual keyword \c
            /// import.</para>
            /// </remarks>
            public bool isModulesImport()
            {
                var __ret = Internal.isModulesImport_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Set whether this identifier is the contextual keyword
            /// import.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Set whether this identifier is the contextual keyword
            /// \c import.</para>
            /// </remarks>
            public void setModulesImport(bool I)
            {
                Internal.setModulesImport_0(__Instance, I);
            }
        }

        /// <summary>
        /// <para>An RAII object for [un]poisoning an identifier within a
        /// scope.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief An RAII object for [un]poisoning an identifier within
        /// a scope.</para>
        /// <para>///</para>
        /// <para>/// \p II is allowed to be null, in which case objects of this
        /// type have</para>
        /// <para>/// no effect.</para>
        /// </remarks>
        public unsafe partial class PoisonIdentifierRAIIObject : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 8)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr II;

                [FieldOffset(4)]
                public bool OldValue;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang26PoisonIdentifierRAIIObjectC2EPNS_14IdentifierInfoEb")]
                internal static extern void ctor_0(global::System.IntPtr instance, global::System.IntPtr II, bool NewValue);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang26PoisonIdentifierRAIIObjectC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang26PoisonIdentifierRAIIObjectD2Ev")]
                internal static extern void dtor_0(global::System.IntPtr instance);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, PoisonIdentifierRAIIObject> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, PoisonIdentifierRAIIObject>();

            private readonly bool __ownsNativeInstance;

            public static PoisonIdentifierRAIIObject __CreateInstance(global::System.IntPtr native)
            {
                return new PoisonIdentifierRAIIObject((PoisonIdentifierRAIIObject.Internal*) native);
            }

            public static PoisonIdentifierRAIIObject __CreateInstance(PoisonIdentifierRAIIObject.Internal native)
            {
                return new PoisonIdentifierRAIIObject(native);
            }

            private static PoisonIdentifierRAIIObject.Internal* __CopyValue(PoisonIdentifierRAIIObject.Internal native)
            {
                var ret = (PoisonIdentifierRAIIObject.Internal*) Marshal.AllocHGlobal(8);
                *ret = native;
                return ret;
            }

            private PoisonIdentifierRAIIObject(PoisonIdentifierRAIIObject.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected PoisonIdentifierRAIIObject(PoisonIdentifierRAIIObject.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public PoisonIdentifierRAIIObject(clang.IdentifierInfo II, bool NewValue)
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(II, null) ? global::System.IntPtr.Zero : II.__Instance;
                Internal.ctor_0(__Instance, arg0, NewValue);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.PoisonIdentifierRAIIObject __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance || force)
                    Internal.dtor_0(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>An iterator that walks over all of the known identifiers in the
        /// lookup table.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief An iterator that walks over all of the known
        /// identifiers</para>
        /// <para>/// in the lookup table.</para>
        /// <para>///</para>
        /// <para>/// Since this iterator uses an abstract interface via
        /// virtual</para>
        /// <para>/// functions, it uses an object-oriented interface rather than
        /// the</para>
        /// <para>/// more standard C++ STL iterator interface. In this
        /// OO-style</para>
        /// <para>/// iteration, the single function \c Next() provides
        /// dereference,</para>
        /// <para>/// advance, and end-of-sequence checking in a single</para>
        /// <para>/// operation. Subclasses of this iterator type will provide
        /// the</para>
        /// <para>/// actual functionality.</para>
        /// </remarks>
        public unsafe abstract partial class IdentifierIterator : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 4)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr vfptr0;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang18IdentifierIteratorC2Ev")]
                internal static extern void ctor_1(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang18IdentifierIteratorD2Ev")]
                internal static extern void dtor_0(global::System.IntPtr instance);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, IdentifierIterator> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, IdentifierIterator>();

            private readonly bool __ownsNativeInstance;

            public static IdentifierIterator __CreateInstance(global::System.IntPtr native)
            {
                return new IdentifierIteratorInternal((IdentifierIterator.Internal*) native);
            }

            public static IdentifierIterator __CreateInstance(IdentifierIterator.Internal native)
            {
                return new IdentifierIteratorInternal(native);
            }

            protected IdentifierIterator(IdentifierIterator.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
                if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                    SetupVTables(__Instance);
            }

            protected IdentifierIterator()
            {
                __Instance = Marshal.AllocHGlobal(4);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_1(__Instance);
                SetupVTables(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.IdentifierIterator __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance || force)
                    Internal.dtor_0(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            /// <summary>
            /// <para>Retrieve the next string in the identifier table and advances the
            /// iterator for the following string.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the next string in the identifier table
            /// and</para>
            /// <para>  /// advances the iterator for the following string.</para>
            /// <para>  ///</para>
            /// <para>  /// \returns The next string in the identifier table. If there
            /// is</para>
            /// <para>  /// no such string, returns an empty \c StringRef.</para>
            /// </remarks>
            public abstract llvm.StringRef Next();

            #region Virtual table interop

            // virtual ~IdentifierIterator()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
            private static _dtor_0Delegate _dtor_0DelegateInstance;

            private static void _dtor_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (IdentifierIterator) _References[instance].Target;
                __target.DestroyNativeInstance();
            }

            // StringRef Next() = 0
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate llvm.StringRef.Internal _Next_0Delegate(global::System.IntPtr instance);
            private static _Next_0Delegate _Next_0DelegateInstance;

            private static llvm.StringRef.Internal _Next_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (IdentifierIterator) _References[instance].Target;
                var __ret = __target.Next();
                return ReferenceEquals(__ret, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (__ret.__Instance);
            }

            private static void*[] _OldVTables;
            private static void*[] _NewVTables;
            private static void*[] _Thunks;
            private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

            void SetupVTables(global::System.IntPtr instance)
            {
                var native = (Internal*)instance.ToPointer();

                if (_References == null)
                    _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

                if (_References.ContainsKey(instance))
                    return;

                _References[instance] = new WeakReference(this);

                if (_OldVTables == null)
                {
                    _OldVTables = new void*[1];
                    _OldVTables[0] = native->vfptr0.ToPointer();
                }

                if (_Thunks == null)
                {
                    _Thunks = new void*[2];
                    _dtor_0DelegateInstance += _dtor_0DelegateHook;
                    _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                    _Next_0DelegateInstance += _Next_0DelegateHook;
                    _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_Next_0DelegateInstance).ToPointer();
                }

                if (_NewVTables == null)
                {
                    _NewVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(2 * 4);
                    _NewVTables[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + 4) = _Thunks[0];
                    *(void**)(vfptr0 + 8) = _Thunks[1];
                }

                native->vfptr0 = new IntPtr(_NewVTables[0]);
            }

            #endregion
        }

        /// <summary>
        /// <para>Provides lookups to, and iteration over, IdentiferInfo
        /// objects.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief Provides lookups to, and iteration over, IdentiferInfo
        /// objects.</para>
        /// </remarks>
        public unsafe abstract partial class IdentifierInfoLookup : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 4)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr vfptr0;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang20IdentifierInfoLookupC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang20IdentifierInfoLookupC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang20IdentifierInfoLookupD2Ev")]
                internal static extern void dtor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang20IdentifierInfoLookup14getIdentifiersEv")]
                internal static extern global::System.IntPtr getIdentifiers_0(global::System.IntPtr instance);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, IdentifierInfoLookup> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, IdentifierInfoLookup>();

            private readonly bool __ownsNativeInstance;

            public static IdentifierInfoLookup __CreateInstance(global::System.IntPtr native)
            {
                return new IdentifierInfoLookupInternal((IdentifierInfoLookup.Internal*) native);
            }

            public static IdentifierInfoLookup __CreateInstance(IdentifierInfoLookup.Internal native)
            {
                return new IdentifierInfoLookupInternal(native);
            }

            protected IdentifierInfoLookup(IdentifierInfoLookup.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
                if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                    SetupVTables(__Instance);
            }

            protected IdentifierInfoLookup()
            {
                __Instance = Marshal.AllocHGlobal(4);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
                SetupVTables(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.IdentifierInfoLookup __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance || force)
                    Internal.dtor_0(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            /// <summary>
            /// <para>Return the IdentifierInfo for the specified named
            /// identifier.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the IdentifierInfo for the specified named
            /// identifier.</para>
            /// <para>  ///</para>
            /// <para>  /// Unlike the version in IdentifierTable, this returns a
            /// pointer instead</para>
            /// <para>  /// of a reference.  If the pointer is null then the
            /// IdentifierInfo cannot</para>
            /// <para>  /// be found.</para>
            /// </remarks>
            public abstract clang.IdentifierInfo get(llvm.StringRef Name);

            /// <summary>
            /// <para>Retrieve an iterator into the set of all identifiers known to
            /// this identifier lookup source.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve an iterator into the set of all
            /// identifiers</para>
            /// <para>  /// known to this identifier lookup source.</para>
            /// <para>  ///</para>
            /// <para>  /// This routine provides access to all of the identifiers
            /// known to</para>
            /// <para>  /// the identifier lookup, allowing access to the contents of
            /// the</para>
            /// <para>  /// identifiers without introducing the overhead of
            /// constructing</para>
            /// <para>  /// IdentifierInfo objects for each.</para>
            /// <para>  ///</para>
            /// <para>  /// \returns A new iterator into the set of known identifiers.
            /// The</para>
            /// <para>  /// caller is responsible for deleting this iterator.</para>
            /// </remarks>
            public virtual clang.IdentifierIterator getIdentifiers()
            {
                var __ret = Internal.getIdentifiers_0(__Instance);
                clang.IdentifierIterator __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.IdentifierIterator.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.IdentifierIterator) clang.IdentifierIterator.NativeToManagedMap[__ret];
                else clang.IdentifierIterator.NativeToManagedMap[__ret] = __result0 = (clang.IdentifierIterator) clang.IdentifierIterator.__CreateInstance(__ret);
                return __result0;
            }

            #region Virtual table interop

            // virtual ~IdentifierInfoLookup()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
            private static _dtor_0Delegate _dtor_0DelegateInstance;

            private static void _dtor_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (IdentifierInfoLookup) _References[instance].Target;
                __target.DestroyNativeInstance();
            }

            // IdentifierInfo* get(StringRef Name) = 0
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _get_0Delegate(global::System.IntPtr instance, llvm.StringRef.Internal Name);
            private static _get_0Delegate _get_0DelegateInstance;

            private static global::System.IntPtr _get_0DelegateHook(global::System.IntPtr instance, llvm.StringRef.Internal Name)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (IdentifierInfoLookup) _References[instance].Target;
                var __ret = __target.get(llvm.StringRef.__CreateInstance(Name));
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // IdentifierIterator *getIdentifiers()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getIdentifiers_0Delegate(global::System.IntPtr instance);
            private static _getIdentifiers_0Delegate _getIdentifiers_0DelegateInstance;

            private static global::System.IntPtr _getIdentifiers_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (IdentifierInfoLookup) _References[instance].Target;
                var __ret = __target.getIdentifiers();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            private static void*[] _OldVTables;
            private static void*[] _NewVTables;
            private static void*[] _Thunks;
            private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

            void SetupVTables(global::System.IntPtr instance)
            {
                var native = (Internal*)instance.ToPointer();

                if (_References == null)
                    _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

                if (_References.ContainsKey(instance))
                    return;

                _References[instance] = new WeakReference(this);

                if (_OldVTables == null)
                {
                    _OldVTables = new void*[1];
                    _OldVTables[0] = native->vfptr0.ToPointer();
                }

                if (_Thunks == null)
                {
                    _Thunks = new void*[3];
                    _dtor_0DelegateInstance += _dtor_0DelegateHook;
                    _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                    _get_0DelegateInstance += _get_0DelegateHook;
                    _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_get_0DelegateInstance).ToPointer();
                    _getIdentifiers_0DelegateInstance += _getIdentifiers_0DelegateHook;
                    _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_getIdentifiers_0DelegateInstance).ToPointer();
                }

                if (_NewVTables == null)
                {
                    _NewVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 4);
                    _NewVTables[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + 4) = _Thunks[0];
                    *(void**)(vfptr0 + 8) = _Thunks[1];
                    *(void**)(vfptr0 + 12) = _Thunks[2];
                }

                native->vfptr0 = new IntPtr(_NewVTables[0]);
            }

            #endregion
        }

        /// <summary>
        /// <para>An abstract class used to resolve numerical identifier references
        /// (meaningful only to some external source) into IdentifierInfo
        /// pointers.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief An abstract class used to resolve numerical
        /// identifier</para>
        /// <para>/// references (meaningful only to some external source)
        /// into</para>
        /// <para>/// IdentifierInfo pointers.</para>
        /// </remarks>
        public unsafe abstract partial class ExternalIdentifierLookup : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 4)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr vfptr0;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang24ExternalIdentifierLookupC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang24ExternalIdentifierLookupC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang24ExternalIdentifierLookupD2Ev")]
                internal static extern void dtor_0(global::System.IntPtr instance);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ExternalIdentifierLookup> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ExternalIdentifierLookup>();

            private readonly bool __ownsNativeInstance;

            public static ExternalIdentifierLookup __CreateInstance(global::System.IntPtr native)
            {
                return new ExternalIdentifierLookupInternal((ExternalIdentifierLookup.Internal*) native);
            }

            public static ExternalIdentifierLookup __CreateInstance(ExternalIdentifierLookup.Internal native)
            {
                return new ExternalIdentifierLookupInternal(native);
            }

            protected ExternalIdentifierLookup(ExternalIdentifierLookup.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
                if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                    SetupVTables(__Instance);
            }

            protected ExternalIdentifierLookup()
            {
                __Instance = Marshal.AllocHGlobal(4);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
                SetupVTables(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.ExternalIdentifierLookup __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance || force)
                    Internal.dtor_0(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            /// <summary>
            /// <para>Return the identifier associated with the given ID number.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the identifier associated with the given ID
            /// number.</para>
            /// <para>  ///</para>
            /// <para>  /// The ID 0 is associated with the NULL identifier.</para>
            /// </remarks>
            public abstract clang.IdentifierInfo GetIdentifier(uint ID);

            #region Virtual table interop

            // virtual ~ExternalIdentifierLookup()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
            private static _dtor_0Delegate _dtor_0DelegateInstance;

            private static void _dtor_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (ExternalIdentifierLookup) _References[instance].Target;
                __target.DestroyNativeInstance();
            }

            // IdentifierInfo *GetIdentifier(unsigned ID) = 0
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _GetIdentifier_0Delegate(global::System.IntPtr instance, uint ID);
            private static _GetIdentifier_0Delegate _GetIdentifier_0DelegateInstance;

            private static global::System.IntPtr _GetIdentifier_0DelegateHook(global::System.IntPtr instance, uint ID)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (ExternalIdentifierLookup) _References[instance].Target;
                var __ret = __target.GetIdentifier(ID);
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            private static void*[] _OldVTables;
            private static void*[] _NewVTables;
            private static void*[] _Thunks;
            private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

            void SetupVTables(global::System.IntPtr instance)
            {
                var native = (Internal*)instance.ToPointer();

                if (_References == null)
                    _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

                if (_References.ContainsKey(instance))
                    return;

                _References[instance] = new WeakReference(this);

                if (_OldVTables == null)
                {
                    _OldVTables = new void*[1];
                    _OldVTables[0] = native->vfptr0.ToPointer();
                }

                if (_Thunks == null)
                {
                    _Thunks = new void*[2];
                    _dtor_0DelegateInstance += _dtor_0DelegateHook;
                    _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                    _GetIdentifier_0DelegateInstance += _GetIdentifier_0DelegateHook;
                    _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetIdentifier_0DelegateInstance).ToPointer();
                }

                if (_NewVTables == null)
                {
                    _NewVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(2 * 4);
                    _NewVTables[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + 4) = _Thunks[0];
                    *(void**)(vfptr0 + 8) = _Thunks[1];
                }

                native->vfptr0 = new IntPtr(_NewVTables[0]);
            }

            #endregion
        }

        /// <summary>
        /// <para>Implements an efficient mapping from strings to IdentifierInfo
        /// nodes.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief Implements an efficient mapping from strings to
        /// IdentifierInfo nodes.</para>
        /// <para>///</para>
        /// <para>/// This has no other purpose, but this is an extremely
        /// performance-critical</para>
        /// <para>/// piece of the code, as each occurrence of every identifier
        /// goes through</para>
        /// <para>/// here when lexed.</para>
        /// </remarks>
        public unsafe partial class IdentifierTable : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 92)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                internal llvm.StringMap.Internal HashTable;

                [FieldOffset(88)]
                public global::System.IntPtr ExternalLookup;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang15IdentifierTableC2ERKNS_11LangOptionsEPNS_20IdentifierInfoLookupE")]
                internal static extern void ctor_0(global::System.IntPtr instance, global::System.IntPtr LangOpts, global::System.IntPtr externalLookup);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang15IdentifierTableC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang15IdentifierTableD2Ev")]
                internal static extern void dtor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang15IdentifierTable27setExternalIdentifierLookupEPNS_20IdentifierInfoLookupE")]
                internal static extern void setExternalIdentifierLookup_0(global::System.IntPtr instance, global::System.IntPtr IILookup);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang15IdentifierTable27getExternalIdentifierLookupEv")]
                internal static extern global::System.IntPtr getExternalIdentifierLookup_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang15IdentifierTable3getEN4llvm9StringRefE")]
                internal static extern global::System.IntPtr get_0(global::System.IntPtr instance, llvm.StringRef.Internal Name);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang15IdentifierTable3getEN4llvm9StringRefENS_3tok9TokenKindE")]
                internal static extern global::System.IntPtr get_1(global::System.IntPtr instance, llvm.StringRef.Internal Name, clang.tok.TokenKind TokenCode);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang15IdentifierTable6getOwnEN4llvm9StringRefE")]
                internal static extern global::System.IntPtr getOwn_0(global::System.IntPtr instance, llvm.StringRef.Internal Name);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang15IdentifierTable4sizeEv")]
                internal static extern uint size_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang15IdentifierTable10PrintStatsEv")]
                internal static extern void PrintStats_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang15IdentifierTable11AddKeywordsERKNS_11LangOptionsE")]
                internal static extern void AddKeywords_0(global::System.IntPtr instance, global::System.IntPtr LangOpts);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, IdentifierTable> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, IdentifierTable>();

            private readonly bool __ownsNativeInstance;

            public static IdentifierTable __CreateInstance(global::System.IntPtr native)
            {
                return new IdentifierTable((IdentifierTable.Internal*) native);
            }

            public static IdentifierTable __CreateInstance(IdentifierTable.Internal native)
            {
                return new IdentifierTable(native);
            }

            private static IdentifierTable.Internal* __CopyValue(IdentifierTable.Internal native)
            {
                var ret = (IdentifierTable.Internal*) Marshal.AllocHGlobal(92);
                *ret = native;
                return ret;
            }

            private IdentifierTable(IdentifierTable.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected IdentifierTable(IdentifierTable.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            /// <summary>
            /// <para>Create the identifier table, populating it with info about the
            /// language keywords for the language specified by LangOpts.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Create the identifier table, populating it with info
            /// about the</para>
            /// <para>  /// language keywords for the language specified by \p
            /// LangOpts.</para>
            /// </remarks>
            public IdentifierTable(clang.LangOptions LangOpts, clang.IdentifierInfoLookup externalLookup)
            {
                __Instance = Marshal.AllocHGlobal(92);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(LangOpts, null) ? global::System.IntPtr.Zero : LangOpts.__Instance;
                var arg1 = ReferenceEquals(externalLookup, null) ? global::System.IntPtr.Zero : externalLookup.__Instance;
                Internal.ctor_0(__Instance, arg0, arg1);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.IdentifierTable __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance || force)
                    Internal.dtor_0(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            /// <summary>
            /// <para>Set the external identifier lookup mechanism.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Set the external identifier lookup mechanism.</para>
            /// </remarks>
            public void setExternalIdentifierLookup(clang.IdentifierInfoLookup IILookup)
            {
                var arg0 = ReferenceEquals(IILookup, null) ? global::System.IntPtr.Zero : IILookup.__Instance;
                Internal.setExternalIdentifierLookup_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>Retrieve the external identifier lookup object, if any.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the external identifier lookup object, if
            /// any.</para>
            /// </remarks>
            public clang.IdentifierInfoLookup getExternalIdentifierLookup()
            {
                var __ret = Internal.getExternalIdentifierLookup_0(__Instance);
                clang.IdentifierInfoLookup __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.IdentifierInfoLookup.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.IdentifierInfoLookup) clang.IdentifierInfoLookup.NativeToManagedMap[__ret];
                else clang.IdentifierInfoLookup.NativeToManagedMap[__ret] = __result0 = (clang.IdentifierInfoLookup) clang.IdentifierInfoLookup.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Return the identifier token info for the specified named
            /// identifier.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the identifier token info for the specified
            /// named</para>
            /// <para>  /// identifier.</para>
            /// </remarks>
            public clang.IdentifierInfo get(llvm.StringRef Name)
            {
                var arg0 = ReferenceEquals(Name, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (Name.__Instance);
                var __ret = Internal.get_0(__Instance, arg0);
                clang.IdentifierInfo __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.IdentifierInfo.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.IdentifierInfo) clang.IdentifierInfo.NativeToManagedMap[__ret];
                else __result0 = clang.IdentifierInfo.__CreateInstance(__ret);
                return __result0;
            }

            public clang.IdentifierInfo get(llvm.StringRef Name, clang.tok.TokenKind TokenCode)
            {
                var arg0 = ReferenceEquals(Name, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (Name.__Instance);
                var arg1 = TokenCode;
                var __ret = Internal.get_1(__Instance, arg0, arg1);
                clang.IdentifierInfo __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.IdentifierInfo.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.IdentifierInfo) clang.IdentifierInfo.NativeToManagedMap[__ret];
                else __result0 = clang.IdentifierInfo.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Gets an IdentifierInfo for the given name without consulting
            /// external sources.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Gets an IdentifierInfo for the given name without
            /// consulting</para>
            /// <para>  ///        external sources.</para>
            /// <para>  ///</para>
            /// <para>  /// This is a version of get() meant for external sources that
            /// want to</para>
            /// <para>  /// introduce or modify an identifier. If they called get(),
            /// they would</para>
            /// <para>  /// likely end up in a recursion.</para>
            /// </remarks>
            public clang.IdentifierInfo getOwn(llvm.StringRef Name)
            {
                var arg0 = ReferenceEquals(Name, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (Name.__Instance);
                var __ret = Internal.getOwn_0(__Instance, arg0);
                clang.IdentifierInfo __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.IdentifierInfo.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.IdentifierInfo) clang.IdentifierInfo.NativeToManagedMap[__ret];
                else __result0 = clang.IdentifierInfo.__CreateInstance(__ret);
                return __result0;
            }

            public uint size()
            {
                var __ret = Internal.size_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Print some statistics to stderr that indicate how well the
            /// hashing is doing.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Print some statistics to stderr that indicate how well
            /// the</para>
            /// <para>  /// hashing is doing.</para>
            /// </remarks>
            public void PrintStats()
            {
                Internal.PrintStats_0(__Instance);
            }

            public void AddKeywords(clang.LangOptions LangOpts)
            {
                var arg0 = ReferenceEquals(LangOpts, null) ? global::System.IntPtr.Zero : LangOpts.__Instance;
                Internal.AddKeywords_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>Smart pointer class that efficiently represents Objective-C
        /// method names.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief Smart pointer class that efficiently represents
        /// Objective-C method</para>
        /// <para>/// names.</para>
        /// <para>///</para>
        /// <para>/// This class will either point to an IdentifierInfo or a</para>
        /// <para>/// MultiKeywordSelector (which is private). This enables us to
        /// optimize</para>
        /// <para>/// selectors that take no arguments and selectors that take 1
        /// argument, which</para>
        /// <para>/// accounts for 78% of all selectors in Cocoa.h.</para>
        /// </remarks>
        public unsafe partial class Selector : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 4)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public uint InfoPtr;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8SelectorC2Ev")]
                internal static extern void ctor_2(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8SelectorC2Em")]
                internal static extern void ctor_3(global::System.IntPtr instance, uint V);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8SelectorC2ERKS0_")]
                internal static extern void cctor_4(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8SelectoreqES0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorEqualEqual_0(global::System.IntPtr instance, clang.Selector.Internal RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8SelectorneES0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorExclaimEqual_0(global::System.IntPtr instance, clang.Selector.Internal RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8Selector14getAsOpaquePtrEv")]
                internal static extern global::System.IntPtr getAsOpaquePtr_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8Selector6isNullEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isNull_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8Selector17isKeywordSelectorEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isKeywordSelector_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8Selector15isUnarySelectorEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isUnarySelector_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8Selector10getNumArgsEv")]
                internal static extern uint getNumArgs_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8Selector24getIdentifierInfoForSlotEj")]
                internal static extern global::System.IntPtr getIdentifierInfoForSlot_0(global::System.IntPtr instance, uint argIndex);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8Selector14getNameForSlotEj")]
                internal static extern llvm.StringRef.Internal getNameForSlot_0(global::System.IntPtr instance, uint argIndex);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8Selector5printERN4llvm11raw_ostreamE")]
                internal static extern void print_0(global::System.IntPtr instance, global::System.IntPtr OS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8Selector15getMethodFamilyEv")]
                internal static extern clang.ObjCMethodFamily getMethodFamily_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8Selector21getStringFormatFamilyEv")]
                internal static extern clang.ObjCStringFormatFamily getStringFormatFamily_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8Selector14getEmptyMarkerEv")]
                internal static extern clang.Selector.Internal getEmptyMarker_0();

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8Selector18getTombstoneMarkerEv")]
                internal static extern clang.Selector.Internal getTombstoneMarker_0();

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8Selector23getInstTypeMethodFamilyES0_")]
                internal static extern clang.ObjCInstanceTypeFamily getInstTypeMethodFamily_0(clang.Selector.Internal sel);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, Selector> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, Selector>();

            private readonly bool __ownsNativeInstance;

            public static Selector __CreateInstance(global::System.IntPtr native)
            {
                return new Selector((Selector.Internal*) native);
            }

            public static Selector __CreateInstance(Selector.Internal native)
            {
                return new Selector(native);
            }

            private static Selector.Internal* __CopyValue(Selector.Internal native)
            {
                var ret = (Selector.Internal*) Marshal.AllocHGlobal(4);
                *ret = native;
                return ret;
            }

            private Selector(Selector.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected Selector(Selector.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            /// <summary>
            /// <para>The default ctor should only be used when creating data
            /// structures that will contain selectors.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// The default ctor should only be used when creating data
            /// structures that</para>
            /// <para>  ///  will contain selectors.</para>
            /// </remarks>
            public Selector()
            {
                __Instance = Marshal.AllocHGlobal(4);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_2(__Instance);
            }

            public Selector(uint V)
            {
                __Instance = Marshal.AllocHGlobal(4);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = V;
                Internal.ctor_3(__Instance, arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Selector __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            /// <summary>
            /// <para>operator==/!= - Indicate whether the specified selectors are
            /// identical.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// operator==/!= - Indicate whether the specified selectors are
            /// identical.</para>
            /// </remarks>
            public static bool operator ==(clang.Selector __op, clang.Selector RHS)
            {
                bool __opNull = ReferenceEquals(__op, null);
                bool RHSNull = ReferenceEquals(RHS, null);
                if (__opNull || RHSNull)
                    return __opNull && RHSNull;
                var arg0 = __op.__Instance;
                var arg1 = ReferenceEquals(RHS, null) ? new clang.Selector.Internal() : *(clang.Selector.Internal*) (RHS.__Instance);
                var __ret = Internal.OperatorEqualEqual_0(arg0, arg1);
                return __ret;
            }

            public override bool Equals(object obj)
            {
                return this == obj as Selector;
            }

            public static bool operator !=(clang.Selector __op, clang.Selector RHS)
            {
                var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
                var arg1 = ReferenceEquals(RHS, null) ? new clang.Selector.Internal() : *(clang.Selector.Internal*) (RHS.__Instance);
                var __ret = Internal.OperatorExclaimEqual_0(arg0, arg1);
                return __ret;
            }

            public global::System.IntPtr getAsOpaquePtr()
            {
                var __ret = Internal.getAsOpaquePtr_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determine whether this is the empty selector.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine whether this is the empty selector.</para>
            /// </remarks>
            public bool isNull()
            {
                var __ret = Internal.isNull_0(__Instance);
                return __ret;
            }

            public bool isKeywordSelector()
            {
                var __ret = Internal.isKeywordSelector_0(__Instance);
                return __ret;
            }

            public bool isUnarySelector()
            {
                var __ret = Internal.isUnarySelector_0(__Instance);
                return __ret;
            }

            public uint getNumArgs()
            {
                var __ret = Internal.getNumArgs_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Retrieve the identifier at a given position in the
            /// selector.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the identifier at a given position in the
            /// selector.</para>
            /// <para>  ///</para>
            /// <para>  /// Note that the identifier pointer returned may be NULL.
            /// Clients that only</para>
            /// <para>  /// care about the text of the identifier string, and not the
            /// specific, </para>
            /// <para>  /// uniqued identifier pointer, should use \c getNameForSlot(),
            /// which returns</para>
            /// <para>  /// an empty string when the identifier pointer would be
            /// NULL.</para>
            /// <para>  ///</para>
            /// <para>  /// \param argIndex The index for which we want to retrieve the
            /// identifier.</para>
            /// <para>  /// This index shall be less than \c getNumArgs() unless this
            /// is a keyword</para>
            /// <para>  /// selector, in which case 0 is the only permissible
            /// value.</para>
            /// <para>  ///</para>
            /// <para>  /// \returns the uniqued identifier for this slot, or NULL if
            /// this slot has</para>
            /// <para>  /// no corresponding identifier.</para>
            /// </remarks>
            public clang.IdentifierInfo getIdentifierInfoForSlot(uint argIndex)
            {
                var __ret = Internal.getIdentifierInfoForSlot_0(__Instance, argIndex);
                clang.IdentifierInfo __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.IdentifierInfo.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.IdentifierInfo) clang.IdentifierInfo.NativeToManagedMap[__ret];
                else __result0 = clang.IdentifierInfo.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Retrieve the name at a given position in the selector.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the name at a given position in the
            /// selector.</para>
            /// <para>  ///</para>
            /// <para>  /// \param argIndex The index for which we want to retrieve the
            /// name.</para>
            /// <para>  /// This index shall be less than \c getNumArgs() unless this
            /// is a keyword</para>
            /// <para>  /// selector, in which case 0 is the only permissible
            /// value.</para>
            /// <para>  ///</para>
            /// <para>  /// \returns the name for this slot, which may be the empty
            /// string if no</para>
            /// <para>  /// name was supplied.</para>
            /// </remarks>
            public llvm.StringRef getNameForSlot(uint argIndex)
            {
                var __ret = Internal.getNameForSlot_0(__Instance, argIndex);
                return llvm.StringRef.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Prints the full selector name (e.g. &quot;foo:bar:&quot;).</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Prints the full selector name (e.g.
            /// &quot;foo:bar:&quot;).</para>
            /// </remarks>
            public void print(llvm.raw_ostream OS)
            {
                var arg0 = ReferenceEquals(OS, null) ? global::System.IntPtr.Zero : OS.__Instance;
                Internal.print_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>Derive the conventional family of this method.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Derive the conventional family of this method.</para>
            /// </remarks>
            public clang.ObjCMethodFamily getMethodFamily()
            {
                var __ret = Internal.getMethodFamily_0(__Instance);
                return __ret;
            }

            public clang.ObjCStringFormatFamily getStringFormatFamily()
            {
                var __ret = Internal.getStringFormatFamily_0(__Instance);
                return __ret;
            }

            public static clang.Selector getEmptyMarker()
            {
                var __ret = Internal.getEmptyMarker_0();
                return clang.Selector.__CreateInstance(__ret);
            }

            public static clang.Selector getTombstoneMarker()
            {
                var __ret = Internal.getTombstoneMarker_0();
                return clang.Selector.__CreateInstance(__ret);
            }

            public static clang.ObjCInstanceTypeFamily getInstTypeMethodFamily(clang.Selector sel)
            {
                var arg0 = ReferenceEquals(sel, null) ? new clang.Selector.Internal() : *(clang.Selector.Internal*) (sel.__Instance);
                var __ret = Internal.getInstTypeMethodFamily_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>This table allows us to fully hide how we implement multi-keyword
        /// caching.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief This table allows us to fully hide how we
        /// implement</para>
        /// <para>/// multi-keyword caching.</para>
        /// </remarks>
        public unsafe partial class SelectorTable : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 4)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr Impl;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13SelectorTableC2Ev")]
                internal static extern void ctor_1(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13SelectorTableD2Ev")]
                internal static extern void dtor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13SelectorTable11getSelectorEjPPNS_14IdentifierInfoE")]
                internal static extern clang.Selector.Internal getSelector_0(global::System.IntPtr instance, uint NumArgs, global::System.IntPtr IIV);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13SelectorTable16getUnarySelectorEPNS_14IdentifierInfoE")]
                internal static extern clang.Selector.Internal getUnarySelector_0(global::System.IntPtr instance, global::System.IntPtr ID);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13SelectorTable18getNullarySelectorEPNS_14IdentifierInfoE")]
                internal static extern clang.Selector.Internal getNullarySelector_0(global::System.IntPtr instance, global::System.IntPtr ID);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13SelectorTable14getTotalMemoryEv")]
                internal static extern uint getTotalMemory_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13SelectorTable23constructSetterSelectorERNS_15IdentifierTableERS0_PKNS_14IdentifierInfoE")]
                internal static extern clang.Selector.Internal constructSetterSelector_0(global::System.IntPtr Idents, global::System.IntPtr SelTable, global::System.IntPtr Name);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, SelectorTable> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, SelectorTable>();

            private readonly bool __ownsNativeInstance;

            public static SelectorTable __CreateInstance(global::System.IntPtr native)
            {
                return new SelectorTable((SelectorTable.Internal*) native);
            }

            public static SelectorTable __CreateInstance(SelectorTable.Internal native)
            {
                return new SelectorTable(native);
            }

            private static SelectorTable.Internal* __CopyValue(SelectorTable.Internal native)
            {
                var ret = (SelectorTable.Internal*) Marshal.AllocHGlobal(4);
                *ret = native;
                return ret;
            }

            private SelectorTable(SelectorTable.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected SelectorTable(SelectorTable.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public SelectorTable()
            {
                __Instance = Marshal.AllocHGlobal(4);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_1(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.SelectorTable __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance || force)
                    Internal.dtor_0(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            /// <summary>
            /// <para>Can create any sort of selector.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Can create any sort of selector.</para>
            /// <para>  ///</para>
            /// <para>  /// \p NumArgs indicates whether this is a no argument selector
            /// &quot;foo&quot;, a</para>
            /// <para>  /// single argument selector &quot;foo:&quot; or multi-argument
            /// &quot;foo:bar:&quot;.</para>
            /// </remarks>
            public clang.Selector getSelector(uint NumArgs, clang.IdentifierInfo IIV)
            {
                var arg1 = ReferenceEquals(IIV, null) ? global::System.IntPtr.Zero : IIV.__Instance;
                var __ret = Internal.getSelector_0(__Instance, NumArgs, arg1);
                return clang.Selector.__CreateInstance(__ret);
            }

            public clang.Selector getUnarySelector(clang.IdentifierInfo ID)
            {
                var arg0 = ReferenceEquals(ID, null) ? global::System.IntPtr.Zero : ID.__Instance;
                var __ret = Internal.getUnarySelector_0(__Instance, arg0);
                return clang.Selector.__CreateInstance(__ret);
            }

            public clang.Selector getNullarySelector(clang.IdentifierInfo ID)
            {
                var arg0 = ReferenceEquals(ID, null) ? global::System.IntPtr.Zero : ID.__Instance;
                var __ret = Internal.getNullarySelector_0(__Instance, arg0);
                return clang.Selector.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Return the total amount of memory allocated for managing
            /// selectors.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the total amount of memory allocated for
            /// managing selectors.</para>
            /// </remarks>
            public uint getTotalMemory()
            {
                var __ret = Internal.getTotalMemory_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Return the default setter selector for the given
            /// identifier.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the default setter selector for the given
            /// identifier.</para>
            /// <para>  ///</para>
            /// <para>  /// This is &quot;set&quot; + \p Name where the initial
            /// character of \p Name</para>
            /// <para>  /// has been capitalized.</para>
            /// </remarks>
            public static clang.Selector constructSetterSelector(clang.IdentifierTable Idents, clang.SelectorTable SelTable, clang.IdentifierInfo Name)
            {
                var arg0 = ReferenceEquals(Idents, null) ? global::System.IntPtr.Zero : Idents.__Instance;
                var arg1 = ReferenceEquals(SelTable, null) ? global::System.IntPtr.Zero : SelTable.__Instance;
                var arg2 = ReferenceEquals(Name, null) ? global::System.IntPtr.Zero : Name.__Instance;
                var __ret = Internal.constructSetterSelector_0(arg0, arg1, arg2);
                return clang.Selector.__CreateInstance(__ret);
            }
        }

        /// <summary>
        /// <para>DeclarationNameExtra - Common base of the MultiKeywordSelector,
        /// CXXSpecialName, and CXXOperatorIdName classes, all of which are private
        /// classes that describe different kinds of names.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// DeclarationNameExtra - Common base of the
        /// MultiKeywordSelector,</para>
        /// <para>/// CXXSpecialName, and CXXOperatorIdName classes, all of which
        /// are</para>
        /// <para>/// private classes that describe different kinds of
        /// names.</para>
        /// </remarks>
        public unsafe partial class DeclarationNameExtra : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 4)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public uint ExtraKindOrNumArgs;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang20DeclarationNameExtraC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
            }

            /// <summary>
            /// <para>ExtraKind - The kind of &quot;extra&quot; information stored in
            /// the DeclarationName. See ExtraKindOrNumArgs for an explanation of how these
            /// enumerator values are used.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// ExtraKind - The kind of &quot;extra&quot; information stored
            /// in the</para>
            /// <para>  /// DeclarationName. See @c ExtraKindOrNumArgs for an
            /// explanation of</para>
            /// <para>  /// how these enumerator values are used.</para>
            /// </remarks>
            public enum ExtraKind : uint
            {
                CXXConstructor = 0,
                CXXDestructor = 1,
                CXXConversionFunction = 2,
                CXXOperatorNew = 3,
                CXXOperatorDelete = 4,
                CXXOperatorArray_New = 5,
                CXXOperatorArray_Delete = 6,
                CXXOperatorPlus = 7,
                CXXOperatorMinus = 8,
                CXXOperatorStar = 9,
                CXXOperatorSlash = 10,
                CXXOperatorPercent = 11,
                CXXOperatorCaret = 12,
                CXXOperatorAmp = 13,
                CXXOperatorPipe = 14,
                CXXOperatorTilde = 15,
                CXXOperatorExclaim = 16,
                CXXOperatorEqual = 17,
                CXXOperatorLess = 18,
                CXXOperatorGreater = 19,
                CXXOperatorPlusEqual = 20,
                CXXOperatorMinusEqual = 21,
                CXXOperatorStarEqual = 22,
                CXXOperatorSlashEqual = 23,
                CXXOperatorPercentEqual = 24,
                CXXOperatorCaretEqual = 25,
                CXXOperatorAmpEqual = 26,
                CXXOperatorPipeEqual = 27,
                CXXOperatorLessLess = 28,
                CXXOperatorGreaterGreater = 29,
                CXXOperatorLessLessEqual = 30,
                CXXOperatorGreaterGreaterEqual = 31,
                CXXOperatorEqualEqual = 32,
                CXXOperatorExclaimEqual = 33,
                CXXOperatorLessEqual = 34,
                CXXOperatorGreaterEqual = 35,
                CXXOperatorAmpAmp = 36,
                CXXOperatorPipePipe = 37,
                CXXOperatorPlusPlus = 38,
                CXXOperatorMinusMinus = 39,
                CXXOperatorComma = 40,
                CXXOperatorArrowStar = 41,
                CXXOperatorArrow = 42,
                CXXOperatorCall = 43,
                CXXOperatorSubscript = 44,
                CXXOperatorConditional = 45,
                CXXLiteralOperator = 46,
                CXXUsingDirective = 47,
                NUM_EXTRA_KINDS = 48
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, DeclarationNameExtra> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, DeclarationNameExtra>();

            private readonly bool __ownsNativeInstance;

            public static DeclarationNameExtra __CreateInstance(global::System.IntPtr native)
            {
                return new DeclarationNameExtra((DeclarationNameExtra.Internal*) native);
            }

            public static DeclarationNameExtra __CreateInstance(DeclarationNameExtra.Internal native)
            {
                return new DeclarationNameExtra(native);
            }

            private static DeclarationNameExtra.Internal* __CopyValue(DeclarationNameExtra.Internal native)
            {
                var ret = (DeclarationNameExtra.Internal*) Marshal.AllocHGlobal(4);
                *ret = native;
                return ret;
            }

            private DeclarationNameExtra(DeclarationNameExtra.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected DeclarationNameExtra(DeclarationNameExtra.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public DeclarationNameExtra()
            {
                __Instance = Marshal.AllocHGlobal(4);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.DeclarationNameExtra __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public uint ExtraKindOrNumArgs
            {
                get
                {
                    return ((Internal*) __Instance)->ExtraKindOrNumArgs;
                }

                set
                {
                    ((Internal*) __Instance)->ExtraKindOrNumArgs = value;
                }
            }
        }

        internal unsafe partial class IdentifierIteratorInternal : clang.IdentifierIterator, IDisposable
        {
            private readonly bool __ownsNativeInstance;

            private static IdentifierIterator.Internal* __CopyValue(IdentifierIterator.Internal native)
            {
                var ret = (IdentifierIterator.Internal*) Marshal.AllocHGlobal(4);
                *ret = native;
                return ret;
            }

            internal IdentifierIteratorInternal(IdentifierIterator.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            internal IdentifierIteratorInternal(IdentifierIterator.Internal* native, bool isInternalImpl = false)
                : base((clang.IdentifierIterator.Internal*) native, true)
            {
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.IdentifierIterator __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            /// <summary>
            /// <para>Retrieve the next string in the identifier table and advances the
            /// iterator for the following string.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the next string in the identifier table
            /// and</para>
            /// <para>  /// advances the iterator for the following string.</para>
            /// <para>  ///</para>
            /// <para>  /// \returns The next string in the identifier table. If there
            /// is</para>
            /// <para>  /// no such string, returns an empty \c StringRef.</para>
            /// </remarks>
            public override llvm.StringRef Next()
            {
                void* slot = *(void**) (((IdentifierIterator.Internal*) __Instance)->vfptr0 + 2 * 4);
                var ___Next_0Delegate = (_Next_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_Next_0Delegate));
                var __ret = ___Next_0Delegate(__Instance);
                return llvm.StringRef.__CreateInstance(__ret);
            }
        }

        internal unsafe partial class IdentifierInfoLookupInternal : clang.IdentifierInfoLookup, IDisposable
        {
            private readonly bool __ownsNativeInstance;

            private static IdentifierInfoLookup.Internal* __CopyValue(IdentifierInfoLookup.Internal native)
            {
                var ret = (IdentifierInfoLookup.Internal*) Marshal.AllocHGlobal(4);
                *ret = native;
                return ret;
            }

            internal IdentifierInfoLookupInternal(IdentifierInfoLookup.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            internal IdentifierInfoLookupInternal(IdentifierInfoLookup.Internal* native, bool isInternalImpl = false)
                : base((clang.IdentifierInfoLookup.Internal*) native, true)
            {
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.IdentifierInfoLookup __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            /// <summary>
            /// <para>Return the IdentifierInfo for the specified named
            /// identifier.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the IdentifierInfo for the specified named
            /// identifier.</para>
            /// <para>  ///</para>
            /// <para>  /// Unlike the version in IdentifierTable, this returns a
            /// pointer instead</para>
            /// <para>  /// of a reference.  If the pointer is null then the
            /// IdentifierInfo cannot</para>
            /// <para>  /// be found.</para>
            /// </remarks>
            public override clang.IdentifierInfo get(llvm.StringRef Name)
            {
                void* slot = *(void**) (((IdentifierInfoLookup.Internal*) __Instance)->vfptr0 + 2 * 4);
                var ___get_0Delegate = (_get_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_get_0Delegate));
                var arg0 = ReferenceEquals(Name, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (Name.__Instance);
                var __ret = ___get_0Delegate(__Instance, arg0);
                clang.IdentifierInfo __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.IdentifierInfo.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.IdentifierInfo) clang.IdentifierInfo.NativeToManagedMap[__ret];
                else __result0 = clang.IdentifierInfo.__CreateInstance(__ret);
                return __result0;
            }
        }

        internal unsafe partial class ExternalIdentifierLookupInternal : clang.ExternalIdentifierLookup, IDisposable
        {
            private readonly bool __ownsNativeInstance;

            private static ExternalIdentifierLookup.Internal* __CopyValue(ExternalIdentifierLookup.Internal native)
            {
                var ret = (ExternalIdentifierLookup.Internal*) Marshal.AllocHGlobal(4);
                *ret = native;
                return ret;
            }

            internal ExternalIdentifierLookupInternal(ExternalIdentifierLookup.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            internal ExternalIdentifierLookupInternal(ExternalIdentifierLookup.Internal* native, bool isInternalImpl = false)
                : base((clang.ExternalIdentifierLookup.Internal*) native, true)
            {
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.ExternalIdentifierLookup __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            /// <summary>
            /// <para>Return the identifier associated with the given ID number.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the identifier associated with the given ID
            /// number.</para>
            /// <para>  ///</para>
            /// <para>  /// The ID 0 is associated with the NULL identifier.</para>
            /// </remarks>
            public override clang.IdentifierInfo GetIdentifier(uint ID)
            {
                void* slot = *(void**) (((ExternalIdentifierLookup.Internal*) __Instance)->vfptr0 + 2 * 4);
                var ___GetIdentifier_0Delegate = (_GetIdentifier_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_GetIdentifier_0Delegate));
                var __ret = ___GetIdentifier_0Delegate(__Instance, ID);
                clang.IdentifierInfo __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.IdentifierInfo.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.IdentifierInfo) clang.IdentifierInfo.NativeToManagedMap[__ret];
                else __result0 = clang.IdentifierInfo.__CreateInstance(__ret);
                return __result0;
            }
        }
    }

    namespace llvm
    {
    }
}
