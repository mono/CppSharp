//----------------------------------------------------------------------------
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
//----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace CppSharp
{
    public unsafe partial class APFloat
    {
        public partial struct Internal
        {
        }
    }

    namespace llvm
    {
        /// <summary>
        /// <para>Enum that represents what fraction of the LSB truncated bits of
        /// an fp number represent.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// Enum that represents what fraction of the LSB truncated bits
        /// of an fp number</para>
        /// <para>/// represent.</para>
        /// <para>///</para>
        /// <para>/// This essentially combines the roles of guard and sticky
        /// bits.</para>
        /// </remarks>
        public enum lostFraction : uint
        {
            lfExactlyZero = 0,
            lfLessThanHalf = 1,
            lfExactlyHalf = 2,
            lfMoreThanHalf = 3
        }

        /// <summary>
        /// <para>A self-contained host- and target-independent arbitrary-precision
        /// floating-point software implementation.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief A self-contained host- and target-independent
        /// arbitrary-precision</para>
        /// <para>/// floating-point software implementation.</para>
        /// <para>///</para>
        /// <para>/// APFloat uses bignum integer arithmetic as provided by static
        /// functions in</para>
        /// <para>/// the APInt class.  The library will work with bignum integers
        /// whose parts are</para>
        /// <para>/// any unsigned type at least 16 bits wide, but 64 bits is
        /// recommended.</para>
        /// <para>///</para>
        /// <para>/// Written for clarity rather than speed, in particular with a
        /// view to use in</para>
        /// <para>/// the front-end of a cross compiler so that target arithmetic
        /// can be correctly</para>
        /// <para>/// performed on the host.  Performance should nonetheless be
        /// reasonable,</para>
        /// <para>/// particularly for its intended use.  It may be useful as a
        /// base</para>
        /// <para>/// implementation for a run-time library during development of a
        /// faster</para>
        /// <para>/// target-specific one.</para>
        /// <para>///</para>
        /// <para>/// All 5 rounding modes in the IEEE-754R draft are handled
        /// correctly for all</para>
        /// <para>/// implemented operations.  Currently implemented operations are
        /// add, subtract,</para>
        /// <para>/// multiply, divide, fused-multiply-add,
        /// conversion-to-float,</para>
        /// <para>/// conversion-to-integer and conversion-from-integer.  New
        /// rounding modes</para>
        /// <para>/// (e.g. away from zero) can be added with three or four lines
        /// of code.</para>
        /// <para>///</para>
        /// <para>/// Four formats are built-in: IEEE single precision, double
        /// precision,</para>
        /// <para>/// quadruple precision, and x87 80-bit extended double (when
        /// operating with</para>
        /// <para>/// full extended precision).  Adding a new format that obeys
        /// IEEE semantics</para>
        /// <para>/// only requires adding two lines of code: a declaration and
        /// definition of the</para>
        /// <para>/// format.</para>
        /// <para>///</para>
        /// <para>/// All operations return the status of that operation as an
        /// exception bit-mask,</para>
        /// <para>/// so multiple operations can be done consecutively with their
        /// results or-ed</para>
        /// <para>/// together.  The returned status can be useful for compiler
        /// diagnostics; e.g.,</para>
        /// <para>/// inexact, underflow and overflow can be easily diagnosed on
        /// constant folding,</para>
        /// <para>/// and compiler optimizers can determine what exceptions would
        /// be raised by</para>
        /// <para>/// folding operations and optimize, or perhaps not optimize,
        /// accordingly.</para>
        /// <para>///</para>
        /// <para>/// At present, underflow tininess is detected after rounding; it
        /// should be</para>
        /// <para>/// straight forward to add support for the before-rounding case
        /// too.</para>
        /// <para>///</para>
        /// <para>/// The library reads hexadecimal floating point numbers as per
        /// C99, and</para>
        /// <para>/// correctly rounds if necessary according to the specified
        /// rounding mode.</para>
        /// <para>/// Syntax is required to have been validated by the caller.  It
        /// also converts</para>
        /// <para>/// floating point numbers to hexadecimal text as per the C99 %a
        /// and %A</para>
        /// <para>/// conversions.  The output precision (or alternatively the
        /// natural minimal</para>
        /// <para>/// precision) can be specified; if the requested precision is
        /// less than the</para>
        /// <para>/// natural precision the output is correctly rounded for the
        /// specified rounding</para>
        /// <para>/// mode.</para>
        /// <para>///</para>
        /// <para>/// It also reads decimal floating point numbers and correctly
        /// rounds according</para>
        /// <para>/// to the specified rounding mode.</para>
        /// <para>///</para>
        /// <para>/// Conversion to decimal text is not currently
        /// implemented.</para>
        /// <para>///</para>
        /// <para>/// Non-zero finite numbers are represented internally as a sign
        /// bit, a 16-bit</para>
        /// <para>/// signed exponent, and the significand as an array of integer
        /// parts.  After</para>
        /// <para>/// normalization of a number of precision P the exponent is
        /// within the range of</para>
        /// <para>/// the format, and if the number is not denormal the P-th bit of
        /// the</para>
        /// <para>/// significand is set as an explicit integer bit.  For denormals
        /// the most</para>
        /// <para>/// significant bit is shifted right so that the exponent is
        /// maintained at the</para>
        /// <para>/// format's minimum, so that the smallest denormal has just the
        /// least</para>
        /// <para>/// significant bit of the significand set.  The sign of zeroes
        /// and infinities</para>
        /// <para>/// is significant; the exponent and significand of such numbers
        /// is not stored,</para>
        /// <para>/// but has a known implicit (deterministic) value: 0 for the
        /// significands, 0</para>
        /// <para>/// for zero exponent, all 1 bits for infinity exponent.  For
        /// NaNs the sign and</para>
        /// <para>/// significand are deterministic, although not really
        /// meaningful, and preserved</para>
        /// <para>/// in non-conversion operations.  The exponent is implicitly all
        /// 1 bits.</para>
        /// <para>///</para>
        /// <para>/// APFloat does not provide any exception handling beyond
        /// default exception</para>
        /// <para>/// handling. We represent Signaling NaNs via IEEE-754R 2008
        /// 6.2.1 should clause</para>
        /// <para>/// by encoding Signaling NaNs with the first bit of its trailing
        /// significand as</para>
        /// <para>/// 0.</para>
        /// <para>///</para>
        /// <para>/// TODO</para>
        /// <para>/// ====</para>
        /// <para>///</para>
        /// <para>/// Some features that may or may not be worth adding:</para>
        /// <para>///</para>
        /// <para>/// Binary to decimal conversion (hard).</para>
        /// <para>///</para>
        /// <para>/// Optional ability to detect underflow tininess before
        /// rounding.</para>
        /// <para>///</para>
        /// <para>/// New formats: x87 in single and double precision mode (IEEE
        /// apart from</para>
        /// <para>/// extended exponent range) (hard).</para>
        /// <para>///</para>
        /// <para>/// New operations: sqrt, IEEE remainder, C90 fmod,
        /// nexttoward.</para>
        /// <para>///</para>
        /// </remarks>
        public unsafe partial class APFloat : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr semantics;

                [FieldOffset(4)]
                internal llvm.APFloat.Significand.Internal significand;

                [FieldOffset(12)]
                public short exponent;

                [FieldOffset(14)]
                public llvm.APFloat.fltCategory category;

                [FieldOffset(14)]
                public uint sign;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm7APFloatC2Ed")]
                internal static extern void ctor_5(global::System.IntPtr instance, double d);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm7APFloatC2Ef")]
                internal static extern void ctor_6(global::System.IntPtr instance, float f);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm7APFloatC2ERKS0_")]
                internal static extern void cctor_7(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm7APFloatD2Ev")]
                internal static extern void dtor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm7APFloat12needsCleanupEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool needsCleanup_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm7APFloat15getAllOnesValueEjb")]
                internal static extern void getAllOnesValue_0(global::System.IntPtr @return, uint BitWidth, bool isIEEE);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm7APFloat7ProfileERNS_16FoldingSetNodeIDE")]
                internal static extern void Profile_0(global::System.IntPtr instance, global::System.IntPtr NID);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm7APFloat3addERKS0_NS0_12roundingModeE")]
                internal static extern llvm.APFloat.opStatus add_0(global::System.IntPtr instance, global::System.IntPtr _0, llvm.APFloat.roundingMode _1);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm7APFloat8subtractERKS0_NS0_12roundingModeE")]
                internal static extern llvm.APFloat.opStatus subtract_0(global::System.IntPtr instance, global::System.IntPtr _0, llvm.APFloat.roundingMode _1);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm7APFloat8multiplyERKS0_NS0_12roundingModeE")]
                internal static extern llvm.APFloat.opStatus multiply_0(global::System.IntPtr instance, global::System.IntPtr _0, llvm.APFloat.roundingMode _1);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm7APFloat6divideERKS0_NS0_12roundingModeE")]
                internal static extern llvm.APFloat.opStatus divide_0(global::System.IntPtr instance, global::System.IntPtr _0, llvm.APFloat.roundingMode _1);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm7APFloat9remainderERKS0_")]
                internal static extern llvm.APFloat.opStatus remainder_0(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm7APFloat3modERKS0_NS0_12roundingModeE")]
                internal static extern llvm.APFloat.opStatus mod_0(global::System.IntPtr instance, global::System.IntPtr _0, llvm.APFloat.roundingMode _1);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm7APFloat16fusedMultiplyAddERKS0_S2_NS0_12roundingModeE")]
                internal static extern llvm.APFloat.opStatus fusedMultiplyAdd_0(global::System.IntPtr instance, global::System.IntPtr _0, global::System.IntPtr _1, llvm.APFloat.roundingMode _2);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm7APFloat15roundToIntegralENS0_12roundingModeE")]
                internal static extern llvm.APFloat.opStatus roundToIntegral_0(global::System.IntPtr instance, llvm.APFloat.roundingMode _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm7APFloat4nextEb")]
                internal static extern llvm.APFloat.opStatus next_0(global::System.IntPtr instance, bool nextDown);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm7APFloatplERKS0_")]
                internal static extern void OperatorPlus_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm7APFloatmiERKS0_")]
                internal static extern void OperatorMinus_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm7APFloatmlERKS0_")]
                internal static extern void OperatorStar_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm7APFloatdvERKS0_")]
                internal static extern void OperatorSlash_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm7APFloat10changeSignEv")]
                internal static extern void changeSign_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm7APFloat9clearSignEv")]
                internal static extern void clearSign_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm7APFloat8copySignERKS0_")]
                internal static extern void copySign_0(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm7APFloat8copySignES0_RKS0_")]
                internal static extern void copySign_1(global::System.IntPtr @return, llvm.APFloat.Internal Value, global::System.IntPtr Sign);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm7APFloat16convertToIntegerEPyjbNS0_12roundingModeEPb")]
                internal static extern llvm.APFloat.opStatus convertToInteger_0(global::System.IntPtr instance, ulong* _0, uint _1, bool _2, llvm.APFloat.roundingMode _3, bool* _4);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm7APFloat16convertToIntegerERNS_6APSIntENS0_12roundingModeEPb")]
                internal static extern llvm.APFloat.opStatus convertToInteger_1(global::System.IntPtr instance, global::System.IntPtr _0, llvm.APFloat.roundingMode _1, bool* _2);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm7APFloat16convertFromAPIntERKNS_5APIntEbNS0_12roundingModeE")]
                internal static extern llvm.APFloat.opStatus convertFromAPInt_0(global::System.IntPtr instance, global::System.IntPtr _0, bool _1, llvm.APFloat.roundingMode _2);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm7APFloat30convertFromSignExtendedIntegerEPKyjbNS0_12roundingModeE")]
                internal static extern llvm.APFloat.opStatus convertFromSignExtendedInteger_0(global::System.IntPtr instance, ulong* _0, uint _1, bool _2, llvm.APFloat.roundingMode _3);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm7APFloat30convertFromZeroExtendedIntegerEPKyjbNS0_12roundingModeE")]
                internal static extern llvm.APFloat.opStatus convertFromZeroExtendedInteger_0(global::System.IntPtr instance, ulong* _0, uint _1, bool _2, llvm.APFloat.roundingMode _3);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm7APFloat17convertFromStringENS_9StringRefENS0_12roundingModeE")]
                internal static extern llvm.APFloat.opStatus convertFromString_0(global::System.IntPtr instance, llvm.StringRef.Internal _0, llvm.APFloat.roundingMode _1);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm7APFloat14bitcastToAPIntEv")]
                internal static extern void bitcastToAPInt_0(global::System.IntPtr @return, global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm7APFloat15convertToDoubleEv")]
                internal static extern double convertToDouble_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm7APFloat14convertToFloatEv")]
                internal static extern float convertToFloat_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm7APFloateqERKS0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorEqualEqual_0(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm7APFloat7compareERKS0_")]
                internal static extern llvm.APFloat.cmpResult compare_0(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm7APFloat14bitwiseIsEqualERKS0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool bitwiseIsEqual_0(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm7APFloat18convertToHexStringEPcjbNS0_12roundingModeE")]
                internal static extern uint convertToHexString_0(global::System.IntPtr instance, sbyte* dst, uint hexDigits, bool upperCase, llvm.APFloat.roundingMode _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm7APFloat10isNegativeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isNegative_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm7APFloat8isNormalEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isNormal_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm7APFloat8isFiniteEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isFinite_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm7APFloat6isZeroEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isZero_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm7APFloat10isDenormalEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isDenormal_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm7APFloat10isInfinityEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isInfinity_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm7APFloat5isNaNEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isNaN_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm7APFloat11isSignalingEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isSignaling_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm7APFloat11getCategoryEv")]
                internal static extern llvm.APFloat.fltCategory getCategory_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm7APFloat9isNonZeroEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isNonZero_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm7APFloat15isFiniteNonZeroEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isFiniteNonZero_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm7APFloat9isPosZeroEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isPosZero_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm7APFloat9isNegZeroEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isNegZero_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm7APFloat10isSmallestEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isSmallest_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm7APFloat9isLargestEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isLargest_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm7APFloat15getExactInverseEPS0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool getExactInverse_0(global::System.IntPtr instance, global::System.IntPtr inv);
            }

            /// <summary>
            /// <para>IEEE-754R 5.11: Floating Point Comparison Relations.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// IEEE-754R 5.11: Floating Point Comparison Relations.</para>
            /// </remarks>
            public enum cmpResult : uint
            {
                cmpLessThan = 0,
                cmpEqual = 1,
                cmpGreaterThan = 2,
                cmpUnordered = 3
            }

            /// <summary>
            /// <para>IEEE-754R 4.3: Rounding-direction attributes.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// IEEE-754R 4.3: Rounding-direction attributes.</para>
            /// </remarks>
            public enum roundingMode : uint
            {
                rmNearestTiesToEven = 0,
                rmTowardPositive = 1,
                rmTowardNegative = 2,
                rmTowardZero = 3,
                rmNearestTiesToAway = 4
            }

            /// <summary>
            /// <para>IEEE-754R 7: Default exception handling.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// IEEE-754R 7: Default exception handling.</para>
            /// <para>  ///</para>
            /// <para>  /// opUnderflow or opOverflow are always returned or-ed with
            /// opInexact.</para>
            /// </remarks>
            [Flags]
            public enum opStatus : uint
            {
                opOK = 0x0,
                opInvalidOp = 0x1,
                opDivByZero = 0x2,
                opOverflow = 0x4,
                opUnderflow = 0x8,
                opInexact = 0x10
            }

            /// <summary>
            /// <para>Category of internally-represented number.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Category of internally-represented number.</para>
            /// </remarks>
            public enum fltCategory : uint
            {
                fcInfinity = 0,
                fcNaN = 1,
                fcNormal = 2,
                fcZero = 3
            }

            /// <summary>
            /// <para>Convenience enum used to construct an uninitialized
            /// APFloat.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Convenience enum used to construct an uninitialized
            /// APFloat.</para>
            /// </remarks>
            public enum uninitializedTag : uint
            {
                uninitialized = 0
            }

            /// <summary>
            /// <para>Enumeration of ilogb error results.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Enumeration of \c ilogb error results.</para>
            /// </remarks>
            public enum IlogbErrorKinds
            {
                IEK_Zero = -2147483647,
                IEK_NaN = -2147483648,
                IEK_Inf = 2147483647
            }

            /// <summary>
            /// <para>A signed type to represent a floating point numbers unbiased
            /// exponent.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// A signed type to represent a floating point numbers
            /// unbiased exponent.</para>
            /// </remarks>
            /// <summary>
            /// <para>A binary fraction with an explicit integer bit.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// A binary fraction with an explicit integer bit.</para>
            /// <para>  ///</para>
            /// <para>  /// The significand must be at least one bit wider than the
            /// target precision.</para>
            /// </remarks>
            internal unsafe partial struct Significand
            {
                [StructLayout(LayoutKind.Explicit, Size = 8)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public ulong part;

                    [FieldOffset(0)]
                    public ulong* parts;
                }
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, APFloat> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, APFloat>();

            private readonly bool __ownsNativeInstance;

            public static APFloat __CreateInstance(global::System.IntPtr native)
            {
                return new APFloat((APFloat.Internal*) native);
            }

            public static APFloat __CreateInstance(APFloat.Internal native)
            {
                return new APFloat(native);
            }

            private static APFloat.Internal* __CopyValue(APFloat.Internal native)
            {
                var ret = (APFloat.Internal*) Marshal.AllocHGlobal(16);
                *ret = native;
                return ret;
            }

            private APFloat(APFloat.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected APFloat(APFloat.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public APFloat(double d)
            {
                __Instance = Marshal.AllocHGlobal(16);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_5(__Instance, d);
            }

            public APFloat(float f)
            {
                __Instance = Marshal.AllocHGlobal(16);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_6(__Instance, f);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                llvm.APFloat __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance || force)
                    Internal.dtor_0(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            /// <summary>
            /// <para>Returns whether this instance allocated memory.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Returns whether this instance allocated memory.</para>
            /// </remarks>
            public bool needsCleanup()
            {
                var __ret = Internal.needsCleanup_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Used to insert APFloat objects, or objects that contain APFloat
            /// objects, into FoldingSets.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Used to insert APFloat objects, or objects that contain
            /// APFloat objects,</para>
            /// <para>  /// into FoldingSets.</para>
            /// </remarks>
            public void Profile(llvm.FoldingSetNodeID NID)
            {
                var arg0 = ReferenceEquals(NID, null) ? global::System.IntPtr.Zero : NID.__Instance;
                Internal.Profile_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>@{</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \name Arithmetic</para>
            /// <para>  /// @{</para>
            /// </remarks>
            public llvm.APFloat.opStatus add(llvm.APFloat _0, llvm.APFloat.roundingMode _1)
            {
                var arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
                var arg1 = _1;
                var __ret = Internal.add_0(__Instance, arg0, arg1);
                return __ret;
            }

            public llvm.APFloat.opStatus subtract(llvm.APFloat _0, llvm.APFloat.roundingMode _1)
            {
                var arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
                var arg1 = _1;
                var __ret = Internal.subtract_0(__Instance, arg0, arg1);
                return __ret;
            }

            public llvm.APFloat.opStatus multiply(llvm.APFloat _0, llvm.APFloat.roundingMode _1)
            {
                var arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
                var arg1 = _1;
                var __ret = Internal.multiply_0(__Instance, arg0, arg1);
                return __ret;
            }

            public llvm.APFloat.opStatus divide(llvm.APFloat _0, llvm.APFloat.roundingMode _1)
            {
                var arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
                var arg1 = _1;
                var __ret = Internal.divide_0(__Instance, arg0, arg1);
                return __ret;
            }

            /// <summary>
            /// <para>IEEE remainder.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// IEEE remainder.</para>
            /// </remarks>
            public llvm.APFloat.opStatus remainder(llvm.APFloat _0)
            {
                var arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
                var __ret = Internal.remainder_0(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>C fmod, or llvm frem.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// C fmod, or llvm frem.</para>
            /// </remarks>
            public llvm.APFloat.opStatus mod(llvm.APFloat _0, llvm.APFloat.roundingMode _1)
            {
                var arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
                var arg1 = _1;
                var __ret = Internal.mod_0(__Instance, arg0, arg1);
                return __ret;
            }

            public llvm.APFloat.opStatus fusedMultiplyAdd(llvm.APFloat _0, llvm.APFloat _1, llvm.APFloat.roundingMode _2)
            {
                var arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
                var arg1 = ReferenceEquals(_1, null) ? global::System.IntPtr.Zero : _1.__Instance;
                var arg2 = _2;
                var __ret = Internal.fusedMultiplyAdd_0(__Instance, arg0, arg1, arg2);
                return __ret;
            }

            public llvm.APFloat.opStatus roundToIntegral(llvm.APFloat.roundingMode _0)
            {
                var arg0 = _0;
                var __ret = Internal.roundToIntegral_0(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>IEEE-754R 5.3.1: nextUp/nextDown.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// IEEE-754R 5.3.1: nextUp/nextDown.</para>
            /// </remarks>
            public llvm.APFloat.opStatus next(bool nextDown)
            {
                var __ret = Internal.next_0(__Instance, nextDown);
                return __ret;
            }

            /// <summary>
            /// <para>Operator+ overload which provides the default nmNearestTiesToEven
            /// rounding mode and *no* error checking.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Operator+ overload which provides the default</para>
            /// <para>  /// \c nmNearestTiesToEven rounding mode and *no* error
            /// checking.</para>
            /// </remarks>
            public static llvm.APFloat operator +(llvm.APFloat __op, llvm.APFloat RHS)
            {
                var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
                var arg1 = ReferenceEquals(RHS, null) ? global::System.IntPtr.Zero : RHS.__Instance;
                var __ret = new llvm.APFloat.Internal();
                Internal.OperatorPlus_0(new IntPtr(&__ret), arg0, arg1);
                return llvm.APFloat.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Operator- overload which provides the default nmNearestTiesToEven
            /// rounding mode and *no* error checking.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Operator- overload which provides the default</para>
            /// <para>  /// \c nmNearestTiesToEven rounding mode and *no* error
            /// checking.</para>
            /// </remarks>
            public static llvm.APFloat operator -(llvm.APFloat __op, llvm.APFloat RHS)
            {
                var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
                var arg1 = ReferenceEquals(RHS, null) ? global::System.IntPtr.Zero : RHS.__Instance;
                var __ret = new llvm.APFloat.Internal();
                Internal.OperatorMinus_0(new IntPtr(&__ret), arg0, arg1);
                return llvm.APFloat.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Operator* overload which provides the default nmNearestTiesToEven
            /// rounding mode and *no* error checking.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Operator* overload which provides the default</para>
            /// <para>  /// \c nmNearestTiesToEven rounding mode and *no* error
            /// checking.</para>
            /// </remarks>
            public static llvm.APFloat operator *(llvm.APFloat __op, llvm.APFloat RHS)
            {
                var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
                var arg1 = ReferenceEquals(RHS, null) ? global::System.IntPtr.Zero : RHS.__Instance;
                var __ret = new llvm.APFloat.Internal();
                Internal.OperatorStar_0(new IntPtr(&__ret), arg0, arg1);
                return llvm.APFloat.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Operator/ overload which provides the default nmNearestTiesToEven
            /// rounding mode and *no* error checking.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Operator/ overload which provides the default</para>
            /// <para>  /// \c nmNearestTiesToEven rounding mode and *no* error
            /// checking.</para>
            /// </remarks>
            public static llvm.APFloat operator /(llvm.APFloat __op, llvm.APFloat RHS)
            {
                var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
                var arg1 = ReferenceEquals(RHS, null) ? global::System.IntPtr.Zero : RHS.__Instance;
                var __ret = new llvm.APFloat.Internal();
                Internal.OperatorSlash_0(new IntPtr(&__ret), arg0, arg1);
                return llvm.APFloat.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>@{</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \name Sign operations.</para>
            /// <para>  /// @{</para>
            /// </remarks>
            public void changeSign()
            {
                Internal.changeSign_0(__Instance);
            }

            public void clearSign()
            {
                Internal.clearSign_0(__Instance);
            }

            public void copySign(llvm.APFloat _0)
            {
                var arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
                Internal.copySign_0(__Instance, arg0);
            }

            public llvm.APFloat.opStatus convertToInteger(ref ulong _0, uint _1, bool _2, llvm.APFloat.roundingMode _3, ref bool _4)
            {
                fixed (ulong* arg0 = &_0)
                {
                    var arg3 = _3;
                    fixed (bool* arg4 = &_4)
                    {
                        var __ret = Internal.convertToInteger_0(__Instance, arg0, _1, _2, arg3, arg4);
                        return __ret;
                    }
                }
            }

            public llvm.APFloat.opStatus convertToInteger(llvm.APSInt _0, llvm.APFloat.roundingMode _1, ref bool _2)
            {
                var arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
                var arg1 = _1;
                fixed (bool* arg2 = &_2)
                {
                    var __ret = Internal.convertToInteger_1(__Instance, arg0, arg1, arg2);
                    return __ret;
                }
            }

            public llvm.APFloat.opStatus convertFromAPInt(llvm.APInt _0, bool _1, llvm.APFloat.roundingMode _2)
            {
                var arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
                var arg2 = _2;
                var __ret = Internal.convertFromAPInt_0(__Instance, arg0, _1, arg2);
                return __ret;
            }

            public llvm.APFloat.opStatus convertFromSignExtendedInteger(ref ulong _0, uint _1, bool _2, llvm.APFloat.roundingMode _3)
            {
                fixed (ulong* arg0 = &_0)
                {
                    var arg3 = _3;
                    var __ret = Internal.convertFromSignExtendedInteger_0(__Instance, arg0, _1, _2, arg3);
                    return __ret;
                }
            }

            public llvm.APFloat.opStatus convertFromZeroExtendedInteger(ref ulong _0, uint _1, bool _2, llvm.APFloat.roundingMode _3)
            {
                fixed (ulong* arg0 = &_0)
                {
                    var arg3 = _3;
                    var __ret = Internal.convertFromZeroExtendedInteger_0(__Instance, arg0, _1, _2, arg3);
                    return __ret;
                }
            }

            public llvm.APFloat.opStatus convertFromString(llvm.StringRef _0, llvm.APFloat.roundingMode _1)
            {
                var arg0 = ReferenceEquals(_0, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (_0.__Instance);
                var arg1 = _1;
                var __ret = Internal.convertFromString_0(__Instance, arg0, arg1);
                return __ret;
            }

            public llvm.APInt bitcastToAPInt()
            {
                var __ret = new llvm.APInt.Internal();
                Internal.bitcastToAPInt_0(new IntPtr(&__ret), __Instance);
                return llvm.APInt.__CreateInstance(__ret);
            }

            public double convertToDouble()
            {
                var __ret = Internal.convertToDouble_0(__Instance);
                return __ret;
            }

            public float convertToFloat()
            {
                var __ret = Internal.convertToFloat_0(__Instance);
                return __ret;
            }

            public static bool operator !=(llvm.APFloat __op, llvm.APFloat _0)
            {
                return !(__op == _0);
            }

            /// <summary>
            /// <para>The definition of equality is not straightforward for floating
            /// point, so we won't use operator==. Use one of the following, or write
            /// whatever it is you really mean.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// The definition of equality is not straightforward for
            /// floating point, so</para>
            /// <para>  /// we won't use operator==.  Use one of the following, or
            /// write whatever it</para>
            /// <para>  /// is you really mean.</para>
            /// </remarks>
            public static bool operator ==(llvm.APFloat __op, llvm.APFloat _0)
            {
                bool __opNull = ReferenceEquals(__op, null);
                bool _0Null = ReferenceEquals(_0, null);
                if (__opNull || _0Null)
                    return __opNull && _0Null;
                var arg0 = __op.__Instance;
                var arg1 = _0.__Instance;
                var __ret = Internal.OperatorEqualEqual_0(arg0, arg1);
                return __ret;
            }

            public override bool Equals(object obj)
            {
                return this == obj as APFloat;
            }

            /// <summary>
            /// <para>IEEE comparison with another floating point number (NaNs compare
            /// unordered, 0==-0).</para>
            /// </summary>
            /// <remarks>
            /// <para>/// IEEE comparison with another floating point number (NaNs
            /// compare</para>
            /// <para>  /// unordered, 0==-0).</para>
            /// </remarks>
            public llvm.APFloat.cmpResult compare(llvm.APFloat _0)
            {
                var arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
                var __ret = Internal.compare_0(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Bitwise comparison for equality (QNaNs compare equal,
            /// 0!=-0).</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Bitwise comparison for equality (QNaNs compare equal,
            /// 0!=-0).</para>
            /// </remarks>
            public bool bitwiseIsEqual(llvm.APFloat _0)
            {
                var arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
                var __ret = Internal.bitwiseIsEqual_0(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Write out a hexadecimal representation of the floating point
            /// value to DST, which must be of sufficient size, in the C99 form
            /// [-]0xh.hhhhp[+-]d. Return the number of characters written, excluding the
            /// terminating NUL.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Write out a hexadecimal representation of the floating point
            /// value to DST,</para>
            /// <para>  /// which must be of sufficient size, in the C99 form
            /// [-]0xh.hhhhp[+-]d.</para>
            /// <para>  /// Return the number of characters written, excluding the
            /// terminating NUL.</para>
            /// </remarks>
            public uint convertToHexString(sbyte* dst, uint hexDigits, bool upperCase, llvm.APFloat.roundingMode _0)
            {
                var arg0 = dst;
                var arg3 = _0;
                var __ret = Internal.convertToHexString_0(__Instance, arg0, hexDigits, upperCase, arg3);
                return __ret;
            }

            /// <summary>
            /// <para>IEEE-754R isSignMinus: Returns true if and only if the current
            /// value is negative.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// IEEE-754R isSignMinus: Returns true if and only if the
            /// current value is</para>
            /// <para>  /// negative.</para>
            /// <para>  ///</para>
            /// <para>  /// This applies to zeros and NaNs as well.</para>
            /// </remarks>
            public bool isNegative()
            {
                var __ret = Internal.isNegative_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>IEEE-754R isNormal: Returns true if and only if the current value
            /// is normal.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// IEEE-754R isNormal: Returns true if and only if the current
            /// value is normal.</para>
            /// <para>  ///</para>
            /// <para>  /// This implies that the current value of the float is not
            /// zero, subnormal,</para>
            /// <para>  /// infinite, or NaN following the definition of normality from
            /// IEEE-754R.</para>
            /// </remarks>
            public bool isNormal()
            {
                var __ret = Internal.isNormal_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Returns true if and only if the current value is zero, subnormal,
            /// or normal.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Returns true if and only if the current value is zero,
            /// subnormal, or</para>
            /// <para>  /// normal.</para>
            /// <para>  ///</para>
            /// <para>  /// This means that the value is not infinite or NaN.</para>
            /// </remarks>
            public bool isFinite()
            {
                var __ret = Internal.isFinite_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Returns true if and only if the float is plus or minus
            /// zero.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Returns true if and only if the float is plus or minus
            /// zero.</para>
            /// </remarks>
            public bool isZero()
            {
                var __ret = Internal.isZero_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>IEEE-754R isSubnormal(): Returns true if and only if the float is
            /// a denormal.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// IEEE-754R isSubnormal(): Returns true if and only if the
            /// float is a</para>
            /// <para>  /// denormal.</para>
            /// </remarks>
            public bool isDenormal()
            {
                var __ret = Internal.isDenormal_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>IEEE-754R isInfinite(): Returns true if and only if the float is
            /// infinity.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// IEEE-754R isInfinite(): Returns true if and only if the float
            /// is infinity.</para>
            /// </remarks>
            public bool isInfinity()
            {
                var __ret = Internal.isInfinity_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Returns true if and only if the float is a quiet or signaling
            /// NaN.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Returns true if and only if the float is a quiet or signaling
            /// NaN.</para>
            /// </remarks>
            public bool isNaN()
            {
                var __ret = Internal.isNaN_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Returns true if and only if the float is a signaling NaN.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Returns true if and only if the float is a signaling
            /// NaN.</para>
            /// </remarks>
            public bool isSignaling()
            {
                var __ret = Internal.isSignaling_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>@{</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \name Simple Queries</para>
            /// <para>  /// @{</para>
            /// </remarks>
            public llvm.APFloat.fltCategory getCategory()
            {
                var __ret = Internal.getCategory_0(__Instance);
                return __ret;
            }

            public bool isNonZero()
            {
                var __ret = Internal.isNonZero_0(__Instance);
                return __ret;
            }

            public bool isFiniteNonZero()
            {
                var __ret = Internal.isFiniteNonZero_0(__Instance);
                return __ret;
            }

            public bool isPosZero()
            {
                var __ret = Internal.isPosZero_0(__Instance);
                return __ret;
            }

            public bool isNegZero()
            {
                var __ret = Internal.isNegZero_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Returns true if and only if the number has the smallest possible
            /// non-zero magnitude in the current semantics.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Returns true if and only if the number has the smallest
            /// possible non-zero</para>
            /// <para>  /// magnitude in the current semantics.</para>
            /// </remarks>
            public bool isSmallest()
            {
                var __ret = Internal.isSmallest_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Returns true if and only if the number has the largest possible
            /// finite magnitude in the current semantics.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Returns true if and only if the number has the largest
            /// possible finite</para>
            /// <para>  /// magnitude in the current semantics.</para>
            /// </remarks>
            public bool isLargest()
            {
                var __ret = Internal.isLargest_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>If this value has an exact multiplicative inverse, store it in
            /// inv and return true.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// If this value has an exact multiplicative inverse, store it
            /// in inv and</para>
            /// <para>  /// return true.</para>
            /// </remarks>
            public bool getExactInverse(llvm.APFloat inv)
            {
                var arg0 = ReferenceEquals(inv, null) ? global::System.IntPtr.Zero : inv.__Instance;
                var __ret = Internal.getExactInverse_0(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Returns a float which is bitcasted from an all one value
            /// int.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Returns a float which is bitcasted from an all one value
            /// int.</para>
            /// <para>  ///</para>
            /// <para>  /// \param BitWidth - Select float type</para>
            /// <para>  /// \param isIEEE   - If 128 bit number, select between PPC and
            /// IEEE</para>
            /// </remarks>
            public static llvm.APFloat getAllOnesValue(uint BitWidth, bool isIEEE)
            {
                var __ret = new llvm.APFloat.Internal();
                Internal.getAllOnesValue_0(new IntPtr(&__ret), BitWidth, isIEEE);
                return llvm.APFloat.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>A static helper to produce a copy of an APFloat value with its
            /// sign copied from some other APFloat.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief A static helper to produce a copy of an APFloat value
            /// with its sign</para>
            /// <para>  /// copied from some other APFloat.</para>
            /// </remarks>
            public static llvm.APFloat copySign(llvm.APFloat Value, llvm.APFloat Sign)
            {
                var arg0 = ReferenceEquals(Value, null) ? new llvm.APFloat.Internal() : *(llvm.APFloat.Internal*) (Value.__Instance);
                var arg1 = ReferenceEquals(Sign, null) ? global::System.IntPtr.Zero : Sign.__Instance;
                var __ret = new llvm.APFloat.Internal();
                Internal.copySign_1(new IntPtr(&__ret), arg0, arg1);
                return llvm.APFloat.__CreateInstance(__ret);
            }
        }

        public unsafe partial class APFloat
        {
            public partial struct Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm5ilogbERKNS_7APFloatE")]
                internal static extern int ilogb_0(global::System.IntPtr Arg);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm6scalbnENS_7APFloatEi")]
                internal static extern void scalbn_0(global::System.IntPtr @return, llvm.APFloat.Internal X, int Exp);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm3absENS_7APFloatE")]
                internal static extern void abs_0(global::System.IntPtr @return, llvm.APFloat.Internal X);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm6minnumERKNS_7APFloatES2_")]
                internal static extern void minnum_0(global::System.IntPtr @return, global::System.IntPtr A, global::System.IntPtr B);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm6maxnumERKNS_7APFloatES2_")]
                internal static extern void maxnum_0(global::System.IntPtr @return, global::System.IntPtr A, global::System.IntPtr B);
            }

            /// <summary>
            /// <para>Returns the exponent of the internal representation of the
            /// APFloat.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Returns the exponent of the internal representation of
            /// the APFloat.</para>
            /// <para>  ///</para>
            /// <para>  /// Because the radix of APFloat is 2, this is equivalent to
            /// floor(log2(x)).</para>
            /// <para>  /// For special APFloat values, this returns special error
            /// codes:</para>
            /// <para>  ///</para>
            /// <para>  ///   NaN -&gt; \c IEK_NaN</para>
            /// <para>  ///   0   -&gt; \c IEK_Zero</para>
            /// <para>  ///   Inf -&gt; \c IEK_Inf</para>
            /// <para>  ///</para>
            /// </remarks>
            public static int ilogb(llvm.APFloat Arg)
            {
                var arg0 = ReferenceEquals(Arg, null) ? global::System.IntPtr.Zero : Arg.__Instance;
                var __ret = Internal.ilogb_0(arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Returns: X * 2^Exp for integral exponents.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Returns: X * 2^Exp for integral exponents.</para>
            /// </remarks>
            public static llvm.APFloat scalbn(llvm.APFloat X, int Exp)
            {
                var arg0 = ReferenceEquals(X, null) ? new llvm.APFloat.Internal() : *(llvm.APFloat.Internal*) (X.__Instance);
                var __ret = new llvm.APFloat.Internal();
                Internal.scalbn_0(new IntPtr(&__ret), arg0, Exp);
                return llvm.APFloat.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Returns the absolute value of the argument.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Returns the absolute value of the argument.</para>
            /// </remarks>
            public static llvm.APFloat abs(llvm.APFloat X)
            {
                var arg0 = ReferenceEquals(X, null) ? new llvm.APFloat.Internal() : *(llvm.APFloat.Internal*) (X.__Instance);
                var __ret = new llvm.APFloat.Internal();
                Internal.abs_0(new IntPtr(&__ret), arg0);
                return llvm.APFloat.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Implements IEEE minNum semantics. Returns the smaller of the 2
            /// arguments if both are not NaN. If either argument is a NaN, returns the
            /// other argument.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Implements IEEE minNum semantics. Returns the smaller of the
            /// 2 arguments if</para>
            /// <para>/// both are not NaN. If either argument is a NaN, returns the
            /// other argument.</para>
            /// </remarks>
            public static llvm.APFloat minnum(llvm.APFloat A, llvm.APFloat B)
            {
                var arg0 = ReferenceEquals(A, null) ? global::System.IntPtr.Zero : A.__Instance;
                var arg1 = ReferenceEquals(B, null) ? global::System.IntPtr.Zero : B.__Instance;
                var __ret = new llvm.APFloat.Internal();
                Internal.minnum_0(new IntPtr(&__ret), arg0, arg1);
                return llvm.APFloat.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Implements IEEE maxNum semantics. Returns the larger of the 2
            /// arguments if both are not NaN. If either argument is a NaN, returns the
            /// other argument.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Implements IEEE maxNum semantics. Returns the larger of the 2
            /// arguments if</para>
            /// <para>/// both are not NaN. If either argument is a NaN, returns the
            /// other argument.</para>
            /// </remarks>
            public static llvm.APFloat maxnum(llvm.APFloat A, llvm.APFloat B)
            {
                var arg0 = ReferenceEquals(A, null) ? global::System.IntPtr.Zero : A.__Instance;
                var arg1 = ReferenceEquals(B, null) ? global::System.IntPtr.Zero : B.__Instance;
                var __ret = new llvm.APFloat.Internal();
                Internal.maxnum_0(new IntPtr(&__ret), arg0, arg1);
                return llvm.APFloat.__CreateInstance(__ret);
            }
        }
    }
}
