//----------------------------------------------------------------------------
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
//----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace CppSharp
{
    namespace clang
    {
        /// <summary>
        /// <para>Represents a template argument.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief Represents a template argument.</para>
        /// </remarks>
        public unsafe partial class TemplateArgument : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 20)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                internal clang.TemplateArgument._.Internal _0;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16TemplateArgumentC2Ev")]
                internal static extern void ctor_1(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16TemplateArgumentC2ENS_8QualTypeEb")]
                internal static extern void ctor_2(global::System.IntPtr instance, clang.QualType.Internal T, bool isNullPtr);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16TemplateArgumentC2EPNS_9ValueDeclENS_8QualTypeE")]
                internal static extern void ctor_3(global::System.IntPtr instance, global::System.IntPtr D, clang.QualType.Internal QT);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16TemplateArgumentC2ERNS_10ASTContextERKN4llvm6APSIntENS_8QualTypeE")]
                internal static extern void ctor_4(global::System.IntPtr instance, global::System.IntPtr Ctx, global::System.IntPtr Value, clang.QualType.Internal Type);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16TemplateArgumentC2ERKS0_NS_8QualTypeE")]
                internal static extern void ctor_5(global::System.IntPtr instance, global::System.IntPtr Other, clang.QualType.Internal Type);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16TemplateArgumentC2ENS_12TemplateNameE")]
                internal static extern void ctor_6(global::System.IntPtr instance, clang.TemplateName.Internal Name);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16TemplateArgumentC2EPKS0_j")]
                internal static extern void ctor_9(global::System.IntPtr instance, global::System.IntPtr Args, uint NumArgs);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16TemplateArgumentC2ERKS0_")]
                internal static extern void cctor_10(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16TemplateArgument12getEmptyPackEv")]
                internal static extern void getEmptyPack_0(global::System.IntPtr @return);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16TemplateArgument14CreatePackCopyERNS_10ASTContextEPKS0_j")]
                internal static extern void CreatePackCopy_0(global::System.IntPtr @return, global::System.IntPtr Context, global::System.IntPtr Args, uint NumArgs);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang16TemplateArgument7getKindEv")]
                internal static extern clang.TemplateArgument.ArgKind getKind_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang16TemplateArgument6isNullEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isNull_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang16TemplateArgument11isDependentEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isDependent_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang16TemplateArgument24isInstantiationDependentEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isInstantiationDependent_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang16TemplateArgument31containsUnexpandedParameterPackEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool containsUnexpandedParameterPack_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang16TemplateArgument15isPackExpansionEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isPackExpansion_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang16TemplateArgument9getAsTypeEv")]
                internal static extern clang.QualType.Internal getAsType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang16TemplateArgument9getAsDeclEv")]
                internal static extern global::System.IntPtr getAsDecl_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang16TemplateArgument19getParamTypeForDeclEv")]
                internal static extern clang.QualType.Internal getParamTypeForDecl_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang16TemplateArgument14getNullPtrTypeEv")]
                internal static extern clang.QualType.Internal getNullPtrType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang16TemplateArgument13getAsTemplateEv")]
                internal static extern clang.TemplateName.Internal getAsTemplate_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang16TemplateArgument30getAsTemplateOrTemplatePatternEv")]
                internal static extern clang.TemplateName.Internal getAsTemplateOrTemplatePattern_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang16TemplateArgument13getAsIntegralEv")]
                internal static extern void getAsIntegral_0(global::System.IntPtr @return, global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang16TemplateArgument15getIntegralTypeEv")]
                internal static extern clang.QualType.Internal getIntegralType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16TemplateArgument15setIntegralTypeENS_8QualTypeE")]
                internal static extern void setIntegralType_0(global::System.IntPtr instance, clang.QualType.Internal T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang16TemplateArgument10pack_beginEv")]
                internal static extern global::System.IntPtr pack_begin_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang16TemplateArgument8pack_endEv")]
                internal static extern global::System.IntPtr pack_end_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang16TemplateArgument9pack_sizeEv")]
                internal static extern uint pack_size_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang16TemplateArgument18structurallyEqualsERKS0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool structurallyEquals_0(global::System.IntPtr instance, global::System.IntPtr Other);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang16TemplateArgument23getPackExpansionPatternEv")]
                internal static extern void getPackExpansionPattern_0(global::System.IntPtr @return, global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang16TemplateArgument5printERKNS_14PrintingPolicyERN4llvm11raw_ostreamE")]
                internal static extern void print_0(global::System.IntPtr instance, global::System.IntPtr Policy, global::System.IntPtr Out);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang16TemplateArgument7ProfileERN4llvm16FoldingSetNodeIDERKNS_10ASTContextE")]
                internal static extern void Profile_0(global::System.IntPtr instance, global::System.IntPtr ID, global::System.IntPtr Context);
            }

            /// <summary>
            /// <para>The kind of template argument we're storing.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief The kind of template argument we're storing.</para>
            /// </remarks>
            public enum ArgKind : uint
            {
                /// <summary>Represents an empty template argument, e.g., one that has not been deduced.</summary>
                Null = 0,
                /// <summary>The template argument is a type.</summary>
                Type = 1,
                /// <summary>The template argument is a declaration that was provided for a pointer, reference, or pointer to member non-type template parameter.</summary>
                Declaration = 2,
                /// <summary>The template argument is a null pointer or null pointer to member that was provided for a non-type template parameter.</summary>
                NullPtr = 3,
                /// <summary>The template argument is an integral value stored in an llvm::APSInt that was provided for an integral non-type template parameter.</summary>
                Integral = 4,
                /// <summary>The template argument is a template name that was provided for a template template parameter.</summary>
                Template = 5,
                /// <summary>The template argument is a pack expansion of a template name that was provided for a template template parameter.</summary>
                TemplateExpansion = 6,
                /// <summary>The template argument is an expression, and we've not resolved it to one of the other forms yet, either because it's dependent or because we're representing a non-canonical template argument (for instance, in a TemplateSpecializationType). Also used to represent a non-dependent __uuidof expression (a Microsoft extension).</summary>
                Expression = 7,
                /// <summary>The template argument is actually a parameter pack. Arguments are stored in the Args struct.</summary>
                Pack = 8
            }

            /// <summary>
            /// <para>Iterator that traverses the elements of a template argument
            /// pack.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Iterator that traverses the elements of a template
            /// argument pack.</para>
            /// </remarks>
            public class pack_iterator { }

            /// <summary>
            /// <para>The kind of template argument we're storing.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief The kind of template argument we're storing.</para>
            /// </remarks>
            internal unsafe partial class DA
            {
                [StructLayout(LayoutKind.Explicit, Size = 12)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public uint Kind;

                    [FieldOffset(4)]
                    public global::System.IntPtr QT;

                    [FieldOffset(8)]
                    public global::System.IntPtr D;
                }
            }

            internal unsafe partial class I
            {
                [StructLayout(LayoutKind.Explicit, Size = 20)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public uint Kind;

                    [FieldOffset(4)]
                    public uint BitWidth;

                    [FieldOffset(7)]
                    public uint IsUnsigned;

                    [FieldOffset(8)]
                    internal clang.TemplateArgument.I._.Internal _0;

                    [FieldOffset(16)]
                    public global::System.IntPtr Type;
                }

                public unsafe partial struct _
                {
                    [StructLayout(LayoutKind.Explicit, Size = 8)]
                    public partial struct Internal
                    {
                        [FieldOffset(0)]
                        public ulong VAL;

                        [FieldOffset(0)]
                        public ulong* pVal;
                    }
                }
            }

            internal unsafe partial class A
            {
                [StructLayout(LayoutKind.Explicit, Size = 12)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public uint Kind;

                    [FieldOffset(4)]
                    public uint NumArgs;

                    [FieldOffset(8)]
                    public global::System.IntPtr Args;
                }
            }

            internal unsafe partial class TA
            {
                [StructLayout(LayoutKind.Explicit, Size = 12)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public uint Kind;

                    [FieldOffset(4)]
                    public uint NumExpansions;

                    [FieldOffset(8)]
                    public global::System.IntPtr Name;
                }
            }

            internal unsafe partial class TV
            {
                [StructLayout(LayoutKind.Explicit, Size = 8)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public uint Kind;

                    [FieldOffset(4)]
                    public uint V;
                }
            }

            internal unsafe partial struct _
            {
                [StructLayout(LayoutKind.Explicit, Size = 20)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    internal clang.TemplateArgument.DA.Internal DeclArg;

                    [FieldOffset(0)]
                    internal clang.TemplateArgument.I.Internal Integer;

                    [FieldOffset(0)]
                    internal clang.TemplateArgument.A.Internal Args;

                    [FieldOffset(0)]
                    internal clang.TemplateArgument.TA.Internal TemplateArg;

                    [FieldOffset(0)]
                    internal clang.TemplateArgument.TV.Internal TypeOrValue;
                }
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, TemplateArgument> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, TemplateArgument>();

            private readonly bool __ownsNativeInstance;

            public static TemplateArgument __CreateInstance(global::System.IntPtr native)
            {
                return new TemplateArgument((TemplateArgument.Internal*) native);
            }

            public static TemplateArgument __CreateInstance(TemplateArgument.Internal native)
            {
                return new TemplateArgument(native);
            }

            private static TemplateArgument.Internal* __CopyValue(TemplateArgument.Internal native)
            {
                var ret = (TemplateArgument.Internal*) Marshal.AllocHGlobal(20);
                *ret = native;
                return ret;
            }

            private TemplateArgument(TemplateArgument.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected TemplateArgument(TemplateArgument.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            /// <summary>
            /// <para>Construct an empty, invalid template argument.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Construct an empty, invalid template argument.</para>
            /// </remarks>
            public TemplateArgument()
            {
                __Instance = Marshal.AllocHGlobal(20);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_1(__Instance);
            }

            /// <summary>
            /// <para>Construct a template type argument.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Construct a template type argument.</para>
            /// </remarks>
            public TemplateArgument(clang.QualType T, bool isNullPtr)
            {
                __Instance = Marshal.AllocHGlobal(20);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(T, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (T.__Instance);
                Internal.ctor_2(__Instance, arg0, isNullPtr);
            }

            /// <summary>
            /// <para>Construct a template argument that refers to a declaration, which
            /// is either an external declaration or a template declaration.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Construct a template argument that refers to a</para>
            /// <para>  /// declaration, which is either an external declaration or
            /// a</para>
            /// <para>  /// template declaration.</para>
            /// </remarks>
            public TemplateArgument(clang.ValueDecl D, clang.QualType QT)
            {
                __Instance = Marshal.AllocHGlobal(20);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(D, null) ? global::System.IntPtr.Zero : D.__Instance;
                var arg1 = ReferenceEquals(QT, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (QT.__Instance);
                Internal.ctor_3(__Instance, arg0, arg1);
            }

            /// <summary>
            /// <para>Construct an integral constant template argument. The memory to
            /// store the value is allocated with Ctx.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Construct an integral constant template argument. The
            /// memory to</para>
            /// <para>  /// store the value is allocated with Ctx.</para>
            /// </remarks>
            public TemplateArgument(clang.ASTContext Ctx, llvm.APSInt Value, clang.QualType Type)
            {
                __Instance = Marshal.AllocHGlobal(20);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(Ctx, null) ? global::System.IntPtr.Zero : Ctx.__Instance;
                var arg1 = ReferenceEquals(Value, null) ? global::System.IntPtr.Zero : Value.__Instance;
                var arg2 = ReferenceEquals(Type, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (Type.__Instance);
                Internal.ctor_4(__Instance, arg0, arg1, arg2);
            }

            /// <summary>
            /// <para>Construct an integral constant template argument with the same
            /// value as Other but a different type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Construct an integral constant template argument with
            /// the same</para>
            /// <para>  /// value as Other but a different type.</para>
            /// </remarks>
            public TemplateArgument(clang.TemplateArgument Other, clang.QualType Type)
            {
                __Instance = Marshal.AllocHGlobal(20);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(Other, null) ? global::System.IntPtr.Zero : Other.__Instance;
                var arg1 = ReferenceEquals(Type, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (Type.__Instance);
                Internal.ctor_5(__Instance, arg0, arg1);
            }

            /// <summary>
            /// <para>Construct a template argument that is a template.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Construct a template argument that is a
            /// template.</para>
            /// <para>  ///</para>
            /// <para>  /// This form of template argument is generally used for
            /// template template</para>
            /// <para>  /// parameters. However, the template name could be a dependent
            /// template</para>
            /// <para>  /// name that ends up being instantiated to a function template
            /// whose address</para>
            /// <para>  /// is taken.</para>
            /// <para>  ///</para>
            /// <para>  /// \param Name The template name.</para>
            /// </remarks>
            public TemplateArgument(clang.TemplateName Name)
            {
                __Instance = Marshal.AllocHGlobal(20);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(Name, null) ? new clang.TemplateName.Internal() : *(clang.TemplateName.Internal*) (Name.__Instance);
                Internal.ctor_6(__Instance, arg0);
            }

            /// <summary>
            /// <para>Construct a template argument that is a template argument
            /// pack.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Construct a template argument that is a template
            /// argument pack.</para>
            /// <para>  ///</para>
            /// <para>  /// We assume that storage for the template arguments
            /// provided</para>
            /// <para>  /// outlives the TemplateArgument itself.</para>
            /// </remarks>
            public TemplateArgument(clang.TemplateArgument Args, uint NumArgs)
            {
                __Instance = Marshal.AllocHGlobal(20);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(Args, null) ? global::System.IntPtr.Zero : Args.__Instance;
                Internal.ctor_9(__Instance, arg0, NumArgs);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.TemplateArgument __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            /// <summary>
            /// <para>Return the kind of stored template argument.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the kind of stored template argument.</para>
            /// </remarks>
            public clang.TemplateArgument.ArgKind getKind()
            {
                var __ret = Internal.getKind_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determine whether this template argument has no value.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine whether this template argument has no
            /// value.</para>
            /// </remarks>
            public bool isNull()
            {
                var __ret = Internal.isNull_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Whether this template argument is dependent on a template
            /// parameter such that its result can change from one instantiation to
            /// another.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Whether this template argument is dependent on a
            /// template</para>
            /// <para>  /// parameter such that its result can change from one
            /// instantiation to</para>
            /// <para>  /// another.</para>
            /// </remarks>
            public bool isDependent()
            {
                var __ret = Internal.isDependent_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Whether this template argument is dependent on a template
            /// parameter.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Whether this template argument is dependent on a
            /// template</para>
            /// <para>  /// parameter.</para>
            /// </remarks>
            public bool isInstantiationDependent()
            {
                var __ret = Internal.isInstantiationDependent_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Whether this template argument contains an unexpanded parameter
            /// pack.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Whether this template argument contains an
            /// unexpanded</para>
            /// <para>  /// parameter pack.</para>
            /// </remarks>
            public bool containsUnexpandedParameterPack()
            {
                var __ret = Internal.containsUnexpandedParameterPack_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determine whether this template argument is a pack
            /// expansion.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine whether this template argument is a pack
            /// expansion.</para>
            /// </remarks>
            public bool isPackExpansion()
            {
                var __ret = Internal.isPackExpansion_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Retrieve the type for a type template argument.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the type for a type template argument.</para>
            /// </remarks>
            public clang.QualType getAsType()
            {
                var __ret = Internal.getAsType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Retrieve the declaration for a declaration non-type template
            /// argument.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the declaration for a declaration
            /// non-type</para>
            /// <para>  /// template argument.</para>
            /// </remarks>
            public clang.ValueDecl getAsDecl()
            {
                var __ret = Internal.getAsDecl_0(__Instance);
                clang.ValueDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.ValueDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.ValueDecl) clang.ValueDecl.NativeToManagedMap[__ret];
                else clang.ValueDecl.NativeToManagedMap[__ret] = __result0 = (clang.ValueDecl) clang.ValueDecl.__CreateInstance(__ret);
                return __result0;
            }

            public clang.QualType getParamTypeForDecl()
            {
                var __ret = Internal.getParamTypeForDecl_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Retrieve the type for null non-type template argument.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the type for null non-type template
            /// argument.</para>
            /// </remarks>
            public clang.QualType getNullPtrType()
            {
                var __ret = Internal.getNullPtrType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Retrieve the template name for a template name argument.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the template name for a template name
            /// argument.</para>
            /// </remarks>
            public clang.TemplateName getAsTemplate()
            {
                var __ret = Internal.getAsTemplate_0(__Instance);
                return clang.TemplateName.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Retrieve the template argument as a template name; if the
            /// argument is a pack expansion, return the pattern as a template name.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the template argument as a template name; if
            /// the argument</para>
            /// <para>  /// is a pack expansion, return the pattern as a template
            /// name.</para>
            /// </remarks>
            public clang.TemplateName getAsTemplateOrTemplatePattern()
            {
                var __ret = Internal.getAsTemplateOrTemplatePattern_0(__Instance);
                return clang.TemplateName.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Retrieve the template argument as an integral value.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the template argument as an integral
            /// value.</para>
            /// </remarks>
            public llvm.APSInt getAsIntegral()
            {
                var __ret = new llvm.APSInt.Internal();
                Internal.getAsIntegral_0(new IntPtr(&__ret), __Instance);
                return llvm.APSInt.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Retrieve the type of the integral value.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the type of the integral value.</para>
            /// </remarks>
            public clang.QualType getIntegralType()
            {
                var __ret = Internal.getIntegralType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            public void setIntegralType(clang.QualType T)
            {
                var arg0 = ReferenceEquals(T, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (T.__Instance);
                Internal.setIntegralType_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>Iterator referencing the first argument of a template argument
            /// pack.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Iterator referencing the first argument of a template
            /// argument</para>
            /// <para>  /// pack.</para>
            /// </remarks>
            public clang.TemplateArgument pack_begin()
            {
                var __ret = Internal.pack_begin_0(__Instance);
                clang.TemplateArgument __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.TemplateArgument.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.TemplateArgument) clang.TemplateArgument.NativeToManagedMap[__ret];
                else __result0 = clang.TemplateArgument.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Iterator referencing one past the last argument of a template
            /// argument pack.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Iterator referencing one past the last argument of a
            /// template</para>
            /// <para>  /// argument pack.</para>
            /// </remarks>
            public clang.TemplateArgument pack_end()
            {
                var __ret = Internal.pack_end_0(__Instance);
                clang.TemplateArgument __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.TemplateArgument.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.TemplateArgument) clang.TemplateArgument.NativeToManagedMap[__ret];
                else __result0 = clang.TemplateArgument.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>The number of template arguments in the given template argument
            /// pack.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief The number of template arguments in the given template
            /// argument</para>
            /// <para>  /// pack.</para>
            /// </remarks>
            public uint pack_size()
            {
                var __ret = Internal.pack_size_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determines whether two template arguments are superficially the
            /// same.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determines whether two template arguments are
            /// superficially the</para>
            /// <para>  /// same.</para>
            /// </remarks>
            public bool structurallyEquals(clang.TemplateArgument Other)
            {
                var arg0 = ReferenceEquals(Other, null) ? global::System.IntPtr.Zero : Other.__Instance;
                var __ret = Internal.structurallyEquals_0(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>When the template argument is a pack expansion, returns the
            /// pattern of the pack expansion.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief When the template argument is a pack expansion,
            /// returns</para>
            /// <para>  /// the pattern of the pack expansion.</para>
            /// </remarks>
            public clang.TemplateArgument getPackExpansionPattern()
            {
                var __ret = new clang.TemplateArgument.Internal();
                Internal.getPackExpansionPattern_0(new IntPtr(&__ret), __Instance);
                return clang.TemplateArgument.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Print this template argument to the given output stream.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Print this template argument to the given output
            /// stream.</para>
            /// </remarks>
            public void print(clang.PrintingPolicy Policy, llvm.raw_ostream Out)
            {
                var arg0 = ReferenceEquals(Policy, null) ? global::System.IntPtr.Zero : Policy.__Instance;
                var arg1 = ReferenceEquals(Out, null) ? global::System.IntPtr.Zero : Out.__Instance;
                Internal.print_0(__Instance, arg0, arg1);
            }

            /// <summary>
            /// <para>Used to insert TemplateArguments into FoldingSets.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Used to insert TemplateArguments into
            /// FoldingSets.</para>
            /// </remarks>
            public void Profile(llvm.FoldingSetNodeID ID, clang.ASTContext Context)
            {
                var arg0 = ReferenceEquals(ID, null) ? global::System.IntPtr.Zero : ID.__Instance;
                var arg1 = ReferenceEquals(Context, null) ? global::System.IntPtr.Zero : Context.__Instance;
                Internal.Profile_0(__Instance, arg0, arg1);
            }

            public static clang.TemplateArgument getEmptyPack()
            {
                var __ret = new clang.TemplateArgument.Internal();
                Internal.getEmptyPack_0(new IntPtr(&__ret));
                return clang.TemplateArgument.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Create a new template argument pack by copying the given set of
            /// template arguments.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Create a new template argument pack by copying the
            /// given set of</para>
            /// <para>  /// template arguments.</para>
            /// </remarks>
            public static clang.TemplateArgument CreatePackCopy(clang.ASTContext Context, clang.TemplateArgument Args, uint NumArgs)
            {
                var arg0 = ReferenceEquals(Context, null) ? global::System.IntPtr.Zero : Context.__Instance;
                var arg1 = ReferenceEquals(Args, null) ? global::System.IntPtr.Zero : Args.__Instance;
                var __ret = new clang.TemplateArgument.Internal();
                Internal.CreatePackCopy_0(new IntPtr(&__ret), arg0, arg1, NumArgs);
                return clang.TemplateArgument.__CreateInstance(__ret);
            }
        }

        /// <summary>
        /// <para>Location information for a TemplateArgument.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// Location information for a TemplateArgument.</para>
        /// </remarks>
        public unsafe partial class TemplateArgumentLocInfo : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                internal clang.TemplateArgumentLocInfo._.Internal _0;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang23TemplateArgumentLocInfoC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang23TemplateArgumentLocInfoC2EPNS_14TypeSourceInfoE")]
                internal static extern void ctor_1(global::System.IntPtr instance, global::System.IntPtr TInfo);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang23TemplateArgumentLocInfoC2ENS_22NestedNameSpecifierLocENS_14SourceLocationES2_")]
                internal static extern void ctor_3(global::System.IntPtr instance, clang.NestedNameSpecifierLoc.Internal QualifierLoc, clang.SourceLocation.Internal TemplateNameLoc, clang.SourceLocation.Internal EllipsisLoc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang23TemplateArgumentLocInfoC2ERKS0_")]
                internal static extern void cctor_4(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang23TemplateArgumentLocInfo19getAsTypeSourceInfoEv")]
                internal static extern global::System.IntPtr getAsTypeSourceInfo_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang23TemplateArgumentLocInfo23getTemplateQualifierLocEv")]
                internal static extern clang.NestedNameSpecifierLoc.Internal getTemplateQualifierLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang23TemplateArgumentLocInfo18getTemplateNameLocEv")]
                internal static extern clang.SourceLocation.Internal getTemplateNameLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang23TemplateArgumentLocInfo22getTemplateEllipsisLocEv")]
                internal static extern clang.SourceLocation.Internal getTemplateEllipsisLoc_0(global::System.IntPtr instance);
            }

            internal unsafe partial class T
            {
                [StructLayout(LayoutKind.Explicit, Size = 16)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public global::System.IntPtr Qualifier;

                    [FieldOffset(4)]
                    public global::System.IntPtr QualifierLocData;

                    [FieldOffset(8)]
                    public uint TemplateNameLoc;

                    [FieldOffset(12)]
                    public uint EllipsisLoc;
                }
            }

            internal unsafe partial struct _
            {
                [StructLayout(LayoutKind.Explicit, Size = 16)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    internal clang.TemplateArgumentLocInfo.T.Internal Template;

                    [FieldOffset(0)]
                    public global::System.IntPtr Expression;

                    [FieldOffset(0)]
                    public global::System.IntPtr Declarator;
                }
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, TemplateArgumentLocInfo> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, TemplateArgumentLocInfo>();

            private readonly bool __ownsNativeInstance;

            public static TemplateArgumentLocInfo __CreateInstance(global::System.IntPtr native)
            {
                return new TemplateArgumentLocInfo((TemplateArgumentLocInfo.Internal*) native);
            }

            public static TemplateArgumentLocInfo __CreateInstance(TemplateArgumentLocInfo.Internal native)
            {
                return new TemplateArgumentLocInfo(native);
            }

            private static TemplateArgumentLocInfo.Internal* __CopyValue(TemplateArgumentLocInfo.Internal native)
            {
                var ret = (TemplateArgumentLocInfo.Internal*) Marshal.AllocHGlobal(16);
                *ret = native;
                return ret;
            }

            private TemplateArgumentLocInfo(TemplateArgumentLocInfo.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected TemplateArgumentLocInfo(TemplateArgumentLocInfo.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public TemplateArgumentLocInfo()
            {
                __Instance = Marshal.AllocHGlobal(16);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public TemplateArgumentLocInfo(clang.TypeSourceInfo TInfo)
            {
                __Instance = Marshal.AllocHGlobal(16);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(TInfo, null) ? global::System.IntPtr.Zero : TInfo.__Instance;
                Internal.ctor_1(__Instance, arg0);
            }

            public TemplateArgumentLocInfo(clang.NestedNameSpecifierLoc QualifierLoc, clang.SourceLocation TemplateNameLoc, clang.SourceLocation EllipsisLoc)
            {
                __Instance = Marshal.AllocHGlobal(16);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(QualifierLoc, null) ? new clang.NestedNameSpecifierLoc.Internal() : *(clang.NestedNameSpecifierLoc.Internal*) (QualifierLoc.__Instance);
                var arg1 = ReferenceEquals(TemplateNameLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (TemplateNameLoc.__Instance);
                var arg2 = ReferenceEquals(EllipsisLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (EllipsisLoc.__Instance);
                Internal.ctor_3(__Instance, arg0, arg1, arg2);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.TemplateArgumentLocInfo __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.TypeSourceInfo getAsTypeSourceInfo()
            {
                var __ret = Internal.getAsTypeSourceInfo_0(__Instance);
                clang.TypeSourceInfo __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.TypeSourceInfo.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.TypeSourceInfo) clang.TypeSourceInfo.NativeToManagedMap[__ret];
                else __result0 = clang.TypeSourceInfo.__CreateInstance(__ret);
                return __result0;
            }

            public clang.NestedNameSpecifierLoc getTemplateQualifierLoc()
            {
                var __ret = Internal.getTemplateQualifierLoc_0(__Instance);
                return clang.NestedNameSpecifierLoc.__CreateInstance(__ret);
            }

            public clang.SourceLocation getTemplateNameLoc()
            {
                var __ret = Internal.getTemplateNameLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getTemplateEllipsisLoc()
            {
                var __ret = Internal.getTemplateEllipsisLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }
        }

        /// <summary>
        /// <para>Location wrapper for a TemplateArgument. TemplateArgument is to
        /// TemplateArgumentLoc as Type is to TypeLoc.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// Location wrapper for a TemplateArgument.  TemplateArgument is
        /// to</para>
        /// <para>/// TemplateArgumentLoc as Type is to TypeLoc.</para>
        /// </remarks>
        public unsafe partial class TemplateArgumentLoc : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 36)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public clang.TemplateArgument.Internal Argument;

                [FieldOffset(20)]
                public clang.TemplateArgumentLocInfo.Internal LocInfo;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang19TemplateArgumentLocC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang19TemplateArgumentLocC2ERKNS_16TemplateArgumentENS_23TemplateArgumentLocInfoE")]
                internal static extern void ctor_1(global::System.IntPtr instance, global::System.IntPtr Argument, clang.TemplateArgumentLocInfo.Internal Opaque);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang19TemplateArgumentLocC2ERKNS_16TemplateArgumentEPNS_14TypeSourceInfoE")]
                internal static extern void ctor_2(global::System.IntPtr instance, global::System.IntPtr Argument, global::System.IntPtr TInfo);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang19TemplateArgumentLocC2ERKNS_16TemplateArgumentENS_22NestedNameSpecifierLocENS_14SourceLocationES5_")]
                internal static extern void ctor_4(global::System.IntPtr instance, global::System.IntPtr Argument, clang.NestedNameSpecifierLoc.Internal QualifierLoc, clang.SourceLocation.Internal TemplateNameLoc, clang.SourceLocation.Internal EllipsisLoc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang19TemplateArgumentLocC2ERKS0_")]
                internal static extern void cctor_5(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang19TemplateArgumentLoc11getLocationEv")]
                internal static extern clang.SourceLocation.Internal getLocation_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang19TemplateArgumentLoc14getSourceRangeEv")]
                internal static extern clang.SourceRange.Internal getSourceRange_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang19TemplateArgumentLoc11getArgumentEv")]
                internal static extern global::System.IntPtr getArgument_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang19TemplateArgumentLoc10getLocInfoEv")]
                internal static extern void getLocInfo_0(global::System.IntPtr @return, global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang19TemplateArgumentLoc17getTypeSourceInfoEv")]
                internal static extern global::System.IntPtr getTypeSourceInfo_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang19TemplateArgumentLoc23getTemplateQualifierLocEv")]
                internal static extern clang.NestedNameSpecifierLoc.Internal getTemplateQualifierLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang19TemplateArgumentLoc18getTemplateNameLocEv")]
                internal static extern clang.SourceLocation.Internal getTemplateNameLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang19TemplateArgumentLoc22getTemplateEllipsisLocEv")]
                internal static extern clang.SourceLocation.Internal getTemplateEllipsisLoc_0(global::System.IntPtr instance);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, TemplateArgumentLoc> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, TemplateArgumentLoc>();

            private readonly bool __ownsNativeInstance;

            public static TemplateArgumentLoc __CreateInstance(global::System.IntPtr native)
            {
                return new TemplateArgumentLoc((TemplateArgumentLoc.Internal*) native);
            }

            public static TemplateArgumentLoc __CreateInstance(TemplateArgumentLoc.Internal native)
            {
                return new TemplateArgumentLoc(native);
            }

            private static TemplateArgumentLoc.Internal* __CopyValue(TemplateArgumentLoc.Internal native)
            {
                var ret = (TemplateArgumentLoc.Internal*) Marshal.AllocHGlobal(36);
                *ret = native;
                return ret;
            }

            private TemplateArgumentLoc(TemplateArgumentLoc.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected TemplateArgumentLoc(TemplateArgumentLoc.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public TemplateArgumentLoc()
            {
                __Instance = Marshal.AllocHGlobal(36);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public TemplateArgumentLoc(clang.TemplateArgument Argument, clang.TemplateArgumentLocInfo Opaque)
            {
                __Instance = Marshal.AllocHGlobal(36);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(Argument, null) ? global::System.IntPtr.Zero : Argument.__Instance;
                var arg1 = ReferenceEquals(Opaque, null) ? new clang.TemplateArgumentLocInfo.Internal() : *(clang.TemplateArgumentLocInfo.Internal*) (Opaque.__Instance);
                Internal.ctor_1(__Instance, arg0, arg1);
            }

            public TemplateArgumentLoc(clang.TemplateArgument Argument, clang.TypeSourceInfo TInfo)
            {
                __Instance = Marshal.AllocHGlobal(36);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(Argument, null) ? global::System.IntPtr.Zero : Argument.__Instance;
                var arg1 = ReferenceEquals(TInfo, null) ? global::System.IntPtr.Zero : TInfo.__Instance;
                Internal.ctor_2(__Instance, arg0, arg1);
            }

            public TemplateArgumentLoc(clang.TemplateArgument Argument, clang.NestedNameSpecifierLoc QualifierLoc, clang.SourceLocation TemplateNameLoc, clang.SourceLocation EllipsisLoc)
            {
                __Instance = Marshal.AllocHGlobal(36);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(Argument, null) ? global::System.IntPtr.Zero : Argument.__Instance;
                var arg1 = ReferenceEquals(QualifierLoc, null) ? new clang.NestedNameSpecifierLoc.Internal() : *(clang.NestedNameSpecifierLoc.Internal*) (QualifierLoc.__Instance);
                var arg2 = ReferenceEquals(TemplateNameLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (TemplateNameLoc.__Instance);
                var arg3 = ReferenceEquals(EllipsisLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (EllipsisLoc.__Instance);
                Internal.ctor_4(__Instance, arg0, arg1, arg2, arg3);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.TemplateArgumentLoc __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            /// <summary>
            /// <para>- Fetches the primary location of the argument.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief - Fetches the primary location of the argument.</para>
            /// </remarks>
            public clang.SourceLocation getLocation()
            {
                var __ret = Internal.getLocation_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>- Fetches the full source range of the argument.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief - Fetches the full source range of the
            /// argument.</para>
            /// </remarks>
            public clang.SourceRange getSourceRange()
            {
                var __ret = Internal.getSourceRange_0(__Instance);
                return clang.SourceRange.__CreateInstance(__ret);
            }

            public clang.TemplateArgument getArgument()
            {
                var __ret = Internal.getArgument_0(__Instance);
                clang.TemplateArgument __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.TemplateArgument.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.TemplateArgument) clang.TemplateArgument.NativeToManagedMap[__ret];
                else __result0 = clang.TemplateArgument.__CreateInstance(__ret);
                return __result0;
            }

            public clang.TemplateArgumentLocInfo getLocInfo()
            {
                var __ret = new clang.TemplateArgumentLocInfo.Internal();
                Internal.getLocInfo_0(new IntPtr(&__ret), __Instance);
                return clang.TemplateArgumentLocInfo.__CreateInstance(__ret);
            }

            public clang.TypeSourceInfo getTypeSourceInfo()
            {
                var __ret = Internal.getTypeSourceInfo_0(__Instance);
                clang.TypeSourceInfo __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.TypeSourceInfo.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.TypeSourceInfo) clang.TypeSourceInfo.NativeToManagedMap[__ret];
                else __result0 = clang.TypeSourceInfo.__CreateInstance(__ret);
                return __result0;
            }

            public clang.NestedNameSpecifierLoc getTemplateQualifierLoc()
            {
                var __ret = Internal.getTemplateQualifierLoc_0(__Instance);
                return clang.NestedNameSpecifierLoc.__CreateInstance(__ret);
            }

            public clang.SourceLocation getTemplateNameLoc()
            {
                var __ret = Internal.getTemplateNameLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getTemplateEllipsisLoc()
            {
                var __ret = Internal.getTemplateEllipsisLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }
        }

        /// <summary>
        /// <para>A convenient class for passing around template argument
        /// information. Designed to be passed by reference.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// A convenient class for passing around template
        /// argument</para>
        /// <para>/// information.  Designed to be passed by reference.</para>
        /// </remarks>
        public unsafe partial class TemplateArgumentListInfo : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 308)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                internal llvm.SmallVector.Internal Arguments;

                [FieldOffset(300)]
                public clang.SourceLocation.Internal LAngleLoc;

                [FieldOffset(304)]
                public clang.SourceLocation.Internal RAngleLoc;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang24TemplateArgumentListInfoC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang24TemplateArgumentListInfoC2ENS_14SourceLocationES1_")]
                internal static extern void ctor_1(global::System.IntPtr instance, clang.SourceLocation.Internal LAngleLoc, clang.SourceLocation.Internal RAngleLoc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang24TemplateArgumentListInfoC2ERKS0_")]
                internal static extern void cctor_3(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang24TemplateArgumentListInfoD2Ev")]
                internal static extern void dtor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang24TemplateArgumentListInfo12getLAngleLocEv")]
                internal static extern clang.SourceLocation.Internal getLAngleLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang24TemplateArgumentListInfo12getRAngleLocEv")]
                internal static extern clang.SourceLocation.Internal getRAngleLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang24TemplateArgumentListInfo12setLAngleLocENS_14SourceLocationE")]
                internal static extern void setLAngleLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal Loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang24TemplateArgumentListInfo12setRAngleLocENS_14SourceLocationE")]
                internal static extern void setRAngleLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal Loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang24TemplateArgumentListInfo4sizeEv")]
                internal static extern uint size_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang24TemplateArgumentListInfo16getArgumentArrayEv")]
                internal static extern global::System.IntPtr getArgumentArray_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang24TemplateArgumentListInfo11addArgumentERKNS_19TemplateArgumentLocE")]
                internal static extern void addArgument_0(global::System.IntPtr instance, global::System.IntPtr Loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang24TemplateArgumentListInfoixEj")]
                internal static extern global::System.IntPtr OperatorSubscript_1(global::System.IntPtr instance, uint I);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, TemplateArgumentListInfo> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, TemplateArgumentListInfo>();

            private readonly bool __ownsNativeInstance;

            public static TemplateArgumentListInfo __CreateInstance(global::System.IntPtr native)
            {
                return new TemplateArgumentListInfo((TemplateArgumentListInfo.Internal*) native);
            }

            public static TemplateArgumentListInfo __CreateInstance(TemplateArgumentListInfo.Internal native)
            {
                return new TemplateArgumentListInfo(native);
            }

            private static TemplateArgumentListInfo.Internal* __CopyValue(TemplateArgumentListInfo.Internal native)
            {
                var ret = (TemplateArgumentListInfo.Internal*) Marshal.AllocHGlobal(308);
                *ret = native;
                return ret;
            }

            private TemplateArgumentListInfo(TemplateArgumentListInfo.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected TemplateArgumentListInfo(TemplateArgumentListInfo.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public TemplateArgumentListInfo()
            {
                __Instance = Marshal.AllocHGlobal(308);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public TemplateArgumentListInfo(clang.SourceLocation LAngleLoc, clang.SourceLocation RAngleLoc)
            {
                __Instance = Marshal.AllocHGlobal(308);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(LAngleLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (LAngleLoc.__Instance);
                var arg1 = ReferenceEquals(RAngleLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (RAngleLoc.__Instance);
                Internal.ctor_1(__Instance, arg0, arg1);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.TemplateArgumentListInfo __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance || force)
                    Internal.dtor_0(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.SourceLocation getLAngleLoc()
            {
                var __ret = Internal.getLAngleLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getRAngleLoc()
            {
                var __ret = Internal.getRAngleLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setLAngleLoc(clang.SourceLocation Loc)
            {
                var arg0 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                Internal.setLAngleLoc_0(__Instance, arg0);
            }

            public void setRAngleLoc(clang.SourceLocation Loc)
            {
                var arg0 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                Internal.setRAngleLoc_0(__Instance, arg0);
            }

            public uint size()
            {
                var __ret = Internal.size_0(__Instance);
                return __ret;
            }

            public clang.TemplateArgumentLoc getArgumentArray()
            {
                var __ret = Internal.getArgumentArray_0(__Instance);
                clang.TemplateArgumentLoc __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.TemplateArgumentLoc.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.TemplateArgumentLoc) clang.TemplateArgumentLoc.NativeToManagedMap[__ret];
                else __result0 = clang.TemplateArgumentLoc.__CreateInstance(__ret);
                return __result0;
            }

            public void addArgument(clang.TemplateArgumentLoc Loc)
            {
                var arg0 = ReferenceEquals(Loc, null) ? global::System.IntPtr.Zero : Loc.__Instance;
                Internal.addArgument_0(__Instance, arg0);
            }

            public clang.TemplateArgumentLoc this[uint I]
            {
                get
                {
                    var __ret = Internal.OperatorSubscript_1(__Instance, I);
                    clang.TemplateArgumentLoc __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (clang.TemplateArgumentLoc.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (clang.TemplateArgumentLoc) clang.TemplateArgumentLoc.NativeToManagedMap[__ret];
                    else __result0 = clang.TemplateArgumentLoc.__CreateInstance(__ret);
                    return __result0;
                }

                set
                {
                    *(clang.TemplateArgumentLoc.Internal*) Internal.OperatorSubscript_1(__Instance, I) = *(clang.TemplateArgumentLoc.Internal*) value.__Instance;
                }
            }
        }

        /// <summary>
        /// <para>Represents an explicit template argument list in C++, e.g., the
        /// &quot;&lt;int&gt;&quot; in &quot;sort&lt;int&gt;&quot;. This is safe to be
        /// used inside an AST node, in contrast with TemplateArgumentListInfo.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief Represents an explicit template argument list in C++,
        /// e.g.,</para>
        /// <para>/// the &quot;&lt;int&gt;&quot; in
        /// &quot;sort&lt;int&gt;&quot;.</para>
        /// <para>/// This is safe to be used inside an AST node, in contrast
        /// with</para>
        /// <para>/// TemplateArgumentListInfo.</para>
        /// </remarks>
        public unsafe partial class ASTTemplateArgumentListInfo : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 12)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public clang.SourceLocation.Internal LAngleLoc;

                [FieldOffset(4)]
                public clang.SourceLocation.Internal RAngleLoc;

                [FieldOffset(8)]
                internal clang.ASTTemplateArgumentListInfo._.Internal __;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang27ASTTemplateArgumentListInfoC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang27ASTTemplateArgumentListInfoC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang27ASTTemplateArgumentListInfo15getTemplateArgsEv")]
                internal static extern global::System.IntPtr getTemplateArgs_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang27ASTTemplateArgumentListInfo6CreateERNS_10ASTContextERKNS_24TemplateArgumentListInfoE")]
                internal static extern global::System.IntPtr Create_0(global::System.IntPtr C, global::System.IntPtr List);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang27ASTTemplateArgumentListInfo14initializeFromERKNS_24TemplateArgumentListInfoE")]
                internal static extern void initializeFrom_0(global::System.IntPtr instance, global::System.IntPtr List);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang27ASTTemplateArgumentListInfo14initializeFromERKNS_24TemplateArgumentListInfoERbS4_S4_")]
                internal static extern void initializeFrom_1(global::System.IntPtr instance, global::System.IntPtr List, bool* Dependent, bool* InstantiationDependent, bool* ContainsUnexpandedParameterPack);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang27ASTTemplateArgumentListInfo8copyIntoERNS_24TemplateArgumentListInfoE")]
                internal static extern void copyInto_0(global::System.IntPtr instance, global::System.IntPtr List);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang27ASTTemplateArgumentListInfo7sizeForEj")]
                internal static extern uint sizeFor_0(uint NumTemplateArgs);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang27ASTTemplateArgumentListInfoixEj")]
                internal static extern global::System.IntPtr OperatorSubscript_0(global::System.IntPtr instance, uint I);
            }

            public unsafe partial struct _
            {
                [StructLayout(LayoutKind.Explicit, Size = 4)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public uint NumTemplateArgs;

                    [FieldOffset(0)]
                    internal llvm.AlignedCharArray.Internal Aligner;
                }
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ASTTemplateArgumentListInfo> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ASTTemplateArgumentListInfo>();

            private readonly bool __ownsNativeInstance;

            public static ASTTemplateArgumentListInfo __CreateInstance(global::System.IntPtr native)
            {
                return new ASTTemplateArgumentListInfo((ASTTemplateArgumentListInfo.Internal*) native);
            }

            public static ASTTemplateArgumentListInfo __CreateInstance(ASTTemplateArgumentListInfo.Internal native)
            {
                return new ASTTemplateArgumentListInfo(native);
            }

            private static ASTTemplateArgumentListInfo.Internal* __CopyValue(ASTTemplateArgumentListInfo.Internal native)
            {
                var ret = (ASTTemplateArgumentListInfo.Internal*) Marshal.AllocHGlobal(12);
                *ret = native;
                return ret;
            }

            private ASTTemplateArgumentListInfo(ASTTemplateArgumentListInfo.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected ASTTemplateArgumentListInfo(ASTTemplateArgumentListInfo.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public ASTTemplateArgumentListInfo()
            {
                __Instance = Marshal.AllocHGlobal(12);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.ASTTemplateArgumentListInfo __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            /// <summary>
            /// <para>Retrieve the template arguments</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the template arguments</para>
            /// </remarks>
            public clang.TemplateArgumentLoc getTemplateArgs()
            {
                var __ret = Internal.getTemplateArgs_0(__Instance);
                clang.TemplateArgumentLoc __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.TemplateArgumentLoc.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.TemplateArgumentLoc) clang.TemplateArgumentLoc.NativeToManagedMap[__ret];
                else __result0 = clang.TemplateArgumentLoc.__CreateInstance(__ret);
                return __result0;
            }

            public void initializeFrom(clang.TemplateArgumentListInfo List)
            {
                var arg0 = ReferenceEquals(List, null) ? global::System.IntPtr.Zero : List.__Instance;
                Internal.initializeFrom_0(__Instance, arg0);
            }

            public void initializeFrom(clang.TemplateArgumentListInfo List, ref bool Dependent, ref bool InstantiationDependent, ref bool ContainsUnexpandedParameterPack)
            {
                var arg0 = ReferenceEquals(List, null) ? global::System.IntPtr.Zero : List.__Instance;
                fixed (bool* arg1 = &Dependent)
                {
                    fixed (bool* arg2 = &InstantiationDependent)
                    {
                        fixed (bool* arg3 = &ContainsUnexpandedParameterPack)
                        {
                            Internal.initializeFrom_1(__Instance, arg0, arg1, arg2, arg3);
                        }
                    }
                }
            }

            public void copyInto(clang.TemplateArgumentListInfo List)
            {
                var arg0 = ReferenceEquals(List, null) ? global::System.IntPtr.Zero : List.__Instance;
                Internal.copyInto_0(__Instance, arg0);
            }

            public static clang.ASTTemplateArgumentListInfo Create(clang.ASTContext C, clang.TemplateArgumentListInfo List)
            {
                var arg0 = ReferenceEquals(C, null) ? global::System.IntPtr.Zero : C.__Instance;
                var arg1 = ReferenceEquals(List, null) ? global::System.IntPtr.Zero : List.__Instance;
                var __ret = Internal.Create_0(arg0, arg1);
                clang.ASTTemplateArgumentListInfo __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.ASTTemplateArgumentListInfo.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.ASTTemplateArgumentListInfo) clang.ASTTemplateArgumentListInfo.NativeToManagedMap[__ret];
                else __result0 = clang.ASTTemplateArgumentListInfo.__CreateInstance(__ret);
                return __result0;
            }

            public static uint sizeFor(uint NumTemplateArgs)
            {
                var __ret = Internal.sizeFor_0(NumTemplateArgs);
                return __ret;
            }

            public clang.TemplateArgumentLoc this[uint I]
            {
                get
                {
                    var __ret = Internal.OperatorSubscript_0(__Instance, I);
                    clang.TemplateArgumentLoc __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (clang.TemplateArgumentLoc.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (clang.TemplateArgumentLoc) clang.TemplateArgumentLoc.NativeToManagedMap[__ret];
                    else __result0 = clang.TemplateArgumentLoc.__CreateInstance(__ret);
                    return __result0;
                }
            }

            public clang.SourceLocation LAngleLoc
            {
                get
                {
                    return clang.SourceLocation.__CreateInstance(((Internal*) __Instance)->LAngleLoc);
                }

                set
                {
                    ((Internal*) __Instance)->LAngleLoc = ReferenceEquals(value, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (value.__Instance);
                }
            }

            public clang.SourceLocation RAngleLoc
            {
                get
                {
                    return clang.SourceLocation.__CreateInstance(((Internal*) __Instance)->RAngleLoc);
                }

                set
                {
                    ((Internal*) __Instance)->RAngleLoc = ReferenceEquals(value, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (value.__Instance);
                }
            }
        }

        /// <summary>
        /// <para>Extends ASTTemplateArgumentListInfo with the source location
        /// information for the template keyword; this is used as part of the
        /// representation of qualified identifiers, such as S&lt;T&gt;::template
        /// apply&lt;T&gt;.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief Extends ASTTemplateArgumentListInfo with the source
        /// location</para>
        /// <para>/// information for the template keyword; this is used as part of
        /// the</para>
        /// <para>/// representation of qualified identifiers, such as
        /// S&lt;T&gt;::template apply&lt;T&gt;.</para>
        /// </remarks>
        public unsafe partial class ASTTemplateKWAndArgsInfo : clang.ASTTemplateArgumentListInfo, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 12)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                public clang.SourceLocation.Internal LAngleLoc;

                [FieldOffset(4)]
                public clang.SourceLocation.Internal RAngleLoc;

                [FieldOffset(8)]
                internal clang.ASTTemplateArgumentListInfo._.Internal __;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang24ASTTemplateKWAndArgsInfoC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang24ASTTemplateKWAndArgsInfoC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang24ASTTemplateKWAndArgsInfo21getTemplateKeywordLocEv")]
                internal static extern clang.SourceLocation.Internal getTemplateKeywordLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang24ASTTemplateKWAndArgsInfo21setTemplateKeywordLocENS_14SourceLocationE")]
                internal static extern void setTemplateKeywordLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal TemplateKWLoc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang24ASTTemplateKWAndArgsInfo6CreateERNS_10ASTContextENS_14SourceLocationERKNS_24TemplateArgumentListInfoE")]
                internal static extern global::System.IntPtr Create_0(global::System.IntPtr C, clang.SourceLocation.Internal TemplateKWLoc, global::System.IntPtr List);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang24ASTTemplateKWAndArgsInfo14initializeFromENS_14SourceLocationERKNS_24TemplateArgumentListInfoE")]
                internal static extern void initializeFrom_0(global::System.IntPtr instance, clang.SourceLocation.Internal TemplateKWLoc, global::System.IntPtr List);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang24ASTTemplateKWAndArgsInfo14initializeFromENS_14SourceLocationERKNS_24TemplateArgumentListInfoERbS5_S5_")]
                internal static extern void initializeFrom_1(global::System.IntPtr instance, clang.SourceLocation.Internal TemplateKWLoc, global::System.IntPtr List, bool* Dependent, bool* InstantiationDependent, bool* ContainsUnexpandedParameterPack);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang24ASTTemplateKWAndArgsInfo14initializeFromENS_14SourceLocationE")]
                internal static extern void initializeFrom_2(global::System.IntPtr instance, clang.SourceLocation.Internal TemplateKWLoc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang24ASTTemplateKWAndArgsInfo7sizeForEj")]
                internal static extern uint sizeFor_0(uint NumTemplateArgs);
            }

            private readonly bool __ownsNativeInstance;

            public static new ASTTemplateKWAndArgsInfo __CreateInstance(global::System.IntPtr native)
            {
                return new ASTTemplateKWAndArgsInfo((ASTTemplateKWAndArgsInfo.Internal*) native);
            }

            public static ASTTemplateKWAndArgsInfo __CreateInstance(ASTTemplateKWAndArgsInfo.Internal native)
            {
                return new ASTTemplateKWAndArgsInfo(native);
            }

            private static ASTTemplateKWAndArgsInfo.Internal* __CopyValue(ASTTemplateKWAndArgsInfo.Internal native)
            {
                var ret = (ASTTemplateKWAndArgsInfo.Internal*) Marshal.AllocHGlobal(12);
                *ret = native;
                return ret;
            }

            private ASTTemplateKWAndArgsInfo(ASTTemplateKWAndArgsInfo.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected ASTTemplateKWAndArgsInfo(ASTTemplateKWAndArgsInfo.Internal* native, bool isInternalImpl = false)
                : base((clang.ASTTemplateArgumentListInfo.Internal*) native)
            {
            }

            public ASTTemplateKWAndArgsInfo()
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(12);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.ASTTemplateArgumentListInfo __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            /// <summary>
            /// <para>Get the source location of the template keyword.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Get the source location of the template
            /// keyword.</para>
            /// </remarks>
            public clang.SourceLocation getTemplateKeywordLoc()
            {
                var __ret = Internal.getTemplateKeywordLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Sets the source location of the template keyword.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Sets the source location of the template
            /// keyword.</para>
            /// </remarks>
            public void setTemplateKeywordLoc(clang.SourceLocation TemplateKWLoc)
            {
                var arg0 = ReferenceEquals(TemplateKWLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (TemplateKWLoc.__Instance);
                Internal.setTemplateKeywordLoc_0(__Instance, arg0);
            }

            public void initializeFrom(clang.SourceLocation TemplateKWLoc, clang.TemplateArgumentListInfo List)
            {
                var arg0 = ReferenceEquals(TemplateKWLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (TemplateKWLoc.__Instance);
                var arg1 = ReferenceEquals(List, null) ? global::System.IntPtr.Zero : List.__Instance;
                Internal.initializeFrom_0(__Instance, arg0, arg1);
            }

            public void initializeFrom(clang.SourceLocation TemplateKWLoc, clang.TemplateArgumentListInfo List, ref bool Dependent, ref bool InstantiationDependent, ref bool ContainsUnexpandedParameterPack)
            {
                var arg0 = ReferenceEquals(TemplateKWLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (TemplateKWLoc.__Instance);
                var arg1 = ReferenceEquals(List, null) ? global::System.IntPtr.Zero : List.__Instance;
                fixed (bool* arg2 = &Dependent)
                {
                    fixed (bool* arg3 = &InstantiationDependent)
                    {
                        fixed (bool* arg4 = &ContainsUnexpandedParameterPack)
                        {
                            Internal.initializeFrom_1(__Instance, arg0, arg1, arg2, arg3, arg4);
                        }
                    }
                }
            }

            public void initializeFrom(clang.SourceLocation TemplateKWLoc)
            {
                var arg0 = ReferenceEquals(TemplateKWLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (TemplateKWLoc.__Instance);
                Internal.initializeFrom_2(__Instance, arg0);
            }

            public static clang.ASTTemplateKWAndArgsInfo Create(clang.ASTContext C, clang.SourceLocation TemplateKWLoc, clang.TemplateArgumentListInfo List)
            {
                var arg0 = ReferenceEquals(C, null) ? global::System.IntPtr.Zero : C.__Instance;
                var arg1 = ReferenceEquals(TemplateKWLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (TemplateKWLoc.__Instance);
                var arg2 = ReferenceEquals(List, null) ? global::System.IntPtr.Zero : List.__Instance;
                var __ret = Internal.Create_0(arg0, arg1, arg2);
                clang.ASTTemplateKWAndArgsInfo __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.ASTTemplateKWAndArgsInfo.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.ASTTemplateKWAndArgsInfo) clang.ASTTemplateKWAndArgsInfo.NativeToManagedMap[__ret];
                else __result0 = clang.ASTTemplateKWAndArgsInfo.__CreateInstance(__ret);
                return __result0;
            }

            public static uint sizeFor(uint NumTemplateArgs)
            {
                var __ret = Internal.sizeFor_0(NumTemplateArgs);
                return __ret;
            }
        }
    }

    namespace llvm
    {
    }
}
