//----------------------------------------------------------------------------
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
//----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace CppSharp
{
    public unsafe partial class FileSystem
    {
        public partial struct Internal
        {
        }
    }

    namespace llvm
    {
        public unsafe partial class FileSystem
        {
            public partial struct Internal
            {
            }
        }

        namespace sys
        {
            public unsafe partial class FileSystem
            {
                public partial struct Internal
                {
                }
            }

            namespace fs
            {
                /// <summary>
                /// <para>An enumeration for the file system's view of the type.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// An enumeration for the file system's view of the type.</para>
                /// </remarks>
                public enum file_type
                {
                    status_error = 0,
                    file_not_found = 1,
                    regular_file = 2,
                    directory_file = 3,
                    symlink_file = 4,
                    block_file = 5,
                    character_file = 6,
                    fifo_file = 7,
                    socket_file = 8,
                    type_unknown = 9
                }

                public enum perms : uint
                {
                    no_perms = 0,
                    owner_read = 256,
                    owner_write = 128,
                    owner_exe = 64,
                    owner_all = 448,
                    group_read = 32,
                    group_write = 16,
                    group_exe = 8,
                    group_all = 56,
                    others_read = 4,
                    others_write = 2,
                    others_exe = 1,
                    others_all = 7,
                    all_read = 292,
                    all_write = 146,
                    all_exe = 73,
                    all_all = 511,
                    set_uid_on_exe = 2048,
                    set_gid_on_exe = 1024,
                    sticky_bit = 512,
                    perms_not_known = 0xffff
                }

                [Flags]
                public enum OpenFlags : uint
                {
                    F_None = 0,
                    /// <summary>F_Excl - When opening a file, this flag makes raw_fd_ostream report an error if the file already exists.</summary>
                    F_Excl = 1,
                    /// <summary>F_Append - When opening a file, if it already exists append to the existing file instead of returning an error. This may not be specified with F_Excl.</summary>
                    F_Append = 2,
                    /// <summary>The file should be opened in text mode on platforms that make this distinction.</summary>
                    F_Text = 4,
                    /// <summary>Open the file for read and write.</summary>
                    F_RW = 8
                }

                public enum AccessMode
                {
                    Exist = 0,
                    Write = 1,
                    Execute = 2
                }

                /// <summary>
                /// <para>space_info - Self explanatory.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// space_info - Self explanatory.</para>
                /// </remarks>
                public unsafe partial class space_info : IDisposable
                {
                    [StructLayout(LayoutKind.Explicit, Size = 24)]
                    public partial struct Internal
                    {
                        [FieldOffset(0)]
                        public ulong capacity;

                        [FieldOffset(8)]
                        public ulong free;

                        [FieldOffset(16)]
                        public ulong available;

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZN4llvm3sys2fs10space_infoC2ERKS2_")]
                        internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
                    }

                    public global::System.IntPtr __Instance { get; protected set; }
                    public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, space_info> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, space_info>();

                    private readonly bool __ownsNativeInstance;

                    public static space_info __CreateInstance(global::System.IntPtr native)
                    {
                        return new space_info((space_info.Internal*) native);
                    }

                    public static space_info __CreateInstance(space_info.Internal native)
                    {
                        return new space_info(native);
                    }

                    private static space_info.Internal* __CopyValue(space_info.Internal native)
                    {
                        var ret = (space_info.Internal*) Marshal.AllocHGlobal(24);
                        *ret = native;
                        return ret;
                    }

                    private space_info(space_info.Internal native)
                        : this(__CopyValue(native))
                    {
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                    }

                    protected space_info(space_info.Internal* native, bool isInternalImpl = false)
                    {
                        __Instance = new global::System.IntPtr(native);
                    }

                    public space_info()
                    {
                        __Instance = Marshal.AllocHGlobal(24);
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                    }

                    public void Dispose()
                    {
                        Dispose(disposing: true);
                    }

                    protected virtual void Dispose(bool disposing)
                    {
                        DestroyNativeInstance(false);
                    }

                    public virtual void DestroyNativeInstance()
                    {
                        DestroyNativeInstance(true);
                    }

                    private void DestroyNativeInstance(bool force)
                    {
                        llvm.sys.fs.space_info __dummy;
                        NativeToManagedMap.TryRemove(__Instance, out __dummy);
                        if (__ownsNativeInstance)
                            Marshal.FreeHGlobal(__Instance);
                    }

                    public ulong capacity
                    {
                        get
                        {
                            return ((Internal*) __Instance)->capacity;
                        }

                        set
                        {
                            ((Internal*) __Instance)->capacity = value;
                        }
                    }

                    public ulong free
                    {
                        get
                        {
                            return ((Internal*) __Instance)->free;
                        }

                        set
                        {
                            ((Internal*) __Instance)->free = value;
                        }
                    }

                    public ulong available
                    {
                        get
                        {
                            return ((Internal*) __Instance)->available;
                        }

                        set
                        {
                            ((Internal*) __Instance)->available = value;
                        }
                    }
                }

                public unsafe partial class UniqueID : IDisposable
                {
                    [StructLayout(LayoutKind.Explicit, Size = 16)]
                    public partial struct Internal
                    {
                        [FieldOffset(0)]
                        public ulong Device;

                        [FieldOffset(8)]
                        public ulong File;

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZN4llvm3sys2fs8UniqueIDC2Ev")]
                        internal static extern void ctor_0(global::System.IntPtr instance);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZN4llvm3sys2fs8UniqueIDC2Eyy")]
                        internal static extern void ctor_1(global::System.IntPtr instance, ulong Device, ulong File);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZN4llvm3sys2fs8UniqueIDC2ERKS2_")]
                        internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZNK4llvm3sys2fs8UniqueIDeqERKS2_")]
                        [return: MarshalAsAttribute(UnmanagedType.I1)]
                        internal static extern bool OperatorEqualEqual_0(global::System.IntPtr instance, global::System.IntPtr Other);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZNK4llvm3sys2fs8UniqueIDneERKS2_")]
                        [return: MarshalAsAttribute(UnmanagedType.I1)]
                        internal static extern bool OperatorExclaimEqual_0(global::System.IntPtr instance, global::System.IntPtr Other);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZNK4llvm3sys2fs8UniqueIDltERKS2_")]
                        [return: MarshalAsAttribute(UnmanagedType.I1)]
                        internal static extern bool OperatorLess_0(global::System.IntPtr instance, global::System.IntPtr Other);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZNK4llvm3sys2fs8UniqueID9getDeviceEv")]
                        internal static extern ulong getDevice_0(global::System.IntPtr instance);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZNK4llvm3sys2fs8UniqueID7getFileEv")]
                        internal static extern ulong getFile_0(global::System.IntPtr instance);
                    }

                    public global::System.IntPtr __Instance { get; protected set; }
                    public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, UniqueID> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, UniqueID>();

                    private readonly bool __ownsNativeInstance;

                    public static UniqueID __CreateInstance(global::System.IntPtr native)
                    {
                        return new UniqueID((UniqueID.Internal*) native);
                    }

                    public static UniqueID __CreateInstance(UniqueID.Internal native)
                    {
                        return new UniqueID(native);
                    }

                    private static UniqueID.Internal* __CopyValue(UniqueID.Internal native)
                    {
                        var ret = (UniqueID.Internal*) Marshal.AllocHGlobal(16);
                        *ret = native;
                        return ret;
                    }

                    private UniqueID(UniqueID.Internal native)
                        : this(__CopyValue(native))
                    {
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                    }

                    protected UniqueID(UniqueID.Internal* native, bool isInternalImpl = false)
                    {
                        __Instance = new global::System.IntPtr(native);
                    }

                    public UniqueID()
                    {
                        __Instance = Marshal.AllocHGlobal(16);
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                        Internal.ctor_0(__Instance);
                    }

                    public UniqueID(ulong Device, ulong File)
                    {
                        __Instance = Marshal.AllocHGlobal(16);
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                        var arg0 = Device;
                        var arg1 = File;
                        Internal.ctor_1(__Instance, arg0, arg1);
                    }

                    public void Dispose()
                    {
                        Dispose(disposing: true);
                    }

                    protected virtual void Dispose(bool disposing)
                    {
                        DestroyNativeInstance(false);
                    }

                    public virtual void DestroyNativeInstance()
                    {
                        DestroyNativeInstance(true);
                    }

                    private void DestroyNativeInstance(bool force)
                    {
                        llvm.sys.fs.UniqueID __dummy;
                        NativeToManagedMap.TryRemove(__Instance, out __dummy);
                        if (__ownsNativeInstance)
                            Marshal.FreeHGlobal(__Instance);
                    }

                    public static bool operator ==(llvm.sys.fs.UniqueID __op, llvm.sys.fs.UniqueID Other)
                    {
                        bool __opNull = ReferenceEquals(__op, null);
                        bool OtherNull = ReferenceEquals(Other, null);
                        if (__opNull || OtherNull)
                            return __opNull && OtherNull;
                        var arg0 = __op.__Instance;
                        var arg1 = Other.__Instance;
                        var __ret = Internal.OperatorEqualEqual_0(arg0, arg1);
                        return __ret;
                    }

                    public override bool Equals(object obj)
                    {
                        return this == obj as UniqueID;
                    }

                    public static bool operator !=(llvm.sys.fs.UniqueID __op, llvm.sys.fs.UniqueID Other)
                    {
                        var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
                        var arg1 = ReferenceEquals(Other, null) ? global::System.IntPtr.Zero : Other.__Instance;
                        var __ret = Internal.OperatorExclaimEqual_0(arg0, arg1);
                        return __ret;
                    }

                    public static bool operator >(llvm.sys.fs.UniqueID __op, llvm.sys.fs.UniqueID Other)
                    {
                        return !(__op < Other);
                    }

                    public static bool operator <(llvm.sys.fs.UniqueID __op, llvm.sys.fs.UniqueID Other)
                    {
                        var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
                        var arg1 = ReferenceEquals(Other, null) ? global::System.IntPtr.Zero : Other.__Instance;
                        var __ret = Internal.OperatorLess_0(arg0, arg1);
                        return __ret;
                    }

                    public ulong getDevice()
                    {
                        var __ret = Internal.getDevice_0(__Instance);
                        return __ret;
                    }

                    public ulong getFile()
                    {
                        var __ret = Internal.getFile_0(__Instance);
                        return __ret;
                    }
                }

                /// <summary>
                /// <para>file_status - Represents the result of a call to stat and
                /// friends. It has a platform-specific member to store the result.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// file_status - Represents the result of a call to stat and
                /// friends. It has</para>
                /// <para>///               a platform-specific member to store the
                /// result.</para>
                /// </remarks>
                public unsafe partial class file_status : IDisposable
                {
                    [StructLayout(LayoutKind.Explicit, Size = 40)]
                    public partial struct Internal
                    {
                        [FieldOffset(0)]
                        public int fs_st_dev;

                        [FieldOffset(4)]
                        public ulong fs_st_ino;

                        [FieldOffset(12)]
                        public int fs_st_mtime;

                        [FieldOffset(16)]
                        public uint fs_st_uid;

                        [FieldOffset(20)]
                        public uint fs_st_gid;

                        [FieldOffset(24)]
                        public long fs_st_size;

                        [FieldOffset(32)]
                        public llvm.sys.fs.file_type Type;

                        [FieldOffset(36)]
                        public llvm.sys.fs.perms Perms;

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZN4llvm3sys2fs11file_statusC2Ev")]
                        internal static extern void ctor_0(global::System.IntPtr instance);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZN4llvm3sys2fs11file_statusC2ENS1_9file_typeE")]
                        internal static extern void ctor_1(global::System.IntPtr instance, llvm.sys.fs.file_type Type);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZN4llvm3sys2fs11file_statusC2ENS1_9file_typeENS1_5permsEiyljjx")]
                        internal static extern void ctor_2(global::System.IntPtr instance, llvm.sys.fs.file_type Type, llvm.sys.fs.perms Perms, int Dev, ulong Ino, int MTime, uint UID, uint GID, long Size);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZN4llvm3sys2fs11file_statusC2ERKS2_")]
                        internal static extern void cctor_3(global::System.IntPtr instance, global::System.IntPtr _0);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZNK4llvm3sys2fs11file_status4typeEv")]
                        internal static extern llvm.sys.fs.file_type type_0(global::System.IntPtr instance);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZNK4llvm3sys2fs11file_status11permissionsEv")]
                        internal static extern llvm.sys.fs.perms permissions_0(global::System.IntPtr instance);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZNK4llvm3sys2fs11file_status23getLastModificationTimeEv")]
                        internal static extern void getLastModificationTime_0(global::System.IntPtr @return, global::System.IntPtr instance);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZNK4llvm3sys2fs11file_status11getUniqueIDEv")]
                        internal static extern void getUniqueID_0(global::System.IntPtr @return, global::System.IntPtr instance);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZNK4llvm3sys2fs11file_status7getUserEv")]
                        internal static extern uint getUser_0(global::System.IntPtr instance);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZNK4llvm3sys2fs11file_status8getGroupEv")]
                        internal static extern uint getGroup_0(global::System.IntPtr instance);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZNK4llvm3sys2fs11file_status7getSizeEv")]
                        internal static extern ulong getSize_0(global::System.IntPtr instance);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZN4llvm3sys2fs11file_status4typeENS1_9file_typeE")]
                        internal static extern void type_1(global::System.IntPtr instance, llvm.sys.fs.file_type v);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZN4llvm3sys2fs11file_status11permissionsENS1_5permsE")]
                        internal static extern void permissions_1(global::System.IntPtr instance, llvm.sys.fs.perms p);
                    }

                    public global::System.IntPtr __Instance { get; protected set; }
                    public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, file_status> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, file_status>();

                    private readonly bool __ownsNativeInstance;

                    public static file_status __CreateInstance(global::System.IntPtr native)
                    {
                        return new file_status((file_status.Internal*) native);
                    }

                    public static file_status __CreateInstance(file_status.Internal native)
                    {
                        return new file_status(native);
                    }

                    private static file_status.Internal* __CopyValue(file_status.Internal native)
                    {
                        var ret = (file_status.Internal*) Marshal.AllocHGlobal(40);
                        *ret = native;
                        return ret;
                    }

                    private file_status(file_status.Internal native)
                        : this(__CopyValue(native))
                    {
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                    }

                    protected file_status(file_status.Internal* native, bool isInternalImpl = false)
                    {
                        __Instance = new global::System.IntPtr(native);
                    }

                    public file_status()
                    {
                        __Instance = Marshal.AllocHGlobal(40);
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                        Internal.ctor_0(__Instance);
                    }

                    public file_status(llvm.sys.fs.file_type Type)
                    {
                        __Instance = Marshal.AllocHGlobal(40);
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                        var arg0 = Type;
                        Internal.ctor_1(__Instance, arg0);
                    }

                    public file_status(llvm.sys.fs.file_type Type, llvm.sys.fs.perms Perms, int Dev, ulong Ino, int MTime, uint UID, uint GID, long Size)
                    {
                        __Instance = Marshal.AllocHGlobal(40);
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                        var arg0 = Type;
                        var arg1 = Perms;
                        var arg2 = Dev;
                        var arg3 = Ino;
                        var arg4 = MTime;
                        var arg5 = UID;
                        var arg6 = GID;
                        var arg7 = Size;
                        Internal.ctor_2(__Instance, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
                    }

                    public void Dispose()
                    {
                        Dispose(disposing: true);
                    }

                    protected virtual void Dispose(bool disposing)
                    {
                        DestroyNativeInstance(false);
                    }

                    public virtual void DestroyNativeInstance()
                    {
                        DestroyNativeInstance(true);
                    }

                    private void DestroyNativeInstance(bool force)
                    {
                        llvm.sys.fs.file_status __dummy;
                        NativeToManagedMap.TryRemove(__Instance, out __dummy);
                        if (__ownsNativeInstance)
                            Marshal.FreeHGlobal(__Instance);
                    }

                    public llvm.sys.fs.file_type type()
                    {
                        var __ret = Internal.type_0(__Instance);
                        return __ret;
                    }

                    public llvm.sys.fs.perms permissions()
                    {
                        var __ret = Internal.permissions_0(__Instance);
                        return __ret;
                    }

                    public llvm.sys.TimeValue getLastModificationTime()
                    {
                        var __ret = new llvm.sys.TimeValue.Internal();
                        Internal.getLastModificationTime_0(new IntPtr(&__ret), __Instance);
                        return llvm.sys.TimeValue.__CreateInstance(__ret);
                    }

                    public llvm.sys.fs.UniqueID getUniqueID()
                    {
                        var __ret = new llvm.sys.fs.UniqueID.Internal();
                        Internal.getUniqueID_0(new IntPtr(&__ret), __Instance);
                        return llvm.sys.fs.UniqueID.__CreateInstance(__ret);
                    }

                    public uint getUser()
                    {
                        var __ret = Internal.getUser_0(__Instance);
                        return __ret;
                    }

                    public uint getGroup()
                    {
                        var __ret = Internal.getGroup_0(__Instance);
                        return __ret;
                    }

                    public ulong getSize()
                    {
                        var __ret = Internal.getSize_0(__Instance);
                        return __ret;
                    }

                    public void type(llvm.sys.fs.file_type v)
                    {
                        var arg0 = v;
                        Internal.type_1(__Instance, arg0);
                    }

                    public void permissions(llvm.sys.fs.perms p)
                    {
                        var arg0 = p;
                        Internal.permissions_1(__Instance, arg0);
                    }
                }

                /// <summary>
                /// <para>file_magic - An &quot;enum class&quot; enumeration of file types
                /// based on magic (the first N bytes of the file).</para>
                /// </summary>
                /// <remarks>
                /// <para>/// file_magic - An &quot;enum class&quot; enumeration of file
                /// types based on magic (the first</para>
                /// <para>///         N bytes of the file).</para>
                /// </remarks>
                public unsafe partial class file_magic : IDisposable
                {
                    [StructLayout(LayoutKind.Explicit, Size = 4)]
                    public partial struct Internal
                    {
                        [FieldOffset(0)]
                        public llvm.sys.fs.file_magic.Impl V;

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZN4llvm3sys2fs10file_magicC2Ev")]
                        internal static extern void ctor_0(global::System.IntPtr instance);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZN4llvm3sys2fs10file_magicC2ENS2_4ImplE")]
                        internal static extern void ctor_1(global::System.IntPtr instance, llvm.sys.fs.file_magic.Impl V);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZN4llvm3sys2fs10file_magicC2ERKS2_")]
                        internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZNK4llvm3sys2fs10file_magic9is_objectEv")]
                        [return: MarshalAsAttribute(UnmanagedType.I1)]
                        internal static extern bool is_object_0(global::System.IntPtr instance);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZNK4llvm3sys2fs10file_magiccvNS2_4ImplEEv")]
                        internal static extern llvm.sys.fs.file_magic.Impl OperatorConversion_0(global::System.IntPtr instance);
                    }

                    public enum Impl : uint
                    {
                        /// <summary>Unrecognized file</summary>
                        unknown = 0,
                        /// <summary>Bitcode file</summary>
                        bitcode = 1,
                        /// <summary>ar style archive file</summary>
                        archive = 2,
                        /// <summary>ELF Unknown type</summary>
                        elf = 3,
                        /// <summary>ELF Relocatable object file</summary>
                        elf_relocatable = 4,
                        /// <summary>ELF Executable image</summary>
                        elf_executable = 5,
                        /// <summary>ELF dynamically linked shared lib</summary>
                        elf_shared_object = 6,
                        /// <summary>ELF core image</summary>
                        elf_core = 7,
                        /// <summary>Mach-O Object file</summary>
                        macho_object = 8,
                        /// <summary>Mach-O Executable</summary>
                        macho_executable = 9,
                        /// <summary>Mach-O Shared Lib, FVM</summary>
                        macho_fixed_virtual_memory_shared_lib = 10,
                        /// <summary>Mach-O Core File</summary>
                        macho_core = 11,
                        /// <summary>Mach-O Preloaded Executable</summary>
                        macho_preload_executable = 12,
                        /// <summary>Mach-O dynlinked shared lib</summary>
                        macho_dynamically_linked_shared_lib = 13,
                        /// <summary>The Mach-O dynamic linker</summary>
                        macho_dynamic_linker = 14,
                        /// <summary>Mach-O Bundle file</summary>
                        macho_bundle = 15,
                        /// <summary>Mach-O Shared lib stub</summary>
                        macho_dynamically_linked_shared_lib_stub = 16,
                        /// <summary>Mach-O dSYM companion file</summary>
                        macho_dsym_companion = 17,
                        /// <summary>Mach-O universal binary</summary>
                        macho_universal_binary = 18,
                        /// <summary>COFF object file</summary>
                        coff_object = 19,
                        /// <summary>COFF import library</summary>
                        coff_import_library = 20,
                        /// <summary>PECOFF executable file</summary>
                        pecoff_executable = 21,
                        /// <summary>Windows compiled resource file (.rc)</summary>
                        windows_resource = 22
                    }

                    public global::System.IntPtr __Instance { get; protected set; }
                    public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, file_magic> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, file_magic>();

                    private readonly bool __ownsNativeInstance;

                    public static file_magic __CreateInstance(global::System.IntPtr native)
                    {
                        return new file_magic((file_magic.Internal*) native);
                    }

                    public static file_magic __CreateInstance(file_magic.Internal native)
                    {
                        return new file_magic(native);
                    }

                    private static file_magic.Internal* __CopyValue(file_magic.Internal native)
                    {
                        var ret = (file_magic.Internal*) Marshal.AllocHGlobal(4);
                        *ret = native;
                        return ret;
                    }

                    private file_magic(file_magic.Internal native)
                        : this(__CopyValue(native))
                    {
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                    }

                    protected file_magic(file_magic.Internal* native, bool isInternalImpl = false)
                    {
                        __Instance = new global::System.IntPtr(native);
                    }

                    public file_magic()
                    {
                        __Instance = Marshal.AllocHGlobal(4);
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                        Internal.ctor_0(__Instance);
                    }

                    public file_magic(llvm.sys.fs.file_magic.Impl V)
                    {
                        __Instance = Marshal.AllocHGlobal(4);
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                        var arg0 = V;
                        Internal.ctor_1(__Instance, arg0);
                    }

                    public void Dispose()
                    {
                        Dispose(disposing: true);
                    }

                    protected virtual void Dispose(bool disposing)
                    {
                        DestroyNativeInstance(false);
                    }

                    public virtual void DestroyNativeInstance()
                    {
                        DestroyNativeInstance(true);
                    }

                    private void DestroyNativeInstance(bool force)
                    {
                        llvm.sys.fs.file_magic __dummy;
                        NativeToManagedMap.TryRemove(__Instance, out __dummy);
                        if (__ownsNativeInstance)
                            Marshal.FreeHGlobal(__Instance);
                    }

                    public bool is_object()
                    {
                        var __ret = Internal.is_object_0(__Instance);
                        return __ret;
                    }

                    public static implicit operator llvm.sys.fs.file_magic.Impl(llvm.sys.fs.file_magic __op)
                    {
                        var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
                        var __ret = Internal.OperatorConversion_0(arg0);
                        return __ret;
                    }
                }

                /// <summary>
                /// <para>This class represents a memory mapped file. It is based on
                /// boost::iostreams::mapped_file.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// This class represents a memory mapped file. It is based
                /// on</para>
                /// <para>/// boost::iostreams::mapped_file.</para>
                /// </remarks>
                public unsafe partial class mapped_file_region : IDisposable
                {
                    [StructLayout(LayoutKind.Explicit, Size = 12)]
                    public partial struct Internal
                    {
                        [FieldOffset(0)]
                        public ulong Size;

                        [FieldOffset(8)]
                        public global::System.IntPtr Mapping;

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZN4llvm3sys2fs18mapped_file_regionC2EiNS2_7mapmodeEyyRNSt3__110error_codeE")]
                        internal static extern void ctor_2(global::System.IntPtr instance, int fd, llvm.sys.fs.mapped_file_region.mapmode mode, ulong length, ulong offset, global::System.IntPtr ec);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZN4llvm3sys2fs18mapped_file_regionD2Ev")]
                        internal static extern void dtor_0(global::System.IntPtr instance);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZNK4llvm3sys2fs18mapped_file_region4sizeEv")]
                        internal static extern ulong size_0(global::System.IntPtr instance);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZNK4llvm3sys2fs18mapped_file_region4dataEv")]
                        internal static extern sbyte* data_0(global::System.IntPtr instance);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZNK4llvm3sys2fs18mapped_file_region10const_dataEv")]
                        internal static extern global::System.IntPtr const_data_0(global::System.IntPtr instance);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZN4llvm3sys2fs18mapped_file_region9alignmentEv")]
                        internal static extern int alignment_0();
                    }

                    public enum mapmode : uint
                    {
                        /// <summary>May only access map via const_data as read only.</summary>
                        @readonly = 0,
                        /// <summary>May access map via data and modify it. Written to path.</summary>
                        readwrite = 1,
                        /// <summary>May modify via data, but changes are lost on destruction.</summary>
                        priv = 2
                    }

                    public global::System.IntPtr __Instance { get; protected set; }
                    public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, mapped_file_region> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, mapped_file_region>();

                    private readonly bool __ownsNativeInstance;

                    public static mapped_file_region __CreateInstance(global::System.IntPtr native)
                    {
                        return new mapped_file_region((mapped_file_region.Internal*) native);
                    }

                    public static mapped_file_region __CreateInstance(mapped_file_region.Internal native)
                    {
                        return new mapped_file_region(native);
                    }

                    private static mapped_file_region.Internal* __CopyValue(mapped_file_region.Internal native)
                    {
                        var ret = (mapped_file_region.Internal*) Marshal.AllocHGlobal(12);
                        *ret = native;
                        return ret;
                    }

                    private mapped_file_region(mapped_file_region.Internal native)
                        : this(__CopyValue(native))
                    {
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                    }

                    protected mapped_file_region(mapped_file_region.Internal* native, bool isInternalImpl = false)
                    {
                        __Instance = new global::System.IntPtr(native);
                    }

                    public mapped_file_region(int fd, llvm.sys.fs.mapped_file_region.mapmode mode, ulong length, ulong offset, std.__1.error_code ec)
                    {
                        __Instance = Marshal.AllocHGlobal(12);
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                        var arg1 = mode;
                        var arg2 = length;
                        var arg3 = offset;
                        var arg4 = ReferenceEquals(ec, null) ? global::System.IntPtr.Zero : ec.__Instance;
                        Internal.ctor_2(__Instance, fd, arg1, arg2, arg3, arg4);
                    }

                    public void Dispose()
                    {
                        Dispose(disposing: true);
                    }

                    protected virtual void Dispose(bool disposing)
                    {
                        DestroyNativeInstance(false);
                    }

                    public virtual void DestroyNativeInstance()
                    {
                        DestroyNativeInstance(true);
                    }

                    private void DestroyNativeInstance(bool force)
                    {
                        llvm.sys.fs.mapped_file_region __dummy;
                        NativeToManagedMap.TryRemove(__Instance, out __dummy);
                        if (__ownsNativeInstance || force)
                            Internal.dtor_0(__Instance);
                        if (__ownsNativeInstance)
                            Marshal.FreeHGlobal(__Instance);
                    }

                    public ulong size()
                    {
                        var __ret = Internal.size_0(__Instance);
                        return __ret;
                    }

                    public sbyte* data()
                    {
                        var __ret = Internal.data_0(__Instance);
                        return __ret;
                    }

                    /// <summary>
                    /// <para>Get a const view of the data. Modifying this memory has undefined
                    /// behavior.</para>
                    /// </summary>
                    /// <remarks>
                    /// <para>/// Get a const view of the data. Modifying this memory has
                    /// undefined</para>
                    /// <para>  /// behavior.</para>
                    /// </remarks>
                    public string const_data()
                    {
                        var __ret = Internal.const_data_0(__Instance);
                        return Marshal.PtrToStringAnsi(__ret);
                    }

                    /// <summary>
                    /// <para>Returns The minimum alignment offset must be.</para>
                    /// </summary>
                    /// <remarks>
                    /// <para>/// \returns The minimum alignment offset must be.</para>
                    /// </remarks>
                    public static int alignment()
                    {
                        var __ret = Internal.alignment_0();
                        return __ret;
                    }
                }

                /// <summary>
                /// <para>directory_entry - A single entry in a directory. Caches the
                /// status either from the result of the iteration syscall, or the first time
                /// status is called.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// directory_entry - A single entry in a directory. Caches the
                /// status either</para>
                /// <para>/// from the result of the iteration syscall, or the first time
                /// status is</para>
                /// <para>/// called.</para>
                /// </remarks>
                public unsafe partial class directory_entry : IDisposable
                {
                    [StructLayout(LayoutKind.Explicit, Size = 52)]
                    public partial struct Internal
                    {
                        [FieldOffset(12)]
                        public llvm.sys.fs.file_status.Internal Status;

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZN4llvm3sys2fs15directory_entryC2ERKNS_5TwineENS1_11file_statusE")]
                        internal static extern void ctor_0(global::System.IntPtr instance, global::System.IntPtr path, llvm.sys.fs.file_status.Internal st);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZN4llvm3sys2fs15directory_entryC2Ev")]
                        internal static extern void ctor_1(global::System.IntPtr instance);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZN4llvm3sys2fs15directory_entryC2ERKS2_")]
                        internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZN4llvm3sys2fs15directory_entryD2Ev")]
                        internal static extern void dtor_0(global::System.IntPtr instance);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZN4llvm3sys2fs15directory_entry6assignERKNS_5TwineENS1_11file_statusE")]
                        internal static extern void assign_0(global::System.IntPtr instance, global::System.IntPtr path, llvm.sys.fs.file_status.Internal st);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZN4llvm3sys2fs15directory_entry16replace_filenameERKNS_5TwineENS1_11file_statusE")]
                        internal static extern void replace_filename_0(global::System.IntPtr instance, global::System.IntPtr filename, llvm.sys.fs.file_status.Internal st);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZNK4llvm3sys2fs15directory_entry6statusERNS1_11file_statusE")]
                        internal static extern std.__1.error_code.Internal status_0(global::System.IntPtr instance, global::System.IntPtr result);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZNK4llvm3sys2fs15directory_entryeqERKS2_")]
                        [return: MarshalAsAttribute(UnmanagedType.I1)]
                        internal static extern bool OperatorEqualEqual_0(global::System.IntPtr instance, global::System.IntPtr rhs);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZNK4llvm3sys2fs15directory_entryneERKS2_")]
                        [return: MarshalAsAttribute(UnmanagedType.I1)]
                        internal static extern bool OperatorExclaimEqual_0(global::System.IntPtr instance, global::System.IntPtr rhs);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZNK4llvm3sys2fs15directory_entryltERKS2_")]
                        [return: MarshalAsAttribute(UnmanagedType.I1)]
                        internal static extern bool OperatorLess_0(global::System.IntPtr instance, global::System.IntPtr rhs);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZNK4llvm3sys2fs15directory_entryleERKS2_")]
                        [return: MarshalAsAttribute(UnmanagedType.I1)]
                        internal static extern bool OperatorLessEqual_0(global::System.IntPtr instance, global::System.IntPtr rhs);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZNK4llvm3sys2fs15directory_entrygtERKS2_")]
                        [return: MarshalAsAttribute(UnmanagedType.I1)]
                        internal static extern bool OperatorGreater_0(global::System.IntPtr instance, global::System.IntPtr rhs);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZNK4llvm3sys2fs15directory_entrygeERKS2_")]
                        [return: MarshalAsAttribute(UnmanagedType.I1)]
                        internal static extern bool OperatorGreaterEqual_0(global::System.IntPtr instance, global::System.IntPtr rhs);
                    }

                    public global::System.IntPtr __Instance { get; protected set; }
                    public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, directory_entry> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, directory_entry>();

                    private readonly bool __ownsNativeInstance;

                    public static directory_entry __CreateInstance(global::System.IntPtr native)
                    {
                        return new directory_entry((directory_entry.Internal*) native);
                    }

                    public static directory_entry __CreateInstance(directory_entry.Internal native)
                    {
                        return new directory_entry(native);
                    }

                    private static directory_entry.Internal* __CopyValue(directory_entry.Internal native)
                    {
                        var ret = (directory_entry.Internal*) Marshal.AllocHGlobal(52);
                        *ret = native;
                        return ret;
                    }

                    private directory_entry(directory_entry.Internal native)
                        : this(__CopyValue(native))
                    {
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                    }

                    protected directory_entry(directory_entry.Internal* native, bool isInternalImpl = false)
                    {
                        __Instance = new global::System.IntPtr(native);
                    }

                    public directory_entry(llvm.Twine path, llvm.sys.fs.file_status st)
                    {
                        __Instance = Marshal.AllocHGlobal(52);
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                        var arg0 = ReferenceEquals(path, null) ? global::System.IntPtr.Zero : path.__Instance;
                        var arg1 = ReferenceEquals(st, null) ? new llvm.sys.fs.file_status.Internal() : *(llvm.sys.fs.file_status.Internal*) (st.__Instance);
                        Internal.ctor_0(__Instance, arg0, arg1);
                    }

                    public directory_entry()
                    {
                        __Instance = Marshal.AllocHGlobal(52);
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                        Internal.ctor_1(__Instance);
                    }

                    public void Dispose()
                    {
                        Dispose(disposing: true);
                    }

                    protected virtual void Dispose(bool disposing)
                    {
                        DestroyNativeInstance(false);
                    }

                    public virtual void DestroyNativeInstance()
                    {
                        DestroyNativeInstance(true);
                    }

                    private void DestroyNativeInstance(bool force)
                    {
                        llvm.sys.fs.directory_entry __dummy;
                        NativeToManagedMap.TryRemove(__Instance, out __dummy);
                        if (__ownsNativeInstance || force)
                            Internal.dtor_0(__Instance);
                        if (__ownsNativeInstance)
                            Marshal.FreeHGlobal(__Instance);
                    }

                    public void assign(llvm.Twine path, llvm.sys.fs.file_status st)
                    {
                        var arg0 = ReferenceEquals(path, null) ? global::System.IntPtr.Zero : path.__Instance;
                        var arg1 = ReferenceEquals(st, null) ? new llvm.sys.fs.file_status.Internal() : *(llvm.sys.fs.file_status.Internal*) (st.__Instance);
                        Internal.assign_0(__Instance, arg0, arg1);
                    }

                    public void replace_filename(llvm.Twine filename, llvm.sys.fs.file_status st)
                    {
                        var arg0 = ReferenceEquals(filename, null) ? global::System.IntPtr.Zero : filename.__Instance;
                        var arg1 = ReferenceEquals(st, null) ? new llvm.sys.fs.file_status.Internal() : *(llvm.sys.fs.file_status.Internal*) (st.__Instance);
                        Internal.replace_filename_0(__Instance, arg0, arg1);
                    }

                    public std.__1.error_code status(llvm.sys.fs.file_status result)
                    {
                        var arg0 = ReferenceEquals(result, null) ? global::System.IntPtr.Zero : result.__Instance;
                        var __ret = Internal.status_0(__Instance, arg0);
                        return std.__1.error_code.__CreateInstance(__ret);
                    }

                    public static bool operator ==(llvm.sys.fs.directory_entry __op, llvm.sys.fs.directory_entry rhs)
                    {
                        bool __opNull = ReferenceEquals(__op, null);
                        bool rhsNull = ReferenceEquals(rhs, null);
                        if (__opNull || rhsNull)
                            return __opNull && rhsNull;
                        var arg0 = __op.__Instance;
                        var arg1 = rhs.__Instance;
                        var __ret = Internal.OperatorEqualEqual_0(arg0, arg1);
                        return __ret;
                    }

                    public override bool Equals(object obj)
                    {
                        return this == obj as directory_entry;
                    }

                    public static bool operator !=(llvm.sys.fs.directory_entry __op, llvm.sys.fs.directory_entry rhs)
                    {
                        var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
                        var arg1 = ReferenceEquals(rhs, null) ? global::System.IntPtr.Zero : rhs.__Instance;
                        var __ret = Internal.OperatorExclaimEqual_0(arg0, arg1);
                        return __ret;
                    }

                    public static bool operator <(llvm.sys.fs.directory_entry __op, llvm.sys.fs.directory_entry rhs)
                    {
                        var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
                        var arg1 = ReferenceEquals(rhs, null) ? global::System.IntPtr.Zero : rhs.__Instance;
                        var __ret = Internal.OperatorLess_0(arg0, arg1);
                        return __ret;
                    }

                    public static bool operator <=(llvm.sys.fs.directory_entry __op, llvm.sys.fs.directory_entry rhs)
                    {
                        var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
                        var arg1 = ReferenceEquals(rhs, null) ? global::System.IntPtr.Zero : rhs.__Instance;
                        var __ret = Internal.OperatorLessEqual_0(arg0, arg1);
                        return __ret;
                    }

                    public static bool operator >(llvm.sys.fs.directory_entry __op, llvm.sys.fs.directory_entry rhs)
                    {
                        var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
                        var arg1 = ReferenceEquals(rhs, null) ? global::System.IntPtr.Zero : rhs.__Instance;
                        var __ret = Internal.OperatorGreater_0(arg0, arg1);
                        return __ret;
                    }

                    public static bool operator >=(llvm.sys.fs.directory_entry __op, llvm.sys.fs.directory_entry rhs)
                    {
                        var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
                        var arg1 = ReferenceEquals(rhs, null) ? global::System.IntPtr.Zero : rhs.__Instance;
                        var __ret = Internal.OperatorGreaterEqual_0(arg0, arg1);
                        return __ret;
                    }
                }

                /// <summary>
                /// <para>directory_iterator - Iterates through the entries in path. There
                /// is no operator++ because we need an error_code. If it's really needed we
                /// can make it call report_fatal_error on error.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// directory_iterator - Iterates through the entries in path.
                /// There is no</para>
                /// <para>/// operator++ because we need an error_code. If it's really
                /// needed we can make</para>
                /// <para>/// it call report_fatal_error on error.</para>
                /// </remarks>
                public unsafe partial class directory_iterator : IDisposable
                {
                    [StructLayout(LayoutKind.Explicit, Size = 4)]
                    public partial struct Internal
                    {
                        [FieldOffset(0)]
                        public llvm.IntrusiveRefCntPtr.Internal State;

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZN4llvm3sys2fs18directory_iteratorC2ERKNS_5TwineERNSt3__110error_codeE")]
                        internal static extern void ctor_0(global::System.IntPtr instance, global::System.IntPtr path, global::System.IntPtr ec);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZN4llvm3sys2fs18directory_iteratorC2ERKNS1_15directory_entryERNSt3__110error_codeE")]
                        internal static extern void ctor_1(global::System.IntPtr instance, global::System.IntPtr de, global::System.IntPtr ec);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZN4llvm3sys2fs18directory_iteratorC2Ev")]
                        internal static extern void ctor_2(global::System.IntPtr instance);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZN4llvm3sys2fs18directory_iteratorC2ERKS2_")]
                        internal static extern void cctor_4(global::System.IntPtr instance, global::System.IntPtr _0);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZN4llvm3sys2fs18directory_iteratorD2Ev")]
                        internal static extern void dtor_0(global::System.IntPtr instance);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZN4llvm3sys2fs18directory_iterator9incrementERNSt3__110error_codeE")]
                        internal static extern global::System.IntPtr increment_0(global::System.IntPtr instance, global::System.IntPtr ec);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZNK4llvm3sys2fs18directory_iteratoreqERKS2_")]
                        [return: MarshalAsAttribute(UnmanagedType.I1)]
                        internal static extern bool OperatorEqualEqual_0(global::System.IntPtr instance, global::System.IntPtr RHS);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZNK4llvm3sys2fs18directory_iteratorneERKS2_")]
                        [return: MarshalAsAttribute(UnmanagedType.I1)]
                        internal static extern bool OperatorExclaimEqual_0(global::System.IntPtr instance, global::System.IntPtr RHS);
                    }

                    public global::System.IntPtr __Instance { get; protected set; }
                    public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, directory_iterator> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, directory_iterator>();

                    private readonly bool __ownsNativeInstance;

                    public static directory_iterator __CreateInstance(global::System.IntPtr native)
                    {
                        return new directory_iterator((directory_iterator.Internal*) native);
                    }

                    public static directory_iterator __CreateInstance(directory_iterator.Internal native)
                    {
                        return new directory_iterator(native);
                    }

                    private static directory_iterator.Internal* __CopyValue(directory_iterator.Internal native)
                    {
                        var ret = (directory_iterator.Internal*) Marshal.AllocHGlobal(4);
                        *ret = native;
                        return ret;
                    }

                    private directory_iterator(directory_iterator.Internal native)
                        : this(__CopyValue(native))
                    {
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                    }

                    protected directory_iterator(directory_iterator.Internal* native, bool isInternalImpl = false)
                    {
                        __Instance = new global::System.IntPtr(native);
                    }

                    public directory_iterator(llvm.Twine path, std.__1.error_code ec)
                    {
                        __Instance = Marshal.AllocHGlobal(4);
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                        var arg0 = ReferenceEquals(path, null) ? global::System.IntPtr.Zero : path.__Instance;
                        var arg1 = ReferenceEquals(ec, null) ? global::System.IntPtr.Zero : ec.__Instance;
                        Internal.ctor_0(__Instance, arg0, arg1);
                    }

                    public directory_iterator(llvm.sys.fs.directory_entry de, std.__1.error_code ec)
                    {
                        __Instance = Marshal.AllocHGlobal(4);
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                        var arg0 = ReferenceEquals(de, null) ? global::System.IntPtr.Zero : de.__Instance;
                        var arg1 = ReferenceEquals(ec, null) ? global::System.IntPtr.Zero : ec.__Instance;
                        Internal.ctor_1(__Instance, arg0, arg1);
                    }

                    /// <summary>
                    /// <para>Construct end iterator.</para>
                    /// </summary>
                    /// <remarks>
                    /// <para>/// Construct end iterator.</para>
                    /// </remarks>
                    public directory_iterator()
                    {
                        __Instance = Marshal.AllocHGlobal(4);
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                        Internal.ctor_2(__Instance);
                    }

                    public void Dispose()
                    {
                        Dispose(disposing: true);
                    }

                    protected virtual void Dispose(bool disposing)
                    {
                        DestroyNativeInstance(false);
                    }

                    public virtual void DestroyNativeInstance()
                    {
                        DestroyNativeInstance(true);
                    }

                    private void DestroyNativeInstance(bool force)
                    {
                        llvm.sys.fs.directory_iterator __dummy;
                        NativeToManagedMap.TryRemove(__Instance, out __dummy);
                        if (__ownsNativeInstance || force)
                            Internal.dtor_0(__Instance);
                        if (__ownsNativeInstance)
                            Marshal.FreeHGlobal(__Instance);
                    }

                    public llvm.sys.fs.directory_iterator increment(std.__1.error_code ec)
                    {
                        var arg0 = ReferenceEquals(ec, null) ? global::System.IntPtr.Zero : ec.__Instance;
                        var __ret = Internal.increment_0(__Instance, arg0);
                        llvm.sys.fs.directory_iterator __result0;
                        if (__ret == IntPtr.Zero) __result0 = null;
                        else if (llvm.sys.fs.directory_iterator.NativeToManagedMap.ContainsKey(__ret))
                            __result0 = (llvm.sys.fs.directory_iterator) llvm.sys.fs.directory_iterator.NativeToManagedMap[__ret];
                        else __result0 = llvm.sys.fs.directory_iterator.__CreateInstance(__ret);
                        return __result0;
                    }

                    public static bool operator ==(llvm.sys.fs.directory_iterator __op, llvm.sys.fs.directory_iterator RHS)
                    {
                        bool __opNull = ReferenceEquals(__op, null);
                        bool RHSNull = ReferenceEquals(RHS, null);
                        if (__opNull || RHSNull)
                            return __opNull && RHSNull;
                        var arg0 = __op.__Instance;
                        var arg1 = RHS.__Instance;
                        var __ret = Internal.OperatorEqualEqual_0(arg0, arg1);
                        return __ret;
                    }

                    public override bool Equals(object obj)
                    {
                        return this == obj as directory_iterator;
                    }

                    public static bool operator !=(llvm.sys.fs.directory_iterator __op, llvm.sys.fs.directory_iterator RHS)
                    {
                        var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
                        var arg1 = ReferenceEquals(RHS, null) ? global::System.IntPtr.Zero : RHS.__Instance;
                        var __ret = Internal.OperatorExclaimEqual_0(arg0, arg1);
                        return __ret;
                    }
                }

                /// <summary>
                /// <para>recursive_directory_iterator - Same as directory_iterator except
                /// for it recurses down into child directories.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// recursive_directory_iterator - Same as directory_iterator
                /// except for it</para>
                /// <para>/// recurses down into child directories.</para>
                /// </remarks>
                public unsafe partial class recursive_directory_iterator : IDisposable
                {
                    [StructLayout(LayoutKind.Explicit, Size = 4)]
                    public partial struct Internal
                    {
                        [FieldOffset(0)]
                        public llvm.IntrusiveRefCntPtr.Internal State;

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZN4llvm3sys2fs28recursive_directory_iteratorC2Ev")]
                        internal static extern void ctor_0(global::System.IntPtr instance);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZN4llvm3sys2fs28recursive_directory_iteratorC2ERKNS_5TwineERNSt3__110error_codeE")]
                        internal static extern void ctor_1(global::System.IntPtr instance, global::System.IntPtr path, global::System.IntPtr ec);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZN4llvm3sys2fs28recursive_directory_iteratorC2ERKS2_")]
                        internal static extern void cctor_3(global::System.IntPtr instance, global::System.IntPtr _0);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZN4llvm3sys2fs28recursive_directory_iteratorD2Ev")]
                        internal static extern void dtor_0(global::System.IntPtr instance);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZN4llvm3sys2fs28recursive_directory_iterator9incrementERNSt3__110error_codeE")]
                        internal static extern global::System.IntPtr increment_0(global::System.IntPtr instance, global::System.IntPtr ec);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZNK4llvm3sys2fs28recursive_directory_iterator5levelEv")]
                        internal static extern int level_0(global::System.IntPtr instance);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZNK4llvm3sys2fs28recursive_directory_iterator15no_push_requestEv")]
                        [return: MarshalAsAttribute(UnmanagedType.I1)]
                        internal static extern bool no_push_request_0(global::System.IntPtr instance);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZN4llvm3sys2fs28recursive_directory_iterator3popEv")]
                        internal static extern void pop_0(global::System.IntPtr instance);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZN4llvm3sys2fs28recursive_directory_iterator7no_pushEv")]
                        internal static extern void no_push_0(global::System.IntPtr instance);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZNK4llvm3sys2fs28recursive_directory_iteratoreqERKS2_")]
                        [return: MarshalAsAttribute(UnmanagedType.I1)]
                        internal static extern bool OperatorEqualEqual_0(global::System.IntPtr instance, global::System.IntPtr RHS);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZNK4llvm3sys2fs28recursive_directory_iteratorneERKS2_")]
                        [return: MarshalAsAttribute(UnmanagedType.I1)]
                        internal static extern bool OperatorExclaimEqual_0(global::System.IntPtr instance, global::System.IntPtr RHS);
                    }

                    public global::System.IntPtr __Instance { get; protected set; }
                    public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, recursive_directory_iterator> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, recursive_directory_iterator>();

                    private readonly bool __ownsNativeInstance;

                    public static recursive_directory_iterator __CreateInstance(global::System.IntPtr native)
                    {
                        return new recursive_directory_iterator((recursive_directory_iterator.Internal*) native);
                    }

                    public static recursive_directory_iterator __CreateInstance(recursive_directory_iterator.Internal native)
                    {
                        return new recursive_directory_iterator(native);
                    }

                    private static recursive_directory_iterator.Internal* __CopyValue(recursive_directory_iterator.Internal native)
                    {
                        var ret = (recursive_directory_iterator.Internal*) Marshal.AllocHGlobal(4);
                        *ret = native;
                        return ret;
                    }

                    private recursive_directory_iterator(recursive_directory_iterator.Internal native)
                        : this(__CopyValue(native))
                    {
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                    }

                    protected recursive_directory_iterator(recursive_directory_iterator.Internal* native, bool isInternalImpl = false)
                    {
                        __Instance = new global::System.IntPtr(native);
                    }

                    public recursive_directory_iterator()
                    {
                        __Instance = Marshal.AllocHGlobal(4);
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                        Internal.ctor_0(__Instance);
                    }

                    public recursive_directory_iterator(llvm.Twine path, std.__1.error_code ec)
                    {
                        __Instance = Marshal.AllocHGlobal(4);
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                        var arg0 = ReferenceEquals(path, null) ? global::System.IntPtr.Zero : path.__Instance;
                        var arg1 = ReferenceEquals(ec, null) ? global::System.IntPtr.Zero : ec.__Instance;
                        Internal.ctor_1(__Instance, arg0, arg1);
                    }

                    public void Dispose()
                    {
                        Dispose(disposing: true);
                    }

                    protected virtual void Dispose(bool disposing)
                    {
                        DestroyNativeInstance(false);
                    }

                    public virtual void DestroyNativeInstance()
                    {
                        DestroyNativeInstance(true);
                    }

                    private void DestroyNativeInstance(bool force)
                    {
                        llvm.sys.fs.recursive_directory_iterator __dummy;
                        NativeToManagedMap.TryRemove(__Instance, out __dummy);
                        if (__ownsNativeInstance || force)
                            Internal.dtor_0(__Instance);
                        if (__ownsNativeInstance)
                            Marshal.FreeHGlobal(__Instance);
                    }

                    public llvm.sys.fs.recursive_directory_iterator increment(std.__1.error_code ec)
                    {
                        var arg0 = ReferenceEquals(ec, null) ? global::System.IntPtr.Zero : ec.__Instance;
                        var __ret = Internal.increment_0(__Instance, arg0);
                        llvm.sys.fs.recursive_directory_iterator __result0;
                        if (__ret == IntPtr.Zero) __result0 = null;
                        else if (llvm.sys.fs.recursive_directory_iterator.NativeToManagedMap.ContainsKey(__ret))
                            __result0 = (llvm.sys.fs.recursive_directory_iterator) llvm.sys.fs.recursive_directory_iterator.NativeToManagedMap[__ret];
                        else __result0 = llvm.sys.fs.recursive_directory_iterator.__CreateInstance(__ret);
                        return __result0;
                    }

                    /// <summary>
                    /// <para>Gets the current level. Starting path is at level 0.</para>
                    /// </summary>
                    /// <remarks>
                    /// <para>/// Gets the current level. Starting path is at level 0.</para>
                    /// </remarks>
                    public int level()
                    {
                        var __ret = Internal.level_0(__Instance);
                        return __ret;
                    }

                    /// <summary>
                    /// <para>Returns true if no_push has been called for this
                    /// directory_entry.</para>
                    /// </summary>
                    /// <remarks>
                    /// <para>/// Returns true if no_push has been called for this
                    /// directory_entry.</para>
                    /// </remarks>
                    public bool no_push_request()
                    {
                        var __ret = Internal.no_push_request_0(__Instance);
                        return __ret;
                    }

                    /// <summary>
                    /// <para>Goes up one level if Level &gt; 0.</para>
                    /// </summary>
                    /// <remarks>
                    /// <para>/// Goes up one level if Level &gt; 0.</para>
                    /// </remarks>
                    public void pop()
                    {
                        Internal.pop_0(__Instance);
                    }

                    /// <summary>
                    /// <para>Does not go down into the current directory_entry.</para>
                    /// </summary>
                    /// <remarks>
                    /// <para>/// Does not go down into the current directory_entry.</para>
                    /// </remarks>
                    public void no_push()
                    {
                        Internal.no_push_0(__Instance);
                    }

                    public static bool operator ==(llvm.sys.fs.recursive_directory_iterator __op, llvm.sys.fs.recursive_directory_iterator RHS)
                    {
                        bool __opNull = ReferenceEquals(__op, null);
                        bool RHSNull = ReferenceEquals(RHS, null);
                        if (__opNull || RHSNull)
                            return __opNull && RHSNull;
                        var arg0 = __op.__Instance;
                        var arg1 = RHS.__Instance;
                        var __ret = Internal.OperatorEqualEqual_0(arg0, arg1);
                        return __ret;
                    }

                    public override bool Equals(object obj)
                    {
                        return this == obj as recursive_directory_iterator;
                    }

                    public static bool operator !=(llvm.sys.fs.recursive_directory_iterator __op, llvm.sys.fs.recursive_directory_iterator RHS)
                    {
                        var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
                        var arg1 = ReferenceEquals(RHS, null) ? global::System.IntPtr.Zero : RHS.__Instance;
                        var __ret = Internal.OperatorExclaimEqual_0(arg0, arg1);
                        return __ret;
                    }
                }

                public unsafe partial class FileSystem
                {
                    public partial struct Internal
                    {
                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZN4llvm3sys2fs10equivalentENS1_11file_statusES2_")]
                        [return: MarshalAsAttribute(UnmanagedType.I1)]
                        internal static extern bool equivalent_0(llvm.sys.fs.file_status.Internal A, llvm.sys.fs.file_status.Internal B);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZN4llvm3sys2fs18create_directoriesERKNS_5TwineEb")]
                        internal static extern std.__1.error_code.Internal create_directories_0(global::System.IntPtr path, bool IgnoreExisting);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZN4llvm3sys2fs16create_directoryERKNS_5TwineEb")]
                        internal static extern std.__1.error_code.Internal create_directory_0(global::System.IntPtr path, bool IgnoreExisting);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZN4llvm3sys2fs11create_linkERKNS_5TwineES4_")]
                        internal static extern std.__1.error_code.Internal create_link_0(global::System.IntPtr to, global::System.IntPtr from);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZN4llvm3sys2fs6removeERKNS_5TwineEb")]
                        internal static extern std.__1.error_code.Internal remove_0(global::System.IntPtr path, bool IgnoreNonExisting);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZN4llvm3sys2fs6renameERKNS_5TwineES4_")]
                        internal static extern std.__1.error_code.Internal rename_0(global::System.IntPtr from, global::System.IntPtr to);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZN4llvm3sys2fs9copy_fileERKNS_5TwineES4_")]
                        internal static extern std.__1.error_code.Internal copy_file_0(global::System.IntPtr From, global::System.IntPtr To);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZN4llvm3sys2fs11resize_fileEiy")]
                        internal static extern std.__1.error_code.Internal resize_file_0(int FD, ulong Size);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZN4llvm3sys2fs6existsENS1_11file_statusE")]
                        [return: MarshalAsAttribute(UnmanagedType.I1)]
                        internal static extern bool exists_0(llvm.sys.fs.file_status.Internal status);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZN4llvm3sys2fs6accessERKNS_5TwineENS1_10AccessModeE")]
                        internal static extern std.__1.error_code.Internal access_0(global::System.IntPtr Path, llvm.sys.fs.AccessMode Mode);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZN4llvm3sys2fs6existsERKNS_5TwineE")]
                        [return: MarshalAsAttribute(UnmanagedType.I1)]
                        internal static extern bool exists_1(global::System.IntPtr Path);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZN4llvm3sys2fs11can_executeERKNS_5TwineE")]
                        [return: MarshalAsAttribute(UnmanagedType.I1)]
                        internal static extern bool can_execute_0(global::System.IntPtr Path);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZN4llvm3sys2fs9can_writeERKNS_5TwineE")]
                        [return: MarshalAsAttribute(UnmanagedType.I1)]
                        internal static extern bool can_write_0(global::System.IntPtr Path);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZN4llvm3sys2fs10equivalentERKNS_5TwineES4_Rb")]
                        internal static extern std.__1.error_code.Internal equivalent_1(global::System.IntPtr A, global::System.IntPtr B, bool* result);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZN4llvm3sys2fs10equivalentERKNS_5TwineES4_")]
                        [return: MarshalAsAttribute(UnmanagedType.I1)]
                        internal static extern bool equivalent_2(global::System.IntPtr A, global::System.IntPtr B);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZN4llvm3sys2fs12is_directoryENS1_11file_statusE")]
                        [return: MarshalAsAttribute(UnmanagedType.I1)]
                        internal static extern bool is_directory_0(llvm.sys.fs.file_status.Internal status);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZN4llvm3sys2fs12is_directoryERKNS_5TwineERb")]
                        internal static extern std.__1.error_code.Internal is_directory_1(global::System.IntPtr path, bool* result);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZN4llvm3sys2fs12is_directoryERKNS_5TwineE")]
                        [return: MarshalAsAttribute(UnmanagedType.I1)]
                        internal static extern bool is_directory_2(global::System.IntPtr Path);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZN4llvm3sys2fs15is_regular_fileENS1_11file_statusE")]
                        [return: MarshalAsAttribute(UnmanagedType.I1)]
                        internal static extern bool is_regular_file_0(llvm.sys.fs.file_status.Internal status);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZN4llvm3sys2fs15is_regular_fileERKNS_5TwineERb")]
                        internal static extern std.__1.error_code.Internal is_regular_file_1(global::System.IntPtr path, bool* result);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZN4llvm3sys2fs15is_regular_fileERKNS_5TwineE")]
                        [return: MarshalAsAttribute(UnmanagedType.I1)]
                        internal static extern bool is_regular_file_2(global::System.IntPtr Path);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZN4llvm3sys2fs8is_otherENS1_11file_statusE")]
                        [return: MarshalAsAttribute(UnmanagedType.I1)]
                        internal static extern bool is_other_0(llvm.sys.fs.file_status.Internal status);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZN4llvm3sys2fs8is_otherERKNS_5TwineERb")]
                        internal static extern std.__1.error_code.Internal is_other_1(global::System.IntPtr path, bool* result);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZN4llvm3sys2fs6statusERKNS_5TwineERNS1_11file_statusE")]
                        internal static extern std.__1.error_code.Internal status_0(global::System.IntPtr path, global::System.IntPtr result);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZN4llvm3sys2fs6statusEiRNS1_11file_statusE")]
                        internal static extern std.__1.error_code.Internal status_1(int FD, global::System.IntPtr Result);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZN4llvm3sys2fs9file_sizeERKNS_5TwineERy")]
                        internal static extern std.__1.error_code.Internal file_size_0(global::System.IntPtr Path, ulong* Result);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZN4llvm3sys2fs32setLastModificationAndAccessTimeEiNS0_9TimeValueE")]
                        internal static extern std.__1.error_code.Internal setLastModificationAndAccessTime_0(int FD, llvm.sys.TimeValue.Internal Time);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZN4llvm3sys2fs12status_knownENS1_11file_statusE")]
                        [return: MarshalAsAttribute(UnmanagedType.I1)]
                        internal static extern bool status_known_0(llvm.sys.fs.file_status.Internal s);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZN4llvm3sys2fs12status_knownERKNS_5TwineERb")]
                        internal static extern std.__1.error_code.Internal status_known_1(global::System.IntPtr path, bool* result);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZN4llvm3sys2fs16openFileForWriteERKNS_5TwineERiNS1_9OpenFlagsEj")]
                        internal static extern std.__1.error_code.Internal openFileForWrite_0(global::System.IntPtr Name, int* ResultFD, llvm.sys.fs.OpenFlags Flags, uint Mode);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZN4llvm3sys2fs15openFileForReadERKNS_5TwineERi")]
                        internal static extern std.__1.error_code.Internal openFileForRead_0(global::System.IntPtr Name, int* ResultFD);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZN4llvm3sys2fs14identify_magicENS_9StringRefE")]
                        internal static extern llvm.sys.fs.file_magic.Internal identify_magic_0(llvm.StringRef.Internal magic);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZN4llvm3sys2fs14identify_magicERKNS_5TwineERNS1_10file_magicE")]
                        internal static extern std.__1.error_code.Internal identify_magic_1(global::System.IntPtr path, global::System.IntPtr result);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZN4llvm3sys2fs11getUniqueIDENS_5TwineERNS1_8UniqueIDE")]
                        internal static extern std.__1.error_code.Internal getUniqueID_0(llvm.Twine.Internal Path, global::System.IntPtr Result);
                    }

                    /// <summary>
                    /// <para>Do file_status's represent the same thing?</para>
                    /// </summary>
                    /// <remarks>
                    /// <para>/// @brief Do file_status's represent the same thing?</para>
                    /// <para>///</para>
                    /// <para>/// @param A Input file_status.</para>
                    /// <para>/// @param B Input file_status.</para>
                    /// <para>///</para>
                    /// <para>/// assert(status_known(A) || status_known(B));</para>
                    /// <para>///</para>
                    /// <para>/// @returns True if A and B both represent the same file system
                    /// entity, false</para>
                    /// <para>///          otherwise.</para>
                    /// </remarks>
                    public static bool equivalent(llvm.sys.fs.file_status A, llvm.sys.fs.file_status B)
                    {
                        var arg0 = ReferenceEquals(A, null) ? new llvm.sys.fs.file_status.Internal() : *(llvm.sys.fs.file_status.Internal*) (A.__Instance);
                        var arg1 = ReferenceEquals(B, null) ? new llvm.sys.fs.file_status.Internal() : *(llvm.sys.fs.file_status.Internal*) (B.__Instance);
                        var __ret = Internal.equivalent_0(arg0, arg1);
                        return __ret;
                    }

                    /// <summary>
                    /// <para>Create all the non-existent directories in path.</para>
                    /// </summary>
                    /// <remarks>
                    /// <para>/// @brief Create all the non-existent directories in
                    /// path.</para>
                    /// <para>///</para>
                    /// <para>/// @param path Directories to create.</para>
                    /// <para>/// @returns errc::success if is_directory(path), otherwise a
                    /// platform</para>
                    /// <para>///          specific error_code. If IgnoreExisting is false,
                    /// also returns</para>
                    /// <para>///          error if the directory already existed.</para>
                    /// </remarks>
                    public static std.__1.error_code create_directories(llvm.Twine path, bool IgnoreExisting)
                    {
                        var arg0 = ReferenceEquals(path, null) ? global::System.IntPtr.Zero : path.__Instance;
                        var __ret = Internal.create_directories_0(arg0, IgnoreExisting);
                        return std.__1.error_code.__CreateInstance(__ret);
                    }

                    /// <summary>
                    /// <para>Create the directory in path.</para>
                    /// </summary>
                    /// <remarks>
                    /// <para>/// @brief Create the directory in path.</para>
                    /// <para>///</para>
                    /// <para>/// @param path Directory to create.</para>
                    /// <para>/// @returns errc::success if is_directory(path), otherwise a
                    /// platform</para>
                    /// <para>///          specific error_code. If IgnoreExisting is false,
                    /// also returns</para>
                    /// <para>///          error if the directory already existed.</para>
                    /// </remarks>
                    public static std.__1.error_code create_directory(llvm.Twine path, bool IgnoreExisting)
                    {
                        var arg0 = ReferenceEquals(path, null) ? global::System.IntPtr.Zero : path.__Instance;
                        var __ret = Internal.create_directory_0(arg0, IgnoreExisting);
                        return std.__1.error_code.__CreateInstance(__ret);
                    }

                    /// <summary>
                    /// <para>Create a link from from to to.</para>
                    /// </summary>
                    /// <remarks>
                    /// <para>/// @brief Create a link from \a from to \a to.</para>
                    /// <para>///</para>
                    /// <para>/// The link may be a soft or a hard link, depending on the
                    /// platform. The caller</para>
                    /// <para>/// may not assume which one. Currently on windows it creates a
                    /// hard link since</para>
                    /// <para>/// soft links require extra privileges. On unix, it creates a
                    /// soft link since</para>
                    /// <para>/// hard links don't work on SMB file systems.</para>
                    /// <para>///</para>
                    /// <para>/// @param to The path to hard link to.</para>
                    /// <para>/// @param from The path to hard link from. This is
                    /// created.</para>
                    /// <para>/// @returns errc::success if the link was created, otherwise a
                    /// platform</para>
                    /// <para>/// specific error_code.</para>
                    /// </remarks>
                    public static std.__1.error_code create_link(llvm.Twine to, llvm.Twine from)
                    {
                        var arg0 = ReferenceEquals(to, null) ? global::System.IntPtr.Zero : to.__Instance;
                        var arg1 = ReferenceEquals(from, null) ? global::System.IntPtr.Zero : from.__Instance;
                        var __ret = Internal.create_link_0(arg0, arg1);
                        return std.__1.error_code.__CreateInstance(__ret);
                    }

                    /// <summary>
                    /// <para>Remove path. Equivalent to POSIX remove().</para>
                    /// </summary>
                    /// <remarks>
                    /// <para>/// @brief Remove path. Equivalent to POSIX remove().</para>
                    /// <para>///</para>
                    /// <para>/// @param path Input path.</para>
                    /// <para>/// @returns errc::success if path has been removed or didn't
                    /// exist, otherwise a</para>
                    /// <para>///          platform-specific error code. If IgnoreNonExisting
                    /// is false, also</para>
                    /// <para>///          returns error if the file didn't exist.</para>
                    /// </remarks>
                    public static std.__1.error_code remove(llvm.Twine path, bool IgnoreNonExisting)
                    {
                        var arg0 = ReferenceEquals(path, null) ? global::System.IntPtr.Zero : path.__Instance;
                        var __ret = Internal.remove_0(arg0, IgnoreNonExisting);
                        return std.__1.error_code.__CreateInstance(__ret);
                    }

                    /// <summary>
                    /// <para>Rename from to to. Files are renamed as if by POSIX
                    /// rename().</para>
                    /// </summary>
                    /// <remarks>
                    /// <para>/// @brief Rename \a from to \a to. Files are renamed as if by
                    /// POSIX rename().</para>
                    /// <para>///</para>
                    /// <para>/// @param from The path to rename from.</para>
                    /// <para>/// @param to The path to rename to. This is created.</para>
                    /// </remarks>
                    public static std.__1.error_code rename(llvm.Twine from, llvm.Twine to)
                    {
                        var arg0 = ReferenceEquals(from, null) ? global::System.IntPtr.Zero : from.__Instance;
                        var arg1 = ReferenceEquals(to, null) ? global::System.IntPtr.Zero : to.__Instance;
                        var __ret = Internal.rename_0(arg0, arg1);
                        return std.__1.error_code.__CreateInstance(__ret);
                    }

                    /// <summary>
                    /// <para>Copy the contents of From to To.</para>
                    /// </summary>
                    /// <remarks>
                    /// <para>/// @brief Copy the contents of \a From to \a To.</para>
                    /// <para>///</para>
                    /// <para>/// @param From The path to copy from.</para>
                    /// <para>/// @param To The path to copy to. This is created.</para>
                    /// </remarks>
                    public static std.__1.error_code copy_file(llvm.Twine From, llvm.Twine To)
                    {
                        var arg0 = ReferenceEquals(From, null) ? global::System.IntPtr.Zero : From.__Instance;
                        var arg1 = ReferenceEquals(To, null) ? global::System.IntPtr.Zero : To.__Instance;
                        var __ret = Internal.copy_file_0(arg0, arg1);
                        return std.__1.error_code.__CreateInstance(__ret);
                    }

                    /// <summary>
                    /// <para>Resize path to size. File is resized as if by POSIX
                    /// truncate().</para>
                    /// </summary>
                    /// <remarks>
                    /// <para>/// @brief Resize path to size. File is resized as if by POSIX
                    /// truncate().</para>
                    /// <para>///</para>
                    /// <para>/// @param FD Input file descriptor.</para>
                    /// <para>/// @param Size Size to resize to.</para>
                    /// <para>/// @returns errc::success if \a path has been resized to \a
                    /// size, otherwise a</para>
                    /// <para>///          platform-specific error_code.</para>
                    /// </remarks>
                    public static std.__1.error_code resize_file(int FD, ulong Size)
                    {
                        var arg1 = Size;
                        var __ret = Internal.resize_file_0(FD, arg1);
                        return std.__1.error_code.__CreateInstance(__ret);
                    }

                    /// <summary>
                    /// <para>Does file exist?</para>
                    /// </summary>
                    /// <remarks>
                    /// <para>/// @brief Does file exist?</para>
                    /// <para>///</para>
                    /// <para>/// @param status A file_status previously returned from
                    /// stat.</para>
                    /// <para>/// @returns True if the file represented by status exists, false
                    /// if it does</para>
                    /// <para>///          not.</para>
                    /// </remarks>
                    public static bool exists(llvm.sys.fs.file_status status)
                    {
                        var arg0 = ReferenceEquals(status, null) ? new llvm.sys.fs.file_status.Internal() : *(llvm.sys.fs.file_status.Internal*) (status.__Instance);
                        var __ret = Internal.exists_0(arg0);
                        return __ret;
                    }

                    /// <summary>
                    /// <para>Can the file be accessed?</para>
                    /// </summary>
                    /// <remarks>
                    /// <para>/// @brief Can the file be accessed?</para>
                    /// <para>///</para>
                    /// <para>/// @param Path Input path.</para>
                    /// <para>/// @returns errc::success if the path can be accessed, otherwise
                    /// a</para>
                    /// <para>///          platform-specific error_code.</para>
                    /// </remarks>
                    public static std.__1.error_code access(llvm.Twine Path, llvm.sys.fs.AccessMode Mode)
                    {
                        var arg0 = ReferenceEquals(Path, null) ? global::System.IntPtr.Zero : Path.__Instance;
                        var arg1 = Mode;
                        var __ret = Internal.access_0(arg0, arg1);
                        return std.__1.error_code.__CreateInstance(__ret);
                    }

                    /// <summary>
                    /// <para>Does file exist?</para>
                    /// </summary>
                    /// <remarks>
                    /// <para>/// @brief Does file exist?</para>
                    /// <para>///</para>
                    /// <para>/// @param Path Input path.</para>
                    /// <para>/// @returns True if it exists, false otherwise.</para>
                    /// </remarks>
                    public static bool exists(llvm.Twine Path)
                    {
                        var arg0 = ReferenceEquals(Path, null) ? global::System.IntPtr.Zero : Path.__Instance;
                        var __ret = Internal.exists_1(arg0);
                        return __ret;
                    }

                    /// <summary>
                    /// <para>Can we execute this file?</para>
                    /// </summary>
                    /// <remarks>
                    /// <para>/// @brief Can we execute this file?</para>
                    /// <para>///</para>
                    /// <para>/// @param Path Input path.</para>
                    /// <para>/// @returns True if we can execute it, false otherwise.</para>
                    /// </remarks>
                    public static bool can_execute(llvm.Twine Path)
                    {
                        var arg0 = ReferenceEquals(Path, null) ? global::System.IntPtr.Zero : Path.__Instance;
                        var __ret = Internal.can_execute_0(arg0);
                        return __ret;
                    }

                    /// <summary>
                    /// <para>Can we write this file?</para>
                    /// </summary>
                    /// <remarks>
                    /// <para>/// @brief Can we write this file?</para>
                    /// <para>///</para>
                    /// <para>/// @param Path Input path.</para>
                    /// <para>/// @returns True if we can write to it, false otherwise.</para>
                    /// </remarks>
                    public static bool can_write(llvm.Twine Path)
                    {
                        var arg0 = ReferenceEquals(Path, null) ? global::System.IntPtr.Zero : Path.__Instance;
                        var __ret = Internal.can_write_0(arg0);
                        return __ret;
                    }

                    /// <summary>
                    /// <para>Do paths represent the same thing?</para>
                    /// </summary>
                    /// <remarks>
                    /// <para>/// @brief Do paths represent the same thing?</para>
                    /// <para>///</para>
                    /// <para>/// assert(status_known(A) || status_known(B));</para>
                    /// <para>///</para>
                    /// <para>/// @param A Input path A.</para>
                    /// <para>/// @param B Input path B.</para>
                    /// <para>/// @param result Set to true if stat(A) and stat(B) have the
                    /// same device and</para>
                    /// <para>///               inode (or equivalent).</para>
                    /// <para>/// @returns errc::success if result has been successfully set,
                    /// otherwise a</para>
                    /// <para>///          platform-specific error_code.</para>
                    /// </remarks>
                    public static std.__1.error_code equivalent(llvm.Twine A, llvm.Twine B, ref bool result)
                    {
                        var arg0 = ReferenceEquals(A, null) ? global::System.IntPtr.Zero : A.__Instance;
                        var arg1 = ReferenceEquals(B, null) ? global::System.IntPtr.Zero : B.__Instance;
                        fixed (bool* arg2 = &result)
                        {
                            var __ret = Internal.equivalent_1(arg0, arg1, arg2);
                            return std.__1.error_code.__CreateInstance(__ret);
                        }
                    }

                    /// <summary>
                    /// <para>Simpler version of equivalent for clients that don't need to
                    /// differentiate between an error and false.</para>
                    /// </summary>
                    /// <remarks>
                    /// <para>/// @brief Simpler version of equivalent for clients that don't
                    /// need to</para>
                    /// <para>///        differentiate between an error and false.</para>
                    /// </remarks>
                    public static bool equivalent(llvm.Twine A, llvm.Twine B)
                    {
                        var arg0 = ReferenceEquals(A, null) ? global::System.IntPtr.Zero : A.__Instance;
                        var arg1 = ReferenceEquals(B, null) ? global::System.IntPtr.Zero : B.__Instance;
                        var __ret = Internal.equivalent_2(arg0, arg1);
                        return __ret;
                    }

                    /// <summary>
                    /// <para>Does status represent a directory?</para>
                    /// </summary>
                    /// <remarks>
                    /// <para>/// @brief Does status represent a directory?</para>
                    /// <para>///</para>
                    /// <para>/// @param status A file_status previously returned from
                    /// status.</para>
                    /// <para>/// @returns status.type() == file_type::directory_file.</para>
                    /// </remarks>
                    public static bool is_directory(llvm.sys.fs.file_status status)
                    {
                        var arg0 = ReferenceEquals(status, null) ? new llvm.sys.fs.file_status.Internal() : *(llvm.sys.fs.file_status.Internal*) (status.__Instance);
                        var __ret = Internal.is_directory_0(arg0);
                        return __ret;
                    }

                    /// <summary>
                    /// <para>Is path a directory?</para>
                    /// </summary>
                    /// <remarks>
                    /// <para>/// @brief Is path a directory?</para>
                    /// <para>///</para>
                    /// <para>/// @param path Input path.</para>
                    /// <para>/// @param result Set to true if \a path is a directory, false if
                    /// it is not.</para>
                    /// <para>///               Undefined otherwise.</para>
                    /// <para>/// @returns errc::success if result has been successfully set,
                    /// otherwise a</para>
                    /// <para>///          platform-specific error_code.</para>
                    /// </remarks>
                    public static std.__1.error_code is_directory(llvm.Twine path, ref bool result)
                    {
                        var arg0 = ReferenceEquals(path, null) ? global::System.IntPtr.Zero : path.__Instance;
                        fixed (bool* arg1 = &result)
                        {
                            var __ret = Internal.is_directory_1(arg0, arg1);
                            return std.__1.error_code.__CreateInstance(__ret);
                        }
                    }

                    /// <summary>
                    /// <para>Simpler version of is_directory for clients that don't need to
                    /// differentiate between an error and false.</para>
                    /// </summary>
                    /// <remarks>
                    /// <para>/// @brief Simpler version of is_directory for clients that don't
                    /// need to</para>
                    /// <para>///        differentiate between an error and false.</para>
                    /// </remarks>
                    public static bool is_directory(llvm.Twine Path)
                    {
                        var arg0 = ReferenceEquals(Path, null) ? global::System.IntPtr.Zero : Path.__Instance;
                        var __ret = Internal.is_directory_2(arg0);
                        return __ret;
                    }

                    /// <summary>
                    /// <para>Does status represent a regular file?</para>
                    /// </summary>
                    /// <remarks>
                    /// <para>/// @brief Does status represent a regular file?</para>
                    /// <para>///</para>
                    /// <para>/// @param status A file_status previously returned from
                    /// status.</para>
                    /// <para>/// @returns status_known(status) &amp;&amp; status.type() ==
                    /// file_type::regular_file.</para>
                    /// </remarks>
                    public static bool is_regular_file(llvm.sys.fs.file_status status)
                    {
                        var arg0 = ReferenceEquals(status, null) ? new llvm.sys.fs.file_status.Internal() : *(llvm.sys.fs.file_status.Internal*) (status.__Instance);
                        var __ret = Internal.is_regular_file_0(arg0);
                        return __ret;
                    }

                    /// <summary>
                    /// <para>Is path a regular file?</para>
                    /// </summary>
                    /// <remarks>
                    /// <para>/// @brief Is path a regular file?</para>
                    /// <para>///</para>
                    /// <para>/// @param path Input path.</para>
                    /// <para>/// @param result Set to true if \a path is a regular file, false
                    /// if it is not.</para>
                    /// <para>///               Undefined otherwise.</para>
                    /// <para>/// @returns errc::success if result has been successfully set,
                    /// otherwise a</para>
                    /// <para>///          platform-specific error_code.</para>
                    /// </remarks>
                    public static std.__1.error_code is_regular_file(llvm.Twine path, ref bool result)
                    {
                        var arg0 = ReferenceEquals(path, null) ? global::System.IntPtr.Zero : path.__Instance;
                        fixed (bool* arg1 = &result)
                        {
                            var __ret = Internal.is_regular_file_1(arg0, arg1);
                            return std.__1.error_code.__CreateInstance(__ret);
                        }
                    }

                    /// <summary>
                    /// <para>Simpler version of is_regular_file for clients that don't need to
                    /// differentiate between an error and false.</para>
                    /// </summary>
                    /// <remarks>
                    /// <para>/// @brief Simpler version of is_regular_file for clients that
                    /// don't need to</para>
                    /// <para>///        differentiate between an error and false.</para>
                    /// </remarks>
                    public static bool is_regular_file(llvm.Twine Path)
                    {
                        var arg0 = ReferenceEquals(Path, null) ? global::System.IntPtr.Zero : Path.__Instance;
                        var __ret = Internal.is_regular_file_2(arg0);
                        return __ret;
                    }

                    /// <summary>
                    /// <para>Does this status represent something that exists but is not a
                    /// directory, regular file, or symlink?</para>
                    /// </summary>
                    /// <remarks>
                    /// <para>/// @brief Does this status represent something that exists but
                    /// is not a</para>
                    /// <para>///        directory, regular file, or symlink?</para>
                    /// <para>///</para>
                    /// <para>/// @param status A file_status previously returned from
                    /// status.</para>
                    /// <para>/// @returns exists(s) &amp;&amp; !is_regular_file(s) &amp;&amp;
                    /// !is_directory(s)</para>
                    /// </remarks>
                    public static bool is_other(llvm.sys.fs.file_status status)
                    {
                        var arg0 = ReferenceEquals(status, null) ? new llvm.sys.fs.file_status.Internal() : *(llvm.sys.fs.file_status.Internal*) (status.__Instance);
                        var __ret = Internal.is_other_0(arg0);
                        return __ret;
                    }

                    /// <summary>
                    /// <para>Is path something that exists but is not a directory, regular
                    /// file, or symlink?</para>
                    /// </summary>
                    /// <remarks>
                    /// <para>/// @brief Is path something that exists but is not a
                    /// directory,</para>
                    /// <para>///        regular file, or symlink?</para>
                    /// <para>///</para>
                    /// <para>/// @param path Input path.</para>
                    /// <para>/// @param result Set to true if \a path exists, but is not a
                    /// directory, regular</para>
                    /// <para>///               file, or a symlink, false if it does not.
                    /// Undefined otherwise.</para>
                    /// <para>/// @returns errc::success if result has been successfully set,
                    /// otherwise a</para>
                    /// <para>///          platform-specific error_code.</para>
                    /// </remarks>
                    public static std.__1.error_code is_other(llvm.Twine path, ref bool result)
                    {
                        var arg0 = ReferenceEquals(path, null) ? global::System.IntPtr.Zero : path.__Instance;
                        fixed (bool* arg1 = &result)
                        {
                            var __ret = Internal.is_other_1(arg0, arg1);
                            return std.__1.error_code.__CreateInstance(__ret);
                        }
                    }

                    /// <summary>
                    /// <para>Get file status as if by POSIX stat().</para>
                    /// </summary>
                    /// <remarks>
                    /// <para>/// @brief Get file status as if by POSIX stat().</para>
                    /// <para>///</para>
                    /// <para>/// @param path Input path.</para>
                    /// <para>/// @param result Set to the file status.</para>
                    /// <para>/// @returns errc::success if result has been successfully set,
                    /// otherwise a</para>
                    /// <para>///          platform-specific error_code.</para>
                    /// </remarks>
                    public static std.__1.error_code status(llvm.Twine path, llvm.sys.fs.file_status result)
                    {
                        var arg0 = ReferenceEquals(path, null) ? global::System.IntPtr.Zero : path.__Instance;
                        var arg1 = ReferenceEquals(result, null) ? global::System.IntPtr.Zero : result.__Instance;
                        var __ret = Internal.status_0(arg0, arg1);
                        return std.__1.error_code.__CreateInstance(__ret);
                    }

                    /// <summary>
                    /// <para>A version for when a file descriptor is already available.</para>
                    /// </summary>
                    /// <remarks>
                    /// <para>/// @brief A version for when a file descriptor is already
                    /// available.</para>
                    /// </remarks>
                    public static std.__1.error_code status(int FD, llvm.sys.fs.file_status Result)
                    {
                        var arg1 = ReferenceEquals(Result, null) ? global::System.IntPtr.Zero : Result.__Instance;
                        var __ret = Internal.status_1(FD, arg1);
                        return std.__1.error_code.__CreateInstance(__ret);
                    }

                    /// <summary>
                    /// <para>Get file size.</para>
                    /// </summary>
                    /// <remarks>
                    /// <para>/// @brief Get file size.</para>
                    /// <para>///</para>
                    /// <para>/// @param Path Input path.</para>
                    /// <para>/// @param Result Set to the size of the file in \a Path.</para>
                    /// <para>/// @returns errc::success if result has been successfully set,
                    /// otherwise a</para>
                    /// <para>///          platform-specific error_code.</para>
                    /// </remarks>
                    public static std.__1.error_code file_size(llvm.Twine Path, ref ulong Result)
                    {
                        var arg0 = ReferenceEquals(Path, null) ? global::System.IntPtr.Zero : Path.__Instance;
                        fixed (ulong* arg1 = &Result)
                        {
                            var __ret = Internal.file_size_0(arg0, arg1);
                            return std.__1.error_code.__CreateInstance(__ret);
                        }
                    }

                    /// <summary>
                    /// <para>Set the file modification and access time.</para>
                    /// </summary>
                    /// <remarks>
                    /// <para>/// @brief Set the file modification and access time.</para>
                    /// <para>///</para>
                    /// <para>/// @returns errc::success if the file times were successfully
                    /// set, otherwise a</para>
                    /// <para>///          platform-specific error_code or
                    /// errc::function_not_supported on</para>
                    /// <para>///          platforms where the functionality isn't
                    /// available.</para>
                    /// </remarks>
                    public static std.__1.error_code setLastModificationAndAccessTime(int FD, llvm.sys.TimeValue Time)
                    {
                        var arg1 = ReferenceEquals(Time, null) ? new llvm.sys.TimeValue.Internal() : *(llvm.sys.TimeValue.Internal*) (Time.__Instance);
                        var __ret = Internal.setLastModificationAndAccessTime_0(FD, arg1);
                        return std.__1.error_code.__CreateInstance(__ret);
                    }

                    /// <summary>
                    /// <para>Is status available?</para>
                    /// </summary>
                    /// <remarks>
                    /// <para>/// @brief Is status available?</para>
                    /// <para>///</para>
                    /// <para>/// @param s Input file status.</para>
                    /// <para>/// @returns True if status() != status_error.</para>
                    /// </remarks>
                    public static bool status_known(llvm.sys.fs.file_status s)
                    {
                        var arg0 = ReferenceEquals(s, null) ? new llvm.sys.fs.file_status.Internal() : *(llvm.sys.fs.file_status.Internal*) (s.__Instance);
                        var __ret = Internal.status_known_0(arg0);
                        return __ret;
                    }

                    /// <summary>
                    /// <para>Is status available?</para>
                    /// </summary>
                    /// <remarks>
                    /// <para>/// @brief Is status available?</para>
                    /// <para>///</para>
                    /// <para>/// @param path Input path.</para>
                    /// <para>/// @param result Set to true if status() != status_error.</para>
                    /// <para>/// @returns errc::success if result has been successfully set,
                    /// otherwise a</para>
                    /// <para>///          platform-specific error_code.</para>
                    /// </remarks>
                    public static std.__1.error_code status_known(llvm.Twine path, ref bool result)
                    {
                        var arg0 = ReferenceEquals(path, null) ? global::System.IntPtr.Zero : path.__Instance;
                        fixed (bool* arg1 = &result)
                        {
                            var __ret = Internal.status_known_1(arg0, arg1);
                            return std.__1.error_code.__CreateInstance(__ret);
                        }
                    }

                    public static std.__1.error_code openFileForWrite(llvm.Twine Name, ref int ResultFD, llvm.sys.fs.OpenFlags Flags, uint Mode)
                    {
                        var arg0 = ReferenceEquals(Name, null) ? global::System.IntPtr.Zero : Name.__Instance;
                        fixed (int* arg1 = &ResultFD)
                        {
                            var arg2 = Flags;
                            var __ret = Internal.openFileForWrite_0(arg0, arg1, arg2, Mode);
                            return std.__1.error_code.__CreateInstance(__ret);
                        }
                    }

                    public static std.__1.error_code openFileForRead(llvm.Twine Name, ref int ResultFD)
                    {
                        var arg0 = ReferenceEquals(Name, null) ? global::System.IntPtr.Zero : Name.__Instance;
                        fixed (int* arg1 = &ResultFD)
                        {
                            var __ret = Internal.openFileForRead_0(arg0, arg1);
                            return std.__1.error_code.__CreateInstance(__ret);
                        }
                    }

                    /// <summary>
                    /// <para>Identify the type of a binary file based on how magical it
                    /// is.</para>
                    /// </summary>
                    /// <remarks>
                    /// <para>/// @brief Identify the type of a binary file based on how
                    /// magical it is.</para>
                    /// </remarks>
                    public static llvm.sys.fs.file_magic identify_magic(llvm.StringRef magic)
                    {
                        var arg0 = ReferenceEquals(magic, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (magic.__Instance);
                        var __ret = Internal.identify_magic_0(arg0);
                        return llvm.sys.fs.file_magic.__CreateInstance(__ret);
                    }

                    /// <summary>
                    /// <para>Get and identify path's type based on its content.</para>
                    /// </summary>
                    /// <remarks>
                    /// <para>/// @brief Get and identify \a path's type based on its
                    /// content.</para>
                    /// <para>///</para>
                    /// <para>/// @param path Input path.</para>
                    /// <para>/// @param result Set to the type of file, or
                    /// file_magic::unknown.</para>
                    /// <para>/// @returns errc::success if result has been successfully set,
                    /// otherwise a</para>
                    /// <para>///          platform-specific error_code.</para>
                    /// </remarks>
                    public static std.__1.error_code identify_magic(llvm.Twine path, llvm.sys.fs.file_magic result)
                    {
                        var arg0 = ReferenceEquals(path, null) ? global::System.IntPtr.Zero : path.__Instance;
                        var arg1 = ReferenceEquals(result, null) ? global::System.IntPtr.Zero : result.__Instance;
                        var __ret = Internal.identify_magic_1(arg0, arg1);
                        return std.__1.error_code.__CreateInstance(__ret);
                    }

                    public static std.__1.error_code getUniqueID(llvm.Twine Path, llvm.sys.fs.UniqueID Result)
                    {
                        var arg0 = ReferenceEquals(Path, null) ? new llvm.Twine.Internal() : *(llvm.Twine.Internal*) (Path.__Instance);
                        var arg1 = ReferenceEquals(Result, null) ? global::System.IntPtr.Zero : Result.__Instance;
                        var __ret = Internal.getUniqueID_0(arg0, arg1);
                        return std.__1.error_code.__CreateInstance(__ret);
                    }
                }

                namespace detail
                {
                    /// <summary>
                    /// <para>DirIterState - Keeps state for the directory_iterator. It is
                    /// reference counted in order to preserve InputIterator semantics on
                    /// copy.</para>
                    /// </summary>
                    /// <remarks>
                    /// <para>/// DirIterState - Keeps state for the directory_iterator. It is
                    /// reference</para>
                    /// <para>  /// counted in order to preserve InputIterator semantics on
                    /// copy.</para>
                    /// </remarks>
                    public unsafe partial class DirIterState : IDisposable
                    {
                        [StructLayout(LayoutKind.Explicit, Size = 60)]
                        public partial struct Internal
                        {
                            [FieldOffset(4)]
                            public int IterationHandle;

                            [FieldOffset(8)]
                            public llvm.sys.fs.directory_entry.Internal CurrentEntry;

                            [SuppressUnmanagedCodeSecurity]
                            [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                                EntryPoint="_ZN4llvm3sys2fs6detail12DirIterStateC2Ev")]
                            internal static extern void ctor_0(global::System.IntPtr instance);

                            [SuppressUnmanagedCodeSecurity]
                            [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                                EntryPoint="_ZN4llvm3sys2fs6detail12DirIterStateC2ERKS3_")]
                            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                            [SuppressUnmanagedCodeSecurity]
                            [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                                EntryPoint="_ZN4llvm3sys2fs6detail12DirIterStateD2Ev")]
                            internal static extern void dtor_0(global::System.IntPtr instance);
                        }

                        public global::System.IntPtr __Instance { get; protected set; }
                        public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, DirIterState> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, DirIterState>();

                        private readonly bool __ownsNativeInstance;

                        public static DirIterState __CreateInstance(global::System.IntPtr native)
                        {
                            return new DirIterState((DirIterState.Internal*) native);
                        }

                        public static DirIterState __CreateInstance(DirIterState.Internal native)
                        {
                            return new DirIterState(native);
                        }

                        private static DirIterState.Internal* __CopyValue(DirIterState.Internal native)
                        {
                            var ret = (DirIterState.Internal*) Marshal.AllocHGlobal(60);
                            *ret = native;
                            return ret;
                        }

                        private DirIterState(DirIterState.Internal native)
                            : this(__CopyValue(native))
                        {
                            __ownsNativeInstance = true;
                            NativeToManagedMap[__Instance] = this;
                        }

                        protected DirIterState(DirIterState.Internal* native, bool isInternalImpl = false)
                        {
                            __Instance = new global::System.IntPtr(native);
                        }

                        public DirIterState()
                        {
                            __Instance = Marshal.AllocHGlobal(60);
                            __ownsNativeInstance = true;
                            NativeToManagedMap[__Instance] = this;
                            Internal.ctor_0(__Instance);
                        }

                        public void Dispose()
                        {
                            Dispose(disposing: true);
                        }

                        protected virtual void Dispose(bool disposing)
                        {
                            DestroyNativeInstance(false);
                        }

                        public virtual void DestroyNativeInstance()
                        {
                            DestroyNativeInstance(true);
                        }

                        private void DestroyNativeInstance(bool force)
                        {
                            llvm.sys.fs.detail.DirIterState __dummy;
                            NativeToManagedMap.TryRemove(__Instance, out __dummy);
                            if (__ownsNativeInstance || force)
                                Internal.dtor_0(__Instance);
                            if (__ownsNativeInstance)
                                Marshal.FreeHGlobal(__Instance);
                        }

                        public int IterationHandle
                        {
                            get
                            {
                                return ((Internal*) __Instance)->IterationHandle;
                            }

                            set
                            {
                                ((Internal*) __Instance)->IterationHandle = value;
                            }
                        }

                        public llvm.sys.fs.directory_entry CurrentEntry
                        {
                            get
                            {
                                return llvm.sys.fs.directory_entry.__CreateInstance(((Internal*) __Instance)->CurrentEntry);
                            }

                            set
                            {
                                ((Internal*) __Instance)->CurrentEntry = ReferenceEquals(value, null) ? new llvm.sys.fs.directory_entry.Internal() : *(llvm.sys.fs.directory_entry.Internal*) (value.__Instance);
                            }
                        }
                    }

                    /// <summary>
                    /// <para>RecDirIterState - Keeps state for the
                    /// recursive_directory_iterator. It is reference counted in order to preserve
                    /// InputIterator semantics on copy.</para>
                    /// </summary>
                    /// <remarks>
                    /// <para>/// RecDirIterState - Keeps state for the
                    /// recursive_directory_iterator. It is</para>
                    /// <para>  /// reference counted in order to preserve InputIterator
                    /// semantics on copy.</para>
                    /// </remarks>
                    public unsafe partial class RecDirIterState : IDisposable
                    {
                        [StructLayout(LayoutKind.Explicit, Size = 20)]
                        public partial struct Internal
                        {
                            [FieldOffset(16)]
                            public ushort Level;

                            [FieldOffset(18)]
                            public bool HasNoPushRequest;

                            [SuppressUnmanagedCodeSecurity]
                            [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                                EntryPoint="_ZN4llvm3sys2fs6detail15RecDirIterStateC2Ev")]
                            internal static extern void ctor_0(global::System.IntPtr instance);

                            [SuppressUnmanagedCodeSecurity]
                            [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                                EntryPoint="_ZN4llvm3sys2fs6detail15RecDirIterStateC2ERKS3_")]
                            internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                            [SuppressUnmanagedCodeSecurity]
                            [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                                EntryPoint="_ZN4llvm3sys2fs6detail15RecDirIterStateD2Ev")]
                            internal static extern void dtor_0(global::System.IntPtr instance);
                        }

                        public global::System.IntPtr __Instance { get; protected set; }
                        public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, RecDirIterState> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, RecDirIterState>();

                        private readonly bool __ownsNativeInstance;

                        public static RecDirIterState __CreateInstance(global::System.IntPtr native)
                        {
                            return new RecDirIterState((RecDirIterState.Internal*) native);
                        }

                        public static RecDirIterState __CreateInstance(RecDirIterState.Internal native)
                        {
                            return new RecDirIterState(native);
                        }

                        private static RecDirIterState.Internal* __CopyValue(RecDirIterState.Internal native)
                        {
                            var ret = (RecDirIterState.Internal*) Marshal.AllocHGlobal(20);
                            *ret = native;
                            return ret;
                        }

                        private RecDirIterState(RecDirIterState.Internal native)
                            : this(__CopyValue(native))
                        {
                            __ownsNativeInstance = true;
                            NativeToManagedMap[__Instance] = this;
                        }

                        protected RecDirIterState(RecDirIterState.Internal* native, bool isInternalImpl = false)
                        {
                            __Instance = new global::System.IntPtr(native);
                        }

                        public RecDirIterState()
                        {
                            __Instance = Marshal.AllocHGlobal(20);
                            __ownsNativeInstance = true;
                            NativeToManagedMap[__Instance] = this;
                            Internal.ctor_0(__Instance);
                        }

                        public void Dispose()
                        {
                            Dispose(disposing: true);
                        }

                        protected virtual void Dispose(bool disposing)
                        {
                            DestroyNativeInstance(false);
                        }

                        public virtual void DestroyNativeInstance()
                        {
                            DestroyNativeInstance(true);
                        }

                        private void DestroyNativeInstance(bool force)
                        {
                            llvm.sys.fs.detail.RecDirIterState __dummy;
                            NativeToManagedMap.TryRemove(__Instance, out __dummy);
                            if (__ownsNativeInstance || force)
                                Internal.dtor_0(__Instance);
                            if (__ownsNativeInstance)
                                Marshal.FreeHGlobal(__Instance);
                        }

                        public ushort Level
                        {
                            get
                            {
                                return ((Internal*) __Instance)->Level;
                            }

                            set
                            {
                                ((Internal*) __Instance)->Level = value;
                            }
                        }

                        public bool HasNoPushRequest
                        {
                            get
                            {
                                return ((Internal*) __Instance)->HasNoPushRequest;
                            }

                            set
                            {
                                ((Internal*) __Instance)->HasNoPushRequest = value;
                            }
                        }
                    }

                    public unsafe partial class FileSystem
                    {
                        public partial struct Internal
                        {
                            [SuppressUnmanagedCodeSecurity]
                            [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                                EntryPoint="_ZN4llvm3sys2fs6detail28directory_iterator_constructERNS2_12DirIterStateENS_9StringRefE")]
                            internal static extern std.__1.error_code.Internal directory_iterator_construct_0(global::System.IntPtr _0, llvm.StringRef.Internal _1);

                            [SuppressUnmanagedCodeSecurity]
                            [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                                EntryPoint="_ZN4llvm3sys2fs6detail28directory_iterator_incrementERNS2_12DirIterStateE")]
                            internal static extern std.__1.error_code.Internal directory_iterator_increment_0(global::System.IntPtr _0);

                            [SuppressUnmanagedCodeSecurity]
                            [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                                EntryPoint="_ZN4llvm3sys2fs6detail27directory_iterator_destructERNS2_12DirIterStateE")]
                            internal static extern std.__1.error_code.Internal directory_iterator_destruct_0(global::System.IntPtr _0);
                        }

                        public static std.__1.error_code directory_iterator_construct(llvm.sys.fs.detail.DirIterState _0, llvm.StringRef _1)
                        {
                            var arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
                            var arg1 = ReferenceEquals(_1, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (_1.__Instance);
                            var __ret = Internal.directory_iterator_construct_0(arg0, arg1);
                            return std.__1.error_code.__CreateInstance(__ret);
                        }

                        public static std.__1.error_code directory_iterator_increment(llvm.sys.fs.detail.DirIterState _0)
                        {
                            var arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
                            var __ret = Internal.directory_iterator_increment_0(arg0);
                            return std.__1.error_code.__CreateInstance(__ret);
                        }

                        public static std.__1.error_code directory_iterator_destruct(llvm.sys.fs.detail.DirIterState _0)
                        {
                            var arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
                            var __ret = Internal.directory_iterator_destruct_0(arg0);
                            return std.__1.error_code.__CreateInstance(__ret);
                        }
                    }
                }
            }
        }
    }
}
