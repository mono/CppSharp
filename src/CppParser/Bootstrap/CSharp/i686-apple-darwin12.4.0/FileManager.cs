//----------------------------------------------------------------------------
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
//----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace CppSharp
{
    namespace clang
    {
        /// <summary>
        /// <para>Cached information about one directory (either on disk or in the
        /// virtual file system).</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief Cached information about one directory (either on disk
        /// or in</para>
        /// <para>/// the virtual file system).</para>
        /// </remarks>
        public unsafe partial class DirectoryEntry : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 4)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr Name;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14DirectoryEntryC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14DirectoryEntryC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14DirectoryEntry7getNameEv")]
                internal static extern global::System.IntPtr getName_0(global::System.IntPtr instance);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, DirectoryEntry> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, DirectoryEntry>();

            private readonly bool __ownsNativeInstance;

            public static DirectoryEntry __CreateInstance(global::System.IntPtr native)
            {
                return new DirectoryEntry((DirectoryEntry.Internal*) native);
            }

            public static DirectoryEntry __CreateInstance(DirectoryEntry.Internal native)
            {
                return new DirectoryEntry(native);
            }

            private static DirectoryEntry.Internal* __CopyValue(DirectoryEntry.Internal native)
            {
                var ret = (DirectoryEntry.Internal*) Marshal.AllocHGlobal(4);
                *ret = native;
                return ret;
            }

            private DirectoryEntry(DirectoryEntry.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected DirectoryEntry(DirectoryEntry.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public DirectoryEntry()
            {
                __Instance = Marshal.AllocHGlobal(4);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.DirectoryEntry __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public string getName()
            {
                var __ret = Internal.getName_0(__Instance);
                return Marshal.PtrToStringAnsi(__ret);
            }
        }

        /// <summary>
        /// <para>Cached information about one file (either on disk or in the
        /// virtual file system).</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief Cached information about one file (either on
        /// disk</para>
        /// <para>/// or in the virtual file system).</para>
        /// <para>///</para>
        /// <para>/// If the 'File' member is valid, then this FileEntry has an
        /// open file</para>
        /// <para>/// descriptor for the file.</para>
        /// </remarks>
        public unsafe partial class FileEntry : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 48)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr Name;

                [FieldOffset(4)]
                public long Size;

                [FieldOffset(12)]
                public int ModTime;

                [FieldOffset(16)]
                public global::System.IntPtr Dir;

                [FieldOffset(20)]
                public uint UID;

                [FieldOffset(24)]
                public llvm.sys.fs.UniqueID.Internal UniqueID;

                [FieldOffset(40)]
                public bool IsNamedPipe;

                [FieldOffset(41)]
                public bool InPCH;

                [FieldOffset(42)]
                public bool IsValid;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9FileEntryC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9FileEntryC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr FE);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9FileEntryD2Ev")]
                internal static extern void dtor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9FileEntry7getNameEv")]
                internal static extern global::System.IntPtr getName_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9FileEntry7isValidEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isValid_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9FileEntry7getSizeEv")]
                internal static extern long getSize_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9FileEntry6getUIDEv")]
                internal static extern uint getUID_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9FileEntry11getUniqueIDEv")]
                internal static extern global::System.IntPtr getUniqueID_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9FileEntry7isInPCHEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isInPCH_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9FileEntry19getModificationTimeEv")]
                internal static extern int getModificationTime_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9FileEntry6getDirEv")]
                internal static extern global::System.IntPtr getDir_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9FileEntryltERKS0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorLess_0(global::System.IntPtr instance, global::System.IntPtr RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9FileEntry11isNamedPipeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isNamedPipe_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9FileEntry9closeFileEv")]
                internal static extern void closeFile_0(global::System.IntPtr instance);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, FileEntry> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, FileEntry>();

            private readonly bool __ownsNativeInstance;

            public static FileEntry __CreateInstance(global::System.IntPtr native)
            {
                return new FileEntry((FileEntry.Internal*) native);
            }

            public static FileEntry __CreateInstance(FileEntry.Internal native)
            {
                return new FileEntry(native);
            }

            private static FileEntry.Internal* __CopyValue(FileEntry.Internal native)
            {
                var ret = (FileEntry.Internal*) Marshal.AllocHGlobal(48);
                *ret = native;
                return ret;
            }

            private FileEntry(FileEntry.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected FileEntry(FileEntry.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public FileEntry()
            {
                __Instance = Marshal.AllocHGlobal(48);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.FileEntry __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance || force)
                    Internal.dtor_0(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public string getName()
            {
                var __ret = Internal.getName_0(__Instance);
                return Marshal.PtrToStringAnsi(__ret);
            }

            public bool isValid()
            {
                var __ret = Internal.isValid_0(__Instance);
                return __ret;
            }

            public long getSize()
            {
                var __ret = Internal.getSize_0(__Instance);
                return __ret;
            }

            public uint getUID()
            {
                var __ret = Internal.getUID_0(__Instance);
                return __ret;
            }

            public llvm.sys.fs.UniqueID getUniqueID()
            {
                var __ret = Internal.getUniqueID_0(__Instance);
                llvm.sys.fs.UniqueID __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (llvm.sys.fs.UniqueID.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (llvm.sys.fs.UniqueID) llvm.sys.fs.UniqueID.NativeToManagedMap[__ret];
                else __result0 = llvm.sys.fs.UniqueID.__CreateInstance(__ret);
                return __result0;
            }

            public bool isInPCH()
            {
                var __ret = Internal.isInPCH_0(__Instance);
                return __ret;
            }

            public int getModificationTime()
            {
                var __ret = Internal.getModificationTime_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Return the directory the file lives in.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the directory the file lives in.</para>
            /// </remarks>
            public clang.DirectoryEntry getDir()
            {
                var __ret = Internal.getDir_0(__Instance);
                clang.DirectoryEntry __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.DirectoryEntry.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.DirectoryEntry) clang.DirectoryEntry.NativeToManagedMap[__ret];
                else __result0 = clang.DirectoryEntry.__CreateInstance(__ret);
                return __result0;
            }

            public static bool operator >(clang.FileEntry __op, clang.FileEntry RHS)
            {
                return !(__op < RHS);
            }

            public static bool operator <(clang.FileEntry __op, clang.FileEntry RHS)
            {
                var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
                var arg1 = ReferenceEquals(RHS, null) ? global::System.IntPtr.Zero : RHS.__Instance;
                var __ret = Internal.OperatorLess_0(arg0, arg1);
                return __ret;
            }

            /// <summary>
            /// <para>Check whether the file is a named pipe (and thus can't be opened
            /// by the native FileManager methods).</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Check whether the file is a named pipe (and thus can't
            /// be opened by</para>
            /// <para>  /// the native FileManager methods).</para>
            /// </remarks>
            public bool isNamedPipe()
            {
                var __ret = Internal.isNamedPipe_0(__Instance);
                return __ret;
            }

            public void closeFile()
            {
                Internal.closeFile_0(__Instance);
            }
        }

        /// <summary>
        /// <para>Implements support for file system lookup, file system caching,
        /// and directory search management.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief Implements support for file system lookup, file system
        /// caching,</para>
        /// <para>/// and directory search management.</para>
        /// <para>///</para>
        /// <para>/// This also handles more advanced properties, such as uniquing
        /// files based</para>
        /// <para>/// on &quot;inode&quot;, so that a file with two names (e.g.
        /// symlinked) will be treated</para>
        /// <para>/// as a single file.</para>
        /// <para>///</para>
        /// </remarks>
        public unsafe partial class FileManager : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 384)]
            public partial struct Internal
            {
                [FieldOffset(4)]
                internal llvm.IntrusiveRefCntPtr.Internal FS;

                [FieldOffset(8)]
                public clang.FileSystemOptions.Internal FileSystemOpts;

                [FieldOffset(44)]
                internal llvm.SmallVector.Internal VirtualDirectoryEntries;

                [FieldOffset(72)]
                internal llvm.SmallVector.Internal VirtualFileEntries;

                [FieldOffset(100)]
                internal llvm.StringMap.Internal SeenDirEntries;

                [FieldOffset(188)]
                internal llvm.StringMap.Internal SeenFileEntries;

                [FieldOffset(276)]
                internal llvm.DenseMap.Internal CanonicalDirNames;

                [FieldOffset(292)]
                internal llvm.BumpPtrAllocatorImpl.Internal CanonicalNameStorage;

                [FieldOffset(360)]
                public uint NextFileUID;

                [FieldOffset(364)]
                public uint NumDirLookups;

                [FieldOffset(368)]
                public uint NumFileLookups;

                [FieldOffset(372)]
                public uint NumDirCacheMisses;

                [FieldOffset(376)]
                public uint NumFileCacheMisses;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11FileManagerC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11FileManagerD2Ev")]
                internal static extern void dtor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11FileManager15clearStatCachesEv")]
                internal static extern void clearStatCaches_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11FileManager12getDirectoryEN4llvm9StringRefEb")]
                internal static extern global::System.IntPtr getDirectory_0(global::System.IntPtr instance, llvm.StringRef.Internal DirName, bool CacheFailure);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11FileManager7getFileEN4llvm9StringRefEbb")]
                internal static extern global::System.IntPtr getFile_0(global::System.IntPtr instance, llvm.StringRef.Internal Filename, bool OpenFile, bool CacheFailure);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11FileManager20getFileSystemOptionsEv")]
                internal static extern global::System.IntPtr getFileSystemOptions_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11FileManager14getVirtualFileEN4llvm9StringRefExl")]
                internal static extern global::System.IntPtr getVirtualFile_0(global::System.IntPtr instance, llvm.StringRef.Internal Filename, long Size, int ModificationTime);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11FileManager21getNoncachedStatValueEN4llvm9StringRefERNS_3vfs6StatusE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool getNoncachedStatValue_0(global::System.IntPtr instance, llvm.StringRef.Internal Path, global::System.IntPtr Result);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11FileManager15invalidateCacheEPKNS_9FileEntryE")]
                internal static extern void invalidateCache_0(global::System.IntPtr instance, global::System.IntPtr Entry);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11FileManager15modifyFileEntryEPNS_9FileEntryExl")]
                internal static extern void modifyFileEntry_0(global::System.IntPtr File, long Size, int ModificationTime);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11FileManager16getCanonicalNameEPKNS_14DirectoryEntryE")]
                internal static extern llvm.StringRef.Internal getCanonicalName_0(global::System.IntPtr instance, global::System.IntPtr Dir);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11FileManager10PrintStatsEv")]
                internal static extern void PrintStats_0(global::System.IntPtr instance);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, FileManager> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, FileManager>();

            private readonly bool __ownsNativeInstance;

            public static FileManager __CreateInstance(global::System.IntPtr native)
            {
                return new FileManager((FileManager.Internal*) native);
            }

            public static FileManager __CreateInstance(FileManager.Internal native)
            {
                return new FileManager(native);
            }

            private static FileManager.Internal* __CopyValue(FileManager.Internal native)
            {
                var ret = (FileManager.Internal*) Marshal.AllocHGlobal(384);
                *ret = native;
                return ret;
            }

            private FileManager(FileManager.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected FileManager(FileManager.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.FileManager __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance || force)
                    Internal.dtor_0(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            /// <summary>
            /// <para>Removes all FileSystemStatCache objects from the manager.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Removes all FileSystemStatCache objects from the
            /// manager.</para>
            /// </remarks>
            public void clearStatCaches()
            {
                Internal.clearStatCaches_0(__Instance);
            }

            /// <summary>
            /// <para>Lookup, cache, and verify the specified directory (real or
            /// virtual).</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Lookup, cache, and verify the specified directory
            /// (real or</para>
            /// <para>  /// virtual).</para>
            /// <para>  ///</para>
            /// <para>  /// This returns NULL if the directory doesn't exist.</para>
            /// <para>  ///</para>
            /// <para>  /// \param CacheFailure If true and the file does not exist,
            /// we'll cache</para>
            /// <para>  /// the failure to find this file.</para>
            /// </remarks>
            public clang.DirectoryEntry getDirectory(llvm.StringRef DirName, bool CacheFailure)
            {
                var arg0 = ReferenceEquals(DirName, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (DirName.__Instance);
                var __ret = Internal.getDirectory_0(__Instance, arg0, CacheFailure);
                clang.DirectoryEntry __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.DirectoryEntry.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.DirectoryEntry) clang.DirectoryEntry.NativeToManagedMap[__ret];
                else __result0 = clang.DirectoryEntry.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Lookup, cache, and verify the specified file (real or
            /// virtual).</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Lookup, cache, and verify the specified file (real
            /// or</para>
            /// <para>  /// virtual).</para>
            /// <para>  ///</para>
            /// <para>  /// This returns NULL if the file doesn't exist.</para>
            /// <para>  ///</para>
            /// <para>  /// \param OpenFile if true and the file exists, it will be
            /// opened.</para>
            /// <para>  ///</para>
            /// <para>  /// \param CacheFailure If true and the file does not exist,
            /// we'll cache</para>
            /// <para>  /// the failure to find this file.</para>
            /// </remarks>
            public clang.FileEntry getFile(llvm.StringRef Filename, bool OpenFile, bool CacheFailure)
            {
                var arg0 = ReferenceEquals(Filename, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (Filename.__Instance);
                var __ret = Internal.getFile_0(__Instance, arg0, OpenFile, CacheFailure);
                clang.FileEntry __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.FileEntry.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.FileEntry) clang.FileEntry.NativeToManagedMap[__ret];
                else __result0 = clang.FileEntry.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Returns the current file system options</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Returns the current file system options</para>
            /// </remarks>
            public clang.FileSystemOptions getFileSystemOptions()
            {
                var __ret = Internal.getFileSystemOptions_0(__Instance);
                clang.FileSystemOptions __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.FileSystemOptions.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.FileSystemOptions) clang.FileSystemOptions.NativeToManagedMap[__ret];
                else __result0 = clang.FileSystemOptions.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Retrieve a file entry for a &quot;virtual&quot; file that acts as
            /// if there were a file with the given name on disk.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve a file entry for a &quot;virtual&quot; file
            /// that acts as</para>
            /// <para>  /// if there were a file with the given name on disk.</para>
            /// <para>  ///</para>
            /// <para>  /// The file itself is not accessed.</para>
            /// </remarks>
            public clang.FileEntry getVirtualFile(llvm.StringRef Filename, long Size, int ModificationTime)
            {
                var arg0 = ReferenceEquals(Filename, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (Filename.__Instance);
                var arg1 = Size;
                var arg2 = ModificationTime;
                var __ret = Internal.getVirtualFile_0(__Instance, arg0, arg1, arg2);
                clang.FileEntry __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.FileEntry.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.FileEntry) clang.FileEntry.NativeToManagedMap[__ret];
                else __result0 = clang.FileEntry.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Get the 'stat' information for the given Path.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Get the 'stat' information for the given \p
            /// Path.</para>
            /// <para>  ///</para>
            /// <para>  /// If the path is relative, it will be resolved against the
            /// WorkingDir of the</para>
            /// <para>  /// FileManager's FileSystemOptions.</para>
            /// <para>  ///</para>
            /// <para>  /// \returns false on success, true on error.</para>
            /// </remarks>
            public bool getNoncachedStatValue(llvm.StringRef Path, clang.vfs.Status Result)
            {
                var arg0 = ReferenceEquals(Path, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (Path.__Instance);
                var arg1 = ReferenceEquals(Result, null) ? global::System.IntPtr.Zero : Result.__Instance;
                var __ret = Internal.getNoncachedStatValue_0(__Instance, arg0, arg1);
                return __ret;
            }

            /// <summary>
            /// <para>Remove the real file Entry from the cache.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Remove the real file \p Entry from the cache.</para>
            /// </remarks>
            public void invalidateCache(clang.FileEntry Entry)
            {
                var arg0 = ReferenceEquals(Entry, null) ? global::System.IntPtr.Zero : Entry.__Instance;
                Internal.invalidateCache_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>Retrieve the canonical name for a given directory.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the canonical name for a given
            /// directory.</para>
            /// <para>  ///</para>
            /// <para>  /// This is a very expensive operation, despite its results
            /// being cached,</para>
            /// <para>  /// and should only be used when the physical layout of the
            /// file system is</para>
            /// <para>  /// required, which is (almost) never.</para>
            /// </remarks>
            public llvm.StringRef getCanonicalName(clang.DirectoryEntry Dir)
            {
                var arg0 = ReferenceEquals(Dir, null) ? global::System.IntPtr.Zero : Dir.__Instance;
                var __ret = Internal.getCanonicalName_0(__Instance, arg0);
                return llvm.StringRef.__CreateInstance(__ret);
            }

            public void PrintStats()
            {
                Internal.PrintStats_0(__Instance);
            }

            /// <summary>
            /// <para>Modifies the size and modification time of a previously created
            /// FileEntry. Use with caution.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Modifies the size and modification time of a
            /// previously created</para>
            /// <para>  /// FileEntry. Use with caution.</para>
            /// </remarks>
            public static void modifyFileEntry(clang.FileEntry File, long Size, int ModificationTime)
            {
                var arg0 = ReferenceEquals(File, null) ? global::System.IntPtr.Zero : File.__Instance;
                var arg1 = Size;
                var arg2 = ModificationTime;
                Internal.modifyFileEntry_0(arg0, arg1, arg2);
            }
        }
    }

    namespace llvm
    {
    }
}
