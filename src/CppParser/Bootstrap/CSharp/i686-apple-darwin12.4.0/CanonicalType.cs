//----------------------------------------------------------------------------
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
//----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace CppSharp
{
    namespace clang
    {
        /// <summary>
        /// <para>DeclarationName - The name of a declaration. In the common case,
        /// this just stores an IdentifierInfo pointer to a normal name. However, it
        /// also provides encodings for Objective-C selectors (optimizing zero- and
        /// one-argument selectors, which make up 78% percent of all selectors in
        /// Cocoa.h) and special C++ names for constructors, destructors, and
        /// conversion functions.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// DeclarationName - The name of a declaration. In the common
        /// case,</para>
        /// <para>/// this just stores an IdentifierInfo pointer to a normal</para>
        /// <para>/// name. However, it also provides encodings for
        /// Objective-C</para>
        /// <para>/// selectors (optimizing zero- and one-argument selectors, which
        /// make</para>
        /// <para>/// up 78% percent of all selectors in Cocoa.h) and special C++
        /// names</para>
        /// <para>/// for constructors, destructors, and conversion
        /// functions.</para>
        /// </remarks>
        public unsafe partial class DeclarationName : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 4)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public uint Ptr;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang15DeclarationNameC2Ev")]
                internal static extern void ctor_4(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang15DeclarationNameC2EPKNS_14IdentifierInfoE")]
                internal static extern void ctor_5(global::System.IntPtr instance, global::System.IntPtr II);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang15DeclarationNameC2ENS_8SelectorE")]
                internal static extern void ctor_6(global::System.IntPtr instance, clang.Selector.Internal Sel);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang15DeclarationNameC2ERKS0_")]
                internal static extern void cctor_7(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang15DeclarationName21getUsingDirectiveNameEv")]
                internal static extern clang.DeclarationName.Internal getUsingDirectiveName_0();

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang15DeclarationNamecvbEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorConversion_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang15DeclarationName7isEmptyEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isEmpty_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang15DeclarationName12isIdentifierEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isIdentifier_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang15DeclarationName21isObjCZeroArgSelectorEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isObjCZeroArgSelector_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang15DeclarationName20isObjCOneArgSelectorEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isObjCOneArgSelector_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang15DeclarationName11getNameKindEv")]
                internal static extern clang.DeclarationName.NameKind getNameKind_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang15DeclarationName15isDependentNameEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isDependentName_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang15DeclarationName19getAsIdentifierInfoEv")]
                internal static extern global::System.IntPtr getAsIdentifierInfo_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang15DeclarationName18getAsOpaqueIntegerEv")]
                internal static extern uint getAsOpaqueInteger_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang15DeclarationName14getAsOpaquePtrEv")]
                internal static extern global::System.IntPtr getAsOpaquePtr_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang15DeclarationName16getFromOpaquePtrEPv")]
                internal static extern clang.DeclarationName.Internal getFromOpaquePtr_0(global::System.IntPtr P);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang15DeclarationName20getFromOpaqueIntegerEm")]
                internal static extern clang.DeclarationName.Internal getFromOpaqueInteger_0(uint P);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang15DeclarationName14getCXXNameTypeEv")]
                internal static extern clang.QualType.Internal getCXXNameType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang15DeclarationName24getCXXOverloadedOperatorEv")]
                internal static extern clang.OverloadedOperatorKind getCXXOverloadedOperator_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang15DeclarationName23getCXXLiteralIdentifierEv")]
                internal static extern global::System.IntPtr getCXXLiteralIdentifier_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang15DeclarationName15getObjCSelectorEv")]
                internal static extern clang.Selector.Internal getObjCSelector_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang15DeclarationName14setFETokenInfoEPv")]
                internal static extern void setFETokenInfo_0(global::System.IntPtr instance, global::System.IntPtr T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang15DeclarationName14getEmptyMarkerEv")]
                internal static extern clang.DeclarationName.Internal getEmptyMarker_0();

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang15DeclarationName18getTombstoneMarkerEv")]
                internal static extern clang.DeclarationName.Internal getTombstoneMarker_0();

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang15DeclarationName7compareES0_S0_")]
                internal static extern int compare_0(clang.DeclarationName.Internal LHS, clang.DeclarationName.Internal RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang15DeclarationName4dumpEv")]
                internal static extern void dump_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clangeqENS_15DeclarationNameES0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorEqualEqual_0(clang.DeclarationName.Internal LHS, clang.DeclarationName.Internal RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clangneENS_15DeclarationNameES0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorExclaimEqual_0(clang.DeclarationName.Internal LHS, clang.DeclarationName.Internal RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clangltENS_15DeclarationNameES0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorLess_0(clang.DeclarationName.Internal LHS, clang.DeclarationName.Internal RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clanggtENS_15DeclarationNameES0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorGreater_0(clang.DeclarationName.Internal LHS, clang.DeclarationName.Internal RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clangleENS_15DeclarationNameES0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorLessEqual_0(clang.DeclarationName.Internal LHS, clang.DeclarationName.Internal RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clanggeENS_15DeclarationNameES0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorGreaterEqual_0(clang.DeclarationName.Internal LHS, clang.DeclarationName.Internal RHS);
            }

            /// <summary>
            /// <para>NameKind - The kind of name this object contains.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// NameKind - The kind of name this object contains.</para>
            /// </remarks>
            public enum NameKind : uint
            {
                Identifier = 0,
                ObjCZeroArgSelector = 1,
                ObjCOneArgSelector = 2,
                ObjCMultiArgSelector = 3,
                CXXConstructorName = 4,
                CXXDestructorName = 5,
                CXXConversionFunctionName = 6,
                CXXOperatorName = 7,
                CXXLiteralOperatorName = 8,
                CXXUsingDirective = 9
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, DeclarationName> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, DeclarationName>();

            private readonly bool __ownsNativeInstance;

            public static DeclarationName __CreateInstance(global::System.IntPtr native)
            {
                return new DeclarationName((DeclarationName.Internal*) native);
            }

            public static DeclarationName __CreateInstance(DeclarationName.Internal native)
            {
                return new DeclarationName(native);
            }

            private static DeclarationName.Internal* __CopyValue(DeclarationName.Internal native)
            {
                var ret = (DeclarationName.Internal*) Marshal.AllocHGlobal(4);
                *ret = native;
                return ret;
            }

            private DeclarationName(DeclarationName.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected DeclarationName(DeclarationName.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            /// <summary>
            /// <para>DeclarationName - Used to create an empty selector.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// DeclarationName - Used to create an empty selector.</para>
            /// </remarks>
            public DeclarationName()
            {
                __Instance = Marshal.AllocHGlobal(4);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_4(__Instance);
            }

            public DeclarationName(clang.IdentifierInfo II)
            {
                __Instance = Marshal.AllocHGlobal(4);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(II, null) ? global::System.IntPtr.Zero : II.__Instance;
                Internal.ctor_5(__Instance, arg0);
            }

            public DeclarationName(clang.Selector Sel)
            {
                __Instance = Marshal.AllocHGlobal(4);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(Sel, null) ? new clang.Selector.Internal() : *(clang.Selector.Internal*) (Sel.__Instance);
                Internal.ctor_6(__Instance, arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.DeclarationName __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public static implicit operator bool(clang.DeclarationName __op)
            {
                var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
                var __ret = Internal.OperatorConversion_0(arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Evaluates true when this declaration name is empty.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Evaluates true when this declaration name is
            /// empty.</para>
            /// </remarks>
            public bool isEmpty()
            {
                var __ret = Internal.isEmpty_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Predicate functions for querying what type of name this
            /// is.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Predicate functions for querying what type of name this
            /// is.</para>
            /// </remarks>
            public bool isIdentifier()
            {
                var __ret = Internal.isIdentifier_0(__Instance);
                return __ret;
            }

            public bool isObjCZeroArgSelector()
            {
                var __ret = Internal.isObjCZeroArgSelector_0(__Instance);
                return __ret;
            }

            public bool isObjCOneArgSelector()
            {
                var __ret = Internal.isObjCOneArgSelector_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>getNameKind - Determine what kind of name this is.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getNameKind - Determine what kind of name this is.</para>
            /// </remarks>
            public clang.DeclarationName.NameKind getNameKind()
            {
                var __ret = Internal.getNameKind_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determines whether the name itself is dependent, e.g., because it
            /// involves a C++ type that is itself dependent.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determines whether the name itself is dependent, e.g.,
            /// because it </para>
            /// <para>  /// involves a C++ type that is itself dependent.</para>
            /// <para>  ///</para>
            /// <para>  /// Note that this does not capture all of the notions of
            /// &quot;dependent name&quot;,</para>
            /// <para>  /// because an identifier can be a dependent name if it is used
            /// as the </para>
            /// <para>  /// callee in a call expression with dependent
            /// arguments.</para>
            /// </remarks>
            public bool isDependentName()
            {
                var __ret = Internal.isDependentName_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>getAsIdentifierInfo - Retrieve the IdentifierInfo * stored in
            /// this declaration name, or NULL if this declaration name isn't a simple
            /// identifier.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getAsIdentifierInfo - Retrieve the IdentifierInfo * stored
            /// in</para>
            /// <para>  /// this declaration name, or NULL if this declaration name
            /// isn't a</para>
            /// <para>  /// simple identifier.</para>
            /// </remarks>
            public clang.IdentifierInfo getAsIdentifierInfo()
            {
                var __ret = Internal.getAsIdentifierInfo_0(__Instance);
                clang.IdentifierInfo __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.IdentifierInfo.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.IdentifierInfo) clang.IdentifierInfo.NativeToManagedMap[__ret];
                else __result0 = clang.IdentifierInfo.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>getAsOpaqueInteger - Get the representation of this declaration
            /// name as an opaque integer.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getAsOpaqueInteger - Get the representation of this
            /// declaration</para>
            /// <para>  /// name as an opaque integer.</para>
            /// </remarks>
            public uint getAsOpaqueInteger()
            {
                var __ret = Internal.getAsOpaqueInteger_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>getAsOpaquePtr - Get the representation of this declaration name
            /// as an opaque pointer.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getAsOpaquePtr - Get the representation of this declaration
            /// name as</para>
            /// <para>  /// an opaque pointer.</para>
            /// </remarks>
            public global::System.IntPtr getAsOpaquePtr()
            {
                var __ret = Internal.getAsOpaquePtr_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>getCXXNameType - If this name is one of the C++ names (of a
            /// constructor, destructor, or conversion function), return the type
            /// associated with that name.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getCXXNameType - If this name is one of the C++ names (of
            /// a</para>
            /// <para>  /// constructor, destructor, or conversion function), return
            /// the</para>
            /// <para>  /// type associated with that name.</para>
            /// </remarks>
            public clang.QualType getCXXNameType()
            {
                var __ret = Internal.getCXXNameType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>getCXXOverloadedOperator - If this name is the name of an
            /// overloadable operator in C++ (e.g., operator+), retrieve the kind of
            /// overloaded operator.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getCXXOverloadedOperator - If this name is the name of
            /// an</para>
            /// <para>  /// overloadable operator in C++ (e.g., @c operator+), retrieve
            /// the</para>
            /// <para>  /// kind of overloaded operator.</para>
            /// </remarks>
            public clang.OverloadedOperatorKind getCXXOverloadedOperator()
            {
                var __ret = Internal.getCXXOverloadedOperator_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>getCXXLiteralIdentifier - If this name is the name of a literal
            /// operator, retrieve the identifier associated with it.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getCXXLiteralIdentifier - If this name is the name of a
            /// literal</para>
            /// <para>  /// operator, retrieve the identifier associated with
            /// it.</para>
            /// </remarks>
            public clang.IdentifierInfo getCXXLiteralIdentifier()
            {
                var __ret = Internal.getCXXLiteralIdentifier_0(__Instance);
                clang.IdentifierInfo __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.IdentifierInfo.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.IdentifierInfo) clang.IdentifierInfo.NativeToManagedMap[__ret];
                else __result0 = clang.IdentifierInfo.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>getObjCSelector - Get the Objective-C selector stored in this
            /// declaration name.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getObjCSelector - Get the Objective-C selector stored in
            /// this</para>
            /// <para>  /// declaration name.</para>
            /// </remarks>
            public clang.Selector getObjCSelector()
            {
                var __ret = Internal.getObjCSelector_0(__Instance);
                return clang.Selector.__CreateInstance(__ret);
            }

            public void setFETokenInfo(global::System.IntPtr T)
            {
                var arg0 = T;
                Internal.setFETokenInfo_0(__Instance, arg0);
            }

            public void dump()
            {
                Internal.dump_0(__Instance);
            }

            /// <summary>
            /// <para>getUsingDirectiveName - Return name for all
            /// using-directives.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getUsingDirectiveName - Return name for all
            /// using-directives.</para>
            /// </remarks>
            public static clang.DeclarationName getUsingDirectiveName()
            {
                var __ret = Internal.getUsingDirectiveName_0();
                return clang.DeclarationName.__CreateInstance(__ret);
            }

            public static clang.DeclarationName getFromOpaquePtr(global::System.IntPtr P)
            {
                var arg0 = P;
                var __ret = Internal.getFromOpaquePtr_0(arg0);
                return clang.DeclarationName.__CreateInstance(__ret);
            }

            public static clang.DeclarationName getFromOpaqueInteger(uint P)
            {
                var arg0 = P;
                var __ret = Internal.getFromOpaqueInteger_0(arg0);
                return clang.DeclarationName.__CreateInstance(__ret);
            }

            public static clang.DeclarationName getEmptyMarker()
            {
                var __ret = Internal.getEmptyMarker_0();
                return clang.DeclarationName.__CreateInstance(__ret);
            }

            public static clang.DeclarationName getTombstoneMarker()
            {
                var __ret = Internal.getTombstoneMarker_0();
                return clang.DeclarationName.__CreateInstance(__ret);
            }

            public static int compare(clang.DeclarationName LHS, clang.DeclarationName RHS)
            {
                var arg0 = ReferenceEquals(LHS, null) ? new clang.DeclarationName.Internal() : *(clang.DeclarationName.Internal*) (LHS.__Instance);
                var arg1 = ReferenceEquals(RHS, null) ? new clang.DeclarationName.Internal() : *(clang.DeclarationName.Internal*) (RHS.__Instance);
                var __ret = Internal.compare_0(arg0, arg1);
                return __ret;
            }

            /// <summary>
            /// <para>operator== - Determine whether the specified names are
            /// identical..</para>
            /// </summary>
            /// <remarks>
            /// <para>/// operator== - Determine whether the specified names are
            /// identical..</para>
            /// </remarks>
            public static bool operator ==(clang.DeclarationName LHS, clang.DeclarationName RHS)
            {
                bool LHSNull = ReferenceEquals(LHS, null);
                bool RHSNull = ReferenceEquals(RHS, null);
                if (LHSNull || RHSNull)
                    return LHSNull && RHSNull;
                var arg0 = ReferenceEquals(LHS, null) ? new clang.DeclarationName.Internal() : *(clang.DeclarationName.Internal*) (LHS.__Instance);
                var arg1 = ReferenceEquals(RHS, null) ? new clang.DeclarationName.Internal() : *(clang.DeclarationName.Internal*) (RHS.__Instance);
                var __ret = Internal.OperatorEqualEqual_0(arg0, arg1);
                return __ret;
            }

            public override bool Equals(object obj)
            {
                return this == obj as DeclarationName;
            }

            /// <summary>
            /// <para>operator!= - Determine whether the specified names are
            /// different.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// operator!= - Determine whether the specified names are
            /// different.</para>
            /// </remarks>
            public static bool operator !=(clang.DeclarationName LHS, clang.DeclarationName RHS)
            {
                var arg0 = ReferenceEquals(LHS, null) ? new clang.DeclarationName.Internal() : *(clang.DeclarationName.Internal*) (LHS.__Instance);
                var arg1 = ReferenceEquals(RHS, null) ? new clang.DeclarationName.Internal() : *(clang.DeclarationName.Internal*) (RHS.__Instance);
                var __ret = Internal.OperatorExclaimEqual_0(arg0, arg1);
                return __ret;
            }

            /// <summary>
            /// <para>Ordering on two declaration names. If both names are identifiers,
            /// this provides a lexicographical ordering.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Ordering on two declaration names. If both names are
            /// identifiers,</para>
            /// <para>/// this provides a lexicographical ordering.</para>
            /// </remarks>
            public static bool operator <(clang.DeclarationName LHS, clang.DeclarationName RHS)
            {
                var arg0 = ReferenceEquals(LHS, null) ? new clang.DeclarationName.Internal() : *(clang.DeclarationName.Internal*) (LHS.__Instance);
                var arg1 = ReferenceEquals(RHS, null) ? new clang.DeclarationName.Internal() : *(clang.DeclarationName.Internal*) (RHS.__Instance);
                var __ret = Internal.OperatorLess_0(arg0, arg1);
                return __ret;
            }

            /// <summary>
            /// <para>Ordering on two declaration names. If both names are identifiers,
            /// this provides a lexicographical ordering.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Ordering on two declaration names. If both names are
            /// identifiers,</para>
            /// <para>/// this provides a lexicographical ordering.</para>
            /// </remarks>
            public static bool operator >(clang.DeclarationName LHS, clang.DeclarationName RHS)
            {
                var arg0 = ReferenceEquals(LHS, null) ? new clang.DeclarationName.Internal() : *(clang.DeclarationName.Internal*) (LHS.__Instance);
                var arg1 = ReferenceEquals(RHS, null) ? new clang.DeclarationName.Internal() : *(clang.DeclarationName.Internal*) (RHS.__Instance);
                var __ret = Internal.OperatorGreater_0(arg0, arg1);
                return __ret;
            }

            /// <summary>
            /// <para>Ordering on two declaration names. If both names are identifiers,
            /// this provides a lexicographical ordering.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Ordering on two declaration names. If both names are
            /// identifiers,</para>
            /// <para>/// this provides a lexicographical ordering.</para>
            /// </remarks>
            public static bool operator <=(clang.DeclarationName LHS, clang.DeclarationName RHS)
            {
                var arg0 = ReferenceEquals(LHS, null) ? new clang.DeclarationName.Internal() : *(clang.DeclarationName.Internal*) (LHS.__Instance);
                var arg1 = ReferenceEquals(RHS, null) ? new clang.DeclarationName.Internal() : *(clang.DeclarationName.Internal*) (RHS.__Instance);
                var __ret = Internal.OperatorLessEqual_0(arg0, arg1);
                return __ret;
            }

            /// <summary>
            /// <para>Ordering on two declaration names. If both names are identifiers,
            /// this provides a lexicographical ordering.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Ordering on two declaration names. If both names are
            /// identifiers,</para>
            /// <para>/// this provides a lexicographical ordering.</para>
            /// </remarks>
            public static bool operator >=(clang.DeclarationName LHS, clang.DeclarationName RHS)
            {
                var arg0 = ReferenceEquals(LHS, null) ? new clang.DeclarationName.Internal() : *(clang.DeclarationName.Internal*) (LHS.__Instance);
                var arg1 = ReferenceEquals(RHS, null) ? new clang.DeclarationName.Internal() : *(clang.DeclarationName.Internal*) (RHS.__Instance);
                var __ret = Internal.OperatorGreaterEqual_0(arg0, arg1);
                return __ret;
            }

            public static uint NumNameKinds
            {
                get
                {
                    var __ptr = (uint*)CppSharp.SymbolResolver.ResolveSymbol("CppSharp", "_ZN5clang15DeclarationName12NumNameKindsE");
                    return *__ptr;
                }
            }
        }

        /// <summary>
        /// <para>DeclarationNameTable - Used to store and retrieve DeclarationName
        /// instances for the various kinds of declaration names, e.g., normal
        /// identifiers, C++ constructor names, etc. This class contains uniqued
        /// versions of each of the C++ special names, which can be retrieved using its
        /// member functions (e.g., getCXXConstructorName).</para>
        /// </summary>
        /// <remarks>
        /// <para>/// DeclarationNameTable - Used to store and retrieve
        /// DeclarationName</para>
        /// <para>/// instances for the various kinds of declaration names, e.g.,
        /// normal</para>
        /// <para>/// identifiers, C++ constructor names, etc. This class
        /// contains</para>
        /// <para>/// uniqued versions of each of the C++ special names, which can
        /// be</para>
        /// <para>/// retrieved using its member functions (e.g.,</para>
        /// <para>/// getCXXConstructorName).</para>
        /// </remarks>
        public unsafe partial class DeclarationNameTable : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr Ctx;

                [FieldOffset(4)]
                public global::System.IntPtr CXXSpecialNamesImpl;

                [FieldOffset(8)]
                public global::System.IntPtr CXXOperatorNames;

                [FieldOffset(12)]
                public global::System.IntPtr CXXLiteralOperatorNames;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang20DeclarationNameTableC2ERKNS_10ASTContextE")]
                internal static extern void ctor_1(global::System.IntPtr instance, global::System.IntPtr C);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang20DeclarationNameTableD2Ev")]
                internal static extern void dtor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang20DeclarationNameTable13getIdentifierEPKNS_14IdentifierInfoE")]
                internal static extern clang.DeclarationName.Internal getIdentifier_0(global::System.IntPtr instance, global::System.IntPtr ID);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang20DeclarationNameTable18getCXXOperatorNameENS_22OverloadedOperatorKindE")]
                internal static extern clang.DeclarationName.Internal getCXXOperatorName_0(global::System.IntPtr instance, clang.OverloadedOperatorKind Op);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang20DeclarationNameTable25getCXXLiteralOperatorNameEPNS_14IdentifierInfoE")]
                internal static extern clang.DeclarationName.Internal getCXXLiteralOperatorName_0(global::System.IntPtr instance, global::System.IntPtr II);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, DeclarationNameTable> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, DeclarationNameTable>();

            private readonly bool __ownsNativeInstance;

            public static DeclarationNameTable __CreateInstance(global::System.IntPtr native)
            {
                return new DeclarationNameTable((DeclarationNameTable.Internal*) native);
            }

            public static DeclarationNameTable __CreateInstance(DeclarationNameTable.Internal native)
            {
                return new DeclarationNameTable(native);
            }

            private static DeclarationNameTable.Internal* __CopyValue(DeclarationNameTable.Internal native)
            {
                var ret = (DeclarationNameTable.Internal*) Marshal.AllocHGlobal(16);
                *ret = native;
                return ret;
            }

            private DeclarationNameTable(DeclarationNameTable.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected DeclarationNameTable(DeclarationNameTable.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public DeclarationNameTable(clang.ASTContext C)
            {
                __Instance = Marshal.AllocHGlobal(16);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(C, null) ? global::System.IntPtr.Zero : C.__Instance;
                Internal.ctor_1(__Instance, arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.DeclarationNameTable __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance || force)
                    Internal.dtor_0(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            /// <summary>
            /// <para>getIdentifier - Create a declaration name that is a simple
            /// identifier.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getIdentifier - Create a declaration name that is a
            /// simple</para>
            /// <para>  /// identifier.</para>
            /// </remarks>
            public clang.DeclarationName getIdentifier(clang.IdentifierInfo ID)
            {
                var arg0 = ReferenceEquals(ID, null) ? global::System.IntPtr.Zero : ID.__Instance;
                var __ret = Internal.getIdentifier_0(__Instance, arg0);
                return clang.DeclarationName.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>getCXXOperatorName - Get the name of the overloadable C++
            /// operator corresponding to Op.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getCXXOperatorName - Get the name of the overloadable
            /// C++</para>
            /// <para>  /// operator corresponding to Op.</para>
            /// </remarks>
            public clang.DeclarationName getCXXOperatorName(clang.OverloadedOperatorKind Op)
            {
                var arg0 = Op;
                var __ret = Internal.getCXXOperatorName_0(__Instance, arg0);
                return clang.DeclarationName.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>getCXXLiteralOperatorName - Get the name of the literal operator
            /// function with II as the identifier.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getCXXLiteralOperatorName - Get the name of the literal
            /// operator function</para>
            /// <para>  /// with II as the identifier.</para>
            /// </remarks>
            public clang.DeclarationName getCXXLiteralOperatorName(clang.IdentifierInfo II)
            {
                var arg0 = ReferenceEquals(II, null) ? global::System.IntPtr.Zero : II.__Instance;
                var __ret = Internal.getCXXLiteralOperatorName_0(__Instance, arg0);
                return clang.DeclarationName.__CreateInstance(__ret);
            }
        }

        /// <summary>
        /// <para>DeclarationNameLoc - Additional source/type location info for a
        /// declaration name. Needs a DeclarationName in order to be interpreted
        /// correctly.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// DeclarationNameLoc - Additional source/type location
        /// info</para>
        /// <para>/// for a declaration name. Needs a DeclarationName in
        /// order</para>
        /// <para>/// to be interpreted correctly.</para>
        /// </remarks>
        public unsafe partial class DeclarationNameLoc : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 8)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                internal clang.DeclarationNameLoc._.Internal __;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang18DeclarationNameLocC2ENS_15DeclarationNameE")]
                internal static extern void ctor_0(global::System.IntPtr instance, clang.DeclarationName.Internal Name);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang18DeclarationNameLocC2Ev")]
                internal static extern void ctor_1(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang18DeclarationNameLocC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);
            }

            public unsafe partial class NT : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 4)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public global::System.IntPtr TInfo;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang18DeclarationNameLoc2NTC2ERKS1_")]
                    internal static extern void cctor_0(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, NT> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, NT>();

                private readonly bool __ownsNativeInstance;

                public static NT __CreateInstance(global::System.IntPtr native)
                {
                    return new NT((NT.Internal*) native);
                }

                public static NT __CreateInstance(NT.Internal native)
                {
                    return new NT(native);
                }

                private static NT.Internal* __CopyValue(NT.Internal native)
                {
                    var ret = (NT.Internal*) Marshal.AllocHGlobal(4);
                    *ret = native;
                    return ret;
                }

                private NT(NT.Internal native)
                    : this(__CopyValue(native))
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected NT(NT.Internal* native, bool isInternalImpl = false)
                {
                    __Instance = new global::System.IntPtr(native);
                }

                public NT()
                {
                    __Instance = Marshal.AllocHGlobal(4);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    DestroyNativeInstance(false);
                }

                public virtual void DestroyNativeInstance()
                {
                    DestroyNativeInstance(true);
                }

                private void DestroyNativeInstance(bool force)
                {
                    clang.DeclarationNameLoc.NT __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public clang.TypeSourceInfo TInfo
                {
                    get
                    {
                        clang.TypeSourceInfo __result0;
                        if (((Internal*) __Instance)->TInfo == IntPtr.Zero) __result0 = null;
                        else if (clang.TypeSourceInfo.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->TInfo))
                            __result0 = (clang.TypeSourceInfo) clang.TypeSourceInfo.NativeToManagedMap[((Internal*) __Instance)->TInfo];
                        else __result0 = clang.TypeSourceInfo.__CreateInstance(((Internal*) __Instance)->TInfo);
                        return __result0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->TInfo = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }
            }

            public unsafe partial class CXXOpName : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 8)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public uint BeginOpNameLoc;

                    [FieldOffset(4)]
                    public uint EndOpNameLoc;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang18DeclarationNameLoc9CXXOpNameC2ERKS1_")]
                    internal static extern void cctor_0(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, CXXOpName> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, CXXOpName>();

                private readonly bool __ownsNativeInstance;

                public static CXXOpName __CreateInstance(global::System.IntPtr native)
                {
                    return new CXXOpName((CXXOpName.Internal*) native);
                }

                public static CXXOpName __CreateInstance(CXXOpName.Internal native)
                {
                    return new CXXOpName(native);
                }

                private static CXXOpName.Internal* __CopyValue(CXXOpName.Internal native)
                {
                    var ret = (CXXOpName.Internal*) Marshal.AllocHGlobal(8);
                    *ret = native;
                    return ret;
                }

                private CXXOpName(CXXOpName.Internal native)
                    : this(__CopyValue(native))
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected CXXOpName(CXXOpName.Internal* native, bool isInternalImpl = false)
                {
                    __Instance = new global::System.IntPtr(native);
                }

                public CXXOpName()
                {
                    __Instance = Marshal.AllocHGlobal(8);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    DestroyNativeInstance(false);
                }

                public virtual void DestroyNativeInstance()
                {
                    DestroyNativeInstance(true);
                }

                private void DestroyNativeInstance(bool force)
                {
                    clang.DeclarationNameLoc.CXXOpName __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public uint BeginOpNameLoc
                {
                    get
                    {
                        return ((Internal*) __Instance)->BeginOpNameLoc;
                    }

                    set
                    {
                        ((Internal*) __Instance)->BeginOpNameLoc = value;
                    }
                }

                public uint EndOpNameLoc
                {
                    get
                    {
                        return ((Internal*) __Instance)->EndOpNameLoc;
                    }

                    set
                    {
                        ((Internal*) __Instance)->EndOpNameLoc = value;
                    }
                }
            }

            public unsafe partial class CXXLitOpName : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 4)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public uint OpNameLoc;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang18DeclarationNameLoc12CXXLitOpNameC2ERKS1_")]
                    internal static extern void cctor_0(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, CXXLitOpName> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, CXXLitOpName>();

                private readonly bool __ownsNativeInstance;

                public static CXXLitOpName __CreateInstance(global::System.IntPtr native)
                {
                    return new CXXLitOpName((CXXLitOpName.Internal*) native);
                }

                public static CXXLitOpName __CreateInstance(CXXLitOpName.Internal native)
                {
                    return new CXXLitOpName(native);
                }

                private static CXXLitOpName.Internal* __CopyValue(CXXLitOpName.Internal native)
                {
                    var ret = (CXXLitOpName.Internal*) Marshal.AllocHGlobal(4);
                    *ret = native;
                    return ret;
                }

                private CXXLitOpName(CXXLitOpName.Internal native)
                    : this(__CopyValue(native))
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected CXXLitOpName(CXXLitOpName.Internal* native, bool isInternalImpl = false)
                {
                    __Instance = new global::System.IntPtr(native);
                }

                public CXXLitOpName()
                {
                    __Instance = Marshal.AllocHGlobal(4);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    DestroyNativeInstance(false);
                }

                public virtual void DestroyNativeInstance()
                {
                    DestroyNativeInstance(true);
                }

                private void DestroyNativeInstance(bool force)
                {
                    clang.DeclarationNameLoc.CXXLitOpName __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public uint OpNameLoc
                {
                    get
                    {
                        return ((Internal*) __Instance)->OpNameLoc;
                    }

                    set
                    {
                        ((Internal*) __Instance)->OpNameLoc = value;
                    }
                }
            }

            public unsafe partial struct _
            {
                [StructLayout(LayoutKind.Explicit, Size = 8)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public clang.DeclarationNameLoc.NT.Internal NamedType;

                    [FieldOffset(0)]
                    public clang.DeclarationNameLoc.CXXOpName.Internal CXXOperatorName;

                    [FieldOffset(0)]
                    public clang.DeclarationNameLoc.CXXLitOpName.Internal CXXLiteralOperatorName;
                }
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, DeclarationNameLoc> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, DeclarationNameLoc>();

            private readonly bool __ownsNativeInstance;

            public static DeclarationNameLoc __CreateInstance(global::System.IntPtr native)
            {
                return new DeclarationNameLoc((DeclarationNameLoc.Internal*) native);
            }

            public static DeclarationNameLoc __CreateInstance(DeclarationNameLoc.Internal native)
            {
                return new DeclarationNameLoc(native);
            }

            private static DeclarationNameLoc.Internal* __CopyValue(DeclarationNameLoc.Internal native)
            {
                var ret = (DeclarationNameLoc.Internal*) Marshal.AllocHGlobal(8);
                *ret = native;
                return ret;
            }

            private DeclarationNameLoc(DeclarationNameLoc.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected DeclarationNameLoc(DeclarationNameLoc.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public DeclarationNameLoc(clang.DeclarationName Name)
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(Name, null) ? new clang.DeclarationName.Internal() : *(clang.DeclarationName.Internal*) (Name.__Instance);
                Internal.ctor_0(__Instance, arg0);
            }

            public DeclarationNameLoc()
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_1(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.DeclarationNameLoc __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>DeclarationNameInfo - A collector data type for bundling together
        /// a DeclarationName and the correspnding source/type location info.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// DeclarationNameInfo - A collector data type for bundling
        /// together</para>
        /// <para>/// a DeclarationName and the correspnding source/type location
        /// info.</para>
        /// </remarks>
        public unsafe partial class DeclarationNameInfo : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public clang.DeclarationName.Internal Name;

                [FieldOffset(4)]
                public clang.SourceLocation.Internal NameLoc;

                [FieldOffset(8)]
                public clang.DeclarationNameLoc.Internal LocInfo;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang19DeclarationNameInfoC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang19DeclarationNameInfoC2ENS_15DeclarationNameENS_14SourceLocationE")]
                internal static extern void ctor_1(global::System.IntPtr instance, clang.DeclarationName.Internal Name, clang.SourceLocation.Internal NameLoc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang19DeclarationNameInfoC2ENS_15DeclarationNameENS_14SourceLocationENS_18DeclarationNameLocE")]
                internal static extern void ctor_2(global::System.IntPtr instance, clang.DeclarationName.Internal Name, clang.SourceLocation.Internal NameLoc, clang.DeclarationNameLoc.Internal LocInfo);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang19DeclarationNameInfoC2ERKS0_")]
                internal static extern void cctor_3(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang19DeclarationNameInfo7getNameEv")]
                internal static extern clang.DeclarationName.Internal getName_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang19DeclarationNameInfo7setNameENS_15DeclarationNameE")]
                internal static extern void setName_0(global::System.IntPtr instance, clang.DeclarationName.Internal N);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang19DeclarationNameInfo6getLocEv")]
                internal static extern clang.SourceLocation.Internal getLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang19DeclarationNameInfo6setLocENS_14SourceLocationE")]
                internal static extern void setLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal L);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang19DeclarationNameInfo7getInfoEv")]
                internal static extern global::System.IntPtr getInfo_1(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang19DeclarationNameInfo7setInfoERKNS_18DeclarationNameLocE")]
                internal static extern void setInfo_0(global::System.IntPtr instance, global::System.IntPtr Info);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang19DeclarationNameInfo16getNamedTypeInfoEv")]
                internal static extern global::System.IntPtr getNamedTypeInfo_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang19DeclarationNameInfo16setNamedTypeInfoEPNS_14TypeSourceInfoE")]
                internal static extern void setNamedTypeInfo_0(global::System.IntPtr instance, global::System.IntPtr TInfo);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang19DeclarationNameInfo23getCXXOperatorNameRangeEv")]
                internal static extern clang.SourceRange.Internal getCXXOperatorNameRange_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang19DeclarationNameInfo23setCXXOperatorNameRangeENS_11SourceRangeE")]
                internal static extern void setCXXOperatorNameRange_0(global::System.IntPtr instance, clang.SourceRange.Internal R);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang19DeclarationNameInfo28getCXXLiteralOperatorNameLocEv")]
                internal static extern clang.SourceLocation.Internal getCXXLiteralOperatorNameLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang19DeclarationNameInfo28setCXXLiteralOperatorNameLocENS_14SourceLocationE")]
                internal static extern void setCXXLiteralOperatorNameLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal Loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang19DeclarationNameInfo24isInstantiationDependentEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isInstantiationDependent_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang19DeclarationNameInfo31containsUnexpandedParameterPackEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool containsUnexpandedParameterPack_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang19DeclarationNameInfo9printNameERN4llvm11raw_ostreamE")]
                internal static extern void printName_0(global::System.IntPtr instance, global::System.IntPtr OS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang19DeclarationNameInfo11getBeginLocEv")]
                internal static extern clang.SourceLocation.Internal getBeginLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang19DeclarationNameInfo9getEndLocEv")]
                internal static extern clang.SourceLocation.Internal getEndLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang19DeclarationNameInfo14getSourceRangeEv")]
                internal static extern clang.SourceRange.Internal getSourceRange_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang19DeclarationNameInfo11getLocStartEv")]
                internal static extern clang.SourceLocation.Internal getLocStart_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang19DeclarationNameInfo9getLocEndEv")]
                internal static extern clang.SourceLocation.Internal getLocEnd_0(global::System.IntPtr instance);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, DeclarationNameInfo> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, DeclarationNameInfo>();

            private readonly bool __ownsNativeInstance;

            public static DeclarationNameInfo __CreateInstance(global::System.IntPtr native)
            {
                return new DeclarationNameInfo((DeclarationNameInfo.Internal*) native);
            }

            public static DeclarationNameInfo __CreateInstance(DeclarationNameInfo.Internal native)
            {
                return new DeclarationNameInfo(native);
            }

            private static DeclarationNameInfo.Internal* __CopyValue(DeclarationNameInfo.Internal native)
            {
                var ret = (DeclarationNameInfo.Internal*) Marshal.AllocHGlobal(16);
                *ret = native;
                return ret;
            }

            private DeclarationNameInfo(DeclarationNameInfo.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected DeclarationNameInfo(DeclarationNameInfo.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public DeclarationNameInfo()
            {
                __Instance = Marshal.AllocHGlobal(16);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public DeclarationNameInfo(clang.DeclarationName Name, clang.SourceLocation NameLoc)
            {
                __Instance = Marshal.AllocHGlobal(16);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(Name, null) ? new clang.DeclarationName.Internal() : *(clang.DeclarationName.Internal*) (Name.__Instance);
                var arg1 = ReferenceEquals(NameLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (NameLoc.__Instance);
                Internal.ctor_1(__Instance, arg0, arg1);
            }

            public DeclarationNameInfo(clang.DeclarationName Name, clang.SourceLocation NameLoc, clang.DeclarationNameLoc LocInfo)
            {
                __Instance = Marshal.AllocHGlobal(16);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(Name, null) ? new clang.DeclarationName.Internal() : *(clang.DeclarationName.Internal*) (Name.__Instance);
                var arg1 = ReferenceEquals(NameLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (NameLoc.__Instance);
                var arg2 = ReferenceEquals(LocInfo, null) ? new clang.DeclarationNameLoc.Internal() : *(clang.DeclarationNameLoc.Internal*) (LocInfo.__Instance);
                Internal.ctor_2(__Instance, arg0, arg1, arg2);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.DeclarationNameInfo __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            /// <summary>
            /// <para>getName - Returns the embedded declaration name.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getName - Returns the embedded declaration name.</para>
            /// </remarks>
            public clang.DeclarationName getName()
            {
                var __ret = Internal.getName_0(__Instance);
                return clang.DeclarationName.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>setName - Sets the embedded declaration name.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// setName - Sets the embedded declaration name.</para>
            /// </remarks>
            public void setName(clang.DeclarationName N)
            {
                var arg0 = ReferenceEquals(N, null) ? new clang.DeclarationName.Internal() : *(clang.DeclarationName.Internal*) (N.__Instance);
                Internal.setName_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>getLoc - Returns the main location of the declaration
            /// name.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getLoc - Returns the main location of the declaration
            /// name.</para>
            /// </remarks>
            public clang.SourceLocation getLoc()
            {
                var __ret = Internal.getLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>setLoc - Sets the main location of the declaration name.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// setLoc - Sets the main location of the declaration
            /// name.</para>
            /// </remarks>
            public void setLoc(clang.SourceLocation L)
            {
                var arg0 = ReferenceEquals(L, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (L.__Instance);
                Internal.setLoc_0(__Instance, arg0);
            }

            public clang.DeclarationNameLoc getInfo()
            {
                var __ret = Internal.getInfo_1(__Instance);
                clang.DeclarationNameLoc __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.DeclarationNameLoc.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.DeclarationNameLoc) clang.DeclarationNameLoc.NativeToManagedMap[__ret];
                else __result0 = clang.DeclarationNameLoc.__CreateInstance(__ret);
                return __result0;
            }

            public void setInfo(clang.DeclarationNameLoc Info)
            {
                var arg0 = ReferenceEquals(Info, null) ? global::System.IntPtr.Zero : Info.__Instance;
                Internal.setInfo_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>getNamedTypeInfo - Returns the source type info associated to the
            /// name. Assumes it is a constructor, destructor or conversion.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getNamedTypeInfo - Returns the source type info associated
            /// to</para>
            /// <para>  /// the name. Assumes it is a constructor, destructor or
            /// conversion.</para>
            /// </remarks>
            public clang.TypeSourceInfo getNamedTypeInfo()
            {
                var __ret = Internal.getNamedTypeInfo_0(__Instance);
                clang.TypeSourceInfo __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.TypeSourceInfo.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.TypeSourceInfo) clang.TypeSourceInfo.NativeToManagedMap[__ret];
                else __result0 = clang.TypeSourceInfo.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>setNamedTypeInfo - Sets the source type info associated to the
            /// name. Assumes it is a constructor, destructor or conversion.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// setNamedTypeInfo - Sets the source type info associated
            /// to</para>
            /// <para>  /// the name. Assumes it is a constructor, destructor or
            /// conversion.</para>
            /// </remarks>
            public void setNamedTypeInfo(clang.TypeSourceInfo TInfo)
            {
                var arg0 = ReferenceEquals(TInfo, null) ? global::System.IntPtr.Zero : TInfo.__Instance;
                Internal.setNamedTypeInfo_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>getCXXOperatorNameRange - Gets the range of the operator name
            /// (without the operator keyword). Assumes it is a (non-literal)
            /// operator.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getCXXOperatorNameRange - Gets the range of the operator
            /// name</para>
            /// <para>  /// (without the operator keyword). Assumes it is a
            /// (non-literal) operator.</para>
            /// </remarks>
            public clang.SourceRange getCXXOperatorNameRange()
            {
                var __ret = Internal.getCXXOperatorNameRange_0(__Instance);
                return clang.SourceRange.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>setCXXOperatorNameRange - Sets the range of the operator name
            /// (without the operator keyword). Assumes it is a C++ operator.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// setCXXOperatorNameRange - Sets the range of the operator
            /// name</para>
            /// <para>  /// (without the operator keyword). Assumes it is a C++
            /// operator.</para>
            /// </remarks>
            public void setCXXOperatorNameRange(clang.SourceRange R)
            {
                var arg0 = ReferenceEquals(R, null) ? new clang.SourceRange.Internal() : *(clang.SourceRange.Internal*) (R.__Instance);
                Internal.setCXXOperatorNameRange_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>getCXXLiteralOperatorNameLoc - Returns the location of the
            /// literal operator name (not the operator keyword). Assumes it is a literal
            /// operator.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getCXXLiteralOperatorNameLoc - Returns the location of the
            /// literal</para>
            /// <para>  /// operator name (not the operator keyword).</para>
            /// <para>  /// Assumes it is a literal operator.</para>
            /// </remarks>
            public clang.SourceLocation getCXXLiteralOperatorNameLoc()
            {
                var __ret = Internal.getCXXLiteralOperatorNameLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>setCXXLiteralOperatorNameLoc - Sets the location of the literal
            /// operator name (not the operator keyword). Assumes it is a literal
            /// operator.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// setCXXLiteralOperatorNameLoc - Sets the location of the
            /// literal</para>
            /// <para>  /// operator name (not the operator keyword).</para>
            /// <para>  /// Assumes it is a literal operator.</para>
            /// </remarks>
            public void setCXXLiteralOperatorNameLoc(clang.SourceLocation Loc)
            {
                var arg0 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                Internal.setCXXLiteralOperatorNameLoc_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>Determine whether this name involves a template parameter.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine whether this name involves a template
            /// parameter.</para>
            /// </remarks>
            public bool isInstantiationDependent()
            {
                var __ret = Internal.isInstantiationDependent_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determine whether this name contains an unexpanded parameter
            /// pack.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine whether this name contains an
            /// unexpanded</para>
            /// <para>  /// parameter pack.</para>
            /// </remarks>
            public bool containsUnexpandedParameterPack()
            {
                var __ret = Internal.containsUnexpandedParameterPack_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>printName - Print the human-readable name to a stream.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// printName - Print the human-readable name to a stream.</para>
            /// </remarks>
            public void printName(llvm.raw_ostream OS)
            {
                var arg0 = ReferenceEquals(OS, null) ? global::System.IntPtr.Zero : OS.__Instance;
                Internal.printName_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>getBeginLoc - Retrieve the location of the first token.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getBeginLoc - Retrieve the location of the first
            /// token.</para>
            /// </remarks>
            public clang.SourceLocation getBeginLoc()
            {
                var __ret = Internal.getBeginLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>getEndLoc - Retrieve the location of the last token.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getEndLoc - Retrieve the location of the last token.</para>
            /// </remarks>
            public clang.SourceLocation getEndLoc()
            {
                var __ret = Internal.getEndLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>getSourceRange - The range of the declaration name.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getSourceRange - The range of the declaration name.</para>
            /// </remarks>
            public clang.SourceRange getSourceRange()
            {
                var __ret = Internal.getSourceRange_0(__Instance);
                return clang.SourceRange.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLocStart()
            {
                var __ret = Internal.getLocStart_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLocEnd()
            {
                var __ret = Internal.getLocEnd_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }
        }
    }

    namespace llvm
    {
    }
}
