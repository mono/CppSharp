//----------------------------------------------------------------------------
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
//----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace CppSharp
{
    namespace llvm
    {
        /// <summary>
        /// <para>This is the part of SmallVectorTemplateBase which does not depend
        /// on whether the type T is a POD. The extra dummy template argument is used
        /// by ArrayRef to avoid unnecessarily requiring T to be complete.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// This is the part of SmallVectorTemplateBase which does not
        /// depend on whether</para>
        /// <para>/// the type T is a POD. The extra dummy template argument is
        /// used by ArrayRef</para>
        /// <para>/// to avoid unnecessarily requiring T to be complete.</para>
        /// </remarks>
        public unsafe partial class SmallVectorTemplateCommon
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr BeginX;

                [FieldOffset(4)]
                public global::System.IntPtr EndX;

                [FieldOffset(8)]
                public global::System.IntPtr CapacityX;
            }
        }

        /// <summary>
        /// <para>SmallVectorTemplateBase&lt;isPodLike = false&gt; - This is where
        /// we put method implementations that are designed to work with non-POD-like
        /// T's.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// SmallVectorTemplateBase&lt;isPodLike = false&gt; - This is
        /// where we put method</para>
        /// <para>/// implementations that are designed to work with non-POD-like
        /// T's.</para>
        /// </remarks>
        public unsafe partial class SmallVectorTemplateBase
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct Internal
            {
            }
        }

        /// <summary>
        /// <para>This class consists of common code factored out of the
        /// SmallVector class to reduce code duplication based on the SmallVector 'N'
        /// template parameter.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// This class consists of common code factored out of the
        /// SmallVector class to</para>
        /// <para>/// reduce code duplication based on the SmallVector 'N' template
        /// parameter.</para>
        /// </remarks>
        public unsafe partial class SmallVectorImpl
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct Internal
            {
            }
        }

        /// <summary>
        /// <para>This is a 'vector' (really, a variable-sized array), optimized
        /// for the case when the array is small. It contains some number of elements
        /// in-place, which allows it to avoid heap allocation when the actual number
        /// of elements is below that threshold. This allows normal &quot;small&quot;
        /// cases to be fast without losing generality for large inputs.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// This is a 'vector' (really, a variable-sized array),
        /// optimized</para>
        /// <para>/// for the case when the array is small.  It contains some
        /// number of elements</para>
        /// <para>/// in-place, which allows it to avoid heap allocation when the
        /// actual number of</para>
        /// <para>/// elements is below that threshold.  This allows normal
        /// &quot;small&quot; cases to be</para>
        /// <para>/// fast without losing generality for large inputs.</para>
        /// <para>///</para>
        /// <para>/// Note that this does not attempt to be exception safe.</para>
        /// <para>///</para>
        /// </remarks>
        public unsafe partial class SmallVector
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct Internal
            {
            }
        }

        /// <summary>
        /// <para>This is all the non-templated stuff common to all
        /// SmallVectors.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// This is all the non-templated stuff common to all
        /// SmallVectors.</para>
        /// </remarks>
        public unsafe partial class SmallVectorBase : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 12)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr BeginX;

                [FieldOffset(4)]
                public global::System.IntPtr EndX;

                [FieldOffset(8)]
                public global::System.IntPtr CapacityX;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm15SmallVectorBaseC2EPvm")]
                internal static extern void ctor_0(global::System.IntPtr instance, global::System.IntPtr FirstEl, uint Size);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm15SmallVectorBaseC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm15SmallVectorBase8grow_podEPvmm")]
                internal static extern void grow_pod_0(global::System.IntPtr instance, global::System.IntPtr FirstEl, uint MinSizeInBytes, uint TSize);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm15SmallVectorBase13size_in_bytesEv")]
                internal static extern uint size_in_bytes_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm15SmallVectorBase17capacity_in_bytesEv")]
                internal static extern uint capacity_in_bytes_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm15SmallVectorBase5emptyEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool empty_0(global::System.IntPtr instance);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, SmallVectorBase> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, SmallVectorBase>();

            private readonly bool __ownsNativeInstance;

            public static SmallVectorBase __CreateInstance(global::System.IntPtr native)
            {
                return new SmallVectorBase((SmallVectorBase.Internal*) native);
            }

            public static SmallVectorBase __CreateInstance(SmallVectorBase.Internal native)
            {
                return new SmallVectorBase(native);
            }

            private static SmallVectorBase.Internal* __CopyValue(SmallVectorBase.Internal native)
            {
                var ret = (SmallVectorBase.Internal*) Marshal.AllocHGlobal(12);
                *ret = native;
                return ret;
            }

            private SmallVectorBase(SmallVectorBase.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected SmallVectorBase(SmallVectorBase.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            protected SmallVectorBase(global::System.IntPtr FirstEl, uint Size)
            {
                __Instance = Marshal.AllocHGlobal(12);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = FirstEl;
                var arg1 = Size;
                Internal.ctor_0(__Instance, arg0, arg1);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                llvm.SmallVectorBase __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            /// <summary>
            /// <para>This is an implementation of the grow() method which only works
            /// on POD-like data types and is out of line to reduce code
            /// duplication.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// This is an implementation of the grow() method which only
            /// works</para>
            /// <para>  /// on POD-like data types and is out of line to reduce code
            /// duplication.</para>
            /// </remarks>
            protected void grow_pod(global::System.IntPtr FirstEl, uint MinSizeInBytes, uint TSize)
            {
                var arg0 = FirstEl;
                var arg1 = MinSizeInBytes;
                var arg2 = TSize;
                Internal.grow_pod_0(__Instance, arg0, arg1, arg2);
            }

            /// <summary>
            /// <para>This returns size()*sizeof(T).</para>
            /// </summary>
            /// <remarks>
            /// <para>/// This returns size()*sizeof(T).</para>
            /// </remarks>
            public uint size_in_bytes()
            {
                var __ret = Internal.size_in_bytes_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>capacity_in_bytes - This returns capacity()*sizeof(T).</para>
            /// </summary>
            /// <remarks>
            /// <para>/// capacity_in_bytes - This returns capacity()*sizeof(T).</para>
            /// </remarks>
            public uint capacity_in_bytes()
            {
                var __ret = Internal.capacity_in_bytes_0(__Instance);
                return __ret;
            }

            public bool empty()
            {
                var __ret = Internal.empty_0(__Instance);
                return __ret;
            }

            protected global::System.IntPtr BeginX
            {
                get
                {
                    return ((Internal*) __Instance)->BeginX;
                }

                set
                {
                    ((Internal*) __Instance)->BeginX = value;
                }
            }

            protected global::System.IntPtr EndX
            {
                get
                {
                    return ((Internal*) __Instance)->EndX;
                }

                set
                {
                    ((Internal*) __Instance)->EndX = value;
                }
            }

            protected global::System.IntPtr CapacityX
            {
                get
                {
                    return ((Internal*) __Instance)->CapacityX;
                }

                set
                {
                    ((Internal*) __Instance)->CapacityX = value;
                }
            }
        }
    }

    namespace std
    {
    }
}
