//----------------------------------------------------------------------------
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
//----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace CppSharp
{
    namespace clang
    {
        /// <summary>
        /// <para>Represents a C++ nested name specifier, such as
        /// &quot;::std::vector&lt;int&gt;::&quot;.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief Represents a C++ nested name specifier, such as</para>
        /// <para>/// &quot;\::std::vector&lt;int&gt;::&quot;.</para>
        /// <para>///</para>
        /// <para>/// C++ nested name specifiers are the prefixes to
        /// qualified</para>
        /// <para>/// namespaces. For example, &quot;foo::&quot; in
        /// &quot;foo::x&quot; is a nested name</para>
        /// <para>/// specifier. Nested name specifiers are made up of a sequence
        /// of</para>
        /// <para>/// specifiers, each of which can be a namespace, type,
        /// identifier</para>
        /// <para>/// (for dependent names), decltype specifier, or the global
        /// specifier ('::').</para>
        /// <para>/// The last two specifiers can only appear at the start of a
        /// </para>
        /// <para>/// nested-namespace-specifier.</para>
        /// </remarks>
        public unsafe partial class NestedNameSpecifier : llvm.FoldingSetImpl.Node, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 12)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr NextInFoldingSetBucket;

                [FieldOffset(4)]
                internal llvm.PointerIntPair.Internal Prefix;

                [FieldOffset(8)]
                public global::System.IntPtr Specifier;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang19NestedNameSpecifier6CreateERKNS_10ASTContextEPS0_PNS_14IdentifierInfoE")]
                internal static extern global::System.IntPtr Create_0(global::System.IntPtr Context, global::System.IntPtr Prefix, global::System.IntPtr II);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang19NestedNameSpecifier6CreateERKNS_10ASTContextEPS0_PKNS_13NamespaceDeclE")]
                internal static extern global::System.IntPtr Create_1(global::System.IntPtr Context, global::System.IntPtr Prefix, global::System.IntPtr NS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang19NestedNameSpecifier6CreateERKNS_10ASTContextEPS0_bPKNS_4TypeE")]
                internal static extern global::System.IntPtr Create_3(global::System.IntPtr Context, global::System.IntPtr Prefix, bool Template, global::System.IntPtr T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang19NestedNameSpecifier6CreateERKNS_10ASTContextEPNS_14IdentifierInfoE")]
                internal static extern global::System.IntPtr Create_4(global::System.IntPtr Context, global::System.IntPtr II);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang19NestedNameSpecifier15GlobalSpecifierERKNS_10ASTContextE")]
                internal static extern global::System.IntPtr GlobalSpecifier_0(global::System.IntPtr Context);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang19NestedNameSpecifier9getPrefixEv")]
                internal static extern global::System.IntPtr getPrefix_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang19NestedNameSpecifier7getKindEv")]
                internal static extern clang.NestedNameSpecifier.SpecifierKind getKind_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang19NestedNameSpecifier15getAsIdentifierEv")]
                internal static extern global::System.IntPtr getAsIdentifier_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang19NestedNameSpecifier14getAsNamespaceEv")]
                internal static extern global::System.IntPtr getAsNamespace_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang19NestedNameSpecifier9getAsTypeEv")]
                internal static extern global::System.IntPtr getAsType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang19NestedNameSpecifier11isDependentEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isDependent_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang19NestedNameSpecifier24isInstantiationDependentEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isInstantiationDependent_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang19NestedNameSpecifier31containsUnexpandedParameterPackEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool containsUnexpandedParameterPack_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang19NestedNameSpecifier5printERN4llvm11raw_ostreamERKNS_14PrintingPolicyE")]
                internal static extern void print_0(global::System.IntPtr instance, global::System.IntPtr OS, global::System.IntPtr Policy);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang19NestedNameSpecifier7ProfileERN4llvm16FoldingSetNodeIDE")]
                internal static extern void Profile_0(global::System.IntPtr instance, global::System.IntPtr ID);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang19NestedNameSpecifier4dumpERKNS_11LangOptionsE")]
                internal static extern void dump_0(global::System.IntPtr instance, global::System.IntPtr LO);
            }

            /// <summary>
            /// <para>The kind of specifier that completes this nested name
            /// specifier.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief The kind of specifier that completes this nested
            /// name</para>
            /// <para>  /// specifier.</para>
            /// </remarks>
            public enum SpecifierKind : uint
            {
                /// <summary>An identifier, stored as an IdentifierInfo*.</summary>
                Identifier = 0,
                /// <summary>A namespace, stored as a NamespaceDecl*.</summary>
                Namespace = 1,
                /// <summary>A namespace alias, stored as a NamespaceAliasDecl*.</summary>
                NamespaceAlias = 2,
                /// <summary>A type, stored as a Type*.</summary>
                TypeSpec = 3,
                /// <summary>A type that was preceded by the 'template' keyword, stored as a Type*.</summary>
                TypeSpecWithTemplate = 4,
                /// <summary>The global specifier '::'. There is no stored value.</summary>
                Global = 5,
                /// <summary>Microsoft's '__super' specifier, stored as a CXXRecordDecl* of the class it appeared in.</summary>
                Super = 6
            }

            private readonly bool __ownsNativeInstance;

            public static new NestedNameSpecifier __CreateInstance(global::System.IntPtr native)
            {
                return new NestedNameSpecifier((NestedNameSpecifier.Internal*) native);
            }

            public static NestedNameSpecifier __CreateInstance(NestedNameSpecifier.Internal native)
            {
                return new NestedNameSpecifier(native);
            }

            private static NestedNameSpecifier.Internal* __CopyValue(NestedNameSpecifier.Internal native)
            {
                var ret = (NestedNameSpecifier.Internal*) Marshal.AllocHGlobal(12);
                *ret = native;
                return ret;
            }

            private NestedNameSpecifier(NestedNameSpecifier.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected NestedNameSpecifier(NestedNameSpecifier.Internal* native, bool isInternalImpl = false)
                : base((llvm.FoldingSetImpl.Node.Internal*) native)
            {
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                llvm.FoldingSetImpl.Node __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            /// <summary>
            /// <para>Return the prefix of this nested name specifier.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the prefix of this nested name
            /// specifier.</para>
            /// <para>  ///</para>
            /// <para>  /// The prefix contains all of the parts of the nested
            /// name</para>
            /// <para>  /// specifier that preced this current specifier. For example,
            /// for a</para>
            /// <para>  /// nested name specifier that represents
            /// &quot;foo::bar::&quot;, the current</para>
            /// <para>  /// specifier will contain &quot;bar::&quot; and the prefix
            /// will contain</para>
            /// <para>  /// &quot;foo::&quot;.</para>
            /// </remarks>
            public clang.NestedNameSpecifier getPrefix()
            {
                var __ret = Internal.getPrefix_0(__Instance);
                clang.NestedNameSpecifier __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.NestedNameSpecifier.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.NestedNameSpecifier) clang.NestedNameSpecifier.NativeToManagedMap[__ret];
                else __result0 = clang.NestedNameSpecifier.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Determine what kind of nested name specifier is stored.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine what kind of nested name specifier is
            /// stored.</para>
            /// </remarks>
            public clang.NestedNameSpecifier.SpecifierKind getKind()
            {
                var __ret = Internal.getKind_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Retrieve the identifier stored in this nested name
            /// specifier.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the identifier stored in this nested
            /// name</para>
            /// <para>  /// specifier.</para>
            /// </remarks>
            public clang.IdentifierInfo getAsIdentifier()
            {
                var __ret = Internal.getAsIdentifier_0(__Instance);
                clang.IdentifierInfo __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.IdentifierInfo.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.IdentifierInfo) clang.IdentifierInfo.NativeToManagedMap[__ret];
                else __result0 = clang.IdentifierInfo.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Retrieve the namespace stored in this nested name
            /// specifier.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the namespace stored in this nested
            /// name</para>
            /// <para>  /// specifier.</para>
            /// </remarks>
            public clang.NamespaceDecl getAsNamespace()
            {
                var __ret = Internal.getAsNamespace_0(__Instance);
                clang.NamespaceDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.NamespaceDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.NamespaceDecl) clang.NamespaceDecl.NativeToManagedMap[__ret];
                else clang.NamespaceDecl.NativeToManagedMap[__ret] = __result0 = (clang.NamespaceDecl) clang.NamespaceDecl.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Retrieve the type stored in this nested name specifier.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the type stored in this nested name
            /// specifier.</para>
            /// </remarks>
            public clang.Type getAsType()
            {
                var __ret = Internal.getAsType_0(__Instance);
                clang.Type __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Type.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Type) clang.Type.NativeToManagedMap[__ret];
                else __result0 = clang.Type.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Whether this nested name specifier refers to a dependent type or
            /// not.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Whether this nested name specifier refers to a
            /// dependent</para>
            /// <para>  /// type or not.</para>
            /// </remarks>
            public bool isDependent()
            {
                var __ret = Internal.isDependent_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Whether this nested name specifier involves a template
            /// parameter.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Whether this nested name specifier involves a
            /// template</para>
            /// <para>  /// parameter.</para>
            /// </remarks>
            public bool isInstantiationDependent()
            {
                var __ret = Internal.isInstantiationDependent_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Whether this nested-name-specifier contains an unexpanded
            /// parameter pack (for C++11 variadic templates).</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Whether this nested-name-specifier contains an
            /// unexpanded</para>
            /// <para>  /// parameter pack (for C++11 variadic templates).</para>
            /// </remarks>
            public bool containsUnexpandedParameterPack()
            {
                var __ret = Internal.containsUnexpandedParameterPack_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Print this nested name specifier to the given output
            /// stream.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Print this nested name specifier to the given
            /// output</para>
            /// <para>  /// stream.</para>
            /// </remarks>
            public void print(llvm.raw_ostream OS, clang.PrintingPolicy Policy)
            {
                var arg0 = ReferenceEquals(OS, null) ? global::System.IntPtr.Zero : OS.__Instance;
                var arg1 = ReferenceEquals(Policy, null) ? global::System.IntPtr.Zero : Policy.__Instance;
                Internal.print_0(__Instance, arg0, arg1);
            }

            public void Profile(llvm.FoldingSetNodeID ID)
            {
                var arg0 = ReferenceEquals(ID, null) ? global::System.IntPtr.Zero : ID.__Instance;
                Internal.Profile_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>Dump the nested name specifier to standard output to aid in
            /// debugging.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Dump the nested name specifier to standard output to
            /// aid</para>
            /// <para>  /// in debugging.</para>
            /// </remarks>
            public void dump(clang.LangOptions LO)
            {
                var arg0 = ReferenceEquals(LO, null) ? global::System.IntPtr.Zero : LO.__Instance;
                Internal.dump_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>Builds a specifier combining a prefix and an identifier.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Builds a specifier combining a prefix and an
            /// identifier.</para>
            /// <para>  ///</para>
            /// <para>  /// The prefix must be dependent, since nested name
            /// specifiers</para>
            /// <para>  /// referencing an identifier are only permitted when the
            /// identifier</para>
            /// <para>  /// cannot be resolved.</para>
            /// </remarks>
            public static clang.NestedNameSpecifier Create(clang.ASTContext Context, clang.NestedNameSpecifier Prefix, clang.IdentifierInfo II)
            {
                var arg0 = ReferenceEquals(Context, null) ? global::System.IntPtr.Zero : Context.__Instance;
                var arg1 = ReferenceEquals(Prefix, null) ? global::System.IntPtr.Zero : Prefix.__Instance;
                var arg2 = ReferenceEquals(II, null) ? global::System.IntPtr.Zero : II.__Instance;
                var __ret = Internal.Create_0(arg0, arg1, arg2);
                clang.NestedNameSpecifier __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.NestedNameSpecifier.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.NestedNameSpecifier) clang.NestedNameSpecifier.NativeToManagedMap[__ret];
                else __result0 = clang.NestedNameSpecifier.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Builds a nested name specifier that names a namespace.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Builds a nested name specifier that names a
            /// namespace.</para>
            /// </remarks>
            public static clang.NestedNameSpecifier Create(clang.ASTContext Context, clang.NestedNameSpecifier Prefix, clang.NamespaceDecl NS)
            {
                var arg0 = ReferenceEquals(Context, null) ? global::System.IntPtr.Zero : Context.__Instance;
                var arg1 = ReferenceEquals(Prefix, null) ? global::System.IntPtr.Zero : Prefix.__Instance;
                var arg2 = ReferenceEquals(NS, null) ? global::System.IntPtr.Zero : NS.__Instance;
                var __ret = Internal.Create_1(arg0, arg1, arg2);
                clang.NestedNameSpecifier __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.NestedNameSpecifier.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.NestedNameSpecifier) clang.NestedNameSpecifier.NativeToManagedMap[__ret];
                else __result0 = clang.NestedNameSpecifier.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Builds a nested name specifier that names a type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Builds a nested name specifier that names a
            /// type.</para>
            /// </remarks>
            public static clang.NestedNameSpecifier Create(clang.ASTContext Context, clang.NestedNameSpecifier Prefix, bool Template, clang.Type T)
            {
                var arg0 = ReferenceEquals(Context, null) ? global::System.IntPtr.Zero : Context.__Instance;
                var arg1 = ReferenceEquals(Prefix, null) ? global::System.IntPtr.Zero : Prefix.__Instance;
                var arg3 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.Create_3(arg0, arg1, Template, arg3);
                clang.NestedNameSpecifier __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.NestedNameSpecifier.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.NestedNameSpecifier) clang.NestedNameSpecifier.NativeToManagedMap[__ret];
                else __result0 = clang.NestedNameSpecifier.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Builds a specifier that consists of just an identifier.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Builds a specifier that consists of just an
            /// identifier.</para>
            /// <para>  ///</para>
            /// <para>  /// The nested-name-specifier is assumed to be dependent, but
            /// has no</para>
            /// <para>  /// prefix because the prefix is implied by something outside
            /// of the</para>
            /// <para>  /// nested name specifier, e.g., in &quot;x-&gt;Base::f&quot;,
            /// the &quot;x&quot; has a dependent</para>
            /// <para>  /// type.</para>
            /// </remarks>
            public static clang.NestedNameSpecifier Create(clang.ASTContext Context, clang.IdentifierInfo II)
            {
                var arg0 = ReferenceEquals(Context, null) ? global::System.IntPtr.Zero : Context.__Instance;
                var arg1 = ReferenceEquals(II, null) ? global::System.IntPtr.Zero : II.__Instance;
                var __ret = Internal.Create_4(arg0, arg1);
                clang.NestedNameSpecifier __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.NestedNameSpecifier.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.NestedNameSpecifier) clang.NestedNameSpecifier.NativeToManagedMap[__ret];
                else __result0 = clang.NestedNameSpecifier.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Returns the nested name specifier representing the global
            /// scope.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Returns the nested name specifier representing the
            /// global</para>
            /// <para>  /// scope.</para>
            /// </remarks>
            public static clang.NestedNameSpecifier GlobalSpecifier(clang.ASTContext Context)
            {
                var arg0 = ReferenceEquals(Context, null) ? global::System.IntPtr.Zero : Context.__Instance;
                var __ret = Internal.GlobalSpecifier_0(arg0);
                clang.NestedNameSpecifier __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.NestedNameSpecifier.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.NestedNameSpecifier) clang.NestedNameSpecifier.NativeToManagedMap[__ret];
                else __result0 = clang.NestedNameSpecifier.__CreateInstance(__ret);
                return __result0;
            }
        }

        /// <summary>
        /// <para>A C++ nested-name-specifier augmented with source location
        /// information.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief A C++ nested-name-specifier augmented with source
        /// location</para>
        /// <para>/// information.</para>
        /// </remarks>
        public unsafe partial class NestedNameSpecifierLoc : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 8)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr Qualifier;

                [FieldOffset(4)]
                public global::System.IntPtr Data;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang22NestedNameSpecifierLocC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang22NestedNameSpecifierLocC2EPNS_19NestedNameSpecifierEPv")]
                internal static extern void ctor_1(global::System.IntPtr instance, global::System.IntPtr Qualifier, global::System.IntPtr Data);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang22NestedNameSpecifierLocC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang22NestedNameSpecifierLoccvbEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorConversion_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang22NestedNameSpecifierLoc12hasQualifierEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasQualifier_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang22NestedNameSpecifierLoc22getNestedNameSpecifierEv")]
                internal static extern global::System.IntPtr getNestedNameSpecifier_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang22NestedNameSpecifierLoc13getOpaqueDataEv")]
                internal static extern global::System.IntPtr getOpaqueData_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang22NestedNameSpecifierLoc14getSourceRangeEv")]
                internal static extern clang.SourceRange.Internal getSourceRange_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang22NestedNameSpecifierLoc19getLocalSourceRangeEv")]
                internal static extern clang.SourceRange.Internal getLocalSourceRange_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang22NestedNameSpecifierLoc11getBeginLocEv")]
                internal static extern clang.SourceLocation.Internal getBeginLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang22NestedNameSpecifierLoc9getEndLocEv")]
                internal static extern clang.SourceLocation.Internal getEndLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang22NestedNameSpecifierLoc16getLocalBeginLocEv")]
                internal static extern clang.SourceLocation.Internal getLocalBeginLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang22NestedNameSpecifierLoc14getLocalEndLocEv")]
                internal static extern clang.SourceLocation.Internal getLocalEndLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang22NestedNameSpecifierLoc9getPrefixEv")]
                internal static extern clang.NestedNameSpecifierLoc.Internal getPrefix_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang22NestedNameSpecifierLoc10getTypeLocEv")]
                internal static extern clang.TypeLoc.Internal getTypeLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang22NestedNameSpecifierLoc13getDataLengthEv")]
                internal static extern uint getDataLength_1(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clangeqENS_22NestedNameSpecifierLocES0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorEqualEqual_0(clang.NestedNameSpecifierLoc.Internal X, clang.NestedNameSpecifierLoc.Internal Y);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clangneENS_22NestedNameSpecifierLocES0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorExclaimEqual_0(clang.NestedNameSpecifierLoc.Internal X, clang.NestedNameSpecifierLoc.Internal Y);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, NestedNameSpecifierLoc> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, NestedNameSpecifierLoc>();

            private readonly bool __ownsNativeInstance;

            public static NestedNameSpecifierLoc __CreateInstance(global::System.IntPtr native)
            {
                return new NestedNameSpecifierLoc((NestedNameSpecifierLoc.Internal*) native);
            }

            public static NestedNameSpecifierLoc __CreateInstance(NestedNameSpecifierLoc.Internal native)
            {
                return new NestedNameSpecifierLoc(native);
            }

            private static NestedNameSpecifierLoc.Internal* __CopyValue(NestedNameSpecifierLoc.Internal native)
            {
                var ret = (NestedNameSpecifierLoc.Internal*) Marshal.AllocHGlobal(8);
                *ret = native;
                return ret;
            }

            private NestedNameSpecifierLoc(NestedNameSpecifierLoc.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected NestedNameSpecifierLoc(NestedNameSpecifierLoc.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            /// <summary>
            /// <para>Construct an empty nested-name-specifier.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Construct an empty nested-name-specifier.</para>
            /// </remarks>
            public NestedNameSpecifierLoc()
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            /// <summary>
            /// <para>Construct a nested-name-specifier with source location
            /// information from</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Construct a nested-name-specifier with source location
            /// information</para>
            /// <para>  /// from</para>
            /// </remarks>
            public NestedNameSpecifierLoc(clang.NestedNameSpecifier Qualifier, global::System.IntPtr Data)
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(Qualifier, null) ? global::System.IntPtr.Zero : Qualifier.__Instance;
                var arg1 = Data;
                Internal.ctor_1(__Instance, arg0, arg1);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.NestedNameSpecifierLoc __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            /// <summary>
            /// <para>Evalutes true when this nested-name-specifier location is
            /// non-empty.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Evalutes true when this nested-name-specifier location
            /// is</para>
            /// <para>  /// non-empty.</para>
            /// </remarks>
            public static implicit operator bool(clang.NestedNameSpecifierLoc __op)
            {
                var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
                var __ret = Internal.OperatorConversion_0(arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Evalutes true when this nested-name-specifier location is
            /// empty.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Evalutes true when this nested-name-specifier location
            /// is</para>
            /// <para>  /// empty.</para>
            /// </remarks>
            public bool hasQualifier()
            {
                var __ret = Internal.hasQualifier_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Retrieve the nested-name-specifier to which this instance
            /// refers.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the nested-name-specifier to which this
            /// instance</para>
            /// <para>  /// refers.</para>
            /// </remarks>
            public clang.NestedNameSpecifier getNestedNameSpecifier()
            {
                var __ret = Internal.getNestedNameSpecifier_0(__Instance);
                clang.NestedNameSpecifier __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.NestedNameSpecifier.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.NestedNameSpecifier) clang.NestedNameSpecifier.NativeToManagedMap[__ret];
                else __result0 = clang.NestedNameSpecifier.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Retrieve the opaque pointer that refers to source-location
            /// data.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the opaque pointer that refers to
            /// source-location data.</para>
            /// </remarks>
            public global::System.IntPtr getOpaqueData()
            {
                var __ret = Internal.getOpaqueData_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Retrieve the source range covering the entirety of this
            /// nested-name-specifier.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the source range covering the entirety of
            /// this</para>
            /// <para>  /// nested-name-specifier.</para>
            /// <para>  ///</para>
            /// <para>  /// For example, if this instance refers to a
            /// nested-name-specifier</para>
            /// <para>  /// \c \::std::vector&lt;int&gt;::, the returned source range
            /// would cover</para>
            /// <para>  /// from the initial '::' to the last '::'.</para>
            /// </remarks>
            public clang.SourceRange getSourceRange()
            {
                var __ret = Internal.getSourceRange_0(__Instance);
                return clang.SourceRange.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Retrieve the source range covering just the last part of this
            /// nested-name-specifier, not including the prefix.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the source range covering just the last part
            /// of</para>
            /// <para>  /// this nested-name-specifier, not including the
            /// prefix.</para>
            /// <para>  ///</para>
            /// <para>  /// For example, if this instance refers to a
            /// nested-name-specifier</para>
            /// <para>  /// \c \::std::vector&lt;int&gt;::, the returned source range
            /// would cover</para>
            /// <para>  /// from &quot;vector&quot; to the last '::'.</para>
            /// </remarks>
            public clang.SourceRange getLocalSourceRange()
            {
                var __ret = Internal.getLocalSourceRange_0(__Instance);
                return clang.SourceRange.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Retrieve the location of the beginning of this
            /// nested-name-specifier.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the location of the beginning of this</para>
            /// <para>  /// nested-name-specifier.</para>
            /// </remarks>
            public clang.SourceLocation getBeginLoc()
            {
                var __ret = Internal.getBeginLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Retrieve the location of the end of this
            /// nested-name-specifier.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the location of the end of this</para>
            /// <para>  /// nested-name-specifier.</para>
            /// </remarks>
            public clang.SourceLocation getEndLoc()
            {
                var __ret = Internal.getEndLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Retrieve the location of the beginning of this component of the
            /// nested-name-specifier.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the location of the beginning of this</para>
            /// <para>  /// component of the nested-name-specifier.</para>
            /// </remarks>
            public clang.SourceLocation getLocalBeginLoc()
            {
                var __ret = Internal.getLocalBeginLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Retrieve the location of the end of this component of the
            /// nested-name-specifier.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the location of the end of this component of
            /// the</para>
            /// <para>  /// nested-name-specifier.</para>
            /// </remarks>
            public clang.SourceLocation getLocalEndLoc()
            {
                var __ret = Internal.getLocalEndLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Return the prefix of this nested-name-specifier.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the prefix of this
            /// nested-name-specifier.</para>
            /// <para>  ///</para>
            /// <para>  /// For example, if this instance refers to a
            /// nested-name-specifier</para>
            /// <para>  /// \c \::std::vector&lt;int&gt;::, the prefix is \c \::std::.
            /// Note that the</para>
            /// <para>  /// returned prefix may be empty, if this is the first
            /// component of</para>
            /// <para>  /// the nested-name-specifier.</para>
            /// </remarks>
            public clang.NestedNameSpecifierLoc getPrefix()
            {
                var __ret = Internal.getPrefix_0(__Instance);
                return clang.NestedNameSpecifierLoc.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>For a nested-name-specifier that refers to a type, retrieve the
            /// type with source-location information.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief For a nested-name-specifier that refers to a
            /// type,</para>
            /// <para>  /// retrieve the type with source-location information.</para>
            /// </remarks>
            public clang.TypeLoc getTypeLoc()
            {
                var __ret = Internal.getTypeLoc_0(__Instance);
                return clang.TypeLoc.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Determines the data length for the entire
            /// nested-name-specifier.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determines the data length for the entire</para>
            /// <para>  /// nested-name-specifier.</para>
            /// </remarks>
            public uint getDataLength()
            {
                var __ret = Internal.getDataLength_1(__Instance);
                return __ret;
            }

            public static bool operator ==(clang.NestedNameSpecifierLoc X, clang.NestedNameSpecifierLoc Y)
            {
                bool XNull = ReferenceEquals(X, null);
                bool YNull = ReferenceEquals(Y, null);
                if (XNull || YNull)
                    return XNull && YNull;
                var arg0 = ReferenceEquals(X, null) ? new clang.NestedNameSpecifierLoc.Internal() : *(clang.NestedNameSpecifierLoc.Internal*) (X.__Instance);
                var arg1 = ReferenceEquals(Y, null) ? new clang.NestedNameSpecifierLoc.Internal() : *(clang.NestedNameSpecifierLoc.Internal*) (Y.__Instance);
                var __ret = Internal.OperatorEqualEqual_0(arg0, arg1);
                return __ret;
            }

            public override bool Equals(object obj)
            {
                return this == obj as NestedNameSpecifierLoc;
            }

            public static bool operator !=(clang.NestedNameSpecifierLoc X, clang.NestedNameSpecifierLoc Y)
            {
                var arg0 = ReferenceEquals(X, null) ? new clang.NestedNameSpecifierLoc.Internal() : *(clang.NestedNameSpecifierLoc.Internal*) (X.__Instance);
                var arg1 = ReferenceEquals(Y, null) ? new clang.NestedNameSpecifierLoc.Internal() : *(clang.NestedNameSpecifierLoc.Internal*) (Y.__Instance);
                var __ret = Internal.OperatorExclaimEqual_0(arg0, arg1);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Class that aids in the construction of nested-name-specifiers
        /// along with source-location information for all of the components of the
        /// nested-name-specifier.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief Class that aids in the construction of
        /// nested-name-specifiers along</para>
        /// <para>/// with source-location information for all of the components of
        /// the</para>
        /// <para>/// nested-name-specifier.</para>
        /// </remarks>
        public unsafe partial class NestedNameSpecifierLocBuilder : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr Representation;

                [FieldOffset(4)]
                public sbyte* Buffer;

                [FieldOffset(8)]
                public uint BufferSize;

                [FieldOffset(12)]
                public uint BufferCapacity;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang29NestedNameSpecifierLocBuilderC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang29NestedNameSpecifierLocBuilderC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr Other);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang29NestedNameSpecifierLocBuilderD2Ev")]
                internal static extern void dtor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang29NestedNameSpecifierLocBuilder17getRepresentationEv")]
                internal static extern global::System.IntPtr getRepresentation_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang29NestedNameSpecifierLocBuilder6ExtendERNS_10ASTContextENS_14SourceLocationENS_7TypeLocES3_")]
                internal static extern void Extend_0(global::System.IntPtr instance, global::System.IntPtr Context, clang.SourceLocation.Internal TemplateKWLoc, clang.TypeLoc.Internal TL, clang.SourceLocation.Internal ColonColonLoc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang29NestedNameSpecifierLocBuilder6ExtendERNS_10ASTContextEPNS_14IdentifierInfoENS_14SourceLocationES5_")]
                internal static extern void Extend_1(global::System.IntPtr instance, global::System.IntPtr Context, global::System.IntPtr Identifier, clang.SourceLocation.Internal IdentifierLoc, clang.SourceLocation.Internal ColonColonLoc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang29NestedNameSpecifierLocBuilder6ExtendERNS_10ASTContextEPNS_13NamespaceDeclENS_14SourceLocationES5_")]
                internal static extern void Extend_2(global::System.IntPtr instance, global::System.IntPtr Context, global::System.IntPtr Namespace, clang.SourceLocation.Internal NamespaceLoc, clang.SourceLocation.Internal ColonColonLoc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang29NestedNameSpecifierLocBuilder10MakeGlobalERNS_10ASTContextENS_14SourceLocationE")]
                internal static extern void MakeGlobal_0(global::System.IntPtr instance, global::System.IntPtr Context, clang.SourceLocation.Internal ColonColonLoc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang29NestedNameSpecifierLocBuilder11MakeTrivialERNS_10ASTContextEPNS_19NestedNameSpecifierENS_11SourceRangeE")]
                internal static extern void MakeTrivial_0(global::System.IntPtr instance, global::System.IntPtr Context, global::System.IntPtr Qualifier, clang.SourceRange.Internal R);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang29NestedNameSpecifierLocBuilder5AdoptENS_22NestedNameSpecifierLocE")]
                internal static extern void Adopt_0(global::System.IntPtr instance, clang.NestedNameSpecifierLoc.Internal Other);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang29NestedNameSpecifierLocBuilder14getSourceRangeEv")]
                internal static extern clang.SourceRange.Internal getSourceRange_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang29NestedNameSpecifierLocBuilder19getWithLocInContextERNS_10ASTContextE")]
                internal static extern clang.NestedNameSpecifierLoc.Internal getWithLocInContext_0(global::System.IntPtr instance, global::System.IntPtr Context);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang29NestedNameSpecifierLocBuilder12getTemporaryEv")]
                internal static extern clang.NestedNameSpecifierLoc.Internal getTemporary_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang29NestedNameSpecifierLocBuilder5ClearEv")]
                internal static extern void Clear_0(global::System.IntPtr instance);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, NestedNameSpecifierLocBuilder> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, NestedNameSpecifierLocBuilder>();

            private readonly bool __ownsNativeInstance;

            public static NestedNameSpecifierLocBuilder __CreateInstance(global::System.IntPtr native)
            {
                return new NestedNameSpecifierLocBuilder((NestedNameSpecifierLocBuilder.Internal*) native);
            }

            public static NestedNameSpecifierLocBuilder __CreateInstance(NestedNameSpecifierLocBuilder.Internal native)
            {
                return new NestedNameSpecifierLocBuilder(native);
            }

            private static NestedNameSpecifierLocBuilder.Internal* __CopyValue(NestedNameSpecifierLocBuilder.Internal native)
            {
                var ret = (NestedNameSpecifierLocBuilder.Internal*) Marshal.AllocHGlobal(16);
                *ret = native;
                return ret;
            }

            private NestedNameSpecifierLocBuilder(NestedNameSpecifierLocBuilder.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected NestedNameSpecifierLocBuilder(NestedNameSpecifierLocBuilder.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public NestedNameSpecifierLocBuilder()
            {
                __Instance = Marshal.AllocHGlobal(16);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.NestedNameSpecifierLocBuilder __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance || force)
                    Internal.dtor_0(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            /// <summary>
            /// <para>Retrieve the representation of the nested-name-specifier.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the representation of the
            /// nested-name-specifier.</para>
            /// </remarks>
            public clang.NestedNameSpecifier getRepresentation()
            {
                var __ret = Internal.getRepresentation_0(__Instance);
                clang.NestedNameSpecifier __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.NestedNameSpecifier.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.NestedNameSpecifier) clang.NestedNameSpecifier.NativeToManagedMap[__ret];
                else __result0 = clang.NestedNameSpecifier.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Extend the current nested-name-specifier by another
            /// nested-name-specifier component of the form 'type::'.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Extend the current nested-name-specifier by
            /// another</para>
            /// <para>  /// nested-name-specifier component of the form
            /// 'type::'.</para>
            /// <para>  ///</para>
            /// <para>  /// \param Context The AST context in which this
            /// nested-name-specifier</para>
            /// <para>  /// resides.</para>
            /// <para>  ///</para>
            /// <para>  /// \param TemplateKWLoc The location of the 'template'
            /// keyword, if present.</para>
            /// <para>  ///</para>
            /// <para>  /// \param TL The TypeLoc that describes the type preceding the
            /// '::'.</para>
            /// <para>  ///</para>
            /// <para>  /// \param ColonColonLoc The location of the trailing
            /// '::'.</para>
            /// </remarks>
            public void Extend(clang.ASTContext Context, clang.SourceLocation TemplateKWLoc, clang.TypeLoc TL, clang.SourceLocation ColonColonLoc)
            {
                var arg0 = ReferenceEquals(Context, null) ? global::System.IntPtr.Zero : Context.__Instance;
                var arg1 = ReferenceEquals(TemplateKWLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (TemplateKWLoc.__Instance);
                var arg2 = ReferenceEquals(TL, null) ? new clang.TypeLoc.Internal() : *(clang.TypeLoc.Internal*) (TL.__Instance);
                var arg3 = ReferenceEquals(ColonColonLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (ColonColonLoc.__Instance);
                Internal.Extend_0(__Instance, arg0, arg1, arg2, arg3);
            }

            /// <summary>
            /// <para>Extend the current nested-name-specifier by another
            /// nested-name-specifier component of the form 'identifier::'.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Extend the current nested-name-specifier by
            /// another</para>
            /// <para>  /// nested-name-specifier component of the form
            /// 'identifier::'.</para>
            /// <para>  ///</para>
            /// <para>  /// \param Context The AST context in which this
            /// nested-name-specifier</para>
            /// <para>  /// resides.</para>
            /// <para>  ///</para>
            /// <para>  /// \param Identifier The identifier.</para>
            /// <para>  ///</para>
            /// <para>  /// \param IdentifierLoc The location of the identifier.</para>
            /// <para>  ///</para>
            /// <para>  /// \param ColonColonLoc The location of the trailing
            /// '::'.</para>
            /// </remarks>
            public void Extend(clang.ASTContext Context, clang.IdentifierInfo Identifier, clang.SourceLocation IdentifierLoc, clang.SourceLocation ColonColonLoc)
            {
                var arg0 = ReferenceEquals(Context, null) ? global::System.IntPtr.Zero : Context.__Instance;
                var arg1 = ReferenceEquals(Identifier, null) ? global::System.IntPtr.Zero : Identifier.__Instance;
                var arg2 = ReferenceEquals(IdentifierLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (IdentifierLoc.__Instance);
                var arg3 = ReferenceEquals(ColonColonLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (ColonColonLoc.__Instance);
                Internal.Extend_1(__Instance, arg0, arg1, arg2, arg3);
            }

            /// <summary>
            /// <para>Extend the current nested-name-specifier by another
            /// nested-name-specifier component of the form 'namespace::'.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Extend the current nested-name-specifier by
            /// another</para>
            /// <para>  /// nested-name-specifier component of the form
            /// 'namespace::'.</para>
            /// <para>  ///</para>
            /// <para>  /// \param Context The AST context in which this
            /// nested-name-specifier</para>
            /// <para>  /// resides.</para>
            /// <para>  ///</para>
            /// <para>  /// \param Namespace The namespace.</para>
            /// <para>  ///</para>
            /// <para>  /// \param NamespaceLoc The location of the namespace
            /// name.</para>
            /// <para>  ///</para>
            /// <para>  /// \param ColonColonLoc The location of the trailing
            /// '::'.</para>
            /// </remarks>
            public void Extend(clang.ASTContext Context, clang.NamespaceDecl Namespace, clang.SourceLocation NamespaceLoc, clang.SourceLocation ColonColonLoc)
            {
                var arg0 = ReferenceEquals(Context, null) ? global::System.IntPtr.Zero : Context.__Instance;
                var arg1 = ReferenceEquals(Namespace, null) ? global::System.IntPtr.Zero : Namespace.__Instance;
                var arg2 = ReferenceEquals(NamespaceLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (NamespaceLoc.__Instance);
                var arg3 = ReferenceEquals(ColonColonLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (ColonColonLoc.__Instance);
                Internal.Extend_2(__Instance, arg0, arg1, arg2, arg3);
            }

            /// <summary>
            /// <para>Turn this (empty) nested-name-specifier into the global
            /// nested-name-specifier '::'.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Turn this (empty) nested-name-specifier into the
            /// global</para>
            /// <para>  /// nested-name-specifier '::'.</para>
            /// </remarks>
            public void MakeGlobal(clang.ASTContext Context, clang.SourceLocation ColonColonLoc)
            {
                var arg0 = ReferenceEquals(Context, null) ? global::System.IntPtr.Zero : Context.__Instance;
                var arg1 = ReferenceEquals(ColonColonLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (ColonColonLoc.__Instance);
                Internal.MakeGlobal_0(__Instance, arg0, arg1);
            }

            /// <summary>
            /// <para>Make a new nested-name-specifier from incomplete source-location
            /// information.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Make a new nested-name-specifier from incomplete
            /// source-location</para>
            /// <para>  /// information.</para>
            /// <para>  ///</para>
            /// <para>  /// This routine should be used very, very rarely, in cases
            /// where we</para>
            /// <para>  /// need to synthesize a nested-name-specifier. Most code
            /// should instead use</para>
            /// <para>  /// \c Adopt() with a proper \c NestedNameSpecifierLoc.</para>
            /// </remarks>
            public void MakeTrivial(clang.ASTContext Context, clang.NestedNameSpecifier Qualifier, clang.SourceRange R)
            {
                var arg0 = ReferenceEquals(Context, null) ? global::System.IntPtr.Zero : Context.__Instance;
                var arg1 = ReferenceEquals(Qualifier, null) ? global::System.IntPtr.Zero : Qualifier.__Instance;
                var arg2 = ReferenceEquals(R, null) ? new clang.SourceRange.Internal() : *(clang.SourceRange.Internal*) (R.__Instance);
                Internal.MakeTrivial_0(__Instance, arg0, arg1, arg2);
            }

            /// <summary>
            /// <para>Adopt an existing nested-name-specifier (with source-range
            /// information).</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Adopt an existing nested-name-specifier (with
            /// source-range</para>
            /// <para>  /// information).</para>
            /// </remarks>
            public void Adopt(clang.NestedNameSpecifierLoc Other)
            {
                var arg0 = ReferenceEquals(Other, null) ? new clang.NestedNameSpecifierLoc.Internal() : *(clang.NestedNameSpecifierLoc.Internal*) (Other.__Instance);
                Internal.Adopt_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>Retrieve the source range covered by this
            /// nested-name-specifier.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the source range covered by this
            /// nested-name-specifier.</para>
            /// </remarks>
            public clang.SourceRange getSourceRange()
            {
                var __ret = Internal.getSourceRange_0(__Instance);
                return clang.SourceRange.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Retrieve a nested-name-specifier with location information,
            /// copied into the given AST context.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve a nested-name-specifier with location
            /// information,</para>
            /// <para>  /// copied into the given AST context.</para>
            /// <para>  ///</para>
            /// <para>  /// \param Context The context into which this
            /// nested-name-specifier will be</para>
            /// <para>  /// copied.</para>
            /// </remarks>
            public clang.NestedNameSpecifierLoc getWithLocInContext(clang.ASTContext Context)
            {
                var arg0 = ReferenceEquals(Context, null) ? global::System.IntPtr.Zero : Context.__Instance;
                var __ret = Internal.getWithLocInContext_0(__Instance, arg0);
                return clang.NestedNameSpecifierLoc.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Retrieve a nested-name-specifier with location information based
            /// on the information in this builder.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve a nested-name-specifier with location</para>
            /// <para>  /// information based on the information in this
            /// builder.</para>
            /// <para>  ///</para>
            /// <para>  /// This loc will contain references to the builder's internal
            /// data and may</para>
            /// <para>  /// be invalidated by any change to the builder.</para>
            /// </remarks>
            public clang.NestedNameSpecifierLoc getTemporary()
            {
                var __ret = Internal.getTemporary_0(__Instance);
                return clang.NestedNameSpecifierLoc.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Clear out this builder, and prepare it to build another
            /// nested-name-specifier with source-location information.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Clear out this builder, and prepare it to build
            /// another</para>
            /// <para>  /// nested-name-specifier with source-location
            /// information.</para>
            /// </remarks>
            public void Clear()
            {
                Internal.Clear_0(__Instance);
            }
        }
    }
}
