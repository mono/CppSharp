//----------------------------------------------------------------------------
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
//----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace CppSharp
{
    public unsafe partial class StringRef
    {
        public partial struct Internal
        {
        }
    }

    namespace llvm
    {
        /// <summary>
        /// <para>StringRef - Represent a constant reference to a string, i.e. a
        /// character array and a length, which need not be null terminated.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// StringRef - Represent a constant reference to a string, i.e.
        /// a character</para>
        /// <para>  /// array and a length, which need not be null
        /// terminated.</para>
        /// <para>  ///</para>
        /// <para>  /// This class does not own the string data, it is expected to
        /// be used in</para>
        /// <para>  /// situations where the character data resides in some other
        /// buffer, whose</para>
        /// <para>  /// lifetime extends past that of the StringRef. For this
        /// reason, it is not in</para>
        /// <para>  /// general safe to store a StringRef.</para>
        /// </remarks>
        public unsafe partial class StringRef : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 8)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr Data;

                [FieldOffset(4)]
                public uint Length;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm9StringRefC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm9StringRefC2EPKc")]
                internal static extern void ctor_1(global::System.IntPtr instance, global::System.IntPtr Str);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm9StringRefC2EPKcm")]
                internal static extern void ctor_2(global::System.IntPtr instance, global::System.IntPtr data, uint length);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm9StringRefC2ERKS0_")]
                internal static extern void cctor_5(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm9StringRef5beginEv")]
                internal static extern global::System.IntPtr begin_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm9StringRef3endEv")]
                internal static extern global::System.IntPtr end_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm9StringRef11bytes_beginEv")]
                internal static extern byte* bytes_begin_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm9StringRef9bytes_endEv")]
                internal static extern byte* bytes_end_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm9StringRef4dataEv")]
                internal static extern global::System.IntPtr data_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm9StringRef5emptyEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool empty_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm9StringRef4sizeEv")]
                internal static extern uint size_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm9StringRef5frontEv")]
                internal static extern sbyte front_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm9StringRef4backEv")]
                internal static extern sbyte back_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm9StringRef6equalsES0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool equals_0(global::System.IntPtr instance, llvm.StringRef.Internal RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm9StringRef12equals_lowerES0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool equals_lower_0(global::System.IntPtr instance, llvm.StringRef.Internal RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm9StringRef7compareES0_")]
                internal static extern int compare_0(global::System.IntPtr instance, llvm.StringRef.Internal RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm9StringRef13compare_lowerES0_")]
                internal static extern int compare_lower_0(global::System.IntPtr instance, llvm.StringRef.Internal RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm9StringRef15compare_numericES0_")]
                internal static extern int compare_numeric_0(global::System.IntPtr instance, llvm.StringRef.Internal RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm9StringRef13edit_distanceES0_bj")]
                internal static extern uint edit_distance_0(global::System.IntPtr instance, llvm.StringRef.Internal Other, bool AllowReplacements, uint MaxEditDistance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm9StringRef10startswithES0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool startswith_0(global::System.IntPtr instance, llvm.StringRef.Internal Prefix);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm9StringRef16startswith_lowerES0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool startswith_lower_0(global::System.IntPtr instance, llvm.StringRef.Internal Prefix);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm9StringRef8endswithES0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool endswith_0(global::System.IntPtr instance, llvm.StringRef.Internal Suffix);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm9StringRef14endswith_lowerES0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool endswith_lower_0(global::System.IntPtr instance, llvm.StringRef.Internal Suffix);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm9StringRef4findEcm")]
                internal static extern uint find_0(global::System.IntPtr instance, sbyte C, uint From);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm9StringRef4findES0_m")]
                internal static extern uint find_1(global::System.IntPtr instance, llvm.StringRef.Internal Str, uint From);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm9StringRef5rfindEcm")]
                internal static extern uint rfind_0(global::System.IntPtr instance, sbyte C, uint From);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm9StringRef5rfindES0_")]
                internal static extern uint rfind_1(global::System.IntPtr instance, llvm.StringRef.Internal Str);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm9StringRef13find_first_ofEcm")]
                internal static extern uint find_first_of_0(global::System.IntPtr instance, sbyte C, uint From);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm9StringRef13find_first_ofES0_m")]
                internal static extern uint find_first_of_1(global::System.IntPtr instance, llvm.StringRef.Internal Chars, uint From);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm9StringRef17find_first_not_ofEcm")]
                internal static extern uint find_first_not_of_0(global::System.IntPtr instance, sbyte C, uint From);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm9StringRef17find_first_not_ofES0_m")]
                internal static extern uint find_first_not_of_1(global::System.IntPtr instance, llvm.StringRef.Internal Chars, uint From);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm9StringRef12find_last_ofEcm")]
                internal static extern uint find_last_of_0(global::System.IntPtr instance, sbyte C, uint From);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm9StringRef12find_last_ofES0_m")]
                internal static extern uint find_last_of_1(global::System.IntPtr instance, llvm.StringRef.Internal Chars, uint From);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm9StringRef16find_last_not_ofEcm")]
                internal static extern uint find_last_not_of_0(global::System.IntPtr instance, sbyte C, uint From);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm9StringRef16find_last_not_ofES0_m")]
                internal static extern uint find_last_not_of_1(global::System.IntPtr instance, llvm.StringRef.Internal Chars, uint From);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm9StringRef5countEc")]
                internal static extern uint count_0(global::System.IntPtr instance, sbyte C);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm9StringRef5countES0_")]
                internal static extern uint count_1(global::System.IntPtr instance, llvm.StringRef.Internal Str);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm9StringRef12getAsIntegerEjRNS_5APIntE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool getAsInteger_0(global::System.IntPtr instance, uint Radix, global::System.IntPtr Result);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm9StringRef6substrEmm")]
                internal static extern llvm.StringRef.Internal substr_0(global::System.IntPtr instance, uint Start, uint N);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm9StringRef10drop_frontEm")]
                internal static extern llvm.StringRef.Internal drop_front_0(global::System.IntPtr instance, uint N);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm9StringRef9drop_backEm")]
                internal static extern llvm.StringRef.Internal drop_back_0(global::System.IntPtr instance, uint N);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm9StringRef5sliceEmm")]
                internal static extern llvm.StringRef.Internal slice_0(global::System.IntPtr instance, uint Start, uint End);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm9StringRef5ltrimES0_")]
                internal static extern llvm.StringRef.Internal ltrim_0(global::System.IntPtr instance, llvm.StringRef.Internal Chars);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm9StringRef5rtrimES0_")]
                internal static extern llvm.StringRef.Internal rtrim_0(global::System.IntPtr instance, llvm.StringRef.Internal Chars);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm9StringRef4trimES0_")]
                internal static extern llvm.StringRef.Internal trim_0(global::System.IntPtr instance, llvm.StringRef.Internal Chars);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvmeqENS_9StringRefES0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorEqualEqual_0(llvm.StringRef.Internal LHS, llvm.StringRef.Internal RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvmneENS_9StringRefES0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorExclaimEqual_0(llvm.StringRef.Internal LHS, llvm.StringRef.Internal RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvmltENS_9StringRefES0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorLess_0(llvm.StringRef.Internal LHS, llvm.StringRef.Internal RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvmleENS_9StringRefES0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorLessEqual_0(llvm.StringRef.Internal LHS, llvm.StringRef.Internal RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvmgtENS_9StringRefES0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorGreater_0(llvm.StringRef.Internal LHS, llvm.StringRef.Internal RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvmgeENS_9StringRefES0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorGreaterEqual_0(llvm.StringRef.Internal LHS, llvm.StringRef.Internal RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvmplEPKcRKNS_9StringRefE")]
                internal static extern void OperatorPlus_0(global::System.IntPtr @return, global::System.IntPtr LHS, global::System.IntPtr RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvmplERKNS_9StringRefEPKc")]
                internal static extern void OperatorPlus_1(global::System.IntPtr @return, global::System.IntPtr LHS, global::System.IntPtr RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm9StringRefixEm")]
                internal static extern sbyte OperatorSubscript_0(global::System.IntPtr instance, uint Index);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, StringRef> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, StringRef>();

            private readonly bool __ownsNativeInstance;

            public static StringRef __CreateInstance(global::System.IntPtr native)
            {
                return new StringRef((StringRef.Internal*) native);
            }

            public static StringRef __CreateInstance(StringRef.Internal native)
            {
                return new StringRef(native);
            }

            private static StringRef.Internal* __CopyValue(StringRef.Internal native)
            {
                var ret = (StringRef.Internal*) Marshal.AllocHGlobal(8);
                *ret = native;
                return ret;
            }

            private StringRef(StringRef.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected StringRef(StringRef.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            /// <summary>
            /// <para>Construct an empty string ref.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Construct an empty string ref.</para>
            /// </remarks>
            public StringRef()
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            /// <summary>
            /// <para>Construct a string ref from a cstring.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Construct a string ref from a cstring.</para>
            /// </remarks>
            public StringRef(string Str)
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = Marshal.StringToHGlobalAnsi(Str);
                Internal.ctor_1(__Instance, arg0);
                Marshal.FreeHGlobal(arg0);
            }

            /// <summary>
            /// <para>Construct a string ref from a pointer and length.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Construct a string ref from a pointer and length.</para>
            /// </remarks>
            public StringRef(string data, uint length)
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = Marshal.StringToHGlobalAnsi(data);
                var arg1 = length;
                Internal.ctor_2(__Instance, arg0, arg1);
                Marshal.FreeHGlobal(arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                llvm.StringRef __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            /// <summary>
            /// <para>@} @{</para>
            /// </summary>
            /// <remarks>
            /// <para>/// @}</para>
            /// <para>    /// @name Iterators</para>
            /// <para>    /// @{</para>
            /// </remarks>
            public string begin()
            {
                var __ret = Internal.begin_0(__Instance);
                return Marshal.PtrToStringAnsi(__ret);
            }

            public string end()
            {
                var __ret = Internal.end_0(__Instance);
                return Marshal.PtrToStringAnsi(__ret);
            }

            public byte* bytes_begin()
            {
                var __ret = Internal.bytes_begin_0(__Instance);
                return __ret;
            }

            public byte* bytes_end()
            {
                var __ret = Internal.bytes_end_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>data - Get a pointer to the start of the string (which may not be
            /// null terminated).</para>
            /// </summary>
            /// <remarks>
            /// <para>/// data - Get a pointer to the start of the string (which may
            /// not be null</para>
            /// <para>    /// terminated).</para>
            /// </remarks>
            public string data()
            {
                var __ret = Internal.data_0(__Instance);
                return Marshal.PtrToStringAnsi(__ret);
            }

            /// <summary>
            /// <para>empty - Check if the string is empty.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// empty - Check if the string is empty.</para>
            /// </remarks>
            public bool empty()
            {
                var __ret = Internal.empty_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>size - Get the string size.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// size - Get the string size.</para>
            /// </remarks>
            public uint size()
            {
                var __ret = Internal.size_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>front - Get the first character in the string.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// front - Get the first character in the string.</para>
            /// </remarks>
            public sbyte front()
            {
                var __ret = Internal.front_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>back - Get the last character in the string.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// back - Get the last character in the string.</para>
            /// </remarks>
            public sbyte back()
            {
                var __ret = Internal.back_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>equals - Check for string equality, this is more efficient than
            /// compare() when the relative ordering of inequal strings isn't
            /// needed.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// equals - Check for string equality, this is more efficient
            /// than</para>
            /// <para>    /// compare() when the relative ordering of inequal strings
            /// isn't needed.</para>
            /// </remarks>
            public bool equals(llvm.StringRef RHS)
            {
                var arg0 = ReferenceEquals(RHS, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (RHS.__Instance);
                var __ret = Internal.equals_0(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>equals_lower - Check for string equality, ignoring case.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// equals_lower - Check for string equality, ignoring
            /// case.</para>
            /// </remarks>
            public bool equals_lower(llvm.StringRef RHS)
            {
                var arg0 = ReferenceEquals(RHS, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (RHS.__Instance);
                var __ret = Internal.equals_lower_0(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>compare - Compare two strings; the result is -1, 0, or 1 if this
            /// string is lexicographically less than, equal to, or greater than the
            /// RHS.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// compare - Compare two strings; the result is -1, 0, or 1 if
            /// this string</para>
            /// <para>    /// is lexicographically less than, equal to, or greater than
            /// the \p RHS.</para>
            /// </remarks>
            public int compare(llvm.StringRef RHS)
            {
                var arg0 = ReferenceEquals(RHS, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (RHS.__Instance);
                var __ret = Internal.compare_0(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>compare_lower - Compare two strings, ignoring case.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// compare_lower - Compare two strings, ignoring case.</para>
            /// </remarks>
            public int compare_lower(llvm.StringRef RHS)
            {
                var arg0 = ReferenceEquals(RHS, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (RHS.__Instance);
                var __ret = Internal.compare_lower_0(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>compare_numeric - Compare two strings, treating sequences of
            /// digits as numbers.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// compare_numeric - Compare two strings, treating sequences of
            /// digits as</para>
            /// <para>    /// numbers.</para>
            /// </remarks>
            public int compare_numeric(llvm.StringRef RHS)
            {
                var arg0 = ReferenceEquals(RHS, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (RHS.__Instance);
                var __ret = Internal.compare_numeric_0(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Determine the edit distance between this string and another
            /// string.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine the edit distance between this string and
            /// another</para>
            /// <para>    /// string.</para>
            /// <para>    ///</para>
            /// <para>    /// \param Other the string to compare this string
            /// against.</para>
            /// <para>    ///</para>
            /// <para>    /// \param AllowReplacements whether to allow
            /// character</para>
            /// <para>    /// replacements (change one character into another) as a
            /// single</para>
            /// <para>    /// operation, rather than as two operations (an insertion
            /// and a</para>
            /// <para>    /// removal).</para>
            /// <para>    ///</para>
            /// <para>    /// \param MaxEditDistance If non-zero, the maximum edit
            /// distance that</para>
            /// <para>    /// this routine is allowed to compute. If the edit distance
            /// will exceed</para>
            /// <para>    /// that maximum, returns \c MaxEditDistance+1.</para>
            /// <para>    ///</para>
            /// <para>    /// \returns the minimum number of character insertions,
            /// removals,</para>
            /// <para>    /// or (if \p AllowReplacements is \c true) replacements
            /// needed to</para>
            /// <para>    /// transform one of the given strings into the other. If
            /// zero,</para>
            /// <para>    /// the strings are identical.</para>
            /// </remarks>
            public uint edit_distance(llvm.StringRef Other, bool AllowReplacements, uint MaxEditDistance)
            {
                var arg0 = ReferenceEquals(Other, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (Other.__Instance);
                var __ret = Internal.edit_distance_0(__Instance, arg0, AllowReplacements, MaxEditDistance);
                return __ret;
            }

            /// <summary>
            /// <para>Check if this string starts with the given Prefix.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Check if this string starts with the given \p Prefix.</para>
            /// </remarks>
            public bool startswith(llvm.StringRef Prefix)
            {
                var arg0 = ReferenceEquals(Prefix, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (Prefix.__Instance);
                var __ret = Internal.startswith_0(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Check if this string starts with the given Prefix, ignoring
            /// case.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Check if this string starts with the given \p Prefix,
            /// ignoring case.</para>
            /// </remarks>
            public bool startswith_lower(llvm.StringRef Prefix)
            {
                var arg0 = ReferenceEquals(Prefix, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (Prefix.__Instance);
                var __ret = Internal.startswith_lower_0(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Check if this string ends with the given Suffix.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Check if this string ends with the given \p Suffix.</para>
            /// </remarks>
            public bool endswith(llvm.StringRef Suffix)
            {
                var arg0 = ReferenceEquals(Suffix, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (Suffix.__Instance);
                var __ret = Internal.endswith_0(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Check if this string ends with the given Suffix, ignoring
            /// case.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Check if this string ends with the given \p Suffix, ignoring
            /// case.</para>
            /// </remarks>
            public bool endswith_lower(llvm.StringRef Suffix)
            {
                var arg0 = ReferenceEquals(Suffix, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (Suffix.__Instance);
                var __ret = Internal.endswith_lower_0(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Search for the first character C in the string.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Search for the first character \p C in the string.</para>
            /// <para>    ///</para>
            /// <para>    /// \returns The index of the first occurrence of \p C, or
            /// npos if not</para>
            /// <para>    /// found.</para>
            /// </remarks>
            public uint find(sbyte C, uint From)
            {
                var arg1 = From;
                var __ret = Internal.find_0(__Instance, C, arg1);
                return __ret;
            }

            /// <summary>
            /// <para>Search for the first string Str in the string.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Search for the first string \p Str in the string.</para>
            /// <para>    ///</para>
            /// <para>    /// \returns The index of the first occurrence of \p Str, or
            /// npos if not</para>
            /// <para>    /// found.</para>
            /// </remarks>
            public uint find(llvm.StringRef Str, uint From)
            {
                var arg0 = ReferenceEquals(Str, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (Str.__Instance);
                var arg1 = From;
                var __ret = Internal.find_1(__Instance, arg0, arg1);
                return __ret;
            }

            /// <summary>
            /// <para>Search for the last character C in the string.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Search for the last character \p C in the string.</para>
            /// <para>    ///</para>
            /// <para>    /// \returns The index of the last occurrence of \p C, or
            /// npos if not</para>
            /// <para>    /// found.</para>
            /// </remarks>
            public uint rfind(sbyte C, uint From)
            {
                var arg1 = From;
                var __ret = Internal.rfind_0(__Instance, C, arg1);
                return __ret;
            }

            /// <summary>
            /// <para>Search for the last string Str in the string.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Search for the last string \p Str in the string.</para>
            /// <para>    ///</para>
            /// <para>    /// \returns The index of the last occurrence of \p Str, or
            /// npos if not</para>
            /// <para>    /// found.</para>
            /// </remarks>
            public uint rfind(llvm.StringRef Str)
            {
                var arg0 = ReferenceEquals(Str, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (Str.__Instance);
                var __ret = Internal.rfind_1(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Find the first character in the string that is C, or npos if not
            /// found. Same as find.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Find the first character in the string that is \p C, or npos
            /// if not</para>
            /// <para>    /// found. Same as find.</para>
            /// </remarks>
            public uint find_first_of(sbyte C, uint From)
            {
                var arg1 = From;
                var __ret = Internal.find_first_of_0(__Instance, C, arg1);
                return __ret;
            }

            /// <summary>
            /// <para>Find the first character in the string that is in Chars, or npos
            /// if not found.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Find the first character in the string that is in \p Chars,
            /// or npos if</para>
            /// <para>    /// not found.</para>
            /// <para>    ///</para>
            /// <para>    /// Complexity: O(size() + Chars.size())</para>
            /// </remarks>
            public uint find_first_of(llvm.StringRef Chars, uint From)
            {
                var arg0 = ReferenceEquals(Chars, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (Chars.__Instance);
                var arg1 = From;
                var __ret = Internal.find_first_of_1(__Instance, arg0, arg1);
                return __ret;
            }

            /// <summary>
            /// <para>Find the first character in the string that is not C or npos if
            /// not found.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Find the first character in the string that is not \p C or
            /// npos if not</para>
            /// <para>    /// found.</para>
            /// </remarks>
            public uint find_first_not_of(sbyte C, uint From)
            {
                var arg1 = From;
                var __ret = Internal.find_first_not_of_0(__Instance, C, arg1);
                return __ret;
            }

            /// <summary>
            /// <para>Find the first character in the string that is not in the string
            /// Chars, or npos if not found.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Find the first character in the string that is not in the
            /// string</para>
            /// <para>    /// \p Chars, or npos if not found.</para>
            /// <para>    ///</para>
            /// <para>    /// Complexity: O(size() + Chars.size())</para>
            /// </remarks>
            public uint find_first_not_of(llvm.StringRef Chars, uint From)
            {
                var arg0 = ReferenceEquals(Chars, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (Chars.__Instance);
                var arg1 = From;
                var __ret = Internal.find_first_not_of_1(__Instance, arg0, arg1);
                return __ret;
            }

            /// <summary>
            /// <para>Find the last character in the string that is C, or npos if not
            /// found.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Find the last character in the string that is \p C, or npos
            /// if not</para>
            /// <para>    /// found.</para>
            /// </remarks>
            public uint find_last_of(sbyte C, uint From)
            {
                var arg1 = From;
                var __ret = Internal.find_last_of_0(__Instance, C, arg1);
                return __ret;
            }

            /// <summary>
            /// <para>Find the last character in the string that is in C, or npos if
            /// not found.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Find the last character in the string that is in \p C, or
            /// npos if not</para>
            /// <para>    /// found.</para>
            /// <para>    ///</para>
            /// <para>    /// Complexity: O(size() + Chars.size())</para>
            /// </remarks>
            public uint find_last_of(llvm.StringRef Chars, uint From)
            {
                var arg0 = ReferenceEquals(Chars, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (Chars.__Instance);
                var arg1 = From;
                var __ret = Internal.find_last_of_1(__Instance, arg0, arg1);
                return __ret;
            }

            /// <summary>
            /// <para>Find the last character in the string that is not C, or npos if
            /// not found.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Find the last character in the string that is not \p C, or
            /// npos if not</para>
            /// <para>    /// found.</para>
            /// </remarks>
            public uint find_last_not_of(sbyte C, uint From)
            {
                var arg1 = From;
                var __ret = Internal.find_last_not_of_0(__Instance, C, arg1);
                return __ret;
            }

            /// <summary>
            /// <para>Find the last character in the string that is not in Chars, or
            /// npos if not found.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Find the last character in the string that is not in \p
            /// Chars, or</para>
            /// <para>    /// npos if not found.</para>
            /// <para>    ///</para>
            /// <para>    /// Complexity: O(size() + Chars.size())</para>
            /// </remarks>
            public uint find_last_not_of(llvm.StringRef Chars, uint From)
            {
                var arg0 = ReferenceEquals(Chars, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (Chars.__Instance);
                var arg1 = From;
                var __ret = Internal.find_last_not_of_1(__Instance, arg0, arg1);
                return __ret;
            }

            /// <summary>
            /// <para>Return the number of occurrences of C in the string.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Return the number of occurrences of \p C in the
            /// string.</para>
            /// </remarks>
            public uint count(sbyte C)
            {
                var __ret = Internal.count_0(__Instance, C);
                return __ret;
            }

            /// <summary>
            /// <para>Return the number of non-overlapped occurrences of Str in the
            /// string.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Return the number of non-overlapped occurrences of \p Str
            /// in</para>
            /// <para>    /// the string.</para>
            /// </remarks>
            public uint count(llvm.StringRef Str)
            {
                var arg0 = ReferenceEquals(Str, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (Str.__Instance);
                var __ret = Internal.count_1(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Parse the current string as an integer of the specified Radix, or
            /// of an autosensed radix if the Radix given is 0. The current value in Result
            /// is discarded, and the storage is changed to be wide enough to store the
            /// parsed integer.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Parse the current string as an integer of the specified \p
            /// Radix, or of</para>
            /// <para>    /// an autosensed radix if the \p Radix given is 0.  The
            /// current value in</para>
            /// <para>    /// \p Result is discarded, and the storage is changed to be
            /// wide enough to</para>
            /// <para>    /// store the parsed integer.</para>
            /// <para>    ///</para>
            /// <para>    /// \returns true if the string does not solely consist of a
            /// valid</para>
            /// <para>    /// non-empty number in the appropriate base.</para>
            /// <para>    ///</para>
            /// <para>    /// APInt::fromString is superficially similar but assumes
            /// the</para>
            /// <para>    /// string is well-formed in the given radix.</para>
            /// </remarks>
            public bool getAsInteger(uint Radix, llvm.APInt Result)
            {
                var arg1 = ReferenceEquals(Result, null) ? global::System.IntPtr.Zero : Result.__Instance;
                var __ret = Internal.getAsInteger_0(__Instance, Radix, arg1);
                return __ret;
            }

            /// <summary>
            /// <para>Return a reference to the substring from [Start, Start +
            /// N).</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Return a reference to the substring from [Start, Start +
            /// N).</para>
            /// <para>    ///</para>
            /// <para>    /// \param Start The index of the starting character in the
            /// substring; if</para>
            /// <para>    /// the index is npos or greater than the length of the
            /// string then the</para>
            /// <para>    /// empty substring will be returned.</para>
            /// <para>    ///</para>
            /// <para>    /// \param N The number of characters to included in the
            /// substring. If N</para>
            /// <para>    /// exceeds the number of characters remaining in the string,
            /// the string</para>
            /// <para>    /// suffix (starting with \p Start) will be returned.</para>
            /// </remarks>
            public llvm.StringRef substr(uint Start, uint N)
            {
                var arg0 = Start;
                var arg1 = N;
                var __ret = Internal.substr_0(__Instance, arg0, arg1);
                return llvm.StringRef.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Return a StringRef equal to 'this' but with the first N elements
            /// dropped.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Return a StringRef equal to 'this' but with the first \p N
            /// elements</para>
            /// <para>    /// dropped.</para>
            /// </remarks>
            public llvm.StringRef drop_front(uint N)
            {
                var arg0 = N;
                var __ret = Internal.drop_front_0(__Instance, arg0);
                return llvm.StringRef.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Return a StringRef equal to 'this' but with the last N elements
            /// dropped.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Return a StringRef equal to 'this' but with the last \p N
            /// elements</para>
            /// <para>    /// dropped.</para>
            /// </remarks>
            public llvm.StringRef drop_back(uint N)
            {
                var arg0 = N;
                var __ret = Internal.drop_back_0(__Instance, arg0);
                return llvm.StringRef.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Return a reference to the substring from [Start, End).</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Return a reference to the substring from [Start, End).</para>
            /// <para>    ///</para>
            /// <para>    /// \param Start The index of the starting character in the
            /// substring; if</para>
            /// <para>    /// the index is npos or greater than the length of the
            /// string then the</para>
            /// <para>    /// empty substring will be returned.</para>
            /// <para>    ///</para>
            /// <para>    /// \param End The index following the last character to
            /// include in the</para>
            /// <para>    /// substring. If this is npos, or less than \p Start, or
            /// exceeds the</para>
            /// <para>    /// number of characters remaining in the string, the string
            /// suffix</para>
            /// <para>    /// (starting with \p Start) will be returned.</para>
            /// </remarks>
            public llvm.StringRef slice(uint Start, uint End)
            {
                var arg0 = Start;
                var arg1 = End;
                var __ret = Internal.slice_0(__Instance, arg0, arg1);
                return llvm.StringRef.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Return string with consecutive characters in Chars starting from
            /// the left removed.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Return string with consecutive characters in \p Chars
            /// starting from</para>
            /// <para>    /// the left removed.</para>
            /// </remarks>
            public llvm.StringRef ltrim(llvm.StringRef Chars)
            {
                var arg0 = ReferenceEquals(Chars, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (Chars.__Instance);
                var __ret = Internal.ltrim_0(__Instance, arg0);
                return llvm.StringRef.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Return string with consecutive characters in Chars starting from
            /// the right removed.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Return string with consecutive characters in \p Chars
            /// starting from</para>
            /// <para>    /// the right removed.</para>
            /// </remarks>
            public llvm.StringRef rtrim(llvm.StringRef Chars)
            {
                var arg0 = ReferenceEquals(Chars, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (Chars.__Instance);
                var __ret = Internal.rtrim_0(__Instance, arg0);
                return llvm.StringRef.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Return string with consecutive characters in Chars starting from
            /// the left and right removed.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Return string with consecutive characters in \p Chars
            /// starting from</para>
            /// <para>    /// the left and right removed.</para>
            /// </remarks>
            public llvm.StringRef trim(llvm.StringRef Chars)
            {
                var arg0 = ReferenceEquals(Chars, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (Chars.__Instance);
                var __ret = Internal.trim_0(__Instance, arg0);
                return llvm.StringRef.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>@{</para>
            /// </summary>
            /// <remarks>
            /// <para>/// @name StringRef Comparison Operators</para>
            /// <para>  /// @{</para>
            /// </remarks>
            public static bool operator ==(llvm.StringRef LHS, llvm.StringRef RHS)
            {
                bool LHSNull = ReferenceEquals(LHS, null);
                bool RHSNull = ReferenceEquals(RHS, null);
                if (LHSNull || RHSNull)
                    return LHSNull && RHSNull;
                var arg0 = ReferenceEquals(LHS, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (LHS.__Instance);
                var arg1 = ReferenceEquals(RHS, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (RHS.__Instance);
                var __ret = Internal.OperatorEqualEqual_0(arg0, arg1);
                return __ret;
            }

            public override bool Equals(object obj)
            {
                return this == obj as StringRef;
            }

            public static bool operator !=(llvm.StringRef LHS, llvm.StringRef RHS)
            {
                var arg0 = ReferenceEquals(LHS, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (LHS.__Instance);
                var arg1 = ReferenceEquals(RHS, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (RHS.__Instance);
                var __ret = Internal.OperatorExclaimEqual_0(arg0, arg1);
                return __ret;
            }

            public static bool operator <(llvm.StringRef LHS, llvm.StringRef RHS)
            {
                var arg0 = ReferenceEquals(LHS, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (LHS.__Instance);
                var arg1 = ReferenceEquals(RHS, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (RHS.__Instance);
                var __ret = Internal.OperatorLess_0(arg0, arg1);
                return __ret;
            }

            public static bool operator <=(llvm.StringRef LHS, llvm.StringRef RHS)
            {
                var arg0 = ReferenceEquals(LHS, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (LHS.__Instance);
                var arg1 = ReferenceEquals(RHS, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (RHS.__Instance);
                var __ret = Internal.OperatorLessEqual_0(arg0, arg1);
                return __ret;
            }

            public static bool operator >(llvm.StringRef LHS, llvm.StringRef RHS)
            {
                var arg0 = ReferenceEquals(LHS, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (LHS.__Instance);
                var arg1 = ReferenceEquals(RHS, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (RHS.__Instance);
                var __ret = Internal.OperatorGreater_0(arg0, arg1);
                return __ret;
            }

            public static bool operator >=(llvm.StringRef LHS, llvm.StringRef RHS)
            {
                var arg0 = ReferenceEquals(LHS, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (LHS.__Instance);
                var arg1 = ReferenceEquals(RHS, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (RHS.__Instance);
                var __ret = Internal.OperatorGreaterEqual_0(arg0, arg1);
                return __ret;
            }

            /// <summary>
            /// <para>Additional overload to guarantee simplified codegen; this is
            /// equivalent to concat().</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Additional overload to guarantee simplified codegen; this is
            /// equivalent to</para>
            /// <para>  /// concat().</para>
            /// </remarks>
            public static llvm.Twine operator +(string LHS, llvm.StringRef RHS)
            {
                var arg0 = Marshal.StringToHGlobalAnsi(LHS);
                var arg1 = ReferenceEquals(RHS, null) ? global::System.IntPtr.Zero : RHS.__Instance;
                var __ret = new llvm.Twine.Internal();
                Internal.OperatorPlus_0(new IntPtr(&__ret), arg0, arg1);
                Marshal.FreeHGlobal(arg0);
                return llvm.Twine.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Additional overload to guarantee simplified codegen; this is
            /// equivalent to concat().</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Additional overload to guarantee simplified codegen; this is
            /// equivalent to</para>
            /// <para>  /// concat().</para>
            /// </remarks>
            public static llvm.Twine operator +(llvm.StringRef LHS, string RHS)
            {
                var arg0 = ReferenceEquals(LHS, null) ? global::System.IntPtr.Zero : LHS.__Instance;
                var arg1 = Marshal.StringToHGlobalAnsi(RHS);
                var __ret = new llvm.Twine.Internal();
                Internal.OperatorPlus_1(new IntPtr(&__ret), arg0, arg1);
                Marshal.FreeHGlobal(arg1);
                return llvm.Twine.__CreateInstance(__ret);
            }

            public static uint npos
            {
                get
                {
                    var __ptr = (uint*)CppSharp.SymbolResolver.ResolveSymbol("CppSharp", "_ZN4llvm9StringRef4nposE");
                    return *__ptr;
                }
            }

            public sbyte this[uint Index]
            {
                get
                {
                    var arg0 = Index;
                    var __ret = Internal.OperatorSubscript_0(__Instance, arg0);
                    return __ret;
                }
            }
        }

        public unsafe partial class StringRef
        {
            public partial struct Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm20getAsUnsignedIntegerENS_9StringRefEjRy")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool getAsUnsignedInteger_0(llvm.StringRef.Internal Str, uint Radix, ulong* Result);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm18getAsSignedIntegerENS_9StringRefEjRx")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool getAsSignedInteger_0(llvm.StringRef.Internal Str, uint Radix, long* Result);
            }

            /// <summary>
            /// <para>Helper functions for StringRef::getAsInteger.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Helper functions for StringRef::getAsInteger.</para>
            /// </remarks>
            public static bool getAsUnsignedInteger(llvm.StringRef Str, uint Radix, ref ulong Result)
            {
                var arg0 = ReferenceEquals(Str, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (Str.__Instance);
                fixed (ulong* arg2 = &Result)
                {
                    var __ret = Internal.getAsUnsignedInteger_0(arg0, Radix, arg2);
                    return __ret;
                }
            }

            public static bool getAsSignedInteger(llvm.StringRef Str, uint Radix, ref long Result)
            {
                var arg0 = ReferenceEquals(Str, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (Str.__Instance);
                fixed (long* arg2 = &Result)
                {
                    var __ret = Internal.getAsSignedInteger_0(arg0, Radix, arg2);
                    return __ret;
                }
            }
        }
    }
}
