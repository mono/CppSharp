//----------------------------------------------------------------------------
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
//----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace CppSharp
{
    namespace clang
    {
        /// <summary>
        /// <para>Enumeration describing the result of loading information from an
        /// external source.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief Enumeration describing the result of loading
        /// information from</para>
        /// <para>/// an external source.</para>
        /// </remarks>
        public enum ExternalLoadResult : uint
        {
            /// <summary>Loading the external information has succeeded.</summary>
            ELR_Success = 0,
            /// <summary>Loading the external information has failed.</summary>
            ELR_Failure = 1,
            /// <summary>The external information has already been loaded, and therefore no additional processing is required.</summary>
            ELR_AlreadyLoaded = 2
        }

        /// <summary>
        /// <para>A lazy value (of type T) that is within an AST node of type
        /// Owner, where the value might change in later generations of the external
        /// AST source.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief A lazy value (of type T) that is within an AST node of
        /// type Owner,</para>
        /// <para>/// where the value might change in later generations of the
        /// external AST</para>
        /// <para>/// source.</para>
        /// </remarks>
        public unsafe partial class LazyGenerationalUpdatePtr
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct Internal
            {
            }

            /// <summary>
            /// <para>A cache of the value of this pointer, in the most recent
            /// generation in which we queried it.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// A cache of the value of this pointer, in the most recent
            /// generation in</para>
            /// <para>  /// which we queried it.</para>
            /// </remarks>
            public unsafe partial class LazyData
            {
                [StructLayout(LayoutKind.Explicit, Size = 0)]
                public partial struct Internal
                {
                    [FieldOffset(204311656)]
                    public global::System.IntPtr ExternalSource;

                    [FieldOffset(76302533)]
                    public uint LastGeneration;
                }
            }
        }

        /// <summary>
        /// <para>A lazy pointer to an AST node (of base type T) that resides
        /// within an external AST source.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief A lazy pointer to an AST node (of base type T) that
        /// resides</para>
        /// <para>/// within an external AST source.</para>
        /// <para>///</para>
        /// <para>/// The AST node is identified within the external AST source by
        /// a</para>
        /// <para>/// 63-bit offset, and can be retrieved via an operation on
        /// the</para>
        /// <para>/// external AST source itself.</para>
        /// </remarks>
        public unsafe partial class LazyOffsetPtr
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public ulong Ptr;
            }
        }

        /// <summary>
        /// <para>Represents a lazily-loaded vector of data.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief Represents a lazily-loaded vector of data.</para>
        /// <para>///</para>
        /// <para>/// The lazily-loaded vector of data contains data that is
        /// partially loaded</para>
        /// <para>/// from an external source and partially added by local
        /// translation. The </para>
        /// <para>/// items loaded from the external source are loaded lazily, when
        /// needed for</para>
        /// <para>/// iteration over the complete vector.</para>
        /// </remarks>
        public unsafe partial class LazyVector
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct Internal
            {
            }

            public unsafe partial class iterator
            {
                [StructLayout(LayoutKind.Explicit, Size = 0)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public global::System.IntPtr Self;

                    [FieldOffset(0)]
                    public int Position;
                }
            }
        }

        /// <summary>
        /// <para>Abstract interface for external sources of AST nodes.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief Abstract interface for external sources of AST
        /// nodes.</para>
        /// <para>///</para>
        /// <para>/// External AST sources provide AST nodes constructed from
        /// some</para>
        /// <para>/// external source, such as a precompiled header. External
        /// AST</para>
        /// <para>/// sources can resolve types and declarations from abstract IDs
        /// into</para>
        /// <para>/// actual type and declaration nodes, and read parts of
        /// declaration</para>
        /// <para>/// contexts.</para>
        /// </remarks>
        public unsafe partial class ExternalASTSource : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public partial struct Internal
            {
                [FieldOffset(8)]
                public uint CurrentGeneration;

                [FieldOffset(12)]
                public bool SemaSource;

                [FieldOffset(0)]
                public global::System.IntPtr vfptr0;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17ExternalASTSourceC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17ExternalASTSourceC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17ExternalASTSourceD2Ev")]
                internal static extern void dtor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17ExternalASTSource13getGenerationEv")]
                internal static extern uint getGeneration_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17ExternalASTSource15GetExternalDeclEj")]
                internal static extern global::System.IntPtr GetExternalDecl_0(global::System.IntPtr instance, uint ID);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17ExternalASTSource19GetExternalSelectorEj")]
                internal static extern clang.Selector.Internal GetExternalSelector_0(global::System.IntPtr instance, uint ID);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17ExternalASTSource23GetNumExternalSelectorsEv")]
                internal static extern uint GetNumExternalSelectors_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17ExternalASTSource19GetExternalDeclStmtEy")]
                internal static extern global::System.IntPtr GetExternalDeclStmt_0(global::System.IntPtr instance, ulong Offset);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17ExternalASTSource25updateOutOfDateIdentifierERNS_14IdentifierInfoE")]
                internal static extern void updateOutOfDateIdentifier_0(global::System.IntPtr instance, global::System.IntPtr II);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17ExternalASTSource30FindExternalVisibleDeclsByNameEPKNS_11DeclContextENS_15DeclarationNameE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool FindExternalVisibleDeclsByName_0(global::System.IntPtr instance, global::System.IntPtr DC, clang.DeclarationName.Internal Name);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17ExternalASTSource23completeVisibleDeclsMapEPKNS_11DeclContextE")]
                internal static extern void completeVisibleDeclsMap_0(global::System.IntPtr instance, global::System.IntPtr DC);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17ExternalASTSource19CompleteRedeclChainEPKNS_4DeclE")]
                internal static extern void CompleteRedeclChain_0(global::System.IntPtr instance, global::System.IntPtr D);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17ExternalASTSource12CompleteTypeEPNS_7TagDeclE")]
                internal static extern void CompleteType_0(global::System.IntPtr instance, global::System.IntPtr Tag);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17ExternalASTSource12ReadCommentsEv")]
                internal static extern void ReadComments_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17ExternalASTSource20StartedDeserializingEv")]
                internal static extern void StartedDeserializing_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17ExternalASTSource21FinishedDeserializingEv")]
                internal static extern void FinishedDeserializing_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17ExternalASTSource10PrintStatsEv")]
                internal static extern void PrintStats_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17ExternalASTSource20getMemoryBufferSizesEv")]
                internal static extern clang.ExternalASTSource.MemoryBufferSizes.Internal getMemoryBufferSizes_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17ExternalASTSource20getMemoryBufferSizesERNS0_17MemoryBufferSizesE")]
                internal static extern void getMemoryBufferSizes_1(global::System.IntPtr instance, global::System.IntPtr sizes);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17ExternalASTSource32SetNoExternalVisibleDeclsForNameEPKNS_11DeclContextENS_15DeclarationNameE")]
                internal static extern void SetNoExternalVisibleDeclsForName_0(global::System.IntPtr @return, global::System.IntPtr DC, clang.DeclarationName.Internal Name);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17ExternalASTSource19incrementGenerationERNS_10ASTContextE")]
                internal static extern uint incrementGeneration_0(global::System.IntPtr instance, global::System.IntPtr C);
            }

            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            public unsafe delegate bool __AnonymousDelegate0(clang.Decl.Kind _0);

            /// <summary>
            /// <para>RAII class for safely pairing a StartedDeserializing call with
            /// FinishedDeserializing.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief RAII class for safely pairing a StartedDeserializing
            /// call</para>
            /// <para>  /// with FinishedDeserializing.</para>
            /// </remarks>
            public unsafe partial class Deserializing : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 4)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public global::System.IntPtr Source;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang17ExternalASTSource13DeserializingC2EPS0_")]
                    internal static extern void ctor_0(global::System.IntPtr instance, global::System.IntPtr source);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang17ExternalASTSource13DeserializingC2ERKS1_")]
                    internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang17ExternalASTSource13DeserializingD2Ev")]
                    internal static extern void dtor_0(global::System.IntPtr instance);
                }

                public global::System.IntPtr __Instance { get; protected set; }
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, Deserializing> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, Deserializing>();

                private readonly bool __ownsNativeInstance;

                public static Deserializing __CreateInstance(global::System.IntPtr native)
                {
                    return new Deserializing((Deserializing.Internal*) native);
                }

                public static Deserializing __CreateInstance(Deserializing.Internal native)
                {
                    return new Deserializing(native);
                }

                private static Deserializing.Internal* __CopyValue(Deserializing.Internal native)
                {
                    var ret = (Deserializing.Internal*) Marshal.AllocHGlobal(4);
                    *ret = native;
                    return ret;
                }

                private Deserializing(Deserializing.Internal native)
                    : this(__CopyValue(native))
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected Deserializing(Deserializing.Internal* native, bool isInternalImpl = false)
                {
                    __Instance = new global::System.IntPtr(native);
                }

                public Deserializing(clang.ExternalASTSource source)
                {
                    __Instance = Marshal.AllocHGlobal(4);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    var arg0 = ReferenceEquals(source, null) ? global::System.IntPtr.Zero : source.__Instance;
                    Internal.ctor_0(__Instance, arg0);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    DestroyNativeInstance(false);
                }

                public virtual void DestroyNativeInstance()
                {
                    DestroyNativeInstance(true);
                }

                private void DestroyNativeInstance(bool force)
                {
                    clang.ExternalASTSource.Deserializing __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance || force)
                        Internal.dtor_0(__Instance);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }
            }

            public unsafe partial class MemoryBufferSizes : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 8)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public uint malloc_bytes;

                    [FieldOffset(4)]
                    public uint mmap_bytes;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang17ExternalASTSource17MemoryBufferSizesC2Emm")]
                    internal static extern void ctor_0(global::System.IntPtr instance, uint malloc_bytes, uint mmap_bytes);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang17ExternalASTSource17MemoryBufferSizesC2ERKS1_")]
                    internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, MemoryBufferSizes> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, MemoryBufferSizes>();

                private readonly bool __ownsNativeInstance;

                public static MemoryBufferSizes __CreateInstance(global::System.IntPtr native)
                {
                    return new MemoryBufferSizes((MemoryBufferSizes.Internal*) native);
                }

                public static MemoryBufferSizes __CreateInstance(MemoryBufferSizes.Internal native)
                {
                    return new MemoryBufferSizes(native);
                }

                private static MemoryBufferSizes.Internal* __CopyValue(MemoryBufferSizes.Internal native)
                {
                    var ret = (MemoryBufferSizes.Internal*) Marshal.AllocHGlobal(8);
                    *ret = native;
                    return ret;
                }

                private MemoryBufferSizes(MemoryBufferSizes.Internal native)
                    : this(__CopyValue(native))
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected MemoryBufferSizes(MemoryBufferSizes.Internal* native, bool isInternalImpl = false)
                {
                    __Instance = new global::System.IntPtr(native);
                }

                public MemoryBufferSizes(uint malloc_bytes, uint mmap_bytes)
                {
                    __Instance = Marshal.AllocHGlobal(8);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    var arg0 = malloc_bytes;
                    var arg1 = mmap_bytes;
                    Internal.ctor_0(__Instance, arg0, arg1);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    DestroyNativeInstance(false);
                }

                public virtual void DestroyNativeInstance()
                {
                    DestroyNativeInstance(true);
                }

                private void DestroyNativeInstance(bool force)
                {
                    clang.ExternalASTSource.MemoryBufferSizes __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public uint malloc_bytes
                {
                    get
                    {
                        return ((Internal*) __Instance)->malloc_bytes;
                    }

                    set
                    {
                        ((Internal*) __Instance)->malloc_bytes = value;
                    }
                }

                public uint mmap_bytes
                {
                    get
                    {
                        return ((Internal*) __Instance)->mmap_bytes;
                    }

                    set
                    {
                        ((Internal*) __Instance)->mmap_bytes = value;
                    }
                }
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ExternalASTSource> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ExternalASTSource>();

            private readonly bool __ownsNativeInstance;

            public static ExternalASTSource __CreateInstance(global::System.IntPtr native)
            {
                return new ExternalASTSource((ExternalASTSource.Internal*) native);
            }

            public static ExternalASTSource __CreateInstance(ExternalASTSource.Internal native)
            {
                return new ExternalASTSource(native);
            }

            private static ExternalASTSource.Internal* __CopyValue(ExternalASTSource.Internal native)
            {
                var ret = (ExternalASTSource.Internal*) Marshal.AllocHGlobal(16);
                *ret = native;
                return ret;
            }

            private ExternalASTSource(ExternalASTSource.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected ExternalASTSource(ExternalASTSource.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
                if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                    SetupVTables(__Instance);
            }

            public ExternalASTSource()
            {
                __Instance = Marshal.AllocHGlobal(16);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
                SetupVTables(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.ExternalASTSource __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance || force)
                    Internal.dtor_0(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            /// <summary>
            /// <para>Get the current generation of this AST source. This number is
            /// incremented each time the AST source lazily extends an existing
            /// entity.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Get the current generation of this AST source. This
            /// number</para>
            /// <para>  /// is incremented each time the AST source lazily extends an
            /// existing</para>
            /// <para>  /// entity.</para>
            /// </remarks>
            public uint getGeneration()
            {
                var __ret = Internal.getGeneration_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Resolve a declaration ID into a declaration, potentially building
            /// a new declaration.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Resolve a declaration ID into a declaration,
            /// potentially</para>
            /// <para>  /// building a new declaration.</para>
            /// <para>  ///</para>
            /// <para>  /// This method only needs to be implemented if the AST source
            /// ever</para>
            /// <para>  /// passes back decl sets as VisibleDeclaration objects.</para>
            /// <para>  ///</para>
            /// <para>  /// The default implementation of this method is a
            /// no-op.</para>
            /// </remarks>
            public virtual clang.Decl GetExternalDecl(uint ID)
            {
                var arg0 = ID;
                var __ret = Internal.GetExternalDecl_0(__Instance, arg0);
                clang.Decl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Decl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Decl) clang.Decl.NativeToManagedMap[__ret];
                else clang.Decl.NativeToManagedMap[__ret] = __result0 = (clang.Decl) clang.Decl.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Resolve a selector ID into a selector.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Resolve a selector ID into a selector.</para>
            /// <para>  ///</para>
            /// <para>  /// This operation only needs to be implemented if the AST
            /// source</para>
            /// <para>  /// returns non-zero for GetNumKnownSelectors().</para>
            /// <para>  ///</para>
            /// <para>  /// The default implementation of this method is a
            /// no-op.</para>
            /// </remarks>
            public virtual clang.Selector GetExternalSelector(uint ID)
            {
                var arg0 = ID;
                var __ret = Internal.GetExternalSelector_0(__Instance, arg0);
                return clang.Selector.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Returns the number of selectors known to the external AST
            /// source.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Returns the number of selectors known to the external
            /// AST</para>
            /// <para>  /// source.</para>
            /// <para>  ///</para>
            /// <para>  /// The default implementation of this method is a
            /// no-op.</para>
            /// </remarks>
            public virtual uint GetNumExternalSelectors()
            {
                var __ret = Internal.GetNumExternalSelectors_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Resolve the offset of a statement in the decl stream into a
            /// statement.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Resolve the offset of a statement in the decl stream
            /// into</para>
            /// <para>  /// a statement.</para>
            /// <para>  ///</para>
            /// <para>  /// This operation is meant to be used via a LazyOffsetPtr.  It
            /// only</para>
            /// <para>  /// needs to be implemented if the AST source uses methods
            /// like</para>
            /// <para>  /// FunctionDecl::setLazyBody when building decls.</para>
            /// <para>  ///</para>
            /// <para>  /// The default implementation of this method is a
            /// no-op.</para>
            /// </remarks>
            public virtual clang.Stmt GetExternalDeclStmt(ulong Offset)
            {
                var arg0 = Offset;
                var __ret = Internal.GetExternalDeclStmt_0(__Instance, arg0);
                clang.Stmt __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Stmt.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Stmt) clang.Stmt.NativeToManagedMap[__ret];
                else __result0 = clang.Stmt.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Update an out-of-date identifier.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Update an out-of-date identifier.</para>
            /// </remarks>
            public virtual void updateOutOfDateIdentifier(clang.IdentifierInfo II)
            {
                var arg0 = ReferenceEquals(II, null) ? global::System.IntPtr.Zero : II.__Instance;
                Internal.updateOutOfDateIdentifier_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>Find all declarations with the given name in the given context,
            /// and add them to the context by calling SetExternalVisibleDeclsForName or
            /// SetNoExternalVisibleDeclsForName.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Find all declarations with the given name in the given
            /// context,</para>
            /// <para>  /// and add them to the context by calling
            /// SetExternalVisibleDeclsForName</para>
            /// <para>  /// or SetNoExternalVisibleDeclsForName.</para>
            /// <para>  /// \return \c true if any declarations might have been found,
            /// \c false if</para>
            /// <para>  /// we definitely have no declarations with tbis name.</para>
            /// <para>  ///</para>
            /// <para>  /// The default implementation of this method is a no-op
            /// returning \c false.</para>
            /// </remarks>
            public virtual bool FindExternalVisibleDeclsByName(clang.DeclContext DC, clang.DeclarationName Name)
            {
                var arg0 = ReferenceEquals(DC, null) ? global::System.IntPtr.Zero : DC.__Instance;
                var arg1 = ReferenceEquals(Name, null) ? new clang.DeclarationName.Internal() : *(clang.DeclarationName.Internal*) (Name.__Instance);
                var __ret = Internal.FindExternalVisibleDeclsByName_0(__Instance, arg0, arg1);
                return __ret;
            }

            /// <summary>
            /// <para>Ensures that the table of all visible declarations inside this
            /// context is up to date.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Ensures that the table of all visible declarations
            /// inside this</para>
            /// <para>  /// context is up to date.</para>
            /// <para>  ///</para>
            /// <para>  /// The default implementation of this function is a
            /// no-op.</para>
            /// </remarks>
            public virtual void completeVisibleDeclsMap(clang.DeclContext DC)
            {
                var arg0 = ReferenceEquals(DC, null) ? global::System.IntPtr.Zero : DC.__Instance;
                Internal.completeVisibleDeclsMap_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>Gives the external AST source an opportunity to complete the
            /// redeclaration chain for a declaration. Called each time we need the most
            /// recent declaration of a declaration after the generation count is
            /// incremented.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Gives the external AST source an opportunity to
            /// complete</para>
            /// <para>  /// the redeclaration chain for a declaration. Called each time
            /// we</para>
            /// <para>  /// need the most recent declaration of a declaration after
            /// the</para>
            /// <para>  /// generation count is incremented.</para>
            /// </remarks>
            public virtual void CompleteRedeclChain(clang.Decl D)
            {
                var arg0 = ReferenceEquals(D, null) ? global::System.IntPtr.Zero : D.__Instance;
                Internal.CompleteRedeclChain_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>Gives the external AST source an opportunity to complete an
            /// incomplete type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Gives the external AST source an opportunity to
            /// complete</para>
            /// <para>  /// an incomplete type.</para>
            /// </remarks>
            public virtual void CompleteType(clang.TagDecl Tag)
            {
                var arg0 = ReferenceEquals(Tag, null) ? global::System.IntPtr.Zero : Tag.__Instance;
                Internal.CompleteType_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>Loads comment ranges.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Loads comment ranges.</para>
            /// </remarks>
            public virtual void ReadComments()
            {
                Internal.ReadComments_0(__Instance);
            }

            /// <summary>
            /// <para>Notify ExternalASTSource that we started deserialization of a
            /// decl or type so until FinishedDeserializing is called there may be decls
            /// that are initializing. Must be paired with FinishedDeserializing.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Notify ExternalASTSource that we started
            /// deserialization of</para>
            /// <para>  /// a decl or type so until FinishedDeserializing is called
            /// there may be</para>
            /// <para>  /// decls that are initializing. Must be paired with
            /// FinishedDeserializing.</para>
            /// <para>  ///</para>
            /// <para>  /// The default implementation of this method is a
            /// no-op.</para>
            /// </remarks>
            public virtual void StartedDeserializing()
            {
                Internal.StartedDeserializing_0(__Instance);
            }

            /// <summary>
            /// <para>Notify ExternalASTSource that we finished the deserialization of
            /// a decl or type. Must be paired with StartedDeserializing.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Notify ExternalASTSource that we finished the
            /// deserialization of</para>
            /// <para>  /// a decl or type. Must be paired with
            /// StartedDeserializing.</para>
            /// <para>  ///</para>
            /// <para>  /// The default implementation of this method is a
            /// no-op.</para>
            /// </remarks>
            public virtual void FinishedDeserializing()
            {
                Internal.FinishedDeserializing_0(__Instance);
            }

            /// <summary>
            /// <para>Print any statistics that have been gathered regarding the
            /// external AST source.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Print any statistics that have been gathered
            /// regarding</para>
            /// <para>  /// the external AST source.</para>
            /// <para>  ///</para>
            /// <para>  /// The default implementation of this method is a
            /// no-op.</para>
            /// </remarks>
            public virtual void PrintStats()
            {
                Internal.PrintStats_0(__Instance);
            }

            /// <summary>
            /// <para>Return the amount of memory used by memory buffers, breaking down
            /// by heap-backed versus mmap'ed memory.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Return the amount of memory used by memory buffers, breaking
            /// down</para>
            /// <para>  /// by heap-backed versus mmap'ed memory.</para>
            /// </remarks>
            public clang.ExternalASTSource.MemoryBufferSizes getMemoryBufferSizes()
            {
                var __ret = Internal.getMemoryBufferSizes_0(__Instance);
                return clang.ExternalASTSource.MemoryBufferSizes.__CreateInstance(__ret);
            }

            public virtual void getMemoryBufferSizes(clang.ExternalASTSource.MemoryBufferSizes sizes)
            {
                var arg0 = ReferenceEquals(sizes, null) ? global::System.IntPtr.Zero : sizes.__Instance;
                Internal.getMemoryBufferSizes_1(__Instance, arg0);
            }

            /// <summary>
            /// <para>Increment the current generation.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Increment the current generation.</para>
            /// </remarks>
            protected uint incrementGeneration(clang.ASTContext C)
            {
                var arg0 = ReferenceEquals(C, null) ? global::System.IntPtr.Zero : C.__Instance;
                var __ret = Internal.incrementGeneration_0(__Instance, arg0);
                return __ret;
            }

            protected static clang.DeclContextLookupResult SetNoExternalVisibleDeclsForName(clang.DeclContext DC, clang.DeclarationName Name)
            {
                var arg0 = ReferenceEquals(DC, null) ? global::System.IntPtr.Zero : DC.__Instance;
                var arg1 = ReferenceEquals(Name, null) ? new clang.DeclarationName.Internal() : *(clang.DeclarationName.Internal*) (Name.__Instance);
                var __ret = new clang.DeclContextLookupResult.Internal();
                Internal.SetNoExternalVisibleDeclsForName_0(new IntPtr(&__ret), arg0, arg1);
                return clang.DeclContextLookupResult.__CreateInstance(__ret);
            }

            #region Virtual table interop

            // virtual ~ExternalASTSource()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
            private static _dtor_0Delegate _dtor_0DelegateInstance;

            private static void _dtor_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (ExternalASTSource) _References[instance].Target;
                __target.DestroyNativeInstance();
            }

            // Decl *GetExternalDecl(uint32_t ID)
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _GetExternalDecl_0Delegate(global::System.IntPtr instance, uint ID);
            private static _GetExternalDecl_0Delegate _GetExternalDecl_0DelegateInstance;

            private static global::System.IntPtr _GetExternalDecl_0DelegateHook(global::System.IntPtr instance, uint ID)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (ExternalASTSource) _References[instance].Target;
                var __ret = __target.GetExternalDecl(ID);
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // Selector GetExternalSelector(uint32_t ID)
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate clang.Selector.Internal _GetExternalSelector_0Delegate(global::System.IntPtr instance, uint ID);
            private static _GetExternalSelector_0Delegate _GetExternalSelector_0DelegateInstance;

            private static clang.Selector.Internal _GetExternalSelector_0DelegateHook(global::System.IntPtr instance, uint ID)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (ExternalASTSource) _References[instance].Target;
                var __ret = __target.GetExternalSelector(ID);
                return ReferenceEquals(__ret, null) ? new clang.Selector.Internal() : *(clang.Selector.Internal*) (__ret.__Instance);
            }

            // uint32_t GetNumExternalSelectors()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate uint _GetNumExternalSelectors_0Delegate(global::System.IntPtr instance);
            private static _GetNumExternalSelectors_0Delegate _GetNumExternalSelectors_0DelegateInstance;

            private static uint _GetNumExternalSelectors_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (ExternalASTSource) _References[instance].Target;
                var __ret = __target.GetNumExternalSelectors();
                return __ret;
            }

            // Stmt *GetExternalDeclStmt(uint64_t Offset)
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _GetExternalDeclStmt_0Delegate(global::System.IntPtr instance, ulong Offset);
            private static _GetExternalDeclStmt_0Delegate _GetExternalDeclStmt_0DelegateInstance;

            private static global::System.IntPtr _GetExternalDeclStmt_0DelegateHook(global::System.IntPtr instance, ulong Offset)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (ExternalASTSource) _References[instance].Target;
                var __ret = __target.GetExternalDeclStmt(Offset);
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // void updateOutOfDateIdentifier(IdentifierInfo &II)
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate void _updateOutOfDateIdentifier_0Delegate(global::System.IntPtr instance, global::System.IntPtr II);
            private static _updateOutOfDateIdentifier_0Delegate _updateOutOfDateIdentifier_0DelegateInstance;

            private static void _updateOutOfDateIdentifier_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr II)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (ExternalASTSource) _References[instance].Target;
                clang.IdentifierInfo __result0;
                if (II == IntPtr.Zero) __result0 = null;
                else if (clang.IdentifierInfo.NativeToManagedMap.ContainsKey(II))
                    __result0 = (clang.IdentifierInfo) clang.IdentifierInfo.NativeToManagedMap[II];
                else __result0 = clang.IdentifierInfo.__CreateInstance(II);
                __target.updateOutOfDateIdentifier(__result0);
            }

            // bool FindExternalVisibleDeclsByName(const DeclContext *DC, DeclarationName Name)
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate bool _FindExternalVisibleDeclsByName_0Delegate(global::System.IntPtr instance, global::System.IntPtr DC, clang.DeclarationName.Internal Name);
            private static _FindExternalVisibleDeclsByName_0Delegate _FindExternalVisibleDeclsByName_0DelegateInstance;

            private static bool _FindExternalVisibleDeclsByName_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr DC, clang.DeclarationName.Internal Name)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (ExternalASTSource) _References[instance].Target;
                clang.DeclContext __result0;
                if (DC == IntPtr.Zero) __result0 = null;
                else if (clang.DeclContext.NativeToManagedMap.ContainsKey(DC))
                    __result0 = (clang.DeclContext) clang.DeclContext.NativeToManagedMap[DC];
                else __result0 = clang.DeclContext.__CreateInstance(DC);
                var __ret = __target.FindExternalVisibleDeclsByName(__result0, clang.DeclarationName.__CreateInstance(Name));
                return __ret;
            }

            // void completeVisibleDeclsMap(const DeclContext *DC)
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate void _completeVisibleDeclsMap_0Delegate(global::System.IntPtr instance, global::System.IntPtr DC);
            private static _completeVisibleDeclsMap_0Delegate _completeVisibleDeclsMap_0DelegateInstance;

            private static void _completeVisibleDeclsMap_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr DC)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (ExternalASTSource) _References[instance].Target;
                clang.DeclContext __result0;
                if (DC == IntPtr.Zero) __result0 = null;
                else if (clang.DeclContext.NativeToManagedMap.ContainsKey(DC))
                    __result0 = (clang.DeclContext) clang.DeclContext.NativeToManagedMap[DC];
                else __result0 = clang.DeclContext.__CreateInstance(DC);
                __target.completeVisibleDeclsMap(__result0);
            }

            // void CompleteRedeclChain(const Decl *D)
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate void _CompleteRedeclChain_0Delegate(global::System.IntPtr instance, global::System.IntPtr D);
            private static _CompleteRedeclChain_0Delegate _CompleteRedeclChain_0DelegateInstance;

            private static void _CompleteRedeclChain_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr D)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (ExternalASTSource) _References[instance].Target;
                clang.Decl __result0;
                if (D == IntPtr.Zero) __result0 = null;
                else if (clang.Decl.NativeToManagedMap.ContainsKey(D))
                    __result0 = (clang.Decl) clang.Decl.NativeToManagedMap[D];
                else clang.Decl.NativeToManagedMap[D] = __result0 = (clang.Decl) clang.Decl.__CreateInstance(D);
                __target.CompleteRedeclChain(__result0);
            }

            // void CompleteType(TagDecl *Tag)
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate void _CompleteType_0Delegate(global::System.IntPtr instance, global::System.IntPtr Tag);
            private static _CompleteType_0Delegate _CompleteType_0DelegateInstance;

            private static void _CompleteType_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr Tag)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (ExternalASTSource) _References[instance].Target;
                clang.TagDecl __result0;
                if (Tag == IntPtr.Zero) __result0 = null;
                else if (clang.TagDecl.NativeToManagedMap.ContainsKey(Tag))
                    __result0 = (clang.TagDecl) clang.TagDecl.NativeToManagedMap[Tag];
                else clang.TagDecl.NativeToManagedMap[Tag] = __result0 = (clang.TagDecl) clang.TagDecl.__CreateInstance(Tag);
                __target.CompleteType(__result0);
            }

            // void ReadComments()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate void _ReadComments_0Delegate(global::System.IntPtr instance);
            private static _ReadComments_0Delegate _ReadComments_0DelegateInstance;

            private static void _ReadComments_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (ExternalASTSource) _References[instance].Target;
                __target.ReadComments();
            }

            // void StartedDeserializing()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate void _StartedDeserializing_0Delegate(global::System.IntPtr instance);
            private static _StartedDeserializing_0Delegate _StartedDeserializing_0DelegateInstance;

            private static void _StartedDeserializing_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (ExternalASTSource) _References[instance].Target;
                __target.StartedDeserializing();
            }

            // void FinishedDeserializing()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate void _FinishedDeserializing_0Delegate(global::System.IntPtr instance);
            private static _FinishedDeserializing_0Delegate _FinishedDeserializing_0DelegateInstance;

            private static void _FinishedDeserializing_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (ExternalASTSource) _References[instance].Target;
                __target.FinishedDeserializing();
            }

            // void PrintStats()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate void _PrintStats_0Delegate(global::System.IntPtr instance);
            private static _PrintStats_0Delegate _PrintStats_0DelegateInstance;

            private static void _PrintStats_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (ExternalASTSource) _References[instance].Target;
                __target.PrintStats();
            }

            // void getMemoryBufferSizes(MemoryBufferSizes &sizes) const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate void _getMemoryBufferSizes_1Delegate(global::System.IntPtr instance, global::System.IntPtr sizes);
            private static _getMemoryBufferSizes_1Delegate _getMemoryBufferSizes_1DelegateInstance;

            private static void _getMemoryBufferSizes_1DelegateHook(global::System.IntPtr instance, global::System.IntPtr sizes)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (ExternalASTSource) _References[instance].Target;
                clang.ExternalASTSource.MemoryBufferSizes __result0;
                if (sizes == IntPtr.Zero) __result0 = null;
                else if (clang.ExternalASTSource.MemoryBufferSizes.NativeToManagedMap.ContainsKey(sizes))
                    __result0 = (clang.ExternalASTSource.MemoryBufferSizes) clang.ExternalASTSource.MemoryBufferSizes.NativeToManagedMap[sizes];
                else __result0 = clang.ExternalASTSource.MemoryBufferSizes.__CreateInstance(sizes);
                __target.getMemoryBufferSizes(__result0);
            }

            private static void*[] _OldVTables;
            private static void*[] _NewVTables;
            private static void*[] _Thunks;
            private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

            void SetupVTables(global::System.IntPtr instance)
            {
                var native = (Internal*)instance.ToPointer();

                if (_References == null)
                    _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

                if (_References.ContainsKey(instance))
                    return;

                _References[instance] = new WeakReference(this);

                if (_OldVTables == null)
                {
                    _OldVTables = new void*[1];
                    _OldVTables[0] = native->vfptr0.ToPointer();
                }

                if (_Thunks == null)
                {
                    _Thunks = new void*[15];
                    _dtor_0DelegateInstance += _dtor_0DelegateHook;
                    _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                    _GetExternalDecl_0DelegateInstance += _GetExternalDecl_0DelegateHook;
                    _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetExternalDecl_0DelegateInstance).ToPointer();
                    _GetExternalSelector_0DelegateInstance += _GetExternalSelector_0DelegateHook;
                    _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_GetExternalSelector_0DelegateInstance).ToPointer();
                    _GetNumExternalSelectors_0DelegateInstance += _GetNumExternalSelectors_0DelegateHook;
                    _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_GetNumExternalSelectors_0DelegateInstance).ToPointer();
                    _GetExternalDeclStmt_0DelegateInstance += _GetExternalDeclStmt_0DelegateHook;
                    _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_GetExternalDeclStmt_0DelegateInstance).ToPointer();
                    _updateOutOfDateIdentifier_0DelegateInstance += _updateOutOfDateIdentifier_0DelegateHook;
                    _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_updateOutOfDateIdentifier_0DelegateInstance).ToPointer();
                    _FindExternalVisibleDeclsByName_0DelegateInstance += _FindExternalVisibleDeclsByName_0DelegateHook;
                    _Thunks[6] = Marshal.GetFunctionPointerForDelegate(_FindExternalVisibleDeclsByName_0DelegateInstance).ToPointer();
                    _completeVisibleDeclsMap_0DelegateInstance += _completeVisibleDeclsMap_0DelegateHook;
                    _Thunks[7] = Marshal.GetFunctionPointerForDelegate(_completeVisibleDeclsMap_0DelegateInstance).ToPointer();
                    _CompleteRedeclChain_0DelegateInstance += _CompleteRedeclChain_0DelegateHook;
                    _Thunks[8] = Marshal.GetFunctionPointerForDelegate(_CompleteRedeclChain_0DelegateInstance).ToPointer();
                    _CompleteType_0DelegateInstance += _CompleteType_0DelegateHook;
                    _Thunks[9] = Marshal.GetFunctionPointerForDelegate(_CompleteType_0DelegateInstance).ToPointer();
                    _ReadComments_0DelegateInstance += _ReadComments_0DelegateHook;
                    _Thunks[10] = Marshal.GetFunctionPointerForDelegate(_ReadComments_0DelegateInstance).ToPointer();
                    _StartedDeserializing_0DelegateInstance += _StartedDeserializing_0DelegateHook;
                    _Thunks[11] = Marshal.GetFunctionPointerForDelegate(_StartedDeserializing_0DelegateInstance).ToPointer();
                    _FinishedDeserializing_0DelegateInstance += _FinishedDeserializing_0DelegateHook;
                    _Thunks[12] = Marshal.GetFunctionPointerForDelegate(_FinishedDeserializing_0DelegateInstance).ToPointer();
                    _PrintStats_0DelegateInstance += _PrintStats_0DelegateHook;
                    _Thunks[13] = Marshal.GetFunctionPointerForDelegate(_PrintStats_0DelegateInstance).ToPointer();
                    _getMemoryBufferSizes_1DelegateInstance += _getMemoryBufferSizes_1DelegateHook;
                    _Thunks[14] = Marshal.GetFunctionPointerForDelegate(_getMemoryBufferSizes_1DelegateInstance).ToPointer();
                }

                if (_NewVTables == null)
                {
                    _NewVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(22 * 4);
                    _NewVTables[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + 4) = _Thunks[0];
                    *(void**)(vfptr0 + 8) = _Thunks[1];
                    *(void**)(vfptr0 + 12) = _Thunks[2];
                    *(void**)(vfptr0 + 16) = _Thunks[3];
                    *(void**)(vfptr0 + 20) = _Thunks[4];
                    *(void**)(vfptr0 + 24) = *(void**)(native->vfptr0 + 24);
                    *(void**)(vfptr0 + 28) = _Thunks[5];
                    *(void**)(vfptr0 + 32) = _Thunks[6];
                    *(void**)(vfptr0 + 36) = _Thunks[7];
                    *(void**)(vfptr0 + 40) = *(void**)(native->vfptr0 + 40);
                    *(void**)(vfptr0 + 44) = *(void**)(native->vfptr0 + 44);
                    *(void**)(vfptr0 + 48) = *(void**)(native->vfptr0 + 48);
                    *(void**)(vfptr0 + 52) = _Thunks[8];
                    *(void**)(vfptr0 + 56) = _Thunks[9];
                    *(void**)(vfptr0 + 60) = *(void**)(native->vfptr0 + 60);
                    *(void**)(vfptr0 + 64) = _Thunks[10];
                    *(void**)(vfptr0 + 68) = _Thunks[11];
                    *(void**)(vfptr0 + 72) = _Thunks[12];
                    *(void**)(vfptr0 + 76) = *(void**)(native->vfptr0 + 76);
                    *(void**)(vfptr0 + 80) = _Thunks[13];
                    *(void**)(vfptr0 + 84) = *(void**)(native->vfptr0 + 84);
                    *(void**)(vfptr0 + 88) = _Thunks[14];
                }

                native->vfptr0 = new IntPtr(_NewVTables[0]);
            }

            #endregion
        }
    }

    namespace llvm
    {
    }
}
