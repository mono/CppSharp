//----------------------------------------------------------------------------
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
//----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace CppSharp
{
    namespace clang
    {
        public unsafe partial class PartialDiagnostic : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 12)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public uint DiagID;

                [FieldOffset(4)]
                public global::System.IntPtr DiagStorage;

                [FieldOffset(8)]
                public global::System.IntPtr Allocator;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17PartialDiagnosticC2ENS0_14NullDiagnosticE")]
                internal static extern void ctor_0(global::System.IntPtr instance, clang.PartialDiagnostic.NullDiagnostic.Internal _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17PartialDiagnosticC2EjRNS0_16StorageAllocatorE")]
                internal static extern void ctor_1(global::System.IntPtr instance, uint DiagID, global::System.IntPtr Allocator);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17PartialDiagnosticC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr Other);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17PartialDiagnosticC2ERKS0_PNS0_7StorageE")]
                internal static extern void ctor_4(global::System.IntPtr instance, global::System.IntPtr Other, global::System.IntPtr DiagStorage);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17PartialDiagnosticC2ERKNS_10DiagnosticERNS0_16StorageAllocatorE")]
                internal static extern void ctor_5(global::System.IntPtr instance, global::System.IntPtr Other, global::System.IntPtr Allocator);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17PartialDiagnosticD2Ev")]
                internal static extern void dtor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17PartialDiagnostic4swapERS0_")]
                internal static extern void swap_0(global::System.IntPtr instance, global::System.IntPtr PD);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17PartialDiagnostic9getDiagIDEv")]
                internal static extern uint getDiagID_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17PartialDiagnostic12AddTaggedValElNS_17DiagnosticsEngine12ArgumentKindE")]
                internal static extern void AddTaggedVal_0(global::System.IntPtr instance, int V, clang.DiagnosticsEngine.ArgumentKind Kind);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17PartialDiagnostic9AddStringEN4llvm9StringRefE")]
                internal static extern void AddString_0(global::System.IntPtr instance, llvm.StringRef.Internal V);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17PartialDiagnostic4EmitERKNS_17DiagnosticBuilderE")]
                internal static extern void Emit_0(global::System.IntPtr instance, global::System.IntPtr DB);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17PartialDiagnostic5ResetEj")]
                internal static extern void Reset_0(global::System.IntPtr instance, uint DiagID);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17PartialDiagnostic10hasStorageEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasStorage_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clanglsERKNS_17PartialDiagnosticEi")]
                internal static extern global::System.IntPtr OperatorLessLess_1(global::System.IntPtr PD, int I);
            }

            public enum MaxArguments : uint
            {
                MaxArguments = 10
            }

            public unsafe partial class Storage : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 532)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public byte NumDiagArgs;

                    [FieldOffset(1)]
                    public fixed byte DiagArgumentsKind[10];

                    [FieldOffset(12)]
                    public fixed int DiagArgumentsVal[10];

                    [FieldOffset(52)]
                    public fixed byte DiagArgumentsStr[0];

                    [FieldOffset(172)]
                    internal llvm.SmallVector.Internal DiagRanges;

                    [FieldOffset(280)]
                    internal llvm.SmallVector.Internal FixItHints;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang17PartialDiagnostic7StorageC2Ev")]
                    internal static extern void ctor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang17PartialDiagnostic7StorageC2ERKS1_")]
                    internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang17PartialDiagnostic7StorageD2Ev")]
                    internal static extern void dtor_0(global::System.IntPtr instance);
                }

                public enum MaxArguments : uint
                {
                    /// <summary>The maximum number of arguments we can hold. We currently only support up to 10 arguments (%0-%9).</summary>
                    MaxArguments = 10
                }

                public global::System.IntPtr __Instance { get; protected set; }
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, Storage> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, Storage>();

                private readonly bool __ownsNativeInstance;

                public static Storage __CreateInstance(global::System.IntPtr native)
                {
                    return new Storage((Storage.Internal*) native);
                }

                public static Storage __CreateInstance(Storage.Internal native)
                {
                    return new Storage(native);
                }

                private static Storage.Internal* __CopyValue(Storage.Internal native)
                {
                    var ret = (Storage.Internal*) Marshal.AllocHGlobal(532);
                    *ret = native;
                    return ret;
                }

                private Storage(Storage.Internal native)
                    : this(__CopyValue(native))
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected Storage(Storage.Internal* native, bool isInternalImpl = false)
                {
                    __Instance = new global::System.IntPtr(native);
                }

                public Storage()
                {
                    __Instance = Marshal.AllocHGlobal(532);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_0(__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    DestroyNativeInstance(false);
                }

                public virtual void DestroyNativeInstance()
                {
                    DestroyNativeInstance(true);
                }

                private void DestroyNativeInstance(bool force)
                {
                    clang.PartialDiagnostic.Storage __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance || force)
                        Internal.dtor_0(__Instance);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public byte NumDiagArgs
                {
                    get
                    {
                        return ((Internal*) __Instance)->NumDiagArgs;
                    }

                    set
                    {
                        ((Internal*) __Instance)->NumDiagArgs = value;
                    }
                }

                public byte[] DiagArgumentsKind
                {
                    get
                    {
                        byte[] __value = null;
                        if (((Internal*) __Instance)->DiagArgumentsKind != null)
                        {
                            __value = new byte[10];
                            for (int i = 0; i < 10; i++)
                                __value[i] = ((Internal*) __Instance)->DiagArgumentsKind[i];
                        }
                        return __value;
                    }

                    set
                    {
                        if (value != null)
                        {
                            for (int i = 0; i < 10; i++)
                                ((Internal*) __Instance)->DiagArgumentsKind[i] = value[i];
                        }
                    }
                }

                public int[] DiagArgumentsVal
                {
                    get
                    {
                        int[] __value = null;
                        if (((Internal*) __Instance)->DiagArgumentsVal != null)
                        {
                            __value = new int[10];
                            for (int i = 0; i < 10; i++)
                                __value[i] = ((Internal*) __Instance)->DiagArgumentsVal[i];
                        }
                        return __value;
                    }

                    set
                    {
                        if (value != null)
                        {
                            for (int i = 0; i < 10; i++)
                                ((Internal*) __Instance)->DiagArgumentsVal[i] = value[i];
                        }
                    }
                }
            }

            /// <summary>
            /// <para>An allocator for Storage objects, which uses a small cache to
            /// objects, used to reduce malloc()/free() traffic for partial
            /// diagnostics.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief An allocator for Storage objects, which uses a small
            /// cache to</para>
            /// <para>  /// objects, used to reduce malloc()/free() traffic for partial
            /// diagnostics.</para>
            /// </remarks>
            public unsafe partial class StorageAllocator : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 8580)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public fixed byte Cached[8512];

                    [FieldOffset(8512)]
                    public fixed global::System.IntPtr FreeList[16];

                    [FieldOffset(8576)]
                    public uint NumFreeListEntries;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang17PartialDiagnostic16StorageAllocatorC2Ev")]
                    internal static extern void ctor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang17PartialDiagnostic16StorageAllocatorC2ERKS1_")]
                    internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang17PartialDiagnostic16StorageAllocatorD2Ev")]
                    internal static extern void dtor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang17PartialDiagnostic16StorageAllocator8AllocateEv")]
                    internal static extern global::System.IntPtr Allocate_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang17PartialDiagnostic16StorageAllocator10DeallocateEPNS0_7StorageE")]
                    internal static extern void Deallocate_0(global::System.IntPtr instance, global::System.IntPtr S);
                }

                public global::System.IntPtr __Instance { get; protected set; }
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, StorageAllocator> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, StorageAllocator>();

                private readonly bool __ownsNativeInstance;

                public static StorageAllocator __CreateInstance(global::System.IntPtr native)
                {
                    return new StorageAllocator((StorageAllocator.Internal*) native);
                }

                public static StorageAllocator __CreateInstance(StorageAllocator.Internal native)
                {
                    return new StorageAllocator(native);
                }

                private static StorageAllocator.Internal* __CopyValue(StorageAllocator.Internal native)
                {
                    var ret = (StorageAllocator.Internal*) Marshal.AllocHGlobal(8580);
                    *ret = native;
                    return ret;
                }

                private StorageAllocator(StorageAllocator.Internal native)
                    : this(__CopyValue(native))
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected StorageAllocator(StorageAllocator.Internal* native, bool isInternalImpl = false)
                {
                    __Instance = new global::System.IntPtr(native);
                }

                public StorageAllocator()
                {
                    __Instance = Marshal.AllocHGlobal(8580);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_0(__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    DestroyNativeInstance(false);
                }

                public virtual void DestroyNativeInstance()
                {
                    DestroyNativeInstance(true);
                }

                private void DestroyNativeInstance(bool force)
                {
                    clang.PartialDiagnostic.StorageAllocator __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance || force)
                        Internal.dtor_0(__Instance);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                /// <summary>
                /// <para>Allocate new storage.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Allocate new storage.</para>
                /// </remarks>
                public clang.PartialDiagnostic.Storage Allocate()
                {
                    var __ret = Internal.Allocate_0(__Instance);
                    clang.PartialDiagnostic.Storage __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (clang.PartialDiagnostic.Storage.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (clang.PartialDiagnostic.Storage) clang.PartialDiagnostic.Storage.NativeToManagedMap[__ret];
                    else __result0 = clang.PartialDiagnostic.Storage.__CreateInstance(__ret);
                    return __result0;
                }

                /// <summary>
                /// <para>Free the given storage object.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Free the given storage object.</para>
                /// </remarks>
                public void Deallocate(clang.PartialDiagnostic.Storage S)
                {
                    var arg0 = ReferenceEquals(S, null) ? global::System.IntPtr.Zero : S.__Instance;
                    Internal.Deallocate_0(__Instance, arg0);
                }
            }

            public unsafe partial class NullDiagnostic : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 0)]
                public partial struct Internal
                {
                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang17PartialDiagnostic14NullDiagnosticC2ERKS1_")]
                    internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, NullDiagnostic> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, NullDiagnostic>();

                private readonly bool __ownsNativeInstance;

                public static NullDiagnostic __CreateInstance(global::System.IntPtr native)
                {
                    return new NullDiagnostic((NullDiagnostic.Internal*) native);
                }

                public static NullDiagnostic __CreateInstance(NullDiagnostic.Internal native)
                {
                    return new NullDiagnostic(native);
                }

                private static NullDiagnostic.Internal* __CopyValue(NullDiagnostic.Internal native)
                {
                    var ret = (NullDiagnostic.Internal*) Marshal.AllocHGlobal(0);
                    *ret = native;
                    return ret;
                }

                private NullDiagnostic(NullDiagnostic.Internal native)
                    : this(__CopyValue(native))
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected NullDiagnostic(NullDiagnostic.Internal* native, bool isInternalImpl = false)
                {
                    __Instance = new global::System.IntPtr(native);
                }

                public NullDiagnostic()
                {
                    __Instance = Marshal.AllocHGlobal(0);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    DestroyNativeInstance(false);
                }

                public virtual void DestroyNativeInstance()
                {
                    DestroyNativeInstance(true);
                }

                private void DestroyNativeInstance(bool force)
                {
                    clang.PartialDiagnostic.NullDiagnostic __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, PartialDiagnostic> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, PartialDiagnostic>();

            private readonly bool __ownsNativeInstance;

            public static PartialDiagnostic __CreateInstance(global::System.IntPtr native)
            {
                return new PartialDiagnostic((PartialDiagnostic.Internal*) native);
            }

            public static PartialDiagnostic __CreateInstance(PartialDiagnostic.Internal native)
            {
                return new PartialDiagnostic(native);
            }

            private static PartialDiagnostic.Internal* __CopyValue(PartialDiagnostic.Internal native)
            {
                var ret = (PartialDiagnostic.Internal*) Marshal.AllocHGlobal(12);
                *ret = native;
                return ret;
            }

            private PartialDiagnostic(PartialDiagnostic.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected PartialDiagnostic(PartialDiagnostic.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            /// <summary>
            /// <para>Create a null partial diagnostic, which cannot carry a payload,
            /// and only exists to be swapped with a real partial diagnostic.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Create a null partial diagnostic, which cannot carry a
            /// payload,</para>
            /// <para>  /// and only exists to be swapped with a real partial
            /// diagnostic.</para>
            /// </remarks>
            public PartialDiagnostic(clang.PartialDiagnostic.NullDiagnostic _0)
            {
                __Instance = Marshal.AllocHGlobal(12);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(_0, null) ? new clang.PartialDiagnostic.NullDiagnostic.Internal() : *(clang.PartialDiagnostic.NullDiagnostic.Internal*) (_0.__Instance);
                Internal.ctor_0(__Instance, arg0);
            }

            public PartialDiagnostic(uint DiagID, clang.PartialDiagnostic.StorageAllocator Allocator)
            {
                __Instance = Marshal.AllocHGlobal(12);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg1 = ReferenceEquals(Allocator, null) ? global::System.IntPtr.Zero : Allocator.__Instance;
                Internal.ctor_1(__Instance, DiagID, arg1);
            }

            public PartialDiagnostic(clang.PartialDiagnostic Other, clang.PartialDiagnostic.Storage DiagStorage)
            {
                __Instance = Marshal.AllocHGlobal(12);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(Other, null) ? global::System.IntPtr.Zero : Other.__Instance;
                var arg1 = ReferenceEquals(DiagStorage, null) ? global::System.IntPtr.Zero : DiagStorage.__Instance;
                Internal.ctor_4(__Instance, arg0, arg1);
            }

            public PartialDiagnostic(clang.Diagnostic Other, clang.PartialDiagnostic.StorageAllocator Allocator)
            {
                __Instance = Marshal.AllocHGlobal(12);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(Other, null) ? global::System.IntPtr.Zero : Other.__Instance;
                var arg1 = ReferenceEquals(Allocator, null) ? global::System.IntPtr.Zero : Allocator.__Instance;
                Internal.ctor_5(__Instance, arg0, arg1);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.PartialDiagnostic __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance || force)
                    Internal.dtor_0(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public void swap(clang.PartialDiagnostic PD)
            {
                var arg0 = ReferenceEquals(PD, null) ? global::System.IntPtr.Zero : PD.__Instance;
                Internal.swap_0(__Instance, arg0);
            }

            public uint getDiagID()
            {
                var __ret = Internal.getDiagID_0(__Instance);
                return __ret;
            }

            public void AddTaggedVal(int V, clang.DiagnosticsEngine.ArgumentKind Kind)
            {
                var arg0 = V;
                var arg1 = Kind;
                Internal.AddTaggedVal_0(__Instance, arg0, arg1);
            }

            public void AddString(llvm.StringRef V)
            {
                var arg0 = ReferenceEquals(V, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (V.__Instance);
                Internal.AddString_0(__Instance, arg0);
            }

            public void Emit(clang.DiagnosticBuilder DB)
            {
                var arg0 = ReferenceEquals(DB, null) ? global::System.IntPtr.Zero : DB.__Instance;
                Internal.Emit_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>Clear out this partial diagnostic, giving it a new diagnostic ID
            /// and removing all of its arguments, ranges, and fix-it hints.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Clear out this partial diagnostic, giving it a new
            /// diagnostic ID</para>
            /// <para>  /// and removing all of its arguments, ranges, and fix-it
            /// hints.</para>
            /// </remarks>
            public void Reset(uint DiagID)
            {
                Internal.Reset_0(__Instance, DiagID);
            }

            public bool hasStorage()
            {
                var __ret = Internal.hasStorage_0(__Instance);
                return __ret;
            }

            public static clang.PartialDiagnostic operator <<(clang.PartialDiagnostic PD, int I)
            {
                var arg0 = ReferenceEquals(PD, null) ? global::System.IntPtr.Zero : PD.__Instance;
                var __ret = Internal.OperatorLessLess_1(arg0, I);
                clang.PartialDiagnostic __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.PartialDiagnostic.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.PartialDiagnostic) clang.PartialDiagnostic.NativeToManagedMap[__ret];
                else __result0 = clang.PartialDiagnostic.__CreateInstance(__ret);
                return __result0;
            }
        }
    }
}
