//----------------------------------------------------------------------------
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
//----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace CppSharp
{
    namespace clang
    {
        /// <summary>
        /// <para>Implementation class used to describe either a set of overloaded
        /// template names or an already-substituted template template parameter
        /// pack.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief Implementation class used to describe either a set of
        /// overloaded</para>
        /// <para>/// template names or an already-substituted template template
        /// parameter pack.</para>
        /// </remarks>
        public unsafe partial class UncommonTemplateNameStorage : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 8)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                internal clang.UncommonTemplateNameStorage._.Internal __;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang27UncommonTemplateNameStorageC2ENS0_4KindEj")]
                internal static extern void ctor_0(global::System.IntPtr instance, clang.UncommonTemplateNameStorage.Kind kind, uint size);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang27UncommonTemplateNameStorageC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang27UncommonTemplateNameStorage4sizeEv")]
                internal static extern uint size_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang27UncommonTemplateNameStorage22getAsOverloadedStorageEv")]
                internal static extern global::System.IntPtr getAsOverloadedStorage_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang27UncommonTemplateNameStorage30getAsSubstTemplateTemplateParmEv")]
                internal static extern global::System.IntPtr getAsSubstTemplateTemplateParm_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang27UncommonTemplateNameStorage34getAsSubstTemplateTemplateParmPackEv")]
                internal static extern global::System.IntPtr getAsSubstTemplateTemplateParmPack_0(global::System.IntPtr instance);
            }

            public enum Kind : uint
            {
                Overloaded = 0,
                SubstTemplateTemplateParm = 1,
                SubstTemplateTemplateParmPack = 2
            }

            protected internal unsafe partial class BitsTag : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 4)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public uint Kind;

                    [FieldOffset(0)]
                    public uint Size;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang27UncommonTemplateNameStorage7BitsTagC2ERKS1_")]
                    internal static extern void cctor_0(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, BitsTag> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, BitsTag>();

                private readonly bool __ownsNativeInstance;

                public static BitsTag __CreateInstance(global::System.IntPtr native)
                {
                    return new BitsTag((BitsTag.Internal*) native);
                }

                public static BitsTag __CreateInstance(BitsTag.Internal native)
                {
                    return new BitsTag(native);
                }

                private static BitsTag.Internal* __CopyValue(BitsTag.Internal native)
                {
                    var ret = (BitsTag.Internal*) Marshal.AllocHGlobal(4);
                    *ret = native;
                    return ret;
                }

                private BitsTag(BitsTag.Internal native)
                    : this(__CopyValue(native))
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected BitsTag(BitsTag.Internal* native, bool isInternalImpl = false)
                {
                    __Instance = new global::System.IntPtr(native);
                }

                public BitsTag()
                {
                    __Instance = Marshal.AllocHGlobal(4);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    DestroyNativeInstance(false);
                }

                public virtual void DestroyNativeInstance()
                {
                    DestroyNativeInstance(true);
                }

                private void DestroyNativeInstance(bool force)
                {
                    clang.UncommonTemplateNameStorage.BitsTag __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public uint Kind
                {
                    get
                    {
                        return ((Internal*) __Instance)->Kind;
                    }

                    set
                    {
                        ((Internal*) __Instance)->Kind = value;
                    }
                }

                public uint Size
                {
                    get
                    {
                        return ((Internal*) __Instance)->Size;
                    }

                    set
                    {
                        ((Internal*) __Instance)->Size = value;
                    }
                }
            }

            protected internal unsafe partial struct _
            {
                [StructLayout(LayoutKind.Explicit, Size = 8)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public clang.UncommonTemplateNameStorage.BitsTag.Internal Bits;

                    [FieldOffset(0)]
                    public global::System.IntPtr PointerAlignment;
                }
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, UncommonTemplateNameStorage> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, UncommonTemplateNameStorage>();

            private readonly bool __ownsNativeInstance;

            public static UncommonTemplateNameStorage __CreateInstance(global::System.IntPtr native)
            {
                return new UncommonTemplateNameStorage((UncommonTemplateNameStorage.Internal*) native);
            }

            public static UncommonTemplateNameStorage __CreateInstance(UncommonTemplateNameStorage.Internal native)
            {
                return new UncommonTemplateNameStorage(native);
            }

            private static UncommonTemplateNameStorage.Internal* __CopyValue(UncommonTemplateNameStorage.Internal native)
            {
                var ret = (UncommonTemplateNameStorage.Internal*) Marshal.AllocHGlobal(8);
                *ret = native;
                return ret;
            }

            private UncommonTemplateNameStorage(UncommonTemplateNameStorage.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected UncommonTemplateNameStorage(UncommonTemplateNameStorage.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            protected UncommonTemplateNameStorage(clang.UncommonTemplateNameStorage.Kind kind, uint size)
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = kind;
                Internal.ctor_0(__Instance, arg0, size);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.UncommonTemplateNameStorage __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public uint size()
            {
                var __ret = Internal.size_0(__Instance);
                return __ret;
            }

            public clang.OverloadedTemplateStorage getAsOverloadedStorage()
            {
                var __ret = Internal.getAsOverloadedStorage_0(__Instance);
                clang.OverloadedTemplateStorage __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.OverloadedTemplateStorage.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.OverloadedTemplateStorage) clang.OverloadedTemplateStorage.NativeToManagedMap[__ret];
                else __result0 = clang.OverloadedTemplateStorage.__CreateInstance(__ret);
                return __result0;
            }

            public clang.SubstTemplateTemplateParmStorage getAsSubstTemplateTemplateParm()
            {
                var __ret = Internal.getAsSubstTemplateTemplateParm_0(__Instance);
                clang.SubstTemplateTemplateParmStorage __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.SubstTemplateTemplateParmStorage.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.SubstTemplateTemplateParmStorage) clang.SubstTemplateTemplateParmStorage.NativeToManagedMap[__ret];
                else __result0 = clang.SubstTemplateTemplateParmStorage.__CreateInstance(__ret);
                return __result0;
            }

            public clang.SubstTemplateTemplateParmPackStorage getAsSubstTemplateTemplateParmPack()
            {
                var __ret = Internal.getAsSubstTemplateTemplateParmPack_0(__Instance);
                clang.SubstTemplateTemplateParmPackStorage __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.SubstTemplateTemplateParmPackStorage.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.SubstTemplateTemplateParmPackStorage) clang.SubstTemplateTemplateParmPackStorage.NativeToManagedMap[__ret];
                else __result0 = clang.SubstTemplateTemplateParmPackStorage.__CreateInstance(__ret);
                return __result0;
            }
        }

        /// <summary>
        /// <para>A structure for storing the information associated with an
        /// overloaded template name.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief A structure for storing the information associated
        /// with an</para>
        /// <para>/// overloaded template name.</para>
        /// </remarks>
        public unsafe partial class OverloadedTemplateStorage : clang.UncommonTemplateNameStorage, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 8)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                internal clang.UncommonTemplateNameStorage._.Internal __;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang25OverloadedTemplateStorageC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang25OverloadedTemplateStorage5beginEv")]
                internal static extern global::System.IntPtr begin_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang25OverloadedTemplateStorage3endEv")]
                internal static extern global::System.IntPtr end_0(global::System.IntPtr instance);
            }

            private readonly bool __ownsNativeInstance;

            public static new OverloadedTemplateStorage __CreateInstance(global::System.IntPtr native)
            {
                return new OverloadedTemplateStorage((OverloadedTemplateStorage.Internal*) native);
            }

            public static OverloadedTemplateStorage __CreateInstance(OverloadedTemplateStorage.Internal native)
            {
                return new OverloadedTemplateStorage(native);
            }

            private static OverloadedTemplateStorage.Internal* __CopyValue(OverloadedTemplateStorage.Internal native)
            {
                var ret = (OverloadedTemplateStorage.Internal*) Marshal.AllocHGlobal(8);
                *ret = native;
                return ret;
            }

            private OverloadedTemplateStorage(OverloadedTemplateStorage.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected OverloadedTemplateStorage(OverloadedTemplateStorage.Internal* native, bool isInternalImpl = false)
                : base((clang.UncommonTemplateNameStorage.Internal*) native)
            {
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.UncommonTemplateNameStorage __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.NamedDecl begin()
            {
                var __ret = Internal.begin_0(__Instance);
                clang.NamedDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.NamedDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.NamedDecl) clang.NamedDecl.NativeToManagedMap[__ret];
                else clang.NamedDecl.NativeToManagedMap[__ret] = __result0 = (clang.NamedDecl) clang.NamedDecl.__CreateInstance(__ret);
                return __result0;
            }

            public clang.NamedDecl end()
            {
                var __ret = Internal.end_0(__Instance);
                clang.NamedDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.NamedDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.NamedDecl) clang.NamedDecl.NativeToManagedMap[__ret];
                else clang.NamedDecl.NativeToManagedMap[__ret] = __result0 = (clang.NamedDecl) clang.NamedDecl.__CreateInstance(__ret);
                return __result0;
            }
        }

        /// <summary>
        /// <para>A structure for storing an already-substituted template template
        /// parameter pack.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief A structure for storing an already-substituted
        /// template template</para>
        /// <para>/// parameter pack.</para>
        /// <para>///</para>
        /// <para>/// This kind of template names occurs when the parameter pack
        /// has been </para>
        /// <para>/// provided with a template template argument pack in a context
        /// where its</para>
        /// <para>/// enclosing pack expansion could not be fully expanded.</para>
        /// </remarks>
        public unsafe partial class SubstTemplateTemplateParmPackStorage : clang.UncommonTemplateNameStorage, llvm.FoldingSetImpl.Node, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 32)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                internal clang.UncommonTemplateNameStorage._.Internal __;

                [FieldOffset(0)]
                public global::System.IntPtr NextInFoldingSetBucket;

                [FieldOffset(16)]
                public global::System.IntPtr Parameter;

                [FieldOffset(24)]
                public global::System.IntPtr Arguments;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang36SubstTemplateTemplateParmPackStorageC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang36SubstTemplateTemplateParmPackStorage15getArgumentPackEv")]
                internal static extern void getArgumentPack_0(global::System.IntPtr @return, global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang36SubstTemplateTemplateParmPackStorage7ProfileERN4llvm16FoldingSetNodeIDERNS_10ASTContextE")]
                internal static extern void Profile_0(global::System.IntPtr instance, global::System.IntPtr ID, global::System.IntPtr Context);
            }

            private readonly bool __ownsNativeInstance;

            public static new SubstTemplateTemplateParmPackStorage __CreateInstance(global::System.IntPtr native)
            {
                return new SubstTemplateTemplateParmPackStorage((SubstTemplateTemplateParmPackStorage.Internal*) native);
            }

            public static SubstTemplateTemplateParmPackStorage __CreateInstance(SubstTemplateTemplateParmPackStorage.Internal native)
            {
                return new SubstTemplateTemplateParmPackStorage(native);
            }

            private static SubstTemplateTemplateParmPackStorage.Internal* __CopyValue(SubstTemplateTemplateParmPackStorage.Internal native)
            {
                var ret = (SubstTemplateTemplateParmPackStorage.Internal*) Marshal.AllocHGlobal(32);
                *ret = native;
                return ret;
            }

            private SubstTemplateTemplateParmPackStorage(SubstTemplateTemplateParmPackStorage.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected SubstTemplateTemplateParmPackStorage(SubstTemplateTemplateParmPackStorage.Internal* native, bool isInternalImpl = false)
                : base((clang.UncommonTemplateNameStorage.Internal*) native)
            {
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.UncommonTemplateNameStorage __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            /// <summary>
            /// <para>Retrieve the template template argument pack with which this
            /// parameter was substituted.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the template template argument pack with
            /// which this</para>
            /// <para>  /// parameter was substituted.</para>
            /// </remarks>
            public clang.TemplateArgument getArgumentPack()
            {
                var __ret = new clang.TemplateArgument.Internal();
                Internal.getArgumentPack_0(new IntPtr(&__ret), __Instance);
                return clang.TemplateArgument.__CreateInstance(__ret);
            }

            public void Profile(llvm.FoldingSetNodeID ID, clang.ASTContext Context)
            {
                var arg0 = ReferenceEquals(ID, null) ? global::System.IntPtr.Zero : ID.__Instance;
                var arg1 = ReferenceEquals(Context, null) ? global::System.IntPtr.Zero : Context.__Instance;
                Internal.Profile_0(__Instance, arg0, arg1);
            }
        }

        /// <summary>
        /// <para>Represents a C++ template name within the type system.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief Represents a C++ template name within the type
        /// system.</para>
        /// <para>///</para>
        /// <para>/// A C++ template name refers to a template within the C++
        /// type</para>
        /// <para>/// system. In most cases, a template name is simply a reference
        /// to a</para>
        /// <para>/// class template, e.g.</para>
        /// <para>///</para>
        /// <para>/// \code</para>
        /// <para>/// template&lt;typename T&gt; class X { };</para>
        /// <para>///</para>
        /// <para>/// X&lt;int&gt; xi;</para>
        /// <para>/// \endcode</para>
        /// <para>///</para>
        /// <para>/// Here, the 'X' in \c X&lt;int&gt; is a template name that
        /// refers to the</para>
        /// <para>/// declaration of the class template X, above. Template names
        /// can</para>
        /// <para>/// also refer to function templates, C++0x template aliases,
        /// etc.</para>
        /// <para>///</para>
        /// <para>/// Some template names are dependent. For example,
        /// consider:</para>
        /// <para>///</para>
        /// <para>/// \code</para>
        /// <para>/// template&lt;typename MetaFun, typename T1, typename T2&gt;
        /// struct apply2 {</para>
        /// <para>///   typedef typename MetaFun::template apply&lt;T1,
        /// T2&gt;::type type;</para>
        /// <para>/// };</para>
        /// <para>/// \endcode</para>
        /// <para>///</para>
        /// <para>/// Here, &quot;apply&quot; is treated as a template name within
        /// the typename</para>
        /// <para>/// specifier in the typedef. &quot;apply&quot; is a nested
        /// template, and can</para>
        /// <para>/// only be understood in the context of</para>
        /// </remarks>
        public unsafe partial class TemplateName : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 8)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                internal llvm.PointerUnion4.Internal Storage;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12TemplateNameC2Ev")]
                internal static extern void ctor_1(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12TemplateNameC2EPNS_25OverloadedTemplateStorageE")]
                internal static extern void ctor_3(global::System.IntPtr instance, global::System.IntPtr Storage);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12TemplateNameC2EPNS_32SubstTemplateTemplateParmStorageE")]
                internal static extern void ctor_4(global::System.IntPtr instance, global::System.IntPtr Storage);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12TemplateNameC2EPNS_36SubstTemplateTemplateParmPackStorageE")]
                internal static extern void ctor_5(global::System.IntPtr instance, global::System.IntPtr Storage);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12TemplateNameC2EPNS_21QualifiedTemplateNameE")]
                internal static extern void ctor_6(global::System.IntPtr instance, global::System.IntPtr Qual);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12TemplateNameC2EPNS_21DependentTemplateNameE")]
                internal static extern void ctor_7(global::System.IntPtr instance, global::System.IntPtr Dep);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12TemplateNameC2ERKS0_")]
                internal static extern void cctor_8(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12TemplateName6isNullEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isNull_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12TemplateName7getKindEv")]
                internal static extern clang.TemplateName.NameKind getKind_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12TemplateName23getAsOverloadedTemplateEv")]
                internal static extern global::System.IntPtr getAsOverloadedTemplate_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12TemplateName30getAsSubstTemplateTemplateParmEv")]
                internal static extern global::System.IntPtr getAsSubstTemplateTemplateParm_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12TemplateName34getAsSubstTemplateTemplateParmPackEv")]
                internal static extern global::System.IntPtr getAsSubstTemplateTemplateParmPack_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12TemplateName26getAsQualifiedTemplateNameEv")]
                internal static extern global::System.IntPtr getAsQualifiedTemplateName_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12TemplateName26getAsDependentTemplateNameEv")]
                internal static extern global::System.IntPtr getAsDependentTemplateName_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12TemplateName13getUnderlyingEv")]
                internal static extern clang.TemplateName.Internal getUnderlying_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12TemplateName11isDependentEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isDependent_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12TemplateName24isInstantiationDependentEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isInstantiationDependent_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12TemplateName31containsUnexpandedParameterPackEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool containsUnexpandedParameterPack_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12TemplateName5printERN4llvm11raw_ostreamERKNS_14PrintingPolicyEb")]
                internal static extern void print_0(global::System.IntPtr instance, global::System.IntPtr OS, global::System.IntPtr Policy, bool SuppressNNS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12TemplateName4dumpERN4llvm11raw_ostreamE")]
                internal static extern void dump_0(global::System.IntPtr instance, global::System.IntPtr OS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12TemplateName4dumpEv")]
                internal static extern void dump_1(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12TemplateName7ProfileERN4llvm16FoldingSetNodeIDE")]
                internal static extern void Profile_0(global::System.IntPtr instance, global::System.IntPtr ID);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12TemplateName16getAsVoidPointerEv")]
                internal static extern global::System.IntPtr getAsVoidPointer_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12TemplateName18getFromVoidPointerEPv")]
                internal static extern clang.TemplateName.Internal getFromVoidPointer_0(global::System.IntPtr Ptr);
            }

            public enum NameKind : uint
            {
                /// <summary>A single template declaration.</summary>
                Template = 0,
                /// <summary>A set of overloaded template declarations.</summary>
                OverloadedTemplate = 1,
                /// <summary>A qualified template name, where the qualification is kept to describe the source code as written.</summary>
                QualifiedTemplate = 2,
                /// <summary>A dependent template name that has not been resolved to a template (or set of templates).</summary>
                DependentTemplate = 3,
                /// <summary>A template template parameter that has been substituted for some other template name.</summary>
                SubstTemplateTemplateParm = 4,
                /// <summary>A template template parameter pack that has been substituted for a template template argument pack, but has not yet been expanded into individual arguments.</summary>
                SubstTemplateTemplateParmPack = 5
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, TemplateName> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, TemplateName>();

            private readonly bool __ownsNativeInstance;

            public static TemplateName __CreateInstance(global::System.IntPtr native)
            {
                return new TemplateName((TemplateName.Internal*) native);
            }

            public static TemplateName __CreateInstance(TemplateName.Internal native)
            {
                return new TemplateName(native);
            }

            private static TemplateName.Internal* __CopyValue(TemplateName.Internal native)
            {
                var ret = (TemplateName.Internal*) Marshal.AllocHGlobal(8);
                *ret = native;
                return ret;
            }

            private TemplateName(TemplateName.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected TemplateName(TemplateName.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public TemplateName()
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_1(__Instance);
            }

            public TemplateName(clang.OverloadedTemplateStorage Storage)
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(Storage, null) ? global::System.IntPtr.Zero : Storage.__Instance;
                Internal.ctor_3(__Instance, arg0);
            }

            public TemplateName(clang.SubstTemplateTemplateParmStorage Storage)
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(Storage, null) ? global::System.IntPtr.Zero : Storage.__Instance;
                Internal.ctor_4(__Instance, arg0);
            }

            public TemplateName(clang.SubstTemplateTemplateParmPackStorage Storage)
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(Storage, null) ? global::System.IntPtr.Zero : Storage.__Instance;
                Internal.ctor_5(__Instance, arg0);
            }

            public TemplateName(clang.QualifiedTemplateName Qual)
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(Qual, null) ? global::System.IntPtr.Zero : Qual.__Instance;
                Internal.ctor_6(__Instance, arg0);
            }

            public TemplateName(clang.DependentTemplateName Dep)
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(Dep, null) ? global::System.IntPtr.Zero : Dep.__Instance;
                Internal.ctor_7(__Instance, arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.TemplateName __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            /// <summary>
            /// <para>Determine whether this template name is NULL.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine whether this template name is NULL.</para>
            /// </remarks>
            public bool isNull()
            {
                var __ret = Internal.isNull_0(__Instance);
                return __ret;
            }

            public clang.TemplateName.NameKind getKind()
            {
                var __ret = Internal.getKind_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Returns The set of overloaded function templates that this
            /// template name refers to, if known. If the template name does not refer to a
            /// specific set of function templates because it is a dependent name or refers
            /// to a single template, returns NULL.</para>
            /// </summary>
            /// <remarks>
            /// <para>///</para>
            /// <para>  /// \returns The set of overloaded function templates that this
            /// template</para>
            /// <para>  /// name refers to, if known. If the template name does not
            /// refer to a</para>
            /// <para>  /// specific set of function templates because it is a
            /// dependent name or</para>
            /// <para>  /// refers to a single template, returns NULL.</para>
            /// </remarks>
            public clang.OverloadedTemplateStorage getAsOverloadedTemplate()
            {
                var __ret = Internal.getAsOverloadedTemplate_0(__Instance);
                clang.OverloadedTemplateStorage __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.OverloadedTemplateStorage.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.OverloadedTemplateStorage) clang.OverloadedTemplateStorage.NativeToManagedMap[__ret];
                else __result0 = clang.OverloadedTemplateStorage.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Retrieve the substituted template template parameter, if
            /// known.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the substituted template template parameter,
            /// if </para>
            /// <para>  /// known.</para>
            /// <para>  ///</para>
            /// <para>  /// \returns The storage for the substituted template template
            /// parameter,</para>
            /// <para>  /// if known. Otherwise, returns NULL.</para>
            /// </remarks>
            public clang.SubstTemplateTemplateParmStorage getAsSubstTemplateTemplateParm()
            {
                var __ret = Internal.getAsSubstTemplateTemplateParm_0(__Instance);
                clang.SubstTemplateTemplateParmStorage __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.SubstTemplateTemplateParmStorage.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.SubstTemplateTemplateParmStorage) clang.SubstTemplateTemplateParmStorage.NativeToManagedMap[__ret];
                else __result0 = clang.SubstTemplateTemplateParmStorage.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Retrieve the substituted template template parameter pack, if
            /// known.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the substituted template template parameter
            /// pack, if </para>
            /// <para>  /// known.</para>
            /// <para>  ///</para>
            /// <para>  /// \returns The storage for the substituted template template
            /// parameter pack,</para>
            /// <para>  /// if known. Otherwise, returns NULL.</para>
            /// </remarks>
            public clang.SubstTemplateTemplateParmPackStorage getAsSubstTemplateTemplateParmPack()
            {
                var __ret = Internal.getAsSubstTemplateTemplateParmPack_0(__Instance);
                clang.SubstTemplateTemplateParmPackStorage __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.SubstTemplateTemplateParmPackStorage.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.SubstTemplateTemplateParmPackStorage) clang.SubstTemplateTemplateParmPackStorage.NativeToManagedMap[__ret];
                else __result0 = clang.SubstTemplateTemplateParmPackStorage.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Retrieve the underlying qualified template name structure, if
            /// any.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the underlying qualified template name</para>
            /// <para>  /// structure, if any.</para>
            /// </remarks>
            public clang.QualifiedTemplateName getAsQualifiedTemplateName()
            {
                var __ret = Internal.getAsQualifiedTemplateName_0(__Instance);
                clang.QualifiedTemplateName __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.QualifiedTemplateName.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.QualifiedTemplateName) clang.QualifiedTemplateName.NativeToManagedMap[__ret];
                else __result0 = clang.QualifiedTemplateName.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Retrieve the underlying dependent template name structure, if
            /// any.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the underlying dependent template name</para>
            /// <para>  /// structure, if any.</para>
            /// </remarks>
            public clang.DependentTemplateName getAsDependentTemplateName()
            {
                var __ret = Internal.getAsDependentTemplateName_0(__Instance);
                clang.DependentTemplateName __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.DependentTemplateName.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.DependentTemplateName) clang.DependentTemplateName.NativeToManagedMap[__ret];
                else __result0 = clang.DependentTemplateName.__CreateInstance(__ret);
                return __result0;
            }

            public clang.TemplateName getUnderlying()
            {
                var __ret = Internal.getUnderlying_0(__Instance);
                return clang.TemplateName.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Determines whether this is a dependent template name.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determines whether this is a dependent template
            /// name.</para>
            /// </remarks>
            public bool isDependent()
            {
                var __ret = Internal.isDependent_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determines whether this is a template name that somehow depends
            /// on a template parameter.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determines whether this is a template name that
            /// somehow</para>
            /// <para>  /// depends on a template parameter.</para>
            /// </remarks>
            public bool isInstantiationDependent()
            {
                var __ret = Internal.isInstantiationDependent_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determines whether this template name contains an unexpanded
            /// parameter pack (for C++0x variadic templates).</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determines whether this template name contains
            /// an</para>
            /// <para>  /// unexpanded parameter pack (for C++0x variadic
            /// templates).</para>
            /// </remarks>
            public bool containsUnexpandedParameterPack()
            {
                var __ret = Internal.containsUnexpandedParameterPack_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Print the template name.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Print the template name.</para>
            /// <para>  ///</para>
            /// <para>  /// \param OS the output stream to which the template name will
            /// be</para>
            /// <para>  /// printed.</para>
            /// <para>  ///</para>
            /// <para>  /// \param SuppressNNS if true, don't print the</para>
            /// <para>  /// nested-name-specifier that precedes the template name (if
            /// it has</para>
            /// <para>  /// one).</para>
            /// </remarks>
            public void print(llvm.raw_ostream OS, clang.PrintingPolicy Policy, bool SuppressNNS)
            {
                var arg0 = ReferenceEquals(OS, null) ? global::System.IntPtr.Zero : OS.__Instance;
                var arg1 = ReferenceEquals(Policy, null) ? global::System.IntPtr.Zero : Policy.__Instance;
                Internal.print_0(__Instance, arg0, arg1, SuppressNNS);
            }

            /// <summary>
            /// <para>Debugging aid that dumps the template name.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Debugging aid that dumps the template name.</para>
            /// </remarks>
            public void dump(llvm.raw_ostream OS)
            {
                var arg0 = ReferenceEquals(OS, null) ? global::System.IntPtr.Zero : OS.__Instance;
                Internal.dump_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>Debugging aid that dumps the template name to standard
            /// error.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Debugging aid that dumps the template name to
            /// standard</para>
            /// <para>  /// error.</para>
            /// </remarks>
            public void dump()
            {
                Internal.dump_1(__Instance);
            }

            public void Profile(llvm.FoldingSetNodeID ID)
            {
                var arg0 = ReferenceEquals(ID, null) ? global::System.IntPtr.Zero : ID.__Instance;
                Internal.Profile_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>Retrieve the template name as a void pointer.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the template name as a void pointer.</para>
            /// </remarks>
            public global::System.IntPtr getAsVoidPointer()
            {
                var __ret = Internal.getAsVoidPointer_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Build a template name from a void pointer.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Build a template name from a void pointer.</para>
            /// </remarks>
            public static clang.TemplateName getFromVoidPointer(global::System.IntPtr Ptr)
            {
                var arg0 = Ptr;
                var __ret = Internal.getFromVoidPointer_0(arg0);
                return clang.TemplateName.__CreateInstance(__ret);
            }
        }

        /// <summary>
        /// <para>A structure for storing the information associated with a
        /// substituted template template parameter.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief A structure for storing the information associated
        /// with a</para>
        /// <para>/// substituted template template parameter.</para>
        /// </remarks>
        public unsafe partial class SubstTemplateTemplateParmStorage : clang.UncommonTemplateNameStorage, llvm.FoldingSetImpl.Node, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 32)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                internal clang.UncommonTemplateNameStorage._.Internal __;

                [FieldOffset(0)]
                public global::System.IntPtr NextInFoldingSetBucket;

                [FieldOffset(16)]
                public global::System.IntPtr Parameter;

                [FieldOffset(24)]
                public clang.TemplateName.Internal Replacement;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang32SubstTemplateTemplateParmStorageC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang32SubstTemplateTemplateParmStorage14getReplacementEv")]
                internal static extern clang.TemplateName.Internal getReplacement_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang32SubstTemplateTemplateParmStorage7ProfileERN4llvm16FoldingSetNodeIDE")]
                internal static extern void Profile_0(global::System.IntPtr instance, global::System.IntPtr ID);
            }

            private readonly bool __ownsNativeInstance;

            public static new SubstTemplateTemplateParmStorage __CreateInstance(global::System.IntPtr native)
            {
                return new SubstTemplateTemplateParmStorage((SubstTemplateTemplateParmStorage.Internal*) native);
            }

            public static SubstTemplateTemplateParmStorage __CreateInstance(SubstTemplateTemplateParmStorage.Internal native)
            {
                return new SubstTemplateTemplateParmStorage(native);
            }

            private static SubstTemplateTemplateParmStorage.Internal* __CopyValue(SubstTemplateTemplateParmStorage.Internal native)
            {
                var ret = (SubstTemplateTemplateParmStorage.Internal*) Marshal.AllocHGlobal(32);
                *ret = native;
                return ret;
            }

            private SubstTemplateTemplateParmStorage(SubstTemplateTemplateParmStorage.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected SubstTemplateTemplateParmStorage(SubstTemplateTemplateParmStorage.Internal* native, bool isInternalImpl = false)
                : base((clang.UncommonTemplateNameStorage.Internal*) native)
            {
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.UncommonTemplateNameStorage __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.TemplateName getReplacement()
            {
                var __ret = Internal.getReplacement_0(__Instance);
                return clang.TemplateName.__CreateInstance(__ret);
            }

            public void Profile(llvm.FoldingSetNodeID ID)
            {
                var arg0 = ReferenceEquals(ID, null) ? global::System.IntPtr.Zero : ID.__Instance;
                Internal.Profile_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>Represents a template name that was expressed as a qualified
        /// name.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief Represents a template name that was expressed as
        /// a</para>
        /// <para>/// qualified name.</para>
        /// <para>///</para>
        /// <para>/// This kind of template name refers to a template name that
        /// was</para>
        /// <para>/// preceded by a nested name specifier, e.g., \c std::vector.
        /// Here,</para>
        /// <para>/// the nested name specifier is &quot;std::&quot; and the
        /// template name is the</para>
        /// <para>/// declaration for &quot;vector&quot;. The QualifiedTemplateName
        /// class is only</para>
        /// <para>/// used to provide &quot;sugar&quot; for template names that
        /// were expressed</para>
        /// <para>/// with a qualified name, and has no semantic meaning. In
        /// this</para>
        /// <para>/// manner, it is to TemplateName what ElaboratedType is to
        /// Type,</para>
        /// <para>/// providing extra syntactic sugar for downstream
        /// clients.</para>
        /// </remarks>
        public unsafe partial class QualifiedTemplateName : llvm.FoldingSetImpl.Node, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 24)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr NextInFoldingSetBucket;

                [FieldOffset(8)]
                internal llvm.PointerIntPair.Internal Qualifier;

                [FieldOffset(16)]
                public global::System.IntPtr Template;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang21QualifiedTemplateNameC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang21QualifiedTemplateName12getQualifierEv")]
                internal static extern global::System.IntPtr getQualifier_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang21QualifiedTemplateName18hasTemplateKeywordEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasTemplateKeyword_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang21QualifiedTemplateName7ProfileERN4llvm16FoldingSetNodeIDE")]
                internal static extern void Profile_0(global::System.IntPtr instance, global::System.IntPtr ID);
            }

            private readonly bool __ownsNativeInstance;

            public static new QualifiedTemplateName __CreateInstance(global::System.IntPtr native)
            {
                return new QualifiedTemplateName((QualifiedTemplateName.Internal*) native);
            }

            public static QualifiedTemplateName __CreateInstance(QualifiedTemplateName.Internal native)
            {
                return new QualifiedTemplateName(native);
            }

            private static QualifiedTemplateName.Internal* __CopyValue(QualifiedTemplateName.Internal native)
            {
                var ret = (QualifiedTemplateName.Internal*) Marshal.AllocHGlobal(24);
                *ret = native;
                return ret;
            }

            private QualifiedTemplateName(QualifiedTemplateName.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected QualifiedTemplateName(QualifiedTemplateName.Internal* native, bool isInternalImpl = false)
                : base((llvm.FoldingSetImpl.Node.Internal*) native)
            {
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                llvm.FoldingSetImpl.Node __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            /// <summary>
            /// <para>Return the nested name specifier that qualifies this name.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the nested name specifier that qualifies this
            /// name.</para>
            /// </remarks>
            public clang.NestedNameSpecifier getQualifier()
            {
                var __ret = Internal.getQualifier_0(__Instance);
                clang.NestedNameSpecifier __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.NestedNameSpecifier.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.NestedNameSpecifier) clang.NestedNameSpecifier.NativeToManagedMap[__ret];
                else __result0 = clang.NestedNameSpecifier.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Whether the template name was prefixed by the
            /// &quot;template&quot; keyword.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Whether the template name was prefixed by the
            /// &quot;template&quot;</para>
            /// <para>  /// keyword.</para>
            /// </remarks>
            public bool hasTemplateKeyword()
            {
                var __ret = Internal.hasTemplateKeyword_0(__Instance);
                return __ret;
            }

            public void Profile(llvm.FoldingSetNodeID ID)
            {
                var arg0 = ReferenceEquals(ID, null) ? global::System.IntPtr.Zero : ID.__Instance;
                Internal.Profile_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>Represents a dependent template name that cannot be resolved
        /// prior to template instantiation.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief Represents a dependent template name that cannot
        /// be</para>
        /// <para>/// resolved prior to template instantiation.</para>
        /// <para>///</para>
        /// <para>/// This kind of template name refers to a dependent template
        /// name,</para>
        /// <para>/// including its nested name specifier (if any). For
        /// example,</para>
        /// <para>/// DependentTemplateName can refer to &quot;MetaFun::template
        /// apply&quot;,</para>
        /// <para>/// where &quot;MetaFun::&quot; is the nested name specifier and
        /// &quot;apply&quot; is the</para>
        /// <para>/// template name referenced. The &quot;template&quot; keyword is
        /// implied.</para>
        /// </remarks>
        public unsafe partial class DependentTemplateName : llvm.FoldingSetImpl.Node, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 32)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr NextInFoldingSetBucket;

                [FieldOffset(8)]
                internal llvm.PointerIntPair.Internal Qualifier;

                [FieldOffset(16)]
                internal clang.DependentTemplateName._.Internal _0;

                [FieldOffset(24)]
                public clang.TemplateName.Internal CanonicalTemplateName;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang21DependentTemplateNameC2ERKS0_")]
                internal static extern void cctor_4(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang21DependentTemplateName12getQualifierEv")]
                internal static extern global::System.IntPtr getQualifier_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang21DependentTemplateName12isIdentifierEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isIdentifier_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang21DependentTemplateName13getIdentifierEv")]
                internal static extern global::System.IntPtr getIdentifier_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang21DependentTemplateName20isOverloadedOperatorEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isOverloadedOperator_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang21DependentTemplateName11getOperatorEv")]
                internal static extern clang.OverloadedOperatorKind getOperator_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang21DependentTemplateName7ProfileERN4llvm16FoldingSetNodeIDE")]
                internal static extern void Profile_0(global::System.IntPtr instance, global::System.IntPtr ID);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang21DependentTemplateName7ProfileERN4llvm16FoldingSetNodeIDEPNS_19NestedNameSpecifierEPKNS_14IdentifierInfoE")]
                internal static extern void Profile_1(global::System.IntPtr ID, global::System.IntPtr NNS, global::System.IntPtr Identifier);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang21DependentTemplateName7ProfileERN4llvm16FoldingSetNodeIDEPNS_19NestedNameSpecifierENS_22OverloadedOperatorKindE")]
                internal static extern void Profile_2(global::System.IntPtr ID, global::System.IntPtr NNS, clang.OverloadedOperatorKind Operator);
            }

            /// <summary>
            /// <para>The dependent template name.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief The dependent template name.</para>
            /// </remarks>
            internal unsafe partial struct _
            {
                [StructLayout(LayoutKind.Explicit, Size = 8)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public global::System.IntPtr Identifier;

                    [FieldOffset(0)]
                    public clang.OverloadedOperatorKind Operator;
                }
            }

            private readonly bool __ownsNativeInstance;

            public static new DependentTemplateName __CreateInstance(global::System.IntPtr native)
            {
                return new DependentTemplateName((DependentTemplateName.Internal*) native);
            }

            public static DependentTemplateName __CreateInstance(DependentTemplateName.Internal native)
            {
                return new DependentTemplateName(native);
            }

            private static DependentTemplateName.Internal* __CopyValue(DependentTemplateName.Internal native)
            {
                var ret = (DependentTemplateName.Internal*) Marshal.AllocHGlobal(32);
                *ret = native;
                return ret;
            }

            private DependentTemplateName(DependentTemplateName.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected DependentTemplateName(DependentTemplateName.Internal* native, bool isInternalImpl = false)
                : base((llvm.FoldingSetImpl.Node.Internal*) native)
            {
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                llvm.FoldingSetImpl.Node __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            /// <summary>
            /// <para>Return the nested name specifier that qualifies this name.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the nested name specifier that qualifies this
            /// name.</para>
            /// </remarks>
            public clang.NestedNameSpecifier getQualifier()
            {
                var __ret = Internal.getQualifier_0(__Instance);
                clang.NestedNameSpecifier __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.NestedNameSpecifier.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.NestedNameSpecifier) clang.NestedNameSpecifier.NativeToManagedMap[__ret];
                else __result0 = clang.NestedNameSpecifier.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Determine whether this template name refers to an
            /// identifier.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine whether this template name refers to an
            /// identifier.</para>
            /// </remarks>
            public bool isIdentifier()
            {
                var __ret = Internal.isIdentifier_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Returns the identifier to which this template name refers.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Returns the identifier to which this template name
            /// refers.</para>
            /// </remarks>
            public clang.IdentifierInfo getIdentifier()
            {
                var __ret = Internal.getIdentifier_0(__Instance);
                clang.IdentifierInfo __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.IdentifierInfo.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.IdentifierInfo) clang.IdentifierInfo.NativeToManagedMap[__ret];
                else __result0 = clang.IdentifierInfo.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Determine whether this template name refers to an overloaded
            /// operator.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine whether this template name refers to an
            /// overloaded</para>
            /// <para>  /// operator.</para>
            /// </remarks>
            public bool isOverloadedOperator()
            {
                var __ret = Internal.isOverloadedOperator_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Return the overloaded operator to which this template name
            /// refers.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the overloaded operator to which this template
            /// name refers.</para>
            /// </remarks>
            public clang.OverloadedOperatorKind getOperator()
            {
                var __ret = Internal.getOperator_0(__Instance);
                return __ret;
            }

            public void Profile(llvm.FoldingSetNodeID ID)
            {
                var arg0 = ReferenceEquals(ID, null) ? global::System.IntPtr.Zero : ID.__Instance;
                Internal.Profile_0(__Instance, arg0);
            }

            public static void Profile(llvm.FoldingSetNodeID ID, clang.NestedNameSpecifier NNS, clang.IdentifierInfo Identifier)
            {
                var arg0 = ReferenceEquals(ID, null) ? global::System.IntPtr.Zero : ID.__Instance;
                var arg1 = ReferenceEquals(NNS, null) ? global::System.IntPtr.Zero : NNS.__Instance;
                var arg2 = ReferenceEquals(Identifier, null) ? global::System.IntPtr.Zero : Identifier.__Instance;
                Internal.Profile_1(arg0, arg1, arg2);
            }

            public static void Profile(llvm.FoldingSetNodeID ID, clang.NestedNameSpecifier NNS, clang.OverloadedOperatorKind Operator)
            {
                var arg0 = ReferenceEquals(ID, null) ? global::System.IntPtr.Zero : ID.__Instance;
                var arg1 = ReferenceEquals(NNS, null) ? global::System.IntPtr.Zero : NNS.__Instance;
                var arg2 = Operator;
                Internal.Profile_2(arg0, arg1, arg2);
            }
        }
    }

    namespace llvm
    {
    }
}
