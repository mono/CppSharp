//----------------------------------------------------------------------------
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
//----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace CppSharp
{
    public unsafe partial class TokenKinds
    {
        public partial struct Internal
        {
        }
    }

    namespace clang
    {
        public unsafe partial class TokenKinds
        {
            public partial struct Internal
            {
            }
        }

        namespace tok
        {
            /// <summary>
            /// <para>Provides a simple uniform namespace for tokens from all C
            /// languages.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Provides a simple uniform namespace for tokens from
            /// all C languages.</para>
            /// </remarks>
            public enum TokenKind : ushort
            {
                unknown = 0,
                eof = 1,
                eod = 2,
                code_completion = 3,
                comment = 4,
                identifier = 5,
                raw_identifier = 6,
                numeric_constant = 7,
                char_constant = 8,
                wide_char_constant = 9,
                utf8_char_constant = 10,
                utf16_char_constant = 11,
                utf32_char_constant = 12,
                string_literal = 13,
                wide_string_literal = 14,
                angle_string_literal = 15,
                utf8_string_literal = 16,
                utf16_string_literal = 17,
                utf32_string_literal = 18,
                l_square = 19,
                r_square = 20,
                l_paren = 21,
                r_paren = 22,
                l_brace = 23,
                r_brace = 24,
                period = 25,
                ellipsis = 26,
                amp = 27,
                ampamp = 28,
                ampequal = 29,
                star = 30,
                starequal = 31,
                plus = 32,
                plusplus = 33,
                plusequal = 34,
                minus = 35,
                arrow = 36,
                minusminus = 37,
                minusequal = 38,
                tilde = 39,
                exclaim = 40,
                exclaimequal = 41,
                slash = 42,
                slashequal = 43,
                percent = 44,
                percentequal = 45,
                less = 46,
                lessless = 47,
                lessequal = 48,
                lesslessequal = 49,
                greater = 50,
                greatergreater = 51,
                greaterequal = 52,
                greatergreaterequal = 53,
                caret = 54,
                caretequal = 55,
                pipe = 56,
                pipepipe = 57,
                pipeequal = 58,
                question = 59,
                colon = 60,
                semi = 61,
                equal = 62,
                equalequal = 63,
                comma = 64,
                hash = 65,
                hashhash = 66,
                hashat = 67,
                periodstar = 68,
                arrowstar = 69,
                coloncolon = 70,
                at = 71,
                lesslessless = 72,
                greatergreatergreater = 73,
                kw_auto = 74,
                kw_break = 75,
                kw_case = 76,
                kw_char = 77,
                kw_const = 78,
                kw_continue = 79,
                kw_default = 80,
                kw_do = 81,
                kw_double = 82,
                kw_else = 83,
                kw_enum = 84,
                kw_extern = 85,
                kw_float = 86,
                kw_for = 87,
                kw_goto = 88,
                kw_if = 89,
                kw_inline = 90,
                kw_int = 91,
                kw_long = 92,
                kw_register = 93,
                kw_restrict = 94,
                kw_return = 95,
                kw_short = 96,
                kw_signed = 97,
                kw_sizeof = 98,
                kw_static = 99,
                kw_struct = 100,
                kw_switch = 101,
                kw_typedef = 102,
                kw_union = 103,
                kw_unsigned = 104,
                kw_void = 105,
                kw_volatile = 106,
                kw_while = 107,
                kw__Alignas = 108,
                kw__Alignof = 109,
                kw__Atomic = 110,
                kw__Bool = 111,
                kw__Complex = 112,
                kw__Generic = 113,
                kw__Imaginary = 114,
                kw__Noreturn = 115,
                kw__Static_assert = 116,
                kw__Thread_local = 117,
                kw___func__ = 118,
                kw___objc_yes = 119,
                kw___objc_no = 120,
                kw_asm = 121,
                kw_bool = 122,
                kw_catch = 123,
                kw_class = 124,
                kw_const_cast = 125,
                kw_delete = 126,
                kw_dynamic_cast = 127,
                kw_explicit = 128,
                kw_export = 129,
                kw_false = 130,
                kw_friend = 131,
                kw_mutable = 132,
                kw_namespace = 133,
                kw_new = 134,
                kw_operator = 135,
                kw_private = 136,
                kw_protected = 137,
                kw_public = 138,
                kw_reinterpret_cast = 139,
                kw_static_cast = 140,
                kw_template = 141,
                kw_this = 142,
                kw_throw = 143,
                kw_true = 144,
                kw_try = 145,
                kw_typename = 146,
                kw_typeid = 147,
                kw_using = 148,
                kw_virtual = 149,
                kw_wchar_t = 150,
                kw_alignas = 151,
                kw_alignof = 152,
                kw_char16_t = 153,
                kw_char32_t = 154,
                kw_constexpr = 155,
                kw_decltype = 156,
                kw_noexcept = 157,
                kw_nullptr = 158,
                kw_static_assert = 159,
                kw_thread_local = 160,
                kw__Decimal32 = 161,
                kw__Decimal64 = 162,
                kw__Decimal128 = 163,
                kw___null = 164,
                kw___alignof = 165,
                kw___attribute = 166,
                kw___builtin_choose_expr = 167,
                kw___builtin_offsetof = 168,
                kw___builtin_types_compatible_p = 169,
                kw___builtin_va_arg = 170,
                kw___extension__ = 171,
                kw___imag = 172,
                kw___int128 = 173,
                kw___label__ = 174,
                kw___real = 175,
                kw___thread = 176,
                kw___FUNCTION__ = 177,
                kw___PRETTY_FUNCTION__ = 178,
                kw_typeof = 179,
                kw___FUNCDNAME__ = 180,
                kw___FUNCSIG__ = 181,
                kw_L__FUNCTION__ = 182,
                kw___is_interface_class = 183,
                kw___is_sealed = 184,
                kw___is_destructible = 185,
                kw___is_nothrow_destructible = 186,
                kw___is_nothrow_assignable = 187,
                kw___is_constructible = 188,
                kw___is_nothrow_constructible = 189,
                kw___has_nothrow_assign = 190,
                kw___has_nothrow_move_assign = 191,
                kw___has_nothrow_copy = 192,
                kw___has_nothrow_constructor = 193,
                kw___has_trivial_assign = 194,
                kw___has_trivial_move_assign = 195,
                kw___has_trivial_copy = 196,
                kw___has_trivial_constructor = 197,
                kw___has_trivial_move_constructor = 198,
                kw___has_trivial_destructor = 199,
                kw___has_virtual_destructor = 200,
                kw___is_abstract = 201,
                kw___is_base_of = 202,
                kw___is_class = 203,
                kw___is_convertible_to = 204,
                kw___is_empty = 205,
                kw___is_enum = 206,
                kw___is_final = 207,
                kw___is_literal = 208,
                kw___is_pod = 209,
                kw___is_polymorphic = 210,
                kw___is_trivial = 211,
                kw___is_union = 212,
                kw___is_trivially_constructible = 213,
                kw___is_trivially_copyable = 214,
                kw___is_trivially_assignable = 215,
                kw___underlying_type = 216,
                kw___is_lvalue_expr = 217,
                kw___is_rvalue_expr = 218,
                kw___is_arithmetic = 219,
                kw___is_floating_point = 220,
                kw___is_integral = 221,
                kw___is_complete_type = 222,
                kw___is_void = 223,
                kw___is_array = 224,
                kw___is_function = 225,
                kw___is_reference = 226,
                kw___is_lvalue_reference = 227,
                kw___is_rvalue_reference = 228,
                kw___is_fundamental = 229,
                kw___is_object = 230,
                kw___is_scalar = 231,
                kw___is_compound = 232,
                kw___is_pointer = 233,
                kw___is_member_object_pointer = 234,
                kw___is_member_function_pointer = 235,
                kw___is_member_pointer = 236,
                kw___is_const = 237,
                kw___is_volatile = 238,
                kw___is_standard_layout = 239,
                kw___is_signed = 240,
                kw___is_unsigned = 241,
                kw___is_same = 242,
                kw___is_convertible = 243,
                kw___array_rank = 244,
                kw___array_extent = 245,
                kw___private_extern__ = 246,
                kw___module_private__ = 247,
                kw___declspec = 248,
                kw___cdecl = 249,
                kw___stdcall = 250,
                kw___fastcall = 251,
                kw___thiscall = 252,
                kw___vectorcall = 253,
                kw___forceinline = 254,
                kw___unaligned = 255,
                kw___super = 256,
                kw___global = 257,
                kw___local = 258,
                kw___constant = 259,
                kw___private = 260,
                kw___generic = 261,
                kw___kernel = 262,
                kw___read_only = 263,
                kw___write_only = 264,
                kw___read_write = 265,
                kw___builtin_astype = 266,
                kw_vec_step = 267,
                kw___pascal = 268,
                kw___vector = 269,
                kw___pixel = 270,
                kw___bool = 271,
                kw_half = 272,
                kw___bridge = 273,
                kw___bridge_transfer = 274,
                kw___bridge_retained = 275,
                kw___bridge_retain = 276,
                kw___ptr64 = 277,
                kw___ptr32 = 278,
                kw___sptr = 279,
                kw___uptr = 280,
                kw___w64 = 281,
                kw___uuidof = 282,
                kw___try = 283,
                kw___finally = 284,
                kw___leave = 285,
                kw___int64 = 286,
                kw___if_exists = 287,
                kw___if_not_exists = 288,
                kw___single_inheritance = 289,
                kw___multiple_inheritance = 290,
                kw___virtual_inheritance = 291,
                kw___interface = 292,
                kw___builtin_convertvector = 293,
                kw___unknown_anytype = 294,
                annot_cxxscope = 295,
                annot_typename = 296,
                annot_template_id = 297,
                annot_primary_expr = 298,
                annot_decltype = 299,
                annot_pragma_unused = 300,
                annot_pragma_vis = 301,
                annot_pragma_pack = 302,
                annot_pragma_parser_crash = 303,
                annot_pragma_captured = 304,
                annot_pragma_msstruct = 305,
                annot_pragma_align = 306,
                annot_pragma_weak = 307,
                annot_pragma_weakalias = 308,
                annot_pragma_redefine_extname = 309,
                annot_pragma_fp_contract = 310,
                annot_pragma_ms_pointers_to_members = 311,
                annot_pragma_ms_vtordisp = 312,
                annot_pragma_ms_pragma = 313,
                annot_pragma_opencl_extension = 314,
                annot_pragma_openmp = 315,
                annot_pragma_openmp_end = 316,
                annot_pragma_loop_hint = 317,
                annot_module_include = 318,
                annot_module_begin = 319,
                annot_module_end = 320,
                NUM_TOKENS = 321
            }

            /// <summary>
            /// <para>Provides a namespace for preprocessor keywords which start with a
            /// '#' at the beginning of the line.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Provides a namespace for preprocessor keywords which
            /// start with a</para>
            /// <para>/// '#' at the beginning of the line.</para>
            /// </remarks>
            public enum PPKeywordKind : uint
            {
                pp_not_keyword = 0,
                pp_if = 1,
                pp_ifdef = 2,
                pp_ifndef = 3,
                pp_elif = 4,
                pp_else = 5,
                pp_endif = 6,
                pp_defined = 7,
                pp_include = 8,
                pp___include_macros = 9,
                pp_define = 10,
                pp_undef = 11,
                pp_line = 12,
                pp_error = 13,
                pp_pragma = 14,
                pp_import = 15,
                pp_include_next = 16,
                pp_warning = 17,
                pp_ident = 18,
                pp_sccs = 19,
                pp_assert = 20,
                pp_unassert = 21,
                pp___public_macro = 22,
                pp___private_macro = 23,
                NUM_PP_KEYWORDS = 24
            }

            /// <summary>
            /// <para>Provides a namespace for Objective-C keywords which start with an
            /// '@'.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Provides a namespace for Objective-C keywords which
            /// start with</para>
            /// <para>/// an '@'.</para>
            /// </remarks>
            public enum ObjCKeywordKind : uint
            {
                objc_not_keyword = 0,
                objc_class = 1,
                objc_compatibility_alias = 2,
                objc_defs = 3,
                objc_encode = 4,
                objc_end = 5,
                objc_implementation = 6,
                objc_interface = 7,
                objc_private = 8,
                objc_protected = 9,
                objc_protocol = 10,
                objc_public = 11,
                objc_selector = 12,
                objc_throw = 13,
                objc_try = 14,
                objc_catch = 15,
                objc_finally = 16,
                objc_synchronized = 17,
                objc_autoreleasepool = 18,
                objc_property = 19,
                objc_package = 20,
                objc_required = 21,
                objc_optional = 22,
                objc_synthesize = 23,
                objc_dynamic = 24,
                objc_import = 25,
                NUM_OBJC_KEYWORDS = 26
            }

            /// <summary>
            /// <para>Defines the possible values of an on-off-switch (C99
            /// 6.10.6p2).</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Defines the possible values of an on-off-switch (C99
            /// 6.10.6p2).</para>
            /// </remarks>
            public enum OnOffSwitch : uint
            {
                OOS_ON = 0,
                OOS_OFF = 1,
                OOS_DEFAULT = 2
            }

            public unsafe partial class TokenKinds
            {
                public partial struct Internal
                {
                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang3tok12getTokenNameENS0_9TokenKindE")]
                    internal static extern global::System.IntPtr getTokenName_0(clang.tok.TokenKind Kind);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang3tok21getPunctuatorSpellingENS0_9TokenKindE")]
                    internal static extern global::System.IntPtr getPunctuatorSpelling_0(clang.tok.TokenKind Kind);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang3tok18getKeywordSpellingENS0_9TokenKindE")]
                    internal static extern global::System.IntPtr getKeywordSpelling_0(clang.tok.TokenKind Kind);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang3tok15isAnyIdentifierENS0_9TokenKindE")]
                    [return: MarshalAsAttribute(UnmanagedType.I1)]
                    internal static extern bool isAnyIdentifier_0(clang.tok.TokenKind K);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang3tok15isStringLiteralENS0_9TokenKindE")]
                    [return: MarshalAsAttribute(UnmanagedType.I1)]
                    internal static extern bool isStringLiteral_0(clang.tok.TokenKind K);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang3tok9isLiteralENS0_9TokenKindE")]
                    [return: MarshalAsAttribute(UnmanagedType.I1)]
                    internal static extern bool isLiteral_0(clang.tok.TokenKind K);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang3tok12isAnnotationENS0_9TokenKindE")]
                    [return: MarshalAsAttribute(UnmanagedType.I1)]
                    internal static extern bool isAnnotation_0(clang.tok.TokenKind K);
                }

                /// <summary>
                /// <para>Determines the name of a token as used within the front
                /// end.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Determines the name of a token as used within the
                /// front end.</para>
                /// <para>///</para>
                /// <para>/// The name of a token will be an internal name (such as
                /// &quot;l_square&quot;)</para>
                /// <para>/// and should not be used as part of diagnostic messages.</para>
                /// </remarks>
                public static string getTokenName(clang.tok.TokenKind Kind)
                {
                    var arg0 = Kind;
                    var __ret = Internal.getTokenName_0(arg0);
                    return Marshal.PtrToStringAnsi(__ret);
                }

                /// <summary>
                /// <para>Determines the spelling of simple punctuation tokens like '!' or
                /// '%', and returns NULL for literal and annotation tokens.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Determines the spelling of simple punctuation tokens
                /// like</para>
                /// <para>/// '!' or '%', and returns NULL for literal and annotation
                /// tokens.</para>
                /// <para>///</para>
                /// <para>/// This routine only retrieves the &quot;simple&quot; spelling
                /// of the token,</para>
                /// <para>/// and will not produce any alternative spellings (e.g.,
                /// a</para>
                /// <para>/// digraph). For the actual spelling of a given Token,
                /// use</para>
                /// <para>/// Preprocessor::getSpelling().</para>
                /// </remarks>
                public static string getPunctuatorSpelling(clang.tok.TokenKind Kind)
                {
                    var arg0 = Kind;
                    var __ret = Internal.getPunctuatorSpelling_0(arg0);
                    return Marshal.PtrToStringAnsi(__ret);
                }

                /// <summary>
                /// <para>Determines the spelling of simple keyword and contextual keyword
                /// tokens like 'int' and 'dynamic_cast'. Returns NULL for other token
                /// kinds.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Determines the spelling of simple keyword and
                /// contextual keyword</para>
                /// <para>/// tokens like 'int' and 'dynamic_cast'. Returns NULL for other
                /// token kinds.</para>
                /// </remarks>
                public static string getKeywordSpelling(clang.tok.TokenKind Kind)
                {
                    var arg0 = Kind;
                    var __ret = Internal.getKeywordSpelling_0(arg0);
                    return Marshal.PtrToStringAnsi(__ret);
                }

                /// <summary>
                /// <para>Return true if this is a raw identifier or an identifier
                /// kind.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Return true if this is a raw identifier or an
                /// identifier kind.</para>
                /// </remarks>
                public static bool isAnyIdentifier(clang.tok.TokenKind K)
                {
                    var arg0 = K;
                    var __ret = Internal.isAnyIdentifier_0(arg0);
                    return __ret;
                }

                /// <summary>
                /// <para>Return true if this is a C or C++ string-literal (or C++11
                /// user-defined-string-literal) token.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Return true if this is a C or C++ string-literal
                /// (or</para>
                /// <para>/// C++11 user-defined-string-literal) token.</para>
                /// </remarks>
                public static bool isStringLiteral(clang.tok.TokenKind K)
                {
                    var arg0 = K;
                    var __ret = Internal.isStringLiteral_0(arg0);
                    return __ret;
                }

                /// <summary>
                /// <para>Return true if this is a &quot;literal&quot; kind, like a numeric
                /// constant, string, etc.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Return true if this is a &quot;literal&quot; kind,
                /// like a numeric</para>
                /// <para>/// constant, string, etc.</para>
                /// </remarks>
                public static bool isLiteral(clang.tok.TokenKind K)
                {
                    var arg0 = K;
                    var __ret = Internal.isLiteral_0(arg0);
                    return __ret;
                }

                /// <summary>
                /// <para>Return true if this is any of tok::annot_* kinds.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Return true if this is any of tok::annot_*
                /// kinds.</para>
                /// </remarks>
                public static bool isAnnotation(clang.tok.TokenKind K)
                {
                    var arg0 = K;
                    var __ret = Internal.isAnnotation_0(arg0);
                    return __ret;
                }
            }
        }
    }
}
