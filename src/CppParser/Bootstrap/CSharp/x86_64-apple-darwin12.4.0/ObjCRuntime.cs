//----------------------------------------------------------------------------
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
//----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace CppSharp
{
    namespace clang
    {
        /// <summary>
        /// <para>The basic abstraction for the target Objective-C runtime.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief The basic abstraction for the target Objective-C
        /// runtime.</para>
        /// </remarks>
        public unsafe partial class ObjCRuntime : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 20)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public clang.ObjCRuntime.Kind TheKind;

                [FieldOffset(4)]
                public clang.VersionTuple.Internal Version;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11ObjCRuntimeC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11ObjCRuntimeC2ENS0_4KindERKNS_12VersionTupleE")]
                internal static extern void ctor_1(global::System.IntPtr instance, clang.ObjCRuntime.Kind kind, global::System.IntPtr version);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11ObjCRuntimeC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11ObjCRuntime3setENS0_4KindENS_12VersionTupleE")]
                internal static extern void set_0(global::System.IntPtr instance, clang.ObjCRuntime.Kind kind, clang.VersionTuple.Internal version);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11ObjCRuntime7getKindEv")]
                internal static extern clang.ObjCRuntime.Kind getKind_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11ObjCRuntime10getVersionEv")]
                internal static extern global::System.IntPtr getVersion_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11ObjCRuntime12isNonFragileEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isNonFragile_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11ObjCRuntime9isFragileEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isFragile_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11ObjCRuntime30isLegacyDispatchDefaultForArchEN4llvm6Triple8ArchTypeE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isLegacyDispatchDefaultForArch_0(global::System.IntPtr instance, llvm.Triple.ArchType Arch);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11ObjCRuntime11isGNUFamilyEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isGNUFamily_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11ObjCRuntime12isNeXTFamilyEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isNeXTFamily_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11ObjCRuntime9allowsARCEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool allowsARC_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11ObjCRuntime12hasNativeARCEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasNativeARC_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11ObjCRuntime18hasOptimizedSetterEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasOptimizedSetter_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11ObjCRuntime10allowsWeakEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool allowsWeak_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11ObjCRuntime13hasNativeWeakEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasNativeWeak_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11ObjCRuntime15hasSubscriptingEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasSubscripting_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11ObjCRuntime19allowsSizeofAlignofEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool allowsSizeofAlignof_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11ObjCRuntime23allowsPointerArithmeticEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool allowsPointerArithmetic_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11ObjCRuntime28isSubscriptPointerArithmeticEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isSubscriptPointerArithmetic_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11ObjCRuntime12hasTerminateEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasTerminate_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11ObjCRuntime18hasWeakClassImportEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasWeakClassImport_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11ObjCRuntime19hasUnwindExceptionsEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasUnwindExceptions_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11ObjCRuntime19hasAtomicCopyHelperEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasAtomicCopyHelper_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11ObjCRuntime8tryParseEN4llvm9StringRefE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool tryParse_0(global::System.IntPtr instance, llvm.StringRef.Internal input);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clangeqERKNS_11ObjCRuntimeES2_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorEqualEqual_0(global::System.IntPtr left, global::System.IntPtr right);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clangneERKNS_11ObjCRuntimeES2_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorExclaimEqual_0(global::System.IntPtr left, global::System.IntPtr right);
            }

            /// <summary>
            /// <para>The basic Objective-C runtimes that we know about.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief The basic Objective-C runtimes that we know
            /// about.</para>
            /// </remarks>
            public enum Kind : uint
            {
                /// <summary>'macosx' is the Apple-provided NeXT-derived runtime on Mac OS X platforms that use the non-fragile ABI; the version is a release of that OS.</summary>
                MacOSX = 0,
                /// <summary>'macosx-fragile' is the Apple-provided NeXT-derived runtime on Mac OS X platforms that use the fragile ABI; the version is a release of that OS.</summary>
                FragileMacOSX = 1,
                /// <summary>'ios' is the Apple-provided NeXT-derived runtime on iOS or the iOS simulator; it is always non-fragile. The version is a release version of iOS.</summary>
                iOS = 2,
                /// <summary>'gcc' is the Objective-C runtime shipped with GCC, implementing a fragile Objective-C ABI</summary>
                GCC = 3,
                /// <summary>'gnustep' is the modern non-fragile GNUstep runtime.</summary>
                GNUstep = 4,
                /// <summary>'objfw' is the Objective-C runtime included in ObjFW</summary>
                ObjFW = 5
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ObjCRuntime> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ObjCRuntime>();

            private readonly bool __ownsNativeInstance;

            public static ObjCRuntime __CreateInstance(global::System.IntPtr native)
            {
                return new ObjCRuntime((ObjCRuntime.Internal*) native);
            }

            public static ObjCRuntime __CreateInstance(ObjCRuntime.Internal native)
            {
                return new ObjCRuntime(native);
            }

            private static ObjCRuntime.Internal* __CopyValue(ObjCRuntime.Internal native)
            {
                var ret = (ObjCRuntime.Internal*) Marshal.AllocHGlobal(20);
                *ret = native;
                return ret;
            }

            private ObjCRuntime(ObjCRuntime.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected ObjCRuntime(ObjCRuntime.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            /// <summary>
            /// <para>A bogus initialization of the runtime.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// A bogus initialization of the runtime.</para>
            /// </remarks>
            public ObjCRuntime()
            {
                __Instance = Marshal.AllocHGlobal(20);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public ObjCRuntime(clang.ObjCRuntime.Kind kind, clang.VersionTuple version)
            {
                __Instance = Marshal.AllocHGlobal(20);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = kind;
                var arg1 = ReferenceEquals(version, null) ? global::System.IntPtr.Zero : version.__Instance;
                Internal.ctor_1(__Instance, arg0, arg1);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.ObjCRuntime __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public void set(clang.ObjCRuntime.Kind kind, clang.VersionTuple version)
            {
                var arg0 = kind;
                var arg1 = ReferenceEquals(version, null) ? new clang.VersionTuple.Internal() : *(clang.VersionTuple.Internal*) (version.__Instance);
                Internal.set_0(__Instance, arg0, arg1);
            }

            public clang.ObjCRuntime.Kind getKind()
            {
                var __ret = Internal.getKind_0(__Instance);
                return __ret;
            }

            public clang.VersionTuple getVersion()
            {
                var __ret = Internal.getVersion_0(__Instance);
                clang.VersionTuple __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.VersionTuple.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.VersionTuple) clang.VersionTuple.NativeToManagedMap[__ret];
                else __result0 = clang.VersionTuple.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Does this runtime follow the set of implied behaviors for a
            /// &quot;non-fragile&quot; ABI?</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Does this runtime follow the set of implied behaviors
            /// for a</para>
            /// <para>  /// &quot;non-fragile&quot; ABI?</para>
            /// </remarks>
            public bool isNonFragile()
            {
                var __ret = Internal.isNonFragile_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>The inverse of isNonFragile(): does this runtime follow the set
            /// of implied behaviors for a &quot;fragile&quot; ABI?</para>
            /// </summary>
            /// <remarks>
            /// <para>/// The inverse of isNonFragile():  does this runtime follow the
            /// set of</para>
            /// <para>  /// implied behaviors for a &quot;fragile&quot; ABI?</para>
            /// </remarks>
            public bool isFragile()
            {
                var __ret = Internal.isFragile_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>The default dispatch mechanism to use for the specified
            /// architecture</para>
            /// </summary>
            /// <remarks>
            /// <para>/// The default dispatch mechanism to use for the specified
            /// architecture</para>
            /// </remarks>
            public bool isLegacyDispatchDefaultForArch(llvm.Triple.ArchType Arch)
            {
                var arg0 = Arch;
                var __ret = Internal.isLegacyDispatchDefaultForArch_0(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Is this runtime basically of the GNU family of runtimes?</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Is this runtime basically of the GNU family of
            /// runtimes?</para>
            /// </remarks>
            public bool isGNUFamily()
            {
                var __ret = Internal.isGNUFamily_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Is this runtime basically of the NeXT family of runtimes?</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Is this runtime basically of the NeXT family of
            /// runtimes?</para>
            /// </remarks>
            public bool isNeXTFamily()
            {
                var __ret = Internal.isNeXTFamily_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Does this runtime allow ARC at all?</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Does this runtime allow ARC at all?</para>
            /// </remarks>
            public bool allowsARC()
            {
                var __ret = Internal.allowsARC_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Does this runtime natively provide the ARC entrypoints?</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Does this runtime natively provide the ARC
            /// entrypoints? </para>
            /// <para>  ///</para>
            /// <para>  /// ARC cannot be directly supported on a platform that does
            /// not provide</para>
            /// <para>  /// these entrypoints, although it may be supportable via a
            /// stub</para>
            /// <para>  /// library.</para>
            /// </remarks>
            public bool hasNativeARC()
            {
                var __ret = Internal.hasNativeARC_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Does this runtime supports optimized setter entrypoints?</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Does this runtime supports optimized setter
            /// entrypoints?</para>
            /// </remarks>
            public bool hasOptimizedSetter()
            {
                var __ret = Internal.hasOptimizedSetter_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Does this runtime allow the use of __weak?</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Does this runtime allow the use of __weak?</para>
            /// </remarks>
            public bool allowsWeak()
            {
                var __ret = Internal.allowsWeak_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Does this runtime natively provide ARC-compliant 'weak'
            /// entrypoints?</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Does this runtime natively provide ARC-compliant
            /// 'weak'</para>
            /// <para>  /// entrypoints?</para>
            /// </remarks>
            public bool hasNativeWeak()
            {
                var __ret = Internal.hasNativeWeak_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Does this runtime directly support the subscripting
            /// methods?</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Does this runtime directly support the subscripting
            /// methods?</para>
            /// <para>  ///</para>
            /// <para>  /// This is really a property of the library, not the
            /// runtime.</para>
            /// </remarks>
            public bool hasSubscripting()
            {
                var __ret = Internal.hasSubscripting_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Does this runtime allow sizeof or alignof on object types?</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Does this runtime allow sizeof or alignof on object
            /// types?</para>
            /// </remarks>
            public bool allowsSizeofAlignof()
            {
                var __ret = Internal.allowsSizeofAlignof_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Does this runtime allow pointer arithmetic on objects?</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Does this runtime allow pointer arithmetic on
            /// objects?</para>
            /// <para>  ///</para>
            /// <para>  /// This covers +, -, ++, --, and (if
            /// isSubscriptPointerArithmetic()</para>
            /// <para>  /// yields true) [].</para>
            /// </remarks>
            public bool allowsPointerArithmetic()
            {
                var __ret = Internal.allowsPointerArithmetic_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Is subscripting pointer arithmetic?</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Is subscripting pointer arithmetic?</para>
            /// </remarks>
            public bool isSubscriptPointerArithmetic()
            {
                var __ret = Internal.isSubscriptPointerArithmetic_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Does this runtime provide an objc_terminate function?</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Does this runtime provide an objc_terminate
            /// function?</para>
            /// <para>  ///</para>
            /// <para>  /// This is used in handlers for exceptions during the unwind
            /// process;</para>
            /// <para>  /// without it, abort() must be used in pure ObjC files.</para>
            /// </remarks>
            public bool hasTerminate()
            {
                var __ret = Internal.hasTerminate_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Does this runtime support weakly importing classes?</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Does this runtime support weakly importing
            /// classes?</para>
            /// </remarks>
            public bool hasWeakClassImport()
            {
                var __ret = Internal.hasWeakClassImport_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Does this runtime use zero-cost exceptions?</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Does this runtime use zero-cost exceptions?</para>
            /// </remarks>
            public bool hasUnwindExceptions()
            {
                var __ret = Internal.hasUnwindExceptions_0(__Instance);
                return __ret;
            }

            public bool hasAtomicCopyHelper()
            {
                var __ret = Internal.hasAtomicCopyHelper_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Try to parse an Objective-C runtime specification from the given
            /// string.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Try to parse an Objective-C runtime specification from
            /// the given</para>
            /// <para>  /// string.</para>
            /// <para>  ///</para>
            /// <para>  /// \return true on error.</para>
            /// </remarks>
            public bool tryParse(llvm.StringRef input)
            {
                var arg0 = ReferenceEquals(input, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (input.__Instance);
                var __ret = Internal.tryParse_0(__Instance, arg0);
                return __ret;
            }

            public static bool operator ==(clang.ObjCRuntime left, clang.ObjCRuntime right)
            {
                bool leftNull = ReferenceEquals(left, null);
                bool rightNull = ReferenceEquals(right, null);
                if (leftNull || rightNull)
                    return leftNull && rightNull;
                var arg0 = left.__Instance;
                var arg1 = right.__Instance;
                var __ret = Internal.OperatorEqualEqual_0(arg0, arg1);
                return __ret;
            }

            public override bool Equals(object obj)
            {
                return this == obj as ObjCRuntime;
            }

            public static bool operator !=(clang.ObjCRuntime left, clang.ObjCRuntime right)
            {
                var arg0 = ReferenceEquals(left, null) ? global::System.IntPtr.Zero : left.__Instance;
                var arg1 = ReferenceEquals(right, null) ? global::System.IntPtr.Zero : right.__Instance;
                var __ret = Internal.OperatorExclaimEqual_0(arg0, arg1);
                return __ret;
            }
        }
    }
}
