//----------------------------------------------------------------------------
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
//----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace CppSharp
{
    namespace llvm
    {
        /// <summary>
        /// <para>Twine - A lightweight data structure for efficiently representing
        /// the concatenation of temporary values as strings.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// Twine - A lightweight data structure for efficiently
        /// representing the</para>
        /// <para>  /// concatenation of temporary values as strings.</para>
        /// <para>  ///</para>
        /// <para>  /// A Twine is a kind of rope, it represents a concatenated
        /// string using a</para>
        /// <para>  /// binary-tree, where the string is the preorder of the nodes.
        /// Since the</para>
        /// <para>  /// Twine can be efficiently rendered into a buffer when its
        /// result is used,</para>
        /// <para>  /// it avoids the cost of generating temporary values for
        /// intermediate string</para>
        /// <para>  /// results -- particularly in cases when the Twine result is
        /// never</para>
        /// <para>  /// required. By explicitly tracking the type of leaf nodes, we
        /// can also avoid</para>
        /// <para>  /// the creation of temporary strings for conversions
        /// operations (such as</para>
        /// <para>  /// appending an integer to a string).</para>
        /// <para>  ///</para>
        /// <para>  /// A Twine is not intended for use directly and should not be
        /// stored, its</para>
        /// <para>  /// implementation relies on the ability to store pointers to
        /// temporary stack</para>
        /// <para>  /// objects which may be deallocated at the end of a statement.
        /// Twines should</para>
        /// <para>  /// only be used accepted as const references in arguments,
        /// when an API wishes</para>
        /// <para>  /// to accept possibly-concatenated strings.</para>
        /// <para>  ///</para>
        /// <para>  /// Twines support a special 'null' value, which always
        /// concatenates to form</para>
        /// <para>  /// itself, and renders as an empty string. This can be
        /// returned from APIs to</para>
        /// <para>  /// effectively nullify any concatenations performed on the
        /// result.</para>
        /// <para>  ///</para>
        /// <para>  /// \b Implementation</para>
        /// <para>  ///</para>
        /// <para>  /// Given the nature of a Twine, it is not possible for the
        /// Twine's</para>
        /// <para>  /// concatenation method to construct interior nodes; the
        /// result must be</para>
        /// <para>  /// represented inside the returned value. For this reason a
        /// Twine object</para>
        /// <para>  /// actually holds two values, the left- and right-hand sides
        /// of a</para>
        /// <para>  /// concatenation. We also have nullary Twine objects, which
        /// are effectively</para>
        /// <para>  /// sentinel values that represent empty strings.</para>
        /// <para>  ///</para>
        /// <para>  /// Thus, a Twine can effectively have zero, one, or two
        /// children. The \see</para>
        /// <para>  /// isNullary(), \see isUnary(), and \see isBinary() predicates
        /// exist for</para>
        /// <para>  /// testing the number of children.</para>
        /// <para>  ///</para>
        /// <para>  /// We maintain a number of invariants on Twine objects (FIXME:
        /// Why):</para>
        /// <para>  ///  - Nullary twines are always represented with their Kind on
        /// the left-hand</para>
        /// <para>  ///    side, and the Empty kind on the right-hand side.</para>
        /// <para>  ///  - Unary twines are always represented with the value on
        /// the left-hand</para>
        /// <para>  ///    side, and the Empty kind on the right-hand side.</para>
        /// <para>  ///  - If a Twine has another Twine as a child, that child
        /// should always be</para>
        /// <para>  ///    binary (otherwise it could have been folded into the
        /// parent).</para>
        /// <para>  ///</para>
        /// <para>  /// These invariants are check by \see isValid().</para>
        /// <para>  ///</para>
        /// <para>  /// \b Efficiency Considerations</para>
        /// <para>  ///</para>
        /// <para>  /// The Twine is designed to yield efficient and small code for
        /// common</para>
        /// <para>  /// situations. For this reason, the concat() method is inlined
        /// so that</para>
        /// <para>  /// concatenations of leaf nodes can be optimized into stores
        /// directly into a</para>
        /// <para>  /// single stack allocated object.</para>
        /// <para>  ///</para>
        /// <para>  /// In practice, not all compilers can be trusted to optimize
        /// concat() fully,</para>
        /// <para>  /// so we provide two additional methods (and accompanying
        /// operator+</para>
        /// <para>  /// overloads) to guarantee that particularly important cases
        /// (cstring plus</para>
        /// <para>  /// StringRef) codegen as desired.</para>
        /// </remarks>
        public unsafe partial class Twine : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 24)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                internal llvm.Twine.Child.Internal LHS;

                [FieldOffset(8)]
                internal llvm.Twine.Child.Internal RHS;

                [FieldOffset(16)]
                public llvm.Twine.NodeKind LHSKind;

                [FieldOffset(17)]
                public llvm.Twine.NodeKind RHSKind;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm5TwineC2Ev")]
                internal static extern void ctor_3(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm5TwineC2EPKc")]
                internal static extern void ctor_4(global::System.IntPtr instance, global::System.IntPtr Str);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm5TwineC2ERKNS_9StringRefE")]
                internal static extern void ctor_6(global::System.IntPtr instance, global::System.IntPtr Str);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm5TwineC2Ea")]
                internal static extern void ctor_8(global::System.IntPtr instance, sbyte Val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm5TwineC2Eh")]
                internal static extern void ctor_9(global::System.IntPtr instance, byte Val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm5TwineC2Ej")]
                internal static extern void ctor_10(global::System.IntPtr instance, uint Val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm5TwineC2Ei")]
                internal static extern void ctor_11(global::System.IntPtr instance, int Val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm5TwineC2ERKm")]
                internal static extern void ctor_12(global::System.IntPtr instance, ulong* Val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm5TwineC2ERKl")]
                internal static extern void ctor_13(global::System.IntPtr instance, long* Val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm5TwineC2ERKy")]
                internal static extern void ctor_14(global::System.IntPtr instance, ulong* Val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm5TwineC2ERKx")]
                internal static extern void ctor_15(global::System.IntPtr instance, long* Val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm5TwineC2EPKcRKNS_9StringRefE")]
                internal static extern void ctor_16(global::System.IntPtr instance, global::System.IntPtr _LHS, global::System.IntPtr _RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm5TwineC2ERKNS_9StringRefEPKc")]
                internal static extern void ctor_17(global::System.IntPtr instance, global::System.IntPtr _LHS, global::System.IntPtr _RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm5TwineC2ERKS0_")]
                internal static extern void cctor_18(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm5Twine10createNullEv")]
                internal static extern void createNull_0(global::System.IntPtr @return);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm5Twine9utohexstrERKy")]
                internal static extern void utohexstr_0(global::System.IntPtr @return, ulong* Val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5Twine16isTriviallyEmptyEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isTriviallyEmpty_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5Twine17isSingleStringRefEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isSingleStringRef_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5Twine6concatERKS0_")]
                internal static extern void concat_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr Suffix);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5Twine18getSingleStringRefEv")]
                internal static extern llvm.StringRef.Internal getSingleStringRef_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5Twine5printERNS_11raw_ostreamE")]
                internal static extern void print_0(global::System.IntPtr instance, global::System.IntPtr OS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5Twine4dumpEv")]
                internal static extern void dump_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5Twine9printReprERNS_11raw_ostreamE")]
                internal static extern void printRepr_0(global::System.IntPtr instance, global::System.IntPtr OS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm5Twine8dumpReprEv")]
                internal static extern void dumpRepr_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvmplERKNS_5TwineES2_")]
                internal static extern void OperatorPlus_0(global::System.IntPtr @return, global::System.IntPtr LHS, global::System.IntPtr RHS);
            }

            internal unsafe partial struct Child
            {
                [StructLayout(LayoutKind.Explicit, Size = 8)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public global::System.IntPtr twine;

                    [FieldOffset(0)]
                    public global::System.IntPtr cString;

                    [FieldOffset(0)]
                    public global::System.IntPtr stdString;

                    [FieldOffset(0)]
                    public global::System.IntPtr stringRef;

                    [FieldOffset(0)]
                    public sbyte character;

                    [FieldOffset(0)]
                    public uint decUI;

                    [FieldOffset(0)]
                    public int decI;

                    [FieldOffset(0)]
                    public ulong* decUL;

                    [FieldOffset(0)]
                    public long* decL;

                    [FieldOffset(0)]
                    public ulong* decULL;

                    [FieldOffset(0)]
                    public long* decLL;

                    [FieldOffset(0)]
                    public ulong* uHex;
                }
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, Twine> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, Twine>();

            private readonly bool __ownsNativeInstance;

            public static Twine __CreateInstance(global::System.IntPtr native)
            {
                return new Twine((Twine.Internal*) native);
            }

            public static Twine __CreateInstance(Twine.Internal native)
            {
                return new Twine(native);
            }

            private static Twine.Internal* __CopyValue(Twine.Internal native)
            {
                var ret = (Twine.Internal*) Marshal.AllocHGlobal(24);
                *ret = native;
                return ret;
            }

            private Twine(Twine.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected Twine(Twine.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            /// <summary>
            /// <para>Construct from an empty string.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Construct from an empty string.</para>
            /// </remarks>
            public Twine()
            {
                __Instance = Marshal.AllocHGlobal(24);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_3(__Instance);
            }

            /// <summary>
            /// <para>Construct from a C string.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Construct from a C string.</para>
            /// <para>    ///</para>
            /// <para>    /// We take care here to optimize &quot;&quot; into the empty
            /// twine -- this will be</para>
            /// <para>    /// optimized out for string constants. This allows Twine
            /// arguments have</para>
            /// <para>    /// default &quot;&quot; values, without introducing
            /// unnecessary string constants.</para>
            /// </remarks>
            public Twine(string Str)
            {
                __Instance = Marshal.AllocHGlobal(24);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = Marshal.StringToHGlobalAnsi(Str);
                Internal.ctor_4(__Instance, arg0);
                Marshal.FreeHGlobal(arg0);
            }

            /// <summary>
            /// <para>Construct from a StringRef.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Construct from a StringRef.</para>
            /// </remarks>
            public Twine(llvm.StringRef Str)
            {
                __Instance = Marshal.AllocHGlobal(24);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(Str, null) ? global::System.IntPtr.Zero : Str.__Instance;
                Internal.ctor_6(__Instance, arg0);
            }

            /// <summary>
            /// <para>Construct from a signed char.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Construct from a signed char.</para>
            /// </remarks>
            public Twine(sbyte Val)
            {
                __Instance = Marshal.AllocHGlobal(24);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_8(__Instance, Val);
            }

            /// <summary>
            /// <para>Construct from an unsigned char.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Construct from an unsigned char.</para>
            /// </remarks>
            public Twine(byte Val)
            {
                __Instance = Marshal.AllocHGlobal(24);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_9(__Instance, Val);
            }

            /// <summary>
            /// <para>Construct a twine to print Val as an unsigned decimal
            /// integer.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Construct a twine to print \p Val as an unsigned decimal
            /// integer.</para>
            /// </remarks>
            public Twine(uint Val)
            {
                __Instance = Marshal.AllocHGlobal(24);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_10(__Instance, Val);
            }

            /// <summary>
            /// <para>Construct a twine to print Val as a signed decimal
            /// integer.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Construct a twine to print \p Val as a signed decimal
            /// integer.</para>
            /// </remarks>
            public Twine(int Val)
            {
                __Instance = Marshal.AllocHGlobal(24);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_11(__Instance, Val);
            }

            /// <summary>
            /// <para>Construct a twine to print Val as an unsigned decimal
            /// integer.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Construct a twine to print \p Val as an unsigned decimal
            /// integer.</para>
            /// </remarks>
            public Twine(ref ulong Val)
            {
                __Instance = Marshal.AllocHGlobal(24);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                fixed (ulong* arg0 = &Val)
                {
                    Internal.ctor_12(__Instance, arg0);
                }
            }

            /// <summary>
            /// <para>Construct a twine to print Val as a signed decimal
            /// integer.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Construct a twine to print \p Val as a signed decimal
            /// integer.</para>
            /// </remarks>
            public Twine(ref long Val)
            {
                __Instance = Marshal.AllocHGlobal(24);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                fixed (long* arg0 = &Val)
                {
                    Internal.ctor_13(__Instance, arg0);
                }
            }

            /// <summary>
            /// <para>Construct a twine to print Val as an unsigned decimal
            /// integer.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Construct a twine to print \p Val as an unsigned decimal
            /// integer.</para>
            /// </remarks>
            public Twine(ref ulong Val)
            {
                __Instance = Marshal.AllocHGlobal(24);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                fixed (ulong* arg0 = &Val)
                {
                    Internal.ctor_14(__Instance, arg0);
                }
            }

            /// <summary>
            /// <para>Construct a twine to print Val as a signed decimal
            /// integer.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Construct a twine to print \p Val as a signed decimal
            /// integer.</para>
            /// </remarks>
            public Twine(ref long Val)
            {
                __Instance = Marshal.AllocHGlobal(24);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                fixed (long* arg0 = &Val)
                {
                    Internal.ctor_15(__Instance, arg0);
                }
            }

            /// <summary>
            /// <para>Construct as the concatenation of a C string and a
            /// StringRef.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Construct as the concatenation of a C string and a
            /// StringRef.</para>
            /// </remarks>
            public Twine(string _LHS, llvm.StringRef _RHS)
            {
                __Instance = Marshal.AllocHGlobal(24);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = Marshal.StringToHGlobalAnsi(_LHS);
                var arg1 = ReferenceEquals(_RHS, null) ? global::System.IntPtr.Zero : _RHS.__Instance;
                Internal.ctor_16(__Instance, arg0, arg1);
                Marshal.FreeHGlobal(arg0);
            }

            /// <summary>
            /// <para>Construct as the concatenation of a StringRef and a C
            /// string.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Construct as the concatenation of a StringRef and a C
            /// string.</para>
            /// </remarks>
            public Twine(llvm.StringRef _LHS, string _RHS)
            {
                __Instance = Marshal.AllocHGlobal(24);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(_LHS, null) ? global::System.IntPtr.Zero : _LHS.__Instance;
                var arg1 = Marshal.StringToHGlobalAnsi(_RHS);
                Internal.ctor_17(__Instance, arg0, arg1);
                Marshal.FreeHGlobal(arg1);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                llvm.Twine __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            /// <summary>
            /// <para>isTriviallyEmpty - Check if this twine is trivially empty; a
            /// false return value does not necessarily mean the twine is empty.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// isTriviallyEmpty - Check if this twine is trivially empty; a
            /// false</para>
            /// <para>    /// return value does not necessarily mean the twine is
            /// empty.</para>
            /// </remarks>
            public bool isTriviallyEmpty()
            {
                var __ret = Internal.isTriviallyEmpty_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>isSingleStringRef - Return true if this twine can be dynamically
            /// accessed as a single StringRef value with getSingleStringRef().</para>
            /// </summary>
            /// <remarks>
            /// <para>/// isSingleStringRef - Return true if this twine can be
            /// dynamically</para>
            /// <para>    /// accessed as a single StringRef value with
            /// getSingleStringRef().</para>
            /// </remarks>
            public bool isSingleStringRef()
            {
                var __ret = Internal.isSingleStringRef_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>@} @{</para>
            /// </summary>
            /// <remarks>
            /// <para>/// @}</para>
            /// <para>    /// @name String Operations</para>
            /// <para>    /// @{</para>
            /// </remarks>
            public llvm.Twine concat(llvm.Twine Suffix)
            {
                var arg0 = ReferenceEquals(Suffix, null) ? global::System.IntPtr.Zero : Suffix.__Instance;
                var __ret = new llvm.Twine.Internal();
                Internal.concat_0(new IntPtr(&__ret), __Instance, arg0);
                return llvm.Twine.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>getSingleStringRef - This returns the twine as a single
            /// StringRef. This method is only valid if isSingleStringRef() is true.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getSingleStringRef - This returns the twine as a single
            /// StringRef.  This</para>
            /// <para>    /// method is only valid if isSingleStringRef() is
            /// true.</para>
            /// </remarks>
            public llvm.StringRef getSingleStringRef()
            {
                var __ret = Internal.getSingleStringRef_0(__Instance);
                return llvm.StringRef.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Write the concatenated string represented by this twine to the
            /// stream OS.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Write the concatenated string represented by this twine to
            /// the</para>
            /// <para>    /// stream \p OS.</para>
            /// </remarks>
            public void print(llvm.raw_ostream OS)
            {
                var arg0 = ReferenceEquals(OS, null) ? global::System.IntPtr.Zero : OS.__Instance;
                Internal.print_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>Dump the concatenated string represented by this twine to
            /// stderr.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Dump the concatenated string represented by this twine to
            /// stderr.</para>
            /// </remarks>
            public void dump()
            {
                Internal.dump_0(__Instance);
            }

            /// <summary>
            /// <para>Write the representation of this twine to the stream OS.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Write the representation of this twine to the stream \p
            /// OS.</para>
            /// </remarks>
            public void printRepr(llvm.raw_ostream OS)
            {
                var arg0 = ReferenceEquals(OS, null) ? global::System.IntPtr.Zero : OS.__Instance;
                Internal.printRepr_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>Dump the representation of this twine to stderr.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Dump the representation of this twine to stderr.</para>
            /// </remarks>
            public void dumpRepr()
            {
                Internal.dumpRepr_0(__Instance);
            }

            /// <summary>
            /// <para>Create a 'null' string, which is an empty string that always
            /// concatenates to form another empty string.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Create a 'null' string, which is an empty string that
            /// always</para>
            /// <para>    /// concatenates to form another empty string.</para>
            /// </remarks>
            public static llvm.Twine createNull()
            {
                var __ret = new llvm.Twine.Internal();
                Internal.createNull_0(new IntPtr(&__ret));
                return llvm.Twine.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>@} @{</para>
            /// </summary>
            /// <remarks>
            /// <para>/// @}</para>
            /// <para>    /// @name Numeric Conversions</para>
            /// <para>    /// @{</para>
            /// </remarks>
            public static llvm.Twine utohexstr(ref ulong Val)
            {
                fixed (ulong* arg0 = &Val)
                {
                    var __ret = new llvm.Twine.Internal();
                    Internal.utohexstr_0(new IntPtr(&__ret), arg0);
                    return llvm.Twine.__CreateInstance(__ret);
                }
            }

            public static llvm.Twine operator +(llvm.Twine LHS, llvm.Twine RHS)
            {
                var arg0 = ReferenceEquals(LHS, null) ? global::System.IntPtr.Zero : LHS.__Instance;
                var arg1 = ReferenceEquals(RHS, null) ? global::System.IntPtr.Zero : RHS.__Instance;
                var __ret = new llvm.Twine.Internal();
                Internal.OperatorPlus_0(new IntPtr(&__ret), arg0, arg1);
                return llvm.Twine.__CreateInstance(__ret);
            }
        }
    }
}
