//----------------------------------------------------------------------------
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
//----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace CppSharp
{
    public unsafe partial class Specifiers
    {
        public partial struct Internal
        {
        }
    }

    namespace clang
    {
        /// <summary>
        /// <para>CallingConv - Specifies the calling convention that a function
        /// uses.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief CallingConv - Specifies the calling convention that a
        /// function uses.</para>
        /// </remarks>
        public enum CallingConv : uint
        {
            CC_C = 0,
            CC_X86StdCall = 1,
            CC_X86FastCall = 2,
            CC_X86ThisCall = 3,
            CC_X86VectorCall = 4,
            CC_X86Pascal = 5,
            CC_X86_64Win64 = 6,
            CC_X86_64SysV = 7,
            CC_AAPCS = 8,
            CC_AAPCS_VFP = 9,
            CC_IntelOclBicc = 10,
            CC_SpirFunction = 11,
            CC_SpirKernel = 12
        }

        /// <summary>
        /// <para>Storage classes.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief Storage classes.</para>
        /// </remarks>
        public enum StorageClass : uint
        {
            SC_None = 0,
            SC_Extern = 1,
            SC_Static = 2,
            SC_PrivateExtern = 3,
            SC_OpenCLWorkGroupLocal = 4,
            SC_Auto = 5,
            SC_Register = 6
        }

        /// <summary>
        /// <para>In-class initialization styles for non-static data
        /// members.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief In-class initialization styles for non-static data
        /// members.</para>
        /// </remarks>
        public enum InClassInitStyle : uint
        {
            /// <summary>No in-class initializer.</summary>
            ICIS_NoInit = 0,
            /// <summary>Copy initialization.</summary>
            ICIS_CopyInit = 1,
            /// <summary>Direct list-initialization.</summary>
            ICIS_ListInit = 2
        }

        /// <summary>
        /// <para>Thread storage-class-specifier.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief Thread storage-class-specifier.</para>
        /// </remarks>
        public enum ThreadStorageClassSpecifier : uint
        {
            TSCS_unspecified = 0,
            /// <summary>GNU __thread.</summary>
            TSCS___thread = 1,
            /// <summary>C++11 thread_local. Implies 'static' at block scope, but not at class scope.</summary>
            TSCS_thread_local = 2,
            /// <summary>C11 _Thread_local. Must be combined with either 'static' or 'extern' if used at block scope.</summary>
            TSCS__Thread_local = 3
        }

        /// <summary>
        /// <para>The storage duration for an object (per C++ [basic.stc]).</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief The storage duration for an object (per C++
        /// [basic.stc]).</para>
        /// </remarks>
        public enum StorageDuration : uint
        {
            /// <summary>Full-expression storage duration (for temporaries).</summary>
            SD_FullExpression = 0,
            /// <summary>Automatic storage duration (most local variables).</summary>
            SD_Automatic = 1,
            /// <summary>Thread storage duration.</summary>
            SD_Thread = 2,
            /// <summary>Static storage duration.</summary>
            SD_Static = 3,
            /// <summary>Dynamic storage duration.</summary>
            SD_Dynamic = 4
        }

        /// <summary>
        /// <para>Describes the kind of template specialization that a particular
        /// template specialization declaration represents.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief Describes the kind of template specialization that
        /// a</para>
        /// <para>  /// particular template specialization declaration
        /// represents.</para>
        /// </remarks>
        public enum TemplateSpecializationKind : uint
        {
            /// <summary>This template specialization was formed from a template-id but has not yet been declared, defined, or instantiated.</summary>
            TSK_Undeclared = 0,
            /// <summary>This template specialization was implicitly instantiated from a template. (C++ [temp.inst]).</summary>
            TSK_ImplicitInstantiation = 1,
            /// <summary>This template specialization was declared or defined by an explicit specialization (C++ [temp.expl.spec]) or partial specialization (C++ [temp.class.spec]).</summary>
            TSK_ExplicitSpecialization = 2,
            /// <summary>This template specialization was instantiated from a template due to an explicit instantiation declaration request (C++11 [temp.explicit]).</summary>
            TSK_ExplicitInstantiationDeclaration = 3,
            /// <summary>This template specialization was instantiated from a template due to an explicit instantiation definition request (C++ [temp.explicit]).</summary>
            TSK_ExplicitInstantiationDefinition = 4
        }

        /// <summary>
        /// <para>A C++ access specifier (public, private, protected), plus the
        /// special value &quot;none&quot; which means different things in different
        /// contexts.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief A C++ access specifier (public, private, protected),
        /// plus the</para>
        /// <para>  /// special value &quot;none&quot; which means different things
        /// in different contexts.</para>
        /// </remarks>
        public enum AccessSpecifier : uint
        {
            AS_public = 0,
            AS_protected = 1,
            AS_private = 2,
            AS_none = 3
        }

        /// <summary>
        /// <para>Specifies the width of a type, e.g., short, long, or long
        /// long.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief Specifies the width of a type, e.g., short, long, or
        /// long long.</para>
        /// </remarks>
        public enum TypeSpecifierWidth : uint
        {
            TSW_unspecified = 0,
            TSW_short = 1,
            TSW_long = 2,
            TSW_longlong = 3
        }

        /// <summary>
        /// <para>Specifies the signedness of a type, e.g., signed or
        /// unsigned.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief Specifies the signedness of a type, e.g., signed or
        /// unsigned.</para>
        /// </remarks>
        public enum TypeSpecifierSign : uint
        {
            TSS_unspecified = 0,
            TSS_signed = 1,
            TSS_unsigned = 2
        }

        /// <summary>
        /// <para>Specifies the kind of type.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief Specifies the kind of type.</para>
        /// </remarks>
        public enum TypeSpecifierType : uint
        {
            TST_unspecified = 0,
            TST_void = 1,
            TST_char = 2,
            TST_wchar = 3,
            TST_char16 = 4,
            TST_char32 = 5,
            TST_int = 6,
            TST_int128 = 7,
            TST_half = 8,
            TST_float = 9,
            TST_double = 10,
            TST_bool = 11,
            TST_decimal32 = 12,
            TST_decimal64 = 13,
            TST_decimal128 = 14,
            TST_enum = 15,
            TST_union = 16,
            TST_struct = 17,
            TST_class = 18,
            TST_interface = 19,
            TST_typename = 20,
            TST_typeofType = 21,
            TST_typeofExpr = 22,
            TST_decltype = 23,
            TST_underlyingType = 24,
            TST_auto = 25,
            TST_decltype_auto = 26,
            TST_unknown_anytype = 27,
            TST_atomic = 28,
            TST_error = 29
        }

        /// <summary>
        /// <para>The categorization of expression values, currently following the
        /// C++11 scheme.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief The categorization of expression values, currently
        /// following the</para>
        /// <para>  /// C++11 scheme.</para>
        /// </remarks>
        public enum ExprValueKind : uint
        {
            /// <summary>An r-value expression (a pr-value in the C++11 taxonomy) produces a temporary value.</summary>
            VK_RValue = 0,
            /// <summary>An l-value expression is a reference to an object with independent storage.</summary>
            VK_LValue = 1,
            /// <summary>An x-value expression is a reference to an object with independent storage but which can be "moved", i.e. efficiently cannibalized for its resources.</summary>
            VK_XValue = 2
        }

        /// <summary>
        /// <para>A further classification of the kind of object referenced by an
        /// l-value or x-value.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief A further classification of the kind of object
        /// referenced by an</para>
        /// <para>  /// l-value or x-value.</para>
        /// </remarks>
        public enum ExprObjectKind : uint
        {
            /// <summary>An ordinary object is located at an address in memory.</summary>
            OK_Ordinary = 0,
            /// <summary>A bitfield object is a bitfield on a C or C++ record.</summary>
            OK_BitField = 1,
            /// <summary>A vector component is an element or range of elements on a vector.</summary>
            OK_VectorComponent = 2,
            /// <summary>An Objective-C property is a logical field of an Objective-C object which is read and written via Objective-C method calls.</summary>
            OK_ObjCProperty = 3,
            /// <summary>An Objective-C array/dictionary subscripting which reads an object or writes at the subscripted array/dictionary element via Objective-C method calls.</summary>
            OK_ObjCSubscript = 4
        }

        /// <summary>
        /// <para>Structure that packs information about the type specifiers that
        /// were written in a particular type specifier sequence.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief Structure that packs information about the type
        /// specifiers that</para>
        /// <para>  /// were written in a particular type specifier
        /// sequence.</para>
        /// </remarks>
        public unsafe partial class WrittenBuiltinSpecs : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 4)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public uint Type;

                [FieldOffset(0)]
                public uint Sign;

                [FieldOffset(0)]
                public uint Width;

                [FieldOffset(1)]
                public bool ModeAttr;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang19WrittenBuiltinSpecsC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, WrittenBuiltinSpecs> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, WrittenBuiltinSpecs>();

            private readonly bool __ownsNativeInstance;

            public static WrittenBuiltinSpecs __CreateInstance(global::System.IntPtr native)
            {
                return new WrittenBuiltinSpecs((WrittenBuiltinSpecs.Internal*) native);
            }

            public static WrittenBuiltinSpecs __CreateInstance(WrittenBuiltinSpecs.Internal native)
            {
                return new WrittenBuiltinSpecs(native);
            }

            private static WrittenBuiltinSpecs.Internal* __CopyValue(WrittenBuiltinSpecs.Internal native)
            {
                var ret = (WrittenBuiltinSpecs.Internal*) Marshal.AllocHGlobal(4);
                *ret = native;
                return ret;
            }

            private WrittenBuiltinSpecs(WrittenBuiltinSpecs.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected WrittenBuiltinSpecs(WrittenBuiltinSpecs.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public WrittenBuiltinSpecs()
            {
                __Instance = Marshal.AllocHGlobal(4);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.WrittenBuiltinSpecs __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public uint Type
            {
                get
                {
                    return ((Internal*) __Instance)->Type;
                }

                set
                {
                    ((Internal*) __Instance)->Type = value;
                }
            }

            public uint Sign
            {
                get
                {
                    return ((Internal*) __Instance)->Sign;
                }

                set
                {
                    ((Internal*) __Instance)->Sign = value;
                }
            }

            public uint Width
            {
                get
                {
                    return ((Internal*) __Instance)->Width;
                }

                set
                {
                    ((Internal*) __Instance)->Width = value;
                }
            }

            public bool ModeAttr
            {
                get
                {
                    return ((Internal*) __Instance)->ModeAttr;
                }

                set
                {
                    ((Internal*) __Instance)->ModeAttr = value;
                }
            }
        }

        public unsafe partial class Specifiers
        {
            public partial struct Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang23isTemplateInstantiationENS_26TemplateSpecializationKindE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isTemplateInstantiation_0(clang.TemplateSpecializationKind Kind);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang18isLegalForFunctionENS_12StorageClassE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isLegalForFunction_0(clang.StorageClass SC);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang18isLegalForVariableENS_12StorageClassE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isLegalForVariable_0(clang.StorageClass SC);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang20supportsVariadicCallENS_11CallingConvE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool supportsVariadicCall_0(clang.CallingConv CC);
            }

            /// <summary>
            /// <para>Determine whether this template specialization kind refers to an
            /// instantiation of an entity (as opposed to a non-template or an explicit
            /// specialization).</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine whether this template specialization kind
            /// refers</para>
            /// <para>  /// to an instantiation of an entity (as opposed to a
            /// non-template or</para>
            /// <para>  /// an explicit specialization).</para>
            /// </remarks>
            public static bool isTemplateInstantiation(clang.TemplateSpecializationKind Kind)
            {
                var arg0 = Kind;
                var __ret = Internal.isTemplateInstantiation_0(arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Checks whether the given storage class is legal for
            /// functions.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Checks whether the given storage class is legal for
            /// functions.</para>
            /// </remarks>
            public static bool isLegalForFunction(clang.StorageClass SC)
            {
                var arg0 = SC;
                var __ret = Internal.isLegalForFunction_0(arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Checks whether the given storage class is legal for
            /// variables.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Checks whether the given storage class is legal for
            /// variables.</para>
            /// </remarks>
            public static bool isLegalForVariable(clang.StorageClass SC)
            {
                var arg0 = SC;
                var __ret = Internal.isLegalForVariable_0(arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Checks whether the given calling convention supports variadic
            /// calls. Unprototyped calls also use the variadic call rules.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Checks whether the given calling convention supports
            /// variadic</para>
            /// <para>  /// calls. Unprototyped calls also use the variadic call
            /// rules.</para>
            /// </remarks>
            public static bool supportsVariadicCall(clang.CallingConv CC)
            {
                var arg0 = CC;
                var __ret = Internal.supportsVariadicCall_0(arg0);
                return __ret;
            }
        }
    }
}
