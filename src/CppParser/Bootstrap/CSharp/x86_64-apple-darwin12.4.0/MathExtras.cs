//----------------------------------------------------------------------------
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
//----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace CppSharp
{
    public unsafe partial class MathExtras
    {
        public partial struct Internal
        {
        }
    }

    namespace llvm
    {
        /// <summary>
        /// <para>The behavior an operation has on an input of 0.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief The behavior an operation has on an input of 0.</para>
        /// </remarks>
        public enum ZeroBehavior : uint
        {
            /// <summary>The returned value is undefined.</summary>
            ZB_Undefined = 0,
            /// <summary>The returned value is numeric_limits<T>::max()</summary>
            ZB_Max = 1,
            /// <summary>The returned value is numeric_limits<T>::digits</summary>
            ZB_Width = 2
        }

        public unsafe partial class MathExtras
        {
            public partial struct Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm5Hi_32Ey")]
                internal static extern uint Hi_32_0(ulong Value);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm5Lo_32Ey")]
                internal static extern uint Lo_32_0(ulong Value);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm7Make_64Ejj")]
                internal static extern ulong Make_64_0(uint High, uint Low);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm7isUIntNEjy")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isUIntN_0(uint N, ulong x);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm6isIntNEjx")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isIntN_0(uint N, long x);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm9isMask_32Ej")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isMask_32_0(uint Value);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm9isMask_64Ey")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isMask_64_0(ulong Value);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm16isShiftedMask_32Ej")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isShiftedMask_32_0(uint Value);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm16isShiftedMask_64Ey")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isShiftedMask_64_0(ulong Value);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm13isPowerOf2_32Ej")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isPowerOf2_32_0(uint Value);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm13isPowerOf2_64Ey")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isPowerOf2_64_0(ulong Value);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm11ByteSwap_16Et")]
                internal static extern ushort ByteSwap_16_0(ushort Value);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm11ByteSwap_32Ej")]
                internal static extern uint ByteSwap_32_0(uint Value);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm11ByteSwap_64Ey")]
                internal static extern ulong ByteSwap_64_0(ulong Value);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm7Log2_32Ej")]
                internal static extern uint Log2_32_0(uint Value);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm7Log2_64Ey")]
                internal static extern uint Log2_64_0(ulong Value);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm12Log2_32_CeilEj")]
                internal static extern uint Log2_32_Ceil_0(uint Value);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm12Log2_64_CeilEy")]
                internal static extern uint Log2_64_Ceil_0(ulong Value);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm23GreatestCommonDivisor64Eyy")]
                internal static extern ulong GreatestCommonDivisor64_0(ulong A, ulong B);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm12BitsToDoubleEy")]
                internal static extern double BitsToDouble_0(ulong Bits);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm11BitsToFloatEj")]
                internal static extern float BitsToFloat_0(uint Bits);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm12DoubleToBitsEd")]
                internal static extern ulong DoubleToBits_0(double Double);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm11FloatToBitsEf")]
                internal static extern uint FloatToBits_0(float Float);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm5IsNANEf")]
                internal static extern int IsNAN_0(float f);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm5IsNANEd")]
                internal static extern int IsNAN_1(double d);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm5IsInfEf")]
                internal static extern int IsInf_0(float f);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm5IsInfEd")]
                internal static extern int IsInf_1(double d);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm8MinAlignEyy")]
                internal static extern ulong MinAlign_0(ulong A, ulong B);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm9alignAddrEPvm")]
                internal static extern ulong alignAddr_0(global::System.IntPtr Addr, ulong Alignment);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm19alignmentAdjustmentEPvm")]
                internal static extern ulong alignmentAdjustment_0(global::System.IntPtr Ptr, ulong Alignment);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm12NextPowerOf2Ey")]
                internal static extern ulong NextPowerOf2_0(ulong A);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm13PowerOf2FloorEy")]
                internal static extern ulong PowerOf2Floor_0(ulong A);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm18RoundUpToAlignmentEyy")]
                internal static extern ulong RoundUpToAlignment_0(ulong Value, ulong Align);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm17OffsetToAlignmentEyy")]
                internal static extern ulong OffsetToAlignment_0(ulong Value, ulong Align);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm5abs64Ex")]
                internal static extern long abs64_0(long x);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm12SignExtend32Ejj")]
                internal static extern int SignExtend32_0(uint X, uint B);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm12SignExtend64Eyj")]
                internal static extern long SignExtend64_0(ulong X, uint B);
            }

            /// <summary>
            /// <para>Hi_32 - This function returns the high 32 bits of a 64 bit
            /// value.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Hi_32 - This function returns the high 32 bits of a 64 bit
            /// value.</para>
            /// </remarks>
            public static uint Hi_32(ulong Value)
            {
                var arg0 = Value;
                var __ret = Internal.Hi_32_0(arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Lo_32 - This function returns the low 32 bits of a 64 bit
            /// value.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Lo_32 - This function returns the low 32 bits of a 64 bit
            /// value.</para>
            /// </remarks>
            public static uint Lo_32(ulong Value)
            {
                var arg0 = Value;
                var __ret = Internal.Lo_32_0(arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Make_64 - This functions makes a 64-bit integer from a high / low
            /// pair of 32-bit integers.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Make_64 - This functions makes a 64-bit integer from a high /
            /// low pair of</para>
            /// <para>///           32-bit integers.</para>
            /// </remarks>
            public static ulong Make_64(uint High, uint Low)
            {
                var arg0 = High;
                var arg1 = Low;
                var __ret = Internal.Make_64_0(arg0, arg1);
                return __ret;
            }

            /// <summary>
            /// <para>isUIntN - Checks if an unsigned integer fits into the given
            /// (dynamic) bit width.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// isUIntN - Checks if an unsigned integer fits into the given
            /// (dynamic)</para>
            /// <para>/// bit width.</para>
            /// </remarks>
            public static bool isUIntN(uint N, ulong x)
            {
                var arg1 = x;
                var __ret = Internal.isUIntN_0(N, arg1);
                return __ret;
            }

            /// <summary>
            /// <para>isIntN - Checks if an signed integer fits into the given
            /// (dynamic) bit width.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// isIntN - Checks if an signed integer fits into the given
            /// (dynamic)</para>
            /// <para>/// bit width.</para>
            /// </remarks>
            public static bool isIntN(uint N, long x)
            {
                var arg1 = x;
                var __ret = Internal.isIntN_0(N, arg1);
                return __ret;
            }

            /// <summary>
            /// <para>isMask_32 - This function returns true if the argument is a
            /// sequence of ones starting at the least significant bit with the remainder
            /// zero (32 bit version). Ex. isMask_32(0x0000FFFFU) == true.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// isMask_32 - This function returns true if the argument is a
            /// sequence of ones</para>
            /// <para>/// starting at the least significant bit with the remainder zero
            /// (32 bit</para>
            /// <para>/// version).   Ex. isMask_32(0x0000FFFFU) == true.</para>
            /// </remarks>
            public static bool isMask_32(uint Value)
            {
                var arg0 = Value;
                var __ret = Internal.isMask_32_0(arg0);
                return __ret;
            }

            /// <summary>
            /// <para>isMask_64 - This function returns true if the argument is a
            /// sequence of ones starting at the least significant bit with the remainder
            /// zero (64 bit version).</para>
            /// </summary>
            /// <remarks>
            /// <para>/// isMask_64 - This function returns true if the argument is a
            /// sequence of ones</para>
            /// <para>/// starting at the least significant bit with the remainder zero
            /// (64 bit</para>
            /// <para>/// version).</para>
            /// </remarks>
            public static bool isMask_64(ulong Value)
            {
                var arg0 = Value;
                var __ret = Internal.isMask_64_0(arg0);
                return __ret;
            }

            /// <summary>
            /// <para>isShiftedMask_32 - This function returns true if the argument
            /// contains a sequence of ones with the remainder zero (32 bit version.) Ex.
            /// isShiftedMask_32(0x0000FF00U) == true.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// isShiftedMask_32 - This function returns true if the argument
            /// contains a</para>
            /// <para>/// sequence of ones with the remainder zero (32 bit
            /// version.)</para>
            /// <para>/// Ex. isShiftedMask_32(0x0000FF00U) == true.</para>
            /// </remarks>
            public static bool isShiftedMask_32(uint Value)
            {
                var arg0 = Value;
                var __ret = Internal.isShiftedMask_32_0(arg0);
                return __ret;
            }

            /// <summary>
            /// <para>isShiftedMask_64 - This function returns true if the argument
            /// contains a sequence of ones with the remainder zero (64 bit
            /// version.)</para>
            /// </summary>
            /// <remarks>
            /// <para>/// isShiftedMask_64 - This function returns true if the argument
            /// contains a</para>
            /// <para>/// sequence of ones with the remainder zero (64 bit
            /// version.)</para>
            /// </remarks>
            public static bool isShiftedMask_64(ulong Value)
            {
                var arg0 = Value;
                var __ret = Internal.isShiftedMask_64_0(arg0);
                return __ret;
            }

            /// <summary>
            /// <para>isPowerOf2_32 - This function returns true if the argument is a
            /// power of two &gt; 0. Ex. isPowerOf2_32(0x00100000U) == true (32 bit
            /// edition.)</para>
            /// </summary>
            /// <remarks>
            /// <para>/// isPowerOf2_32 - This function returns true if the argument is
            /// a power of</para>
            /// <para>/// two &gt; 0. Ex. isPowerOf2_32(0x00100000U) == true (32 bit
            /// edition.)</para>
            /// </remarks>
            public static bool isPowerOf2_32(uint Value)
            {
                var arg0 = Value;
                var __ret = Internal.isPowerOf2_32_0(arg0);
                return __ret;
            }

            /// <summary>
            /// <para>isPowerOf2_64 - This function returns true if the argument is a
            /// power of two &gt; 0 (64 bit edition.)</para>
            /// </summary>
            /// <remarks>
            /// <para>/// isPowerOf2_64 - This function returns true if the argument is
            /// a power of two</para>
            /// <para>/// &gt; 0 (64 bit edition.)</para>
            /// </remarks>
            public static bool isPowerOf2_64(ulong Value)
            {
                var arg0 = Value;
                var __ret = Internal.isPowerOf2_64_0(arg0);
                return __ret;
            }

            /// <summary>
            /// <para>ByteSwap_16 - This function returns a byte-swapped representation
            /// of the 16-bit argument, Value.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// ByteSwap_16 - This function returns a byte-swapped
            /// representation of the</para>
            /// <para>/// 16-bit argument, Value.</para>
            /// </remarks>
            public static ushort ByteSwap_16(ushort Value)
            {
                var arg0 = Value;
                var __ret = Internal.ByteSwap_16_0(arg0);
                return __ret;
            }

            /// <summary>
            /// <para>ByteSwap_32 - This function returns a byte-swapped representation
            /// of the 32-bit argument, Value.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// ByteSwap_32 - This function returns a byte-swapped
            /// representation of the</para>
            /// <para>/// 32-bit argument, Value.</para>
            /// </remarks>
            public static uint ByteSwap_32(uint Value)
            {
                var arg0 = Value;
                var __ret = Internal.ByteSwap_32_0(arg0);
                return __ret;
            }

            /// <summary>
            /// <para>ByteSwap_64 - This function returns a byte-swapped representation
            /// of the 64-bit argument, Value.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// ByteSwap_64 - This function returns a byte-swapped
            /// representation of the</para>
            /// <para>/// 64-bit argument, Value.</para>
            /// </remarks>
            public static ulong ByteSwap_64(ulong Value)
            {
                var arg0 = Value;
                var __ret = Internal.ByteSwap_64_0(arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Log2_32 - This function returns the floor log base 2 of the
            /// specified value, -1 if the value is zero. (32 bit edition.) Ex. Log2_32(32)
            /// == 5, Log2_32(1) == 0, Log2_32(0) == -1, Log2_32(6) == 2</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Log2_32 - This function returns the floor log base 2 of the
            /// specified value,</para>
            /// <para>/// -1 if the value is zero. (32 bit edition.)</para>
            /// <para>/// Ex. Log2_32(32) == 5, Log2_32(1) == 0, Log2_32(0) == -1,
            /// Log2_32(6) == 2</para>
            /// </remarks>
            public static uint Log2_32(uint Value)
            {
                var arg0 = Value;
                var __ret = Internal.Log2_32_0(arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Log2_64 - This function returns the floor log base 2 of the
            /// specified value, -1 if the value is zero. (64 bit edition.)</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Log2_64 - This function returns the floor log base 2 of the
            /// specified value,</para>
            /// <para>/// -1 if the value is zero. (64 bit edition.)</para>
            /// </remarks>
            public static uint Log2_64(ulong Value)
            {
                var arg0 = Value;
                var __ret = Internal.Log2_64_0(arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Log2_32_Ceil - This function returns the ceil log base 2 of the
            /// specified value, 32 if the value is zero. (32 bit edition). Ex.
            /// Log2_32_Ceil(32) == 5, Log2_32_Ceil(1) == 0, Log2_32_Ceil(6) == 3</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Log2_32_Ceil - This function returns the ceil log base 2 of
            /// the specified</para>
            /// <para>/// value, 32 if the value is zero. (32 bit edition).</para>
            /// <para>/// Ex. Log2_32_Ceil(32) == 5, Log2_32_Ceil(1) == 0,
            /// Log2_32_Ceil(6) == 3</para>
            /// </remarks>
            public static uint Log2_32_Ceil(uint Value)
            {
                var arg0 = Value;
                var __ret = Internal.Log2_32_Ceil_0(arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Log2_64_Ceil - This function returns the ceil log base 2 of the
            /// specified value, 64 if the value is zero. (64 bit edition.)</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Log2_64_Ceil - This function returns the ceil log base 2 of
            /// the specified</para>
            /// <para>/// value, 64 if the value is zero. (64 bit edition.)</para>
            /// </remarks>
            public static uint Log2_64_Ceil(ulong Value)
            {
                var arg0 = Value;
                var __ret = Internal.Log2_64_Ceil_0(arg0);
                return __ret;
            }

            /// <summary>
            /// <para>GreatestCommonDivisor64 - Return the greatest common divisor of
            /// the two values using Euclid's algorithm.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// GreatestCommonDivisor64 - Return the greatest common divisor
            /// of the two</para>
            /// <para>/// values using Euclid's algorithm.</para>
            /// </remarks>
            public static ulong GreatestCommonDivisor64(ulong A, ulong B)
            {
                var arg0 = A;
                var arg1 = B;
                var __ret = Internal.GreatestCommonDivisor64_0(arg0, arg1);
                return __ret;
            }

            /// <summary>
            /// <para>BitsToDouble - This function takes a 64-bit integer and returns
            /// the bit equivalent double.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// BitsToDouble - This function takes a 64-bit integer and
            /// returns the bit</para>
            /// <para>/// equivalent double.</para>
            /// </remarks>
            public static double BitsToDouble(ulong Bits)
            {
                var arg0 = Bits;
                var __ret = Internal.BitsToDouble_0(arg0);
                return __ret;
            }

            /// <summary>
            /// <para>BitsToFloat - This function takes a 32-bit integer and returns
            /// the bit equivalent float.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// BitsToFloat - This function takes a 32-bit integer and
            /// returns the bit</para>
            /// <para>/// equivalent float.</para>
            /// </remarks>
            public static float BitsToFloat(uint Bits)
            {
                var arg0 = Bits;
                var __ret = Internal.BitsToFloat_0(arg0);
                return __ret;
            }

            /// <summary>
            /// <para>DoubleToBits - This function takes a double and returns the bit
            /// equivalent 64-bit integer. Note that copying doubles around changes the
            /// bits of NaNs on some hosts, notably x86, so this routine cannot be used if
            /// these bits are needed.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// DoubleToBits - This function takes a double and returns the
            /// bit</para>
            /// <para>/// equivalent 64-bit integer.  Note that copying doubles
            /// around</para>
            /// <para>/// changes the bits of NaNs on some hosts, notably x86, so
            /// this</para>
            /// <para>/// routine cannot be used if these bits are needed.</para>
            /// </remarks>
            public static ulong DoubleToBits(double Double)
            {
                var __ret = Internal.DoubleToBits_0(Double);
                return __ret;
            }

            /// <summary>
            /// <para>FloatToBits - This function takes a float and returns the bit
            /// equivalent 32-bit integer. Note that copying floats around changes the bits
            /// of NaNs on some hosts, notably x86, so this routine cannot be used if these
            /// bits are needed.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// FloatToBits - This function takes a float and returns the
            /// bit</para>
            /// <para>/// equivalent 32-bit integer.  Note that copying floats
            /// around</para>
            /// <para>/// changes the bits of NaNs on some hosts, notably x86, so
            /// this</para>
            /// <para>/// routine cannot be used if these bits are needed.</para>
            /// </remarks>
            public static uint FloatToBits(float Float)
            {
                var __ret = Internal.FloatToBits_0(Float);
                return __ret;
            }

            /// <summary>
            /// <para>Platform-independent wrappers for the C99 isnan()
            /// function.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Platform-independent wrappers for the C99 isnan()
            /// function.</para>
            /// </remarks>
            public static int IsNAN(float f)
            {
                var __ret = Internal.IsNAN_0(f);
                return __ret;
            }

            public static int IsNAN(double d)
            {
                var __ret = Internal.IsNAN_1(d);
                return __ret;
            }

            /// <summary>
            /// <para>Platform-independent wrappers for the C99 isinf()
            /// function.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Platform-independent wrappers for the C99 isinf()
            /// function.</para>
            /// </remarks>
            public static int IsInf(float f)
            {
                var __ret = Internal.IsInf_0(f);
                return __ret;
            }

            public static int IsInf(double d)
            {
                var __ret = Internal.IsInf_1(d);
                return __ret;
            }

            /// <summary>
            /// <para>MinAlign - A and B are either alignments or offsets. Return the
            /// minimum alignment that may be assumed after adding the two together.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// MinAlign - A and B are either alignments or offsets.  Return
            /// the minimum</para>
            /// <para>/// alignment that may be assumed after adding the two
            /// together.</para>
            /// </remarks>
            public static ulong MinAlign(ulong A, ulong B)
            {
                var arg0 = A;
                var arg1 = B;
                var __ret = Internal.MinAlign_0(arg0, arg1);
                return __ret;
            }

            /// <summary>
            /// <para>Aligns Addr to Alignment bytes, rounding up.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Aligns \c Addr to \c Alignment bytes, rounding
            /// up.</para>
            /// <para>///</para>
            /// <para>/// Alignment should be a power of two.  This method rounds up,
            /// so</para>
            /// <para>/// alignAddr(7, 4) == 8 and alignAddr(8, 4) == 8.</para>
            /// </remarks>
            public static ulong alignAddr(global::System.IntPtr Addr, ulong Alignment)
            {
                var arg0 = Addr;
                var arg1 = Alignment;
                var __ret = Internal.alignAddr_0(arg0, arg1);
                return __ret;
            }

            /// <summary>
            /// <para>Returns the necessary adjustment for aligning Ptr to Alignment
            /// bytes, rounding up.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Returns the necessary adjustment for aligning \c Ptr
            /// to \c Alignment</para>
            /// <para>/// bytes, rounding up.</para>
            /// </remarks>
            public static ulong alignmentAdjustment(global::System.IntPtr Ptr, ulong Alignment)
            {
                var arg0 = Ptr;
                var arg1 = Alignment;
                var __ret = Internal.alignmentAdjustment_0(arg0, arg1);
                return __ret;
            }

            /// <summary>
            /// <para>NextPowerOf2 - Returns the next power of two (in 64-bits) that is
            /// strictly greater than A. Returns zero on overflow.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// NextPowerOf2 - Returns the next power of two (in
            /// 64-bits)</para>
            /// <para>/// that is strictly greater than A.  Returns zero on
            /// overflow.</para>
            /// </remarks>
            public static ulong NextPowerOf2(ulong A)
            {
                var arg0 = A;
                var __ret = Internal.NextPowerOf2_0(arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Returns the power of two which is less than or equal to the given
            /// value. Essentially, it is a floor operation across the domain of powers of
            /// two.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Returns the power of two which is less than or equal to the
            /// given value.</para>
            /// <para>/// Essentially, it is a floor operation across the domain of
            /// powers of two.</para>
            /// </remarks>
            public static ulong PowerOf2Floor(ulong A)
            {
                var arg0 = A;
                var __ret = Internal.PowerOf2Floor_0(arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Returns the next integer (mod 2**64) that is greater than or
            /// equal to Value and is a multiple of Align. Align must be non-zero.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Returns the next integer (mod 2**64) that is greater than or
            /// equal to</para>
            /// <para>/// \p Value and is a multiple of \p Align. \p Align must be
            /// non-zero.</para>
            /// <para>///</para>
            /// <para>/// Examples:</para>
            /// <para>/// \code</para>
            /// <para>///   RoundUpToAlignment(5, 8) = 8</para>
            /// <para>///   RoundUpToAlignment(17, 8) = 24</para>
            /// <para>///   RoundUpToAlignment(~0LL, 8) = 0</para>
            /// <para>///   RoundUpToAlignment(321, 255) = 510</para>
            /// <para>/// \endcode</para>
            /// </remarks>
            public static ulong RoundUpToAlignment(ulong Value, ulong Align)
            {
                var arg0 = Value;
                var arg1 = Align;
                var __ret = Internal.RoundUpToAlignment_0(arg0, arg1);
                return __ret;
            }

            /// <summary>
            /// <para>Returns the offset to the next integer (mod 2**64) that is
            /// greater than or equal to Value and is a multiple of Align. Align must be
            /// non-zero.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Returns the offset to the next integer (mod 2**64) that is
            /// greater than</para>
            /// <para>/// or equal to \p Value and is a multiple of \p Align. \p Align
            /// must be</para>
            /// <para>/// non-zero.</para>
            /// </remarks>
            public static ulong OffsetToAlignment(ulong Value, ulong Align)
            {
                var arg0 = Value;
                var arg1 = Align;
                var __ret = Internal.OffsetToAlignment_0(arg0, arg1);
                return __ret;
            }

            /// <summary>
            /// <para>abs64 - absolute value of a 64-bit int. Not all environments
            /// support &quot;abs&quot; on whatever their name for the 64-bit int type is.
            /// The absolute value of the largest negative number is undefined, as with
            /// &quot;abs&quot;.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// abs64 - absolute value of a 64-bit int.  Not all environments
            /// support</para>
            /// <para>/// &quot;abs&quot; on whatever their name for the 64-bit int
            /// type is.  The absolute</para>
            /// <para>/// value of the largest negative number is undefined, as with
            /// &quot;abs&quot;.</para>
            /// </remarks>
            public static long abs64(long x)
            {
                var arg0 = x;
                var __ret = Internal.abs64_0(arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Sign extend number in the bottom B bits of X to a 32-bit int.
            /// Requires 0 &lt; B &lt;= 32.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Sign extend number in the bottom B bits of X to a
            /// 32-bit int.</para>
            /// <para>/// Requires 0 &lt; B &lt;= 32.</para>
            /// </remarks>
            public static int SignExtend32(uint X, uint B)
            {
                var arg0 = X;
                var __ret = Internal.SignExtend32_0(arg0, B);
                return __ret;
            }

            /// <summary>
            /// <para>Sign extend number in the bottom B bits of X to a 64-bit int.
            /// Requires 0 &lt; B &lt;= 64.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Sign extend number in the bottom B bits of X to a
            /// 64-bit int.</para>
            /// <para>/// Requires 0 &lt; B &lt;= 64.</para>
            /// </remarks>
            public static long SignExtend64(ulong X, uint B)
            {
                var arg0 = X;
                var __ret = Internal.SignExtend64_0(arg0, B);
                return __ret;
            }
        }

        namespace detail
        {
            public unsafe static partial class TrailingZerosCounter
            {
                [StructLayout(LayoutKind.Explicit, Size = 0)]
                public partial struct Internal
                {
                }
            }

            public unsafe static partial class LeadingZerosCounter
            {
                [StructLayout(LayoutKind.Explicit, Size = 0)]
                public partial struct Internal
                {
                }
            }

            public unsafe static partial class PopulationCounter
            {
                [StructLayout(LayoutKind.Explicit, Size = 0)]
                public partial struct Internal
                {
                }
            }
        }
    }
}
