//----------------------------------------------------------------------------
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
//----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace CppSharp
{
    namespace clang
    {
        /// <summary>
        /// <para>An adjustment to be made to the temporary created when emitting a
        /// reference binding, which accesses a particular subobject of that
        /// temporary.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief An adjustment to be made to the temporary created when
        /// emitting a</para>
        /// <para>/// reference binding, which accesses a particular subobject of
        /// that temporary.</para>
        /// </remarks>
        public unsafe partial class SubobjectAdjustment : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 24)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public clang.SubobjectAdjustment._0 Kind;

                [FieldOffset(8)]
                internal clang.SubobjectAdjustment._.Internal __;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang19SubobjectAdjustmentC2EPNS_9FieldDeclE")]
                internal static extern void ctor_1(global::System.IntPtr instance, global::System.IntPtr Field);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang19SubobjectAdjustmentC2EPKNS_17MemberPointerTypeEPNS_4ExprE")]
                internal static extern void ctor_2(global::System.IntPtr instance, global::System.IntPtr MPT, global::System.IntPtr RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang19SubobjectAdjustmentC2ERKS0_")]
                internal static extern void cctor_3(global::System.IntPtr instance, global::System.IntPtr _0);
            }

            public enum _0 : uint
            {
                DerivedToBaseAdjustment = 0,
                FieldAdjustment = 1,
                MemberPointerAdjustment = 2
            }

            public unsafe partial class DTB : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 16)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public global::System.IntPtr BasePath;

                    [FieldOffset(8)]
                    public global::System.IntPtr DerivedClass;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang19SubobjectAdjustment3DTBC2ERKS1_")]
                    internal static extern void cctor_0(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, DTB> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, DTB>();

                private readonly bool __ownsNativeInstance;

                public static DTB __CreateInstance(global::System.IntPtr native)
                {
                    return new DTB((DTB.Internal*) native);
                }

                public static DTB __CreateInstance(DTB.Internal native)
                {
                    return new DTB(native);
                }

                private static DTB.Internal* __CopyValue(DTB.Internal native)
                {
                    var ret = (DTB.Internal*) Marshal.AllocHGlobal(16);
                    *ret = native;
                    return ret;
                }

                private DTB(DTB.Internal native)
                    : this(__CopyValue(native))
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected DTB(DTB.Internal* native, bool isInternalImpl = false)
                {
                    __Instance = new global::System.IntPtr(native);
                }

                public DTB()
                {
                    __Instance = Marshal.AllocHGlobal(16);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    DestroyNativeInstance(false);
                }

                public virtual void DestroyNativeInstance()
                {
                    DestroyNativeInstance(true);
                }

                private void DestroyNativeInstance(bool force)
                {
                    clang.SubobjectAdjustment.DTB __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public clang.CastExpr BasePath
                {
                    get
                    {
                        clang.CastExpr __result0;
                        if (((Internal*) __Instance)->BasePath == IntPtr.Zero) __result0 = null;
                        else if (clang.CastExpr.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->BasePath))
                            __result0 = (clang.CastExpr) clang.CastExpr.NativeToManagedMap[((Internal*) __Instance)->BasePath];
                        else __result0 = clang.CastExpr.__CreateInstance(((Internal*) __Instance)->BasePath);
                        return __result0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->BasePath = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }
            }

            public unsafe partial class P : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 16)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public global::System.IntPtr MPT;

                    [FieldOffset(8)]
                    public global::System.IntPtr RHS;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang19SubobjectAdjustment1PC2ERKS1_")]
                    internal static extern void cctor_0(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, P> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, P>();

                private readonly bool __ownsNativeInstance;

                public static P __CreateInstance(global::System.IntPtr native)
                {
                    return new P((P.Internal*) native);
                }

                public static P __CreateInstance(P.Internal native)
                {
                    return new P(native);
                }

                private static P.Internal* __CopyValue(P.Internal native)
                {
                    var ret = (P.Internal*) Marshal.AllocHGlobal(16);
                    *ret = native;
                    return ret;
                }

                private P(P.Internal native)
                    : this(__CopyValue(native))
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected P(P.Internal* native, bool isInternalImpl = false)
                {
                    __Instance = new global::System.IntPtr(native);
                }

                public P()
                {
                    __Instance = Marshal.AllocHGlobal(16);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    DestroyNativeInstance(false);
                }

                public virtual void DestroyNativeInstance()
                {
                    DestroyNativeInstance(true);
                }

                private void DestroyNativeInstance(bool force)
                {
                    clang.SubobjectAdjustment.P __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public clang.MemberPointerType MPT
                {
                    get
                    {
                        clang.MemberPointerType __result0;
                        if (((Internal*) __Instance)->MPT == IntPtr.Zero) __result0 = null;
                        else if (clang.MemberPointerType.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->MPT))
                            __result0 = (clang.MemberPointerType) clang.MemberPointerType.NativeToManagedMap[((Internal*) __Instance)->MPT];
                        else __result0 = clang.MemberPointerType.__CreateInstance(((Internal*) __Instance)->MPT);
                        return __result0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->MPT = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public clang.Expr RHS
                {
                    get
                    {
                        clang.Expr __result0;
                        if (((Internal*) __Instance)->RHS == IntPtr.Zero) __result0 = null;
                        else if (clang.Expr.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->RHS))
                            __result0 = (clang.Expr) clang.Expr.NativeToManagedMap[((Internal*) __Instance)->RHS];
                        else __result0 = clang.Expr.__CreateInstance(((Internal*) __Instance)->RHS);
                        return __result0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->RHS = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }
            }

            public unsafe partial struct _
            {
                [StructLayout(LayoutKind.Explicit, Size = 16)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public clang.SubobjectAdjustment.DTB.Internal DerivedToBase;

                    [FieldOffset(0)]
                    public global::System.IntPtr Field;

                    [FieldOffset(0)]
                    public clang.SubobjectAdjustment.P.Internal Ptr;
                }
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, SubobjectAdjustment> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, SubobjectAdjustment>();

            private readonly bool __ownsNativeInstance;

            public static SubobjectAdjustment __CreateInstance(global::System.IntPtr native)
            {
                return new SubobjectAdjustment((SubobjectAdjustment.Internal*) native);
            }

            public static SubobjectAdjustment __CreateInstance(SubobjectAdjustment.Internal native)
            {
                return new SubobjectAdjustment(native);
            }

            private static SubobjectAdjustment.Internal* __CopyValue(SubobjectAdjustment.Internal native)
            {
                var ret = (SubobjectAdjustment.Internal*) Marshal.AllocHGlobal(24);
                *ret = native;
                return ret;
            }

            private SubobjectAdjustment(SubobjectAdjustment.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected SubobjectAdjustment(SubobjectAdjustment.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public SubobjectAdjustment(clang.FieldDecl Field)
            {
                __Instance = Marshal.AllocHGlobal(24);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(Field, null) ? global::System.IntPtr.Zero : Field.__Instance;
                Internal.ctor_1(__Instance, arg0);
            }

            public SubobjectAdjustment(clang.MemberPointerType MPT, clang.Expr RHS)
            {
                __Instance = Marshal.AllocHGlobal(24);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(MPT, null) ? global::System.IntPtr.Zero : MPT.__Instance;
                var arg1 = ReferenceEquals(RHS, null) ? global::System.IntPtr.Zero : RHS.__Instance;
                Internal.ctor_2(__Instance, arg0, arg1);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.SubobjectAdjustment __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.SubobjectAdjustment._0 Kind
            {
                get
                {
                    return ((Internal*) __Instance)->Kind;
                }

                set
                {
                    ((Internal*) __Instance)->Kind = value;
                }
            }
        }

        /// <summary>
        /// <para>Expr - This represents one expression. Note that Expr's are
        /// subclasses of Stmt. This allows an expression to be transparently used any
        /// place a Stmt is required.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// Expr - This represents one expression.  Note that Expr's are
        /// subclasses of</para>
        /// <para>/// Stmt.  This allows an expression to be transparently used any
        /// place a Stmt</para>
        /// <para>/// is required.</para>
        /// <para>///</para>
        /// </remarks>
        public unsafe partial class Expr : clang.Stmt, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                internal clang.Stmt._.Internal __;

                [FieldOffset(8)]
                public clang.QualType.Internal TR;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang4ExprC2ENS_4Stmt9StmtClassENS_8QualTypeENS_13ExprValueKindENS_14ExprObjectKindEbbbb")]
                internal static extern void ctor_0(global::System.IntPtr instance, clang.Stmt.StmtClass SC, clang.QualType.Internal T, clang.ExprValueKind VK, clang.ExprObjectKind OK, bool TD, bool VD, bool ID, bool ContainsUnexpandedParameterPack);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang4ExprC2ENS_4Stmt9StmtClassENS1_10EmptyShellE")]
                internal static extern void ctor_1(global::System.IntPtr instance, clang.Stmt.StmtClass SC, clang.Stmt.EmptyShell.Internal _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang4ExprC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Expr7getTypeEv")]
                internal static extern clang.QualType.Internal getType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang4Expr7setTypeENS_8QualTypeE")]
                internal static extern void setType_0(global::System.IntPtr instance, clang.QualType.Internal t);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Expr16isValueDependentEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isValueDependent_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang4Expr17setValueDependentEb")]
                internal static extern void setValueDependent_0(global::System.IntPtr instance, bool VD);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Expr15isTypeDependentEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isTypeDependent_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang4Expr16setTypeDependentEb")]
                internal static extern void setTypeDependent_0(global::System.IntPtr instance, bool TD);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Expr24isInstantiationDependentEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isInstantiationDependent_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang4Expr25setInstantiationDependentEb")]
                internal static extern void setInstantiationDependent_0(global::System.IntPtr instance, bool ID);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Expr31containsUnexpandedParameterPackEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool containsUnexpandedParameterPack_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang4Expr34setContainsUnexpandedParameterPackEb")]
                internal static extern void setContainsUnexpandedParameterPack_0(global::System.IntPtr instance, bool PP);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Expr10getExprLocEv")]
                internal static extern clang.SourceLocation.Internal getExprLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Expr8isLValueEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isLValue_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Expr8isRValueEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isRValue_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Expr8isXValueEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isXValue_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Expr9isGLValueEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isGLValue_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang4Expr19getValueKindForTypeENS_8QualTypeE")]
                internal static extern clang.ExprValueKind getValueKindForType_0(clang.QualType.Internal T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Expr12getValueKindEv")]
                internal static extern clang.ExprValueKind getValueKind_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Expr13getObjectKindEv")]
                internal static extern clang.ExprObjectKind getObjectKind_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Expr26isOrdinaryOrBitFieldObjectEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isOrdinaryOrBitFieldObject_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang4Expr12setValueKindENS_13ExprValueKindE")]
                internal static extern void setValueKind_0(global::System.IntPtr instance, clang.ExprValueKind Cat);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang4Expr13setObjectKindENS_14ExprObjectKindE")]
                internal static extern void setObjectKind_0(global::System.IntPtr instance, clang.ExprObjectKind Cat);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Expr16refersToBitFieldEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool refersToBitField_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang4Expr17getSourceBitFieldEv")]
                internal static extern global::System.IntPtr getSourceBitField_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Expr14isObjCSelfExprEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isObjCSelfExpr_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Expr21refersToVectorElementEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool refersToVectorElement_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Expr18hasPlaceholderTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasPlaceholderType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Expr18hasPlaceholderTypeENS_11BuiltinType4KindE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasPlaceholderType_1(global::System.IntPtr instance, clang.BuiltinType.Kind K);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Expr25isKnownToHaveBooleanValueEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isKnownToHaveBooleanValue_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang4Expr19findBoundMemberTypeEPKS0_")]
                internal static extern clang.QualType.Internal findBoundMemberType_0(global::System.IntPtr expr);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang4Expr14IgnoreImpCastsEv")]
                internal static extern global::System.IntPtr IgnoreImpCasts_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang4Expr14IgnoreImplicitEv")]
                internal static extern global::System.IntPtr IgnoreImplicit_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang4Expr12IgnoreParensEv")]
                internal static extern global::System.IntPtr IgnoreParens_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang4Expr16IgnoreParenCastsEv")]
                internal static extern global::System.IntPtr IgnoreParenCasts_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang4Expr11IgnoreCastsEv")]
                internal static extern global::System.IntPtr IgnoreCasts_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang4Expr19IgnoreParenImpCastsEv")]
                internal static extern global::System.IntPtr IgnoreParenImpCasts_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang4Expr24IgnoreConversionOperatorEv")]
                internal static extern global::System.IntPtr IgnoreConversionOperator_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang4Expr22IgnoreParenLValueCastsEv")]
                internal static extern global::System.IntPtr IgnoreParenLValueCasts_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang4Expr20ignoreParenBaseCastsEv")]
                internal static extern global::System.IntPtr ignoreParenBaseCasts_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Expr17isDefaultArgumentEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isDefaultArgument_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Expr17isImplicitCXXThisEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isImplicitCXXThis_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang4Expr7classofEPKNS_4StmtE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);
            }

            public enum LValueClassification : uint
            {
                LV_Valid = 0,
                LV_NotObjectType = 1,
                LV_IncompleteVoidType = 2,
                LV_DuplicateVectorComponents = 3,
                LV_InvalidExpression = 4,
                LV_InvalidMessageExpression = 5,
                LV_MemberFunction = 6,
                LV_SubObjCPropertySetting = 7,
                LV_ClassTemporary = 8,
                LV_ArrayTemporary = 9
            }

            public enum isModifiableLvalueResult : uint
            {
                MLV_Valid = 0,
                MLV_NotObjectType = 1,
                MLV_IncompleteVoidType = 2,
                MLV_DuplicateVectorComponents = 3,
                MLV_InvalidExpression = 4,
                MLV_LValueCast = 5,
                MLV_IncompleteType = 6,
                MLV_ConstQualified = 7,
                MLV_ArrayType = 8,
                MLV_NoSetterProperty = 9,
                MLV_MemberFunction = 10,
                MLV_SubObjCPropertySetting = 11,
                MLV_InvalidMessageExpression = 12,
                MLV_ClassTemporary = 13,
                MLV_ArrayTemporary = 14
            }

            public enum SideEffectsKind : uint
            {
                SE_NoSideEffects = 0,
                SE_AllowSideEffects = 1
            }

            /// <summary>
            /// <para>Enumeration used to describe the kind of Null pointer constant
            /// returned from isNullPointerConstant().</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Enumeration used to describe the kind of Null pointer
            /// constant</para>
            /// <para>  /// returned from \c isNullPointerConstant().</para>
            /// </remarks>
            public enum NullPointerConstantKind : uint
            {
                /// <summary>Expression is not a Null pointer constant.</summary>
                NPCK_NotNull = 0,
                /// <summary>Expression is a Null pointer constant built from a zero integer expression that is not a simple, possibly parenthesized, zero literal. C++ Core Issue 903 will classify these expressions as "not pointers" once it is adopted. http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#903</summary>
                NPCK_ZeroExpression = 1,
                /// <summary>Expression is a Null pointer constant built from a literal zero.</summary>
                NPCK_ZeroLiteral = 2,
                /// <summary>Expression is a C++11 nullptr.</summary>
                NPCK_CXX11_nullptr = 3,
                /// <summary>Expression is a GNU-style __null constant.</summary>
                NPCK_GNUNull = 4
            }

            /// <summary>
            /// <para>Enumeration used to describe how isNullPointerConstant() should
            /// cope with value-dependent expressions.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Enumeration used to describe how \c
            /// isNullPointerConstant()</para>
            /// <para>  /// should cope with value-dependent expressions.</para>
            /// </remarks>
            public enum NullPointerConstantValueDependence : uint
            {
                /// <summary>Specifies that the expression should never be value-dependent.</summary>
                NPC_NeverValueDependent = 0,
                /// <summary>Specifies that a value-dependent expression of integral or dependent type should be considered a null pointer constant.</summary>
                NPC_ValueDependentIsNull = 1,
                /// <summary>Specifies that a value-dependent expression should be considered to never be a null pointer constant.</summary>
                NPC_ValueDependentIsNotNull = 2
            }

            /// <summary>
            /// <para>The return type of classify(). Represents the C++11 expression
            /// taxonomy.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief The return type of classify(). Represents the C++11
            /// expression</para>
            /// <para>  ///        taxonomy.</para>
            /// </remarks>
            public unsafe partial class Classification : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 4)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public ushort Kind;

                    [FieldOffset(2)]
                    public ushort Modifiable;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang4Expr14ClassificationC2Ev")]
                    internal static extern void ctor_1(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang4Expr14ClassificationC2ERKS1_")]
                    internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang4Expr14Classification7getKindEv")]
                    internal static extern clang.Expr.Classification.Kinds getKind_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang4Expr14Classification13getModifiableEv")]
                    internal static extern clang.Expr.Classification.ModifiableType getModifiable_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang4Expr14Classification8isLValueEv")]
                    [return: MarshalAsAttribute(UnmanagedType.I1)]
                    internal static extern bool isLValue_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang4Expr14Classification8isXValueEv")]
                    [return: MarshalAsAttribute(UnmanagedType.I1)]
                    internal static extern bool isXValue_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang4Expr14Classification9isGLValueEv")]
                    [return: MarshalAsAttribute(UnmanagedType.I1)]
                    internal static extern bool isGLValue_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang4Expr14Classification9isPRValueEv")]
                    [return: MarshalAsAttribute(UnmanagedType.I1)]
                    internal static extern bool isPRValue_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang4Expr14Classification8isRValueEv")]
                    [return: MarshalAsAttribute(UnmanagedType.I1)]
                    internal static extern bool isRValue_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang4Expr14Classification12isModifiableEv")]
                    [return: MarshalAsAttribute(UnmanagedType.I1)]
                    internal static extern bool isModifiable_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang4Expr14Classification16makeSimpleLValueEv")]
                    internal static extern clang.Expr.Classification.Internal makeSimpleLValue_0();
                }

                /// <summary>
                /// <para>The various classification results. Most of these mean
                /// prvalue.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief The various classification results. Most of these mean
                /// prvalue.</para>
                /// </remarks>
                public enum Kinds : uint
                {
                    CL_LValue = 0,
                    CL_XValue = 1,
                    CL_Function = 2,
                    CL_Void = 3,
                    CL_AddressableVoid = 4,
                    CL_DuplicateVectorComponents = 5,
                    CL_MemberFunction = 6,
                    CL_SubObjCPropertySetting = 7,
                    CL_ClassTemporary = 8,
                    CL_ArrayTemporary = 9,
                    CL_ObjCMessageRValue = 10,
                    CL_PRValue = 11
                }

                /// <summary>
                /// <para>The results of modification testing.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief The results of modification testing.</para>
                /// </remarks>
                public enum ModifiableType : uint
                {
                    CM_Untested = 0,
                    CM_Modifiable = 1,
                    CM_RValue = 2,
                    CM_Function = 3,
                    CM_LValueCast = 4,
                    CM_NoSetterProperty = 5,
                    CM_ConstQualified = 6,
                    CM_ArrayType = 7,
                    CM_IncompleteType = 8
                }

                public global::System.IntPtr __Instance { get; protected set; }
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, Classification> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, Classification>();

                private readonly bool __ownsNativeInstance;

                public static Classification __CreateInstance(global::System.IntPtr native)
                {
                    return new Classification((Classification.Internal*) native);
                }

                public static Classification __CreateInstance(Classification.Internal native)
                {
                    return new Classification(native);
                }

                private static Classification.Internal* __CopyValue(Classification.Internal native)
                {
                    var ret = (Classification.Internal*) Marshal.AllocHGlobal(4);
                    *ret = native;
                    return ret;
                }

                private Classification(Classification.Internal native)
                    : this(__CopyValue(native))
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected Classification(Classification.Internal* native, bool isInternalImpl = false)
                {
                    __Instance = new global::System.IntPtr(native);
                }

                public Classification()
                {
                    __Instance = Marshal.AllocHGlobal(4);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_1(__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    DestroyNativeInstance(false);
                }

                public virtual void DestroyNativeInstance()
                {
                    DestroyNativeInstance(true);
                }

                private void DestroyNativeInstance(bool force)
                {
                    clang.Expr.Classification __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public clang.Expr.Classification.Kinds getKind()
                {
                    var __ret = Internal.getKind_0(__Instance);
                    return __ret;
                }

                public clang.Expr.Classification.ModifiableType getModifiable()
                {
                    var __ret = Internal.getModifiable_0(__Instance);
                    return __ret;
                }

                public bool isLValue()
                {
                    var __ret = Internal.isLValue_0(__Instance);
                    return __ret;
                }

                public bool isXValue()
                {
                    var __ret = Internal.isXValue_0(__Instance);
                    return __ret;
                }

                public bool isGLValue()
                {
                    var __ret = Internal.isGLValue_0(__Instance);
                    return __ret;
                }

                public bool isPRValue()
                {
                    var __ret = Internal.isPRValue_0(__Instance);
                    return __ret;
                }

                public bool isRValue()
                {
                    var __ret = Internal.isRValue_0(__Instance);
                    return __ret;
                }

                public bool isModifiable()
                {
                    var __ret = Internal.isModifiable_0(__Instance);
                    return __ret;
                }

                /// <summary>
                /// <para>Create a simple, modifiably lvalue</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Create a simple, modifiably lvalue</para>
                /// </remarks>
                public static clang.Expr.Classification makeSimpleLValue()
                {
                    var __ret = Internal.makeSimpleLValue_0();
                    return clang.Expr.Classification.__CreateInstance(__ret);
                }
            }

            /// <summary>
            /// <para>EvalStatus is a struct with detailed info about an evaluation in
            /// progress.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// EvalStatus is a struct with detailed info about an evaluation
            /// in progress.</para>
            /// </remarks>
            public unsafe partial class EvalStatus : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 16)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public bool HasSideEffects;

                    [FieldOffset(8)]
                    public global::System.IntPtr Diag;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang4Expr10EvalStatusC2Ev")]
                    internal static extern void ctor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang4Expr10EvalStatusC2ERKS1_")]
                    internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang4Expr10EvalStatus14hasSideEffectsEv")]
                    [return: MarshalAsAttribute(UnmanagedType.I1)]
                    internal static extern bool hasSideEffects_0(global::System.IntPtr instance);
                }

                public global::System.IntPtr __Instance { get; protected set; }
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, EvalStatus> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, EvalStatus>();

                private readonly bool __ownsNativeInstance;

                public static EvalStatus __CreateInstance(global::System.IntPtr native)
                {
                    return new EvalStatus((EvalStatus.Internal*) native);
                }

                public static EvalStatus __CreateInstance(EvalStatus.Internal native)
                {
                    return new EvalStatus(native);
                }

                private static EvalStatus.Internal* __CopyValue(EvalStatus.Internal native)
                {
                    var ret = (EvalStatus.Internal*) Marshal.AllocHGlobal(16);
                    *ret = native;
                    return ret;
                }

                private EvalStatus(EvalStatus.Internal native)
                    : this(__CopyValue(native))
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected EvalStatus(EvalStatus.Internal* native, bool isInternalImpl = false)
                {
                    __Instance = new global::System.IntPtr(native);
                }

                public EvalStatus()
                {
                    __Instance = Marshal.AllocHGlobal(16);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_0(__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    DestroyNativeInstance(false);
                }

                public virtual void DestroyNativeInstance()
                {
                    DestroyNativeInstance(true);
                }

                private void DestroyNativeInstance(bool force)
                {
                    clang.Expr.EvalStatus __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public bool hasSideEffects()
                {
                    var __ret = Internal.hasSideEffects_0(__Instance);
                    return __ret;
                }

                public bool HasSideEffects
                {
                    get
                    {
                        return ((Internal*) __Instance)->HasSideEffects;
                    }

                    set
                    {
                        ((Internal*) __Instance)->HasSideEffects = value;
                    }
                }
            }

            /// <summary>
            /// <para>EvalResult is a struct with detailed info about an evaluated
            /// expression.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// EvalResult is a struct with detailed info about an evaluated
            /// expression.</para>
            /// </remarks>
            public unsafe partial class EvalResult : clang.Expr.EvalStatus, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 72)]
                public new partial struct Internal
                {
                    [FieldOffset(0)]
                    public bool HasSideEffects;

                    [FieldOffset(8)]
                    public global::System.IntPtr Diag;

                    [FieldOffset(16)]
                    public clang.APValue.Internal Val;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang4Expr10EvalResultC2Ev")]
                    internal static extern void ctor_1(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang4Expr10EvalResultC2ERKS1_")]
                    internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang4Expr10EvalResultD2Ev")]
                    internal static extern void dtor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang4Expr10EvalResult14isGlobalLValueEv")]
                    [return: MarshalAsAttribute(UnmanagedType.I1)]
                    internal static extern bool isGlobalLValue_0(global::System.IntPtr instance);
                }

                private readonly bool __ownsNativeInstance;

                public static new EvalResult __CreateInstance(global::System.IntPtr native)
                {
                    return new EvalResult((EvalResult.Internal*) native);
                }

                public static EvalResult __CreateInstance(EvalResult.Internal native)
                {
                    return new EvalResult(native);
                }

                private static EvalResult.Internal* __CopyValue(EvalResult.Internal native)
                {
                    var ret = (EvalResult.Internal*) Marshal.AllocHGlobal(72);
                    *ret = native;
                    return ret;
                }

                private EvalResult(EvalResult.Internal native)
                    : this(__CopyValue(native))
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected EvalResult(EvalResult.Internal* native, bool isInternalImpl = false)
                    : base((clang.Expr.EvalStatus.Internal*) native)
                {
                }

                public EvalResult()
                    : this((Internal*) null)
                {
                    __Instance = Marshal.AllocHGlobal(72);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_1(__Instance);
                }

                protected override void Dispose(bool disposing)
                {
                    DestroyNativeInstance(false);
                    base.Dispose(disposing);
                }

                public override void DestroyNativeInstance()
                {
                    DestroyNativeInstance(true);
                }

                private void DestroyNativeInstance(bool force)
                {
                    clang.Expr.EvalStatus __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public bool isGlobalLValue()
                {
                    var __ret = Internal.isGlobalLValue_0(__Instance);
                    return __ret;
                }

                public clang.APValue Val
                {
                    get
                    {
                        return clang.APValue.__CreateInstance(((Internal*) __Instance)->Val);
                    }

                    set
                    {
                        ((Internal*) __Instance)->Val = ReferenceEquals(value, null) ? new clang.APValue.Internal() : *(clang.APValue.Internal*) (value.__Instance);
                    }
                }
            }

            private readonly bool __ownsNativeInstance;

            public static new Expr __CreateInstance(global::System.IntPtr native)
            {
                return new Expr((Expr.Internal*) native);
            }

            public static Expr __CreateInstance(Expr.Internal native)
            {
                return new Expr(native);
            }

            private static Expr.Internal* __CopyValue(Expr.Internal native)
            {
                var ret = (Expr.Internal*) Marshal.AllocHGlobal(16);
                *ret = native;
                return ret;
            }

            private Expr(Expr.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected Expr(Expr.Internal* native, bool isInternalImpl = false)
                : base((clang.Stmt.Internal*) native)
            {
            }

            protected Expr(clang.Stmt.StmtClass SC, clang.QualType T, clang.ExprValueKind VK, clang.ExprObjectKind OK, bool TD, bool VD, bool ID, bool ContainsUnexpandedParameterPack)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(16);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = SC;
                var arg1 = ReferenceEquals(T, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (T.__Instance);
                var arg2 = VK;
                var arg3 = OK;
                Internal.ctor_0(__Instance, arg0, arg1, arg2, arg3, TD, VD, ID, ContainsUnexpandedParameterPack);
            }

            /// <summary>
            /// <para>Construct an empty expression.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Construct an empty expression.</para>
            /// </remarks>
            protected Expr(clang.Stmt.StmtClass SC, clang.Stmt.EmptyShell _0)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(16);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = SC;
                var arg1 = ReferenceEquals(_0, null) ? new clang.Stmt.EmptyShell.Internal() : *(clang.Stmt.EmptyShell.Internal*) (_0.__Instance);
                Internal.ctor_1(__Instance, arg0, arg1);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Stmt __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.QualType getType()
            {
                var __ret = Internal.getType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            public void setType(clang.QualType t)
            {
                var arg0 = ReferenceEquals(t, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (t.__Instance);
                Internal.setType_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>isValueDependent - Determines whether this expression is
            /// value-dependent (C++ [temp.dep.constexpr]). For example, the array bound of
            /// &quot;Chars&quot; in the following example is value-dependent.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// isValueDependent - Determines whether this expression
            /// is</para>
            /// <para>  /// value-dependent (C++ [temp.dep.constexpr]). For example,
            /// the</para>
            /// <para>  /// array bound of &quot;Chars&quot; in the following example
            /// is</para>
            /// <para>  /// value-dependent.</para>
            /// <para>  /// @code</para>
            /// <para>  /// template&lt;int Size, char (&amp;Chars)[Size]&gt; struct
            /// meta_string;</para>
            /// <para>  /// @endcode</para>
            /// </remarks>
            public bool isValueDependent()
            {
                var __ret = Internal.isValueDependent_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Set whether this expression is value-dependent or not.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Set whether this expression is value-dependent or
            /// not.</para>
            /// </remarks>
            public void setValueDependent(bool VD)
            {
                Internal.setValueDependent_0(__Instance, VD);
            }

            /// <summary>
            /// <para>isTypeDependent - Determines whether this expression is
            /// type-dependent (C++ [temp.dep.expr]), which means that its type could
            /// change from one template instantiation to the next. For example, the
            /// expressions &quot;x&quot; and &quot;x + y&quot; are type-dependent in the
            /// following code, but &quot;y&quot; is not type-dependent:</para>
            /// </summary>
            /// <remarks>
            /// <para>/// isTypeDependent - Determines whether this expression
            /// is</para>
            /// <para>  /// type-dependent (C++ [temp.dep.expr]), which means that its
            /// type</para>
            /// <para>  /// could change from one template instantiation to the next.
            /// For</para>
            /// <para>  /// example, the expressions &quot;x&quot; and &quot;x +
            /// y&quot; are type-dependent in</para>
            /// <para>  /// the following code, but &quot;y&quot; is not
            /// type-dependent:</para>
            /// <para>  /// @code</para>
            /// <para>  /// template&lt;typename T&gt;</para>
            /// <para>  /// void add(T x, int y) {</para>
            /// <para>  ///   x + y;</para>
            /// <para>  /// }</para>
            /// <para>  /// @endcode</para>
            /// </remarks>
            public bool isTypeDependent()
            {
                var __ret = Internal.isTypeDependent_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Set whether this expression is type-dependent or not.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Set whether this expression is type-dependent or
            /// not.</para>
            /// </remarks>
            public void setTypeDependent(bool TD)
            {
                Internal.setTypeDependent_0(__Instance, TD);
            }

            /// <summary>
            /// <para>Whether this expression is instantiation-dependent, meaning that
            /// it depends in some way on a template parameter, even if neither its type
            /// nor (constant) value can change due to the template instantiation.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Whether this expression is instantiation-dependent,
            /// meaning that</para>
            /// <para>  /// it depends in some way on a template parameter, even if
            /// neither its type</para>
            /// <para>  /// nor (constant) value can change due to the template
            /// instantiation.</para>
            /// <para>  ///</para>
            /// <para>  /// In the following example, the expression \c
            /// sizeof(sizeof(T() + T())) is</para>
            /// <para>  /// instantiation-dependent (since it involves a template
            /// parameter \c T), but</para>
            /// <para>  /// is neither type- nor value-dependent, since the type of the
            /// inner</para>
            /// <para>  /// \c sizeof is known (\c std::size_t) and therefore the size
            /// of the outer</para>
            /// <para>  /// \c sizeof is known.</para>
            /// <para>  ///</para>
            /// <para>  /// \code</para>
            /// <para>  /// template&lt;typename T&gt;</para>
            /// <para>  /// void f(T x, T y) {</para>
            /// <para>  ///   sizeof(sizeof(T() + T());</para>
            /// <para>  /// }</para>
            /// <para>  /// \endcode</para>
            /// <para>  ///</para>
            /// </remarks>
            public bool isInstantiationDependent()
            {
                var __ret = Internal.isInstantiationDependent_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Set whether this expression is instantiation-dependent or
            /// not.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Set whether this expression is instantiation-dependent
            /// or not.</para>
            /// </remarks>
            public void setInstantiationDependent(bool ID)
            {
                Internal.setInstantiationDependent_0(__Instance, ID);
            }

            /// <summary>
            /// <para>Whether this expression contains an unexpanded parameter pack
            /// (for C++11 variadic templates).</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Whether this expression contains an unexpanded
            /// parameter</para>
            /// <para>  /// pack (for C++11 variadic templates).</para>
            /// <para>  ///</para>
            /// <para>  /// Given the following function template:</para>
            /// <para>  ///</para>
            /// <para>  /// \code</para>
            /// <para>  /// template&lt;typename F, typename ...Types&gt;</para>
            /// <para>  /// void forward(const F &amp;f, Types &amp;&amp;...args)
            /// {</para>
            /// <para>  ///   f(static_cast&lt;Types&amp;&amp;&gt;(args)...);</para>
            /// <para>  /// }</para>
            /// <para>  /// \endcode</para>
            /// <para>  ///</para>
            /// <para>  /// The expressions \c args and \c
            /// static_cast&lt;Types&amp;&amp;&gt;(args) both</para>
            /// <para>  /// contain parameter packs.</para>
            /// </remarks>
            public bool containsUnexpandedParameterPack()
            {
                var __ret = Internal.containsUnexpandedParameterPack_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Set the bit that describes whether this expression contains an
            /// unexpanded parameter pack.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Set the bit that describes whether this
            /// expression</para>
            /// <para>  /// contains an unexpanded parameter pack.</para>
            /// </remarks>
            public void setContainsUnexpandedParameterPack(bool PP)
            {
                Internal.setContainsUnexpandedParameterPack_0(__Instance, PP);
            }

            /// <summary>
            /// <para>getExprLoc - Return the preferred location for the arrow when
            /// diagnosing a problem with a generic expression.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getExprLoc - Return the preferred location for the arrow when
            /// diagnosing</para>
            /// <para>  /// a problem with a generic expression.</para>
            /// </remarks>
            public clang.SourceLocation getExprLoc()
            {
                var __ret = Internal.getExprLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>isLValue - True if this expression is an &quot;l-value&quot;
            /// according to the rules of the current language. C and C++ give somewhat
            /// different rules for this concept, but in general, the result of an l-value
            /// expression identifies a specific object whereas the result of an r-value
            /// expression is a value detached from any specific storage.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// isLValue - True if this expression is an &quot;l-value&quot;
            /// according to</para>
            /// <para>  /// the rules of the current language.  C and C++ give
            /// somewhat</para>
            /// <para>  /// different rules for this concept, but in general, the
            /// result of</para>
            /// <para>  /// an l-value expression identifies a specific object whereas
            /// the</para>
            /// <para>  /// result of an r-value expression is a value detached from
            /// any</para>
            /// <para>  /// specific storage.</para>
            /// <para>  ///</para>
            /// <para>  /// C++11 divides the concept of &quot;r-value&quot; into pure
            /// r-values</para>
            /// <para>  /// (&quot;pr-values&quot;) and so-called expiring values
            /// (&quot;x-values&quot;), which</para>
            /// <para>  /// identify specific objects that can be safely cannibalized
            /// for</para>
            /// <para>  /// their resources.  This is an unfortunate abuse of
            /// terminology on</para>
            /// <para>  /// the part of the C++ committee.  In Clang, when we say
            /// &quot;r-value&quot;,</para>
            /// <para>  /// we generally mean a pr-value.</para>
            /// </remarks>
            public bool isLValue()
            {
                var __ret = Internal.isLValue_0(__Instance);
                return __ret;
            }

            public bool isRValue()
            {
                var __ret = Internal.isRValue_0(__Instance);
                return __ret;
            }

            public bool isXValue()
            {
                var __ret = Internal.isXValue_0(__Instance);
                return __ret;
            }

            public bool isGLValue()
            {
                var __ret = Internal.isGLValue_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>getValueKind - The value kind that this expression
            /// produces.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getValueKind - The value kind that this expression
            /// produces.</para>
            /// </remarks>
            public clang.ExprValueKind getValueKind()
            {
                var __ret = Internal.getValueKind_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>getObjectKind - The object kind that this expression produces.
            /// Object kinds are meaningful only for expressions that yield an l-value or
            /// x-value.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getObjectKind - The object kind that this expression
            /// produces.</para>
            /// <para>  /// Object kinds are meaningful only for expressions that yield
            /// an</para>
            /// <para>  /// l-value or x-value.</para>
            /// </remarks>
            public clang.ExprObjectKind getObjectKind()
            {
                var __ret = Internal.getObjectKind_0(__Instance);
                return __ret;
            }

            public bool isOrdinaryOrBitFieldObject()
            {
                var __ret = Internal.isOrdinaryOrBitFieldObject_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>setValueKind - Set the value kind produced by this
            /// expression.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// setValueKind - Set the value kind produced by this
            /// expression.</para>
            /// </remarks>
            public void setValueKind(clang.ExprValueKind Cat)
            {
                var arg0 = Cat;
                Internal.setValueKind_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>setObjectKind - Set the object kind produced by this
            /// expression.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// setObjectKind - Set the object kind produced by this
            /// expression.</para>
            /// </remarks>
            public void setObjectKind(clang.ExprObjectKind Cat)
            {
                var arg0 = Cat;
                Internal.setObjectKind_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>Returns true if this expression is a gl-value that potentially
            /// refers to a bit-field.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Returns true if this expression is a gl-value
            /// that</para>
            /// <para>  /// potentially refers to a bit-field.</para>
            /// <para>  ///</para>
            /// <para>  /// In C++, whether a gl-value refers to a bitfield is
            /// essentially</para>
            /// <para>  /// an aspect of the value-kind type system.</para>
            /// </remarks>
            public bool refersToBitField()
            {
                var __ret = Internal.refersToBitField_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>If this expression refers to a bit-field, retrieve the
            /// declaration of that bit-field.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief If this expression refers to a bit-field, retrieve
            /// the</para>
            /// <para>  /// declaration of that bit-field.</para>
            /// <para>  ///</para>
            /// <para>  /// Note that this returns a non-null pointer in subtly
            /// different</para>
            /// <para>  /// places than refersToBitField returns true.  In particular,
            /// this can</para>
            /// <para>  /// return a non-null pointer even for r-values loaded
            /// from</para>
            /// <para>  /// bit-fields, but it will return null for a conditional
            /// bit-field.</para>
            /// </remarks>
            public clang.FieldDecl getSourceBitField()
            {
                var __ret = Internal.getSourceBitField_0(__Instance);
                clang.FieldDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.FieldDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.FieldDecl) clang.FieldDecl.NativeToManagedMap[__ret];
                else clang.FieldDecl.NativeToManagedMap[__ret] = __result0 = (clang.FieldDecl) clang.FieldDecl.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Check if this expression is the ObjC 'self' implicit
            /// parameter.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Check if this expression is the ObjC 'self' implicit
            /// parameter.</para>
            /// </remarks>
            public bool isObjCSelfExpr()
            {
                var __ret = Internal.isObjCSelfExpr_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Returns whether this expression refers to a vector
            /// element.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Returns whether this expression refers to a vector
            /// element.</para>
            /// </remarks>
            public bool refersToVectorElement()
            {
                var __ret = Internal.refersToVectorElement_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Returns whether this expression has a placeholder type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Returns whether this expression has a placeholder
            /// type.</para>
            /// </remarks>
            public bool hasPlaceholderType()
            {
                var __ret = Internal.hasPlaceholderType_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Returns whether this expression has a specific placeholder
            /// type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Returns whether this expression has a specific
            /// placeholder type.</para>
            /// </remarks>
            public bool hasPlaceholderType(clang.BuiltinType.Kind K)
            {
                var arg0 = K;
                var __ret = Internal.hasPlaceholderType_1(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>isKnownToHaveBooleanValue - Return true if this is an integer
            /// expression that is known to return 0 or 1. This happens for _Bool/bool
            /// expressions but also int expressions which are produced by things like
            /// comparisons in C.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// isKnownToHaveBooleanValue - Return true if this is an integer
            /// expression</para>
            /// <para>  /// that is known to return 0 or 1.  This happens for
            /// _Bool/bool expressions</para>
            /// <para>  /// but also int expressions which are produced by things like
            /// comparisons in</para>
            /// <para>  /// C.</para>
            /// </remarks>
            public bool isKnownToHaveBooleanValue()
            {
                var __ret = Internal.isKnownToHaveBooleanValue_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>IgnoreImpCasts - Skip past any implicit casts which might
            /// surround this expression. Only skips ImplicitCastExprs.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// IgnoreImpCasts - Skip past any implicit casts which
            /// might</para>
            /// <para>  /// surround this expression.  Only skips
            /// ImplicitCastExprs.</para>
            /// </remarks>
            public clang.Expr IgnoreImpCasts()
            {
                var __ret = Internal.IgnoreImpCasts_0(__Instance);
                clang.Expr __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Expr.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Expr) clang.Expr.NativeToManagedMap[__ret];
                else __result0 = clang.Expr.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>IgnoreImplicit - Skip past any implicit AST nodes which might
            /// surround this expression.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// IgnoreImplicit - Skip past any implicit AST nodes which
            /// might</para>
            /// <para>  /// surround this expression.</para>
            /// </remarks>
            public clang.Expr IgnoreImplicit()
            {
                var __ret = Internal.IgnoreImplicit_0(__Instance);
                clang.Expr __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Expr.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Expr) clang.Expr.NativeToManagedMap[__ret];
                else __result0 = clang.Expr.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>IgnoreParens - Ignore parentheses. If this Expr is a ParenExpr,
            /// return its subexpression. If that subexpression is also a ParenExpr, then
            /// this method recursively returns its subexpression, and so forth. Otherwise,
            /// the method returns the current Expr.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// IgnoreParens - Ignore parentheses.  If this Expr is a
            /// ParenExpr, return</para>
            /// <para>  ///  its subexpression.  If that subexpression is also a
            /// ParenExpr,</para>
            /// <para>  ///  then this method recursively returns its subexpression,
            /// and so forth.</para>
            /// <para>  ///  Otherwise, the method returns the current Expr.</para>
            /// </remarks>
            public clang.Expr IgnoreParens()
            {
                var __ret = Internal.IgnoreParens_0(__Instance);
                clang.Expr __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Expr.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Expr) clang.Expr.NativeToManagedMap[__ret];
                else __result0 = clang.Expr.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>IgnoreParenCasts - Ignore parentheses and casts. Strip off any
            /// ParenExpr or CastExprs, returning their operand.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// IgnoreParenCasts - Ignore parentheses and casts.  Strip off
            /// any ParenExpr</para>
            /// <para>  /// or CastExprs, returning their operand.</para>
            /// </remarks>
            public clang.Expr IgnoreParenCasts()
            {
                var __ret = Internal.IgnoreParenCasts_0(__Instance);
                clang.Expr __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Expr.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Expr) clang.Expr.NativeToManagedMap[__ret];
                else __result0 = clang.Expr.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Ignore casts. Strip off any CastExprs, returning their
            /// operand.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Ignore casts.  Strip off any CastExprs, returning their
            /// operand.</para>
            /// </remarks>
            public clang.Expr IgnoreCasts()
            {
                var __ret = Internal.IgnoreCasts_0(__Instance);
                clang.Expr __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Expr.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Expr) clang.Expr.NativeToManagedMap[__ret];
                else __result0 = clang.Expr.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>IgnoreParenImpCasts - Ignore parentheses and implicit casts.
            /// Strip off any ParenExpr or ImplicitCastExprs, returning their
            /// operand.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// IgnoreParenImpCasts - Ignore parentheses and implicit casts.
            /// Strip off</para>
            /// <para>  /// any ParenExpr or ImplicitCastExprs, returning their
            /// operand.</para>
            /// </remarks>
            public clang.Expr IgnoreParenImpCasts()
            {
                var __ret = Internal.IgnoreParenImpCasts_0(__Instance);
                clang.Expr __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Expr.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Expr) clang.Expr.NativeToManagedMap[__ret];
                else __result0 = clang.Expr.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>IgnoreConversionOperator - Ignore conversion operator. If this
            /// Expr is a call to a conversion operator, return the argument.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// IgnoreConversionOperator - Ignore conversion operator. If
            /// this Expr is a</para>
            /// <para>  /// call to a conversion operator, return the argument.</para>
            /// </remarks>
            public clang.Expr IgnoreConversionOperator()
            {
                var __ret = Internal.IgnoreConversionOperator_0(__Instance);
                clang.Expr __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Expr.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Expr) clang.Expr.NativeToManagedMap[__ret];
                else __result0 = clang.Expr.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Ignore parentheses and lvalue casts. Strip off any ParenExpr and
            /// CastExprs that represent lvalue casts, returning their operand.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Ignore parentheses and lvalue casts.  Strip off any ParenExpr
            /// and</para>
            /// <para>  /// CastExprs that represent lvalue casts, returning their
            /// operand.</para>
            /// </remarks>
            public clang.Expr IgnoreParenLValueCasts()
            {
                var __ret = Internal.IgnoreParenLValueCasts_0(__Instance);
                clang.Expr __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Expr.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Expr) clang.Expr.NativeToManagedMap[__ret];
                else __result0 = clang.Expr.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Ignore parentheses and derived-to-base casts.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Ignore parentheses and derived-to-base casts.</para>
            /// </remarks>
            public clang.Expr ignoreParenBaseCasts()
            {
                var __ret = Internal.ignoreParenBaseCasts_0(__Instance);
                clang.Expr __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Expr.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Expr) clang.Expr.NativeToManagedMap[__ret];
                else __result0 = clang.Expr.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Determine whether this expression is a default function
            /// argument.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine whether this expression is a default
            /// function argument.</para>
            /// <para>  ///</para>
            /// <para>  /// Default arguments are implicitly generated in the abstract
            /// syntax tree</para>
            /// <para>  /// by semantic analysis for function calls, object
            /// constructions, etc. in</para>
            /// <para>  /// C++. Default arguments are represented by \c
            /// CXXDefaultArgExpr nodes;</para>
            /// <para>  /// this routine also looks through any implicit casts to
            /// determine whether</para>
            /// <para>  /// the expression is a default argument.</para>
            /// </remarks>
            public bool isDefaultArgument()
            {
                var __ret = Internal.isDefaultArgument_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Whether this expression is an implicit reference to 'this' in
            /// C++.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Whether this expression is an implicit reference to
            /// 'this' in C++.</para>
            /// </remarks>
            public bool isImplicitCXXThis()
            {
                var __ret = Internal.isImplicitCXXThis_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>getValueKindForType - Given a formal return or parameter type,
            /// give its value kind.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getValueKindForType - Given a formal return or parameter
            /// type,</para>
            /// <para>  /// give its value kind.</para>
            /// </remarks>
            public static clang.ExprValueKind getValueKindForType(clang.QualType T)
            {
                var arg0 = ReferenceEquals(T, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (T.__Instance);
                var __ret = Internal.getValueKindForType_0(arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Given an expression of bound-member type, find the type of the
            /// member. Returns null if this is an *overloaded* bound member
            /// expression.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Given an expression of bound-member type, find the
            /// type</para>
            /// <para>  /// of the member.  Returns null if this is an *overloaded*
            /// bound</para>
            /// <para>  /// member expression.</para>
            /// </remarks>
            public static clang.QualType findBoundMemberType(clang.Expr expr)
            {
                var arg0 = ReferenceEquals(expr, null) ? global::System.IntPtr.Zero : expr.__Instance;
                var __ret = Internal.findBoundMemberType_0(arg0);
                return clang.QualType.__CreateInstance(__ret);
            }

            public static bool classof(clang.Stmt T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>OpaqueValueExpr - An expression referring to an opaque object of
        /// a fixed type and value class. These don't correspond to concrete syntax;
        /// instead they're used to express operations (usually copy operations) on
        /// values whose source is generally obvious from context.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// OpaqueValueExpr - An expression referring to an opaque object
        /// of a</para>
        /// <para>/// fixed type and value class.  These don't correspond to
        /// concrete</para>
        /// <para>/// syntax; instead they're used to express operations (usually
        /// copy</para>
        /// <para>/// operations) on values whose source is generally obvious
        /// from</para>
        /// <para>/// context.</para>
        /// </remarks>
        public unsafe partial class OpaqueValueExpr : clang.Expr, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 32)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                internal clang.Stmt._.Internal __;

                [FieldOffset(8)]
                public clang.QualType.Internal TR;

                [FieldOffset(16)]
                public global::System.IntPtr SourceExpr;

                [FieldOffset(24)]
                public clang.SourceLocation.Internal Loc;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang15OpaqueValueExprC2ENS_14SourceLocationENS_8QualTypeENS_13ExprValueKindENS_14ExprObjectKindEPNS_4ExprE")]
                internal static extern void ctor_0(global::System.IntPtr instance, clang.SourceLocation.Internal Loc, clang.QualType.Internal T, clang.ExprValueKind VK, clang.ExprObjectKind OK, global::System.IntPtr SourceExpr);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang15OpaqueValueExprC2ENS_4Stmt10EmptyShellE")]
                internal static extern void ctor_1(global::System.IntPtr instance, clang.Stmt.EmptyShell.Internal Empty);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang15OpaqueValueExprC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang15OpaqueValueExpr19findInCopyConstructEPKNS_4ExprE")]
                internal static extern global::System.IntPtr findInCopyConstruct_0(global::System.IntPtr expr);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang15OpaqueValueExpr11getLocationEv")]
                internal static extern clang.SourceLocation.Internal getLocation_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang15OpaqueValueExpr11getLocStartEv")]
                internal static extern clang.SourceLocation.Internal getLocStart_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang15OpaqueValueExpr9getLocEndEv")]
                internal static extern clang.SourceLocation.Internal getLocEnd_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang15OpaqueValueExpr10getExprLocEv")]
                internal static extern clang.SourceLocation.Internal getExprLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang15OpaqueValueExpr8childrenEv")]
                internal static extern void children_0(global::System.IntPtr @return, global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang15OpaqueValueExpr13getSourceExprEv")]
                internal static extern global::System.IntPtr getSourceExpr_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang15OpaqueValueExpr7classofEPKNS_4StmtE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);
            }

            private readonly bool __ownsNativeInstance;

            public static new OpaqueValueExpr __CreateInstance(global::System.IntPtr native)
            {
                return new OpaqueValueExpr((OpaqueValueExpr.Internal*) native);
            }

            public static OpaqueValueExpr __CreateInstance(OpaqueValueExpr.Internal native)
            {
                return new OpaqueValueExpr(native);
            }

            private static OpaqueValueExpr.Internal* __CopyValue(OpaqueValueExpr.Internal native)
            {
                var ret = (OpaqueValueExpr.Internal*) Marshal.AllocHGlobal(32);
                *ret = native;
                return ret;
            }

            private OpaqueValueExpr(OpaqueValueExpr.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected OpaqueValueExpr(OpaqueValueExpr.Internal* native, bool isInternalImpl = false)
                : base((clang.Expr.Internal*) native)
            {
            }

            public OpaqueValueExpr(clang.SourceLocation Loc, clang.QualType T, clang.ExprValueKind VK, clang.ExprObjectKind OK, clang.Expr SourceExpr)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(32);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                var arg1 = ReferenceEquals(T, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (T.__Instance);
                var arg2 = VK;
                var arg3 = OK;
                var arg4 = ReferenceEquals(SourceExpr, null) ? global::System.IntPtr.Zero : SourceExpr.__Instance;
                Internal.ctor_0(__Instance, arg0, arg1, arg2, arg3, arg4);
            }

            public OpaqueValueExpr(clang.Stmt.EmptyShell Empty)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(32);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(Empty, null) ? new clang.Stmt.EmptyShell.Internal() : *(clang.Stmt.EmptyShell.Internal*) (Empty.__Instance);
                Internal.ctor_1(__Instance, arg0);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Stmt __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            /// <summary>
            /// <para>Retrieve the location of this expression.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the location of this expression.</para>
            /// </remarks>
            public clang.SourceLocation getLocation()
            {
                var __ret = Internal.getLocation_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLocStart()
            {
                var __ret = Internal.getLocStart_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLocEnd()
            {
                var __ret = Internal.getLocEnd_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getExprLoc()
            {
                var __ret = Internal.getExprLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.StmtRange children()
            {
                var __ret = new clang.StmtRange.Internal();
                Internal.children_0(new IntPtr(&__ret), __Instance);
                return clang.StmtRange.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>The source expression of an opaque value expression is the
            /// expression which originally generated the value. This is provided as a
            /// convenience for analyses that don't wish to precisely model the execution
            /// behavior of the program.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// The source expression of an opaque value expression is
            /// the</para>
            /// <para>  /// expression which originally generated the value.  This
            /// is</para>
            /// <para>  /// provided as a convenience for analyses that don't wish
            /// to</para>
            /// <para>  /// precisely model the execution behavior of the
            /// program.</para>
            /// <para>  ///</para>
            /// <para>  /// The source expression is typically set when building
            /// the</para>
            /// <para>  /// expression which binds the opaque value expression in the
            /// first</para>
            /// <para>  /// place.</para>
            /// </remarks>
            public clang.Expr getSourceExpr()
            {
                var __ret = Internal.getSourceExpr_0(__Instance);
                clang.Expr __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Expr.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Expr) clang.Expr.NativeToManagedMap[__ret];
                else __result0 = clang.Expr.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Given an expression which invokes a copy constructor --- i.e. a
            /// CXXConstructExpr, possibly wrapped in an ExprWithCleanups --- find the
            /// OpaqueValueExpr that's the source of the construction.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Given an expression which invokes a copy constructor --- i.e.
            /// a</para>
            /// <para>  /// CXXConstructExpr, possibly wrapped in an ExprWithCleanups
            /// ---</para>
            /// <para>  /// find the OpaqueValueExpr that's the source of the
            /// construction.</para>
            /// </remarks>
            public static clang.OpaqueValueExpr findInCopyConstruct(clang.Expr expr)
            {
                var arg0 = ReferenceEquals(expr, null) ? global::System.IntPtr.Zero : expr.__Instance;
                var __ret = Internal.findInCopyConstruct_0(arg0);
                clang.OpaqueValueExpr __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.OpaqueValueExpr.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.OpaqueValueExpr) clang.OpaqueValueExpr.NativeToManagedMap[__ret];
                else __result0 = clang.OpaqueValueExpr.__CreateInstance(__ret);
                return __result0;
            }

            public static bool classof(clang.Stmt T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>A reference to a declared variable, function, enum, etc. [C99
        /// 6.5.1p2]</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief A reference to a declared variable, function, enum,
        /// etc.</para>
        /// <para>/// [C99 6.5.1p2]</para>
        /// <para>///</para>
        /// <para>/// This encodes all the information about how a declaration is
        /// referenced</para>
        /// <para>/// within an expression.</para>
        /// <para>///</para>
        /// <para>/// There are several optional constructs attached to
        /// DeclRefExprs only when</para>
        /// <para>/// they apply in order to conserve memory. These are laid out
        /// past the end of</para>
        /// <para>/// the object, and flags in the DeclRefExprBitfield track
        /// whether they exist:</para>
        /// <para>///</para>
        /// <para>///   DeclRefExprBits.HasQualifier:</para>
        /// <para>///       Specifies when this declaration reference expression
        /// has a C++</para>
        /// <para>///       nested-name-specifier.</para>
        /// <para>///   DeclRefExprBits.HasFoundDecl:</para>
        /// <para>///       Specifies when this declaration reference expression
        /// has a record of</para>
        /// <para>///       a NamedDecl (different from the referenced ValueDecl)
        /// which was found</para>
        /// <para>///       during name lookup and/or overload resolution.</para>
        /// <para>///   DeclRefExprBits.HasTemplateKWAndArgsInfo:</para>
        /// <para>///       Specifies when this declaration reference expression
        /// has an explicit</para>
        /// <para>///       C++ template keyword and/or template argument
        /// list.</para>
        /// <para>///   DeclRefExprBits.RefersToEnclosingVariableOrCapture</para>
        /// <para>///       Specifies when this declaration reference expression
        /// (validly)</para>
        /// <para>///       refers to an enclosed local or a captured
        /// variable.</para>
        /// </remarks>
        public unsafe partial class DeclRefExpr : clang.Expr, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 40)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                internal clang.Stmt._.Internal __;

                [FieldOffset(8)]
                public clang.QualType.Internal TR;

                [FieldOffset(16)]
                public global::System.IntPtr D;

                [FieldOffset(24)]
                public clang.SourceLocation.Internal Loc;

                [FieldOffset(32)]
                public clang.DeclarationNameLoc.Internal DNLoc;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11DeclRefExprC2EPNS_9ValueDeclEbNS_8QualTypeENS_13ExprValueKindENS_14SourceLocationERKNS_18DeclarationNameLocE")]
                internal static extern void ctor_2(global::System.IntPtr instance, global::System.IntPtr D, bool RefersToEnclosingVariableOrCapture, clang.QualType.Internal T, clang.ExprValueKind VK, clang.SourceLocation.Internal L, global::System.IntPtr LocInfo);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11DeclRefExprC2ERKS0_")]
                internal static extern void cctor_3(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11DeclRefExpr7getDeclEv")]
                internal static extern global::System.IntPtr getDecl_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11DeclRefExpr7setDeclEPNS_9ValueDeclE")]
                internal static extern void setDecl_0(global::System.IntPtr instance, global::System.IntPtr NewD);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11DeclRefExpr11getNameInfoEv")]
                internal static extern void getNameInfo_0(global::System.IntPtr @return, global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11DeclRefExpr11getLocationEv")]
                internal static extern clang.SourceLocation.Internal getLocation_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11DeclRefExpr11setLocationENS_14SourceLocationE")]
                internal static extern void setLocation_0(global::System.IntPtr instance, clang.SourceLocation.Internal L);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11DeclRefExpr11getLocStartEv")]
                internal static extern clang.SourceLocation.Internal getLocStart_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11DeclRefExpr9getLocEndEv")]
                internal static extern clang.SourceLocation.Internal getLocEnd_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11DeclRefExpr12hasQualifierEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasQualifier_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11DeclRefExpr12getQualifierEv")]
                internal static extern global::System.IntPtr getQualifier_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11DeclRefExpr15getQualifierLocEv")]
                internal static extern clang.NestedNameSpecifierLoc.Internal getQualifierLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11DeclRefExpr12getFoundDeclEv")]
                internal static extern global::System.IntPtr getFoundDecl_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11DeclRefExpr24hasTemplateKWAndArgsInfoEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasTemplateKWAndArgsInfo_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11DeclRefExpr24getTemplateKWAndArgsInfoEv")]
                internal static extern global::System.IntPtr getTemplateKWAndArgsInfo_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11DeclRefExpr21getTemplateKeywordLocEv")]
                internal static extern clang.SourceLocation.Internal getTemplateKeywordLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11DeclRefExpr12getLAngleLocEv")]
                internal static extern clang.SourceLocation.Internal getLAngleLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11DeclRefExpr12getRAngleLocEv")]
                internal static extern clang.SourceLocation.Internal getRAngleLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11DeclRefExpr18hasTemplateKeywordEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasTemplateKeyword_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11DeclRefExpr23hasExplicitTemplateArgsEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasExplicitTemplateArgs_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11DeclRefExpr23getExplicitTemplateArgsEv")]
                internal static extern global::System.IntPtr getExplicitTemplateArgs_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11DeclRefExpr31getOptionalExplicitTemplateArgsEv")]
                internal static extern global::System.IntPtr getOptionalExplicitTemplateArgs_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11DeclRefExpr25copyTemplateArgumentsIntoERNS_24TemplateArgumentListInfoE")]
                internal static extern void copyTemplateArgumentsInto_0(global::System.IntPtr instance, global::System.IntPtr List);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11DeclRefExpr15getTemplateArgsEv")]
                internal static extern global::System.IntPtr getTemplateArgs_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11DeclRefExpr18getNumTemplateArgsEv")]
                internal static extern uint getNumTemplateArgs_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11DeclRefExpr21hadMultipleCandidatesEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hadMultipleCandidates_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11DeclRefExpr24setHadMultipleCandidatesEb")]
                internal static extern void setHadMultipleCandidates_0(global::System.IntPtr instance, bool V);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11DeclRefExpr34refersToEnclosingVariableOrCaptureEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool refersToEnclosingVariableOrCapture_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11DeclRefExpr7classofEPKNS_4StmtE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11DeclRefExpr8childrenEv")]
                internal static extern void children_0(global::System.IntPtr @return, global::System.IntPtr instance);
            }

            private readonly bool __ownsNativeInstance;

            public static new DeclRefExpr __CreateInstance(global::System.IntPtr native)
            {
                return new DeclRefExpr((DeclRefExpr.Internal*) native);
            }

            public static DeclRefExpr __CreateInstance(DeclRefExpr.Internal native)
            {
                return new DeclRefExpr(native);
            }

            private static DeclRefExpr.Internal* __CopyValue(DeclRefExpr.Internal native)
            {
                var ret = (DeclRefExpr.Internal*) Marshal.AllocHGlobal(40);
                *ret = native;
                return ret;
            }

            private DeclRefExpr(DeclRefExpr.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected DeclRefExpr(DeclRefExpr.Internal* native, bool isInternalImpl = false)
                : base((clang.Expr.Internal*) native)
            {
            }

            public DeclRefExpr(clang.ValueDecl D, bool RefersToEnclosingVariableOrCapture, clang.QualType T, clang.ExprValueKind VK, clang.SourceLocation L, clang.DeclarationNameLoc LocInfo)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(40);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(D, null) ? global::System.IntPtr.Zero : D.__Instance;
                var arg2 = ReferenceEquals(T, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (T.__Instance);
                var arg3 = VK;
                var arg4 = ReferenceEquals(L, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (L.__Instance);
                var arg5 = ReferenceEquals(LocInfo, null) ? global::System.IntPtr.Zero : LocInfo.__Instance;
                Internal.ctor_2(__Instance, arg0, RefersToEnclosingVariableOrCapture, arg2, arg3, arg4, arg5);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Stmt __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.ValueDecl getDecl()
            {
                var __ret = Internal.getDecl_0(__Instance);
                clang.ValueDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.ValueDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.ValueDecl) clang.ValueDecl.NativeToManagedMap[__ret];
                else clang.ValueDecl.NativeToManagedMap[__ret] = __result0 = (clang.ValueDecl) clang.ValueDecl.__CreateInstance(__ret);
                return __result0;
            }

            public void setDecl(clang.ValueDecl NewD)
            {
                var arg0 = ReferenceEquals(NewD, null) ? global::System.IntPtr.Zero : NewD.__Instance;
                Internal.setDecl_0(__Instance, arg0);
            }

            public clang.DeclarationNameInfo getNameInfo()
            {
                var __ret = new clang.DeclarationNameInfo.Internal();
                Internal.getNameInfo_0(new IntPtr(&__ret), __Instance);
                return clang.DeclarationNameInfo.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLocation()
            {
                var __ret = Internal.getLocation_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setLocation(clang.SourceLocation L)
            {
                var arg0 = ReferenceEquals(L, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (L.__Instance);
                Internal.setLocation_0(__Instance, arg0);
            }

            public clang.SourceLocation getLocStart()
            {
                var __ret = Internal.getLocStart_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLocEnd()
            {
                var __ret = Internal.getLocEnd_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Determine whether this declaration reference was preceded by a
            /// C++ nested-name-specifier, e.g., N::foo.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine whether this declaration reference was
            /// preceded by a</para>
            /// <para>  /// C++ nested-name-specifier, e.g., \c N::foo.</para>
            /// </remarks>
            public bool hasQualifier()
            {
                var __ret = Internal.hasQualifier_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>If the name was qualified, retrieves the nested-name-specifier
            /// that precedes the name. Otherwise, returns NULL.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief If the name was qualified, retrieves the
            /// nested-name-specifier</para>
            /// <para>  /// that precedes the name. Otherwise, returns NULL.</para>
            /// </remarks>
            public clang.NestedNameSpecifier getQualifier()
            {
                var __ret = Internal.getQualifier_0(__Instance);
                clang.NestedNameSpecifier __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.NestedNameSpecifier.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.NestedNameSpecifier) clang.NestedNameSpecifier.NativeToManagedMap[__ret];
                else __result0 = clang.NestedNameSpecifier.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>If the name was qualified, retrieves the nested-name-specifier
            /// that precedes the name, with source-location information.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief If the name was qualified, retrieves the
            /// nested-name-specifier</para>
            /// <para>  /// that precedes the name, with source-location
            /// information.</para>
            /// </remarks>
            public clang.NestedNameSpecifierLoc getQualifierLoc()
            {
                var __ret = Internal.getQualifierLoc_0(__Instance);
                return clang.NestedNameSpecifierLoc.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Get the NamedDecl through which this reference occurred.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Get the NamedDecl through which this reference
            /// occurred.</para>
            /// <para>  ///</para>
            /// <para>  /// This Decl may be different from the ValueDecl actually
            /// referred to in the</para>
            /// <para>  /// presence of using declarations, etc. It always returns
            /// non-NULL, and may</para>
            /// <para>  /// simple return the ValueDecl when appropriate.</para>
            /// </remarks>
            public clang.NamedDecl getFoundDecl()
            {
                var __ret = Internal.getFoundDecl_0(__Instance);
                clang.NamedDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.NamedDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.NamedDecl) clang.NamedDecl.NativeToManagedMap[__ret];
                else clang.NamedDecl.NativeToManagedMap[__ret] = __result0 = (clang.NamedDecl) clang.NamedDecl.__CreateInstance(__ret);
                return __result0;
            }

            public bool hasTemplateKWAndArgsInfo()
            {
                var __ret = Internal.hasTemplateKWAndArgsInfo_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Return the optional template keyword and arguments info.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the optional template keyword and arguments
            /// info.</para>
            /// </remarks>
            public clang.ASTTemplateKWAndArgsInfo getTemplateKWAndArgsInfo()
            {
                var __ret = Internal.getTemplateKWAndArgsInfo_0(__Instance);
                clang.ASTTemplateKWAndArgsInfo __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.ASTTemplateKWAndArgsInfo.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.ASTTemplateKWAndArgsInfo) clang.ASTTemplateKWAndArgsInfo.NativeToManagedMap[__ret];
                else __result0 = clang.ASTTemplateKWAndArgsInfo.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Retrieve the location of the template keyword preceding this
            /// name, if any.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the location of the template keyword
            /// preceding</para>
            /// <para>  /// this name, if any.</para>
            /// </remarks>
            public clang.SourceLocation getTemplateKeywordLoc()
            {
                var __ret = Internal.getTemplateKeywordLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Retrieve the location of the left angle bracket starting the
            /// explicit template argument list following the name, if any.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the location of the left angle bracket
            /// starting the</para>
            /// <para>  /// explicit template argument list following the name, if
            /// any.</para>
            /// </remarks>
            public clang.SourceLocation getLAngleLoc()
            {
                var __ret = Internal.getLAngleLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Retrieve the location of the right angle bracket ending the
            /// explicit template argument list following the name, if any.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the location of the right angle bracket
            /// ending the</para>
            /// <para>  /// explicit template argument list following the name, if
            /// any.</para>
            /// </remarks>
            public clang.SourceLocation getRAngleLoc()
            {
                var __ret = Internal.getRAngleLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Determines whether the name in this declaration reference was
            /// preceded by the template keyword.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determines whether the name in this declaration
            /// reference</para>
            /// <para>  /// was preceded by the template keyword.</para>
            /// </remarks>
            public bool hasTemplateKeyword()
            {
                var __ret = Internal.hasTemplateKeyword_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determines whether this declaration reference was followed by an
            /// explicit template argument list.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determines whether this declaration reference was
            /// followed by an</para>
            /// <para>  /// explicit template argument list.</para>
            /// </remarks>
            public bool hasExplicitTemplateArgs()
            {
                var __ret = Internal.hasExplicitTemplateArgs_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Retrieve the explicit template argument list that followed the
            /// member template name.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the explicit template argument list that
            /// followed the</para>
            /// <para>  /// member template name.</para>
            /// </remarks>
            public clang.ASTTemplateArgumentListInfo getExplicitTemplateArgs()
            {
                var __ret = Internal.getExplicitTemplateArgs_0(__Instance);
                clang.ASTTemplateArgumentListInfo __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.ASTTemplateArgumentListInfo.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.ASTTemplateArgumentListInfo) clang.ASTTemplateArgumentListInfo.NativeToManagedMap[__ret];
                else __result0 = clang.ASTTemplateArgumentListInfo.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Retrieves the optional explicit template arguments. This points
            /// to the same data as getExplicitTemplateArgs(), but returns null if there
            /// are no explicit template arguments.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieves the optional explicit template
            /// arguments.</para>
            /// <para>  /// This points to the same data as getExplicitTemplateArgs(),
            /// but</para>
            /// <para>  /// returns null if there are no explicit template
            /// arguments.</para>
            /// </remarks>
            public clang.ASTTemplateArgumentListInfo getOptionalExplicitTemplateArgs()
            {
                var __ret = Internal.getOptionalExplicitTemplateArgs_0(__Instance);
                clang.ASTTemplateArgumentListInfo __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.ASTTemplateArgumentListInfo.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.ASTTemplateArgumentListInfo) clang.ASTTemplateArgumentListInfo.NativeToManagedMap[__ret];
                else __result0 = clang.ASTTemplateArgumentListInfo.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Copies the template arguments (if present) into the given
            /// structure.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Copies the template arguments (if present) into the
            /// given</para>
            /// <para>  /// structure.</para>
            /// </remarks>
            public void copyTemplateArgumentsInto(clang.TemplateArgumentListInfo List)
            {
                var arg0 = ReferenceEquals(List, null) ? global::System.IntPtr.Zero : List.__Instance;
                Internal.copyTemplateArgumentsInto_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>Retrieve the template arguments provided as part of this
            /// template-id.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the template arguments provided as part of
            /// this</para>
            /// <para>  /// template-id.</para>
            /// </remarks>
            public clang.TemplateArgumentLoc getTemplateArgs()
            {
                var __ret = Internal.getTemplateArgs_0(__Instance);
                clang.TemplateArgumentLoc __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.TemplateArgumentLoc.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.TemplateArgumentLoc) clang.TemplateArgumentLoc.NativeToManagedMap[__ret];
                else __result0 = clang.TemplateArgumentLoc.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Retrieve the number of template arguments provided as part of
            /// this template-id.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the number of template arguments provided as
            /// part of this</para>
            /// <para>  /// template-id.</para>
            /// </remarks>
            public uint getNumTemplateArgs()
            {
                var __ret = Internal.getNumTemplateArgs_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Returns true if this expression refers to a function that was
            /// resolved from an overloaded set having size greater than 1.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Returns true if this expression refers to a function
            /// that</para>
            /// <para>  /// was resolved from an overloaded set having size greater
            /// than 1.</para>
            /// </remarks>
            public bool hadMultipleCandidates()
            {
                var __ret = Internal.hadMultipleCandidates_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Sets the flag telling whether this expression refers to a
            /// function that was resolved from an overloaded set having size greater than
            /// 1.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Sets the flag telling whether this expression refers
            /// to</para>
            /// <para>  /// a function that was resolved from an overloaded set having
            /// size</para>
            /// <para>  /// greater than 1.</para>
            /// </remarks>
            public void setHadMultipleCandidates(bool V)
            {
                Internal.setHadMultipleCandidates_0(__Instance, V);
            }

            /// <summary>
            /// <para>Does this DeclRefExpr refer to an enclosing local or a captured
            /// variable?</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Does this DeclRefExpr refer to an enclosing local or a
            /// captured</para>
            /// <para>  /// variable?</para>
            /// </remarks>
            public bool refersToEnclosingVariableOrCapture()
            {
                var __ret = Internal.refersToEnclosingVariableOrCapture_0(__Instance);
                return __ret;
            }

            public clang.StmtRange children()
            {
                var __ret = new clang.StmtRange.Internal();
                Internal.children_0(new IntPtr(&__ret), __Instance);
                return clang.StmtRange.__CreateInstance(__ret);
            }

            public static bool classof(clang.Stmt T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>[C99 6.4.2.2] - A predefined identifier such as __func__.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief [C99 6.4.2.2] - A predefined identifier such as
        /// __func__.</para>
        /// </remarks>
        public unsafe partial class PredefinedExpr : clang.Expr, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 32)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                internal clang.Stmt._.Internal __;

                [FieldOffset(8)]
                public clang.QualType.Internal TR;

                [FieldOffset(16)]
                public clang.SourceLocation.Internal Loc;

                [FieldOffset(20)]
                public clang.PredefinedExpr.IdentType Type;

                [FieldOffset(24)]
                public global::System.IntPtr FnName;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14PredefinedExprC2ENS_14SourceLocationENS_8QualTypeENS0_9IdentTypeEPNS_13StringLiteralE")]
                internal static extern void ctor_0(global::System.IntPtr instance, clang.SourceLocation.Internal L, clang.QualType.Internal FNTy, clang.PredefinedExpr.IdentType IT, global::System.IntPtr SL);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14PredefinedExprC2ENS_4Stmt10EmptyShellE")]
                internal static extern void ctor_1(global::System.IntPtr instance, clang.Stmt.EmptyShell.Internal Empty);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14PredefinedExprC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14PredefinedExpr12getIdentTypeEv")]
                internal static extern clang.PredefinedExpr.IdentType getIdentType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14PredefinedExpr11getLocationEv")]
                internal static extern clang.SourceLocation.Internal getLocation_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14PredefinedExpr11setLocationENS_14SourceLocationE")]
                internal static extern void setLocation_0(global::System.IntPtr instance, clang.SourceLocation.Internal L);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14PredefinedExpr15getFunctionNameEv")]
                internal static extern global::System.IntPtr getFunctionName_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14PredefinedExpr16getIdentTypeNameENS0_9IdentTypeE")]
                internal static extern llvm.StringRef.Internal getIdentTypeName_0(clang.PredefinedExpr.IdentType IT);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14PredefinedExpr11getLocStartEv")]
                internal static extern clang.SourceLocation.Internal getLocStart_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14PredefinedExpr9getLocEndEv")]
                internal static extern clang.SourceLocation.Internal getLocEnd_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14PredefinedExpr7classofEPKNS_4StmtE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14PredefinedExpr8childrenEv")]
                internal static extern void children_0(global::System.IntPtr @return, global::System.IntPtr instance);
            }

            public enum IdentType : uint
            {
                Func = 0,
                Function = 1,
                LFunction = 2,
                FuncDName = 3,
                FuncSig = 4,
                PrettyFunction = 5,
                /// <summary>The same as PrettyFunction, except that the 'virtual' keyword is omitted for virtual member functions.</summary>
                PrettyFunctionNoVirtual = 6
            }

            private readonly bool __ownsNativeInstance;

            public static new PredefinedExpr __CreateInstance(global::System.IntPtr native)
            {
                return new PredefinedExpr((PredefinedExpr.Internal*) native);
            }

            public static PredefinedExpr __CreateInstance(PredefinedExpr.Internal native)
            {
                return new PredefinedExpr(native);
            }

            private static PredefinedExpr.Internal* __CopyValue(PredefinedExpr.Internal native)
            {
                var ret = (PredefinedExpr.Internal*) Marshal.AllocHGlobal(32);
                *ret = native;
                return ret;
            }

            private PredefinedExpr(PredefinedExpr.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected PredefinedExpr(PredefinedExpr.Internal* native, bool isInternalImpl = false)
                : base((clang.Expr.Internal*) native)
            {
            }

            public PredefinedExpr(clang.SourceLocation L, clang.QualType FNTy, clang.PredefinedExpr.IdentType IT, clang.StringLiteral SL)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(32);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(L, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (L.__Instance);
                var arg1 = ReferenceEquals(FNTy, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (FNTy.__Instance);
                var arg2 = IT;
                var arg3 = ReferenceEquals(SL, null) ? global::System.IntPtr.Zero : SL.__Instance;
                Internal.ctor_0(__Instance, arg0, arg1, arg2, arg3);
            }

            /// <summary>
            /// <para>Construct an empty predefined expression.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Construct an empty predefined expression.</para>
            /// </remarks>
            public PredefinedExpr(clang.Stmt.EmptyShell Empty)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(32);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(Empty, null) ? new clang.Stmt.EmptyShell.Internal() : *(clang.Stmt.EmptyShell.Internal*) (Empty.__Instance);
                Internal.ctor_1(__Instance, arg0);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Stmt __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.PredefinedExpr.IdentType getIdentType()
            {
                var __ret = Internal.getIdentType_0(__Instance);
                return __ret;
            }

            public clang.SourceLocation getLocation()
            {
                var __ret = Internal.getLocation_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setLocation(clang.SourceLocation L)
            {
                var arg0 = ReferenceEquals(L, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (L.__Instance);
                Internal.setLocation_0(__Instance, arg0);
            }

            public clang.StringLiteral getFunctionName()
            {
                var __ret = Internal.getFunctionName_0(__Instance);
                clang.StringLiteral __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.StringLiteral.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.StringLiteral) clang.StringLiteral.NativeToManagedMap[__ret];
                else __result0 = clang.StringLiteral.__CreateInstance(__ret);
                return __result0;
            }

            public clang.SourceLocation getLocStart()
            {
                var __ret = Internal.getLocStart_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLocEnd()
            {
                var __ret = Internal.getLocEnd_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.StmtRange children()
            {
                var __ret = new clang.StmtRange.Internal();
                Internal.children_0(new IntPtr(&__ret), __Instance);
                return clang.StmtRange.__CreateInstance(__ret);
            }

            public static llvm.StringRef getIdentTypeName(clang.PredefinedExpr.IdentType IT)
            {
                var arg0 = IT;
                var __ret = Internal.getIdentTypeName_0(arg0);
                return llvm.StringRef.__CreateInstance(__ret);
            }

            public static bool classof(clang.Stmt T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Used by IntegerLiteral/FloatingLiteral to store the numeric
        /// without leaking memory.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief Used by IntegerLiteral/FloatingLiteral to store the
        /// numeric without</para>
        /// <para>/// leaking memory.</para>
        /// <para>///</para>
        /// <para>/// For large floats/integers, APFloat/APInt will allocate memory
        /// from the heap</para>
        /// <para>/// to represent these numbers.  Unfortunately, when we use a
        /// BumpPtrAllocator</para>
        /// <para>/// to allocate IntegerLiteral/FloatingLiteral nodes the memory
        /// associated with</para>
        /// <para>/// the APFloat/APInt values will never get freed.
        /// APNumericStorage uses</para>
        /// <para>/// ASTContext's allocator for memory allocation.</para>
        /// </remarks>
        public unsafe partial class APNumericStorage : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                internal clang.APNumericStorage._.Internal _0;

                [FieldOffset(8)]
                public uint BitWidth;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16APNumericStorageC2Ev")]
                internal static extern void ctor_1(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang16APNumericStorage11getIntValueEv")]
                internal static extern void getIntValue_0(global::System.IntPtr @return, global::System.IntPtr instance);
            }

            internal unsafe partial struct _
            {
                [StructLayout(LayoutKind.Explicit, Size = 8)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public ulong VAL;

                    [FieldOffset(0)]
                    public ulong* pVal;
                }
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, APNumericStorage> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, APNumericStorage>();

            private readonly bool __ownsNativeInstance;

            public static APNumericStorage __CreateInstance(global::System.IntPtr native)
            {
                return new APNumericStorage((APNumericStorage.Internal*) native);
            }

            public static APNumericStorage __CreateInstance(APNumericStorage.Internal native)
            {
                return new APNumericStorage(native);
            }

            private static APNumericStorage.Internal* __CopyValue(APNumericStorage.Internal native)
            {
                var ret = (APNumericStorage.Internal*) Marshal.AllocHGlobal(16);
                *ret = native;
                return ret;
            }

            private APNumericStorage(APNumericStorage.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected APNumericStorage(APNumericStorage.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            protected APNumericStorage()
            {
                __Instance = Marshal.AllocHGlobal(16);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_1(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.APNumericStorage __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            protected llvm.APInt getIntValue()
            {
                var __ret = new llvm.APInt.Internal();
                Internal.getIntValue_0(new IntPtr(&__ret), __Instance);
                return llvm.APInt.__CreateInstance(__ret);
            }
        }

        public unsafe partial class APIntStorage : clang.APNumericStorage, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                internal clang.APNumericStorage._.Internal _0;

                [FieldOffset(8)]
                public uint BitWidth;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12APIntStorageC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12APIntStorageC2Ev")]
                internal static extern void ctor_2(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12APIntStorage8getValueEv")]
                internal static extern void getValue_0(global::System.IntPtr @return, global::System.IntPtr instance);
            }

            private readonly bool __ownsNativeInstance;

            public static new APIntStorage __CreateInstance(global::System.IntPtr native)
            {
                return new APIntStorage((APIntStorage.Internal*) native);
            }

            public static APIntStorage __CreateInstance(APIntStorage.Internal native)
            {
                return new APIntStorage(native);
            }

            private static APIntStorage.Internal* __CopyValue(APIntStorage.Internal native)
            {
                var ret = (APIntStorage.Internal*) Marshal.AllocHGlobal(16);
                *ret = native;
                return ret;
            }

            private APIntStorage(APIntStorage.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected APIntStorage(APIntStorage.Internal* native, bool isInternalImpl = false)
                : base((clang.APNumericStorage.Internal*) native)
            {
            }

            public APIntStorage()
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(16);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_2(__Instance);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.APNumericStorage __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public llvm.APInt getValue()
            {
                var __ret = new llvm.APInt.Internal();
                Internal.getValue_0(new IntPtr(&__ret), __Instance);
                return llvm.APInt.__CreateInstance(__ret);
            }
        }

        public unsafe partial class APFloatStorage : clang.APNumericStorage, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                internal clang.APNumericStorage._.Internal _0;

                [FieldOffset(8)]
                public uint BitWidth;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14APFloatStorageC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14APFloatStorageC2Ev")]
                internal static extern void ctor_2(global::System.IntPtr instance);
            }

            private readonly bool __ownsNativeInstance;

            public static new APFloatStorage __CreateInstance(global::System.IntPtr native)
            {
                return new APFloatStorage((APFloatStorage.Internal*) native);
            }

            public static APFloatStorage __CreateInstance(APFloatStorage.Internal native)
            {
                return new APFloatStorage(native);
            }

            private static APFloatStorage.Internal* __CopyValue(APFloatStorage.Internal native)
            {
                var ret = (APFloatStorage.Internal*) Marshal.AllocHGlobal(16);
                *ret = native;
                return ret;
            }

            private APFloatStorage(APFloatStorage.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected APFloatStorage(APFloatStorage.Internal* native, bool isInternalImpl = false)
                : base((clang.APNumericStorage.Internal*) native)
            {
            }

            public APFloatStorage()
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(16);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_2(__Instance);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.APNumericStorage __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }
        }

        public unsafe partial class IntegerLiteral : clang.Expr, clang.APIntStorage, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 32)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                internal clang.Stmt._.Internal __;

                [FieldOffset(8)]
                public clang.QualType.Internal TR;

                [FieldOffset(0)]
                internal clang.APNumericStorage._.Internal _0;

                [FieldOffset(8)]
                public uint BitWidth;

                [FieldOffset(28)]
                public clang.SourceLocation.Internal Loc;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14IntegerLiteralC2ERKS0_")]
                internal static extern void cctor_3(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14IntegerLiteral11getLocStartEv")]
                internal static extern clang.SourceLocation.Internal getLocStart_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14IntegerLiteral9getLocEndEv")]
                internal static extern clang.SourceLocation.Internal getLocEnd_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14IntegerLiteral11getLocationEv")]
                internal static extern clang.SourceLocation.Internal getLocation_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14IntegerLiteral11setLocationENS_14SourceLocationE")]
                internal static extern void setLocation_0(global::System.IntPtr instance, clang.SourceLocation.Internal Location);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14IntegerLiteral7classofEPKNS_4StmtE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14IntegerLiteral8childrenEv")]
                internal static extern void children_0(global::System.IntPtr @return, global::System.IntPtr instance);
            }

            private readonly bool __ownsNativeInstance;

            public static new IntegerLiteral __CreateInstance(global::System.IntPtr native)
            {
                return new IntegerLiteral((IntegerLiteral.Internal*) native);
            }

            public static IntegerLiteral __CreateInstance(IntegerLiteral.Internal native)
            {
                return new IntegerLiteral(native);
            }

            private static IntegerLiteral.Internal* __CopyValue(IntegerLiteral.Internal native)
            {
                var ret = (IntegerLiteral.Internal*) Marshal.AllocHGlobal(32);
                *ret = native;
                return ret;
            }

            private IntegerLiteral(IntegerLiteral.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected IntegerLiteral(IntegerLiteral.Internal* native, bool isInternalImpl = false)
                : base((clang.Expr.Internal*) native)
            {
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Stmt __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.SourceLocation getLocStart()
            {
                var __ret = Internal.getLocStart_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLocEnd()
            {
                var __ret = Internal.getLocEnd_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Retrieve the location of the literal.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the location of the literal.</para>
            /// </remarks>
            public clang.SourceLocation getLocation()
            {
                var __ret = Internal.getLocation_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setLocation(clang.SourceLocation Location)
            {
                var arg0 = ReferenceEquals(Location, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Location.__Instance);
                Internal.setLocation_0(__Instance, arg0);
            }

            public clang.StmtRange children()
            {
                var __ret = new clang.StmtRange.Internal();
                Internal.children_0(new IntPtr(&__ret), __Instance);
                return clang.StmtRange.__CreateInstance(__ret);
            }

            public static bool classof(clang.Stmt T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        public unsafe partial class CharacterLiteral : clang.Expr, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 24)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                internal clang.Stmt._.Internal __;

                [FieldOffset(8)]
                public clang.QualType.Internal TR;

                [FieldOffset(16)]
                public uint Value;

                [FieldOffset(20)]
                public clang.SourceLocation.Internal Loc;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16CharacterLiteralC2EjNS0_13CharacterKindENS_8QualTypeENS_14SourceLocationE")]
                internal static extern void ctor_0(global::System.IntPtr instance, uint value, clang.CharacterLiteral.CharacterKind kind, clang.QualType.Internal type, clang.SourceLocation.Internal l);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16CharacterLiteralC2ENS_4Stmt10EmptyShellE")]
                internal static extern void ctor_1(global::System.IntPtr instance, clang.Stmt.EmptyShell.Internal Empty);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16CharacterLiteralC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang16CharacterLiteral11getLocationEv")]
                internal static extern clang.SourceLocation.Internal getLocation_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang16CharacterLiteral7getKindEv")]
                internal static extern clang.CharacterLiteral.CharacterKind getKind_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang16CharacterLiteral11getLocStartEv")]
                internal static extern clang.SourceLocation.Internal getLocStart_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang16CharacterLiteral9getLocEndEv")]
                internal static extern clang.SourceLocation.Internal getLocEnd_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang16CharacterLiteral8getValueEv")]
                internal static extern uint getValue_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16CharacterLiteral11setLocationENS_14SourceLocationE")]
                internal static extern void setLocation_0(global::System.IntPtr instance, clang.SourceLocation.Internal Location);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16CharacterLiteral7setKindENS0_13CharacterKindE")]
                internal static extern void setKind_0(global::System.IntPtr instance, clang.CharacterLiteral.CharacterKind kind);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16CharacterLiteral8setValueEj")]
                internal static extern void setValue_0(global::System.IntPtr instance, uint Val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16CharacterLiteral7classofEPKNS_4StmtE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16CharacterLiteral8childrenEv")]
                internal static extern void children_0(global::System.IntPtr @return, global::System.IntPtr instance);
            }

            public enum CharacterKind : uint
            {
                Ascii = 0,
                Wide = 1,
                UTF16 = 2,
                UTF32 = 3
            }

            private readonly bool __ownsNativeInstance;

            public static new CharacterLiteral __CreateInstance(global::System.IntPtr native)
            {
                return new CharacterLiteral((CharacterLiteral.Internal*) native);
            }

            public static CharacterLiteral __CreateInstance(CharacterLiteral.Internal native)
            {
                return new CharacterLiteral(native);
            }

            private static CharacterLiteral.Internal* __CopyValue(CharacterLiteral.Internal native)
            {
                var ret = (CharacterLiteral.Internal*) Marshal.AllocHGlobal(24);
                *ret = native;
                return ret;
            }

            private CharacterLiteral(CharacterLiteral.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected CharacterLiteral(CharacterLiteral.Internal* native, bool isInternalImpl = false)
                : base((clang.Expr.Internal*) native)
            {
            }

            public CharacterLiteral(uint value, clang.CharacterLiteral.CharacterKind kind, clang.QualType type, clang.SourceLocation l)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(24);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg1 = kind;
                var arg2 = ReferenceEquals(type, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (type.__Instance);
                var arg3 = ReferenceEquals(l, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (l.__Instance);
                Internal.ctor_0(__Instance, value, arg1, arg2, arg3);
            }

            /// <summary>
            /// <para>Construct an empty character literal.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Construct an empty character literal.</para>
            /// </remarks>
            public CharacterLiteral(clang.Stmt.EmptyShell Empty)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(24);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(Empty, null) ? new clang.Stmt.EmptyShell.Internal() : *(clang.Stmt.EmptyShell.Internal*) (Empty.__Instance);
                Internal.ctor_1(__Instance, arg0);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Stmt __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.SourceLocation getLocation()
            {
                var __ret = Internal.getLocation_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.CharacterLiteral.CharacterKind getKind()
            {
                var __ret = Internal.getKind_0(__Instance);
                return __ret;
            }

            public clang.SourceLocation getLocStart()
            {
                var __ret = Internal.getLocStart_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLocEnd()
            {
                var __ret = Internal.getLocEnd_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public uint getValue()
            {
                var __ret = Internal.getValue_0(__Instance);
                return __ret;
            }

            public void setLocation(clang.SourceLocation Location)
            {
                var arg0 = ReferenceEquals(Location, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Location.__Instance);
                Internal.setLocation_0(__Instance, arg0);
            }

            public void setKind(clang.CharacterLiteral.CharacterKind kind)
            {
                var arg0 = kind;
                Internal.setKind_0(__Instance, arg0);
            }

            public void setValue(uint Val)
            {
                Internal.setValue_0(__Instance, Val);
            }

            public clang.StmtRange children()
            {
                var __ret = new clang.StmtRange.Internal();
                Internal.children_0(new IntPtr(&__ret), __Instance);
                return clang.StmtRange.__CreateInstance(__ret);
            }

            public static bool classof(clang.Stmt T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        public unsafe partial class FloatingLiteral : clang.Expr, clang.APFloatStorage, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 32)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                internal clang.Stmt._.Internal __;

                [FieldOffset(8)]
                public clang.QualType.Internal TR;

                [FieldOffset(0)]
                internal clang.APNumericStorage._.Internal _0;

                [FieldOffset(8)]
                public uint BitWidth;

                [FieldOffset(28)]
                public clang.SourceLocation.Internal Loc;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang15FloatingLiteralC2ERKS0_")]
                internal static extern void cctor_3(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang15FloatingLiteral8getValueEv")]
                internal static extern void getValue_0(global::System.IntPtr @return, global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang15FloatingLiteral15getRawSemanticsEv")]
                internal static extern clang.Stmt.APFloatSemantics getRawSemantics_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang15FloatingLiteral15setRawSemanticsENS_4Stmt16APFloatSemanticsE")]
                internal static extern void setRawSemantics_0(global::System.IntPtr instance, clang.Stmt.APFloatSemantics Sem);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang15FloatingLiteral7isExactEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isExact_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang15FloatingLiteral8setExactEb")]
                internal static extern void setExact_0(global::System.IntPtr instance, bool E);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang15FloatingLiteral27getValueAsApproximateDoubleEv")]
                internal static extern double getValueAsApproximateDouble_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang15FloatingLiteral11getLocationEv")]
                internal static extern clang.SourceLocation.Internal getLocation_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang15FloatingLiteral11setLocationENS_14SourceLocationE")]
                internal static extern void setLocation_0(global::System.IntPtr instance, clang.SourceLocation.Internal L);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang15FloatingLiteral11getLocStartEv")]
                internal static extern clang.SourceLocation.Internal getLocStart_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang15FloatingLiteral9getLocEndEv")]
                internal static extern clang.SourceLocation.Internal getLocEnd_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang15FloatingLiteral7classofEPKNS_4StmtE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang15FloatingLiteral8childrenEv")]
                internal static extern void children_0(global::System.IntPtr @return, global::System.IntPtr instance);
            }

            private readonly bool __ownsNativeInstance;

            public static new FloatingLiteral __CreateInstance(global::System.IntPtr native)
            {
                return new FloatingLiteral((FloatingLiteral.Internal*) native);
            }

            public static FloatingLiteral __CreateInstance(FloatingLiteral.Internal native)
            {
                return new FloatingLiteral(native);
            }

            private static FloatingLiteral.Internal* __CopyValue(FloatingLiteral.Internal native)
            {
                var ret = (FloatingLiteral.Internal*) Marshal.AllocHGlobal(32);
                *ret = native;
                return ret;
            }

            private FloatingLiteral(FloatingLiteral.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected FloatingLiteral(FloatingLiteral.Internal* native, bool isInternalImpl = false)
                : base((clang.Expr.Internal*) native)
            {
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Stmt __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public llvm.APFloat getValue()
            {
                var __ret = new llvm.APFloat.Internal();
                Internal.getValue_0(new IntPtr(&__ret), __Instance);
                return llvm.APFloat.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Get a raw enumeration value representing the floating-point
            /// semantics of this literal (32-bit IEEE, x87, ...), suitable for
            /// serialisation.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Get a raw enumeration value representing the floating-point
            /// semantics of</para>
            /// <para>  /// this literal (32-bit IEEE, x87, ...), suitable for
            /// serialisation.</para>
            /// </remarks>
            public clang.Stmt.APFloatSemantics getRawSemantics()
            {
                var __ret = Internal.getRawSemantics_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Set the raw enumeration value representing the floating-point
            /// semantics of this literal (32-bit IEEE, x87, ...), suitable for
            /// serialisation.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Set the raw enumeration value representing the floating-point
            /// semantics of</para>
            /// <para>  /// this literal (32-bit IEEE, x87, ...), suitable for
            /// serialisation.</para>
            /// </remarks>
            public void setRawSemantics(clang.Stmt.APFloatSemantics Sem)
            {
                var arg0 = Sem;
                Internal.setRawSemantics_0(__Instance, arg0);
            }

            public bool isExact()
            {
                var __ret = Internal.isExact_0(__Instance);
                return __ret;
            }

            public void setExact(bool E)
            {
                Internal.setExact_0(__Instance, E);
            }

            /// <summary>
            /// <para>getValueAsApproximateDouble - This returns the value as an
            /// inaccurate double. Note that this may cause loss of precision, but is
            /// useful for debugging dumps, etc.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getValueAsApproximateDouble - This returns the value as an
            /// inaccurate</para>
            /// <para>  /// double.  Note that this may cause loss of precision, but is
            /// useful for</para>
            /// <para>  /// debugging dumps, etc.</para>
            /// </remarks>
            public double getValueAsApproximateDouble()
            {
                var __ret = Internal.getValueAsApproximateDouble_0(__Instance);
                return __ret;
            }

            public clang.SourceLocation getLocation()
            {
                var __ret = Internal.getLocation_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setLocation(clang.SourceLocation L)
            {
                var arg0 = ReferenceEquals(L, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (L.__Instance);
                Internal.setLocation_0(__Instance, arg0);
            }

            public clang.SourceLocation getLocStart()
            {
                var __ret = Internal.getLocStart_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLocEnd()
            {
                var __ret = Internal.getLocEnd_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.StmtRange children()
            {
                var __ret = new clang.StmtRange.Internal();
                Internal.children_0(new IntPtr(&__ret), __Instance);
                return clang.StmtRange.__CreateInstance(__ret);
            }

            public static bool classof(clang.Stmt T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>ImaginaryLiteral - We support imaginary integer and floating
        /// point literals, like &quot;1.0i&quot;. We represent these as a wrapper
        /// around FloatingLiteral and IntegerLiteral classes. Instances of this class
        /// always have a Complex type whose element type matches the
        /// subexpression.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// ImaginaryLiteral - We support imaginary integer and floating
        /// point literals,</para>
        /// <para>/// like &quot;1.0i&quot;.  We represent these as a wrapper
        /// around FloatingLiteral and</para>
        /// <para>/// IntegerLiteral classes.  Instances of this class always have
        /// a Complex type</para>
        /// <para>/// whose element type matches the subexpression.</para>
        /// <para>///</para>
        /// </remarks>
        public unsafe partial class ImaginaryLiteral : clang.Expr, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 24)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                internal clang.Stmt._.Internal __;

                [FieldOffset(8)]
                public clang.QualType.Internal TR;

                [FieldOffset(16)]
                public global::System.IntPtr Val;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16ImaginaryLiteralC2EPNS_4ExprENS_8QualTypeE")]
                internal static extern void ctor_0(global::System.IntPtr instance, global::System.IntPtr val, clang.QualType.Internal Ty);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16ImaginaryLiteralC2ENS_4Stmt10EmptyShellE")]
                internal static extern void ctor_1(global::System.IntPtr instance, clang.Stmt.EmptyShell.Internal Empty);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16ImaginaryLiteralC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16ImaginaryLiteral10getSubExprEv")]
                internal static extern global::System.IntPtr getSubExpr_1(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16ImaginaryLiteral10setSubExprEPNS_4ExprE")]
                internal static extern void setSubExpr_0(global::System.IntPtr instance, global::System.IntPtr E);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang16ImaginaryLiteral11getLocStartEv")]
                internal static extern clang.SourceLocation.Internal getLocStart_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang16ImaginaryLiteral9getLocEndEv")]
                internal static extern clang.SourceLocation.Internal getLocEnd_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16ImaginaryLiteral7classofEPKNS_4StmtE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16ImaginaryLiteral8childrenEv")]
                internal static extern void children_0(global::System.IntPtr @return, global::System.IntPtr instance);
            }

            private readonly bool __ownsNativeInstance;

            public static new ImaginaryLiteral __CreateInstance(global::System.IntPtr native)
            {
                return new ImaginaryLiteral((ImaginaryLiteral.Internal*) native);
            }

            public static ImaginaryLiteral __CreateInstance(ImaginaryLiteral.Internal native)
            {
                return new ImaginaryLiteral(native);
            }

            private static ImaginaryLiteral.Internal* __CopyValue(ImaginaryLiteral.Internal native)
            {
                var ret = (ImaginaryLiteral.Internal*) Marshal.AllocHGlobal(24);
                *ret = native;
                return ret;
            }

            private ImaginaryLiteral(ImaginaryLiteral.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected ImaginaryLiteral(ImaginaryLiteral.Internal* native, bool isInternalImpl = false)
                : base((clang.Expr.Internal*) native)
            {
            }

            public ImaginaryLiteral(clang.Expr val, clang.QualType Ty)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(24);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(val, null) ? global::System.IntPtr.Zero : val.__Instance;
                var arg1 = ReferenceEquals(Ty, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (Ty.__Instance);
                Internal.ctor_0(__Instance, arg0, arg1);
            }

            /// <summary>
            /// <para>Build an empty imaginary literal.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Build an empty imaginary literal.</para>
            /// </remarks>
            public ImaginaryLiteral(clang.Stmt.EmptyShell Empty)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(24);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(Empty, null) ? new clang.Stmt.EmptyShell.Internal() : *(clang.Stmt.EmptyShell.Internal*) (Empty.__Instance);
                Internal.ctor_1(__Instance, arg0);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Stmt __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.Expr getSubExpr()
            {
                var __ret = Internal.getSubExpr_1(__Instance);
                clang.Expr __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Expr.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Expr) clang.Expr.NativeToManagedMap[__ret];
                else __result0 = clang.Expr.__CreateInstance(__ret);
                return __result0;
            }

            public void setSubExpr(clang.Expr E)
            {
                var arg0 = ReferenceEquals(E, null) ? global::System.IntPtr.Zero : E.__Instance;
                Internal.setSubExpr_0(__Instance, arg0);
            }

            public clang.SourceLocation getLocStart()
            {
                var __ret = Internal.getLocStart_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLocEnd()
            {
                var __ret = Internal.getLocEnd_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.StmtRange children()
            {
                var __ret = new clang.StmtRange.Internal();
                Internal.children_0(new IntPtr(&__ret), __Instance);
                return clang.StmtRange.__CreateInstance(__ret);
            }

            public static bool classof(clang.Stmt T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>StringLiteral - This represents a string literal expression, e.g.
        /// &quot;foo&quot; or L&quot;bar&quot; (wide strings). The actual string is
        /// returned by getBytes() is NOT null-terminated, and the length of the string
        /// is determined by calling getByteLength(). The C type for a string is always
        /// a ConstantArrayType. In C++, the char type is const qualified, in C it is
        /// not.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// StringLiteral - This represents a string literal expression,
        /// e.g. &quot;foo&quot;</para>
        /// <para>/// or L&quot;bar&quot; (wide strings).  The actual string is
        /// returned by getBytes()</para>
        /// <para>/// is NOT null-terminated, and the length of the string is
        /// determined by</para>
        /// <para>/// calling getByteLength().  The C type for a string is always
        /// a</para>
        /// <para>/// ConstantArrayType.  In C++, the char type is const qualified,
        /// in C it is</para>
        /// <para>/// not.</para>
        /// <para>///</para>
        /// <para>/// Note that strings in C can be formed by concatenation of
        /// multiple string</para>
        /// <para>/// literal pptokens in translation phase #6.  This keeps track
        /// of the locations</para>
        /// <para>/// of each of these pieces.</para>
        /// <para>///</para>
        /// <para>/// Strings in C can also be truncated and extended by assigning
        /// into arrays,</para>
        /// <para>/// e.g. with constructs like:</para>
        /// <para>///   char X[2] = &quot;foobar&quot;;</para>
        /// <para>/// In this case, getByteLength() will return 6, but the string
        /// literal will</para>
        /// <para>/// have type &quot;char[2]&quot;.</para>
        /// </remarks>
        public unsafe partial class StringLiteral : clang.Expr, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 40)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                internal clang.Stmt._.Internal __;

                [FieldOffset(8)]
                public clang.QualType.Internal TR;

                [FieldOffset(16)]
                internal clang.StringLiteral._.Internal StrData;

                [FieldOffset(24)]
                public uint Length;

                [FieldOffset(28)]
                public uint CharByteWidth;

                [FieldOffset(28)]
                public uint Kind;

                [FieldOffset(28)]
                public uint IsPascal;

                [FieldOffset(32)]
                public uint NumConcatenated;

                [FieldOffset(36)]
                public fixed byte TokLocs[4];

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13StringLiteralC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13StringLiteral9getStringEv")]
                internal static extern llvm.StringRef.Internal getString_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13StringLiteral8getBytesEv")]
                internal static extern llvm.StringRef.Internal getBytes_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13StringLiteral12outputStringERN4llvm11raw_ostreamE")]
                internal static extern void outputString_0(global::System.IntPtr instance, global::System.IntPtr OS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13StringLiteral11getCodeUnitEm")]
                internal static extern uint getCodeUnit_0(global::System.IntPtr instance, ulong i);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13StringLiteral13getByteLengthEv")]
                internal static extern uint getByteLength_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13StringLiteral9getLengthEv")]
                internal static extern uint getLength_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13StringLiteral16getCharByteWidthEv")]
                internal static extern uint getCharByteWidth_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13StringLiteral7getKindEv")]
                internal static extern clang.StringLiteral.StringKind getKind_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13StringLiteral7isAsciiEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isAscii_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13StringLiteral6isWideEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isWide_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13StringLiteral6isUTF8Ev")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isUTF8_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13StringLiteral7isUTF16Ev")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isUTF16_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13StringLiteral7isUTF32Ev")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isUTF32_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13StringLiteral8isPascalEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isPascal_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13StringLiteral22containsNonAsciiOrNullEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool containsNonAsciiOrNull_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13StringLiteral18getNumConcatenatedEv")]
                internal static extern uint getNumConcatenated_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13StringLiteral14getStrTokenLocEj")]
                internal static extern clang.SourceLocation.Internal getStrTokenLoc_0(global::System.IntPtr instance, uint TokNum);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13StringLiteral14setStrTokenLocEjNS_14SourceLocationE")]
                internal static extern void setStrTokenLoc_0(global::System.IntPtr instance, uint TokNum, clang.SourceLocation.Internal L);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13StringLiteral12tokloc_beginEv")]
                internal static extern global::System.IntPtr tokloc_begin_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13StringLiteral10tokloc_endEv")]
                internal static extern global::System.IntPtr tokloc_end_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13StringLiteral11getLocStartEv")]
                internal static extern clang.SourceLocation.Internal getLocStart_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13StringLiteral9getLocEndEv")]
                internal static extern clang.SourceLocation.Internal getLocEnd_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13StringLiteral7classofEPKNS_4StmtE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13StringLiteral8childrenEv")]
                internal static extern void children_0(global::System.IntPtr @return, global::System.IntPtr instance);
            }

            public enum StringKind : uint
            {
                Ascii = 0,
                Wide = 1,
                UTF8 = 2,
                UTF16 = 3,
                UTF32 = 4
            }

            public class tokloc_iterator { }

            internal unsafe partial struct _
            {
                [StructLayout(LayoutKind.Explicit, Size = 8)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public global::System.IntPtr asChar;

                    [FieldOffset(0)]
                    public ushort* asUInt16;

                    [FieldOffset(0)]
                    public uint* asUInt32;
                }
            }

            private readonly bool __ownsNativeInstance;

            public static new StringLiteral __CreateInstance(global::System.IntPtr native)
            {
                return new StringLiteral((StringLiteral.Internal*) native);
            }

            public static StringLiteral __CreateInstance(StringLiteral.Internal native)
            {
                return new StringLiteral(native);
            }

            private static StringLiteral.Internal* __CopyValue(StringLiteral.Internal native)
            {
                var ret = (StringLiteral.Internal*) Marshal.AllocHGlobal(40);
                *ret = native;
                return ret;
            }

            private StringLiteral(StringLiteral.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected StringLiteral(StringLiteral.Internal* native, bool isInternalImpl = false)
                : base((clang.Expr.Internal*) native)
            {
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Stmt __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public llvm.StringRef getString()
            {
                var __ret = Internal.getString_0(__Instance);
                return llvm.StringRef.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Allow access to clients that need the byte representation, such
            /// as ASTWriterStmt::VisitStringLiteral().</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Allow access to clients that need the byte representation,
            /// such as</para>
            /// <para>  /// ASTWriterStmt::VisitStringLiteral().</para>
            /// </remarks>
            public llvm.StringRef getBytes()
            {
                var __ret = Internal.getBytes_0(__Instance);
                return llvm.StringRef.__CreateInstance(__ret);
            }

            public void outputString(llvm.raw_ostream OS)
            {
                var arg0 = ReferenceEquals(OS, null) ? global::System.IntPtr.Zero : OS.__Instance;
                Internal.outputString_0(__Instance, arg0);
            }

            public uint getCodeUnit(ulong i)
            {
                var arg0 = i;
                var __ret = Internal.getCodeUnit_0(__Instance, arg0);
                return __ret;
            }

            public uint getByteLength()
            {
                var __ret = Internal.getByteLength_0(__Instance);
                return __ret;
            }

            public uint getLength()
            {
                var __ret = Internal.getLength_0(__Instance);
                return __ret;
            }

            public uint getCharByteWidth()
            {
                var __ret = Internal.getCharByteWidth_0(__Instance);
                return __ret;
            }

            public clang.StringLiteral.StringKind getKind()
            {
                var __ret = Internal.getKind_0(__Instance);
                return __ret;
            }

            public bool isAscii()
            {
                var __ret = Internal.isAscii_0(__Instance);
                return __ret;
            }

            public bool isWide()
            {
                var __ret = Internal.isWide_0(__Instance);
                return __ret;
            }

            public bool isUTF8()
            {
                var __ret = Internal.isUTF8_0(__Instance);
                return __ret;
            }

            public bool isUTF16()
            {
                var __ret = Internal.isUTF16_0(__Instance);
                return __ret;
            }

            public bool isUTF32()
            {
                var __ret = Internal.isUTF32_0(__Instance);
                return __ret;
            }

            public bool isPascal()
            {
                var __ret = Internal.isPascal_0(__Instance);
                return __ret;
            }

            public bool containsNonAsciiOrNull()
            {
                var __ret = Internal.containsNonAsciiOrNull_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>getNumConcatenated - Get the number of string literal tokens that
            /// were concatenated in translation phase #6 to form this string
            /// literal.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getNumConcatenated - Get the number of string literal tokens
            /// that were</para>
            /// <para>  /// concatenated in translation phase #6 to form this string
            /// literal.</para>
            /// </remarks>
            public uint getNumConcatenated()
            {
                var __ret = Internal.getNumConcatenated_0(__Instance);
                return __ret;
            }

            public clang.SourceLocation getStrTokenLoc(uint TokNum)
            {
                var __ret = Internal.getStrTokenLoc_0(__Instance, TokNum);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setStrTokenLoc(uint TokNum, clang.SourceLocation L)
            {
                var arg1 = ReferenceEquals(L, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (L.__Instance);
                Internal.setStrTokenLoc_0(__Instance, TokNum, arg1);
            }

            public clang.SourceLocation tokloc_begin()
            {
                var __ret = Internal.tokloc_begin_0(__Instance);
                clang.SourceLocation __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.SourceLocation.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.SourceLocation) clang.SourceLocation.NativeToManagedMap[__ret];
                else __result0 = clang.SourceLocation.__CreateInstance(__ret);
                return __result0;
            }

            public clang.SourceLocation tokloc_end()
            {
                var __ret = Internal.tokloc_end_0(__Instance);
                clang.SourceLocation __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.SourceLocation.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.SourceLocation) clang.SourceLocation.NativeToManagedMap[__ret];
                else __result0 = clang.SourceLocation.__CreateInstance(__ret);
                return __result0;
            }

            public clang.SourceLocation getLocStart()
            {
                var __ret = Internal.getLocStart_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLocEnd()
            {
                var __ret = Internal.getLocEnd_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.StmtRange children()
            {
                var __ret = new clang.StmtRange.Internal();
                Internal.children_0(new IntPtr(&__ret), __Instance);
                return clang.StmtRange.__CreateInstance(__ret);
            }

            public static bool classof(clang.Stmt T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>ParenExpr - This represents a parethesized expression, e.g.
        /// &quot;(1)&quot;. This AST node is only formed if full location information
        /// is requested.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// ParenExpr - This represents a parethesized expression, e.g.
        /// &quot;(1)&quot;.  This</para>
        /// <para>/// AST node is only formed if full location information is
        /// requested.</para>
        /// </remarks>
        public unsafe partial class ParenExpr : clang.Expr, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 32)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                internal clang.Stmt._.Internal __;

                [FieldOffset(8)]
                public clang.QualType.Internal TR;

                [FieldOffset(16)]
                public clang.SourceLocation.Internal L;

                [FieldOffset(20)]
                public clang.SourceLocation.Internal R;

                [FieldOffset(24)]
                public global::System.IntPtr Val;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9ParenExprC2ENS_14SourceLocationES1_PNS_4ExprE")]
                internal static extern void ctor_0(global::System.IntPtr instance, clang.SourceLocation.Internal l, clang.SourceLocation.Internal r, global::System.IntPtr val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9ParenExprC2ENS_4Stmt10EmptyShellE")]
                internal static extern void ctor_1(global::System.IntPtr instance, clang.Stmt.EmptyShell.Internal Empty);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9ParenExprC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9ParenExpr10getSubExprEv")]
                internal static extern global::System.IntPtr getSubExpr_1(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9ParenExpr10setSubExprEPNS_4ExprE")]
                internal static extern void setSubExpr_0(global::System.IntPtr instance, global::System.IntPtr E);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9ParenExpr11getLocStartEv")]
                internal static extern clang.SourceLocation.Internal getLocStart_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9ParenExpr9getLocEndEv")]
                internal static extern clang.SourceLocation.Internal getLocEnd_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9ParenExpr9getLParenEv")]
                internal static extern clang.SourceLocation.Internal getLParen_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9ParenExpr9setLParenENS_14SourceLocationE")]
                internal static extern void setLParen_0(global::System.IntPtr instance, clang.SourceLocation.Internal Loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9ParenExpr9getRParenEv")]
                internal static extern clang.SourceLocation.Internal getRParen_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9ParenExpr9setRParenENS_14SourceLocationE")]
                internal static extern void setRParen_0(global::System.IntPtr instance, clang.SourceLocation.Internal Loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9ParenExpr7classofEPKNS_4StmtE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9ParenExpr8childrenEv")]
                internal static extern void children_0(global::System.IntPtr @return, global::System.IntPtr instance);
            }

            private readonly bool __ownsNativeInstance;

            public static new ParenExpr __CreateInstance(global::System.IntPtr native)
            {
                return new ParenExpr((ParenExpr.Internal*) native);
            }

            public static ParenExpr __CreateInstance(ParenExpr.Internal native)
            {
                return new ParenExpr(native);
            }

            private static ParenExpr.Internal* __CopyValue(ParenExpr.Internal native)
            {
                var ret = (ParenExpr.Internal*) Marshal.AllocHGlobal(32);
                *ret = native;
                return ret;
            }

            private ParenExpr(ParenExpr.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected ParenExpr(ParenExpr.Internal* native, bool isInternalImpl = false)
                : base((clang.Expr.Internal*) native)
            {
            }

            public ParenExpr(clang.SourceLocation l, clang.SourceLocation r, clang.Expr val)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(32);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(l, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (l.__Instance);
                var arg1 = ReferenceEquals(r, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (r.__Instance);
                var arg2 = ReferenceEquals(val, null) ? global::System.IntPtr.Zero : val.__Instance;
                Internal.ctor_0(__Instance, arg0, arg1, arg2);
            }

            /// <summary>
            /// <para>Construct an empty parenthesized expression.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Construct an empty parenthesized expression.</para>
            /// </remarks>
            public ParenExpr(clang.Stmt.EmptyShell Empty)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(32);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(Empty, null) ? new clang.Stmt.EmptyShell.Internal() : *(clang.Stmt.EmptyShell.Internal*) (Empty.__Instance);
                Internal.ctor_1(__Instance, arg0);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Stmt __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.Expr getSubExpr()
            {
                var __ret = Internal.getSubExpr_1(__Instance);
                clang.Expr __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Expr.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Expr) clang.Expr.NativeToManagedMap[__ret];
                else __result0 = clang.Expr.__CreateInstance(__ret);
                return __result0;
            }

            public void setSubExpr(clang.Expr E)
            {
                var arg0 = ReferenceEquals(E, null) ? global::System.IntPtr.Zero : E.__Instance;
                Internal.setSubExpr_0(__Instance, arg0);
            }

            public clang.SourceLocation getLocStart()
            {
                var __ret = Internal.getLocStart_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLocEnd()
            {
                var __ret = Internal.getLocEnd_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Get the location of the left parentheses '('.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Get the location of the left parentheses '('.</para>
            /// </remarks>
            public clang.SourceLocation getLParen()
            {
                var __ret = Internal.getLParen_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setLParen(clang.SourceLocation Loc)
            {
                var arg0 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                Internal.setLParen_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>Get the location of the right parentheses ')'.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Get the location of the right parentheses ')'.</para>
            /// </remarks>
            public clang.SourceLocation getRParen()
            {
                var __ret = Internal.getRParen_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setRParen(clang.SourceLocation Loc)
            {
                var arg0 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                Internal.setRParen_0(__Instance, arg0);
            }

            public clang.StmtRange children()
            {
                var __ret = new clang.StmtRange.Internal();
                Internal.children_0(new IntPtr(&__ret), __Instance);
                return clang.StmtRange.__CreateInstance(__ret);
            }

            public static bool classof(clang.Stmt T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>UnaryOperator - This represents the unary-expression's (except
        /// sizeof and alignof), the postinc/postdec operators from postfix-expression,
        /// and various extensions.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// UnaryOperator - This represents the unary-expression's
        /// (except sizeof and</para>
        /// <para>/// alignof), the postinc/postdec operators from
        /// postfix-expression, and various</para>
        /// <para>/// extensions.</para>
        /// <para>///</para>
        /// <para>/// Notes on various nodes:</para>
        /// <para>///</para>
        /// <para>/// Real/Imag - These return the real/imag part of a complex
        /// operand.  If</para>
        /// <para>///   applied to a non-complex value, the former returns its
        /// operand and the</para>
        /// <para>///   later returns zero in the type of the operand.</para>
        /// <para>///</para>
        /// </remarks>
        public unsafe partial class UnaryOperator : clang.Expr, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 32)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                internal clang.Stmt._.Internal __;

                [FieldOffset(8)]
                public clang.QualType.Internal TR;

                [FieldOffset(16)]
                public uint Opc;

                [FieldOffset(20)]
                public clang.SourceLocation.Internal Loc;

                [FieldOffset(24)]
                public global::System.IntPtr Val;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13UnaryOperatorC2EPNS_4ExprENS_17UnaryOperatorKindENS_8QualTypeENS_13ExprValueKindENS_14ExprObjectKindENS_14SourceLocationE")]
                internal static extern void ctor_0(global::System.IntPtr instance, global::System.IntPtr input, clang.UnaryOperatorKind opc, clang.QualType.Internal type, clang.ExprValueKind VK, clang.ExprObjectKind OK, clang.SourceLocation.Internal l);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13UnaryOperatorC2ENS_4Stmt10EmptyShellE")]
                internal static extern void ctor_1(global::System.IntPtr instance, clang.Stmt.EmptyShell.Internal Empty);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13UnaryOperatorC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13UnaryOperator9getOpcodeEv")]
                internal static extern clang.UnaryOperatorKind getOpcode_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13UnaryOperator9setOpcodeENS_17UnaryOperatorKindE")]
                internal static extern void setOpcode_0(global::System.IntPtr instance, clang.UnaryOperatorKind O);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13UnaryOperator10getSubExprEv")]
                internal static extern global::System.IntPtr getSubExpr_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13UnaryOperator10setSubExprEPNS_4ExprE")]
                internal static extern void setSubExpr_0(global::System.IntPtr instance, global::System.IntPtr E);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13UnaryOperator14getOperatorLocEv")]
                internal static extern clang.SourceLocation.Internal getOperatorLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13UnaryOperator14setOperatorLocENS_14SourceLocationE")]
                internal static extern void setOperatorLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal L);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13UnaryOperator9isPostfixENS_17UnaryOperatorKindE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isPostfix_0(clang.UnaryOperatorKind Op);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13UnaryOperator8isPrefixENS_17UnaryOperatorKindE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isPrefix_0(clang.UnaryOperatorKind Op);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13UnaryOperator8isPrefixEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isPrefix_1(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13UnaryOperator9isPostfixEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isPostfix_1(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13UnaryOperator13isIncrementOpENS_17UnaryOperatorKindE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isIncrementOp_0(clang.UnaryOperatorKind Op);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13UnaryOperator13isIncrementOpEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isIncrementOp_1(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13UnaryOperator13isDecrementOpENS_17UnaryOperatorKindE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isDecrementOp_0(clang.UnaryOperatorKind Op);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13UnaryOperator13isDecrementOpEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isDecrementOp_1(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13UnaryOperator22isIncrementDecrementOpENS_17UnaryOperatorKindE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isIncrementDecrementOp_0(clang.UnaryOperatorKind Op);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13UnaryOperator22isIncrementDecrementOpEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isIncrementDecrementOp_1(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13UnaryOperator14isArithmeticOpENS_17UnaryOperatorKindE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isArithmeticOp_0(clang.UnaryOperatorKind Op);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13UnaryOperator14isArithmeticOpEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isArithmeticOp_1(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13UnaryOperator12getOpcodeStrENS_17UnaryOperatorKindE")]
                internal static extern llvm.StringRef.Internal getOpcodeStr_0(clang.UnaryOperatorKind Op);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13UnaryOperator19getOverloadedOpcodeENS_22OverloadedOperatorKindEb")]
                internal static extern clang.UnaryOperatorKind getOverloadedOpcode_0(clang.OverloadedOperatorKind OO, bool Postfix);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13UnaryOperator21getOverloadedOperatorENS_17UnaryOperatorKindE")]
                internal static extern clang.OverloadedOperatorKind getOverloadedOperator_0(clang.UnaryOperatorKind Opc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13UnaryOperator11getLocStartEv")]
                internal static extern clang.SourceLocation.Internal getLocStart_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13UnaryOperator9getLocEndEv")]
                internal static extern clang.SourceLocation.Internal getLocEnd_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13UnaryOperator10getExprLocEv")]
                internal static extern clang.SourceLocation.Internal getExprLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13UnaryOperator7classofEPKNS_4StmtE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13UnaryOperator8childrenEv")]
                internal static extern void children_0(global::System.IntPtr @return, global::System.IntPtr instance);
            }

            private readonly bool __ownsNativeInstance;

            public static new UnaryOperator __CreateInstance(global::System.IntPtr native)
            {
                return new UnaryOperator((UnaryOperator.Internal*) native);
            }

            public static UnaryOperator __CreateInstance(UnaryOperator.Internal native)
            {
                return new UnaryOperator(native);
            }

            private static UnaryOperator.Internal* __CopyValue(UnaryOperator.Internal native)
            {
                var ret = (UnaryOperator.Internal*) Marshal.AllocHGlobal(32);
                *ret = native;
                return ret;
            }

            private UnaryOperator(UnaryOperator.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected UnaryOperator(UnaryOperator.Internal* native, bool isInternalImpl = false)
                : base((clang.Expr.Internal*) native)
            {
            }

            public UnaryOperator(clang.Expr input, clang.UnaryOperatorKind opc, clang.QualType type, clang.ExprValueKind VK, clang.ExprObjectKind OK, clang.SourceLocation l)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(32);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(input, null) ? global::System.IntPtr.Zero : input.__Instance;
                var arg1 = opc;
                var arg2 = ReferenceEquals(type, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (type.__Instance);
                var arg3 = VK;
                var arg4 = OK;
                var arg5 = ReferenceEquals(l, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (l.__Instance);
                Internal.ctor_0(__Instance, arg0, arg1, arg2, arg3, arg4, arg5);
            }

            /// <summary>
            /// <para>Build an empty unary operator.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Build an empty unary operator.</para>
            /// </remarks>
            public UnaryOperator(clang.Stmt.EmptyShell Empty)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(32);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(Empty, null) ? new clang.Stmt.EmptyShell.Internal() : *(clang.Stmt.EmptyShell.Internal*) (Empty.__Instance);
                Internal.ctor_1(__Instance, arg0);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Stmt __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.UnaryOperatorKind getOpcode()
            {
                var __ret = Internal.getOpcode_0(__Instance);
                return __ret;
            }

            public void setOpcode(clang.UnaryOperatorKind O)
            {
                var arg0 = O;
                Internal.setOpcode_0(__Instance, arg0);
            }

            public clang.Expr getSubExpr()
            {
                var __ret = Internal.getSubExpr_0(__Instance);
                clang.Expr __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Expr.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Expr) clang.Expr.NativeToManagedMap[__ret];
                else __result0 = clang.Expr.__CreateInstance(__ret);
                return __result0;
            }

            public void setSubExpr(clang.Expr E)
            {
                var arg0 = ReferenceEquals(E, null) ? global::System.IntPtr.Zero : E.__Instance;
                Internal.setSubExpr_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>getOperatorLoc - Return the location of the operator.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getOperatorLoc - Return the location of the operator.</para>
            /// </remarks>
            public clang.SourceLocation getOperatorLoc()
            {
                var __ret = Internal.getOperatorLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setOperatorLoc(clang.SourceLocation L)
            {
                var arg0 = ReferenceEquals(L, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (L.__Instance);
                Internal.setOperatorLoc_0(__Instance, arg0);
            }

            public bool isPrefix()
            {
                var __ret = Internal.isPrefix_1(__Instance);
                return __ret;
            }

            public bool isPostfix()
            {
                var __ret = Internal.isPostfix_1(__Instance);
                return __ret;
            }

            public bool isIncrementOp()
            {
                var __ret = Internal.isIncrementOp_1(__Instance);
                return __ret;
            }

            public bool isDecrementOp()
            {
                var __ret = Internal.isDecrementOp_1(__Instance);
                return __ret;
            }

            public bool isIncrementDecrementOp()
            {
                var __ret = Internal.isIncrementDecrementOp_1(__Instance);
                return __ret;
            }

            public bool isArithmeticOp()
            {
                var __ret = Internal.isArithmeticOp_1(__Instance);
                return __ret;
            }

            public clang.SourceLocation getLocStart()
            {
                var __ret = Internal.getLocStart_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLocEnd()
            {
                var __ret = Internal.getLocEnd_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getExprLoc()
            {
                var __ret = Internal.getExprLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.StmtRange children()
            {
                var __ret = new clang.StmtRange.Internal();
                Internal.children_0(new IntPtr(&__ret), __Instance);
                return clang.StmtRange.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>isPostfix - Return true if this is a postfix operation, like
            /// x++.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// isPostfix - Return true if this is a postfix operation, like
            /// x++.</para>
            /// </remarks>
            public static bool isPostfix(clang.UnaryOperatorKind Op)
            {
                var arg0 = Op;
                var __ret = Internal.isPostfix_0(arg0);
                return __ret;
            }

            /// <summary>
            /// <para>isPrefix - Return true if this is a prefix operation, like
            /// --x.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// isPrefix - Return true if this is a prefix operation, like
            /// --x.</para>
            /// </remarks>
            public static bool isPrefix(clang.UnaryOperatorKind Op)
            {
                var arg0 = Op;
                var __ret = Internal.isPrefix_0(arg0);
                return __ret;
            }

            public static bool isIncrementOp(clang.UnaryOperatorKind Op)
            {
                var arg0 = Op;
                var __ret = Internal.isIncrementOp_0(arg0);
                return __ret;
            }

            public static bool isDecrementOp(clang.UnaryOperatorKind Op)
            {
                var arg0 = Op;
                var __ret = Internal.isDecrementOp_0(arg0);
                return __ret;
            }

            public static bool isIncrementDecrementOp(clang.UnaryOperatorKind Op)
            {
                var arg0 = Op;
                var __ret = Internal.isIncrementDecrementOp_0(arg0);
                return __ret;
            }

            public static bool isArithmeticOp(clang.UnaryOperatorKind Op)
            {
                var arg0 = Op;
                var __ret = Internal.isArithmeticOp_0(arg0);
                return __ret;
            }

            /// <summary>
            /// <para>getOpcodeStr - Turn an Opcode enum value into the punctuation
            /// char it corresponds to, e.g. &quot;sizeof&quot; or
            /// &quot;[pre]++&quot;</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getOpcodeStr - Turn an Opcode enum value into the punctuation
            /// char it</para>
            /// <para>  /// corresponds to, e.g. &quot;sizeof&quot; or
            /// &quot;[pre]++&quot;</para>
            /// </remarks>
            public static llvm.StringRef getOpcodeStr(clang.UnaryOperatorKind Op)
            {
                var arg0 = Op;
                var __ret = Internal.getOpcodeStr_0(arg0);
                return llvm.StringRef.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Retrieve the unary opcode that corresponds to the given
            /// overloaded operator.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the unary opcode that corresponds to the
            /// given</para>
            /// <para>  /// overloaded operator.</para>
            /// </remarks>
            public static clang.UnaryOperatorKind getOverloadedOpcode(clang.OverloadedOperatorKind OO, bool Postfix)
            {
                var arg0 = OO;
                var __ret = Internal.getOverloadedOpcode_0(arg0, Postfix);
                return __ret;
            }

            /// <summary>
            /// <para>Retrieve the overloaded operator kind that corresponds to the
            /// given unary opcode.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the overloaded operator kind that corresponds
            /// to</para>
            /// <para>  /// the given unary opcode.</para>
            /// </remarks>
            public static clang.OverloadedOperatorKind getOverloadedOperator(clang.UnaryOperatorKind Opc)
            {
                var arg0 = Opc;
                var __ret = Internal.getOverloadedOperator_0(arg0);
                return __ret;
            }

            public static bool classof(clang.Stmt T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>OffsetOfExpr - [C99 7.17] - This represents an expression of the
        /// form offsetof(record-type, member-designator). For example, given: we can
        /// represent and evaluate the expression offsetof(struct T, s[2].d).</para>
        /// </summary>
        /// <remarks>
        /// <para>/// OffsetOfExpr - [C99 7.17] - This represents an expression of
        /// the form</para>
        /// <para>/// offsetof(record-type, member-designator). For example,
        /// given:</para>
        /// <para>/// @code</para>
        /// <para>/// struct S {</para>
        /// <para>///   float f;</para>
        /// <para>///   double d;</para>
        /// <para>/// };</para>
        /// <para>/// struct T {</para>
        /// <para>///   int i;</para>
        /// <para>///   struct S s[10];</para>
        /// <para>/// };</para>
        /// <para>/// @endcode</para>
        /// <para>/// we can represent and evaluate the expression @c
        /// offsetof(struct T, s[2].d).</para>
        /// </remarks>
        public unsafe partial class OffsetOfExpr : clang.Expr, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 40)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                internal clang.Stmt._.Internal __;

                [FieldOffset(8)]
                public clang.QualType.Internal TR;

                [FieldOffset(16)]
                public clang.SourceLocation.Internal OperatorLoc;

                [FieldOffset(20)]
                public clang.SourceLocation.Internal RParenLoc;

                [FieldOffset(24)]
                public global::System.IntPtr TSInfo;

                [FieldOffset(32)]
                public uint NumComps;

                [FieldOffset(36)]
                public uint NumExprs;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12OffsetOfExprC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12OffsetOfExpr14getOperatorLocEv")]
                internal static extern clang.SourceLocation.Internal getOperatorLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12OffsetOfExpr14setOperatorLocENS_14SourceLocationE")]
                internal static extern void setOperatorLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal L);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12OffsetOfExpr12getRParenLocEv")]
                internal static extern clang.SourceLocation.Internal getRParenLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12OffsetOfExpr12setRParenLocENS_14SourceLocationE")]
                internal static extern void setRParenLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal R);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12OffsetOfExpr17getTypeSourceInfoEv")]
                internal static extern global::System.IntPtr getTypeSourceInfo_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12OffsetOfExpr17setTypeSourceInfoEPNS_14TypeSourceInfoE")]
                internal static extern void setTypeSourceInfo_0(global::System.IntPtr instance, global::System.IntPtr tsi);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12OffsetOfExpr12getComponentEj")]
                internal static extern global::System.IntPtr getComponent_0(global::System.IntPtr instance, uint Idx);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12OffsetOfExpr12setComponentEjNS0_12OffsetOfNodeE")]
                internal static extern void setComponent_0(global::System.IntPtr instance, uint Idx, clang.OffsetOfExpr.OffsetOfNode.Internal ON);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12OffsetOfExpr16getNumComponentsEv")]
                internal static extern uint getNumComponents_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12OffsetOfExpr12getIndexExprEj")]
                internal static extern global::System.IntPtr getIndexExpr_0(global::System.IntPtr instance, uint Idx);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12OffsetOfExpr12setIndexExprEjPNS_4ExprE")]
                internal static extern void setIndexExpr_0(global::System.IntPtr instance, uint Idx, global::System.IntPtr E);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12OffsetOfExpr17getNumExpressionsEv")]
                internal static extern uint getNumExpressions_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12OffsetOfExpr11getLocStartEv")]
                internal static extern clang.SourceLocation.Internal getLocStart_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12OffsetOfExpr9getLocEndEv")]
                internal static extern clang.SourceLocation.Internal getLocEnd_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12OffsetOfExpr7classofEPKNS_4StmtE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12OffsetOfExpr8childrenEv")]
                internal static extern void children_0(global::System.IntPtr @return, global::System.IntPtr instance);
            }

            public unsafe partial class OffsetOfNode : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 16)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public clang.SourceRange.Internal Range;

                    [FieldOffset(8)]
                    public ulong Data;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang12OffsetOfExpr12OffsetOfNodeC2ENS_14SourceLocationEjS2_")]
                    internal static extern void ctor_0(global::System.IntPtr instance, clang.SourceLocation.Internal LBracketLoc, uint Index, clang.SourceLocation.Internal RBracketLoc);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang12OffsetOfExpr12OffsetOfNodeC2ENS_14SourceLocationEPNS_9FieldDeclES2_")]
                    internal static extern void ctor_1(global::System.IntPtr instance, clang.SourceLocation.Internal DotLoc, global::System.IntPtr Field, clang.SourceLocation.Internal NameLoc);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang12OffsetOfExpr12OffsetOfNodeC2ENS_14SourceLocationEPNS_14IdentifierInfoES2_")]
                    internal static extern void ctor_2(global::System.IntPtr instance, clang.SourceLocation.Internal DotLoc, global::System.IntPtr Name, clang.SourceLocation.Internal NameLoc);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang12OffsetOfExpr12OffsetOfNodeC2ERKS1_")]
                    internal static extern void cctor_4(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang12OffsetOfExpr12OffsetOfNode7getKindEv")]
                    internal static extern clang.OffsetOfExpr.OffsetOfNode.Kind getKind_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang12OffsetOfExpr12OffsetOfNode17getArrayExprIndexEv")]
                    internal static extern uint getArrayExprIndex_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang12OffsetOfExpr12OffsetOfNode8getFieldEv")]
                    internal static extern global::System.IntPtr getField_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang12OffsetOfExpr12OffsetOfNode12getFieldNameEv")]
                    internal static extern global::System.IntPtr getFieldName_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang12OffsetOfExpr12OffsetOfNode14getSourceRangeEv")]
                    internal static extern clang.SourceRange.Internal getSourceRange_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang12OffsetOfExpr12OffsetOfNode11getLocStartEv")]
                    internal static extern clang.SourceLocation.Internal getLocStart_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang12OffsetOfExpr12OffsetOfNode9getLocEndEv")]
                    internal static extern clang.SourceLocation.Internal getLocEnd_0(global::System.IntPtr instance);
                }

                /// <summary>
                /// <para>The kind of offsetof node we have.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief The kind of offsetof node we have.</para>
                /// </remarks>
                public enum Kind : uint
                {
                    /// <summary>An index into an array.</summary>
                    Array = 0x0,
                    /// <summary>A field.</summary>
                    Field = 0x1,
                    /// <summary>A field in a dependent type, known only by its name.</summary>
                    Identifier = 0x2,
                    /// <summary>An implicit indirection through a C++ base class, when the field found is in a base class.</summary>
                    Base = 0x3
                }

                public global::System.IntPtr __Instance { get; protected set; }
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, OffsetOfNode> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, OffsetOfNode>();

                private readonly bool __ownsNativeInstance;

                public static OffsetOfNode __CreateInstance(global::System.IntPtr native)
                {
                    return new OffsetOfNode((OffsetOfNode.Internal*) native);
                }

                public static OffsetOfNode __CreateInstance(OffsetOfNode.Internal native)
                {
                    return new OffsetOfNode(native);
                }

                private static OffsetOfNode.Internal* __CopyValue(OffsetOfNode.Internal native)
                {
                    var ret = (OffsetOfNode.Internal*) Marshal.AllocHGlobal(16);
                    *ret = native;
                    return ret;
                }

                private OffsetOfNode(OffsetOfNode.Internal native)
                    : this(__CopyValue(native))
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected OffsetOfNode(OffsetOfNode.Internal* native, bool isInternalImpl = false)
                {
                    __Instance = new global::System.IntPtr(native);
                }

                /// <summary>
                /// <para>Create an offsetof node that refers to an array element.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Create an offsetof node that refers to an array
                /// element.</para>
                /// </remarks>
                public OffsetOfNode(clang.SourceLocation LBracketLoc, uint Index, clang.SourceLocation RBracketLoc)
                {
                    __Instance = Marshal.AllocHGlobal(16);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    var arg0 = ReferenceEquals(LBracketLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (LBracketLoc.__Instance);
                    var arg2 = ReferenceEquals(RBracketLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (RBracketLoc.__Instance);
                    Internal.ctor_0(__Instance, arg0, Index, arg2);
                }

                /// <summary>
                /// <para>Create an offsetof node that refers to a field.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Create an offsetof node that refers to a field.</para>
                /// </remarks>
                public OffsetOfNode(clang.SourceLocation DotLoc, clang.FieldDecl Field, clang.SourceLocation NameLoc)
                {
                    __Instance = Marshal.AllocHGlobal(16);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    var arg0 = ReferenceEquals(DotLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (DotLoc.__Instance);
                    var arg1 = ReferenceEquals(Field, null) ? global::System.IntPtr.Zero : Field.__Instance;
                    var arg2 = ReferenceEquals(NameLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (NameLoc.__Instance);
                    Internal.ctor_1(__Instance, arg0, arg1, arg2);
                }

                /// <summary>
                /// <para>Create an offsetof node that refers to an identifier.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Create an offsetof node that refers to an
                /// identifier.</para>
                /// </remarks>
                public OffsetOfNode(clang.SourceLocation DotLoc, clang.IdentifierInfo Name, clang.SourceLocation NameLoc)
                {
                    __Instance = Marshal.AllocHGlobal(16);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    var arg0 = ReferenceEquals(DotLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (DotLoc.__Instance);
                    var arg1 = ReferenceEquals(Name, null) ? global::System.IntPtr.Zero : Name.__Instance;
                    var arg2 = ReferenceEquals(NameLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (NameLoc.__Instance);
                    Internal.ctor_2(__Instance, arg0, arg1, arg2);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    DestroyNativeInstance(false);
                }

                public virtual void DestroyNativeInstance()
                {
                    DestroyNativeInstance(true);
                }

                private void DestroyNativeInstance(bool force)
                {
                    clang.OffsetOfExpr.OffsetOfNode __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                /// <summary>
                /// <para>Determine what kind of offsetof node this is.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Determine what kind of offsetof node this is.</para>
                /// </remarks>
                public clang.OffsetOfExpr.OffsetOfNode.Kind getKind()
                {
                    var __ret = Internal.getKind_0(__Instance);
                    return __ret;
                }

                /// <summary>
                /// <para>For an array element node, returns the index into the array of
                /// expressions.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief For an array element node, returns the index into the
                /// array</para>
                /// <para>    /// of expressions.</para>
                /// </remarks>
                public uint getArrayExprIndex()
                {
                    var __ret = Internal.getArrayExprIndex_0(__Instance);
                    return __ret;
                }

                /// <summary>
                /// <para>For a field offsetof node, returns the field.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief For a field offsetof node, returns the field.</para>
                /// </remarks>
                public clang.FieldDecl getField()
                {
                    var __ret = Internal.getField_0(__Instance);
                    clang.FieldDecl __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (clang.FieldDecl.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (clang.FieldDecl) clang.FieldDecl.NativeToManagedMap[__ret];
                    else clang.FieldDecl.NativeToManagedMap[__ret] = __result0 = (clang.FieldDecl) clang.FieldDecl.__CreateInstance(__ret);
                    return __result0;
                }

                /// <summary>
                /// <para>For a field or identifier offsetof node, returns the name of the
                /// field.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief For a field or identifier offsetof node, returns the
                /// name of</para>
                /// <para>    /// the field.</para>
                /// </remarks>
                public clang.IdentifierInfo getFieldName()
                {
                    var __ret = Internal.getFieldName_0(__Instance);
                    clang.IdentifierInfo __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (clang.IdentifierInfo.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (clang.IdentifierInfo) clang.IdentifierInfo.NativeToManagedMap[__ret];
                    else __result0 = clang.IdentifierInfo.__CreateInstance(__ret);
                    return __result0;
                }

                /// <summary>
                /// <para>Retrieve the source range that covers this offsetof node.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Retrieve the source range that covers this offsetof
                /// node.</para>
                /// <para>    ///</para>
                /// <para>    /// For an array element node, the source range contains the
                /// locations of</para>
                /// <para>    /// the square brackets. For a field or identifier node, the
                /// source range</para>
                /// <para>    /// contains the location of the period (if there is one) and
                /// the</para>
                /// <para>    /// identifier.</para>
                /// </remarks>
                public clang.SourceRange getSourceRange()
                {
                    var __ret = Internal.getSourceRange_0(__Instance);
                    return clang.SourceRange.__CreateInstance(__ret);
                }

                public clang.SourceLocation getLocStart()
                {
                    var __ret = Internal.getLocStart_0(__Instance);
                    return clang.SourceLocation.__CreateInstance(__ret);
                }

                public clang.SourceLocation getLocEnd()
                {
                    var __ret = Internal.getLocEnd_0(__Instance);
                    return clang.SourceLocation.__CreateInstance(__ret);
                }
            }

            private readonly bool __ownsNativeInstance;

            public static new OffsetOfExpr __CreateInstance(global::System.IntPtr native)
            {
                return new OffsetOfExpr((OffsetOfExpr.Internal*) native);
            }

            public static OffsetOfExpr __CreateInstance(OffsetOfExpr.Internal native)
            {
                return new OffsetOfExpr(native);
            }

            private static OffsetOfExpr.Internal* __CopyValue(OffsetOfExpr.Internal native)
            {
                var ret = (OffsetOfExpr.Internal*) Marshal.AllocHGlobal(40);
                *ret = native;
                return ret;
            }

            private OffsetOfExpr(OffsetOfExpr.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected OffsetOfExpr(OffsetOfExpr.Internal* native, bool isInternalImpl = false)
                : base((clang.Expr.Internal*) native)
            {
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Stmt __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            /// <summary>
            /// <para>getOperatorLoc - Return the location of the operator.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getOperatorLoc - Return the location of the operator.</para>
            /// </remarks>
            public clang.SourceLocation getOperatorLoc()
            {
                var __ret = Internal.getOperatorLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setOperatorLoc(clang.SourceLocation L)
            {
                var arg0 = ReferenceEquals(L, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (L.__Instance);
                Internal.setOperatorLoc_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>Return the location of the right parentheses.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the location of the right parentheses.</para>
            /// </remarks>
            public clang.SourceLocation getRParenLoc()
            {
                var __ret = Internal.getRParenLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setRParenLoc(clang.SourceLocation R)
            {
                var arg0 = ReferenceEquals(R, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (R.__Instance);
                Internal.setRParenLoc_0(__Instance, arg0);
            }

            public clang.TypeSourceInfo getTypeSourceInfo()
            {
                var __ret = Internal.getTypeSourceInfo_0(__Instance);
                clang.TypeSourceInfo __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.TypeSourceInfo.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.TypeSourceInfo) clang.TypeSourceInfo.NativeToManagedMap[__ret];
                else __result0 = clang.TypeSourceInfo.__CreateInstance(__ret);
                return __result0;
            }

            public void setTypeSourceInfo(clang.TypeSourceInfo tsi)
            {
                var arg0 = ReferenceEquals(tsi, null) ? global::System.IntPtr.Zero : tsi.__Instance;
                Internal.setTypeSourceInfo_0(__Instance, arg0);
            }

            public clang.OffsetOfExpr.OffsetOfNode getComponent(uint Idx)
            {
                var __ret = Internal.getComponent_0(__Instance, Idx);
                clang.OffsetOfExpr.OffsetOfNode __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.OffsetOfExpr.OffsetOfNode.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.OffsetOfExpr.OffsetOfNode) clang.OffsetOfExpr.OffsetOfNode.NativeToManagedMap[__ret];
                else __result0 = clang.OffsetOfExpr.OffsetOfNode.__CreateInstance(__ret);
                return __result0;
            }

            public void setComponent(uint Idx, clang.OffsetOfExpr.OffsetOfNode ON)
            {
                var arg1 = ReferenceEquals(ON, null) ? new clang.OffsetOfExpr.OffsetOfNode.Internal() : *(clang.OffsetOfExpr.OffsetOfNode.Internal*) (ON.__Instance);
                Internal.setComponent_0(__Instance, Idx, arg1);
            }

            public uint getNumComponents()
            {
                var __ret = Internal.getNumComponents_0(__Instance);
                return __ret;
            }

            public clang.Expr getIndexExpr(uint Idx)
            {
                var __ret = Internal.getIndexExpr_0(__Instance, Idx);
                clang.Expr __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Expr.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Expr) clang.Expr.NativeToManagedMap[__ret];
                else __result0 = clang.Expr.__CreateInstance(__ret);
                return __result0;
            }

            public void setIndexExpr(uint Idx, clang.Expr E)
            {
                var arg1 = ReferenceEquals(E, null) ? global::System.IntPtr.Zero : E.__Instance;
                Internal.setIndexExpr_0(__Instance, Idx, arg1);
            }

            public uint getNumExpressions()
            {
                var __ret = Internal.getNumExpressions_0(__Instance);
                return __ret;
            }

            public clang.SourceLocation getLocStart()
            {
                var __ret = Internal.getLocStart_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLocEnd()
            {
                var __ret = Internal.getLocEnd_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.StmtRange children()
            {
                var __ret = new clang.StmtRange.Internal();
                Internal.children_0(new IntPtr(&__ret), __Instance);
                return clang.StmtRange.__CreateInstance(__ret);
            }

            public static bool classof(clang.Stmt T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>UnaryExprOrTypeTraitExpr - expression with either a type or
        /// (unevaluated) expression operand. Used for sizeof/alignof (C99 6.5.3.4) and
        /// vec_step (OpenCL 1.1 6.11.12).</para>
        /// </summary>
        /// <remarks>
        /// <para>/// UnaryExprOrTypeTraitExpr - expression with either a type or
        /// (unevaluated)</para>
        /// <para>/// expression operand.  Used for sizeof/alignof (C99 6.5.3.4)
        /// and</para>
        /// <para>/// vec_step (OpenCL 1.1 6.11.12).</para>
        /// </remarks>
        public unsafe partial class UnaryExprOrTypeTraitExpr : clang.Expr, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 32)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                internal clang.Stmt._.Internal __;

                [FieldOffset(8)]
                public clang.QualType.Internal TR;

                [FieldOffset(16)]
                internal clang.UnaryExprOrTypeTraitExpr._.Internal Argument;

                [FieldOffset(24)]
                public clang.SourceLocation.Internal OpLoc;

                [FieldOffset(28)]
                public clang.SourceLocation.Internal RParenLoc;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang24UnaryExprOrTypeTraitExprC2ENS_20UnaryExprOrTypeTraitEPNS_14TypeSourceInfoENS_8QualTypeENS_14SourceLocationES5_")]
                internal static extern void ctor_0(global::System.IntPtr instance, clang.UnaryExprOrTypeTrait ExprKind, global::System.IntPtr TInfo, clang.QualType.Internal resultType, clang.SourceLocation.Internal op, clang.SourceLocation.Internal rp);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang24UnaryExprOrTypeTraitExprC2ENS_20UnaryExprOrTypeTraitEPNS_4ExprENS_8QualTypeENS_14SourceLocationES5_")]
                internal static extern void ctor_1(global::System.IntPtr instance, clang.UnaryExprOrTypeTrait ExprKind, global::System.IntPtr E, clang.QualType.Internal resultType, clang.SourceLocation.Internal op, clang.SourceLocation.Internal rp);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang24UnaryExprOrTypeTraitExprC2ENS_4Stmt10EmptyShellE")]
                internal static extern void ctor_2(global::System.IntPtr instance, clang.Stmt.EmptyShell.Internal Empty);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang24UnaryExprOrTypeTraitExprC2ERKS0_")]
                internal static extern void cctor_3(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang24UnaryExprOrTypeTraitExpr7getKindEv")]
                internal static extern clang.UnaryExprOrTypeTrait getKind_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang24UnaryExprOrTypeTraitExpr7setKindENS_20UnaryExprOrTypeTraitE")]
                internal static extern void setKind_0(global::System.IntPtr instance, clang.UnaryExprOrTypeTrait K);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang24UnaryExprOrTypeTraitExpr14isArgumentTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isArgumentType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang24UnaryExprOrTypeTraitExpr15getArgumentTypeEv")]
                internal static extern clang.QualType.Internal getArgumentType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang24UnaryExprOrTypeTraitExpr19getArgumentTypeInfoEv")]
                internal static extern global::System.IntPtr getArgumentTypeInfo_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang24UnaryExprOrTypeTraitExpr15getArgumentExprEv")]
                internal static extern global::System.IntPtr getArgumentExpr_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang24UnaryExprOrTypeTraitExpr11setArgumentEPNS_4ExprE")]
                internal static extern void setArgument_0(global::System.IntPtr instance, global::System.IntPtr E);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang24UnaryExprOrTypeTraitExpr11setArgumentEPNS_14TypeSourceInfoE")]
                internal static extern void setArgument_1(global::System.IntPtr instance, global::System.IntPtr TInfo);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang24UnaryExprOrTypeTraitExpr17getTypeOfArgumentEv")]
                internal static extern clang.QualType.Internal getTypeOfArgument_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang24UnaryExprOrTypeTraitExpr14getOperatorLocEv")]
                internal static extern clang.SourceLocation.Internal getOperatorLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang24UnaryExprOrTypeTraitExpr14setOperatorLocENS_14SourceLocationE")]
                internal static extern void setOperatorLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal L);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang24UnaryExprOrTypeTraitExpr12getRParenLocEv")]
                internal static extern clang.SourceLocation.Internal getRParenLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang24UnaryExprOrTypeTraitExpr12setRParenLocENS_14SourceLocationE")]
                internal static extern void setRParenLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal L);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang24UnaryExprOrTypeTraitExpr11getLocStartEv")]
                internal static extern clang.SourceLocation.Internal getLocStart_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang24UnaryExprOrTypeTraitExpr9getLocEndEv")]
                internal static extern clang.SourceLocation.Internal getLocEnd_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang24UnaryExprOrTypeTraitExpr7classofEPKNS_4StmtE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang24UnaryExprOrTypeTraitExpr8childrenEv")]
                internal static extern void children_0(global::System.IntPtr @return, global::System.IntPtr instance);
            }

            internal unsafe partial struct _
            {
                [StructLayout(LayoutKind.Explicit, Size = 8)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public global::System.IntPtr Ty;

                    [FieldOffset(0)]
                    public global::System.IntPtr Ex;
                }
            }

            private readonly bool __ownsNativeInstance;

            public static new UnaryExprOrTypeTraitExpr __CreateInstance(global::System.IntPtr native)
            {
                return new UnaryExprOrTypeTraitExpr((UnaryExprOrTypeTraitExpr.Internal*) native);
            }

            public static UnaryExprOrTypeTraitExpr __CreateInstance(UnaryExprOrTypeTraitExpr.Internal native)
            {
                return new UnaryExprOrTypeTraitExpr(native);
            }

            private static UnaryExprOrTypeTraitExpr.Internal* __CopyValue(UnaryExprOrTypeTraitExpr.Internal native)
            {
                var ret = (UnaryExprOrTypeTraitExpr.Internal*) Marshal.AllocHGlobal(32);
                *ret = native;
                return ret;
            }

            private UnaryExprOrTypeTraitExpr(UnaryExprOrTypeTraitExpr.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected UnaryExprOrTypeTraitExpr(UnaryExprOrTypeTraitExpr.Internal* native, bool isInternalImpl = false)
                : base((clang.Expr.Internal*) native)
            {
            }

            public UnaryExprOrTypeTraitExpr(clang.UnaryExprOrTypeTrait ExprKind, clang.TypeSourceInfo TInfo, clang.QualType resultType, clang.SourceLocation op, clang.SourceLocation rp)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(32);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ExprKind;
                var arg1 = ReferenceEquals(TInfo, null) ? global::System.IntPtr.Zero : TInfo.__Instance;
                var arg2 = ReferenceEquals(resultType, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (resultType.__Instance);
                var arg3 = ReferenceEquals(op, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (op.__Instance);
                var arg4 = ReferenceEquals(rp, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (rp.__Instance);
                Internal.ctor_0(__Instance, arg0, arg1, arg2, arg3, arg4);
            }

            public UnaryExprOrTypeTraitExpr(clang.UnaryExprOrTypeTrait ExprKind, clang.Expr E, clang.QualType resultType, clang.SourceLocation op, clang.SourceLocation rp)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(32);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ExprKind;
                var arg1 = ReferenceEquals(E, null) ? global::System.IntPtr.Zero : E.__Instance;
                var arg2 = ReferenceEquals(resultType, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (resultType.__Instance);
                var arg3 = ReferenceEquals(op, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (op.__Instance);
                var arg4 = ReferenceEquals(rp, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (rp.__Instance);
                Internal.ctor_1(__Instance, arg0, arg1, arg2, arg3, arg4);
            }

            /// <summary>
            /// <para>Construct an empty sizeof/alignof expression.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Construct an empty sizeof/alignof expression.</para>
            /// </remarks>
            public UnaryExprOrTypeTraitExpr(clang.Stmt.EmptyShell Empty)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(32);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(Empty, null) ? new clang.Stmt.EmptyShell.Internal() : *(clang.Stmt.EmptyShell.Internal*) (Empty.__Instance);
                Internal.ctor_2(__Instance, arg0);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Stmt __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.UnaryExprOrTypeTrait getKind()
            {
                var __ret = Internal.getKind_0(__Instance);
                return __ret;
            }

            public void setKind(clang.UnaryExprOrTypeTrait K)
            {
                var arg0 = K;
                Internal.setKind_0(__Instance, arg0);
            }

            public bool isArgumentType()
            {
                var __ret = Internal.isArgumentType_0(__Instance);
                return __ret;
            }

            public clang.QualType getArgumentType()
            {
                var __ret = Internal.getArgumentType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            public clang.TypeSourceInfo getArgumentTypeInfo()
            {
                var __ret = Internal.getArgumentTypeInfo_0(__Instance);
                clang.TypeSourceInfo __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.TypeSourceInfo.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.TypeSourceInfo) clang.TypeSourceInfo.NativeToManagedMap[__ret];
                else __result0 = clang.TypeSourceInfo.__CreateInstance(__ret);
                return __result0;
            }

            public clang.Expr getArgumentExpr()
            {
                var __ret = Internal.getArgumentExpr_0(__Instance);
                clang.Expr __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Expr.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Expr) clang.Expr.NativeToManagedMap[__ret];
                else __result0 = clang.Expr.__CreateInstance(__ret);
                return __result0;
            }

            public void setArgument(clang.Expr E)
            {
                var arg0 = ReferenceEquals(E, null) ? global::System.IntPtr.Zero : E.__Instance;
                Internal.setArgument_0(__Instance, arg0);
            }

            public void setArgument(clang.TypeSourceInfo TInfo)
            {
                var arg0 = ReferenceEquals(TInfo, null) ? global::System.IntPtr.Zero : TInfo.__Instance;
                Internal.setArgument_1(__Instance, arg0);
            }

            /// <summary>
            /// <para>Gets the argument type, or the type of the argument expression,
            /// whichever is appropriate.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Gets the argument type, or the type of the argument
            /// expression, whichever</para>
            /// <para>  /// is appropriate.</para>
            /// </remarks>
            public clang.QualType getTypeOfArgument()
            {
                var __ret = Internal.getTypeOfArgument_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            public clang.SourceLocation getOperatorLoc()
            {
                var __ret = Internal.getOperatorLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setOperatorLoc(clang.SourceLocation L)
            {
                var arg0 = ReferenceEquals(L, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (L.__Instance);
                Internal.setOperatorLoc_0(__Instance, arg0);
            }

            public clang.SourceLocation getRParenLoc()
            {
                var __ret = Internal.getRParenLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setRParenLoc(clang.SourceLocation L)
            {
                var arg0 = ReferenceEquals(L, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (L.__Instance);
                Internal.setRParenLoc_0(__Instance, arg0);
            }

            public clang.SourceLocation getLocStart()
            {
                var __ret = Internal.getLocStart_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLocEnd()
            {
                var __ret = Internal.getLocEnd_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.StmtRange children()
            {
                var __ret = new clang.StmtRange.Internal();
                Internal.children_0(new IntPtr(&__ret), __Instance);
                return clang.StmtRange.__CreateInstance(__ret);
            }

            public static bool classof(clang.Stmt T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>ArraySubscriptExpr - [C99 6.5.2.1] Array Subscripting.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// ArraySubscriptExpr - [C99 6.5.2.1] Array Subscripting.</para>
        /// </remarks>
        public unsafe partial class ArraySubscriptExpr : clang.Expr, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 40)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                internal clang.Stmt._.Internal __;

                [FieldOffset(8)]
                public clang.QualType.Internal TR;

                [FieldOffset(16)]
                public fixed global::System.IntPtr SubExprs[2];

                [FieldOffset(32)]
                public clang.SourceLocation.Internal RBracketLoc;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang18ArraySubscriptExprC2EPNS_4ExprES2_NS_8QualTypeENS_13ExprValueKindENS_14ExprObjectKindENS_14SourceLocationE")]
                internal static extern void ctor_0(global::System.IntPtr instance, global::System.IntPtr lhs, global::System.IntPtr rhs, clang.QualType.Internal t, clang.ExprValueKind VK, clang.ExprObjectKind OK, clang.SourceLocation.Internal rbracketloc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang18ArraySubscriptExprC2ENS_4Stmt10EmptyShellE")]
                internal static extern void ctor_1(global::System.IntPtr instance, clang.Stmt.EmptyShell.Internal Shell);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang18ArraySubscriptExprC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang18ArraySubscriptExpr6getLHSEv")]
                internal static extern global::System.IntPtr getLHS_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang18ArraySubscriptExpr6setLHSEPNS_4ExprE")]
                internal static extern void setLHS_0(global::System.IntPtr instance, global::System.IntPtr E);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang18ArraySubscriptExpr6getRHSEv")]
                internal static extern global::System.IntPtr getRHS_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang18ArraySubscriptExpr6setRHSEPNS_4ExprE")]
                internal static extern void setRHS_0(global::System.IntPtr instance, global::System.IntPtr E);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang18ArraySubscriptExpr7getBaseEv")]
                internal static extern global::System.IntPtr getBase_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang18ArraySubscriptExpr6getIdxEv")]
                internal static extern global::System.IntPtr getIdx_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang18ArraySubscriptExpr11getLocStartEv")]
                internal static extern clang.SourceLocation.Internal getLocStart_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang18ArraySubscriptExpr9getLocEndEv")]
                internal static extern clang.SourceLocation.Internal getLocEnd_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang18ArraySubscriptExpr14getRBracketLocEv")]
                internal static extern clang.SourceLocation.Internal getRBracketLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang18ArraySubscriptExpr14setRBracketLocENS_14SourceLocationE")]
                internal static extern void setRBracketLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal L);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang18ArraySubscriptExpr10getExprLocEv")]
                internal static extern clang.SourceLocation.Internal getExprLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang18ArraySubscriptExpr7classofEPKNS_4StmtE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang18ArraySubscriptExpr8childrenEv")]
                internal static extern void children_0(global::System.IntPtr @return, global::System.IntPtr instance);
            }

            private readonly bool __ownsNativeInstance;

            public static new ArraySubscriptExpr __CreateInstance(global::System.IntPtr native)
            {
                return new ArraySubscriptExpr((ArraySubscriptExpr.Internal*) native);
            }

            public static ArraySubscriptExpr __CreateInstance(ArraySubscriptExpr.Internal native)
            {
                return new ArraySubscriptExpr(native);
            }

            private static ArraySubscriptExpr.Internal* __CopyValue(ArraySubscriptExpr.Internal native)
            {
                var ret = (ArraySubscriptExpr.Internal*) Marshal.AllocHGlobal(40);
                *ret = native;
                return ret;
            }

            private ArraySubscriptExpr(ArraySubscriptExpr.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected ArraySubscriptExpr(ArraySubscriptExpr.Internal* native, bool isInternalImpl = false)
                : base((clang.Expr.Internal*) native)
            {
            }

            public ArraySubscriptExpr(clang.Expr lhs, clang.Expr rhs, clang.QualType t, clang.ExprValueKind VK, clang.ExprObjectKind OK, clang.SourceLocation rbracketloc)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(40);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(lhs, null) ? global::System.IntPtr.Zero : lhs.__Instance;
                var arg1 = ReferenceEquals(rhs, null) ? global::System.IntPtr.Zero : rhs.__Instance;
                var arg2 = ReferenceEquals(t, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (t.__Instance);
                var arg3 = VK;
                var arg4 = OK;
                var arg5 = ReferenceEquals(rbracketloc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (rbracketloc.__Instance);
                Internal.ctor_0(__Instance, arg0, arg1, arg2, arg3, arg4, arg5);
            }

            /// <summary>
            /// <para>Create an empty array subscript expression.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Create an empty array subscript expression.</para>
            /// </remarks>
            public ArraySubscriptExpr(clang.Stmt.EmptyShell Shell)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(40);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(Shell, null) ? new clang.Stmt.EmptyShell.Internal() : *(clang.Stmt.EmptyShell.Internal*) (Shell.__Instance);
                Internal.ctor_1(__Instance, arg0);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Stmt __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            /// <summary>
            /// <para>An array access can be written A[4] or 4[A] (both are
            /// equivalent). - getBase() and getIdx() always present the normalized view:
            /// A[4]. In this case getBase() returns &quot;A&quot; and getIdx() returns
            /// &quot;4&quot;. - getLHS() and getRHS() present the syntactic view. e.g. for
            /// 4[A] getLHS() returns &quot;4&quot;. Note: Because vector element access is
            /// also written A[4] we must predicate the format conversion in getBase and
            /// getIdx only on the the type of the RHS, as it is possible for the LHS to be
            /// a vector of integer type</para>
            /// </summary>
            /// <remarks>
            /// <para>/// An array access can be written A[4] or 4[A] (both are
            /// equivalent).</para>
            /// <para>  /// - getBase() and getIdx() always present the normalized
            /// view: A[4].</para>
            /// <para>  ///    In this case getBase() returns &quot;A&quot; and
            /// getIdx() returns &quot;4&quot;.</para>
            /// <para>  /// - getLHS() and getRHS() present the syntactic view. e.g.
            /// for</para>
            /// <para>  ///    4[A] getLHS() returns &quot;4&quot;.</para>
            /// <para>  /// Note: Because vector element access is also written A[4] we
            /// must</para>
            /// <para>  /// predicate the format conversion in getBase and getIdx only
            /// on the</para>
            /// <para>  /// the type of the RHS, as it is possible for the LHS to be a
            /// vector of</para>
            /// <para>  /// integer type</para>
            /// </remarks>
            public clang.Expr getLHS()
            {
                var __ret = Internal.getLHS_0(__Instance);
                clang.Expr __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Expr.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Expr) clang.Expr.NativeToManagedMap[__ret];
                else __result0 = clang.Expr.__CreateInstance(__ret);
                return __result0;
            }

            public void setLHS(clang.Expr E)
            {
                var arg0 = ReferenceEquals(E, null) ? global::System.IntPtr.Zero : E.__Instance;
                Internal.setLHS_0(__Instance, arg0);
            }

            public clang.Expr getRHS()
            {
                var __ret = Internal.getRHS_0(__Instance);
                clang.Expr __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Expr.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Expr) clang.Expr.NativeToManagedMap[__ret];
                else __result0 = clang.Expr.__CreateInstance(__ret);
                return __result0;
            }

            public void setRHS(clang.Expr E)
            {
                var arg0 = ReferenceEquals(E, null) ? global::System.IntPtr.Zero : E.__Instance;
                Internal.setRHS_0(__Instance, arg0);
            }

            public clang.Expr getBase()
            {
                var __ret = Internal.getBase_0(__Instance);
                clang.Expr __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Expr.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Expr) clang.Expr.NativeToManagedMap[__ret];
                else __result0 = clang.Expr.__CreateInstance(__ret);
                return __result0;
            }

            public clang.Expr getIdx()
            {
                var __ret = Internal.getIdx_0(__Instance);
                clang.Expr __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Expr.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Expr) clang.Expr.NativeToManagedMap[__ret];
                else __result0 = clang.Expr.__CreateInstance(__ret);
                return __result0;
            }

            public clang.SourceLocation getLocStart()
            {
                var __ret = Internal.getLocStart_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLocEnd()
            {
                var __ret = Internal.getLocEnd_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getRBracketLoc()
            {
                var __ret = Internal.getRBracketLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setRBracketLoc(clang.SourceLocation L)
            {
                var arg0 = ReferenceEquals(L, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (L.__Instance);
                Internal.setRBracketLoc_0(__Instance, arg0);
            }

            public clang.SourceLocation getExprLoc()
            {
                var __ret = Internal.getExprLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.StmtRange children()
            {
                var __ret = new clang.StmtRange.Internal();
                Internal.children_0(new IntPtr(&__ret), __Instance);
                return clang.StmtRange.__CreateInstance(__ret);
            }

            public static bool classof(clang.Stmt T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>CallExpr - Represents a function call (C99 6.5.2.2, C++
        /// [expr.call]). CallExpr itself represents a normal function call, e.g.,
        /// &quot;f(x, 2)&quot;, while its subclasses may represent alternative syntax
        /// that (semantically) results in a function call. For example,
        /// CXXOperatorCallExpr is a subclass for overloaded operator calls that use
        /// operator syntax, e.g., &quot;str1 + str2&quot; to resolve to a function
        /// call.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// CallExpr - Represents a function call (C99 6.5.2.2, C++
        /// [expr.call]).</para>
        /// <para>/// CallExpr itself represents a normal function call, e.g.,
        /// &quot;f(x, 2)&quot;,</para>
        /// <para>/// while its subclasses may represent alternative syntax that
        /// (semantically)</para>
        /// <para>/// results in a function call. For example, CXXOperatorCallExpr
        /// is</para>
        /// <para>/// a subclass for overloaded operator calls that use operator
        /// syntax, e.g.,</para>
        /// <para>/// &quot;str1 + str2&quot; to resolve to a function call.</para>
        /// </remarks>
        public unsafe partial class CallExpr : clang.Expr, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 32)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                internal clang.Stmt._.Internal __;

                [FieldOffset(8)]
                public clang.QualType.Internal TR;

                [FieldOffset(16)]
                public global::System.IntPtr SubExprs;

                [FieldOffset(24)]
                public uint NumArgs;

                [FieldOffset(28)]
                public clang.SourceLocation.Internal RParenLoc;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8CallExprC2ERKS0_")]
                internal static extern void cctor_4(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8CallExpr9getPreArgEj")]
                internal static extern global::System.IntPtr getPreArg_0(global::System.IntPtr instance, uint i);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8CallExpr9setPreArgEjPNS_4StmtE")]
                internal static extern void setPreArg_0(global::System.IntPtr instance, uint i, global::System.IntPtr PreArg);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8CallExpr13getNumPreArgsEv")]
                internal static extern uint getNumPreArgs_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8CallExpr9getCalleeEv")]
                internal static extern global::System.IntPtr getCallee_1(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8CallExpr9setCalleeEPNS_4ExprE")]
                internal static extern void setCallee_0(global::System.IntPtr instance, global::System.IntPtr F);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8CallExpr13getCalleeDeclEv")]
                internal static extern global::System.IntPtr getCalleeDecl_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8CallExpr15getDirectCalleeEv")]
                internal static extern global::System.IntPtr getDirectCallee_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8CallExpr10getNumArgsEv")]
                internal static extern uint getNumArgs_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8CallExpr7getArgsEv")]
                internal static extern global::System.IntPtr getArgs_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8CallExpr6getArgEj")]
                internal static extern global::System.IntPtr getArg_0(global::System.IntPtr instance, uint Arg);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8CallExpr6setArgEjPNS_4ExprE")]
                internal static extern void setArg_0(global::System.IntPtr instance, uint Arg, global::System.IntPtr ArgExpr);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8CallExpr9arg_beginEv")]
                internal static extern clang.ExprIterator.Internal arg_begin_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8CallExpr7arg_endEv")]
                internal static extern clang.ExprIterator.Internal arg_end_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8CallExpr12getNumCommasEv")]
                internal static extern uint getNumCommas_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8CallExpr16getBuiltinCalleeEv")]
                internal static extern uint getBuiltinCallee_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8CallExpr17getCallReturnTypeEv")]
                internal static extern clang.QualType.Internal getCallReturnType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8CallExpr12getRParenLocEv")]
                internal static extern clang.SourceLocation.Internal getRParenLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8CallExpr12setRParenLocENS_14SourceLocationE")]
                internal static extern void setRParenLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal L);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8CallExpr11getLocStartEv")]
                internal static extern clang.SourceLocation.Internal getLocStart_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8CallExpr9getLocEndEv")]
                internal static extern clang.SourceLocation.Internal getLocEnd_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8CallExpr7classofEPKNS_4StmtE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8CallExpr8childrenEv")]
                internal static extern void children_0(global::System.IntPtr @return, global::System.IntPtr instance);
            }

            private readonly bool __ownsNativeInstance;

            public static new CallExpr __CreateInstance(global::System.IntPtr native)
            {
                return new CallExpr((CallExpr.Internal*) native);
            }

            public static CallExpr __CreateInstance(CallExpr.Internal native)
            {
                return new CallExpr(native);
            }

            private static CallExpr.Internal* __CopyValue(CallExpr.Internal native)
            {
                var ret = (CallExpr.Internal*) Marshal.AllocHGlobal(32);
                *ret = native;
                return ret;
            }

            private CallExpr(CallExpr.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected CallExpr(CallExpr.Internal* native, bool isInternalImpl = false)
                : base((clang.Expr.Internal*) native)
            {
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Stmt __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            protected clang.Stmt getPreArg(uint i)
            {
                var __ret = Internal.getPreArg_0(__Instance, i);
                clang.Stmt __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Stmt.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Stmt) clang.Stmt.NativeToManagedMap[__ret];
                else __result0 = clang.Stmt.__CreateInstance(__ret);
                return __result0;
            }

            protected void setPreArg(uint i, clang.Stmt PreArg)
            {
                var arg1 = ReferenceEquals(PreArg, null) ? global::System.IntPtr.Zero : PreArg.__Instance;
                Internal.setPreArg_0(__Instance, i, arg1);
            }

            protected uint getNumPreArgs()
            {
                var __ret = Internal.getNumPreArgs_0(__Instance);
                return __ret;
            }

            public clang.Expr getCallee()
            {
                var __ret = Internal.getCallee_1(__Instance);
                clang.Expr __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Expr.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Expr) clang.Expr.NativeToManagedMap[__ret];
                else __result0 = clang.Expr.__CreateInstance(__ret);
                return __result0;
            }

            public void setCallee(clang.Expr F)
            {
                var arg0 = ReferenceEquals(F, null) ? global::System.IntPtr.Zero : F.__Instance;
                Internal.setCallee_0(__Instance, arg0);
            }

            public clang.Decl getCalleeDecl()
            {
                var __ret = Internal.getCalleeDecl_0(__Instance);
                clang.Decl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Decl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Decl) clang.Decl.NativeToManagedMap[__ret];
                else clang.Decl.NativeToManagedMap[__ret] = __result0 = (clang.Decl) clang.Decl.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>If the callee is a FunctionDecl, return it. Otherwise return
            /// 0.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief If the callee is a FunctionDecl, return it. Otherwise
            /// return 0.</para>
            /// </remarks>
            public clang.FunctionDecl getDirectCallee()
            {
                var __ret = Internal.getDirectCallee_0(__Instance);
                clang.FunctionDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.FunctionDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.FunctionDecl) clang.FunctionDecl.NativeToManagedMap[__ret];
                else clang.FunctionDecl.NativeToManagedMap[__ret] = __result0 = (clang.FunctionDecl) clang.FunctionDecl.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>getNumArgs - Return the number of actual arguments to this
            /// call.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getNumArgs - Return the number of actual arguments to this
            /// call.</para>
            /// <para>  ///</para>
            /// </remarks>
            public uint getNumArgs()
            {
                var __ret = Internal.getNumArgs_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Retrieve the call arguments.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the call arguments.</para>
            /// </remarks>
            public clang.Expr getArgs()
            {
                var __ret = Internal.getArgs_0(__Instance);
                clang.Expr __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Expr.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Expr) clang.Expr.NativeToManagedMap[__ret];
                else __result0 = clang.Expr.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>getArg - Return the specified argument.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getArg - Return the specified argument.</para>
            /// </remarks>
            public clang.Expr getArg(uint Arg)
            {
                var __ret = Internal.getArg_0(__Instance, Arg);
                clang.Expr __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Expr.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Expr) clang.Expr.NativeToManagedMap[__ret];
                else __result0 = clang.Expr.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>setArg - Set the specified argument.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// setArg - Set the specified argument.</para>
            /// </remarks>
            public void setArg(uint Arg, clang.Expr ArgExpr)
            {
                var arg1 = ReferenceEquals(ArgExpr, null) ? global::System.IntPtr.Zero : ArgExpr.__Instance;
                Internal.setArg_0(__Instance, Arg, arg1);
            }

            public clang.ExprIterator arg_begin()
            {
                var __ret = Internal.arg_begin_0(__Instance);
                return clang.ExprIterator.__CreateInstance(__ret);
            }

            public clang.ExprIterator arg_end()
            {
                var __ret = Internal.arg_end_0(__Instance);
                return clang.ExprIterator.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>getNumCommas - Return the number of commas that must have been
            /// present in this function call.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getNumCommas - Return the number of commas that must have
            /// been present in</para>
            /// <para>  /// this function call.</para>
            /// </remarks>
            public uint getNumCommas()
            {
                var __ret = Internal.getNumCommas_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>getBuiltinCallee - If this is a call to a builtin, return the
            /// builtin ID of the callee. If not, return 0.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getBuiltinCallee - If this is a call to a builtin, return the
            /// builtin ID</para>
            /// <para>  /// of the callee. If not, return 0.</para>
            /// </remarks>
            public uint getBuiltinCallee()
            {
                var __ret = Internal.getBuiltinCallee_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>getCallReturnType - Get the return type of the call expr. This is
            /// not always the type of the expr itself, if the return type is a reference
            /// type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getCallReturnType - Get the return type of the call expr.
            /// This is not</para>
            /// <para>  /// always the type of the expr itself, if the return type is a
            /// reference</para>
            /// <para>  /// type.</para>
            /// </remarks>
            public clang.QualType getCallReturnType()
            {
                var __ret = Internal.getCallReturnType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            public clang.SourceLocation getRParenLoc()
            {
                var __ret = Internal.getRParenLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setRParenLoc(clang.SourceLocation L)
            {
                var arg0 = ReferenceEquals(L, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (L.__Instance);
                Internal.setRParenLoc_0(__Instance, arg0);
            }

            public clang.SourceLocation getLocStart()
            {
                var __ret = Internal.getLocStart_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLocEnd()
            {
                var __ret = Internal.getLocEnd_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.StmtRange children()
            {
                var __ret = new clang.StmtRange.Internal();
                Internal.children_0(new IntPtr(&__ret), __Instance);
                return clang.StmtRange.__CreateInstance(__ret);
            }

            public static bool classof(clang.Stmt T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>MemberExpr - [C99 6.5.2.3] Structure and Union Members. X-&gt;F
        /// and X.F.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// MemberExpr - [C99 6.5.2.3] Structure and Union Members.
        /// X-&gt;F and X.F.</para>
        /// <para>///</para>
        /// </remarks>
        public unsafe partial class MemberExpr : clang.Expr, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 48)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                internal clang.Stmt._.Internal __;

                [FieldOffset(8)]
                public clang.QualType.Internal TR;

                [FieldOffset(16)]
                public global::System.IntPtr Base;

                [FieldOffset(24)]
                public global::System.IntPtr MemberDecl;

                [FieldOffset(32)]
                public clang.DeclarationNameLoc.Internal MemberDNLoc;

                [FieldOffset(40)]
                public clang.SourceLocation.Internal MemberLoc;

                [FieldOffset(44)]
                public bool IsArrow;

                [FieldOffset(44)]
                public bool HasQualifierOrFoundDecl;

                [FieldOffset(44)]
                public bool HasTemplateKWAndArgsInfo;

                [FieldOffset(44)]
                public bool HadMultipleCandidates;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10MemberExprC2EPNS_4ExprEbPNS_9ValueDeclERKNS_19DeclarationNameInfoENS_8QualTypeENS_13ExprValueKindENS_14ExprObjectKindE")]
                internal static extern void ctor_0(global::System.IntPtr instance, global::System.IntPtr @base, bool isarrow, global::System.IntPtr memberdecl, global::System.IntPtr NameInfo, clang.QualType.Internal ty, clang.ExprValueKind VK, clang.ExprObjectKind OK);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10MemberExprC2EPNS_4ExprEbPNS_9ValueDeclENS_14SourceLocationENS_8QualTypeENS_13ExprValueKindENS_14ExprObjectKindE")]
                internal static extern void ctor_1(global::System.IntPtr instance, global::System.IntPtr @base, bool isarrow, global::System.IntPtr memberdecl, clang.SourceLocation.Internal l, clang.QualType.Internal ty, clang.ExprValueKind VK, clang.ExprObjectKind OK);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10MemberExprC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10MemberExpr7setBaseEPNS_4ExprE")]
                internal static extern void setBase_0(global::System.IntPtr instance, global::System.IntPtr E);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10MemberExpr7getBaseEv")]
                internal static extern global::System.IntPtr getBase_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10MemberExpr13getMemberDeclEv")]
                internal static extern global::System.IntPtr getMemberDecl_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10MemberExpr13setMemberDeclEPNS_9ValueDeclE")]
                internal static extern void setMemberDecl_0(global::System.IntPtr instance, global::System.IntPtr D);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10MemberExpr12getFoundDeclEv")]
                internal static extern clang.DeclAccessPair.Internal getFoundDecl_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10MemberExpr12hasQualifierEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasQualifier_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10MemberExpr12getQualifierEv")]
                internal static extern global::System.IntPtr getQualifier_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10MemberExpr15getQualifierLocEv")]
                internal static extern clang.NestedNameSpecifierLoc.Internal getQualifierLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10MemberExpr24getTemplateKWAndArgsInfoEv")]
                internal static extern global::System.IntPtr getTemplateKWAndArgsInfo_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10MemberExpr21getTemplateKeywordLocEv")]
                internal static extern clang.SourceLocation.Internal getTemplateKeywordLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10MemberExpr12getLAngleLocEv")]
                internal static extern clang.SourceLocation.Internal getLAngleLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10MemberExpr12getRAngleLocEv")]
                internal static extern clang.SourceLocation.Internal getRAngleLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10MemberExpr18hasTemplateKeywordEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasTemplateKeyword_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10MemberExpr23hasExplicitTemplateArgsEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasExplicitTemplateArgs_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10MemberExpr25copyTemplateArgumentsIntoERNS_24TemplateArgumentListInfoE")]
                internal static extern void copyTemplateArgumentsInto_0(global::System.IntPtr instance, global::System.IntPtr List);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10MemberExpr23getExplicitTemplateArgsEv")]
                internal static extern global::System.IntPtr getExplicitTemplateArgs_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10MemberExpr31getOptionalExplicitTemplateArgsEv")]
                internal static extern global::System.IntPtr getOptionalExplicitTemplateArgs_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10MemberExpr15getTemplateArgsEv")]
                internal static extern global::System.IntPtr getTemplateArgs_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10MemberExpr18getNumTemplateArgsEv")]
                internal static extern uint getNumTemplateArgs_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10MemberExpr17getMemberNameInfoEv")]
                internal static extern void getMemberNameInfo_0(global::System.IntPtr @return, global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10MemberExpr7isArrowEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isArrow_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10MemberExpr8setArrowEb")]
                internal static extern void setArrow_0(global::System.IntPtr instance, bool A);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10MemberExpr12getMemberLocEv")]
                internal static extern clang.SourceLocation.Internal getMemberLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10MemberExpr12setMemberLocENS_14SourceLocationE")]
                internal static extern void setMemberLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal L);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10MemberExpr11getLocStartEv")]
                internal static extern clang.SourceLocation.Internal getLocStart_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10MemberExpr9getLocEndEv")]
                internal static extern clang.SourceLocation.Internal getLocEnd_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10MemberExpr10getExprLocEv")]
                internal static extern clang.SourceLocation.Internal getExprLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10MemberExpr16isImplicitAccessEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isImplicitAccess_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10MemberExpr21hadMultipleCandidatesEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hadMultipleCandidates_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10MemberExpr24setHadMultipleCandidatesEb")]
                internal static extern void setHadMultipleCandidates_0(global::System.IntPtr instance, bool V);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10MemberExpr7classofEPKNS_4StmtE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10MemberExpr8childrenEv")]
                internal static extern void children_0(global::System.IntPtr @return, global::System.IntPtr instance);
            }

            /// <summary>
            /// <para>Extra data stored in some member expressions.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Extra data stored in some member expressions.</para>
            /// </remarks>
            internal unsafe partial class MemberNameQualifier
            {
                [StructLayout(LayoutKind.Explicit, Size = 24)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public clang.NestedNameSpecifierLoc.Internal QualifierLoc;

                    [FieldOffset(16)]
                    public clang.DeclAccessPair.Internal FoundDecl;
                }
            }

            private readonly bool __ownsNativeInstance;

            public static new MemberExpr __CreateInstance(global::System.IntPtr native)
            {
                return new MemberExpr((MemberExpr.Internal*) native);
            }

            public static MemberExpr __CreateInstance(MemberExpr.Internal native)
            {
                return new MemberExpr(native);
            }

            private static MemberExpr.Internal* __CopyValue(MemberExpr.Internal native)
            {
                var ret = (MemberExpr.Internal*) Marshal.AllocHGlobal(48);
                *ret = native;
                return ret;
            }

            private MemberExpr(MemberExpr.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected MemberExpr(MemberExpr.Internal* native, bool isInternalImpl = false)
                : base((clang.Expr.Internal*) native)
            {
            }

            public MemberExpr(clang.Expr @base, bool isarrow, clang.ValueDecl memberdecl, clang.DeclarationNameInfo NameInfo, clang.QualType ty, clang.ExprValueKind VK, clang.ExprObjectKind OK)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(48);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(@base, null) ? global::System.IntPtr.Zero : @base.__Instance;
                var arg2 = ReferenceEquals(memberdecl, null) ? global::System.IntPtr.Zero : memberdecl.__Instance;
                var arg3 = ReferenceEquals(NameInfo, null) ? global::System.IntPtr.Zero : NameInfo.__Instance;
                var arg4 = ReferenceEquals(ty, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (ty.__Instance);
                var arg5 = VK;
                var arg6 = OK;
                Internal.ctor_0(__Instance, arg0, isarrow, arg2, arg3, arg4, arg5, arg6);
            }

            public MemberExpr(clang.Expr @base, bool isarrow, clang.ValueDecl memberdecl, clang.SourceLocation l, clang.QualType ty, clang.ExprValueKind VK, clang.ExprObjectKind OK)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(48);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(@base, null) ? global::System.IntPtr.Zero : @base.__Instance;
                var arg2 = ReferenceEquals(memberdecl, null) ? global::System.IntPtr.Zero : memberdecl.__Instance;
                var arg3 = ReferenceEquals(l, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (l.__Instance);
                var arg4 = ReferenceEquals(ty, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (ty.__Instance);
                var arg5 = VK;
                var arg6 = OK;
                Internal.ctor_1(__Instance, arg0, isarrow, arg2, arg3, arg4, arg5, arg6);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Stmt __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public void setBase(clang.Expr E)
            {
                var arg0 = ReferenceEquals(E, null) ? global::System.IntPtr.Zero : E.__Instance;
                Internal.setBase_0(__Instance, arg0);
            }

            public clang.Expr getBase()
            {
                var __ret = Internal.getBase_0(__Instance);
                clang.Expr __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Expr.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Expr) clang.Expr.NativeToManagedMap[__ret];
                else __result0 = clang.Expr.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Retrieve the member declaration to which this expression
            /// refers.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the member declaration to which this
            /// expression refers.</para>
            /// <para>  ///</para>
            /// <para>  /// The returned declaration will either be a FieldDecl or (in
            /// C++)</para>
            /// <para>  /// a CXXMethodDecl.</para>
            /// </remarks>
            public clang.ValueDecl getMemberDecl()
            {
                var __ret = Internal.getMemberDecl_0(__Instance);
                clang.ValueDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.ValueDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.ValueDecl) clang.ValueDecl.NativeToManagedMap[__ret];
                else clang.ValueDecl.NativeToManagedMap[__ret] = __result0 = (clang.ValueDecl) clang.ValueDecl.__CreateInstance(__ret);
                return __result0;
            }

            public void setMemberDecl(clang.ValueDecl D)
            {
                var arg0 = ReferenceEquals(D, null) ? global::System.IntPtr.Zero : D.__Instance;
                Internal.setMemberDecl_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>Retrieves the declaration found by lookup.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieves the declaration found by lookup.</para>
            /// </remarks>
            public clang.DeclAccessPair getFoundDecl()
            {
                var __ret = Internal.getFoundDecl_0(__Instance);
                return clang.DeclAccessPair.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Determines whether this member expression actually had a C++
            /// nested-name-specifier prior to the name of the member, e.g.,
            /// x-&gt;Base::foo.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determines whether this member expression actually
            /// had</para>
            /// <para>  /// a C++ nested-name-specifier prior to the name of the
            /// member, e.g.,</para>
            /// <para>  /// x-&gt;Base::foo.</para>
            /// </remarks>
            public bool hasQualifier()
            {
                var __ret = Internal.hasQualifier_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>If the member name was qualified, retrieves the
            /// nested-name-specifier that precedes the member name. Otherwise, returns
            /// NULL.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief If the member name was qualified, retrieves the</para>
            /// <para>  /// nested-name-specifier that precedes the member name.
            /// Otherwise, returns</para>
            /// <para>  /// NULL.</para>
            /// </remarks>
            public clang.NestedNameSpecifier getQualifier()
            {
                var __ret = Internal.getQualifier_0(__Instance);
                clang.NestedNameSpecifier __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.NestedNameSpecifier.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.NestedNameSpecifier) clang.NestedNameSpecifier.NativeToManagedMap[__ret];
                else __result0 = clang.NestedNameSpecifier.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>If the member name was qualified, retrieves the
            /// nested-name-specifier that precedes the member name, with source-location
            /// information.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief If the member name was qualified, retrieves the</para>
            /// <para>  /// nested-name-specifier that precedes the member name, with
            /// source-location</para>
            /// <para>  /// information.</para>
            /// </remarks>
            public clang.NestedNameSpecifierLoc getQualifierLoc()
            {
                var __ret = Internal.getQualifierLoc_0(__Instance);
                return clang.NestedNameSpecifierLoc.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Return the optional template keyword and arguments info.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the optional template keyword and arguments
            /// info.</para>
            /// </remarks>
            public clang.ASTTemplateKWAndArgsInfo getTemplateKWAndArgsInfo()
            {
                var __ret = Internal.getTemplateKWAndArgsInfo_0(__Instance);
                clang.ASTTemplateKWAndArgsInfo __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.ASTTemplateKWAndArgsInfo.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.ASTTemplateKWAndArgsInfo) clang.ASTTemplateKWAndArgsInfo.NativeToManagedMap[__ret];
                else __result0 = clang.ASTTemplateKWAndArgsInfo.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Retrieve the location of the template keyword preceding the
            /// member name, if any.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the location of the template keyword
            /// preceding</para>
            /// <para>  /// the member name, if any.</para>
            /// </remarks>
            public clang.SourceLocation getTemplateKeywordLoc()
            {
                var __ret = Internal.getTemplateKeywordLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Retrieve the location of the left angle bracket starting the
            /// explicit template argument list following the member name, if any.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the location of the left angle bracket
            /// starting the</para>
            /// <para>  /// explicit template argument list following the member name,
            /// if any.</para>
            /// </remarks>
            public clang.SourceLocation getLAngleLoc()
            {
                var __ret = Internal.getLAngleLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Retrieve the location of the right angle bracket ending the
            /// explicit template argument list following the member name, if any.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the location of the right angle bracket
            /// ending the</para>
            /// <para>  /// explicit template argument list following the member name,
            /// if any.</para>
            /// </remarks>
            public clang.SourceLocation getRAngleLoc()
            {
                var __ret = Internal.getRAngleLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Determines whether the member name was preceded by the template
            /// keyword.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Determines whether the member name was preceded by the
            /// template keyword.</para>
            /// </remarks>
            public bool hasTemplateKeyword()
            {
                var __ret = Internal.hasTemplateKeyword_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determines whether the member name was followed by an explicit
            /// template argument list.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determines whether the member name was followed by
            /// an</para>
            /// <para>  /// explicit template argument list.</para>
            /// </remarks>
            public bool hasExplicitTemplateArgs()
            {
                var __ret = Internal.hasExplicitTemplateArgs_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Copies the template arguments (if present) into the given
            /// structure.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Copies the template arguments (if present) into the
            /// given</para>
            /// <para>  /// structure.</para>
            /// </remarks>
            public void copyTemplateArgumentsInto(clang.TemplateArgumentListInfo List)
            {
                var arg0 = ReferenceEquals(List, null) ? global::System.IntPtr.Zero : List.__Instance;
                Internal.copyTemplateArgumentsInto_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>Retrieve the explicit template argument list that follow the
            /// member template name. This must only be called on an expression with
            /// explicit template arguments.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the explicit template argument list
            /// that</para>
            /// <para>  /// follow the member template name.  This must only be called
            /// on an</para>
            /// <para>  /// expression with explicit template arguments.</para>
            /// </remarks>
            public clang.ASTTemplateArgumentListInfo getExplicitTemplateArgs()
            {
                var __ret = Internal.getExplicitTemplateArgs_0(__Instance);
                clang.ASTTemplateArgumentListInfo __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.ASTTemplateArgumentListInfo.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.ASTTemplateArgumentListInfo) clang.ASTTemplateArgumentListInfo.NativeToManagedMap[__ret];
                else __result0 = clang.ASTTemplateArgumentListInfo.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Retrieves the optional explicit template arguments. This points
            /// to the same data as getExplicitTemplateArgs(), but returns null if there
            /// are no explicit template arguments.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieves the optional explicit template
            /// arguments.</para>
            /// <para>  /// This points to the same data as getExplicitTemplateArgs(),
            /// but</para>
            /// <para>  /// returns null if there are no explicit template
            /// arguments.</para>
            /// </remarks>
            public clang.ASTTemplateArgumentListInfo getOptionalExplicitTemplateArgs()
            {
                var __ret = Internal.getOptionalExplicitTemplateArgs_0(__Instance);
                clang.ASTTemplateArgumentListInfo __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.ASTTemplateArgumentListInfo.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.ASTTemplateArgumentListInfo) clang.ASTTemplateArgumentListInfo.NativeToManagedMap[__ret];
                else __result0 = clang.ASTTemplateArgumentListInfo.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Retrieve the template arguments provided as part of this
            /// template-id.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the template arguments provided as part of
            /// this</para>
            /// <para>  /// template-id.</para>
            /// </remarks>
            public clang.TemplateArgumentLoc getTemplateArgs()
            {
                var __ret = Internal.getTemplateArgs_0(__Instance);
                clang.TemplateArgumentLoc __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.TemplateArgumentLoc.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.TemplateArgumentLoc) clang.TemplateArgumentLoc.NativeToManagedMap[__ret];
                else __result0 = clang.TemplateArgumentLoc.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Retrieve the number of template arguments provided as part of
            /// this template-id.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the number of template arguments provided as
            /// part of this</para>
            /// <para>  /// template-id.</para>
            /// </remarks>
            public uint getNumTemplateArgs()
            {
                var __ret = Internal.getNumTemplateArgs_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Retrieve the member declaration name info.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the member declaration name info.</para>
            /// </remarks>
            public clang.DeclarationNameInfo getMemberNameInfo()
            {
                var __ret = new clang.DeclarationNameInfo.Internal();
                Internal.getMemberNameInfo_0(new IntPtr(&__ret), __Instance);
                return clang.DeclarationNameInfo.__CreateInstance(__ret);
            }

            public bool isArrow()
            {
                var __ret = Internal.isArrow_0(__Instance);
                return __ret;
            }

            public void setArrow(bool A)
            {
                Internal.setArrow_0(__Instance, A);
            }

            /// <summary>
            /// <para>getMemberLoc - Return the location of the &quot;member&quot;, in
            /// X-&gt;F, it is the location of 'F'.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getMemberLoc - Return the location of the &quot;member&quot;,
            /// in X-&gt;F, it is the</para>
            /// <para>  /// location of 'F'.</para>
            /// </remarks>
            public clang.SourceLocation getMemberLoc()
            {
                var __ret = Internal.getMemberLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setMemberLoc(clang.SourceLocation L)
            {
                var arg0 = ReferenceEquals(L, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (L.__Instance);
                Internal.setMemberLoc_0(__Instance, arg0);
            }

            public clang.SourceLocation getLocStart()
            {
                var __ret = Internal.getLocStart_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLocEnd()
            {
                var __ret = Internal.getLocEnd_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getExprLoc()
            {
                var __ret = Internal.getExprLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Determine whether the base of this explicit is implicit.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine whether the base of this explicit is
            /// implicit.</para>
            /// </remarks>
            public bool isImplicitAccess()
            {
                var __ret = Internal.isImplicitAccess_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Returns true if this member expression refers to a method that
            /// was resolved from an overloaded set having size greater than 1.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Returns true if this member expression refers to a
            /// method that</para>
            /// <para>  /// was resolved from an overloaded set having size greater
            /// than 1.</para>
            /// </remarks>
            public bool hadMultipleCandidates()
            {
                var __ret = Internal.hadMultipleCandidates_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Sets the flag telling whether this expression refers to a method
            /// that was resolved from an overloaded set having size greater than 1.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Sets the flag telling whether this expression refers
            /// to</para>
            /// <para>  /// a method that was resolved from an overloaded set having
            /// size</para>
            /// <para>  /// greater than 1.</para>
            /// </remarks>
            public void setHadMultipleCandidates(bool V)
            {
                Internal.setHadMultipleCandidates_0(__Instance, V);
            }

            public clang.StmtRange children()
            {
                var __ret = new clang.StmtRange.Internal();
                Internal.children_0(new IntPtr(&__ret), __Instance);
                return clang.StmtRange.__CreateInstance(__ret);
            }

            public static bool classof(clang.Stmt T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>CompoundLiteralExpr - [C99 6.5.2.5]</para>
        /// </summary>
        /// <remarks>
        /// <para>/// CompoundLiteralExpr - [C99 6.5.2.5]</para>
        /// <para>///</para>
        /// </remarks>
        public unsafe partial class CompoundLiteralExpr : clang.Expr, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 40)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                internal clang.Stmt._.Internal __;

                [FieldOffset(8)]
                public clang.QualType.Internal TR;

                [FieldOffset(16)]
                public clang.SourceLocation.Internal LParenLoc;

                [FieldOffset(24)]
                internal llvm.PointerIntPair.Internal TInfoAndScope;

                [FieldOffset(32)]
                public global::System.IntPtr Init;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang19CompoundLiteralExprC2ENS_14SourceLocationEPNS_14TypeSourceInfoENS_8QualTypeENS_13ExprValueKindEPNS_4ExprEb")]
                internal static extern void ctor_0(global::System.IntPtr instance, clang.SourceLocation.Internal lparenloc, global::System.IntPtr tinfo, clang.QualType.Internal T, clang.ExprValueKind VK, global::System.IntPtr init, bool fileScope);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang19CompoundLiteralExprC2ENS_4Stmt10EmptyShellE")]
                internal static extern void ctor_1(global::System.IntPtr instance, clang.Stmt.EmptyShell.Internal Empty);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang19CompoundLiteralExprC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang19CompoundLiteralExpr14getInitializerEv")]
                internal static extern global::System.IntPtr getInitializer_1(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang19CompoundLiteralExpr14setInitializerEPNS_4ExprE")]
                internal static extern void setInitializer_0(global::System.IntPtr instance, global::System.IntPtr E);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang19CompoundLiteralExpr11isFileScopeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isFileScope_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang19CompoundLiteralExpr12setFileScopeEb")]
                internal static extern void setFileScope_0(global::System.IntPtr instance, bool FS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang19CompoundLiteralExpr12getLParenLocEv")]
                internal static extern clang.SourceLocation.Internal getLParenLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang19CompoundLiteralExpr12setLParenLocENS_14SourceLocationE")]
                internal static extern void setLParenLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal L);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang19CompoundLiteralExpr17getTypeSourceInfoEv")]
                internal static extern global::System.IntPtr getTypeSourceInfo_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang19CompoundLiteralExpr17setTypeSourceInfoEPNS_14TypeSourceInfoE")]
                internal static extern void setTypeSourceInfo_0(global::System.IntPtr instance, global::System.IntPtr tinfo);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang19CompoundLiteralExpr11getLocStartEv")]
                internal static extern clang.SourceLocation.Internal getLocStart_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang19CompoundLiteralExpr9getLocEndEv")]
                internal static extern clang.SourceLocation.Internal getLocEnd_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang19CompoundLiteralExpr7classofEPKNS_4StmtE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang19CompoundLiteralExpr8childrenEv")]
                internal static extern void children_0(global::System.IntPtr @return, global::System.IntPtr instance);
            }

            private readonly bool __ownsNativeInstance;

            public static new CompoundLiteralExpr __CreateInstance(global::System.IntPtr native)
            {
                return new CompoundLiteralExpr((CompoundLiteralExpr.Internal*) native);
            }

            public static CompoundLiteralExpr __CreateInstance(CompoundLiteralExpr.Internal native)
            {
                return new CompoundLiteralExpr(native);
            }

            private static CompoundLiteralExpr.Internal* __CopyValue(CompoundLiteralExpr.Internal native)
            {
                var ret = (CompoundLiteralExpr.Internal*) Marshal.AllocHGlobal(40);
                *ret = native;
                return ret;
            }

            private CompoundLiteralExpr(CompoundLiteralExpr.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected CompoundLiteralExpr(CompoundLiteralExpr.Internal* native, bool isInternalImpl = false)
                : base((clang.Expr.Internal*) native)
            {
            }

            public CompoundLiteralExpr(clang.SourceLocation lparenloc, clang.TypeSourceInfo tinfo, clang.QualType T, clang.ExprValueKind VK, clang.Expr init, bool fileScope)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(40);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(lparenloc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (lparenloc.__Instance);
                var arg1 = ReferenceEquals(tinfo, null) ? global::System.IntPtr.Zero : tinfo.__Instance;
                var arg2 = ReferenceEquals(T, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (T.__Instance);
                var arg3 = VK;
                var arg4 = ReferenceEquals(init, null) ? global::System.IntPtr.Zero : init.__Instance;
                Internal.ctor_0(__Instance, arg0, arg1, arg2, arg3, arg4, fileScope);
            }

            /// <summary>
            /// <para>Construct an empty compound literal.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Construct an empty compound literal.</para>
            /// </remarks>
            public CompoundLiteralExpr(clang.Stmt.EmptyShell Empty)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(40);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(Empty, null) ? new clang.Stmt.EmptyShell.Internal() : *(clang.Stmt.EmptyShell.Internal*) (Empty.__Instance);
                Internal.ctor_1(__Instance, arg0);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Stmt __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.Expr getInitializer()
            {
                var __ret = Internal.getInitializer_1(__Instance);
                clang.Expr __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Expr.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Expr) clang.Expr.NativeToManagedMap[__ret];
                else __result0 = clang.Expr.__CreateInstance(__ret);
                return __result0;
            }

            public void setInitializer(clang.Expr E)
            {
                var arg0 = ReferenceEquals(E, null) ? global::System.IntPtr.Zero : E.__Instance;
                Internal.setInitializer_0(__Instance, arg0);
            }

            public bool isFileScope()
            {
                var __ret = Internal.isFileScope_0(__Instance);
                return __ret;
            }

            public void setFileScope(bool FS)
            {
                Internal.setFileScope_0(__Instance, FS);
            }

            public clang.SourceLocation getLParenLoc()
            {
                var __ret = Internal.getLParenLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setLParenLoc(clang.SourceLocation L)
            {
                var arg0 = ReferenceEquals(L, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (L.__Instance);
                Internal.setLParenLoc_0(__Instance, arg0);
            }

            public clang.TypeSourceInfo getTypeSourceInfo()
            {
                var __ret = Internal.getTypeSourceInfo_0(__Instance);
                clang.TypeSourceInfo __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.TypeSourceInfo.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.TypeSourceInfo) clang.TypeSourceInfo.NativeToManagedMap[__ret];
                else __result0 = clang.TypeSourceInfo.__CreateInstance(__ret);
                return __result0;
            }

            public void setTypeSourceInfo(clang.TypeSourceInfo tinfo)
            {
                var arg0 = ReferenceEquals(tinfo, null) ? global::System.IntPtr.Zero : tinfo.__Instance;
                Internal.setTypeSourceInfo_0(__Instance, arg0);
            }

            public clang.SourceLocation getLocStart()
            {
                var __ret = Internal.getLocStart_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLocEnd()
            {
                var __ret = Internal.getLocEnd_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.StmtRange children()
            {
                var __ret = new clang.StmtRange.Internal();
                Internal.children_0(new IntPtr(&__ret), __Instance);
                return clang.StmtRange.__CreateInstance(__ret);
            }

            public static bool classof(clang.Stmt T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>CastExpr - Base class for type casts, including both implicit
        /// casts (ImplicitCastExpr) and explicit casts that have some representation
        /// in the source code (ExplicitCastExpr's derived classes).</para>
        /// </summary>
        /// <remarks>
        /// <para>/// CastExpr - Base class for type casts, including both
        /// implicit</para>
        /// <para>/// casts (ImplicitCastExpr) and explicit casts that have
        /// some</para>
        /// <para>/// representation in the source code (ExplicitCastExpr's
        /// derived</para>
        /// <para>/// classes).</para>
        /// </remarks>
        public unsafe partial class CastExpr : clang.Expr, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 24)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                internal clang.Stmt._.Internal __;

                [FieldOffset(8)]
                public clang.QualType.Internal TR;

                [FieldOffset(16)]
                public global::System.IntPtr Op;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8CastExprC2ENS_4Stmt9StmtClassENS_8QualTypeENS_13ExprValueKindENS_8CastKindEPNS_4ExprEj")]
                internal static extern void ctor_0(global::System.IntPtr instance, clang.Stmt.StmtClass SC, clang.QualType.Internal ty, clang.ExprValueKind VK, clang.CastKind kind, global::System.IntPtr op, uint BasePathSize);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8CastExprC2ENS_4Stmt9StmtClassENS1_10EmptyShellEj")]
                internal static extern void ctor_1(global::System.IntPtr instance, clang.Stmt.StmtClass SC, clang.Stmt.EmptyShell.Internal Empty, uint BasePathSize);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8CastExprC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8CastExpr11getCastKindEv")]
                internal static extern clang.CastKind getCastKind_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8CastExpr11setCastKindENS_8CastKindE")]
                internal static extern void setCastKind_0(global::System.IntPtr instance, clang.CastKind K);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8CastExpr15getCastKindNameEv")]
                internal static extern global::System.IntPtr getCastKindName_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8CastExpr10getSubExprEv")]
                internal static extern global::System.IntPtr getSubExpr_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8CastExpr10setSubExprEPNS_4ExprE")]
                internal static extern void setSubExpr_0(global::System.IntPtr instance, global::System.IntPtr E);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8CastExpr19getSubExprAsWrittenEv")]
                internal static extern global::System.IntPtr getSubExprAsWritten_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8CastExpr10path_emptyEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool path_empty_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8CastExpr9path_sizeEv")]
                internal static extern uint path_size_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8CastExpr7classofEPKNS_4StmtE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8CastExpr8childrenEv")]
                internal static extern void children_0(global::System.IntPtr @return, global::System.IntPtr instance);
            }

            private readonly bool __ownsNativeInstance;

            public static new CastExpr __CreateInstance(global::System.IntPtr native)
            {
                return new CastExpr((CastExpr.Internal*) native);
            }

            public static CastExpr __CreateInstance(CastExpr.Internal native)
            {
                return new CastExpr(native);
            }

            private static CastExpr.Internal* __CopyValue(CastExpr.Internal native)
            {
                var ret = (CastExpr.Internal*) Marshal.AllocHGlobal(24);
                *ret = native;
                return ret;
            }

            private CastExpr(CastExpr.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected CastExpr(CastExpr.Internal* native, bool isInternalImpl = false)
                : base((clang.Expr.Internal*) native)
            {
            }

            protected CastExpr(clang.Stmt.StmtClass SC, clang.QualType ty, clang.ExprValueKind VK, clang.CastKind kind, clang.Expr op, uint BasePathSize)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(24);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = SC;
                var arg1 = ReferenceEquals(ty, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (ty.__Instance);
                var arg2 = VK;
                var arg3 = kind;
                var arg4 = ReferenceEquals(op, null) ? global::System.IntPtr.Zero : op.__Instance;
                Internal.ctor_0(__Instance, arg0, arg1, arg2, arg3, arg4, BasePathSize);
            }

            /// <summary>
            /// <para>Construct an empty cast.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Construct an empty cast.</para>
            /// </remarks>
            protected CastExpr(clang.Stmt.StmtClass SC, clang.Stmt.EmptyShell Empty, uint BasePathSize)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(24);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = SC;
                var arg1 = ReferenceEquals(Empty, null) ? new clang.Stmt.EmptyShell.Internal() : *(clang.Stmt.EmptyShell.Internal*) (Empty.__Instance);
                Internal.ctor_1(__Instance, arg0, arg1, BasePathSize);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Stmt __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.CastKind getCastKind()
            {
                var __ret = Internal.getCastKind_0(__Instance);
                return __ret;
            }

            public void setCastKind(clang.CastKind K)
            {
                var arg0 = K;
                Internal.setCastKind_0(__Instance, arg0);
            }

            public string getCastKindName()
            {
                var __ret = Internal.getCastKindName_0(__Instance);
                return Marshal.PtrToStringAnsi(__ret);
            }

            public clang.Expr getSubExpr()
            {
                var __ret = Internal.getSubExpr_0(__Instance);
                clang.Expr __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Expr.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Expr) clang.Expr.NativeToManagedMap[__ret];
                else __result0 = clang.Expr.__CreateInstance(__ret);
                return __result0;
            }

            public void setSubExpr(clang.Expr E)
            {
                var arg0 = ReferenceEquals(E, null) ? global::System.IntPtr.Zero : E.__Instance;
                Internal.setSubExpr_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>Retrieve the cast subexpression as it was written in the source
            /// code, looking through any implicit casts or other intermediate nodes
            /// introduced by semantic analysis.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the cast subexpression as it was written in
            /// the source</para>
            /// <para>  /// code, looking through any implicit casts or other
            /// intermediate nodes</para>
            /// <para>  /// introduced by semantic analysis.</para>
            /// </remarks>
            public clang.Expr getSubExprAsWritten()
            {
                var __ret = Internal.getSubExprAsWritten_0(__Instance);
                clang.Expr __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Expr.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Expr) clang.Expr.NativeToManagedMap[__ret];
                else __result0 = clang.Expr.__CreateInstance(__ret);
                return __result0;
            }

            public bool path_empty()
            {
                var __ret = Internal.path_empty_0(__Instance);
                return __ret;
            }

            public uint path_size()
            {
                var __ret = Internal.path_size_0(__Instance);
                return __ret;
            }

            public clang.StmtRange children()
            {
                var __ret = new clang.StmtRange.Internal();
                Internal.children_0(new IntPtr(&__ret), __Instance);
                return clang.StmtRange.__CreateInstance(__ret);
            }

            public static bool classof(clang.Stmt T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>ImplicitCastExpr - Allows us to explicitly represent implicit
        /// type conversions, which have no direct representation in the original
        /// source code. For example: converting T[]-&gt;T*, void f()-&gt;void (*f)(),
        /// float-&gt;double, short-&gt;int, etc.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// ImplicitCastExpr - Allows us to explicitly represent implicit
        /// type</para>
        /// <para>/// conversions, which have no direct representation in the
        /// original</para>
        /// <para>/// source code. For example: converting T[]-&gt;T*, void
        /// f()-&gt;void</para>
        /// <para>/// (*f)(), float-&gt;double, short-&gt;int, etc.</para>
        /// <para>///</para>
        /// <para>/// In C, implicit casts always produce rvalues. However, in C++,
        /// an</para>
        /// <para>/// implicit cast whose result is being bound to a reference will
        /// be</para>
        /// <para>/// an lvalue or xvalue. For example:</para>
        /// <para>///</para>
        /// <para>/// @code</para>
        /// <para>/// class Base { };</para>
        /// <para>/// class Derived : public Base { };</para>
        /// <para>/// Derived &amp;&amp;ref();</para>
        /// <para>/// void f(Derived d) {</para>
        /// <para>///   Base&amp; b = d; // initializer is an
        /// ImplicitCastExpr</para>
        /// <para>///                // to an lvalue of type Base</para>
        /// <para>///   Base&amp;&amp; r = ref(); // initializer is an
        /// ImplicitCastExpr</para>
        /// <para>///                     // to an xvalue of type Base</para>
        /// <para>/// }</para>
        /// <para>/// @endcode</para>
        /// </remarks>
        public unsafe partial class ImplicitCastExpr : clang.CastExpr, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 24)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                internal clang.Stmt._.Internal __;

                [FieldOffset(8)]
                public clang.QualType.Internal TR;

                [FieldOffset(16)]
                public global::System.IntPtr Op;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16ImplicitCastExprC2ENS0_9OnStack_tENS_8QualTypeENS_8CastKindEPNS_4ExprENS_13ExprValueKindE")]
                internal static extern void ctor_2(global::System.IntPtr instance, clang.ImplicitCastExpr.OnStack_t _, clang.QualType.Internal ty, clang.CastKind kind, global::System.IntPtr op, clang.ExprValueKind VK);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16ImplicitCastExprC2ERKS0_")]
                internal static extern void cctor_3(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang16ImplicitCastExpr11getLocStartEv")]
                internal static extern clang.SourceLocation.Internal getLocStart_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang16ImplicitCastExpr9getLocEndEv")]
                internal static extern clang.SourceLocation.Internal getLocEnd_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16ImplicitCastExpr7classofEPKNS_4StmtE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);
            }

            public enum OnStack_t : uint
            {
                OnStack = 0
            }

            private readonly bool __ownsNativeInstance;

            public static new ImplicitCastExpr __CreateInstance(global::System.IntPtr native)
            {
                return new ImplicitCastExpr((ImplicitCastExpr.Internal*) native);
            }

            public static ImplicitCastExpr __CreateInstance(ImplicitCastExpr.Internal native)
            {
                return new ImplicitCastExpr(native);
            }

            private static ImplicitCastExpr.Internal* __CopyValue(ImplicitCastExpr.Internal native)
            {
                var ret = (ImplicitCastExpr.Internal*) Marshal.AllocHGlobal(24);
                *ret = native;
                return ret;
            }

            private ImplicitCastExpr(ImplicitCastExpr.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected ImplicitCastExpr(ImplicitCastExpr.Internal* native, bool isInternalImpl = false)
                : base((clang.CastExpr.Internal*) native)
            {
            }

            public ImplicitCastExpr(clang.ImplicitCastExpr.OnStack_t _, clang.QualType ty, clang.CastKind kind, clang.Expr op, clang.ExprValueKind VK)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(24);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = _;
                var arg1 = ReferenceEquals(ty, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (ty.__Instance);
                var arg2 = kind;
                var arg3 = ReferenceEquals(op, null) ? global::System.IntPtr.Zero : op.__Instance;
                var arg4 = VK;
                Internal.ctor_2(__Instance, arg0, arg1, arg2, arg3, arg4);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Stmt __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.SourceLocation getLocStart()
            {
                var __ret = Internal.getLocStart_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLocEnd()
            {
                var __ret = Internal.getLocEnd_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public static bool classof(clang.Stmt T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>ExplicitCastExpr - An explicit cast written in the source
        /// code.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// ExplicitCastExpr - An explicit cast written in the
        /// source</para>
        /// <para>/// code.</para>
        /// <para>///</para>
        /// <para>/// This class is effectively an abstract class, because it
        /// provides</para>
        /// <para>/// the basic representation of an explicitly-written cast
        /// without</para>
        /// <para>/// specifying which kind of cast (C cast, functional cast,
        /// static</para>
        /// <para>/// cast, etc.) was written; specific derived classes represent
        /// the</para>
        /// <para>/// particular style of cast and its location information.</para>
        /// <para>///</para>
        /// <para>/// Unlike implicit casts, explicit cast nodes have two
        /// different</para>
        /// <para>/// types: the type that was written into the source code, and
        /// the</para>
        /// <para>/// actual type of the expression as determined by
        /// semantic</para>
        /// <para>/// analysis. These types may differ slightly. For example, in
        /// C++ one</para>
        /// <para>/// can cast to a reference type, which indicates that the
        /// resulting</para>
        /// <para>/// expression will be an lvalue or xvalue. The reference type,
        /// however,</para>
        /// <para>/// will not be used as the type of the expression.</para>
        /// </remarks>
        public unsafe partial class ExplicitCastExpr : clang.CastExpr, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 32)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                internal clang.Stmt._.Internal __;

                [FieldOffset(8)]
                public clang.QualType.Internal TR;

                [FieldOffset(16)]
                public global::System.IntPtr Op;

                [FieldOffset(24)]
                public global::System.IntPtr TInfo;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16ExplicitCastExprC2ENS_4Stmt9StmtClassENS_8QualTypeENS_13ExprValueKindENS_8CastKindEPNS_4ExprEjPNS_14TypeSourceInfoE")]
                internal static extern void ctor_0(global::System.IntPtr instance, clang.Stmt.StmtClass SC, clang.QualType.Internal exprTy, clang.ExprValueKind VK, clang.CastKind kind, global::System.IntPtr op, uint PathSize, global::System.IntPtr writtenTy);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16ExplicitCastExprC2ENS_4Stmt9StmtClassENS1_10EmptyShellEj")]
                internal static extern void ctor_1(global::System.IntPtr instance, clang.Stmt.StmtClass SC, clang.Stmt.EmptyShell.Internal Shell, uint PathSize);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16ExplicitCastExprC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang16ExplicitCastExpr20getTypeInfoAsWrittenEv")]
                internal static extern global::System.IntPtr getTypeInfoAsWritten_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16ExplicitCastExpr20setTypeInfoAsWrittenEPNS_14TypeSourceInfoE")]
                internal static extern void setTypeInfoAsWritten_0(global::System.IntPtr instance, global::System.IntPtr writtenTy);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang16ExplicitCastExpr16getTypeAsWrittenEv")]
                internal static extern clang.QualType.Internal getTypeAsWritten_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16ExplicitCastExpr7classofEPKNS_4StmtE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);
            }

            private readonly bool __ownsNativeInstance;

            public static new ExplicitCastExpr __CreateInstance(global::System.IntPtr native)
            {
                return new ExplicitCastExpr((ExplicitCastExpr.Internal*) native);
            }

            public static ExplicitCastExpr __CreateInstance(ExplicitCastExpr.Internal native)
            {
                return new ExplicitCastExpr(native);
            }

            private static ExplicitCastExpr.Internal* __CopyValue(ExplicitCastExpr.Internal native)
            {
                var ret = (ExplicitCastExpr.Internal*) Marshal.AllocHGlobal(32);
                *ret = native;
                return ret;
            }

            private ExplicitCastExpr(ExplicitCastExpr.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected ExplicitCastExpr(ExplicitCastExpr.Internal* native, bool isInternalImpl = false)
                : base((clang.CastExpr.Internal*) native)
            {
            }

            protected ExplicitCastExpr(clang.Stmt.StmtClass SC, clang.QualType exprTy, clang.ExprValueKind VK, clang.CastKind kind, clang.Expr op, uint PathSize, clang.TypeSourceInfo writtenTy)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(32);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = SC;
                var arg1 = ReferenceEquals(exprTy, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (exprTy.__Instance);
                var arg2 = VK;
                var arg3 = kind;
                var arg4 = ReferenceEquals(op, null) ? global::System.IntPtr.Zero : op.__Instance;
                var arg6 = ReferenceEquals(writtenTy, null) ? global::System.IntPtr.Zero : writtenTy.__Instance;
                Internal.ctor_0(__Instance, arg0, arg1, arg2, arg3, arg4, PathSize, arg6);
            }

            /// <summary>
            /// <para>Construct an empty explicit cast.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Construct an empty explicit cast.</para>
            /// </remarks>
            protected ExplicitCastExpr(clang.Stmt.StmtClass SC, clang.Stmt.EmptyShell Shell, uint PathSize)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(32);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = SC;
                var arg1 = ReferenceEquals(Shell, null) ? new clang.Stmt.EmptyShell.Internal() : *(clang.Stmt.EmptyShell.Internal*) (Shell.__Instance);
                Internal.ctor_1(__Instance, arg0, arg1, PathSize);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Stmt __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            /// <summary>
            /// <para>getTypeInfoAsWritten - Returns the type source info for the type
            /// that this expression is casting to.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getTypeInfoAsWritten - Returns the type source info for the
            /// type</para>
            /// <para>  /// that this expression is casting to.</para>
            /// </remarks>
            public clang.TypeSourceInfo getTypeInfoAsWritten()
            {
                var __ret = Internal.getTypeInfoAsWritten_0(__Instance);
                clang.TypeSourceInfo __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.TypeSourceInfo.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.TypeSourceInfo) clang.TypeSourceInfo.NativeToManagedMap[__ret];
                else __result0 = clang.TypeSourceInfo.__CreateInstance(__ret);
                return __result0;
            }

            public void setTypeInfoAsWritten(clang.TypeSourceInfo writtenTy)
            {
                var arg0 = ReferenceEquals(writtenTy, null) ? global::System.IntPtr.Zero : writtenTy.__Instance;
                Internal.setTypeInfoAsWritten_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>getTypeAsWritten - Returns the type that this expression is
            /// casting to, as written in the source code.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getTypeAsWritten - Returns the type that this expression
            /// is</para>
            /// <para>  /// casting to, as written in the source code.</para>
            /// </remarks>
            public clang.QualType getTypeAsWritten()
            {
                var __ret = Internal.getTypeAsWritten_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            public static bool classof(clang.Stmt T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>CStyleCastExpr - An explicit cast in C (C99 6.5.4) or a C-style
        /// cast in C++ (C++ [expr.cast]), which uses the syntax (Type)expr. For
        /// example: (int)f.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// CStyleCastExpr - An explicit cast in C (C99 6.5.4) or a
        /// C-style</para>
        /// <para>/// cast in C++ (C++ [expr.cast]), which uses the syntax</para>
        /// <para>/// (Type)expr. For example: @c (int)f.</para>
        /// </remarks>
        public unsafe partial class CStyleCastExpr : clang.ExplicitCastExpr, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 40)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                internal clang.Stmt._.Internal __;

                [FieldOffset(8)]
                public clang.QualType.Internal TR;

                [FieldOffset(16)]
                public global::System.IntPtr Op;

                [FieldOffset(24)]
                public global::System.IntPtr TInfo;

                [FieldOffset(32)]
                public clang.SourceLocation.Internal LPLoc;

                [FieldOffset(36)]
                public clang.SourceLocation.Internal RPLoc;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14CStyleCastExprC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14CStyleCastExpr12getLParenLocEv")]
                internal static extern clang.SourceLocation.Internal getLParenLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14CStyleCastExpr12setLParenLocENS_14SourceLocationE")]
                internal static extern void setLParenLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal L);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14CStyleCastExpr12getRParenLocEv")]
                internal static extern clang.SourceLocation.Internal getRParenLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14CStyleCastExpr12setRParenLocENS_14SourceLocationE")]
                internal static extern void setRParenLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal L);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14CStyleCastExpr11getLocStartEv")]
                internal static extern clang.SourceLocation.Internal getLocStart_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14CStyleCastExpr9getLocEndEv")]
                internal static extern clang.SourceLocation.Internal getLocEnd_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14CStyleCastExpr7classofEPKNS_4StmtE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);
            }

            private readonly bool __ownsNativeInstance;

            public static new CStyleCastExpr __CreateInstance(global::System.IntPtr native)
            {
                return new CStyleCastExpr((CStyleCastExpr.Internal*) native);
            }

            public static CStyleCastExpr __CreateInstance(CStyleCastExpr.Internal native)
            {
                return new CStyleCastExpr(native);
            }

            private static CStyleCastExpr.Internal* __CopyValue(CStyleCastExpr.Internal native)
            {
                var ret = (CStyleCastExpr.Internal*) Marshal.AllocHGlobal(40);
                *ret = native;
                return ret;
            }

            private CStyleCastExpr(CStyleCastExpr.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected CStyleCastExpr(CStyleCastExpr.Internal* native, bool isInternalImpl = false)
                : base((clang.ExplicitCastExpr.Internal*) native)
            {
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Stmt __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.SourceLocation getLParenLoc()
            {
                var __ret = Internal.getLParenLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setLParenLoc(clang.SourceLocation L)
            {
                var arg0 = ReferenceEquals(L, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (L.__Instance);
                Internal.setLParenLoc_0(__Instance, arg0);
            }

            public clang.SourceLocation getRParenLoc()
            {
                var __ret = Internal.getRParenLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setRParenLoc(clang.SourceLocation L)
            {
                var arg0 = ReferenceEquals(L, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (L.__Instance);
                Internal.setRParenLoc_0(__Instance, arg0);
            }

            public clang.SourceLocation getLocStart()
            {
                var __ret = Internal.getLocStart_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLocEnd()
            {
                var __ret = Internal.getLocEnd_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public static bool classof(clang.Stmt T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>A builtin binary operation expression such as &quot;x + y&quot;
        /// or &quot;x &lt;= y&quot;.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief A builtin binary operation expression such as &quot;x
        /// + y&quot; or &quot;x &lt;= y&quot;.</para>
        /// <para>///</para>
        /// <para>/// This expression node kind describes a builtin binary
        /// operation,</para>
        /// <para>/// such as &quot;x + y&quot; for integer values &quot;x&quot;
        /// and &quot;y&quot;. The operands will</para>
        /// <para>/// already have been converted to appropriate types (e.g.,
        /// by</para>
        /// <para>/// performing promotions or conversions).</para>
        /// <para>///</para>
        /// <para>/// In C++, where operators may be overloaded, a different kind
        /// of</para>
        /// <para>/// expression node (CXXOperatorCallExpr) is used to express
        /// the</para>
        /// <para>/// invocation of an overloaded operator with operator syntax.
        /// Within</para>
        /// <para>/// a C++ template, whether BinaryOperator or CXXOperatorCallExpr
        /// is</para>
        /// <para>/// used to store an expression &quot;x + y&quot; depends on the
        /// subexpressions</para>
        /// <para>/// for x and y. If neither x or y is type-dependent, and the
        /// &quot;+&quot;</para>
        /// <para>/// operator resolves to a built-in operation, BinaryOperator
        /// will be</para>
        /// <para>/// used to express the computation (x and y may still be</para>
        /// <para>/// value-dependent). If either x or y is type-dependent, or if
        /// the</para>
        /// <para>/// &quot;+&quot; resolves to an overloaded operator,
        /// CXXOperatorCallExpr will</para>
        /// <para>/// be used to express the computation.</para>
        /// </remarks>
        public unsafe partial class BinaryOperator : clang.Expr, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 40)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                internal clang.Stmt._.Internal __;

                [FieldOffset(8)]
                public clang.QualType.Internal TR;

                [FieldOffset(16)]
                public uint Opc;

                [FieldOffset(16)]
                public uint FPContractable;

                [FieldOffset(20)]
                public clang.SourceLocation.Internal OpLoc;

                [FieldOffset(24)]
                public fixed global::System.IntPtr SubExprs[2];

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14BinaryOperatorC2EPNS_4ExprES2_NS_18BinaryOperatorKindENS_8QualTypeENS_13ExprValueKindENS_14ExprObjectKindENS_14SourceLocationEb")]
                internal static extern void ctor_0(global::System.IntPtr instance, global::System.IntPtr lhs, global::System.IntPtr rhs, clang.BinaryOperatorKind opc, clang.QualType.Internal ResTy, clang.ExprValueKind VK, clang.ExprObjectKind OK, clang.SourceLocation.Internal opLoc, bool fpContractable);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14BinaryOperatorC2ENS_4Stmt10EmptyShellE")]
                internal static extern void ctor_1(global::System.IntPtr instance, clang.Stmt.EmptyShell.Internal Empty);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14BinaryOperatorC2EPNS_4ExprES2_NS_18BinaryOperatorKindENS_8QualTypeENS_13ExprValueKindENS_14ExprObjectKindENS_14SourceLocationEbb")]
                internal static extern void ctor_2(global::System.IntPtr instance, global::System.IntPtr lhs, global::System.IntPtr rhs, clang.BinaryOperatorKind opc, clang.QualType.Internal ResTy, clang.ExprValueKind VK, clang.ExprObjectKind OK, clang.SourceLocation.Internal opLoc, bool fpContractable, bool dead2);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14BinaryOperatorC2ENS_4Stmt9StmtClassENS1_10EmptyShellE")]
                internal static extern void ctor_3(global::System.IntPtr instance, clang.Stmt.StmtClass SC, clang.Stmt.EmptyShell.Internal Empty);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14BinaryOperatorC2ERKS0_")]
                internal static extern void cctor_4(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14BinaryOperator10getExprLocEv")]
                internal static extern clang.SourceLocation.Internal getExprLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14BinaryOperator14getOperatorLocEv")]
                internal static extern clang.SourceLocation.Internal getOperatorLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14BinaryOperator14setOperatorLocENS_14SourceLocationE")]
                internal static extern void setOperatorLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal L);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14BinaryOperator9getOpcodeEv")]
                internal static extern clang.BinaryOperatorKind getOpcode_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14BinaryOperator9setOpcodeENS_18BinaryOperatorKindE")]
                internal static extern void setOpcode_0(global::System.IntPtr instance, clang.BinaryOperatorKind O);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14BinaryOperator6getLHSEv")]
                internal static extern global::System.IntPtr getLHS_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14BinaryOperator6setLHSEPNS_4ExprE")]
                internal static extern void setLHS_0(global::System.IntPtr instance, global::System.IntPtr E);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14BinaryOperator6getRHSEv")]
                internal static extern global::System.IntPtr getRHS_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14BinaryOperator6setRHSEPNS_4ExprE")]
                internal static extern void setRHS_0(global::System.IntPtr instance, global::System.IntPtr E);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14BinaryOperator11getLocStartEv")]
                internal static extern clang.SourceLocation.Internal getLocStart_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14BinaryOperator9getLocEndEv")]
                internal static extern clang.SourceLocation.Internal getLocEnd_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14BinaryOperator12getOpcodeStrENS_18BinaryOperatorKindE")]
                internal static extern llvm.StringRef.Internal getOpcodeStr_0(clang.BinaryOperatorKind Op);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14BinaryOperator12getOpcodeStrEv")]
                internal static extern llvm.StringRef.Internal getOpcodeStr_1(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14BinaryOperator19getOverloadedOpcodeENS_22OverloadedOperatorKindE")]
                internal static extern clang.BinaryOperatorKind getOverloadedOpcode_0(clang.OverloadedOperatorKind OO);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14BinaryOperator21getOverloadedOperatorENS_18BinaryOperatorKindE")]
                internal static extern clang.OverloadedOperatorKind getOverloadedOperator_0(clang.BinaryOperatorKind Opc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14BinaryOperator10isPtrMemOpEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isPtrMemOp_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14BinaryOperator18isMultiplicativeOpEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isMultiplicativeOp_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14BinaryOperator12isAdditiveOpENS_18BinaryOperatorKindE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isAdditiveOp_0(clang.BinaryOperatorKind Opc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14BinaryOperator12isAdditiveOpEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isAdditiveOp_1(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14BinaryOperator9isShiftOpENS_18BinaryOperatorKindE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isShiftOp_0(clang.BinaryOperatorKind Opc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14BinaryOperator9isShiftOpEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isShiftOp_1(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14BinaryOperator11isBitwiseOpENS_18BinaryOperatorKindE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isBitwiseOp_0(clang.BinaryOperatorKind Opc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14BinaryOperator11isBitwiseOpEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isBitwiseOp_1(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14BinaryOperator14isRelationalOpENS_18BinaryOperatorKindE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isRelationalOp_0(clang.BinaryOperatorKind Opc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14BinaryOperator14isRelationalOpEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isRelationalOp_1(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14BinaryOperator12isEqualityOpENS_18BinaryOperatorKindE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isEqualityOp_0(clang.BinaryOperatorKind Opc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14BinaryOperator12isEqualityOpEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isEqualityOp_1(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14BinaryOperator14isComparisonOpENS_18BinaryOperatorKindE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isComparisonOp_0(clang.BinaryOperatorKind Opc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14BinaryOperator14isComparisonOpEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isComparisonOp_1(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14BinaryOperator18negateComparisonOpENS_18BinaryOperatorKindE")]
                internal static extern clang.BinaryOperatorKind negateComparisonOp_0(clang.BinaryOperatorKind Opc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14BinaryOperator19reverseComparisonOpENS_18BinaryOperatorKindE")]
                internal static extern clang.BinaryOperatorKind reverseComparisonOp_0(clang.BinaryOperatorKind Opc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14BinaryOperator11isLogicalOpENS_18BinaryOperatorKindE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isLogicalOp_0(clang.BinaryOperatorKind Opc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14BinaryOperator11isLogicalOpEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isLogicalOp_1(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14BinaryOperator14isAssignmentOpENS_18BinaryOperatorKindE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isAssignmentOp_0(clang.BinaryOperatorKind Opc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14BinaryOperator14isAssignmentOpEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isAssignmentOp_1(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14BinaryOperator22isCompoundAssignmentOpENS_18BinaryOperatorKindE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isCompoundAssignmentOp_0(clang.BinaryOperatorKind Opc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14BinaryOperator22isCompoundAssignmentOpEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isCompoundAssignmentOp_1(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14BinaryOperator26getOpForCompoundAssignmentENS_18BinaryOperatorKindE")]
                internal static extern clang.BinaryOperatorKind getOpForCompoundAssignment_0(clang.BinaryOperatorKind Opc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14BinaryOperator15isShiftAssignOpENS_18BinaryOperatorKindE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isShiftAssignOp_0(clang.BinaryOperatorKind Opc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14BinaryOperator15isShiftAssignOpEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isShiftAssignOp_1(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14BinaryOperator7classofEPKNS_4StmtE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr S);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14BinaryOperator8childrenEv")]
                internal static extern void children_0(global::System.IntPtr @return, global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14BinaryOperator17setFPContractableEb")]
                internal static extern void setFPContractable_0(global::System.IntPtr instance, bool FPC);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14BinaryOperator16isFPContractableEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isFPContractable_0(global::System.IntPtr instance);
            }

            private readonly bool __ownsNativeInstance;

            public static new BinaryOperator __CreateInstance(global::System.IntPtr native)
            {
                return new BinaryOperator((BinaryOperator.Internal*) native);
            }

            public static BinaryOperator __CreateInstance(BinaryOperator.Internal native)
            {
                return new BinaryOperator(native);
            }

            private static BinaryOperator.Internal* __CopyValue(BinaryOperator.Internal native)
            {
                var ret = (BinaryOperator.Internal*) Marshal.AllocHGlobal(40);
                *ret = native;
                return ret;
            }

            private BinaryOperator(BinaryOperator.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected BinaryOperator(BinaryOperator.Internal* native, bool isInternalImpl = false)
                : base((clang.Expr.Internal*) native)
            {
            }

            public BinaryOperator(clang.Expr lhs, clang.Expr rhs, clang.BinaryOperatorKind opc, clang.QualType ResTy, clang.ExprValueKind VK, clang.ExprObjectKind OK, clang.SourceLocation opLoc, bool fpContractable)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(40);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(lhs, null) ? global::System.IntPtr.Zero : lhs.__Instance;
                var arg1 = ReferenceEquals(rhs, null) ? global::System.IntPtr.Zero : rhs.__Instance;
                var arg2 = opc;
                var arg3 = ReferenceEquals(ResTy, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (ResTy.__Instance);
                var arg4 = VK;
                var arg5 = OK;
                var arg6 = ReferenceEquals(opLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (opLoc.__Instance);
                Internal.ctor_0(__Instance, arg0, arg1, arg2, arg3, arg4, arg5, arg6, fpContractable);
            }

            /// <summary>
            /// <para>Construct an empty binary operator.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Construct an empty binary operator.</para>
            /// </remarks>
            public BinaryOperator(clang.Stmt.EmptyShell Empty)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(40);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(Empty, null) ? new clang.Stmt.EmptyShell.Internal() : *(clang.Stmt.EmptyShell.Internal*) (Empty.__Instance);
                Internal.ctor_1(__Instance, arg0);
            }

            protected BinaryOperator(clang.Expr lhs, clang.Expr rhs, clang.BinaryOperatorKind opc, clang.QualType ResTy, clang.ExprValueKind VK, clang.ExprObjectKind OK, clang.SourceLocation opLoc, bool fpContractable, bool dead2)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(40);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(lhs, null) ? global::System.IntPtr.Zero : lhs.__Instance;
                var arg1 = ReferenceEquals(rhs, null) ? global::System.IntPtr.Zero : rhs.__Instance;
                var arg2 = opc;
                var arg3 = ReferenceEquals(ResTy, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (ResTy.__Instance);
                var arg4 = VK;
                var arg5 = OK;
                var arg6 = ReferenceEquals(opLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (opLoc.__Instance);
                Internal.ctor_2(__Instance, arg0, arg1, arg2, arg3, arg4, arg5, arg6, fpContractable, dead2);
            }

            protected BinaryOperator(clang.Stmt.StmtClass SC, clang.Stmt.EmptyShell Empty)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(40);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = SC;
                var arg1 = ReferenceEquals(Empty, null) ? new clang.Stmt.EmptyShell.Internal() : *(clang.Stmt.EmptyShell.Internal*) (Empty.__Instance);
                Internal.ctor_3(__Instance, arg0, arg1);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Stmt __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.SourceLocation getExprLoc()
            {
                var __ret = Internal.getExprLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getOperatorLoc()
            {
                var __ret = Internal.getOperatorLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setOperatorLoc(clang.SourceLocation L)
            {
                var arg0 = ReferenceEquals(L, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (L.__Instance);
                Internal.setOperatorLoc_0(__Instance, arg0);
            }

            public clang.BinaryOperatorKind getOpcode()
            {
                var __ret = Internal.getOpcode_0(__Instance);
                return __ret;
            }

            public void setOpcode(clang.BinaryOperatorKind O)
            {
                var arg0 = O;
                Internal.setOpcode_0(__Instance, arg0);
            }

            public clang.Expr getLHS()
            {
                var __ret = Internal.getLHS_0(__Instance);
                clang.Expr __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Expr.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Expr) clang.Expr.NativeToManagedMap[__ret];
                else __result0 = clang.Expr.__CreateInstance(__ret);
                return __result0;
            }

            public void setLHS(clang.Expr E)
            {
                var arg0 = ReferenceEquals(E, null) ? global::System.IntPtr.Zero : E.__Instance;
                Internal.setLHS_0(__Instance, arg0);
            }

            public clang.Expr getRHS()
            {
                var __ret = Internal.getRHS_0(__Instance);
                clang.Expr __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Expr.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Expr) clang.Expr.NativeToManagedMap[__ret];
                else __result0 = clang.Expr.__CreateInstance(__ret);
                return __result0;
            }

            public void setRHS(clang.Expr E)
            {
                var arg0 = ReferenceEquals(E, null) ? global::System.IntPtr.Zero : E.__Instance;
                Internal.setRHS_0(__Instance, arg0);
            }

            public clang.SourceLocation getLocStart()
            {
                var __ret = Internal.getLocStart_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLocEnd()
            {
                var __ret = Internal.getLocEnd_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public llvm.StringRef getOpcodeStr()
            {
                var __ret = Internal.getOpcodeStr_1(__Instance);
                return llvm.StringRef.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>predicates to categorize the respective opcodes.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// predicates to categorize the respective opcodes.</para>
            /// </remarks>
            public bool isPtrMemOp()
            {
                var __ret = Internal.isPtrMemOp_0(__Instance);
                return __ret;
            }

            public bool isMultiplicativeOp()
            {
                var __ret = Internal.isMultiplicativeOp_0(__Instance);
                return __ret;
            }

            public bool isAdditiveOp()
            {
                var __ret = Internal.isAdditiveOp_1(__Instance);
                return __ret;
            }

            public bool isShiftOp()
            {
                var __ret = Internal.isShiftOp_1(__Instance);
                return __ret;
            }

            public bool isBitwiseOp()
            {
                var __ret = Internal.isBitwiseOp_1(__Instance);
                return __ret;
            }

            public bool isRelationalOp()
            {
                var __ret = Internal.isRelationalOp_1(__Instance);
                return __ret;
            }

            public bool isEqualityOp()
            {
                var __ret = Internal.isEqualityOp_1(__Instance);
                return __ret;
            }

            public bool isComparisonOp()
            {
                var __ret = Internal.isComparisonOp_1(__Instance);
                return __ret;
            }

            public bool isLogicalOp()
            {
                var __ret = Internal.isLogicalOp_1(__Instance);
                return __ret;
            }

            public bool isAssignmentOp()
            {
                var __ret = Internal.isAssignmentOp_1(__Instance);
                return __ret;
            }

            public bool isCompoundAssignmentOp()
            {
                var __ret = Internal.isCompoundAssignmentOp_1(__Instance);
                return __ret;
            }

            public bool isShiftAssignOp()
            {
                var __ret = Internal.isShiftAssignOp_1(__Instance);
                return __ret;
            }

            public clang.StmtRange children()
            {
                var __ret = new clang.StmtRange.Internal();
                Internal.children_0(new IntPtr(&__ret), __Instance);
                return clang.StmtRange.__CreateInstance(__ret);
            }

            public void setFPContractable(bool FPC)
            {
                Internal.setFPContractable_0(__Instance, FPC);
            }

            public bool isFPContractable()
            {
                var __ret = Internal.isFPContractable_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>getOpcodeStr - Turn an Opcode enum value into the punctuation
            /// char it corresponds to, e.g. &quot;&lt;&lt;=&quot;.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getOpcodeStr - Turn an Opcode enum value into the punctuation
            /// char it</para>
            /// <para>  /// corresponds to, e.g. &quot;&lt;&lt;=&quot;.</para>
            /// </remarks>
            public static llvm.StringRef getOpcodeStr(clang.BinaryOperatorKind Op)
            {
                var arg0 = Op;
                var __ret = Internal.getOpcodeStr_0(arg0);
                return llvm.StringRef.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Retrieve the binary opcode that corresponds to the given
            /// overloaded operator.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the binary opcode that corresponds to the
            /// given</para>
            /// <para>  /// overloaded operator.</para>
            /// </remarks>
            public static clang.BinaryOperatorKind getOverloadedOpcode(clang.OverloadedOperatorKind OO)
            {
                var arg0 = OO;
                var __ret = Internal.getOverloadedOpcode_0(arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Retrieve the overloaded operator kind that corresponds to the
            /// given binary opcode.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the overloaded operator kind that corresponds
            /// to</para>
            /// <para>  /// the given binary opcode.</para>
            /// </remarks>
            public static clang.OverloadedOperatorKind getOverloadedOperator(clang.BinaryOperatorKind Opc)
            {
                var arg0 = Opc;
                var __ret = Internal.getOverloadedOperator_0(arg0);
                return __ret;
            }

            public static bool isAdditiveOp(clang.BinaryOperatorKind Opc)
            {
                var arg0 = Opc;
                var __ret = Internal.isAdditiveOp_0(arg0);
                return __ret;
            }

            public static bool isShiftOp(clang.BinaryOperatorKind Opc)
            {
                var arg0 = Opc;
                var __ret = Internal.isShiftOp_0(arg0);
                return __ret;
            }

            public static bool isBitwiseOp(clang.BinaryOperatorKind Opc)
            {
                var arg0 = Opc;
                var __ret = Internal.isBitwiseOp_0(arg0);
                return __ret;
            }

            public static bool isRelationalOp(clang.BinaryOperatorKind Opc)
            {
                var arg0 = Opc;
                var __ret = Internal.isRelationalOp_0(arg0);
                return __ret;
            }

            public static bool isEqualityOp(clang.BinaryOperatorKind Opc)
            {
                var arg0 = Opc;
                var __ret = Internal.isEqualityOp_0(arg0);
                return __ret;
            }

            public static bool isComparisonOp(clang.BinaryOperatorKind Opc)
            {
                var arg0 = Opc;
                var __ret = Internal.isComparisonOp_0(arg0);
                return __ret;
            }

            public static clang.BinaryOperatorKind negateComparisonOp(clang.BinaryOperatorKind Opc)
            {
                var arg0 = Opc;
                var __ret = Internal.negateComparisonOp_0(arg0);
                return __ret;
            }

            public static clang.BinaryOperatorKind reverseComparisonOp(clang.BinaryOperatorKind Opc)
            {
                var arg0 = Opc;
                var __ret = Internal.reverseComparisonOp_0(arg0);
                return __ret;
            }

            public static bool isLogicalOp(clang.BinaryOperatorKind Opc)
            {
                var arg0 = Opc;
                var __ret = Internal.isLogicalOp_0(arg0);
                return __ret;
            }

            public static bool isAssignmentOp(clang.BinaryOperatorKind Opc)
            {
                var arg0 = Opc;
                var __ret = Internal.isAssignmentOp_0(arg0);
                return __ret;
            }

            public static bool isCompoundAssignmentOp(clang.BinaryOperatorKind Opc)
            {
                var arg0 = Opc;
                var __ret = Internal.isCompoundAssignmentOp_0(arg0);
                return __ret;
            }

            public static clang.BinaryOperatorKind getOpForCompoundAssignment(clang.BinaryOperatorKind Opc)
            {
                var arg0 = Opc;
                var __ret = Internal.getOpForCompoundAssignment_0(arg0);
                return __ret;
            }

            public static bool isShiftAssignOp(clang.BinaryOperatorKind Opc)
            {
                var arg0 = Opc;
                var __ret = Internal.isShiftAssignOp_0(arg0);
                return __ret;
            }

            public static bool classof(clang.Stmt S)
            {
                var arg0 = ReferenceEquals(S, null) ? global::System.IntPtr.Zero : S.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>CompoundAssignOperator - For compound assignments (e.g. +=), we
        /// keep track of the type the operation is performed in. Due to the semantics
        /// of these operators, the operands are promoted, the arithmetic performed, an
        /// implicit conversion back to the result type done, then the assignment takes
        /// place. This captures the intermediate type which the computation is done
        /// in.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// CompoundAssignOperator - For compound assignments (e.g. +=),
        /// we keep</para>
        /// <para>/// track of the type the operation is performed in.  Due to the
        /// semantics of</para>
        /// <para>/// these operators, the operands are promoted, the arithmetic
        /// performed, an</para>
        /// <para>/// implicit conversion back to the result type done, then the
        /// assignment takes</para>
        /// <para>/// place.  This captures the intermediate type which the
        /// computation is done</para>
        /// <para>/// in.</para>
        /// </remarks>
        public unsafe partial class CompoundAssignOperator : clang.BinaryOperator, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 56)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                internal clang.Stmt._.Internal __;

                [FieldOffset(8)]
                public clang.QualType.Internal TR;

                [FieldOffset(16)]
                public uint Opc;

                [FieldOffset(16)]
                public uint FPContractable;

                [FieldOffset(20)]
                public clang.SourceLocation.Internal OpLoc;

                [FieldOffset(24)]
                public fixed global::System.IntPtr SubExprs[2];

                [FieldOffset(40)]
                public clang.QualType.Internal ComputationLHSType;

                [FieldOffset(48)]
                public clang.QualType.Internal ComputationResultType;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang22CompoundAssignOperatorC2EPNS_4ExprES2_NS_18BinaryOperatorKindENS_8QualTypeENS_13ExprValueKindENS_14ExprObjectKindES4_S4_NS_14SourceLocationEb")]
                internal static extern void ctor_0(global::System.IntPtr instance, global::System.IntPtr lhs, global::System.IntPtr rhs, clang.BinaryOperatorKind opc, clang.QualType.Internal ResType, clang.ExprValueKind VK, clang.ExprObjectKind OK, clang.QualType.Internal CompLHSType, clang.QualType.Internal CompResultType, clang.SourceLocation.Internal OpLoc, bool fpContractable);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang22CompoundAssignOperatorC2ENS_4Stmt10EmptyShellE")]
                internal static extern void ctor_1(global::System.IntPtr instance, clang.Stmt.EmptyShell.Internal Empty);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang22CompoundAssignOperatorC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang22CompoundAssignOperator21getComputationLHSTypeEv")]
                internal static extern clang.QualType.Internal getComputationLHSType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang22CompoundAssignOperator21setComputationLHSTypeENS_8QualTypeE")]
                internal static extern void setComputationLHSType_0(global::System.IntPtr instance, clang.QualType.Internal T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang22CompoundAssignOperator24getComputationResultTypeEv")]
                internal static extern clang.QualType.Internal getComputationResultType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang22CompoundAssignOperator24setComputationResultTypeENS_8QualTypeE")]
                internal static extern void setComputationResultType_0(global::System.IntPtr instance, clang.QualType.Internal T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang22CompoundAssignOperator7classofEPKNS_4StmtE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr S);
            }

            private readonly bool __ownsNativeInstance;

            public static new CompoundAssignOperator __CreateInstance(global::System.IntPtr native)
            {
                return new CompoundAssignOperator((CompoundAssignOperator.Internal*) native);
            }

            public static CompoundAssignOperator __CreateInstance(CompoundAssignOperator.Internal native)
            {
                return new CompoundAssignOperator(native);
            }

            private static CompoundAssignOperator.Internal* __CopyValue(CompoundAssignOperator.Internal native)
            {
                var ret = (CompoundAssignOperator.Internal*) Marshal.AllocHGlobal(56);
                *ret = native;
                return ret;
            }

            private CompoundAssignOperator(CompoundAssignOperator.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected CompoundAssignOperator(CompoundAssignOperator.Internal* native, bool isInternalImpl = false)
                : base((clang.BinaryOperator.Internal*) native)
            {
            }

            public CompoundAssignOperator(clang.Expr lhs, clang.Expr rhs, clang.BinaryOperatorKind opc, clang.QualType ResType, clang.ExprValueKind VK, clang.ExprObjectKind OK, clang.QualType CompLHSType, clang.QualType CompResultType, clang.SourceLocation OpLoc, bool fpContractable)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(56);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(lhs, null) ? global::System.IntPtr.Zero : lhs.__Instance;
                var arg1 = ReferenceEquals(rhs, null) ? global::System.IntPtr.Zero : rhs.__Instance;
                var arg2 = opc;
                var arg3 = ReferenceEquals(ResType, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (ResType.__Instance);
                var arg4 = VK;
                var arg5 = OK;
                var arg6 = ReferenceEquals(CompLHSType, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (CompLHSType.__Instance);
                var arg7 = ReferenceEquals(CompResultType, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (CompResultType.__Instance);
                var arg8 = ReferenceEquals(OpLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (OpLoc.__Instance);
                Internal.ctor_0(__Instance, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, fpContractable);
            }

            /// <summary>
            /// <para>Build an empty compound assignment operator expression.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Build an empty compound assignment operator
            /// expression.</para>
            /// </remarks>
            public CompoundAssignOperator(clang.Stmt.EmptyShell Empty)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(56);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(Empty, null) ? new clang.Stmt.EmptyShell.Internal() : *(clang.Stmt.EmptyShell.Internal*) (Empty.__Instance);
                Internal.ctor_1(__Instance, arg0);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Stmt __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.QualType getComputationLHSType()
            {
                var __ret = Internal.getComputationLHSType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            public void setComputationLHSType(clang.QualType T)
            {
                var arg0 = ReferenceEquals(T, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (T.__Instance);
                Internal.setComputationLHSType_0(__Instance, arg0);
            }

            public clang.QualType getComputationResultType()
            {
                var __ret = Internal.getComputationResultType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            public void setComputationResultType(clang.QualType T)
            {
                var arg0 = ReferenceEquals(T, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (T.__Instance);
                Internal.setComputationResultType_0(__Instance, arg0);
            }

            public static bool classof(clang.Stmt S)
            {
                var arg0 = ReferenceEquals(S, null) ? global::System.IntPtr.Zero : S.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>AbstractConditionalOperator - An abstract base class for
        /// ConditionalOperator and BinaryConditionalOperator.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// AbstractConditionalOperator - An abstract base class
        /// for</para>
        /// <para>/// ConditionalOperator and BinaryConditionalOperator.</para>
        /// </remarks>
        public unsafe partial class AbstractConditionalOperator : clang.Expr, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 24)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                internal clang.Stmt._.Internal __;

                [FieldOffset(8)]
                public clang.QualType.Internal TR;

                [FieldOffset(16)]
                public clang.SourceLocation.Internal QuestionLoc;

                [FieldOffset(20)]
                public clang.SourceLocation.Internal ColonLoc;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang27AbstractConditionalOperatorC2ENS_4Stmt9StmtClassENS_8QualTypeENS_13ExprValueKindENS_14ExprObjectKindEbbbbNS_14SourceLocationES6_")]
                internal static extern void ctor_0(global::System.IntPtr instance, clang.Stmt.StmtClass SC, clang.QualType.Internal T, clang.ExprValueKind VK, clang.ExprObjectKind OK, bool TD, bool VD, bool ID, bool ContainsUnexpandedParameterPack, clang.SourceLocation.Internal qloc, clang.SourceLocation.Internal cloc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang27AbstractConditionalOperatorC2ENS_4Stmt9StmtClassENS1_10EmptyShellE")]
                internal static extern void ctor_1(global::System.IntPtr instance, clang.Stmt.StmtClass SC, clang.Stmt.EmptyShell.Internal Empty);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang27AbstractConditionalOperatorC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang27AbstractConditionalOperator7getCondEv")]
                internal static extern global::System.IntPtr getCond_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang27AbstractConditionalOperator11getTrueExprEv")]
                internal static extern global::System.IntPtr getTrueExpr_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang27AbstractConditionalOperator12getFalseExprEv")]
                internal static extern global::System.IntPtr getFalseExpr_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang27AbstractConditionalOperator14getQuestionLocEv")]
                internal static extern clang.SourceLocation.Internal getQuestionLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang27AbstractConditionalOperator11getColonLocEv")]
                internal static extern clang.SourceLocation.Internal getColonLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang27AbstractConditionalOperator7classofEPKNS_4StmtE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);
            }

            private readonly bool __ownsNativeInstance;

            public static new AbstractConditionalOperator __CreateInstance(global::System.IntPtr native)
            {
                return new AbstractConditionalOperator((AbstractConditionalOperator.Internal*) native);
            }

            public static AbstractConditionalOperator __CreateInstance(AbstractConditionalOperator.Internal native)
            {
                return new AbstractConditionalOperator(native);
            }

            private static AbstractConditionalOperator.Internal* __CopyValue(AbstractConditionalOperator.Internal native)
            {
                var ret = (AbstractConditionalOperator.Internal*) Marshal.AllocHGlobal(24);
                *ret = native;
                return ret;
            }

            private AbstractConditionalOperator(AbstractConditionalOperator.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected AbstractConditionalOperator(AbstractConditionalOperator.Internal* native, bool isInternalImpl = false)
                : base((clang.Expr.Internal*) native)
            {
            }

            protected AbstractConditionalOperator(clang.Stmt.StmtClass SC, clang.QualType T, clang.ExprValueKind VK, clang.ExprObjectKind OK, bool TD, bool VD, bool ID, bool ContainsUnexpandedParameterPack, clang.SourceLocation qloc, clang.SourceLocation cloc)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(24);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = SC;
                var arg1 = ReferenceEquals(T, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (T.__Instance);
                var arg2 = VK;
                var arg3 = OK;
                var arg8 = ReferenceEquals(qloc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (qloc.__Instance);
                var arg9 = ReferenceEquals(cloc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (cloc.__Instance);
                Internal.ctor_0(__Instance, arg0, arg1, arg2, arg3, TD, VD, ID, ContainsUnexpandedParameterPack, arg8, arg9);
            }

            protected AbstractConditionalOperator(clang.Stmt.StmtClass SC, clang.Stmt.EmptyShell Empty)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(24);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = SC;
                var arg1 = ReferenceEquals(Empty, null) ? new clang.Stmt.EmptyShell.Internal() : *(clang.Stmt.EmptyShell.Internal*) (Empty.__Instance);
                Internal.ctor_1(__Instance, arg0, arg1);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Stmt __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.Expr getCond()
            {
                var __ret = Internal.getCond_0(__Instance);
                clang.Expr __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Expr.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Expr) clang.Expr.NativeToManagedMap[__ret];
                else __result0 = clang.Expr.__CreateInstance(__ret);
                return __result0;
            }

            public clang.Expr getTrueExpr()
            {
                var __ret = Internal.getTrueExpr_0(__Instance);
                clang.Expr __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Expr.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Expr) clang.Expr.NativeToManagedMap[__ret];
                else __result0 = clang.Expr.__CreateInstance(__ret);
                return __result0;
            }

            public clang.Expr getFalseExpr()
            {
                var __ret = Internal.getFalseExpr_0(__Instance);
                clang.Expr __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Expr.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Expr) clang.Expr.NativeToManagedMap[__ret];
                else __result0 = clang.Expr.__CreateInstance(__ret);
                return __result0;
            }

            public clang.SourceLocation getQuestionLoc()
            {
                var __ret = Internal.getQuestionLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getColonLoc()
            {
                var __ret = Internal.getColonLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public static bool classof(clang.Stmt T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>ConditionalOperator - The ?: ternary operator. The GNU
        /// &quot;missing middle&quot; extension is a BinaryConditionalOperator.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// ConditionalOperator - The ?: ternary operator.  The GNU
        /// &quot;missing</para>
        /// <para>/// middle&quot; extension is a BinaryConditionalOperator.</para>
        /// </remarks>
        public unsafe partial class ConditionalOperator : clang.AbstractConditionalOperator, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 48)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                internal clang.Stmt._.Internal __;

                [FieldOffset(8)]
                public clang.QualType.Internal TR;

                [FieldOffset(16)]
                public clang.SourceLocation.Internal QuestionLoc;

                [FieldOffset(20)]
                public clang.SourceLocation.Internal ColonLoc;

                [FieldOffset(24)]
                public fixed global::System.IntPtr SubExprs[3];

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang19ConditionalOperatorC2EPNS_4ExprENS_14SourceLocationES2_S3_S2_NS_8QualTypeENS_13ExprValueKindENS_14ExprObjectKindE")]
                internal static extern void ctor_0(global::System.IntPtr instance, global::System.IntPtr cond, clang.SourceLocation.Internal QLoc, global::System.IntPtr lhs, clang.SourceLocation.Internal CLoc, global::System.IntPtr rhs, clang.QualType.Internal t, clang.ExprValueKind VK, clang.ExprObjectKind OK);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang19ConditionalOperatorC2ENS_4Stmt10EmptyShellE")]
                internal static extern void ctor_1(global::System.IntPtr instance, clang.Stmt.EmptyShell.Internal Empty);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang19ConditionalOperatorC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang19ConditionalOperator7getCondEv")]
                internal static extern global::System.IntPtr getCond_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang19ConditionalOperator11getTrueExprEv")]
                internal static extern global::System.IntPtr getTrueExpr_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang19ConditionalOperator12getFalseExprEv")]
                internal static extern global::System.IntPtr getFalseExpr_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang19ConditionalOperator6getLHSEv")]
                internal static extern global::System.IntPtr getLHS_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang19ConditionalOperator6getRHSEv")]
                internal static extern global::System.IntPtr getRHS_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang19ConditionalOperator11getLocStartEv")]
                internal static extern clang.SourceLocation.Internal getLocStart_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang19ConditionalOperator9getLocEndEv")]
                internal static extern clang.SourceLocation.Internal getLocEnd_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang19ConditionalOperator7classofEPKNS_4StmtE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang19ConditionalOperator8childrenEv")]
                internal static extern void children_0(global::System.IntPtr @return, global::System.IntPtr instance);
            }

            private readonly bool __ownsNativeInstance;

            public static new ConditionalOperator __CreateInstance(global::System.IntPtr native)
            {
                return new ConditionalOperator((ConditionalOperator.Internal*) native);
            }

            public static ConditionalOperator __CreateInstance(ConditionalOperator.Internal native)
            {
                return new ConditionalOperator(native);
            }

            private static ConditionalOperator.Internal* __CopyValue(ConditionalOperator.Internal native)
            {
                var ret = (ConditionalOperator.Internal*) Marshal.AllocHGlobal(48);
                *ret = native;
                return ret;
            }

            private ConditionalOperator(ConditionalOperator.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected ConditionalOperator(ConditionalOperator.Internal* native, bool isInternalImpl = false)
                : base((clang.AbstractConditionalOperator.Internal*) native)
            {
            }

            public ConditionalOperator(clang.Expr cond, clang.SourceLocation QLoc, clang.Expr lhs, clang.SourceLocation CLoc, clang.Expr rhs, clang.QualType t, clang.ExprValueKind VK, clang.ExprObjectKind OK)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(48);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(cond, null) ? global::System.IntPtr.Zero : cond.__Instance;
                var arg1 = ReferenceEquals(QLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (QLoc.__Instance);
                var arg2 = ReferenceEquals(lhs, null) ? global::System.IntPtr.Zero : lhs.__Instance;
                var arg3 = ReferenceEquals(CLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (CLoc.__Instance);
                var arg4 = ReferenceEquals(rhs, null) ? global::System.IntPtr.Zero : rhs.__Instance;
                var arg5 = ReferenceEquals(t, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (t.__Instance);
                var arg6 = VK;
                var arg7 = OK;
                Internal.ctor_0(__Instance, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
            }

            /// <summary>
            /// <para>Build an empty conditional operator.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Build an empty conditional operator.</para>
            /// </remarks>
            public ConditionalOperator(clang.Stmt.EmptyShell Empty)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(48);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(Empty, null) ? new clang.Stmt.EmptyShell.Internal() : *(clang.Stmt.EmptyShell.Internal*) (Empty.__Instance);
                Internal.ctor_1(__Instance, arg0);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Stmt __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.Expr getCond()
            {
                var __ret = Internal.getCond_0(__Instance);
                clang.Expr __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Expr.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Expr) clang.Expr.NativeToManagedMap[__ret];
                else __result0 = clang.Expr.__CreateInstance(__ret);
                return __result0;
            }

            public clang.Expr getTrueExpr()
            {
                var __ret = Internal.getTrueExpr_0(__Instance);
                clang.Expr __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Expr.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Expr) clang.Expr.NativeToManagedMap[__ret];
                else __result0 = clang.Expr.__CreateInstance(__ret);
                return __result0;
            }

            public clang.Expr getFalseExpr()
            {
                var __ret = Internal.getFalseExpr_0(__Instance);
                clang.Expr __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Expr.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Expr) clang.Expr.NativeToManagedMap[__ret];
                else __result0 = clang.Expr.__CreateInstance(__ret);
                return __result0;
            }

            public clang.Expr getLHS()
            {
                var __ret = Internal.getLHS_0(__Instance);
                clang.Expr __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Expr.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Expr) clang.Expr.NativeToManagedMap[__ret];
                else __result0 = clang.Expr.__CreateInstance(__ret);
                return __result0;
            }

            public clang.Expr getRHS()
            {
                var __ret = Internal.getRHS_0(__Instance);
                clang.Expr __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Expr.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Expr) clang.Expr.NativeToManagedMap[__ret];
                else __result0 = clang.Expr.__CreateInstance(__ret);
                return __result0;
            }

            public clang.SourceLocation getLocStart()
            {
                var __ret = Internal.getLocStart_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLocEnd()
            {
                var __ret = Internal.getLocEnd_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.StmtRange children()
            {
                var __ret = new clang.StmtRange.Internal();
                Internal.children_0(new IntPtr(&__ret), __Instance);
                return clang.StmtRange.__CreateInstance(__ret);
            }

            public static bool classof(clang.Stmt T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>BinaryConditionalOperator - The GNU extension to the conditional
        /// operator which allows the middle operand to be omitted.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// BinaryConditionalOperator - The GNU extension to the
        /// conditional</para>
        /// <para>/// operator which allows the middle operand to be
        /// omitted.</para>
        /// <para>///</para>
        /// <para>/// This is a different expression kind on the assumption that
        /// almost</para>
        /// <para>/// every client ends up needing to know that these are
        /// different.</para>
        /// </remarks>
        public unsafe partial class BinaryConditionalOperator : clang.AbstractConditionalOperator, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 64)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                internal clang.Stmt._.Internal __;

                [FieldOffset(8)]
                public clang.QualType.Internal TR;

                [FieldOffset(16)]
                public clang.SourceLocation.Internal QuestionLoc;

                [FieldOffset(20)]
                public clang.SourceLocation.Internal ColonLoc;

                [FieldOffset(24)]
                public fixed global::System.IntPtr SubExprs[4];

                [FieldOffset(56)]
                public global::System.IntPtr OpaqueValue;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang25BinaryConditionalOperatorC2EPNS_4ExprEPNS_15OpaqueValueExprES2_S2_S2_NS_14SourceLocationES5_NS_8QualTypeENS_13ExprValueKindENS_14ExprObjectKindE")]
                internal static extern void ctor_0(global::System.IntPtr instance, global::System.IntPtr common, global::System.IntPtr opaqueValue, global::System.IntPtr cond, global::System.IntPtr lhs, global::System.IntPtr rhs, clang.SourceLocation.Internal qloc, clang.SourceLocation.Internal cloc, clang.QualType.Internal t, clang.ExprValueKind VK, clang.ExprObjectKind OK);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang25BinaryConditionalOperatorC2ENS_4Stmt10EmptyShellE")]
                internal static extern void ctor_1(global::System.IntPtr instance, clang.Stmt.EmptyShell.Internal Empty);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang25BinaryConditionalOperatorC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang25BinaryConditionalOperator9getCommonEv")]
                internal static extern global::System.IntPtr getCommon_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang25BinaryConditionalOperator14getOpaqueValueEv")]
                internal static extern global::System.IntPtr getOpaqueValue_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang25BinaryConditionalOperator7getCondEv")]
                internal static extern global::System.IntPtr getCond_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang25BinaryConditionalOperator11getTrueExprEv")]
                internal static extern global::System.IntPtr getTrueExpr_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang25BinaryConditionalOperator12getFalseExprEv")]
                internal static extern global::System.IntPtr getFalseExpr_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang25BinaryConditionalOperator11getLocStartEv")]
                internal static extern clang.SourceLocation.Internal getLocStart_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang25BinaryConditionalOperator9getLocEndEv")]
                internal static extern clang.SourceLocation.Internal getLocEnd_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang25BinaryConditionalOperator7classofEPKNS_4StmtE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang25BinaryConditionalOperator8childrenEv")]
                internal static extern void children_0(global::System.IntPtr @return, global::System.IntPtr instance);
            }

            private readonly bool __ownsNativeInstance;

            public static new BinaryConditionalOperator __CreateInstance(global::System.IntPtr native)
            {
                return new BinaryConditionalOperator((BinaryConditionalOperator.Internal*) native);
            }

            public static BinaryConditionalOperator __CreateInstance(BinaryConditionalOperator.Internal native)
            {
                return new BinaryConditionalOperator(native);
            }

            private static BinaryConditionalOperator.Internal* __CopyValue(BinaryConditionalOperator.Internal native)
            {
                var ret = (BinaryConditionalOperator.Internal*) Marshal.AllocHGlobal(64);
                *ret = native;
                return ret;
            }

            private BinaryConditionalOperator(BinaryConditionalOperator.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected BinaryConditionalOperator(BinaryConditionalOperator.Internal* native, bool isInternalImpl = false)
                : base((clang.AbstractConditionalOperator.Internal*) native)
            {
            }

            public BinaryConditionalOperator(clang.Expr common, clang.OpaqueValueExpr opaqueValue, clang.Expr cond, clang.Expr lhs, clang.Expr rhs, clang.SourceLocation qloc, clang.SourceLocation cloc, clang.QualType t, clang.ExprValueKind VK, clang.ExprObjectKind OK)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(64);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(common, null) ? global::System.IntPtr.Zero : common.__Instance;
                var arg1 = ReferenceEquals(opaqueValue, null) ? global::System.IntPtr.Zero : opaqueValue.__Instance;
                var arg2 = ReferenceEquals(cond, null) ? global::System.IntPtr.Zero : cond.__Instance;
                var arg3 = ReferenceEquals(lhs, null) ? global::System.IntPtr.Zero : lhs.__Instance;
                var arg4 = ReferenceEquals(rhs, null) ? global::System.IntPtr.Zero : rhs.__Instance;
                var arg5 = ReferenceEquals(qloc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (qloc.__Instance);
                var arg6 = ReferenceEquals(cloc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (cloc.__Instance);
                var arg7 = ReferenceEquals(t, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (t.__Instance);
                var arg8 = VK;
                var arg9 = OK;
                Internal.ctor_0(__Instance, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9);
            }

            /// <summary>
            /// <para>Build an empty conditional operator.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Build an empty conditional operator.</para>
            /// </remarks>
            public BinaryConditionalOperator(clang.Stmt.EmptyShell Empty)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(64);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(Empty, null) ? new clang.Stmt.EmptyShell.Internal() : *(clang.Stmt.EmptyShell.Internal*) (Empty.__Instance);
                Internal.ctor_1(__Instance, arg0);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Stmt __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            /// <summary>
            /// <para>getCommon - Return the common expression, written to the left of
            /// the condition. The opaque value will be bound to the result of this
            /// expression.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief getCommon - Return the common expression, written to
            /// the</para>
            /// <para>  ///   left of the condition.  The opaque value will be bound to
            /// the</para>
            /// <para>  ///   result of this expression.</para>
            /// </remarks>
            public clang.Expr getCommon()
            {
                var __ret = Internal.getCommon_0(__Instance);
                clang.Expr __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Expr.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Expr) clang.Expr.NativeToManagedMap[__ret];
                else __result0 = clang.Expr.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>getOpaqueValue - Return the opaque value placeholder.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief getOpaqueValue - Return the opaque value
            /// placeholder.</para>
            /// </remarks>
            public clang.OpaqueValueExpr getOpaqueValue()
            {
                var __ret = Internal.getOpaqueValue_0(__Instance);
                clang.OpaqueValueExpr __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.OpaqueValueExpr.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.OpaqueValueExpr) clang.OpaqueValueExpr.NativeToManagedMap[__ret];
                else __result0 = clang.OpaqueValueExpr.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>getCond - Return the condition expression; this is defined in
            /// terms of the opaque value.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief getCond - Return the condition expression; this is
            /// defined</para>
            /// <para>  ///   in terms of the opaque value.</para>
            /// </remarks>
            public clang.Expr getCond()
            {
                var __ret = Internal.getCond_0(__Instance);
                clang.Expr __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Expr.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Expr) clang.Expr.NativeToManagedMap[__ret];
                else __result0 = clang.Expr.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>getTrueExpr - Return the subexpression which will be evaluated if
            /// the condition evaluates to true; this is defined in terms of the opaque
            /// value.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief getTrueExpr - Return the subexpression which will
            /// be</para>
            /// <para>  ///   evaluated if the condition evaluates to true;  this is
            /// defined</para>
            /// <para>  ///   in terms of the opaque value.</para>
            /// </remarks>
            public clang.Expr getTrueExpr()
            {
                var __ret = Internal.getTrueExpr_0(__Instance);
                clang.Expr __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Expr.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Expr) clang.Expr.NativeToManagedMap[__ret];
                else __result0 = clang.Expr.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>getFalseExpr - Return the subexpression which will be evaluated
            /// if the condnition evaluates to false; this is defined in terms of the
            /// opaque value.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief getFalseExpr - Return the subexpression which will
            /// be</para>
            /// <para>  ///   evaluated if the condnition evaluates to false; this
            /// is</para>
            /// <para>  ///   defined in terms of the opaque value.</para>
            /// </remarks>
            public clang.Expr getFalseExpr()
            {
                var __ret = Internal.getFalseExpr_0(__Instance);
                clang.Expr __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Expr.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Expr) clang.Expr.NativeToManagedMap[__ret];
                else __result0 = clang.Expr.__CreateInstance(__ret);
                return __result0;
            }

            public clang.SourceLocation getLocStart()
            {
                var __ret = Internal.getLocStart_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLocEnd()
            {
                var __ret = Internal.getLocEnd_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.StmtRange children()
            {
                var __ret = new clang.StmtRange.Internal();
                Internal.children_0(new IntPtr(&__ret), __Instance);
                return clang.StmtRange.__CreateInstance(__ret);
            }

            public static bool classof(clang.Stmt T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>AddrLabelExpr - The GNU address of label extension, representing
        /// &amp;&amp;label.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// AddrLabelExpr - The GNU address of label extension,
        /// representing &amp;&amp;label.</para>
        /// </remarks>
        public unsafe partial class AddrLabelExpr : clang.Expr, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 32)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                internal clang.Stmt._.Internal __;

                [FieldOffset(8)]
                public clang.QualType.Internal TR;

                [FieldOffset(16)]
                public clang.SourceLocation.Internal AmpAmpLoc;

                [FieldOffset(20)]
                public clang.SourceLocation.Internal LabelLoc;

                [FieldOffset(24)]
                public global::System.IntPtr Label;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13AddrLabelExprC2ENS_14SourceLocationES1_PNS_9LabelDeclENS_8QualTypeE")]
                internal static extern void ctor_0(global::System.IntPtr instance, clang.SourceLocation.Internal AALoc, clang.SourceLocation.Internal LLoc, global::System.IntPtr L, clang.QualType.Internal t);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13AddrLabelExprC2ENS_4Stmt10EmptyShellE")]
                internal static extern void ctor_1(global::System.IntPtr instance, clang.Stmt.EmptyShell.Internal Empty);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13AddrLabelExprC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13AddrLabelExpr12getAmpAmpLocEv")]
                internal static extern clang.SourceLocation.Internal getAmpAmpLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13AddrLabelExpr12setAmpAmpLocENS_14SourceLocationE")]
                internal static extern void setAmpAmpLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal L);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13AddrLabelExpr11getLabelLocEv")]
                internal static extern clang.SourceLocation.Internal getLabelLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13AddrLabelExpr11setLabelLocENS_14SourceLocationE")]
                internal static extern void setLabelLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal L);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13AddrLabelExpr11getLocStartEv")]
                internal static extern clang.SourceLocation.Internal getLocStart_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13AddrLabelExpr9getLocEndEv")]
                internal static extern clang.SourceLocation.Internal getLocEnd_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13AddrLabelExpr8getLabelEv")]
                internal static extern global::System.IntPtr getLabel_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13AddrLabelExpr8setLabelEPNS_9LabelDeclE")]
                internal static extern void setLabel_0(global::System.IntPtr instance, global::System.IntPtr L);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13AddrLabelExpr7classofEPKNS_4StmtE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13AddrLabelExpr8childrenEv")]
                internal static extern void children_0(global::System.IntPtr @return, global::System.IntPtr instance);
            }

            private readonly bool __ownsNativeInstance;

            public static new AddrLabelExpr __CreateInstance(global::System.IntPtr native)
            {
                return new AddrLabelExpr((AddrLabelExpr.Internal*) native);
            }

            public static AddrLabelExpr __CreateInstance(AddrLabelExpr.Internal native)
            {
                return new AddrLabelExpr(native);
            }

            private static AddrLabelExpr.Internal* __CopyValue(AddrLabelExpr.Internal native)
            {
                var ret = (AddrLabelExpr.Internal*) Marshal.AllocHGlobal(32);
                *ret = native;
                return ret;
            }

            private AddrLabelExpr(AddrLabelExpr.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected AddrLabelExpr(AddrLabelExpr.Internal* native, bool isInternalImpl = false)
                : base((clang.Expr.Internal*) native)
            {
            }

            public AddrLabelExpr(clang.SourceLocation AALoc, clang.SourceLocation LLoc, clang.LabelDecl L, clang.QualType t)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(32);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(AALoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (AALoc.__Instance);
                var arg1 = ReferenceEquals(LLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (LLoc.__Instance);
                var arg2 = ReferenceEquals(L, null) ? global::System.IntPtr.Zero : L.__Instance;
                var arg3 = ReferenceEquals(t, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (t.__Instance);
                Internal.ctor_0(__Instance, arg0, arg1, arg2, arg3);
            }

            /// <summary>
            /// <para>Build an empty address of a label expression.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Build an empty address of a label expression.</para>
            /// </remarks>
            public AddrLabelExpr(clang.Stmt.EmptyShell Empty)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(32);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(Empty, null) ? new clang.Stmt.EmptyShell.Internal() : *(clang.Stmt.EmptyShell.Internal*) (Empty.__Instance);
                Internal.ctor_1(__Instance, arg0);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Stmt __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.SourceLocation getAmpAmpLoc()
            {
                var __ret = Internal.getAmpAmpLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setAmpAmpLoc(clang.SourceLocation L)
            {
                var arg0 = ReferenceEquals(L, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (L.__Instance);
                Internal.setAmpAmpLoc_0(__Instance, arg0);
            }

            public clang.SourceLocation getLabelLoc()
            {
                var __ret = Internal.getLabelLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setLabelLoc(clang.SourceLocation L)
            {
                var arg0 = ReferenceEquals(L, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (L.__Instance);
                Internal.setLabelLoc_0(__Instance, arg0);
            }

            public clang.SourceLocation getLocStart()
            {
                var __ret = Internal.getLocStart_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLocEnd()
            {
                var __ret = Internal.getLocEnd_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.LabelDecl getLabel()
            {
                var __ret = Internal.getLabel_0(__Instance);
                clang.LabelDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.LabelDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.LabelDecl) clang.LabelDecl.NativeToManagedMap[__ret];
                else clang.LabelDecl.NativeToManagedMap[__ret] = __result0 = (clang.LabelDecl) clang.LabelDecl.__CreateInstance(__ret);
                return __result0;
            }

            public void setLabel(clang.LabelDecl L)
            {
                var arg0 = ReferenceEquals(L, null) ? global::System.IntPtr.Zero : L.__Instance;
                Internal.setLabel_0(__Instance, arg0);
            }

            public clang.StmtRange children()
            {
                var __ret = new clang.StmtRange.Internal();
                Internal.children_0(new IntPtr(&__ret), __Instance);
                return clang.StmtRange.__CreateInstance(__ret);
            }

            public static bool classof(clang.Stmt T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>StmtExpr - This is the GNU Statement Expression extension: ({int
        /// X=4; X;}). The StmtExpr contains a single CompoundStmt node, which it
        /// evaluates and takes the value of the last subexpression.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// StmtExpr - This is the GNU Statement Expression extension:
        /// ({int X=4; X;}).</para>
        /// <para>/// The StmtExpr contains a single CompoundStmt node, which it
        /// evaluates and</para>
        /// <para>/// takes the value of the last subexpression.</para>
        /// <para>///</para>
        /// <para>/// A StmtExpr is always an r-value; values &quot;returned&quot;
        /// out of a</para>
        /// <para>/// StmtExpr will be copied.</para>
        /// </remarks>
        public unsafe partial class StmtExpr : clang.Expr, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 32)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                internal clang.Stmt._.Internal __;

                [FieldOffset(8)]
                public clang.QualType.Internal TR;

                [FieldOffset(16)]
                public global::System.IntPtr SubStmt;

                [FieldOffset(24)]
                public clang.SourceLocation.Internal LParenLoc;

                [FieldOffset(28)]
                public clang.SourceLocation.Internal RParenLoc;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8StmtExprC2EPNS_12CompoundStmtENS_8QualTypeENS_14SourceLocationES4_")]
                internal static extern void ctor_0(global::System.IntPtr instance, global::System.IntPtr substmt, clang.QualType.Internal T, clang.SourceLocation.Internal lp, clang.SourceLocation.Internal rp);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8StmtExprC2ENS_4Stmt10EmptyShellE")]
                internal static extern void ctor_1(global::System.IntPtr instance, clang.Stmt.EmptyShell.Internal Empty);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8StmtExprC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8StmtExpr10getSubStmtEv")]
                internal static extern global::System.IntPtr getSubStmt_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8StmtExpr10setSubStmtEPNS_12CompoundStmtE")]
                internal static extern void setSubStmt_0(global::System.IntPtr instance, global::System.IntPtr S);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8StmtExpr11getLocStartEv")]
                internal static extern clang.SourceLocation.Internal getLocStart_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8StmtExpr9getLocEndEv")]
                internal static extern clang.SourceLocation.Internal getLocEnd_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8StmtExpr12getLParenLocEv")]
                internal static extern clang.SourceLocation.Internal getLParenLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8StmtExpr12setLParenLocENS_14SourceLocationE")]
                internal static extern void setLParenLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal L);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8StmtExpr12getRParenLocEv")]
                internal static extern clang.SourceLocation.Internal getRParenLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8StmtExpr12setRParenLocENS_14SourceLocationE")]
                internal static extern void setRParenLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal L);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8StmtExpr7classofEPKNS_4StmtE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8StmtExpr8childrenEv")]
                internal static extern void children_0(global::System.IntPtr @return, global::System.IntPtr instance);
            }

            private readonly bool __ownsNativeInstance;

            public static new StmtExpr __CreateInstance(global::System.IntPtr native)
            {
                return new StmtExpr((StmtExpr.Internal*) native);
            }

            public static StmtExpr __CreateInstance(StmtExpr.Internal native)
            {
                return new StmtExpr(native);
            }

            private static StmtExpr.Internal* __CopyValue(StmtExpr.Internal native)
            {
                var ret = (StmtExpr.Internal*) Marshal.AllocHGlobal(32);
                *ret = native;
                return ret;
            }

            private StmtExpr(StmtExpr.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected StmtExpr(StmtExpr.Internal* native, bool isInternalImpl = false)
                : base((clang.Expr.Internal*) native)
            {
            }

            public StmtExpr(clang.CompoundStmt substmt, clang.QualType T, clang.SourceLocation lp, clang.SourceLocation rp)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(32);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(substmt, null) ? global::System.IntPtr.Zero : substmt.__Instance;
                var arg1 = ReferenceEquals(T, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (T.__Instance);
                var arg2 = ReferenceEquals(lp, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (lp.__Instance);
                var arg3 = ReferenceEquals(rp, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (rp.__Instance);
                Internal.ctor_0(__Instance, arg0, arg1, arg2, arg3);
            }

            /// <summary>
            /// <para>Build an empty statement expression.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Build an empty statement expression.</para>
            /// </remarks>
            public StmtExpr(clang.Stmt.EmptyShell Empty)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(32);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(Empty, null) ? new clang.Stmt.EmptyShell.Internal() : *(clang.Stmt.EmptyShell.Internal*) (Empty.__Instance);
                Internal.ctor_1(__Instance, arg0);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Stmt __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.CompoundStmt getSubStmt()
            {
                var __ret = Internal.getSubStmt_0(__Instance);
                clang.CompoundStmt __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.CompoundStmt.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.CompoundStmt) clang.CompoundStmt.NativeToManagedMap[__ret];
                else __result0 = clang.CompoundStmt.__CreateInstance(__ret);
                return __result0;
            }

            public void setSubStmt(clang.CompoundStmt S)
            {
                var arg0 = ReferenceEquals(S, null) ? global::System.IntPtr.Zero : S.__Instance;
                Internal.setSubStmt_0(__Instance, arg0);
            }

            public clang.SourceLocation getLocStart()
            {
                var __ret = Internal.getLocStart_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLocEnd()
            {
                var __ret = Internal.getLocEnd_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLParenLoc()
            {
                var __ret = Internal.getLParenLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setLParenLoc(clang.SourceLocation L)
            {
                var arg0 = ReferenceEquals(L, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (L.__Instance);
                Internal.setLParenLoc_0(__Instance, arg0);
            }

            public clang.SourceLocation getRParenLoc()
            {
                var __ret = Internal.getRParenLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setRParenLoc(clang.SourceLocation L)
            {
                var arg0 = ReferenceEquals(L, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (L.__Instance);
                Internal.setRParenLoc_0(__Instance, arg0);
            }

            public clang.StmtRange children()
            {
                var __ret = new clang.StmtRange.Internal();
                Internal.children_0(new IntPtr(&__ret), __Instance);
                return clang.StmtRange.__CreateInstance(__ret);
            }

            public static bool classof(clang.Stmt T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>ShuffleVectorExpr - clang-specific builtin-in function
        /// __builtin_shufflevector. This AST node represents a operator that does a
        /// constant shuffle, similar to LLVM's shufflevector instruction. It takes two
        /// vectors and a variable number of constant indices, and returns the
        /// appropriately shuffled vector.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// ShuffleVectorExpr - clang-specific builtin-in function</para>
        /// <para>/// __builtin_shufflevector.</para>
        /// <para>/// This AST node represents a operator that does a
        /// constant</para>
        /// <para>/// shuffle, similar to LLVM's shufflevector instruction. It
        /// takes</para>
        /// <para>/// two vectors and a variable number of constant indices,</para>
        /// <para>/// and returns the appropriately shuffled vector.</para>
        /// </remarks>
        public unsafe partial class ShuffleVectorExpr : clang.Expr, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 40)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                internal clang.Stmt._.Internal __;

                [FieldOffset(8)]
                public clang.QualType.Internal TR;

                [FieldOffset(16)]
                public clang.SourceLocation.Internal BuiltinLoc;

                [FieldOffset(20)]
                public clang.SourceLocation.Internal RParenLoc;

                [FieldOffset(24)]
                public global::System.IntPtr SubExprs;

                [FieldOffset(32)]
                public uint NumExprs;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17ShuffleVectorExprC2ENS_4Stmt10EmptyShellE")]
                internal static extern void ctor_1(global::System.IntPtr instance, clang.Stmt.EmptyShell.Internal Empty);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17ShuffleVectorExprC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17ShuffleVectorExpr13getBuiltinLocEv")]
                internal static extern clang.SourceLocation.Internal getBuiltinLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17ShuffleVectorExpr13setBuiltinLocENS_14SourceLocationE")]
                internal static extern void setBuiltinLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal L);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17ShuffleVectorExpr12getRParenLocEv")]
                internal static extern clang.SourceLocation.Internal getRParenLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17ShuffleVectorExpr12setRParenLocENS_14SourceLocationE")]
                internal static extern void setRParenLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal L);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17ShuffleVectorExpr11getLocStartEv")]
                internal static extern clang.SourceLocation.Internal getLocStart_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17ShuffleVectorExpr9getLocEndEv")]
                internal static extern clang.SourceLocation.Internal getLocEnd_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17ShuffleVectorExpr7classofEPKNS_4StmtE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17ShuffleVectorExpr14getNumSubExprsEv")]
                internal static extern uint getNumSubExprs_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17ShuffleVectorExpr11getSubExprsEv")]
                internal static extern global::System.IntPtr getSubExprs_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17ShuffleVectorExpr7getExprEj")]
                internal static extern global::System.IntPtr getExpr_0(global::System.IntPtr instance, uint Index);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17ShuffleVectorExpr8childrenEv")]
                internal static extern void children_0(global::System.IntPtr @return, global::System.IntPtr instance);
            }

            private readonly bool __ownsNativeInstance;

            public static new ShuffleVectorExpr __CreateInstance(global::System.IntPtr native)
            {
                return new ShuffleVectorExpr((ShuffleVectorExpr.Internal*) native);
            }

            public static ShuffleVectorExpr __CreateInstance(ShuffleVectorExpr.Internal native)
            {
                return new ShuffleVectorExpr(native);
            }

            private static ShuffleVectorExpr.Internal* __CopyValue(ShuffleVectorExpr.Internal native)
            {
                var ret = (ShuffleVectorExpr.Internal*) Marshal.AllocHGlobal(40);
                *ret = native;
                return ret;
            }

            private ShuffleVectorExpr(ShuffleVectorExpr.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected ShuffleVectorExpr(ShuffleVectorExpr.Internal* native, bool isInternalImpl = false)
                : base((clang.Expr.Internal*) native)
            {
            }

            /// <summary>
            /// <para>Build an empty vector-shuffle expression.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Build an empty vector-shuffle expression.</para>
            /// </remarks>
            public ShuffleVectorExpr(clang.Stmt.EmptyShell Empty)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(40);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(Empty, null) ? new clang.Stmt.EmptyShell.Internal() : *(clang.Stmt.EmptyShell.Internal*) (Empty.__Instance);
                Internal.ctor_1(__Instance, arg0);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Stmt __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.SourceLocation getBuiltinLoc()
            {
                var __ret = Internal.getBuiltinLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setBuiltinLoc(clang.SourceLocation L)
            {
                var arg0 = ReferenceEquals(L, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (L.__Instance);
                Internal.setBuiltinLoc_0(__Instance, arg0);
            }

            public clang.SourceLocation getRParenLoc()
            {
                var __ret = Internal.getRParenLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setRParenLoc(clang.SourceLocation L)
            {
                var arg0 = ReferenceEquals(L, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (L.__Instance);
                Internal.setRParenLoc_0(__Instance, arg0);
            }

            public clang.SourceLocation getLocStart()
            {
                var __ret = Internal.getLocStart_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLocEnd()
            {
                var __ret = Internal.getLocEnd_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>getNumSubExprs - Return the size of the SubExprs array. This
            /// includes the constant expression, the actual arguments passed in, and the
            /// function pointers.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getNumSubExprs - Return the size of the SubExprs array.  This
            /// includes the</para>
            /// <para>  /// constant expression, the actual arguments passed in, and
            /// the function</para>
            /// <para>  /// pointers.</para>
            /// </remarks>
            public uint getNumSubExprs()
            {
                var __ret = Internal.getNumSubExprs_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Retrieve the array of expressions.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the array of expressions.</para>
            /// </remarks>
            public clang.Expr getSubExprs()
            {
                var __ret = Internal.getSubExprs_0(__Instance);
                clang.Expr __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Expr.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Expr) clang.Expr.NativeToManagedMap[__ret];
                else __result0 = clang.Expr.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>getExpr - Return the Expr at the specified index.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getExpr - Return the Expr at the specified index.</para>
            /// </remarks>
            public clang.Expr getExpr(uint Index)
            {
                var __ret = Internal.getExpr_0(__Instance, Index);
                clang.Expr __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Expr.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Expr) clang.Expr.NativeToManagedMap[__ret];
                else __result0 = clang.Expr.__CreateInstance(__ret);
                return __result0;
            }

            public clang.StmtRange children()
            {
                var __ret = new clang.StmtRange.Internal();
                Internal.children_0(new IntPtr(&__ret), __Instance);
                return clang.StmtRange.__CreateInstance(__ret);
            }

            public static bool classof(clang.Stmt T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>ConvertVectorExpr - Clang builtin function
        /// __builtin_convertvector This AST node provides support for converting a
        /// vector type to another vector type of the same arity.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// ConvertVectorExpr - Clang builtin function
        /// __builtin_convertvector</para>
        /// <para>/// This AST node provides support for converting a vector type
        /// to another</para>
        /// <para>/// vector type of the same arity.</para>
        /// </remarks>
        public unsafe partial class ConvertVectorExpr : clang.Expr, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 40)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                internal clang.Stmt._.Internal __;

                [FieldOffset(8)]
                public clang.QualType.Internal TR;

                [FieldOffset(16)]
                public global::System.IntPtr SrcExpr;

                [FieldOffset(24)]
                public global::System.IntPtr TInfo;

                [FieldOffset(32)]
                public clang.SourceLocation.Internal BuiltinLoc;

                [FieldOffset(36)]
                public clang.SourceLocation.Internal RParenLoc;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17ConvertVectorExprC2EPNS_4ExprEPNS_14TypeSourceInfoENS_8QualTypeENS_13ExprValueKindENS_14ExprObjectKindENS_14SourceLocationES8_")]
                internal static extern void ctor_1(global::System.IntPtr instance, global::System.IntPtr SrcExpr, global::System.IntPtr TI, clang.QualType.Internal DstType, clang.ExprValueKind VK, clang.ExprObjectKind OK, clang.SourceLocation.Internal BuiltinLoc, clang.SourceLocation.Internal RParenLoc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17ConvertVectorExprC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17ConvertVectorExpr10getSrcExprEv")]
                internal static extern global::System.IntPtr getSrcExpr_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17ConvertVectorExpr17getTypeSourceInfoEv")]
                internal static extern global::System.IntPtr getTypeSourceInfo_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17ConvertVectorExpr17setTypeSourceInfoEPNS_14TypeSourceInfoE")]
                internal static extern void setTypeSourceInfo_0(global::System.IntPtr instance, global::System.IntPtr ti);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17ConvertVectorExpr13getBuiltinLocEv")]
                internal static extern clang.SourceLocation.Internal getBuiltinLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17ConvertVectorExpr12getRParenLocEv")]
                internal static extern clang.SourceLocation.Internal getRParenLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17ConvertVectorExpr11getLocStartEv")]
                internal static extern clang.SourceLocation.Internal getLocStart_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17ConvertVectorExpr9getLocEndEv")]
                internal static extern clang.SourceLocation.Internal getLocEnd_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17ConvertVectorExpr7classofEPKNS_4StmtE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17ConvertVectorExpr8childrenEv")]
                internal static extern void children_0(global::System.IntPtr @return, global::System.IntPtr instance);
            }

            private readonly bool __ownsNativeInstance;

            public static new ConvertVectorExpr __CreateInstance(global::System.IntPtr native)
            {
                return new ConvertVectorExpr((ConvertVectorExpr.Internal*) native);
            }

            public static ConvertVectorExpr __CreateInstance(ConvertVectorExpr.Internal native)
            {
                return new ConvertVectorExpr(native);
            }

            private static ConvertVectorExpr.Internal* __CopyValue(ConvertVectorExpr.Internal native)
            {
                var ret = (ConvertVectorExpr.Internal*) Marshal.AllocHGlobal(40);
                *ret = native;
                return ret;
            }

            private ConvertVectorExpr(ConvertVectorExpr.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected ConvertVectorExpr(ConvertVectorExpr.Internal* native, bool isInternalImpl = false)
                : base((clang.Expr.Internal*) native)
            {
            }

            public ConvertVectorExpr(clang.Expr SrcExpr, clang.TypeSourceInfo TI, clang.QualType DstType, clang.ExprValueKind VK, clang.ExprObjectKind OK, clang.SourceLocation BuiltinLoc, clang.SourceLocation RParenLoc)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(40);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(SrcExpr, null) ? global::System.IntPtr.Zero : SrcExpr.__Instance;
                var arg1 = ReferenceEquals(TI, null) ? global::System.IntPtr.Zero : TI.__Instance;
                var arg2 = ReferenceEquals(DstType, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (DstType.__Instance);
                var arg3 = VK;
                var arg4 = OK;
                var arg5 = ReferenceEquals(BuiltinLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (BuiltinLoc.__Instance);
                var arg6 = ReferenceEquals(RParenLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (RParenLoc.__Instance);
                Internal.ctor_1(__Instance, arg0, arg1, arg2, arg3, arg4, arg5, arg6);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Stmt __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            /// <summary>
            /// <para>getSrcExpr - Return the Expr to be converted.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getSrcExpr - Return the Expr to be converted.</para>
            /// </remarks>
            public clang.Expr getSrcExpr()
            {
                var __ret = Internal.getSrcExpr_0(__Instance);
                clang.Expr __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Expr.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Expr) clang.Expr.NativeToManagedMap[__ret];
                else __result0 = clang.Expr.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>getTypeSourceInfo - Return the destination type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getTypeSourceInfo - Return the destination type.</para>
            /// </remarks>
            public clang.TypeSourceInfo getTypeSourceInfo()
            {
                var __ret = Internal.getTypeSourceInfo_0(__Instance);
                clang.TypeSourceInfo __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.TypeSourceInfo.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.TypeSourceInfo) clang.TypeSourceInfo.NativeToManagedMap[__ret];
                else __result0 = clang.TypeSourceInfo.__CreateInstance(__ret);
                return __result0;
            }

            public void setTypeSourceInfo(clang.TypeSourceInfo ti)
            {
                var arg0 = ReferenceEquals(ti, null) ? global::System.IntPtr.Zero : ti.__Instance;
                Internal.setTypeSourceInfo_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>getBuiltinLoc - Return the location of the
            /// __builtin_convertvector token.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getBuiltinLoc - Return the location of the
            /// __builtin_convertvector token.</para>
            /// </remarks>
            public clang.SourceLocation getBuiltinLoc()
            {
                var __ret = Internal.getBuiltinLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>getRParenLoc - Return the location of final right
            /// parenthesis.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getRParenLoc - Return the location of final right
            /// parenthesis.</para>
            /// </remarks>
            public clang.SourceLocation getRParenLoc()
            {
                var __ret = Internal.getRParenLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLocStart()
            {
                var __ret = Internal.getLocStart_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLocEnd()
            {
                var __ret = Internal.getLocEnd_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.StmtRange children()
            {
                var __ret = new clang.StmtRange.Internal();
                Internal.children_0(new IntPtr(&__ret), __Instance);
                return clang.StmtRange.__CreateInstance(__ret);
            }

            public static bool classof(clang.Stmt T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>ChooseExpr - GNU builtin-in function __builtin_choose_expr. This
        /// AST node is similar to the conditional operator (?:) in C, with the
        /// following exceptions: - the test expression must be a integer constant
        /// expression. - the expression returned acts like the chosen subexpression in
        /// every visible way: the type is the same as that of the chosen
        /// subexpression, and all predicates (whether it's an l-value, whether it's an
        /// integer constant expression, etc.) return the same result as for the chosen
        /// sub-expression.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// ChooseExpr - GNU builtin-in function
        /// __builtin_choose_expr.</para>
        /// <para>/// This AST node is similar to the conditional operator (?:) in
        /// C, with</para>
        /// <para>/// the following exceptions:</para>
        /// <para>/// - the test expression must be a integer constant
        /// expression.</para>
        /// <para>/// - the expression returned acts like the chosen subexpression
        /// in every</para>
        /// <para>///   visible way: the type is the same as that of the chosen
        /// subexpression,</para>
        /// <para>///   and all predicates (whether it's an l-value, whether it's
        /// an integer</para>
        /// <para>///   constant expression, etc.) return the same result as for
        /// the chosen</para>
        /// <para>///   sub-expression.</para>
        /// </remarks>
        public unsafe partial class ChooseExpr : clang.Expr, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 56)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                internal clang.Stmt._.Internal __;

                [FieldOffset(8)]
                public clang.QualType.Internal TR;

                [FieldOffset(16)]
                public fixed global::System.IntPtr SubExprs[3];

                [FieldOffset(40)]
                public clang.SourceLocation.Internal BuiltinLoc;

                [FieldOffset(44)]
                public clang.SourceLocation.Internal RParenLoc;

                [FieldOffset(48)]
                public bool CondIsTrue;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ChooseExprC2ENS_14SourceLocationEPNS_4ExprES3_S3_NS_8QualTypeENS_13ExprValueKindENS_14ExprObjectKindES1_bbb")]
                internal static extern void ctor_0(global::System.IntPtr instance, clang.SourceLocation.Internal BLoc, global::System.IntPtr cond, global::System.IntPtr lhs, global::System.IntPtr rhs, clang.QualType.Internal t, clang.ExprValueKind VK, clang.ExprObjectKind OK, clang.SourceLocation.Internal RP, bool condIsTrue, bool TypeDependent, bool ValueDependent);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ChooseExprC2ENS_4Stmt10EmptyShellE")]
                internal static extern void ctor_1(global::System.IntPtr instance, clang.Stmt.EmptyShell.Internal Empty);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ChooseExprC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ChooseExpr15isConditionTrueEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isConditionTrue_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ChooseExpr18setIsConditionTrueEb")]
                internal static extern void setIsConditionTrue_0(global::System.IntPtr instance, bool isTrue);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ChooseExpr20isConditionDependentEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isConditionDependent_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ChooseExpr16getChosenSubExprEv")]
                internal static extern global::System.IntPtr getChosenSubExpr_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ChooseExpr7getCondEv")]
                internal static extern global::System.IntPtr getCond_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ChooseExpr7setCondEPNS_4ExprE")]
                internal static extern void setCond_0(global::System.IntPtr instance, global::System.IntPtr E);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ChooseExpr6getLHSEv")]
                internal static extern global::System.IntPtr getLHS_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ChooseExpr6setLHSEPNS_4ExprE")]
                internal static extern void setLHS_0(global::System.IntPtr instance, global::System.IntPtr E);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ChooseExpr6getRHSEv")]
                internal static extern global::System.IntPtr getRHS_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ChooseExpr6setRHSEPNS_4ExprE")]
                internal static extern void setRHS_0(global::System.IntPtr instance, global::System.IntPtr E);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ChooseExpr13getBuiltinLocEv")]
                internal static extern clang.SourceLocation.Internal getBuiltinLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ChooseExpr13setBuiltinLocENS_14SourceLocationE")]
                internal static extern void setBuiltinLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal L);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ChooseExpr12getRParenLocEv")]
                internal static extern clang.SourceLocation.Internal getRParenLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ChooseExpr12setRParenLocENS_14SourceLocationE")]
                internal static extern void setRParenLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal L);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ChooseExpr11getLocStartEv")]
                internal static extern clang.SourceLocation.Internal getLocStart_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ChooseExpr9getLocEndEv")]
                internal static extern clang.SourceLocation.Internal getLocEnd_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ChooseExpr7classofEPKNS_4StmtE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ChooseExpr8childrenEv")]
                internal static extern void children_0(global::System.IntPtr @return, global::System.IntPtr instance);
            }

            private readonly bool __ownsNativeInstance;

            public static new ChooseExpr __CreateInstance(global::System.IntPtr native)
            {
                return new ChooseExpr((ChooseExpr.Internal*) native);
            }

            public static ChooseExpr __CreateInstance(ChooseExpr.Internal native)
            {
                return new ChooseExpr(native);
            }

            private static ChooseExpr.Internal* __CopyValue(ChooseExpr.Internal native)
            {
                var ret = (ChooseExpr.Internal*) Marshal.AllocHGlobal(56);
                *ret = native;
                return ret;
            }

            private ChooseExpr(ChooseExpr.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected ChooseExpr(ChooseExpr.Internal* native, bool isInternalImpl = false)
                : base((clang.Expr.Internal*) native)
            {
            }

            public ChooseExpr(clang.SourceLocation BLoc, clang.Expr cond, clang.Expr lhs, clang.Expr rhs, clang.QualType t, clang.ExprValueKind VK, clang.ExprObjectKind OK, clang.SourceLocation RP, bool condIsTrue, bool TypeDependent, bool ValueDependent)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(56);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(BLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (BLoc.__Instance);
                var arg1 = ReferenceEquals(cond, null) ? global::System.IntPtr.Zero : cond.__Instance;
                var arg2 = ReferenceEquals(lhs, null) ? global::System.IntPtr.Zero : lhs.__Instance;
                var arg3 = ReferenceEquals(rhs, null) ? global::System.IntPtr.Zero : rhs.__Instance;
                var arg4 = ReferenceEquals(t, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (t.__Instance);
                var arg5 = VK;
                var arg6 = OK;
                var arg7 = ReferenceEquals(RP, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (RP.__Instance);
                Internal.ctor_0(__Instance, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, condIsTrue, TypeDependent, ValueDependent);
            }

            /// <summary>
            /// <para>Build an empty __builtin_choose_expr.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Build an empty __builtin_choose_expr.</para>
            /// </remarks>
            public ChooseExpr(clang.Stmt.EmptyShell Empty)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(56);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(Empty, null) ? new clang.Stmt.EmptyShell.Internal() : *(clang.Stmt.EmptyShell.Internal*) (Empty.__Instance);
                Internal.ctor_1(__Instance, arg0);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Stmt __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            /// <summary>
            /// <para>isConditionTrue - Return whether the condition is true (i.e. not
            /// equal to zero).</para>
            /// </summary>
            /// <remarks>
            /// <para>/// isConditionTrue - Return whether the condition is true (i.e.
            /// not</para>
            /// <para>  /// equal to zero).</para>
            /// </remarks>
            public bool isConditionTrue()
            {
                var __ret = Internal.isConditionTrue_0(__Instance);
                return __ret;
            }

            public void setIsConditionTrue(bool isTrue)
            {
                Internal.setIsConditionTrue_0(__Instance, isTrue);
            }

            public bool isConditionDependent()
            {
                var __ret = Internal.isConditionDependent_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>getChosenSubExpr - Return the subexpression chosen according to
            /// the condition.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getChosenSubExpr - Return the subexpression chosen according
            /// to the</para>
            /// <para>  /// condition.</para>
            /// </remarks>
            public clang.Expr getChosenSubExpr()
            {
                var __ret = Internal.getChosenSubExpr_0(__Instance);
                clang.Expr __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Expr.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Expr) clang.Expr.NativeToManagedMap[__ret];
                else __result0 = clang.Expr.__CreateInstance(__ret);
                return __result0;
            }

            public clang.Expr getCond()
            {
                var __ret = Internal.getCond_0(__Instance);
                clang.Expr __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Expr.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Expr) clang.Expr.NativeToManagedMap[__ret];
                else __result0 = clang.Expr.__CreateInstance(__ret);
                return __result0;
            }

            public void setCond(clang.Expr E)
            {
                var arg0 = ReferenceEquals(E, null) ? global::System.IntPtr.Zero : E.__Instance;
                Internal.setCond_0(__Instance, arg0);
            }

            public clang.Expr getLHS()
            {
                var __ret = Internal.getLHS_0(__Instance);
                clang.Expr __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Expr.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Expr) clang.Expr.NativeToManagedMap[__ret];
                else __result0 = clang.Expr.__CreateInstance(__ret);
                return __result0;
            }

            public void setLHS(clang.Expr E)
            {
                var arg0 = ReferenceEquals(E, null) ? global::System.IntPtr.Zero : E.__Instance;
                Internal.setLHS_0(__Instance, arg0);
            }

            public clang.Expr getRHS()
            {
                var __ret = Internal.getRHS_0(__Instance);
                clang.Expr __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Expr.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Expr) clang.Expr.NativeToManagedMap[__ret];
                else __result0 = clang.Expr.__CreateInstance(__ret);
                return __result0;
            }

            public void setRHS(clang.Expr E)
            {
                var arg0 = ReferenceEquals(E, null) ? global::System.IntPtr.Zero : E.__Instance;
                Internal.setRHS_0(__Instance, arg0);
            }

            public clang.SourceLocation getBuiltinLoc()
            {
                var __ret = Internal.getBuiltinLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setBuiltinLoc(clang.SourceLocation L)
            {
                var arg0 = ReferenceEquals(L, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (L.__Instance);
                Internal.setBuiltinLoc_0(__Instance, arg0);
            }

            public clang.SourceLocation getRParenLoc()
            {
                var __ret = Internal.getRParenLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setRParenLoc(clang.SourceLocation L)
            {
                var arg0 = ReferenceEquals(L, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (L.__Instance);
                Internal.setRParenLoc_0(__Instance, arg0);
            }

            public clang.SourceLocation getLocStart()
            {
                var __ret = Internal.getLocStart_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLocEnd()
            {
                var __ret = Internal.getLocEnd_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.StmtRange children()
            {
                var __ret = new clang.StmtRange.Internal();
                Internal.children_0(new IntPtr(&__ret), __Instance);
                return clang.StmtRange.__CreateInstance(__ret);
            }

            public static bool classof(clang.Stmt T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>GNUNullExpr - Implements the GNU __null extension, which is a
        /// name for a null pointer constant that has integral type (e.g., int or long)
        /// and is the same size and alignment as a pointer. The __null extension is
        /// typically only used by system headers, which define NULL as __null in C++
        /// rather than using 0 (which is an integer that may not match the size of a
        /// pointer).</para>
        /// </summary>
        /// <remarks>
        /// <para>/// GNUNullExpr - Implements the GNU __null extension, which is a
        /// name</para>
        /// <para>/// for a null pointer constant that has integral type (e.g., int
        /// or</para>
        /// <para>/// long) and is the same size and alignment as a pointer. The
        /// __null</para>
        /// <para>/// extension is typically only used by system headers, which
        /// define</para>
        /// <para>/// NULL as __null in C++ rather than using 0 (which is an
        /// integer</para>
        /// <para>/// that may not match the size of a pointer).</para>
        /// </remarks>
        public unsafe partial class GNUNullExpr : clang.Expr, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 24)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                internal clang.Stmt._.Internal __;

                [FieldOffset(8)]
                public clang.QualType.Internal TR;

                [FieldOffset(16)]
                public clang.SourceLocation.Internal TokenLoc;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11GNUNullExprC2ENS_8QualTypeENS_14SourceLocationE")]
                internal static extern void ctor_0(global::System.IntPtr instance, clang.QualType.Internal Ty, clang.SourceLocation.Internal Loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11GNUNullExprC2ENS_4Stmt10EmptyShellE")]
                internal static extern void ctor_1(global::System.IntPtr instance, clang.Stmt.EmptyShell.Internal Empty);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11GNUNullExprC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11GNUNullExpr16getTokenLocationEv")]
                internal static extern clang.SourceLocation.Internal getTokenLocation_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11GNUNullExpr16setTokenLocationENS_14SourceLocationE")]
                internal static extern void setTokenLocation_0(global::System.IntPtr instance, clang.SourceLocation.Internal L);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11GNUNullExpr11getLocStartEv")]
                internal static extern clang.SourceLocation.Internal getLocStart_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11GNUNullExpr9getLocEndEv")]
                internal static extern clang.SourceLocation.Internal getLocEnd_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11GNUNullExpr7classofEPKNS_4StmtE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11GNUNullExpr8childrenEv")]
                internal static extern void children_0(global::System.IntPtr @return, global::System.IntPtr instance);
            }

            private readonly bool __ownsNativeInstance;

            public static new GNUNullExpr __CreateInstance(global::System.IntPtr native)
            {
                return new GNUNullExpr((GNUNullExpr.Internal*) native);
            }

            public static GNUNullExpr __CreateInstance(GNUNullExpr.Internal native)
            {
                return new GNUNullExpr(native);
            }

            private static GNUNullExpr.Internal* __CopyValue(GNUNullExpr.Internal native)
            {
                var ret = (GNUNullExpr.Internal*) Marshal.AllocHGlobal(24);
                *ret = native;
                return ret;
            }

            private GNUNullExpr(GNUNullExpr.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected GNUNullExpr(GNUNullExpr.Internal* native, bool isInternalImpl = false)
                : base((clang.Expr.Internal*) native)
            {
            }

            public GNUNullExpr(clang.QualType Ty, clang.SourceLocation Loc)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(24);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(Ty, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (Ty.__Instance);
                var arg1 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                Internal.ctor_0(__Instance, arg0, arg1);
            }

            /// <summary>
            /// <para>Build an empty GNU __null expression.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Build an empty GNU __null expression.</para>
            /// </remarks>
            public GNUNullExpr(clang.Stmt.EmptyShell Empty)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(24);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(Empty, null) ? new clang.Stmt.EmptyShell.Internal() : *(clang.Stmt.EmptyShell.Internal*) (Empty.__Instance);
                Internal.ctor_1(__Instance, arg0);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Stmt __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            /// <summary>
            /// <para>getTokenLocation - The location of the __null token.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getTokenLocation - The location of the __null token.</para>
            /// </remarks>
            public clang.SourceLocation getTokenLocation()
            {
                var __ret = Internal.getTokenLocation_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setTokenLocation(clang.SourceLocation L)
            {
                var arg0 = ReferenceEquals(L, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (L.__Instance);
                Internal.setTokenLocation_0(__Instance, arg0);
            }

            public clang.SourceLocation getLocStart()
            {
                var __ret = Internal.getLocStart_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLocEnd()
            {
                var __ret = Internal.getLocEnd_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.StmtRange children()
            {
                var __ret = new clang.StmtRange.Internal();
                Internal.children_0(new IntPtr(&__ret), __Instance);
                return clang.StmtRange.__CreateInstance(__ret);
            }

            public static bool classof(clang.Stmt T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>VAArgExpr, used for the builtin function __builtin_va_arg.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// VAArgExpr, used for the builtin function
        /// __builtin_va_arg.</para>
        /// </remarks>
        public unsafe partial class VAArgExpr : clang.Expr, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 40)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                internal clang.Stmt._.Internal __;

                [FieldOffset(8)]
                public clang.QualType.Internal TR;

                [FieldOffset(16)]
                public global::System.IntPtr Val;

                [FieldOffset(24)]
                public global::System.IntPtr TInfo;

                [FieldOffset(32)]
                public clang.SourceLocation.Internal BuiltinLoc;

                [FieldOffset(36)]
                public clang.SourceLocation.Internal RParenLoc;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9VAArgExprC2ENS_14SourceLocationEPNS_4ExprEPNS_14TypeSourceInfoES1_NS_8QualTypeE")]
                internal static extern void ctor_0(global::System.IntPtr instance, clang.SourceLocation.Internal BLoc, global::System.IntPtr e, global::System.IntPtr TInfo, clang.SourceLocation.Internal RPLoc, clang.QualType.Internal t);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9VAArgExprC2ENS_4Stmt10EmptyShellE")]
                internal static extern void ctor_1(global::System.IntPtr instance, clang.Stmt.EmptyShell.Internal Empty);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9VAArgExprC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9VAArgExpr10getSubExprEv")]
                internal static extern global::System.IntPtr getSubExpr_1(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9VAArgExpr10setSubExprEPNS_4ExprE")]
                internal static extern void setSubExpr_0(global::System.IntPtr instance, global::System.IntPtr E);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9VAArgExpr18getWrittenTypeInfoEv")]
                internal static extern global::System.IntPtr getWrittenTypeInfo_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9VAArgExpr18setWrittenTypeInfoEPNS_14TypeSourceInfoE")]
                internal static extern void setWrittenTypeInfo_0(global::System.IntPtr instance, global::System.IntPtr TI);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9VAArgExpr13getBuiltinLocEv")]
                internal static extern clang.SourceLocation.Internal getBuiltinLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9VAArgExpr13setBuiltinLocENS_14SourceLocationE")]
                internal static extern void setBuiltinLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal L);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9VAArgExpr12getRParenLocEv")]
                internal static extern clang.SourceLocation.Internal getRParenLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9VAArgExpr12setRParenLocENS_14SourceLocationE")]
                internal static extern void setRParenLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal L);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9VAArgExpr11getLocStartEv")]
                internal static extern clang.SourceLocation.Internal getLocStart_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9VAArgExpr9getLocEndEv")]
                internal static extern clang.SourceLocation.Internal getLocEnd_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9VAArgExpr7classofEPKNS_4StmtE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9VAArgExpr8childrenEv")]
                internal static extern void children_0(global::System.IntPtr @return, global::System.IntPtr instance);
            }

            private readonly bool __ownsNativeInstance;

            public static new VAArgExpr __CreateInstance(global::System.IntPtr native)
            {
                return new VAArgExpr((VAArgExpr.Internal*) native);
            }

            public static VAArgExpr __CreateInstance(VAArgExpr.Internal native)
            {
                return new VAArgExpr(native);
            }

            private static VAArgExpr.Internal* __CopyValue(VAArgExpr.Internal native)
            {
                var ret = (VAArgExpr.Internal*) Marshal.AllocHGlobal(40);
                *ret = native;
                return ret;
            }

            private VAArgExpr(VAArgExpr.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected VAArgExpr(VAArgExpr.Internal* native, bool isInternalImpl = false)
                : base((clang.Expr.Internal*) native)
            {
            }

            public VAArgExpr(clang.SourceLocation BLoc, clang.Expr e, clang.TypeSourceInfo TInfo, clang.SourceLocation RPLoc, clang.QualType t)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(40);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(BLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (BLoc.__Instance);
                var arg1 = ReferenceEquals(e, null) ? global::System.IntPtr.Zero : e.__Instance;
                var arg2 = ReferenceEquals(TInfo, null) ? global::System.IntPtr.Zero : TInfo.__Instance;
                var arg3 = ReferenceEquals(RPLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (RPLoc.__Instance);
                var arg4 = ReferenceEquals(t, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (t.__Instance);
                Internal.ctor_0(__Instance, arg0, arg1, arg2, arg3, arg4);
            }

            /// <summary>
            /// <para>Create an empty __builtin_va_arg expression.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Create an empty __builtin_va_arg expression.</para>
            /// </remarks>
            public VAArgExpr(clang.Stmt.EmptyShell Empty)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(40);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(Empty, null) ? new clang.Stmt.EmptyShell.Internal() : *(clang.Stmt.EmptyShell.Internal*) (Empty.__Instance);
                Internal.ctor_1(__Instance, arg0);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Stmt __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.Expr getSubExpr()
            {
                var __ret = Internal.getSubExpr_1(__Instance);
                clang.Expr __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Expr.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Expr) clang.Expr.NativeToManagedMap[__ret];
                else __result0 = clang.Expr.__CreateInstance(__ret);
                return __result0;
            }

            public void setSubExpr(clang.Expr E)
            {
                var arg0 = ReferenceEquals(E, null) ? global::System.IntPtr.Zero : E.__Instance;
                Internal.setSubExpr_0(__Instance, arg0);
            }

            public clang.TypeSourceInfo getWrittenTypeInfo()
            {
                var __ret = Internal.getWrittenTypeInfo_0(__Instance);
                clang.TypeSourceInfo __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.TypeSourceInfo.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.TypeSourceInfo) clang.TypeSourceInfo.NativeToManagedMap[__ret];
                else __result0 = clang.TypeSourceInfo.__CreateInstance(__ret);
                return __result0;
            }

            public void setWrittenTypeInfo(clang.TypeSourceInfo TI)
            {
                var arg0 = ReferenceEquals(TI, null) ? global::System.IntPtr.Zero : TI.__Instance;
                Internal.setWrittenTypeInfo_0(__Instance, arg0);
            }

            public clang.SourceLocation getBuiltinLoc()
            {
                var __ret = Internal.getBuiltinLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setBuiltinLoc(clang.SourceLocation L)
            {
                var arg0 = ReferenceEquals(L, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (L.__Instance);
                Internal.setBuiltinLoc_0(__Instance, arg0);
            }

            public clang.SourceLocation getRParenLoc()
            {
                var __ret = Internal.getRParenLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setRParenLoc(clang.SourceLocation L)
            {
                var arg0 = ReferenceEquals(L, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (L.__Instance);
                Internal.setRParenLoc_0(__Instance, arg0);
            }

            public clang.SourceLocation getLocStart()
            {
                var __ret = Internal.getLocStart_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLocEnd()
            {
                var __ret = Internal.getLocEnd_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.StmtRange children()
            {
                var __ret = new clang.StmtRange.Internal();
                Internal.children_0(new IntPtr(&__ret), __Instance);
                return clang.StmtRange.__CreateInstance(__ret);
            }

            public static bool classof(clang.Stmt T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Describes an C or C++ initializer list.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// @brief Describes an C or C++ initializer list.</para>
        /// <para>///</para>
        /// <para>/// InitListExpr describes an initializer list, which can be used
        /// to</para>
        /// <para>/// initialize objects of different types, including</para>
        /// <para>/// struct/class/union types, arrays, and vectors. For
        /// example:</para>
        /// <para>///</para>
        /// <para>/// @code</para>
        /// <para>/// struct foo x = { 1, { 2, 3 } };</para>
        /// <para>/// @endcode</para>
        /// <para>///</para>
        /// <para>/// Prior to semantic analysis, an initializer list will
        /// represent the</para>
        /// <para>/// initializer list as written by the user, but will have
        /// the</para>
        /// <para>/// placeholder type &quot;void&quot;. This initializer list is
        /// called the</para>
        /// <para>/// syntactic form of the initializer, and may contain C99
        /// designated</para>
        /// <para>/// initializers (represented as DesignatedInitExprs),
        /// initializations</para>
        /// <para>/// of subobject members without explicit braces, and so on.
        /// Clients</para>
        /// <para>/// interested in the original syntax of the initializer list
        /// should</para>
        /// <para>/// use the syntactic form of the initializer list.</para>
        /// <para>///</para>
        /// <para>/// After semantic analysis, the initializer list will represent
        /// the</para>
        /// <para>/// semantic form of the initializer, where the initializations
        /// of all</para>
        /// <para>/// subobjects are made explicit with nested InitListExpr nodes
        /// and</para>
        /// <para>/// C99 designators have been eliminated by placing the
        /// designated</para>
        /// <para>/// initializations into the subobject they initialize.
        /// Additionally,</para>
        /// <para>/// any &quot;holes&quot; in the initialization, where no
        /// initializer has been</para>
        /// <para>/// specified for a particular subobject, will be replaced
        /// with</para>
        /// <para>/// implicitly-generated ImplicitValueInitExpr expressions
        /// that</para>
        /// <para>/// value-initialize the subobjects. Note, however, that
        /// the</para>
        /// <para>/// initializer lists may still have fewer initializers than
        /// there are</para>
        /// <para>/// elements to initialize within the object.</para>
        /// <para>///</para>
        /// <para>/// After semantic analysis has completed, given an initializer
        /// list,</para>
        /// <para>/// method isSemanticForm() returns true if and only if this is
        /// the</para>
        /// <para>/// semantic form of the initializer list (note: the same AST
        /// node</para>
        /// <para>/// may at the same time be the syntactic form).</para>
        /// <para>/// Given the semantic form of the initializer list, one can
        /// retrieve</para>
        /// <para>/// the syntactic form of that initializer list (when
        /// different)</para>
        /// <para>/// using method getSyntacticForm(); the method returns null if
        /// applied</para>
        /// <para>/// to a initializer list which is already in syntactic
        /// form.</para>
        /// <para>/// Similarly, given the syntactic form (i.e., an initializer
        /// list such</para>
        /// <para>/// that isSemanticForm() returns false), one can retrieve the
        /// semantic</para>
        /// <para>/// form using method getSemanticForm().</para>
        /// <para>/// Since many initializer lists have the same syntactic and
        /// semantic forms,</para>
        /// <para>/// getSyntacticForm() may return NULL, indicating that the
        /// current</para>
        /// <para>/// semantic initializer list also serves as its syntactic
        /// form.</para>
        /// </remarks>
        public unsafe partial class InitListExpr : clang.Expr, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 64)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                internal clang.Stmt._.Internal __;

                [FieldOffset(8)]
                public clang.QualType.Internal TR;

                [FieldOffset(16)]
                internal clang.ASTVector.Internal InitExprs;

                [FieldOffset(40)]
                public clang.SourceLocation.Internal LBraceLoc;

                [FieldOffset(44)]
                public clang.SourceLocation.Internal RBraceLoc;

                [FieldOffset(48)]
                internal llvm.PointerIntPair.Internal AltForm;

                [FieldOffset(56)]
                internal llvm.PointerUnion.Internal ArrayFillerOrUnionFieldInit;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12InitListExprC2ENS_4Stmt10EmptyShellE")]
                internal static extern void ctor_1(global::System.IntPtr instance, clang.Stmt.EmptyShell.Internal Empty);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12InitListExprC2ERKS0_")]
                internal static extern void cctor_3(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12InitListExprD2Ev")]
                internal static extern void dtor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12InitListExpr11getNumInitsEv")]
                internal static extern uint getNumInits_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12InitListExpr8getInitsEv")]
                internal static extern global::System.IntPtr getInits_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12InitListExpr7getInitEj")]
                internal static extern global::System.IntPtr getInit_1(global::System.IntPtr instance, uint Init);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12InitListExpr7setInitEjPNS_4ExprE")]
                internal static extern void setInit_0(global::System.IntPtr instance, uint Init, global::System.IntPtr expr);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12InitListExpr14getArrayFillerEv")]
                internal static extern global::System.IntPtr getArrayFiller_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12InitListExpr14setArrayFillerEPNS_4ExprE")]
                internal static extern void setArrayFiller_0(global::System.IntPtr instance, global::System.IntPtr filler);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12InitListExpr14hasArrayFillerEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasArrayFiller_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12InitListExpr26getInitializedFieldInUnionEv")]
                internal static extern global::System.IntPtr getInitializedFieldInUnion_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12InitListExpr26setInitializedFieldInUnionEPNS_9FieldDeclE")]
                internal static extern void setInitializedFieldInUnion_0(global::System.IntPtr instance, global::System.IntPtr FD);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12InitListExpr10isExplicitEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isExplicit_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12InitListExpr19isStringLiteralInitEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isStringLiteralInit_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12InitListExpr12getLBraceLocEv")]
                internal static extern clang.SourceLocation.Internal getLBraceLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12InitListExpr12setLBraceLocENS_14SourceLocationE")]
                internal static extern void setLBraceLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal Loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12InitListExpr12getRBraceLocEv")]
                internal static extern clang.SourceLocation.Internal getRBraceLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12InitListExpr12setRBraceLocENS_14SourceLocationE")]
                internal static extern void setRBraceLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal Loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12InitListExpr14isSemanticFormEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isSemanticForm_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12InitListExpr15getSemanticFormEv")]
                internal static extern global::System.IntPtr getSemanticForm_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12InitListExpr16getSyntacticFormEv")]
                internal static extern global::System.IntPtr getSyntacticForm_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12InitListExpr16setSyntacticFormEPS0_")]
                internal static extern void setSyntacticForm_0(global::System.IntPtr instance, global::System.IntPtr Init);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12InitListExpr23hadArrayRangeDesignatorEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hadArrayRangeDesignator_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12InitListExpr23sawArrayRangeDesignatorEb")]
                internal static extern void sawArrayRangeDesignator_0(global::System.IntPtr instance, bool ARD);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12InitListExpr11getLocStartEv")]
                internal static extern clang.SourceLocation.Internal getLocStart_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12InitListExpr9getLocEndEv")]
                internal static extern clang.SourceLocation.Internal getLocEnd_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12InitListExpr7classofEPKNS_4StmtE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12InitListExpr8childrenEv")]
                internal static extern void children_0(global::System.IntPtr @return, global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12InitListExpr5beginEv")]
                internal static extern global::System.IntPtr begin_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12InitListExpr3endEv")]
                internal static extern global::System.IntPtr end_0(global::System.IntPtr instance);
            }

            private readonly bool __ownsNativeInstance;

            public static new InitListExpr __CreateInstance(global::System.IntPtr native)
            {
                return new InitListExpr((InitListExpr.Internal*) native);
            }

            public static InitListExpr __CreateInstance(InitListExpr.Internal native)
            {
                return new InitListExpr(native);
            }

            private static InitListExpr.Internal* __CopyValue(InitListExpr.Internal native)
            {
                var ret = (InitListExpr.Internal*) Marshal.AllocHGlobal(64);
                *ret = native;
                return ret;
            }

            private InitListExpr(InitListExpr.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected InitListExpr(InitListExpr.Internal* native, bool isInternalImpl = false)
                : base((clang.Expr.Internal*) native)
            {
            }

            /// <summary>
            /// <para>Build an empty initializer list.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Build an empty initializer list.</para>
            /// </remarks>
            public InitListExpr(clang.Stmt.EmptyShell Empty)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(64);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(Empty, null) ? new clang.Stmt.EmptyShell.Internal() : *(clang.Stmt.EmptyShell.Internal*) (Empty.__Instance);
                Internal.ctor_1(__Instance, arg0);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Stmt __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public uint getNumInits()
            {
                var __ret = Internal.getNumInits_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Retrieve the set of initializers.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the set of initializers.</para>
            /// </remarks>
            public clang.Expr getInits()
            {
                var __ret = Internal.getInits_0(__Instance);
                clang.Expr __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Expr.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Expr) clang.Expr.NativeToManagedMap[__ret];
                else __result0 = clang.Expr.__CreateInstance(__ret);
                return __result0;
            }

            public clang.Expr getInit(uint Init)
            {
                var __ret = Internal.getInit_1(__Instance, Init);
                clang.Expr __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Expr.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Expr) clang.Expr.NativeToManagedMap[__ret];
                else __result0 = clang.Expr.__CreateInstance(__ret);
                return __result0;
            }

            public void setInit(uint Init, clang.Expr expr)
            {
                var arg1 = ReferenceEquals(expr, null) ? global::System.IntPtr.Zero : expr.__Instance;
                Internal.setInit_0(__Instance, Init, arg1);
            }

            /// <summary>
            /// <para>If this initializer list initializes an array with more elements
            /// than there are initializers in the list, specifies an expression to be used
            /// for value initialization of the rest of the elements.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief If this initializer list initializes an array with
            /// more elements</para>
            /// <para>  /// than there are initializers in the list, specifies an
            /// expression to be</para>
            /// <para>  /// used for value initialization of the rest of the
            /// elements.</para>
            /// </remarks>
            public clang.Expr getArrayFiller()
            {
                var __ret = Internal.getArrayFiller_0(__Instance);
                clang.Expr __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Expr.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Expr) clang.Expr.NativeToManagedMap[__ret];
                else __result0 = clang.Expr.__CreateInstance(__ret);
                return __result0;
            }

            public void setArrayFiller(clang.Expr filler)
            {
                var arg0 = ReferenceEquals(filler, null) ? global::System.IntPtr.Zero : filler.__Instance;
                Internal.setArrayFiller_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>Return true if this is an array initializer and its array
            /// &quot;filler&quot; has been set.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return true if this is an array initializer and its
            /// array &quot;filler&quot;</para>
            /// <para>  /// has been set.</para>
            /// </remarks>
            public bool hasArrayFiller()
            {
                var __ret = Internal.hasArrayFiller_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>If this initializes a union, specifies which field in the union
            /// to initialize.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief If this initializes a union, specifies which field in
            /// the</para>
            /// <para>  /// union to initialize.</para>
            /// <para>  ///</para>
            /// <para>  /// Typically, this field is the first named field within
            /// the</para>
            /// <para>  /// union. However, a designated initializer can specify
            /// the</para>
            /// <para>  /// initialization of a different field within the
            /// union.</para>
            /// </remarks>
            public clang.FieldDecl getInitializedFieldInUnion()
            {
                var __ret = Internal.getInitializedFieldInUnion_0(__Instance);
                clang.FieldDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.FieldDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.FieldDecl) clang.FieldDecl.NativeToManagedMap[__ret];
                else clang.FieldDecl.NativeToManagedMap[__ret] = __result0 = (clang.FieldDecl) clang.FieldDecl.__CreateInstance(__ret);
                return __result0;
            }

            public void setInitializedFieldInUnion(clang.FieldDecl FD)
            {
                var arg0 = ReferenceEquals(FD, null) ? global::System.IntPtr.Zero : FD.__Instance;
                Internal.setInitializedFieldInUnion_0(__Instance, arg0);
            }

            public bool isExplicit()
            {
                var __ret = Internal.isExplicit_0(__Instance);
                return __ret;
            }

            public bool isStringLiteralInit()
            {
                var __ret = Internal.isStringLiteralInit_0(__Instance);
                return __ret;
            }

            public clang.SourceLocation getLBraceLoc()
            {
                var __ret = Internal.getLBraceLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setLBraceLoc(clang.SourceLocation Loc)
            {
                var arg0 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                Internal.setLBraceLoc_0(__Instance, arg0);
            }

            public clang.SourceLocation getRBraceLoc()
            {
                var __ret = Internal.getRBraceLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setRBraceLoc(clang.SourceLocation Loc)
            {
                var arg0 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                Internal.setRBraceLoc_0(__Instance, arg0);
            }

            public bool isSemanticForm()
            {
                var __ret = Internal.isSemanticForm_0(__Instance);
                return __ret;
            }

            public clang.InitListExpr getSemanticForm()
            {
                var __ret = Internal.getSemanticForm_0(__Instance);
                clang.InitListExpr __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.InitListExpr.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.InitListExpr) clang.InitListExpr.NativeToManagedMap[__ret];
                else __result0 = clang.InitListExpr.__CreateInstance(__ret);
                return __result0;
            }

            public clang.InitListExpr getSyntacticForm()
            {
                var __ret = Internal.getSyntacticForm_0(__Instance);
                clang.InitListExpr __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.InitListExpr.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.InitListExpr) clang.InitListExpr.NativeToManagedMap[__ret];
                else __result0 = clang.InitListExpr.__CreateInstance(__ret);
                return __result0;
            }

            public void setSyntacticForm(clang.InitListExpr Init)
            {
                var arg0 = ReferenceEquals(Init, null) ? global::System.IntPtr.Zero : Init.__Instance;
                Internal.setSyntacticForm_0(__Instance, arg0);
            }

            public bool hadArrayRangeDesignator()
            {
                var __ret = Internal.hadArrayRangeDesignator_0(__Instance);
                return __ret;
            }

            public void sawArrayRangeDesignator(bool ARD)
            {
                Internal.sawArrayRangeDesignator_0(__Instance, ARD);
            }

            public clang.SourceLocation getLocStart()
            {
                var __ret = Internal.getLocStart_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLocEnd()
            {
                var __ret = Internal.getLocEnd_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.StmtRange children()
            {
                var __ret = new clang.StmtRange.Internal();
                Internal.children_0(new IntPtr(&__ret), __Instance);
                return clang.StmtRange.__CreateInstance(__ret);
            }

            public clang.Stmt begin()
            {
                var __ret = Internal.begin_0(__Instance);
                clang.Stmt __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Stmt.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Stmt) clang.Stmt.NativeToManagedMap[__ret];
                else __result0 = clang.Stmt.__CreateInstance(__ret);
                return __result0;
            }

            public clang.Stmt end()
            {
                var __ret = Internal.end_0(__Instance);
                clang.Stmt __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Stmt.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Stmt) clang.Stmt.NativeToManagedMap[__ret];
                else __result0 = clang.Stmt.__CreateInstance(__ret);
                return __result0;
            }

            public static bool classof(clang.Stmt T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Represents a C99 designated initializer expression.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// @brief Represents a C99 designated initializer
        /// expression.</para>
        /// <para>///</para>
        /// <para>/// A designated initializer expression (C99 6.7.8) contains one
        /// or</para>
        /// <para>/// more designators (which can be field designators,
        /// array</para>
        /// <para>/// designators, or GNU array-range designators) followed by
        /// an</para>
        /// <para>/// expression that initializes the field or element(s) that
        /// the</para>
        /// <para>/// designators refer to. For example, given:</para>
        /// <para>///</para>
        /// <para>/// @code</para>
        /// <para>/// struct point {</para>
        /// <para>///   double x;</para>
        /// <para>///   double y;</para>
        /// <para>/// };</para>
        /// <para>/// struct point ptarray[10] = { [2].y = 1.0, [2].x = 2.0, [0].x
        /// = 1.0 };</para>
        /// <para>/// @endcode</para>
        /// <para>///</para>
        /// <para>/// The InitListExpr contains three DesignatedInitExprs, the
        /// first of</para>
        /// <para>/// which covers @c [2].y=1.0. This DesignatedInitExpr will have
        /// two</para>
        /// <para>/// designators, one array designator for @c [2] followed by one
        /// field</para>
        /// <para>/// designator for @c .y. The initialization expression will be
        /// 1.0.</para>
        /// </remarks>
        public unsafe partial class DesignatedInitExpr : clang.Expr, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 32)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                internal clang.Stmt._.Internal __;

                [FieldOffset(8)]
                public clang.QualType.Internal TR;

                [FieldOffset(16)]
                public clang.SourceLocation.Internal EqualOrColonLoc;

                [FieldOffset(20)]
                public bool GNUSyntax;

                [FieldOffset(20)]
                public uint NumDesignators;

                [FieldOffset(22)]
                public uint NumSubExprs;

                [FieldOffset(24)]
                public global::System.IntPtr Designators;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang18DesignatedInitExprC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang18DesignatedInitExpr4sizeEv")]
                internal static extern uint size_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang18DesignatedInitExpr17designators_beginEv")]
                internal static extern global::System.IntPtr designators_begin_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang18DesignatedInitExpr15designators_endEv")]
                internal static extern global::System.IntPtr designators_end_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang18DesignatedInitExpr13getDesignatorEj")]
                internal static extern global::System.IntPtr getDesignator_0(global::System.IntPtr instance, uint Idx);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang18DesignatedInitExpr13getArrayIndexERKNS0_10DesignatorE")]
                internal static extern global::System.IntPtr getArrayIndex_0(global::System.IntPtr instance, global::System.IntPtr D);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang18DesignatedInitExpr18getArrayRangeStartERKNS0_10DesignatorE")]
                internal static extern global::System.IntPtr getArrayRangeStart_0(global::System.IntPtr instance, global::System.IntPtr D);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang18DesignatedInitExpr16getArrayRangeEndERKNS0_10DesignatorE")]
                internal static extern global::System.IntPtr getArrayRangeEnd_0(global::System.IntPtr instance, global::System.IntPtr D);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang18DesignatedInitExpr18getEqualOrColonLocEv")]
                internal static extern clang.SourceLocation.Internal getEqualOrColonLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang18DesignatedInitExpr18setEqualOrColonLocENS_14SourceLocationE")]
                internal static extern void setEqualOrColonLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal L);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang18DesignatedInitExpr13usesGNUSyntaxEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool usesGNUSyntax_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang18DesignatedInitExpr12setGNUSyntaxEb")]
                internal static extern void setGNUSyntax_0(global::System.IntPtr instance, bool GNU);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang18DesignatedInitExpr7getInitEv")]
                internal static extern global::System.IntPtr getInit_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang18DesignatedInitExpr7setInitEPNS_4ExprE")]
                internal static extern void setInit_0(global::System.IntPtr instance, global::System.IntPtr init);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang18DesignatedInitExpr14getNumSubExprsEv")]
                internal static extern uint getNumSubExprs_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang18DesignatedInitExpr10getSubExprEj")]
                internal static extern global::System.IntPtr getSubExpr_0(global::System.IntPtr instance, uint Idx);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang18DesignatedInitExpr10setSubExprEjPNS_4ExprE")]
                internal static extern void setSubExpr_0(global::System.IntPtr instance, uint Idx, global::System.IntPtr E);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang18DesignatedInitExpr25getDesignatorsSourceRangeEv")]
                internal static extern clang.SourceRange.Internal getDesignatorsSourceRange_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang18DesignatedInitExpr11getLocStartEv")]
                internal static extern clang.SourceLocation.Internal getLocStart_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang18DesignatedInitExpr9getLocEndEv")]
                internal static extern clang.SourceLocation.Internal getLocEnd_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang18DesignatedInitExpr7classofEPKNS_4StmtE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang18DesignatedInitExpr8childrenEv")]
                internal static extern void children_0(global::System.IntPtr @return, global::System.IntPtr instance);
            }

            public class designators_iterator { }

            public class const_designators_iterator { }

            /// <summary>
            /// <para>Forward declaration of the Designator class.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Forward declaration of the Designator class.</para>
            /// </remarks>
            public unsafe partial class Designator : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 24)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public clang.DesignatedInitExpr.Designator._0 Kind;

                    [FieldOffset(8)]
                    internal clang.DesignatedInitExpr.Designator._.Internal _1;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang18DesignatedInitExpr10DesignatorC2Ev")]
                    internal static extern void ctor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang18DesignatedInitExpr10DesignatorC2EPKNS_14IdentifierInfoENS_14SourceLocationES5_")]
                    internal static extern void ctor_1(global::System.IntPtr instance, global::System.IntPtr FieldName, clang.SourceLocation.Internal DotLoc, clang.SourceLocation.Internal FieldLoc);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang18DesignatedInitExpr10DesignatorC2EjNS_14SourceLocationES2_")]
                    internal static extern void ctor_2(global::System.IntPtr instance, uint Index, clang.SourceLocation.Internal LBracketLoc, clang.SourceLocation.Internal RBracketLoc);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang18DesignatedInitExpr10DesignatorC2EjNS_14SourceLocationES2_S2_")]
                    internal static extern void ctor_3(global::System.IntPtr instance, uint Index, clang.SourceLocation.Internal LBracketLoc, clang.SourceLocation.Internal EllipsisLoc, clang.SourceLocation.Internal RBracketLoc);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang18DesignatedInitExpr10DesignatorC2ERKS1_")]
                    internal static extern void cctor_4(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang18DesignatedInitExpr10Designator17isFieldDesignatorEv")]
                    [return: MarshalAsAttribute(UnmanagedType.I1)]
                    internal static extern bool isFieldDesignator_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang18DesignatedInitExpr10Designator17isArrayDesignatorEv")]
                    [return: MarshalAsAttribute(UnmanagedType.I1)]
                    internal static extern bool isArrayDesignator_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang18DesignatedInitExpr10Designator22isArrayRangeDesignatorEv")]
                    [return: MarshalAsAttribute(UnmanagedType.I1)]
                    internal static extern bool isArrayRangeDesignator_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang18DesignatedInitExpr10Designator12getFieldNameEv")]
                    internal static extern global::System.IntPtr getFieldName_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang18DesignatedInitExpr10Designator8getFieldEv")]
                    internal static extern global::System.IntPtr getField_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang18DesignatedInitExpr10Designator8setFieldEPNS_9FieldDeclE")]
                    internal static extern void setField_0(global::System.IntPtr instance, global::System.IntPtr FD);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang18DesignatedInitExpr10Designator9getDotLocEv")]
                    internal static extern clang.SourceLocation.Internal getDotLoc_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang18DesignatedInitExpr10Designator11getFieldLocEv")]
                    internal static extern clang.SourceLocation.Internal getFieldLoc_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang18DesignatedInitExpr10Designator14getLBracketLocEv")]
                    internal static extern clang.SourceLocation.Internal getLBracketLoc_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang18DesignatedInitExpr10Designator14getRBracketLocEv")]
                    internal static extern clang.SourceLocation.Internal getRBracketLoc_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang18DesignatedInitExpr10Designator14getEllipsisLocEv")]
                    internal static extern clang.SourceLocation.Internal getEllipsisLoc_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang18DesignatedInitExpr10Designator17getFirstExprIndexEv")]
                    internal static extern uint getFirstExprIndex_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang18DesignatedInitExpr10Designator11getLocStartEv")]
                    internal static extern clang.SourceLocation.Internal getLocStart_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang18DesignatedInitExpr10Designator9getLocEndEv")]
                    internal static extern clang.SourceLocation.Internal getLocEnd_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang18DesignatedInitExpr10Designator14getSourceRangeEv")]
                    internal static extern clang.SourceRange.Internal getSourceRange_0(global::System.IntPtr instance);
                }

                internal unsafe partial struct _
                {
                    [StructLayout(LayoutKind.Explicit, Size = 16)]
                    public partial struct Internal
                    {
                        [FieldOffset(0)]
                        public clang.DesignatedInitExpr.FieldDesignator.Internal Field;

                        [FieldOffset(0)]
                        public clang.DesignatedInitExpr.ArrayOrRangeDesignator.Internal ArrayOrRange;
                    }
                }

                public global::System.IntPtr __Instance { get; protected set; }
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, Designator> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, Designator>();

                private readonly bool __ownsNativeInstance;

                public static Designator __CreateInstance(global::System.IntPtr native)
                {
                    return new Designator((Designator.Internal*) native);
                }

                public static Designator __CreateInstance(Designator.Internal native)
                {
                    return new Designator(native);
                }

                private static Designator.Internal* __CopyValue(Designator.Internal native)
                {
                    var ret = (Designator.Internal*) Marshal.AllocHGlobal(24);
                    *ret = native;
                    return ret;
                }

                private Designator(Designator.Internal native)
                    : this(__CopyValue(native))
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected Designator(Designator.Internal* native, bool isInternalImpl = false)
                {
                    __Instance = new global::System.IntPtr(native);
                }

                public Designator()
                {
                    __Instance = Marshal.AllocHGlobal(24);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_0(__Instance);
                }

                /// <summary>
                /// <para>Initializes a field designator.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// @brief Initializes a field designator.</para>
                /// </remarks>
                public Designator(clang.IdentifierInfo FieldName, clang.SourceLocation DotLoc, clang.SourceLocation FieldLoc)
                {
                    __Instance = Marshal.AllocHGlobal(24);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    var arg0 = ReferenceEquals(FieldName, null) ? global::System.IntPtr.Zero : FieldName.__Instance;
                    var arg1 = ReferenceEquals(DotLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (DotLoc.__Instance);
                    var arg2 = ReferenceEquals(FieldLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (FieldLoc.__Instance);
                    Internal.ctor_1(__Instance, arg0, arg1, arg2);
                }

                /// <summary>
                /// <para>Initializes an array designator.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// @brief Initializes an array designator.</para>
                /// </remarks>
                public Designator(uint Index, clang.SourceLocation LBracketLoc, clang.SourceLocation RBracketLoc)
                {
                    __Instance = Marshal.AllocHGlobal(24);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    var arg1 = ReferenceEquals(LBracketLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (LBracketLoc.__Instance);
                    var arg2 = ReferenceEquals(RBracketLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (RBracketLoc.__Instance);
                    Internal.ctor_2(__Instance, Index, arg1, arg2);
                }

                /// <summary>
                /// <para>Initializes a GNU array-range designator.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// @brief Initializes a GNU array-range designator.</para>
                /// </remarks>
                public Designator(uint Index, clang.SourceLocation LBracketLoc, clang.SourceLocation EllipsisLoc, clang.SourceLocation RBracketLoc)
                {
                    __Instance = Marshal.AllocHGlobal(24);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    var arg1 = ReferenceEquals(LBracketLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (LBracketLoc.__Instance);
                    var arg2 = ReferenceEquals(EllipsisLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (EllipsisLoc.__Instance);
                    var arg3 = ReferenceEquals(RBracketLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (RBracketLoc.__Instance);
                    Internal.ctor_3(__Instance, Index, arg1, arg2, arg3);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    DestroyNativeInstance(false);
                }

                public virtual void DestroyNativeInstance()
                {
                    DestroyNativeInstance(true);
                }

                private void DestroyNativeInstance(bool force)
                {
                    clang.DesignatedInitExpr.Designator __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public bool isFieldDesignator()
                {
                    var __ret = Internal.isFieldDesignator_0(__Instance);
                    return __ret;
                }

                public bool isArrayDesignator()
                {
                    var __ret = Internal.isArrayDesignator_0(__Instance);
                    return __ret;
                }

                public bool isArrayRangeDesignator()
                {
                    var __ret = Internal.isArrayRangeDesignator_0(__Instance);
                    return __ret;
                }

                public clang.IdentifierInfo getFieldName()
                {
                    var __ret = Internal.getFieldName_0(__Instance);
                    clang.IdentifierInfo __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (clang.IdentifierInfo.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (clang.IdentifierInfo) clang.IdentifierInfo.NativeToManagedMap[__ret];
                    else __result0 = clang.IdentifierInfo.__CreateInstance(__ret);
                    return __result0;
                }

                public clang.FieldDecl getField()
                {
                    var __ret = Internal.getField_0(__Instance);
                    clang.FieldDecl __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (clang.FieldDecl.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (clang.FieldDecl) clang.FieldDecl.NativeToManagedMap[__ret];
                    else clang.FieldDecl.NativeToManagedMap[__ret] = __result0 = (clang.FieldDecl) clang.FieldDecl.__CreateInstance(__ret);
                    return __result0;
                }

                public void setField(clang.FieldDecl FD)
                {
                    var arg0 = ReferenceEquals(FD, null) ? global::System.IntPtr.Zero : FD.__Instance;
                    Internal.setField_0(__Instance, arg0);
                }

                public clang.SourceLocation getDotLoc()
                {
                    var __ret = Internal.getDotLoc_0(__Instance);
                    return clang.SourceLocation.__CreateInstance(__ret);
                }

                public clang.SourceLocation getFieldLoc()
                {
                    var __ret = Internal.getFieldLoc_0(__Instance);
                    return clang.SourceLocation.__CreateInstance(__ret);
                }

                public clang.SourceLocation getLBracketLoc()
                {
                    var __ret = Internal.getLBracketLoc_0(__Instance);
                    return clang.SourceLocation.__CreateInstance(__ret);
                }

                public clang.SourceLocation getRBracketLoc()
                {
                    var __ret = Internal.getRBracketLoc_0(__Instance);
                    return clang.SourceLocation.__CreateInstance(__ret);
                }

                public clang.SourceLocation getEllipsisLoc()
                {
                    var __ret = Internal.getEllipsisLoc_0(__Instance);
                    return clang.SourceLocation.__CreateInstance(__ret);
                }

                public uint getFirstExprIndex()
                {
                    var __ret = Internal.getFirstExprIndex_0(__Instance);
                    return __ret;
                }

                public clang.SourceLocation getLocStart()
                {
                    var __ret = Internal.getLocStart_0(__Instance);
                    return clang.SourceLocation.__CreateInstance(__ret);
                }

                public clang.SourceLocation getLocEnd()
                {
                    var __ret = Internal.getLocEnd_0(__Instance);
                    return clang.SourceLocation.__CreateInstance(__ret);
                }

                public clang.SourceRange getSourceRange()
                {
                    var __ret = Internal.getSourceRange_0(__Instance);
                    return clang.SourceRange.__CreateInstance(__ret);
                }
            }

            /// <summary>
            /// <para>A field designator, e.g., &quot;.x&quot;.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// A field designator, e.g., &quot;.x&quot;.</para>
            /// </remarks>
            public unsafe partial class FieldDesignator : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 16)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public ulong NameOrField;

                    [FieldOffset(8)]
                    public uint DotLoc;

                    [FieldOffset(12)]
                    public uint FieldLoc;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang18DesignatedInitExpr15FieldDesignatorC2ERKS1_")]
                    internal static extern void cctor_0(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, FieldDesignator> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, FieldDesignator>();

                private readonly bool __ownsNativeInstance;

                public static FieldDesignator __CreateInstance(global::System.IntPtr native)
                {
                    return new FieldDesignator((FieldDesignator.Internal*) native);
                }

                public static FieldDesignator __CreateInstance(FieldDesignator.Internal native)
                {
                    return new FieldDesignator(native);
                }

                private static FieldDesignator.Internal* __CopyValue(FieldDesignator.Internal native)
                {
                    var ret = (FieldDesignator.Internal*) Marshal.AllocHGlobal(16);
                    *ret = native;
                    return ret;
                }

                private FieldDesignator(FieldDesignator.Internal native)
                    : this(__CopyValue(native))
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected FieldDesignator(FieldDesignator.Internal* native, bool isInternalImpl = false)
                {
                    __Instance = new global::System.IntPtr(native);
                }

                public FieldDesignator()
                {
                    __Instance = Marshal.AllocHGlobal(16);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    DestroyNativeInstance(false);
                }

                public virtual void DestroyNativeInstance()
                {
                    DestroyNativeInstance(true);
                }

                private void DestroyNativeInstance(bool force)
                {
                    clang.DesignatedInitExpr.FieldDesignator __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public ulong NameOrField
                {
                    get
                    {
                        return ((Internal*) __Instance)->NameOrField;
                    }

                    set
                    {
                        ((Internal*) __Instance)->NameOrField = value;
                    }
                }

                public uint DotLoc
                {
                    get
                    {
                        return ((Internal*) __Instance)->DotLoc;
                    }

                    set
                    {
                        ((Internal*) __Instance)->DotLoc = value;
                    }
                }

                public uint FieldLoc
                {
                    get
                    {
                        return ((Internal*) __Instance)->FieldLoc;
                    }

                    set
                    {
                        ((Internal*) __Instance)->FieldLoc = value;
                    }
                }
            }

            /// <summary>
            /// <para>An array or GNU array-range designator, e.g., &quot;[9]&quot; or
            /// &quot;[10..15]&quot;.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// An array or GNU array-range designator, e.g., &quot;[9]&quot;
            /// or &quot;[10..15]&quot;.</para>
            /// </remarks>
            public unsafe partial class ArrayOrRangeDesignator : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 16)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public uint Index;

                    [FieldOffset(4)]
                    public uint LBracketLoc;

                    [FieldOffset(8)]
                    public uint EllipsisLoc;

                    [FieldOffset(12)]
                    public uint RBracketLoc;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang18DesignatedInitExpr22ArrayOrRangeDesignatorC2ERKS1_")]
                    internal static extern void cctor_0(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ArrayOrRangeDesignator> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ArrayOrRangeDesignator>();

                private readonly bool __ownsNativeInstance;

                public static ArrayOrRangeDesignator __CreateInstance(global::System.IntPtr native)
                {
                    return new ArrayOrRangeDesignator((ArrayOrRangeDesignator.Internal*) native);
                }

                public static ArrayOrRangeDesignator __CreateInstance(ArrayOrRangeDesignator.Internal native)
                {
                    return new ArrayOrRangeDesignator(native);
                }

                private static ArrayOrRangeDesignator.Internal* __CopyValue(ArrayOrRangeDesignator.Internal native)
                {
                    var ret = (ArrayOrRangeDesignator.Internal*) Marshal.AllocHGlobal(16);
                    *ret = native;
                    return ret;
                }

                private ArrayOrRangeDesignator(ArrayOrRangeDesignator.Internal native)
                    : this(__CopyValue(native))
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected ArrayOrRangeDesignator(ArrayOrRangeDesignator.Internal* native, bool isInternalImpl = false)
                {
                    __Instance = new global::System.IntPtr(native);
                }

                public ArrayOrRangeDesignator()
                {
                    __Instance = Marshal.AllocHGlobal(16);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    DestroyNativeInstance(false);
                }

                public virtual void DestroyNativeInstance()
                {
                    DestroyNativeInstance(true);
                }

                private void DestroyNativeInstance(bool force)
                {
                    clang.DesignatedInitExpr.ArrayOrRangeDesignator __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public uint Index
                {
                    get
                    {
                        return ((Internal*) __Instance)->Index;
                    }

                    set
                    {
                        ((Internal*) __Instance)->Index = value;
                    }
                }

                public uint LBracketLoc
                {
                    get
                    {
                        return ((Internal*) __Instance)->LBracketLoc;
                    }

                    set
                    {
                        ((Internal*) __Instance)->LBracketLoc = value;
                    }
                }

                public uint EllipsisLoc
                {
                    get
                    {
                        return ((Internal*) __Instance)->EllipsisLoc;
                    }

                    set
                    {
                        ((Internal*) __Instance)->EllipsisLoc = value;
                    }
                }

                public uint RBracketLoc
                {
                    get
                    {
                        return ((Internal*) __Instance)->RBracketLoc;
                    }

                    set
                    {
                        ((Internal*) __Instance)->RBracketLoc = value;
                    }
                }
            }

            private readonly bool __ownsNativeInstance;

            public static new DesignatedInitExpr __CreateInstance(global::System.IntPtr native)
            {
                return new DesignatedInitExpr((DesignatedInitExpr.Internal*) native);
            }

            public static DesignatedInitExpr __CreateInstance(DesignatedInitExpr.Internal native)
            {
                return new DesignatedInitExpr(native);
            }

            private static DesignatedInitExpr.Internal* __CopyValue(DesignatedInitExpr.Internal native)
            {
                var ret = (DesignatedInitExpr.Internal*) Marshal.AllocHGlobal(32);
                *ret = native;
                return ret;
            }

            private DesignatedInitExpr(DesignatedInitExpr.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected DesignatedInitExpr(DesignatedInitExpr.Internal* native, bool isInternalImpl = false)
                : base((clang.Expr.Internal*) native)
            {
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Stmt __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            /// <summary>
            /// <para>Returns the number of designators in this initializer.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// @brief Returns the number of designators in this
            /// initializer.</para>
            /// </remarks>
            public uint size()
            {
                var __ret = Internal.size_0(__Instance);
                return __ret;
            }

            public clang.DesignatedInitExpr.Designator designators_begin()
            {
                var __ret = Internal.designators_begin_0(__Instance);
                clang.DesignatedInitExpr.Designator __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.DesignatedInitExpr.Designator.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.DesignatedInitExpr.Designator) clang.DesignatedInitExpr.Designator.NativeToManagedMap[__ret];
                else __result0 = clang.DesignatedInitExpr.Designator.__CreateInstance(__ret);
                return __result0;
            }

            public clang.DesignatedInitExpr.Designator designators_end()
            {
                var __ret = Internal.designators_end_0(__Instance);
                clang.DesignatedInitExpr.Designator __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.DesignatedInitExpr.Designator.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.DesignatedInitExpr.Designator) clang.DesignatedInitExpr.Designator.NativeToManagedMap[__ret];
                else __result0 = clang.DesignatedInitExpr.Designator.__CreateInstance(__ret);
                return __result0;
            }

            public clang.DesignatedInitExpr.Designator getDesignator(uint Idx)
            {
                var __ret = Internal.getDesignator_0(__Instance, Idx);
                clang.DesignatedInitExpr.Designator __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.DesignatedInitExpr.Designator.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.DesignatedInitExpr.Designator) clang.DesignatedInitExpr.Designator.NativeToManagedMap[__ret];
                else __result0 = clang.DesignatedInitExpr.Designator.__CreateInstance(__ret);
                return __result0;
            }

            public clang.Expr getArrayIndex(clang.DesignatedInitExpr.Designator D)
            {
                var arg0 = ReferenceEquals(D, null) ? global::System.IntPtr.Zero : D.__Instance;
                var __ret = Internal.getArrayIndex_0(__Instance, arg0);
                clang.Expr __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Expr.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Expr) clang.Expr.NativeToManagedMap[__ret];
                else __result0 = clang.Expr.__CreateInstance(__ret);
                return __result0;
            }

            public clang.Expr getArrayRangeStart(clang.DesignatedInitExpr.Designator D)
            {
                var arg0 = ReferenceEquals(D, null) ? global::System.IntPtr.Zero : D.__Instance;
                var __ret = Internal.getArrayRangeStart_0(__Instance, arg0);
                clang.Expr __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Expr.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Expr) clang.Expr.NativeToManagedMap[__ret];
                else __result0 = clang.Expr.__CreateInstance(__ret);
                return __result0;
            }

            public clang.Expr getArrayRangeEnd(clang.DesignatedInitExpr.Designator D)
            {
                var arg0 = ReferenceEquals(D, null) ? global::System.IntPtr.Zero : D.__Instance;
                var __ret = Internal.getArrayRangeEnd_0(__Instance, arg0);
                clang.Expr __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Expr.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Expr) clang.Expr.NativeToManagedMap[__ret];
                else __result0 = clang.Expr.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Retrieve the location of the '=' that precedes the initializer
            /// value itself, if present.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// @brief Retrieve the location of the '=' that precedes
            /// the</para>
            /// <para>  /// initializer value itself, if present.</para>
            /// </remarks>
            public clang.SourceLocation getEqualOrColonLoc()
            {
                var __ret = Internal.getEqualOrColonLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setEqualOrColonLoc(clang.SourceLocation L)
            {
                var arg0 = ReferenceEquals(L, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (L.__Instance);
                Internal.setEqualOrColonLoc_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>Determines whether this designated initializer used the
            /// deprecated GNU syntax for designated initializers.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// @brief Determines whether this designated initializer used
            /// the</para>
            /// <para>  /// deprecated GNU syntax for designated initializers.</para>
            /// </remarks>
            public bool usesGNUSyntax()
            {
                var __ret = Internal.usesGNUSyntax_0(__Instance);
                return __ret;
            }

            public void setGNUSyntax(bool GNU)
            {
                Internal.setGNUSyntax_0(__Instance, GNU);
            }

            /// <summary>
            /// <para>Retrieve the initializer value.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// @brief Retrieve the initializer value.</para>
            /// </remarks>
            public clang.Expr getInit()
            {
                var __ret = Internal.getInit_0(__Instance);
                clang.Expr __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Expr.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Expr) clang.Expr.NativeToManagedMap[__ret];
                else __result0 = clang.Expr.__CreateInstance(__ret);
                return __result0;
            }

            public void setInit(clang.Expr init)
            {
                var arg0 = ReferenceEquals(init, null) ? global::System.IntPtr.Zero : init.__Instance;
                Internal.setInit_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>Retrieve the total number of subexpressions in this designated
            /// initializer expression, including the actual initialized value and any
            /// expressions that occur within array and array-range designators.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the total number of subexpressions in
            /// this</para>
            /// <para>  /// designated initializer expression, including the
            /// actual</para>
            /// <para>  /// initialized value and any expressions that occur within
            /// array</para>
            /// <para>  /// and array-range designators.</para>
            /// </remarks>
            public uint getNumSubExprs()
            {
                var __ret = Internal.getNumSubExprs_0(__Instance);
                return __ret;
            }

            public clang.Expr getSubExpr(uint Idx)
            {
                var __ret = Internal.getSubExpr_0(__Instance, Idx);
                clang.Expr __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Expr.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Expr) clang.Expr.NativeToManagedMap[__ret];
                else __result0 = clang.Expr.__CreateInstance(__ret);
                return __result0;
            }

            public void setSubExpr(uint Idx, clang.Expr E)
            {
                var arg1 = ReferenceEquals(E, null) ? global::System.IntPtr.Zero : E.__Instance;
                Internal.setSubExpr_0(__Instance, Idx, arg1);
            }

            public clang.SourceRange getDesignatorsSourceRange()
            {
                var __ret = Internal.getDesignatorsSourceRange_0(__Instance);
                return clang.SourceRange.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLocStart()
            {
                var __ret = Internal.getLocStart_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLocEnd()
            {
                var __ret = Internal.getLocEnd_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.StmtRange children()
            {
                var __ret = new clang.StmtRange.Internal();
                Internal.children_0(new IntPtr(&__ret), __Instance);
                return clang.StmtRange.__CreateInstance(__ret);
            }

            public static bool classof(clang.Stmt T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Represents an implicitly-generated value initialization of an
        /// object of a given type.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief Represents an implicitly-generated value
        /// initialization of</para>
        /// <para>/// an object of a given type.</para>
        /// <para>///</para>
        /// <para>/// Implicit value initializations occur within semantic
        /// initializer</para>
        /// <para>/// list expressions (InitListExpr) as placeholders for
        /// subobject</para>
        /// <para>/// initializations not explicitly specified by the user.</para>
        /// <para>///</para>
        /// <para>/// \see InitListExpr</para>
        /// </remarks>
        public unsafe partial class ImplicitValueInitExpr : clang.Expr, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                internal clang.Stmt._.Internal __;

                [FieldOffset(8)]
                public clang.QualType.Internal TR;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang21ImplicitValueInitExprC2ENS_8QualTypeE")]
                internal static extern void ctor_0(global::System.IntPtr instance, clang.QualType.Internal ty);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang21ImplicitValueInitExprC2ENS_4Stmt10EmptyShellE")]
                internal static extern void ctor_1(global::System.IntPtr instance, clang.Stmt.EmptyShell.Internal Empty);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang21ImplicitValueInitExprC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang21ImplicitValueInitExpr7classofEPKNS_4StmtE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang21ImplicitValueInitExpr11getLocStartEv")]
                internal static extern clang.SourceLocation.Internal getLocStart_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang21ImplicitValueInitExpr9getLocEndEv")]
                internal static extern clang.SourceLocation.Internal getLocEnd_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang21ImplicitValueInitExpr8childrenEv")]
                internal static extern void children_0(global::System.IntPtr @return, global::System.IntPtr instance);
            }

            private readonly bool __ownsNativeInstance;

            public static new ImplicitValueInitExpr __CreateInstance(global::System.IntPtr native)
            {
                return new ImplicitValueInitExpr((ImplicitValueInitExpr.Internal*) native);
            }

            public static ImplicitValueInitExpr __CreateInstance(ImplicitValueInitExpr.Internal native)
            {
                return new ImplicitValueInitExpr(native);
            }

            private static ImplicitValueInitExpr.Internal* __CopyValue(ImplicitValueInitExpr.Internal native)
            {
                var ret = (ImplicitValueInitExpr.Internal*) Marshal.AllocHGlobal(16);
                *ret = native;
                return ret;
            }

            private ImplicitValueInitExpr(ImplicitValueInitExpr.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected ImplicitValueInitExpr(ImplicitValueInitExpr.Internal* native, bool isInternalImpl = false)
                : base((clang.Expr.Internal*) native)
            {
            }

            public ImplicitValueInitExpr(clang.QualType ty)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(16);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(ty, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (ty.__Instance);
                Internal.ctor_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>Construct an empty implicit value initialization.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Construct an empty implicit value
            /// initialization.</para>
            /// </remarks>
            public ImplicitValueInitExpr(clang.Stmt.EmptyShell Empty)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(16);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(Empty, null) ? new clang.Stmt.EmptyShell.Internal() : *(clang.Stmt.EmptyShell.Internal*) (Empty.__Instance);
                Internal.ctor_1(__Instance, arg0);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Stmt __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.SourceLocation getLocStart()
            {
                var __ret = Internal.getLocStart_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLocEnd()
            {
                var __ret = Internal.getLocEnd_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.StmtRange children()
            {
                var __ret = new clang.StmtRange.Internal();
                Internal.children_0(new IntPtr(&__ret), __Instance);
                return clang.StmtRange.__CreateInstance(__ret);
            }

            public static bool classof(clang.Stmt T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        public unsafe partial class ParenListExpr : clang.Expr, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 40)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                internal clang.Stmt._.Internal __;

                [FieldOffset(8)]
                public clang.QualType.Internal TR;

                [FieldOffset(16)]
                public global::System.IntPtr Exprs;

                [FieldOffset(24)]
                public uint NumExprs;

                [FieldOffset(28)]
                public clang.SourceLocation.Internal LParenLoc;

                [FieldOffset(32)]
                public clang.SourceLocation.Internal RParenLoc;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13ParenListExprC2ENS_4Stmt10EmptyShellE")]
                internal static extern void ctor_1(global::System.IntPtr instance, clang.Stmt.EmptyShell.Internal Empty);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13ParenListExprC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13ParenListExpr11getNumExprsEv")]
                internal static extern uint getNumExprs_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13ParenListExpr7getExprEj")]
                internal static extern global::System.IntPtr getExpr_1(global::System.IntPtr instance, uint Init);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13ParenListExpr8getExprsEv")]
                internal static extern global::System.IntPtr getExprs_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13ParenListExpr12getLParenLocEv")]
                internal static extern clang.SourceLocation.Internal getLParenLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13ParenListExpr12getRParenLocEv")]
                internal static extern clang.SourceLocation.Internal getRParenLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13ParenListExpr11getLocStartEv")]
                internal static extern clang.SourceLocation.Internal getLocStart_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13ParenListExpr9getLocEndEv")]
                internal static extern clang.SourceLocation.Internal getLocEnd_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13ParenListExpr7classofEPKNS_4StmtE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13ParenListExpr8childrenEv")]
                internal static extern void children_0(global::System.IntPtr @return, global::System.IntPtr instance);
            }

            private readonly bool __ownsNativeInstance;

            public static new ParenListExpr __CreateInstance(global::System.IntPtr native)
            {
                return new ParenListExpr((ParenListExpr.Internal*) native);
            }

            public static ParenListExpr __CreateInstance(ParenListExpr.Internal native)
            {
                return new ParenListExpr(native);
            }

            private static ParenListExpr.Internal* __CopyValue(ParenListExpr.Internal native)
            {
                var ret = (ParenListExpr.Internal*) Marshal.AllocHGlobal(40);
                *ret = native;
                return ret;
            }

            private ParenListExpr(ParenListExpr.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected ParenListExpr(ParenListExpr.Internal* native, bool isInternalImpl = false)
                : base((clang.Expr.Internal*) native)
            {
            }

            /// <summary>
            /// <para>Build an empty paren list.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Build an empty paren list.</para>
            /// </remarks>
            public ParenListExpr(clang.Stmt.EmptyShell Empty)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(40);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(Empty, null) ? new clang.Stmt.EmptyShell.Internal() : *(clang.Stmt.EmptyShell.Internal*) (Empty.__Instance);
                Internal.ctor_1(__Instance, arg0);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Stmt __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public uint getNumExprs()
            {
                var __ret = Internal.getNumExprs_0(__Instance);
                return __ret;
            }

            public clang.Expr getExpr(uint Init)
            {
                var __ret = Internal.getExpr_1(__Instance, Init);
                clang.Expr __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Expr.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Expr) clang.Expr.NativeToManagedMap[__ret];
                else __result0 = clang.Expr.__CreateInstance(__ret);
                return __result0;
            }

            public clang.Expr getExprs()
            {
                var __ret = Internal.getExprs_0(__Instance);
                clang.Expr __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Expr.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Expr) clang.Expr.NativeToManagedMap[__ret];
                else __result0 = clang.Expr.__CreateInstance(__ret);
                return __result0;
            }

            public clang.SourceLocation getLParenLoc()
            {
                var __ret = Internal.getLParenLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getRParenLoc()
            {
                var __ret = Internal.getRParenLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLocStart()
            {
                var __ret = Internal.getLocStart_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLocEnd()
            {
                var __ret = Internal.getLocEnd_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.StmtRange children()
            {
                var __ret = new clang.StmtRange.Internal();
                Internal.children_0(new IntPtr(&__ret), __Instance);
                return clang.StmtRange.__CreateInstance(__ret);
            }

            public static bool classof(clang.Stmt T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Represents a C11 generic selection.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief Represents a C11 generic selection.</para>
        /// <para>///</para>
        /// <para>/// A generic selection (C11 6.5.1.1) contains an unevaluated
        /// controlling</para>
        /// <para>/// expression, followed by one or more generic associations.
        /// Each generic</para>
        /// <para>/// association specifies a type name and an expression, or
        /// &quot;default&quot; and an</para>
        /// <para>/// expression (in which case it is known as a default generic
        /// association).</para>
        /// <para>/// The type and value of the generic selection are identical to
        /// those of its</para>
        /// <para>/// result expression, which is defined as the expression in the
        /// generic</para>
        /// <para>/// association with a type name that is compatible with the type
        /// of the</para>
        /// <para>/// controlling expression, or the expression in the default
        /// generic association</para>
        /// <para>/// if no types are compatible.  For example:</para>
        /// <para>///</para>
        /// <para>/// @code</para>
        /// <para>/// _Generic(X, double: 1, float: 2, default: 3)</para>
        /// <para>/// @endcode</para>
        /// <para>///</para>
        /// <para>/// The above expression evaluates to 1 if 1.0 is substituted for
        /// X, 2 if 1.0f</para>
        /// <para>/// or 3 if &quot;hello&quot;.</para>
        /// <para>///</para>
        /// <para>/// As an extension, generic selections are allowed in C++, where
        /// the following</para>
        /// <para>/// additional semantics apply:</para>
        /// <para>///</para>
        /// <para>/// Any generic selection whose controlling expression is
        /// type-dependent or</para>
        /// <para>/// which names a dependent type in its association list is
        /// result-dependent,</para>
        /// <para>/// which means that the choice of result expression is
        /// dependent.</para>
        /// <para>/// Result-dependent generic associations are both type- and
        /// value-dependent.</para>
        /// </remarks>
        public unsafe partial class GenericSelectionExpr : clang.Expr, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 56)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                internal clang.Stmt._.Internal __;

                [FieldOffset(8)]
                public clang.QualType.Internal TR;

                [FieldOffset(16)]
                public global::System.IntPtr AssocTypes;

                [FieldOffset(24)]
                public global::System.IntPtr SubExprs;

                [FieldOffset(32)]
                public uint NumAssocs;

                [FieldOffset(36)]
                public uint ResultIndex;

                [FieldOffset(40)]
                public clang.SourceLocation.Internal GenericLoc;

                [FieldOffset(44)]
                public clang.SourceLocation.Internal DefaultLoc;

                [FieldOffset(48)]
                public clang.SourceLocation.Internal RParenLoc;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang20GenericSelectionExprC2ENS_4Stmt10EmptyShellE")]
                internal static extern void ctor_2(global::System.IntPtr instance, clang.Stmt.EmptyShell.Internal Empty);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang20GenericSelectionExprC2ERKS0_")]
                internal static extern void cctor_3(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang20GenericSelectionExpr12getNumAssocsEv")]
                internal static extern uint getNumAssocs_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang20GenericSelectionExpr13getGenericLocEv")]
                internal static extern clang.SourceLocation.Internal getGenericLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang20GenericSelectionExpr13getDefaultLocEv")]
                internal static extern clang.SourceLocation.Internal getDefaultLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang20GenericSelectionExpr12getRParenLocEv")]
                internal static extern clang.SourceLocation.Internal getRParenLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang20GenericSelectionExpr12getAssocExprEj")]
                internal static extern global::System.IntPtr getAssocExpr_1(global::System.IntPtr instance, uint i);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang20GenericSelectionExpr22getAssocTypeSourceInfoEj")]
                internal static extern global::System.IntPtr getAssocTypeSourceInfo_1(global::System.IntPtr instance, uint i);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang20GenericSelectionExpr12getAssocTypeEj")]
                internal static extern clang.QualType.Internal getAssocType_0(global::System.IntPtr instance, uint i);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang20GenericSelectionExpr18getControllingExprEv")]
                internal static extern global::System.IntPtr getControllingExpr_1(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang20GenericSelectionExpr17isResultDependentEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isResultDependent_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang20GenericSelectionExpr14getResultIndexEv")]
                internal static extern uint getResultIndex_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang20GenericSelectionExpr13getResultExprEv")]
                internal static extern global::System.IntPtr getResultExpr_1(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang20GenericSelectionExpr11getLocStartEv")]
                internal static extern clang.SourceLocation.Internal getLocStart_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang20GenericSelectionExpr9getLocEndEv")]
                internal static extern clang.SourceLocation.Internal getLocEnd_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang20GenericSelectionExpr7classofEPKNS_4StmtE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang20GenericSelectionExpr8childrenEv")]
                internal static extern void children_0(global::System.IntPtr @return, global::System.IntPtr instance);
            }

            private readonly bool __ownsNativeInstance;

            public static new GenericSelectionExpr __CreateInstance(global::System.IntPtr native)
            {
                return new GenericSelectionExpr((GenericSelectionExpr.Internal*) native);
            }

            public static GenericSelectionExpr __CreateInstance(GenericSelectionExpr.Internal native)
            {
                return new GenericSelectionExpr(native);
            }

            private static GenericSelectionExpr.Internal* __CopyValue(GenericSelectionExpr.Internal native)
            {
                var ret = (GenericSelectionExpr.Internal*) Marshal.AllocHGlobal(56);
                *ret = native;
                return ret;
            }

            private GenericSelectionExpr(GenericSelectionExpr.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected GenericSelectionExpr(GenericSelectionExpr.Internal* native, bool isInternalImpl = false)
                : base((clang.Expr.Internal*) native)
            {
            }

            public GenericSelectionExpr(clang.Stmt.EmptyShell Empty)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(56);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(Empty, null) ? new clang.Stmt.EmptyShell.Internal() : *(clang.Stmt.EmptyShell.Internal*) (Empty.__Instance);
                Internal.ctor_2(__Instance, arg0);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Stmt __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public uint getNumAssocs()
            {
                var __ret = Internal.getNumAssocs_0(__Instance);
                return __ret;
            }

            public clang.SourceLocation getGenericLoc()
            {
                var __ret = Internal.getGenericLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getDefaultLoc()
            {
                var __ret = Internal.getDefaultLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getRParenLoc()
            {
                var __ret = Internal.getRParenLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.Expr getAssocExpr(uint i)
            {
                var __ret = Internal.getAssocExpr_1(__Instance, i);
                clang.Expr __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Expr.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Expr) clang.Expr.NativeToManagedMap[__ret];
                else __result0 = clang.Expr.__CreateInstance(__ret);
                return __result0;
            }

            public clang.TypeSourceInfo getAssocTypeSourceInfo(uint i)
            {
                var __ret = Internal.getAssocTypeSourceInfo_1(__Instance, i);
                clang.TypeSourceInfo __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.TypeSourceInfo.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.TypeSourceInfo) clang.TypeSourceInfo.NativeToManagedMap[__ret];
                else __result0 = clang.TypeSourceInfo.__CreateInstance(__ret);
                return __result0;
            }

            public clang.QualType getAssocType(uint i)
            {
                var __ret = Internal.getAssocType_0(__Instance, i);
                return clang.QualType.__CreateInstance(__ret);
            }

            public clang.Expr getControllingExpr()
            {
                var __ret = Internal.getControllingExpr_1(__Instance);
                clang.Expr __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Expr.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Expr) clang.Expr.NativeToManagedMap[__ret];
                else __result0 = clang.Expr.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Whether this generic selection is result-dependent.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Whether this generic selection is result-dependent.</para>
            /// </remarks>
            public bool isResultDependent()
            {
                var __ret = Internal.isResultDependent_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>The zero-based index of the result expression's generic
            /// association in the generic selection's association list. Defined only if
            /// the generic selection is not result-dependent.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// The zero-based index of the result expression's generic
            /// association in</para>
            /// <para>  /// the generic selection's association list.  Defined only if
            /// the</para>
            /// <para>  /// generic selection is not result-dependent.</para>
            /// </remarks>
            public uint getResultIndex()
            {
                var __ret = Internal.getResultIndex_0(__Instance);
                return __ret;
            }

            public clang.Expr getResultExpr()
            {
                var __ret = Internal.getResultExpr_1(__Instance);
                clang.Expr __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Expr.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Expr) clang.Expr.NativeToManagedMap[__ret];
                else __result0 = clang.Expr.__CreateInstance(__ret);
                return __result0;
            }

            public clang.SourceLocation getLocStart()
            {
                var __ret = Internal.getLocStart_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLocEnd()
            {
                var __ret = Internal.getLocEnd_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.StmtRange children()
            {
                var __ret = new clang.StmtRange.Internal();
                Internal.children_0(new IntPtr(&__ret), __Instance);
                return clang.StmtRange.__CreateInstance(__ret);
            }

            public static bool classof(clang.Stmt T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>ExtVectorElementExpr - This represents access to specific
        /// elements of a vector, and may occur on the left hand side or right hand
        /// side. For example the following is legal: &quot;V.xy = V.zw&quot; if V is a
        /// 4 element extended vector.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// ExtVectorElementExpr - This represents access to specific
        /// elements of a</para>
        /// <para>/// vector, and may occur on the left hand side or right hand
        /// side.  For example</para>
        /// <para>/// the following is legal:  &quot;V.xy = V.zw&quot; if V is a 4
        /// element extended vector.</para>
        /// <para>///</para>
        /// <para>/// Note that the base may have either vector or pointer to
        /// vector type, just</para>
        /// <para>/// like a struct field reference.</para>
        /// <para>///</para>
        /// </remarks>
        public unsafe partial class ExtVectorElementExpr : clang.Expr, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 40)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                internal clang.Stmt._.Internal __;

                [FieldOffset(8)]
                public clang.QualType.Internal TR;

                [FieldOffset(16)]
                public global::System.IntPtr Base;

                [FieldOffset(24)]
                public global::System.IntPtr Accessor;

                [FieldOffset(32)]
                public clang.SourceLocation.Internal AccessorLoc;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang20ExtVectorElementExprC2ENS_8QualTypeENS_13ExprValueKindEPNS_4ExprERNS_14IdentifierInfoENS_14SourceLocationE")]
                internal static extern void ctor_0(global::System.IntPtr instance, clang.QualType.Internal ty, clang.ExprValueKind VK, global::System.IntPtr @base, global::System.IntPtr accessor, clang.SourceLocation.Internal loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang20ExtVectorElementExprC2ENS_4Stmt10EmptyShellE")]
                internal static extern void ctor_1(global::System.IntPtr instance, clang.Stmt.EmptyShell.Internal Empty);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang20ExtVectorElementExprC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang20ExtVectorElementExpr7getBaseEv")]
                internal static extern global::System.IntPtr getBase_1(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang20ExtVectorElementExpr7setBaseEPNS_4ExprE")]
                internal static extern void setBase_0(global::System.IntPtr instance, global::System.IntPtr E);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang20ExtVectorElementExpr11getAccessorEv")]
                internal static extern global::System.IntPtr getAccessor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang20ExtVectorElementExpr11setAccessorEPNS_14IdentifierInfoE")]
                internal static extern void setAccessor_0(global::System.IntPtr instance, global::System.IntPtr II);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang20ExtVectorElementExpr14getAccessorLocEv")]
                internal static extern clang.SourceLocation.Internal getAccessorLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang20ExtVectorElementExpr14setAccessorLocENS_14SourceLocationE")]
                internal static extern void setAccessorLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal L);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang20ExtVectorElementExpr14getNumElementsEv")]
                internal static extern uint getNumElements_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang20ExtVectorElementExpr25containsDuplicateElementsEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool containsDuplicateElements_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang20ExtVectorElementExpr11getLocStartEv")]
                internal static extern clang.SourceLocation.Internal getLocStart_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang20ExtVectorElementExpr9getLocEndEv")]
                internal static extern clang.SourceLocation.Internal getLocEnd_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang20ExtVectorElementExpr7isArrowEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isArrow_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang20ExtVectorElementExpr7classofEPKNS_4StmtE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang20ExtVectorElementExpr8childrenEv")]
                internal static extern void children_0(global::System.IntPtr @return, global::System.IntPtr instance);
            }

            private readonly bool __ownsNativeInstance;

            public static new ExtVectorElementExpr __CreateInstance(global::System.IntPtr native)
            {
                return new ExtVectorElementExpr((ExtVectorElementExpr.Internal*) native);
            }

            public static ExtVectorElementExpr __CreateInstance(ExtVectorElementExpr.Internal native)
            {
                return new ExtVectorElementExpr(native);
            }

            private static ExtVectorElementExpr.Internal* __CopyValue(ExtVectorElementExpr.Internal native)
            {
                var ret = (ExtVectorElementExpr.Internal*) Marshal.AllocHGlobal(40);
                *ret = native;
                return ret;
            }

            private ExtVectorElementExpr(ExtVectorElementExpr.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected ExtVectorElementExpr(ExtVectorElementExpr.Internal* native, bool isInternalImpl = false)
                : base((clang.Expr.Internal*) native)
            {
            }

            public ExtVectorElementExpr(clang.QualType ty, clang.ExprValueKind VK, clang.Expr @base, clang.IdentifierInfo accessor, clang.SourceLocation loc)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(40);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(ty, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (ty.__Instance);
                var arg1 = VK;
                var arg2 = ReferenceEquals(@base, null) ? global::System.IntPtr.Zero : @base.__Instance;
                var arg3 = ReferenceEquals(accessor, null) ? global::System.IntPtr.Zero : accessor.__Instance;
                var arg4 = ReferenceEquals(loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (loc.__Instance);
                Internal.ctor_0(__Instance, arg0, arg1, arg2, arg3, arg4);
            }

            /// <summary>
            /// <para>Build an empty vector element expression.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Build an empty vector element expression.</para>
            /// </remarks>
            public ExtVectorElementExpr(clang.Stmt.EmptyShell Empty)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(40);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(Empty, null) ? new clang.Stmt.EmptyShell.Internal() : *(clang.Stmt.EmptyShell.Internal*) (Empty.__Instance);
                Internal.ctor_1(__Instance, arg0);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Stmt __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.Expr getBase()
            {
                var __ret = Internal.getBase_1(__Instance);
                clang.Expr __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Expr.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Expr) clang.Expr.NativeToManagedMap[__ret];
                else __result0 = clang.Expr.__CreateInstance(__ret);
                return __result0;
            }

            public void setBase(clang.Expr E)
            {
                var arg0 = ReferenceEquals(E, null) ? global::System.IntPtr.Zero : E.__Instance;
                Internal.setBase_0(__Instance, arg0);
            }

            public clang.IdentifierInfo getAccessor()
            {
                var __ret = Internal.getAccessor_0(__Instance);
                clang.IdentifierInfo __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.IdentifierInfo.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.IdentifierInfo) clang.IdentifierInfo.NativeToManagedMap[__ret];
                else __result0 = clang.IdentifierInfo.__CreateInstance(__ret);
                return __result0;
            }

            public void setAccessor(clang.IdentifierInfo II)
            {
                var arg0 = ReferenceEquals(II, null) ? global::System.IntPtr.Zero : II.__Instance;
                Internal.setAccessor_0(__Instance, arg0);
            }

            public clang.SourceLocation getAccessorLoc()
            {
                var __ret = Internal.getAccessorLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setAccessorLoc(clang.SourceLocation L)
            {
                var arg0 = ReferenceEquals(L, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (L.__Instance);
                Internal.setAccessorLoc_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>getNumElements - Get the number of components being
            /// selected.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getNumElements - Get the number of components being
            /// selected.</para>
            /// </remarks>
            public uint getNumElements()
            {
                var __ret = Internal.getNumElements_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>containsDuplicateElements - Return true if any element access is
            /// repeated.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// containsDuplicateElements - Return true if any element access
            /// is</para>
            /// <para>  /// repeated.</para>
            /// </remarks>
            public bool containsDuplicateElements()
            {
                var __ret = Internal.containsDuplicateElements_0(__Instance);
                return __ret;
            }

            public clang.SourceLocation getLocStart()
            {
                var __ret = Internal.getLocStart_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLocEnd()
            {
                var __ret = Internal.getLocEnd_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>isArrow - Return true if the base expression is a pointer to
            /// vector, return false if the base expression is a vector.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// isArrow - Return true if the base expression is a pointer to
            /// vector,</para>
            /// <para>  /// return false if the base expression is a vector.</para>
            /// </remarks>
            public bool isArrow()
            {
                var __ret = Internal.isArrow_0(__Instance);
                return __ret;
            }

            public clang.StmtRange children()
            {
                var __ret = new clang.StmtRange.Internal();
                Internal.children_0(new IntPtr(&__ret), __Instance);
                return clang.StmtRange.__CreateInstance(__ret);
            }

            public static bool classof(clang.Stmt T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>BlockExpr - Adaptor class for mixing a BlockDecl with
        /// expressions. ^{ statement-body } or ^(int arg1, float arg2){ statement-body
        /// }</para>
        /// </summary>
        /// <remarks>
        /// <para>/// BlockExpr - Adaptor class for mixing a BlockDecl with
        /// expressions.</para>
        /// <para>/// ^{ statement-body }   or   ^(int arg1, float arg2){
        /// statement-body }</para>
        /// </remarks>
        public unsafe partial class BlockExpr : clang.Expr, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 24)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                internal clang.Stmt._.Internal __;

                [FieldOffset(8)]
                public clang.QualType.Internal TR;

                [FieldOffset(16)]
                public global::System.IntPtr TheBlock;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9BlockExprC2EPNS_9BlockDeclENS_8QualTypeE")]
                internal static extern void ctor_0(global::System.IntPtr instance, global::System.IntPtr BD, clang.QualType.Internal ty);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9BlockExprC2ENS_4Stmt10EmptyShellE")]
                internal static extern void ctor_1(global::System.IntPtr instance, clang.Stmt.EmptyShell.Internal Empty);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9BlockExprC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9BlockExpr12getBlockDeclEv")]
                internal static extern global::System.IntPtr getBlockDecl_1(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9BlockExpr12setBlockDeclEPNS_9BlockDeclE")]
                internal static extern void setBlockDecl_0(global::System.IntPtr instance, global::System.IntPtr BD);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9BlockExpr16getCaretLocationEv")]
                internal static extern clang.SourceLocation.Internal getCaretLocation_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9BlockExpr7getBodyEv")]
                internal static extern global::System.IntPtr getBody_1(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9BlockExpr11getLocStartEv")]
                internal static extern clang.SourceLocation.Internal getLocStart_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9BlockExpr9getLocEndEv")]
                internal static extern clang.SourceLocation.Internal getLocEnd_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9BlockExpr15getFunctionTypeEv")]
                internal static extern global::System.IntPtr getFunctionType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9BlockExpr7classofEPKNS_4StmtE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9BlockExpr8childrenEv")]
                internal static extern void children_0(global::System.IntPtr @return, global::System.IntPtr instance);
            }

            private readonly bool __ownsNativeInstance;

            public static new BlockExpr __CreateInstance(global::System.IntPtr native)
            {
                return new BlockExpr((BlockExpr.Internal*) native);
            }

            public static BlockExpr __CreateInstance(BlockExpr.Internal native)
            {
                return new BlockExpr(native);
            }

            private static BlockExpr.Internal* __CopyValue(BlockExpr.Internal native)
            {
                var ret = (BlockExpr.Internal*) Marshal.AllocHGlobal(24);
                *ret = native;
                return ret;
            }

            private BlockExpr(BlockExpr.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected BlockExpr(BlockExpr.Internal* native, bool isInternalImpl = false)
                : base((clang.Expr.Internal*) native)
            {
            }

            public BlockExpr(clang.BlockDecl BD, clang.QualType ty)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(24);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(BD, null) ? global::System.IntPtr.Zero : BD.__Instance;
                var arg1 = ReferenceEquals(ty, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (ty.__Instance);
                Internal.ctor_0(__Instance, arg0, arg1);
            }

            /// <summary>
            /// <para>Build an empty block expression.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Build an empty block expression.</para>
            /// </remarks>
            public BlockExpr(clang.Stmt.EmptyShell Empty)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(24);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(Empty, null) ? new clang.Stmt.EmptyShell.Internal() : *(clang.Stmt.EmptyShell.Internal*) (Empty.__Instance);
                Internal.ctor_1(__Instance, arg0);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Stmt __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.BlockDecl getBlockDecl()
            {
                var __ret = Internal.getBlockDecl_1(__Instance);
                clang.BlockDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.BlockDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.BlockDecl) clang.BlockDecl.NativeToManagedMap[__ret];
                else clang.BlockDecl.NativeToManagedMap[__ret] = __result0 = (clang.BlockDecl) clang.BlockDecl.__CreateInstance(__ret);
                return __result0;
            }

            public void setBlockDecl(clang.BlockDecl BD)
            {
                var arg0 = ReferenceEquals(BD, null) ? global::System.IntPtr.Zero : BD.__Instance;
                Internal.setBlockDecl_0(__Instance, arg0);
            }

            public clang.SourceLocation getCaretLocation()
            {
                var __ret = Internal.getCaretLocation_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.Stmt getBody()
            {
                var __ret = Internal.getBody_1(__Instance);
                clang.Stmt __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Stmt.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Stmt) clang.Stmt.NativeToManagedMap[__ret];
                else __result0 = clang.Stmt.__CreateInstance(__ret);
                return __result0;
            }

            public clang.SourceLocation getLocStart()
            {
                var __ret = Internal.getLocStart_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLocEnd()
            {
                var __ret = Internal.getLocEnd_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>getFunctionType - Return the underlying function type for this
            /// block.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getFunctionType - Return the underlying function type for
            /// this block.</para>
            /// </remarks>
            public clang.FunctionProtoType getFunctionType()
            {
                var __ret = Internal.getFunctionType_0(__Instance);
                clang.FunctionProtoType __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.FunctionProtoType.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.FunctionProtoType) clang.FunctionProtoType.NativeToManagedMap[__ret];
                else __result0 = clang.FunctionProtoType.__CreateInstance(__ret);
                return __result0;
            }

            public clang.StmtRange children()
            {
                var __ret = new clang.StmtRange.Internal();
                Internal.children_0(new IntPtr(&__ret), __Instance);
                return clang.StmtRange.__CreateInstance(__ret);
            }

            public static bool classof(clang.Stmt T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }

            protected clang.BlockDecl TheBlock
            {
                get
                {
                    clang.BlockDecl __result0;
                    if (((Internal*) __Instance)->TheBlock == IntPtr.Zero) __result0 = null;
                    else if (clang.BlockDecl.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->TheBlock))
                        __result0 = (clang.BlockDecl) clang.BlockDecl.NativeToManagedMap[((Internal*) __Instance)->TheBlock];
                    else clang.BlockDecl.NativeToManagedMap[((Internal*) __Instance)->TheBlock] = __result0 = (clang.BlockDecl) clang.BlockDecl.__CreateInstance(((Internal*) __Instance)->TheBlock);
                    return __result0;
                }

                set
                {
                    ((Internal*) __Instance)->TheBlock = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                }
            }
        }

        /// <summary>
        /// <para>AsTypeExpr - Clang builtin function __builtin_astype [OpenCL
        /// 6.2.4.2] This AST node provides support for reinterpreting a type to
        /// another type of the same size.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// AsTypeExpr - Clang builtin function __builtin_astype [OpenCL
        /// 6.2.4.2]</para>
        /// <para>/// This AST node provides support for reinterpreting a type to
        /// another</para>
        /// <para>/// type of the same size.</para>
        /// </remarks>
        public unsafe partial class AsTypeExpr : clang.Expr, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 32)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                internal clang.Stmt._.Internal __;

                [FieldOffset(8)]
                public clang.QualType.Internal TR;

                [FieldOffset(16)]
                public global::System.IntPtr SrcExpr;

                [FieldOffset(24)]
                public clang.SourceLocation.Internal BuiltinLoc;

                [FieldOffset(28)]
                public clang.SourceLocation.Internal RParenLoc;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10AsTypeExprC2EPNS_4ExprENS_8QualTypeENS_13ExprValueKindENS_14ExprObjectKindENS_14SourceLocationES6_")]
                internal static extern void ctor_1(global::System.IntPtr instance, global::System.IntPtr SrcExpr, clang.QualType.Internal DstType, clang.ExprValueKind VK, clang.ExprObjectKind OK, clang.SourceLocation.Internal BuiltinLoc, clang.SourceLocation.Internal RParenLoc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10AsTypeExprC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10AsTypeExpr10getSrcExprEv")]
                internal static extern global::System.IntPtr getSrcExpr_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10AsTypeExpr13getBuiltinLocEv")]
                internal static extern clang.SourceLocation.Internal getBuiltinLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10AsTypeExpr12getRParenLocEv")]
                internal static extern clang.SourceLocation.Internal getRParenLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10AsTypeExpr11getLocStartEv")]
                internal static extern clang.SourceLocation.Internal getLocStart_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10AsTypeExpr9getLocEndEv")]
                internal static extern clang.SourceLocation.Internal getLocEnd_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10AsTypeExpr7classofEPKNS_4StmtE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10AsTypeExpr8childrenEv")]
                internal static extern void children_0(global::System.IntPtr @return, global::System.IntPtr instance);
            }

            private readonly bool __ownsNativeInstance;

            public static new AsTypeExpr __CreateInstance(global::System.IntPtr native)
            {
                return new AsTypeExpr((AsTypeExpr.Internal*) native);
            }

            public static AsTypeExpr __CreateInstance(AsTypeExpr.Internal native)
            {
                return new AsTypeExpr(native);
            }

            private static AsTypeExpr.Internal* __CopyValue(AsTypeExpr.Internal native)
            {
                var ret = (AsTypeExpr.Internal*) Marshal.AllocHGlobal(32);
                *ret = native;
                return ret;
            }

            private AsTypeExpr(AsTypeExpr.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected AsTypeExpr(AsTypeExpr.Internal* native, bool isInternalImpl = false)
                : base((clang.Expr.Internal*) native)
            {
            }

            public AsTypeExpr(clang.Expr SrcExpr, clang.QualType DstType, clang.ExprValueKind VK, clang.ExprObjectKind OK, clang.SourceLocation BuiltinLoc, clang.SourceLocation RParenLoc)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(32);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(SrcExpr, null) ? global::System.IntPtr.Zero : SrcExpr.__Instance;
                var arg1 = ReferenceEquals(DstType, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (DstType.__Instance);
                var arg2 = VK;
                var arg3 = OK;
                var arg4 = ReferenceEquals(BuiltinLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (BuiltinLoc.__Instance);
                var arg5 = ReferenceEquals(RParenLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (RParenLoc.__Instance);
                Internal.ctor_1(__Instance, arg0, arg1, arg2, arg3, arg4, arg5);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Stmt __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            /// <summary>
            /// <para>getSrcExpr - Return the Expr to be converted.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getSrcExpr - Return the Expr to be converted.</para>
            /// </remarks>
            public clang.Expr getSrcExpr()
            {
                var __ret = Internal.getSrcExpr_0(__Instance);
                clang.Expr __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Expr.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Expr) clang.Expr.NativeToManagedMap[__ret];
                else __result0 = clang.Expr.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>getBuiltinLoc - Return the location of the __builtin_astype
            /// token.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getBuiltinLoc - Return the location of the __builtin_astype
            /// token.</para>
            /// </remarks>
            public clang.SourceLocation getBuiltinLoc()
            {
                var __ret = Internal.getBuiltinLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>getRParenLoc - Return the location of final right
            /// parenthesis.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getRParenLoc - Return the location of final right
            /// parenthesis.</para>
            /// </remarks>
            public clang.SourceLocation getRParenLoc()
            {
                var __ret = Internal.getRParenLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLocStart()
            {
                var __ret = Internal.getLocStart_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLocEnd()
            {
                var __ret = Internal.getLocEnd_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.StmtRange children()
            {
                var __ret = new clang.StmtRange.Internal();
                Internal.children_0(new IntPtr(&__ret), __Instance);
                return clang.StmtRange.__CreateInstance(__ret);
            }

            public static bool classof(clang.Stmt T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>PseudoObjectExpr - An expression which accesses a pseudo-object
        /// l-value. A pseudo-object is an abstract object, accesses to which are
        /// translated to calls. The pseudo-object expression has a syntactic form,
        /// which shows how the expression was actually written in the source code, and
        /// a semantic form, which is a series of expressions to be executed in order
        /// which detail how the operation is actually evaluated. Optionally, one of
        /// the semantic forms may also provide a result value for the
        /// expression.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// PseudoObjectExpr - An expression which accesses a
        /// pseudo-object</para>
        /// <para>/// l-value.  A pseudo-object is an abstract object, accesses to
        /// which</para>
        /// <para>/// are translated to calls.  The pseudo-object expression has
        /// a</para>
        /// <para>/// syntactic form, which shows how the expression was
        /// actually</para>
        /// <para>/// written in the source code, and a semantic form, which is a
        /// series</para>
        /// <para>/// of expressions to be executed in order which detail how
        /// the</para>
        /// <para>/// operation is actually evaluated.  Optionally, one of the
        /// semantic</para>
        /// <para>/// forms may also provide a result value for the
        /// expression.</para>
        /// <para>///</para>
        /// <para>/// If any of the semantic-form expressions is an
        /// OpaqueValueExpr,</para>
        /// <para>/// that OVE is required to have a source expression, and it is
        /// bound</para>
        /// <para>/// to the result of that source expression.  Such OVEs may
        /// appear</para>
        /// <para>/// only in subsequent semantic-form expressions and as</para>
        /// <para>/// sub-expressions of the syntactic form.</para>
        /// <para>///</para>
        /// <para>/// PseudoObjectExpr should be used only when an operation can
        /// be</para>
        /// <para>/// usefully described in terms of fairly simple rewrite rules
        /// on</para>
        /// <para>/// objects and functions that are meant to be used by
        /// end-developers.</para>
        /// <para>/// For example, under the Itanium ABI, dynamic casts are
        /// implemented</para>
        /// <para>/// as a call to a runtime function called __dynamic_cast; using
        /// this</para>
        /// <para>/// class to describe that would be inappropriate because that
        /// call is</para>
        /// <para>/// not really part of the user-visible semantics, and instead
        /// the</para>
        /// <para>/// cast is properly reflected in the AST and IR-generation has
        /// been</para>
        /// <para>/// taught to generate the call as necessary.  In contrast,
        /// an</para>
        /// <para>/// Objective-C property access is semantically defined to
        /// be</para>
        /// <para>/// equivalent to a particular message send, and this is very
        /// much</para>
        /// <para>/// part of the user model.  The name of this class encourages
        /// this</para>
        /// <para>/// modelling design.</para>
        /// </remarks>
        public unsafe partial class PseudoObjectExpr : clang.Expr, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                internal clang.Stmt._.Internal __;

                [FieldOffset(8)]
                public clang.QualType.Internal TR;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16PseudoObjectExprC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16PseudoObjectExpr16getSyntacticFormEv")]
                internal static extern global::System.IntPtr getSyntacticForm_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang16PseudoObjectExpr18getResultExprIndexEv")]
                internal static extern uint getResultExprIndex_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16PseudoObjectExpr13getResultExprEv")]
                internal static extern global::System.IntPtr getResultExpr_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang16PseudoObjectExpr19getNumSemanticExprsEv")]
                internal static extern uint getNumSemanticExprs_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16PseudoObjectExpr15semantics_beginEv")]
                internal static extern global::System.IntPtr semantics_begin_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16PseudoObjectExpr13semantics_endEv")]
                internal static extern global::System.IntPtr semantics_end_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16PseudoObjectExpr15getSemanticExprEj")]
                internal static extern global::System.IntPtr getSemanticExpr_0(global::System.IntPtr instance, uint index);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang16PseudoObjectExpr10getExprLocEv")]
                internal static extern clang.SourceLocation.Internal getExprLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang16PseudoObjectExpr11getLocStartEv")]
                internal static extern clang.SourceLocation.Internal getLocStart_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang16PseudoObjectExpr9getLocEndEv")]
                internal static extern clang.SourceLocation.Internal getLocEnd_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16PseudoObjectExpr8childrenEv")]
                internal static extern void children_0(global::System.IntPtr @return, global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16PseudoObjectExpr7classofEPKNS_4StmtE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);
            }

            /// <summary>
            /// <para>NoResult - A value for the result index indicating that there is
            /// no semantic result.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// NoResult - A value for the result index indicating that there
            /// is</para>
            /// <para>  /// no semantic result.</para>
            /// </remarks>
            public enum NoResult : uint
            {
                NoResult = 4294967295
            }

            private readonly bool __ownsNativeInstance;

            public static new PseudoObjectExpr __CreateInstance(global::System.IntPtr native)
            {
                return new PseudoObjectExpr((PseudoObjectExpr.Internal*) native);
            }

            public static PseudoObjectExpr __CreateInstance(PseudoObjectExpr.Internal native)
            {
                return new PseudoObjectExpr(native);
            }

            private static PseudoObjectExpr.Internal* __CopyValue(PseudoObjectExpr.Internal native)
            {
                var ret = (PseudoObjectExpr.Internal*) Marshal.AllocHGlobal(16);
                *ret = native;
                return ret;
            }

            private PseudoObjectExpr(PseudoObjectExpr.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected PseudoObjectExpr(PseudoObjectExpr.Internal* native, bool isInternalImpl = false)
                : base((clang.Expr.Internal*) native)
            {
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Stmt __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            /// <summary>
            /// <para>Return the syntactic form of this expression, i.e. the expression
            /// it actually looks like. Likely to be expressed in terms of OpaqueValueExprs
            /// bound in the semantic form.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Return the syntactic form of this expression, i.e. the</para>
            /// <para>  /// expression it actually looks like.  Likely to be expressed
            /// in</para>
            /// <para>  /// terms of OpaqueValueExprs bound in the semantic
            /// form.</para>
            /// </remarks>
            public clang.Expr getSyntacticForm()
            {
                var __ret = Internal.getSyntacticForm_0(__Instance);
                clang.Expr __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Expr.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Expr) clang.Expr.NativeToManagedMap[__ret];
                else __result0 = clang.Expr.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Return the index of the result-bearing expression into the
            /// semantics expressions, or PseudoObjectExpr::NoResult if there is
            /// none.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Return the index of the result-bearing expression into the
            /// semantics</para>
            /// <para>  /// expressions, or PseudoObjectExpr::NoResult if there is
            /// none.</para>
            /// </remarks>
            public uint getResultExprIndex()
            {
                var __ret = Internal.getResultExprIndex_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Return the result-bearing expression, or null if there is
            /// none.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Return the result-bearing expression, or null if there is
            /// none.</para>
            /// </remarks>
            public clang.Expr getResultExpr()
            {
                var __ret = Internal.getResultExpr_0(__Instance);
                clang.Expr __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Expr.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Expr) clang.Expr.NativeToManagedMap[__ret];
                else __result0 = clang.Expr.__CreateInstance(__ret);
                return __result0;
            }

            public uint getNumSemanticExprs()
            {
                var __ret = Internal.getNumSemanticExprs_0(__Instance);
                return __ret;
            }

            public clang.Expr semantics_begin()
            {
                var __ret = Internal.semantics_begin_0(__Instance);
                clang.Expr __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Expr.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Expr) clang.Expr.NativeToManagedMap[__ret];
                else __result0 = clang.Expr.__CreateInstance(__ret);
                return __result0;
            }

            public clang.Expr semantics_end()
            {
                var __ret = Internal.semantics_end_0(__Instance);
                clang.Expr __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Expr.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Expr) clang.Expr.NativeToManagedMap[__ret];
                else __result0 = clang.Expr.__CreateInstance(__ret);
                return __result0;
            }

            public clang.Expr getSemanticExpr(uint index)
            {
                var __ret = Internal.getSemanticExpr_0(__Instance, index);
                clang.Expr __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Expr.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Expr) clang.Expr.NativeToManagedMap[__ret];
                else __result0 = clang.Expr.__CreateInstance(__ret);
                return __result0;
            }

            public clang.SourceLocation getExprLoc()
            {
                var __ret = Internal.getExprLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLocStart()
            {
                var __ret = Internal.getLocStart_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLocEnd()
            {
                var __ret = Internal.getLocEnd_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.StmtRange children()
            {
                var __ret = new clang.StmtRange.Internal();
                Internal.children_0(new IntPtr(&__ret), __Instance);
                return clang.StmtRange.__CreateInstance(__ret);
            }

            public static bool classof(clang.Stmt T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>AtomicExpr - Variadic atomic builtins: __atomic_exchange,
        /// __atomic_fetch_*, __atomic_load, __atomic_store, and
        /// __atomic_compare_exchange_*, for the similarly-named C++11 instructions,
        /// and __c11 variants for &lt;stdatomic.h&gt;. All of these instructions take
        /// one primary pointer and at least one memory order.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// AtomicExpr - Variadic atomic builtins: __atomic_exchange,
        /// __atomic_fetch_*,</para>
        /// <para>/// __atomic_load, __atomic_store, and
        /// __atomic_compare_exchange_*, for the</para>
        /// <para>/// similarly-named C++11 instructions, and __c11 variants for
        /// &lt;stdatomic.h&gt;.</para>
        /// <para>/// All of these instructions take one primary pointer and at
        /// least one memory</para>
        /// <para>/// order.</para>
        /// </remarks>
        public unsafe partial class AtomicExpr : clang.Expr, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 80)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                internal clang.Stmt._.Internal __;

                [FieldOffset(8)]
                public clang.QualType.Internal TR;

                [FieldOffset(16)]
                public fixed global::System.IntPtr SubExprs[6];

                [FieldOffset(64)]
                public uint NumSubExprs;

                [FieldOffset(68)]
                public clang.SourceLocation.Internal BuiltinLoc;

                [FieldOffset(72)]
                public clang.SourceLocation.Internal RParenLoc;

                [FieldOffset(76)]
                public clang.AtomicExpr.AtomicOp Op;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10AtomicExprC2ENS_4Stmt10EmptyShellE")]
                internal static extern void ctor_1(global::System.IntPtr instance, clang.Stmt.EmptyShell.Internal Empty);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10AtomicExprC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10AtomicExpr14getNumSubExprsENS0_8AtomicOpE")]
                internal static extern uint getNumSubExprs_0(clang.AtomicExpr.AtomicOp Op);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10AtomicExpr6getPtrEv")]
                internal static extern global::System.IntPtr getPtr_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10AtomicExpr8getOrderEv")]
                internal static extern global::System.IntPtr getOrder_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10AtomicExpr7getVal1Ev")]
                internal static extern global::System.IntPtr getVal1_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10AtomicExpr12getOrderFailEv")]
                internal static extern global::System.IntPtr getOrderFail_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10AtomicExpr7getVal2Ev")]
                internal static extern global::System.IntPtr getVal2_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10AtomicExpr7getWeakEv")]
                internal static extern global::System.IntPtr getWeak_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10AtomicExpr5getOpEv")]
                internal static extern clang.AtomicExpr.AtomicOp getOp_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10AtomicExpr14getNumSubExprsEv")]
                internal static extern uint getNumSubExprs_1(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10AtomicExpr11getSubExprsEv")]
                internal static extern global::System.IntPtr getSubExprs_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10AtomicExpr10isVolatileEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isVolatile_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10AtomicExpr9isCmpXChgEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isCmpXChg_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10AtomicExpr13getBuiltinLocEv")]
                internal static extern clang.SourceLocation.Internal getBuiltinLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10AtomicExpr12getRParenLocEv")]
                internal static extern clang.SourceLocation.Internal getRParenLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10AtomicExpr11getLocStartEv")]
                internal static extern clang.SourceLocation.Internal getLocStart_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10AtomicExpr9getLocEndEv")]
                internal static extern clang.SourceLocation.Internal getLocEnd_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10AtomicExpr7classofEPKNS_4StmtE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10AtomicExpr8childrenEv")]
                internal static extern void children_0(global::System.IntPtr @return, global::System.IntPtr instance);
            }

            public enum AtomicOp : uint
            {
                AO__c11_atomic_init = 0,
                AO__c11_atomic_load = 1,
                AO__c11_atomic_store = 2,
                AO__c11_atomic_exchange = 3,
                AO__c11_atomic_compare_exchange_strong = 4,
                AO__c11_atomic_compare_exchange_weak = 5,
                AO__c11_atomic_fetch_add = 6,
                AO__c11_atomic_fetch_sub = 7,
                AO__c11_atomic_fetch_and = 8,
                AO__c11_atomic_fetch_or = 9,
                AO__c11_atomic_fetch_xor = 10,
                AO__atomic_load = 11,
                AO__atomic_load_n = 12,
                AO__atomic_store = 13,
                AO__atomic_store_n = 14,
                AO__atomic_exchange = 15,
                AO__atomic_exchange_n = 16,
                AO__atomic_compare_exchange = 17,
                AO__atomic_compare_exchange_n = 18,
                AO__atomic_fetch_add = 19,
                AO__atomic_fetch_sub = 20,
                AO__atomic_fetch_and = 21,
                AO__atomic_fetch_or = 22,
                AO__atomic_fetch_xor = 23,
                AO__atomic_fetch_nand = 24,
                AO__atomic_add_fetch = 25,
                AO__atomic_sub_fetch = 26,
                AO__atomic_and_fetch = 27,
                AO__atomic_or_fetch = 28,
                AO__atomic_xor_fetch = 29,
                AO__atomic_nand_fetch = 30,
                BI_First = 0
            }

            public enum AtomicOrderingKind : uint
            {
                AO_ABI_memory_order_relaxed = 0,
                AO_ABI_memory_order_consume = 1,
                AO_ABI_memory_order_acquire = 2,
                AO_ABI_memory_order_release = 3,
                AO_ABI_memory_order_acq_rel = 4,
                AO_ABI_memory_order_seq_cst = 5
            }

            private readonly bool __ownsNativeInstance;

            public static new AtomicExpr __CreateInstance(global::System.IntPtr native)
            {
                return new AtomicExpr((AtomicExpr.Internal*) native);
            }

            public static AtomicExpr __CreateInstance(AtomicExpr.Internal native)
            {
                return new AtomicExpr(native);
            }

            private static AtomicExpr.Internal* __CopyValue(AtomicExpr.Internal native)
            {
                var ret = (AtomicExpr.Internal*) Marshal.AllocHGlobal(80);
                *ret = native;
                return ret;
            }

            private AtomicExpr(AtomicExpr.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected AtomicExpr(AtomicExpr.Internal* native, bool isInternalImpl = false)
                : base((clang.Expr.Internal*) native)
            {
            }

            /// <summary>
            /// <para>Build an empty AtomicExpr.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Build an empty AtomicExpr.</para>
            /// </remarks>
            public AtomicExpr(clang.Stmt.EmptyShell Empty)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(80);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(Empty, null) ? new clang.Stmt.EmptyShell.Internal() : *(clang.Stmt.EmptyShell.Internal*) (Empty.__Instance);
                Internal.ctor_1(__Instance, arg0);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Stmt __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.Expr getPtr()
            {
                var __ret = Internal.getPtr_0(__Instance);
                clang.Expr __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Expr.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Expr) clang.Expr.NativeToManagedMap[__ret];
                else __result0 = clang.Expr.__CreateInstance(__ret);
                return __result0;
            }

            public clang.Expr getOrder()
            {
                var __ret = Internal.getOrder_0(__Instance);
                clang.Expr __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Expr.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Expr) clang.Expr.NativeToManagedMap[__ret];
                else __result0 = clang.Expr.__CreateInstance(__ret);
                return __result0;
            }

            public clang.Expr getVal1()
            {
                var __ret = Internal.getVal1_0(__Instance);
                clang.Expr __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Expr.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Expr) clang.Expr.NativeToManagedMap[__ret];
                else __result0 = clang.Expr.__CreateInstance(__ret);
                return __result0;
            }

            public clang.Expr getOrderFail()
            {
                var __ret = Internal.getOrderFail_0(__Instance);
                clang.Expr __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Expr.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Expr) clang.Expr.NativeToManagedMap[__ret];
                else __result0 = clang.Expr.__CreateInstance(__ret);
                return __result0;
            }

            public clang.Expr getVal2()
            {
                var __ret = Internal.getVal2_0(__Instance);
                clang.Expr __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Expr.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Expr) clang.Expr.NativeToManagedMap[__ret];
                else __result0 = clang.Expr.__CreateInstance(__ret);
                return __result0;
            }

            public clang.Expr getWeak()
            {
                var __ret = Internal.getWeak_0(__Instance);
                clang.Expr __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Expr.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Expr) clang.Expr.NativeToManagedMap[__ret];
                else __result0 = clang.Expr.__CreateInstance(__ret);
                return __result0;
            }

            public clang.AtomicExpr.AtomicOp getOp()
            {
                var __ret = Internal.getOp_0(__Instance);
                return __ret;
            }

            public uint getNumSubExprs()
            {
                var __ret = Internal.getNumSubExprs_1(__Instance);
                return __ret;
            }

            public clang.Expr getSubExprs()
            {
                var __ret = Internal.getSubExprs_0(__Instance);
                clang.Expr __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Expr.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Expr) clang.Expr.NativeToManagedMap[__ret];
                else __result0 = clang.Expr.__CreateInstance(__ret);
                return __result0;
            }

            public bool isVolatile()
            {
                var __ret = Internal.isVolatile_0(__Instance);
                return __ret;
            }

            public bool isCmpXChg()
            {
                var __ret = Internal.isCmpXChg_0(__Instance);
                return __ret;
            }

            public clang.SourceLocation getBuiltinLoc()
            {
                var __ret = Internal.getBuiltinLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getRParenLoc()
            {
                var __ret = Internal.getRParenLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLocStart()
            {
                var __ret = Internal.getLocStart_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLocEnd()
            {
                var __ret = Internal.getLocEnd_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.StmtRange children()
            {
                var __ret = new clang.StmtRange.Internal();
                Internal.children_0(new IntPtr(&__ret), __Instance);
                return clang.StmtRange.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Determine the number of arguments the specified atomic builtin
            /// should have.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine the number of arguments the specified atomic
            /// builtin</para>
            /// <para>  /// should have.</para>
            /// </remarks>
            public static uint getNumSubExprs(clang.AtomicExpr.AtomicOp Op)
            {
                var arg0 = Op;
                var __ret = Internal.getNumSubExprs_0(arg0);
                return __ret;
            }

            public static bool classof(clang.Stmt T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>TypoExpr - Internal placeholder for expressions where typo
        /// correction still needs to be performed and/or an error diagnostic
        /// emitted.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// TypoExpr - Internal placeholder for expressions where typo
        /// correction</para>
        /// <para>/// still needs to be performed and/or an error diagnostic
        /// emitted.</para>
        /// </remarks>
        public unsafe partial class TypoExpr : clang.Expr, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                internal clang.Stmt._.Internal __;

                [FieldOffset(8)]
                public clang.QualType.Internal TR;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8TypoExprC2ENS_8QualTypeE")]
                internal static extern void ctor_0(global::System.IntPtr instance, clang.QualType.Internal T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8TypoExprC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8TypoExpr8childrenEv")]
                internal static extern void children_0(global::System.IntPtr @return, global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8TypoExpr11getLocStartEv")]
                internal static extern clang.SourceLocation.Internal getLocStart_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8TypoExpr9getLocEndEv")]
                internal static extern clang.SourceLocation.Internal getLocEnd_0(global::System.IntPtr instance);
            }

            private readonly bool __ownsNativeInstance;

            public static new TypoExpr __CreateInstance(global::System.IntPtr native)
            {
                return new TypoExpr((TypoExpr.Internal*) native);
            }

            public static TypoExpr __CreateInstance(TypoExpr.Internal native)
            {
                return new TypoExpr(native);
            }

            private static TypoExpr.Internal* __CopyValue(TypoExpr.Internal native)
            {
                var ret = (TypoExpr.Internal*) Marshal.AllocHGlobal(16);
                *ret = native;
                return ret;
            }

            private TypoExpr(TypoExpr.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected TypoExpr(TypoExpr.Internal* native, bool isInternalImpl = false)
                : base((clang.Expr.Internal*) native)
            {
            }

            public TypoExpr(clang.QualType T)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(16);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(T, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (T.__Instance);
                Internal.ctor_0(__Instance, arg0);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Stmt __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.StmtRange children()
            {
                var __ret = new clang.StmtRange.Internal();
                Internal.children_0(new IntPtr(&__ret), __Instance);
                return clang.StmtRange.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLocStart()
            {
                var __ret = Internal.getLocStart_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLocEnd()
            {
                var __ret = Internal.getLocEnd_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }
        }
    }
}
