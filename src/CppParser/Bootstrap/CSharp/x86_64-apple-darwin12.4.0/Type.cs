//----------------------------------------------------------------------------
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
//----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace CppSharp
{
    public unsafe partial class Type
    {
        public partial struct Internal
        {
        }
    }

    namespace clang
    {
        /// <summary>
        /// <para>The kind of a tag type.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief The kind of a tag type.</para>
        /// </remarks>
        public enum TagTypeKind : uint
        {
            /// <summary>The "struct" keyword.</summary>
            TTK_Struct = 0,
            /// <summary>The "__interface" keyword.</summary>
            TTK_Interface = 1,
            /// <summary>The "union" keyword.</summary>
            TTK_Union = 2,
            /// <summary>The "class" keyword.</summary>
            TTK_Class = 3,
            /// <summary>The "enum" keyword.</summary>
            TTK_Enum = 4
        }

        /// <summary>
        /// <para>The kind of C++0x ref-qualifier associated with a function type,
        /// which determines whether a member function's &quot;this&quot; object can be
        /// an lvalue, rvalue, or neither.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief The kind of C++0x ref-qualifier associated with a
        /// function type,</para>
        /// <para>/// which determines whether a member function's &quot;this&quot;
        /// object can be an</para>
        /// <para>/// lvalue, rvalue, or neither.</para>
        /// </remarks>
        public enum RefQualifierKind : uint
        {
            /// <summary>No ref-qualifier was provided.</summary>
            RQ_None = 0,
            /// <summary>An lvalue ref-qualifier was provided ( &).</summary>
            RQ_LValue = 1,
            /// <summary>An rvalue ref-qualifier was provided ( &&).</summary>
            RQ_RValue = 2
        }

        /// <summary>
        /// <para>The elaboration keyword that precedes a qualified type name or
        /// introduces an elaborated-type-specifier.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief The elaboration keyword that precedes a qualified type
        /// name or</para>
        /// <para>/// introduces an elaborated-type-specifier.</para>
        /// </remarks>
        public enum ElaboratedTypeKeyword : uint
        {
            /// <summary>The "struct" keyword introduces the elaborated-type-specifier.</summary>
            ETK_Struct = 0,
            /// <summary>The "__interface" keyword introduces the elaborated-type-specifier.</summary>
            ETK_Interface = 1,
            /// <summary>The "union" keyword introduces the elaborated-type-specifier.</summary>
            ETK_Union = 2,
            /// <summary>The "class" keyword introduces the elaborated-type-specifier.</summary>
            ETK_Class = 3,
            /// <summary>The "enum" keyword introduces the elaborated-type-specifier.</summary>
            ETK_Enum = 4,
            /// <summary>The "typename" keyword precedes the qualified type name, e.g., typename T::type.</summary>
            ETK_Typename = 5,
            /// <summary>No keyword precedes the qualified type name.</summary>
            ETK_None = 6
        }

        [Flags]
        public enum TypeAlignment : uint
        {
            TypeAlignmentInBits = 4,
            TypeAlignment = 16
        }

        public unsafe static partial class ArrayType_cannot_be_used_with_getAs
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct Internal
            {
            }
        }

        /// <summary>
        /// <para>Qualifiers - The collection of all-type qualifiers we support.
        /// Clang supports five independent qualifiers: * C99: const, volatile, and
        /// restrict * Embedded C (TR18037): address spaces * Objective C: the GC
        /// attributes (none, weak, or strong)</para>
        /// </summary>
        /// <remarks>
        /// <para>/// Qualifiers - The collection of all-type qualifiers we
        /// support.</para>
        /// <para>/// Clang supports five independent qualifiers:</para>
        /// <para>/// * C99: const, volatile, and restrict</para>
        /// <para>/// * Embedded C (TR18037): address spaces</para>
        /// <para>/// * Objective C: the GC attributes (none, weak, or
        /// strong)</para>
        /// </remarks>
        public unsafe partial class Qualifiers : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 4)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public uint Mask;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10QualifiersC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10QualifiersC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10Qualifiers22removeCommonQualifiersERS0_S1_")]
                internal static extern clang.Qualifiers.Internal removeCommonQualifiers_0(global::System.IntPtr L, global::System.IntPtr R);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10Qualifiers12fromFastMaskEj")]
                internal static extern clang.Qualifiers.Internal fromFastMask_0(uint Mask);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10Qualifiers11fromCVRMaskEj")]
                internal static extern clang.Qualifiers.Internal fromCVRMask_0(uint CVR);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10Qualifiers15fromOpaqueValueEj")]
                internal static extern clang.Qualifiers.Internal fromOpaqueValue_0(uint opaque);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10Qualifiers16getAsOpaqueValueEv")]
                internal static extern uint getAsOpaqueValue_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10Qualifiers8hasConstEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasConst_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10Qualifiers8setConstEb")]
                internal static extern void setConst_0(global::System.IntPtr instance, bool flag);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10Qualifiers11removeConstEv")]
                internal static extern void removeConst_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10Qualifiers8addConstEv")]
                internal static extern void addConst_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10Qualifiers11hasVolatileEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasVolatile_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10Qualifiers11setVolatileEb")]
                internal static extern void setVolatile_0(global::System.IntPtr instance, bool flag);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10Qualifiers14removeVolatileEv")]
                internal static extern void removeVolatile_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10Qualifiers11addVolatileEv")]
                internal static extern void addVolatile_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10Qualifiers11hasRestrictEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasRestrict_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10Qualifiers11setRestrictEb")]
                internal static extern void setRestrict_0(global::System.IntPtr instance, bool flag);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10Qualifiers14removeRestrictEv")]
                internal static extern void removeRestrict_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10Qualifiers11addRestrictEv")]
                internal static extern void addRestrict_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10Qualifiers16hasCVRQualifiersEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasCVRQualifiers_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10Qualifiers16getCVRQualifiersEv")]
                internal static extern uint getCVRQualifiers_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10Qualifiers16setCVRQualifiersEj")]
                internal static extern void setCVRQualifiers_0(global::System.IntPtr instance, uint mask);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10Qualifiers19removeCVRQualifiersEj")]
                internal static extern void removeCVRQualifiers_0(global::System.IntPtr instance, uint mask);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10Qualifiers19removeCVRQualifiersEv")]
                internal static extern void removeCVRQualifiers_1(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10Qualifiers16addCVRQualifiersEj")]
                internal static extern void addCVRQualifiers_0(global::System.IntPtr instance, uint mask);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10Qualifiers13hasObjCGCAttrEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasObjCGCAttr_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10Qualifiers13getObjCGCAttrEv")]
                internal static extern clang.Qualifiers.GC getObjCGCAttr_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10Qualifiers13setObjCGCAttrENS0_2GCE")]
                internal static extern void setObjCGCAttr_0(global::System.IntPtr instance, clang.Qualifiers.GC type);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10Qualifiers16removeObjCGCAttrEv")]
                internal static extern void removeObjCGCAttr_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10Qualifiers13addObjCGCAttrENS0_2GCE")]
                internal static extern void addObjCGCAttr_0(global::System.IntPtr instance, clang.Qualifiers.GC type);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10Qualifiers17withoutObjCGCAttrEv")]
                internal static extern clang.Qualifiers.Internal withoutObjCGCAttr_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10Qualifiers19withoutObjCLifetimeEv")]
                internal static extern clang.Qualifiers.Internal withoutObjCLifetime_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10Qualifiers15hasObjCLifetimeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasObjCLifetime_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10Qualifiers15getObjCLifetimeEv")]
                internal static extern clang.Qualifiers.ObjCLifetime getObjCLifetime_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10Qualifiers15setObjCLifetimeENS0_12ObjCLifetimeE")]
                internal static extern void setObjCLifetime_0(global::System.IntPtr instance, clang.Qualifiers.ObjCLifetime type);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10Qualifiers18removeObjCLifetimeEv")]
                internal static extern void removeObjCLifetime_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10Qualifiers15addObjCLifetimeENS0_12ObjCLifetimeE")]
                internal static extern void addObjCLifetime_0(global::System.IntPtr instance, clang.Qualifiers.ObjCLifetime type);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10Qualifiers25hasNonTrivialObjCLifetimeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasNonTrivialObjCLifetime_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10Qualifiers27hasStrongOrWeakObjCLifetimeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasStrongOrWeakObjCLifetime_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10Qualifiers15hasAddressSpaceEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasAddressSpace_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10Qualifiers15getAddressSpaceEv")]
                internal static extern uint getAddressSpace_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10Qualifiers15setAddressSpaceEj")]
                internal static extern void setAddressSpace_0(global::System.IntPtr instance, uint space);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10Qualifiers18removeAddressSpaceEv")]
                internal static extern void removeAddressSpace_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10Qualifiers15addAddressSpaceEj")]
                internal static extern void addAddressSpace_0(global::System.IntPtr instance, uint space);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10Qualifiers17hasFastQualifiersEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasFastQualifiers_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10Qualifiers17getFastQualifiersEv")]
                internal static extern uint getFastQualifiers_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10Qualifiers17setFastQualifiersEj")]
                internal static extern void setFastQualifiers_0(global::System.IntPtr instance, uint mask);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10Qualifiers20removeFastQualifiersEj")]
                internal static extern void removeFastQualifiers_0(global::System.IntPtr instance, uint mask);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10Qualifiers20removeFastQualifiersEv")]
                internal static extern void removeFastQualifiers_1(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10Qualifiers17addFastQualifiersEj")]
                internal static extern void addFastQualifiers_0(global::System.IntPtr instance, uint mask);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10Qualifiers20hasNonFastQualifiersEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasNonFastQualifiers_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10Qualifiers20getNonFastQualifiersEv")]
                internal static extern clang.Qualifiers.Internal getNonFastQualifiers_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10Qualifiers13hasQualifiersEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasQualifiers_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10Qualifiers5emptyEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool empty_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10Qualifiers13addQualifiersES0_")]
                internal static extern void addQualifiers_0(global::System.IntPtr instance, clang.Qualifiers.Internal Q);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10Qualifiers16removeQualifiersES0_")]
                internal static extern void removeQualifiers_0(global::System.IntPtr instance, clang.Qualifiers.Internal Q);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10Qualifiers23addConsistentQualifiersES0_")]
                internal static extern void addConsistentQualifiers_0(global::System.IntPtr instance, clang.Qualifiers.Internal qs);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10Qualifiers24isAddressSpaceSupersetOfES0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isAddressSpaceSupersetOf_0(global::System.IntPtr instance, clang.Qualifiers.Internal other);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10Qualifiers18compatiblyIncludesES0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool compatiblyIncludes_0(global::System.IntPtr instance, clang.Qualifiers.Internal other);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10Qualifiers30compatiblyIncludesObjCLifetimeES0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool compatiblyIncludesObjCLifetime_0(global::System.IntPtr instance, clang.Qualifiers.Internal other);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10Qualifiers18isStrictSupersetOfES0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isStrictSupersetOf_0(global::System.IntPtr instance, clang.Qualifiers.Internal Other);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10QualifierseqES0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorEqualEqual_0(global::System.IntPtr instance, clang.Qualifiers.Internal Other);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10QualifiersneES0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorExclaimEqual_0(global::System.IntPtr instance, clang.Qualifiers.Internal Other);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10QualifierscvbEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorConversion_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10Qualifiers18isEmptyWhenPrintedERKNS_14PrintingPolicyE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isEmptyWhenPrinted_0(global::System.IntPtr instance, global::System.IntPtr Policy);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10Qualifiers5printERN4llvm11raw_ostreamERKNS_14PrintingPolicyEb")]
                internal static extern void print_0(global::System.IntPtr instance, global::System.IntPtr OS, global::System.IntPtr Policy, bool appendSpaceIfNonEmpty);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10Qualifiers7ProfileERN4llvm16FoldingSetNodeIDE")]
                internal static extern void Profile_0(global::System.IntPtr instance, global::System.IntPtr ID);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clangplENS_10QualifiersES0_")]
                internal static extern clang.Qualifiers.Internal OperatorPlus_0(clang.Qualifiers.Internal L, clang.Qualifiers.Internal R);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clangmiENS_10QualifiersES0_")]
                internal static extern clang.Qualifiers.Internal OperatorMinus_0(clang.Qualifiers.Internal L, clang.Qualifiers.Internal R);
            }

            public enum TQ : uint
            {
                Const = 0x1,
                Restrict = 0x2,
                Volatile = 0x4,
                CVRMask = 7
            }

            public enum GC : uint
            {
                GCNone = 0,
                Weak = 1,
                Strong = 2
            }

            public enum ObjCLifetime : uint
            {
                /// <summary>There is no lifetime qualification on this type.</summary>
                OCL_None = 0,
                /// <summary>This object can be modified without requiring retains or releases.</summary>
                OCL_ExplicitNone = 1,
                /// <summary>Assigning into this object requires the old value to be released and the new value to be retained. The timing of the release of the old value is inexact: it may be moved to immediately after the last known point where the value is live.</summary>
                OCL_Strong = 2,
                /// <summary>Reading or writing from this object requires a barrier call.</summary>
                OCL_Weak = 3,
                /// <summary>Assigning into this object requires a lifetime extension.</summary>
                OCL_Autoreleasing = 4
            }

            public enum _0 : uint
            {
                /// <summary>The maximum supported address space number. 24 bits should be enough for anyone.</summary>
                MaxAddressSpace = 0xffffff,
                /// <summary>The width of the "fast" qualifier mask.</summary>
                FastWidth = 3,
                /// <summary>The fast qualifier mask.</summary>
                FastMask = 7
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, Qualifiers> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, Qualifiers>();

            private readonly bool __ownsNativeInstance;

            public static Qualifiers __CreateInstance(global::System.IntPtr native)
            {
                return new Qualifiers((Qualifiers.Internal*) native);
            }

            public static Qualifiers __CreateInstance(Qualifiers.Internal native)
            {
                return new Qualifiers(native);
            }

            private static Qualifiers.Internal* __CopyValue(Qualifiers.Internal native)
            {
                var ret = (Qualifiers.Internal*) Marshal.AllocHGlobal(4);
                *ret = native;
                return ret;
            }

            private Qualifiers(Qualifiers.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected Qualifiers(Qualifiers.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public Qualifiers()
            {
                __Instance = Marshal.AllocHGlobal(4);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Qualifiers __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public uint getAsOpaqueValue()
            {
                var __ret = Internal.getAsOpaqueValue_0(__Instance);
                return __ret;
            }

            public bool hasConst()
            {
                var __ret = Internal.hasConst_0(__Instance);
                return __ret;
            }

            public void setConst(bool flag)
            {
                Internal.setConst_0(__Instance, flag);
            }

            public void removeConst()
            {
                Internal.removeConst_0(__Instance);
            }

            public void addConst()
            {
                Internal.addConst_0(__Instance);
            }

            public bool hasVolatile()
            {
                var __ret = Internal.hasVolatile_0(__Instance);
                return __ret;
            }

            public void setVolatile(bool flag)
            {
                Internal.setVolatile_0(__Instance, flag);
            }

            public void removeVolatile()
            {
                Internal.removeVolatile_0(__Instance);
            }

            public void addVolatile()
            {
                Internal.addVolatile_0(__Instance);
            }

            public bool hasRestrict()
            {
                var __ret = Internal.hasRestrict_0(__Instance);
                return __ret;
            }

            public void setRestrict(bool flag)
            {
                Internal.setRestrict_0(__Instance, flag);
            }

            public void removeRestrict()
            {
                Internal.removeRestrict_0(__Instance);
            }

            public void addRestrict()
            {
                Internal.addRestrict_0(__Instance);
            }

            public bool hasCVRQualifiers()
            {
                var __ret = Internal.hasCVRQualifiers_0(__Instance);
                return __ret;
            }

            public uint getCVRQualifiers()
            {
                var __ret = Internal.getCVRQualifiers_0(__Instance);
                return __ret;
            }

            public void setCVRQualifiers(uint mask)
            {
                Internal.setCVRQualifiers_0(__Instance, mask);
            }

            public void removeCVRQualifiers(uint mask)
            {
                Internal.removeCVRQualifiers_0(__Instance, mask);
            }

            public void removeCVRQualifiers()
            {
                Internal.removeCVRQualifiers_1(__Instance);
            }

            public void addCVRQualifiers(uint mask)
            {
                Internal.addCVRQualifiers_0(__Instance, mask);
            }

            public bool hasObjCGCAttr()
            {
                var __ret = Internal.hasObjCGCAttr_0(__Instance);
                return __ret;
            }

            public clang.Qualifiers.GC getObjCGCAttr()
            {
                var __ret = Internal.getObjCGCAttr_0(__Instance);
                return __ret;
            }

            public void setObjCGCAttr(clang.Qualifiers.GC type)
            {
                var arg0 = type;
                Internal.setObjCGCAttr_0(__Instance, arg0);
            }

            public void removeObjCGCAttr()
            {
                Internal.removeObjCGCAttr_0(__Instance);
            }

            public void addObjCGCAttr(clang.Qualifiers.GC type)
            {
                var arg0 = type;
                Internal.addObjCGCAttr_0(__Instance, arg0);
            }

            public clang.Qualifiers withoutObjCGCAttr()
            {
                var __ret = Internal.withoutObjCGCAttr_0(__Instance);
                return clang.Qualifiers.__CreateInstance(__ret);
            }

            public clang.Qualifiers withoutObjCLifetime()
            {
                var __ret = Internal.withoutObjCLifetime_0(__Instance);
                return clang.Qualifiers.__CreateInstance(__ret);
            }

            public bool hasObjCLifetime()
            {
                var __ret = Internal.hasObjCLifetime_0(__Instance);
                return __ret;
            }

            public clang.Qualifiers.ObjCLifetime getObjCLifetime()
            {
                var __ret = Internal.getObjCLifetime_0(__Instance);
                return __ret;
            }

            public void setObjCLifetime(clang.Qualifiers.ObjCLifetime type)
            {
                var arg0 = type;
                Internal.setObjCLifetime_0(__Instance, arg0);
            }

            public void removeObjCLifetime()
            {
                Internal.removeObjCLifetime_0(__Instance);
            }

            public void addObjCLifetime(clang.Qualifiers.ObjCLifetime type)
            {
                var arg0 = type;
                Internal.addObjCLifetime_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>True if the lifetime is neither None or ExplicitNone.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// True if the lifetime is neither None or ExplicitNone.</para>
            /// </remarks>
            public bool hasNonTrivialObjCLifetime()
            {
                var __ret = Internal.hasNonTrivialObjCLifetime_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>True if the lifetime is either strong or weak.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// True if the lifetime is either strong or weak.</para>
            /// </remarks>
            public bool hasStrongOrWeakObjCLifetime()
            {
                var __ret = Internal.hasStrongOrWeakObjCLifetime_0(__Instance);
                return __ret;
            }

            public bool hasAddressSpace()
            {
                var __ret = Internal.hasAddressSpace_0(__Instance);
                return __ret;
            }

            public uint getAddressSpace()
            {
                var __ret = Internal.getAddressSpace_0(__Instance);
                return __ret;
            }

            public void setAddressSpace(uint space)
            {
                Internal.setAddressSpace_0(__Instance, space);
            }

            public void removeAddressSpace()
            {
                Internal.removeAddressSpace_0(__Instance);
            }

            public void addAddressSpace(uint space)
            {
                Internal.addAddressSpace_0(__Instance, space);
            }

            public bool hasFastQualifiers()
            {
                var __ret = Internal.hasFastQualifiers_0(__Instance);
                return __ret;
            }

            public uint getFastQualifiers()
            {
                var __ret = Internal.getFastQualifiers_0(__Instance);
                return __ret;
            }

            public void setFastQualifiers(uint mask)
            {
                Internal.setFastQualifiers_0(__Instance, mask);
            }

            public void removeFastQualifiers(uint mask)
            {
                Internal.removeFastQualifiers_0(__Instance, mask);
            }

            public void removeFastQualifiers()
            {
                Internal.removeFastQualifiers_1(__Instance);
            }

            public void addFastQualifiers(uint mask)
            {
                Internal.addFastQualifiers_0(__Instance, mask);
            }

            /// <summary>
            /// <para>hasNonFastQualifiers - Return true if the set contains any
            /// qualifiers which require an ExtQuals node to be allocated.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// hasNonFastQualifiers - Return true if the set contains
            /// any</para>
            /// <para>  /// qualifiers which require an ExtQuals node to be
            /// allocated.</para>
            /// </remarks>
            public bool hasNonFastQualifiers()
            {
                var __ret = Internal.hasNonFastQualifiers_0(__Instance);
                return __ret;
            }

            public clang.Qualifiers getNonFastQualifiers()
            {
                var __ret = Internal.getNonFastQualifiers_0(__Instance);
                return clang.Qualifiers.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>hasQualifiers - Return true if the set contains any
            /// qualifiers.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// hasQualifiers - Return true if the set contains any
            /// qualifiers.</para>
            /// </remarks>
            public bool hasQualifiers()
            {
                var __ret = Internal.hasQualifiers_0(__Instance);
                return __ret;
            }

            public bool empty()
            {
                var __ret = Internal.empty_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Add the qualifiers from the given set to this set.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Add the qualifiers from the given set to this
            /// set.</para>
            /// </remarks>
            public void addQualifiers(clang.Qualifiers Q)
            {
                var arg0 = ReferenceEquals(Q, null) ? new clang.Qualifiers.Internal() : *(clang.Qualifiers.Internal*) (Q.__Instance);
                Internal.addQualifiers_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>Remove the qualifiers from the given set from this set.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Remove the qualifiers from the given set from this
            /// set.</para>
            /// </remarks>
            public void removeQualifiers(clang.Qualifiers Q)
            {
                var arg0 = ReferenceEquals(Q, null) ? new clang.Qualifiers.Internal() : *(clang.Qualifiers.Internal*) (Q.__Instance);
                Internal.removeQualifiers_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>Add the qualifiers from the given set to this set, given that
            /// they don't conflict.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Add the qualifiers from the given set to this set,
            /// given that</para>
            /// <para>  /// they don't conflict.</para>
            /// </remarks>
            public void addConsistentQualifiers(clang.Qualifiers qs)
            {
                var arg0 = ReferenceEquals(qs, null) ? new clang.Qualifiers.Internal() : *(clang.Qualifiers.Internal*) (qs.__Instance);
                Internal.addConsistentQualifiers_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>Returns true if this address space is a superset of the other
            /// one. OpenCL v2.0 defines conversion rules (OpenCLC v2.0 s6.5.5) and notion
            /// of overlapping address spaces. CL1.1 or CL1.2: every address space is a
            /// superset of itself. CL2.0 adds: __generic is a superset of any address
            /// space except for __constant.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Returns true if this address space is a superset of
            /// the other one.</para>
            /// <para>  /// OpenCL v2.0 defines conversion rules (OpenCLC v2.0 s6.5.5)
            /// and notion of</para>
            /// <para>  /// overlapping address spaces.</para>
            /// <para>  /// CL1.1 or CL1.2:</para>
            /// <para>  ///   every address space is a superset of itself.</para>
            /// <para>  /// CL2.0 adds:</para>
            /// <para>  ///   __generic is a superset of any address space except for
            /// __constant.</para>
            /// </remarks>
            public bool isAddressSpaceSupersetOf(clang.Qualifiers other)
            {
                var arg0 = ReferenceEquals(other, null) ? new clang.Qualifiers.Internal() : *(clang.Qualifiers.Internal*) (other.__Instance);
                var __ret = Internal.isAddressSpaceSupersetOf_0(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Determines if these qualifiers compatibly include another set.
            /// Generally this answers the question of whether an object with the other
            /// qualifiers can be safely used as an object with these qualifiers.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determines if these qualifiers compatibly include
            /// another set.</para>
            /// <para>  /// Generally this answers the question of whether an object
            /// with the other</para>
            /// <para>  /// qualifiers can be safely used as an object with these
            /// qualifiers.</para>
            /// </remarks>
            public bool compatiblyIncludes(clang.Qualifiers other)
            {
                var arg0 = ReferenceEquals(other, null) ? new clang.Qualifiers.Internal() : *(clang.Qualifiers.Internal*) (other.__Instance);
                var __ret = Internal.compatiblyIncludes_0(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Determines if these qualifiers compatibly include another set of
            /// qualifiers from the narrow perspective of Objective-C ARC lifetime.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determines if these qualifiers compatibly include
            /// another set of</para>
            /// <para>  /// qualifiers from the narrow perspective of Objective-C ARC
            /// lifetime.</para>
            /// <para>  ///</para>
            /// <para>  /// One set of Objective-C lifetime qualifiers compatibly
            /// includes the other</para>
            /// <para>  /// if the lifetime qualifiers match, or if both are non-__weak
            /// and the</para>
            /// <para>  /// including set also contains the 'const' qualifier.</para>
            /// </remarks>
            public bool compatiblyIncludesObjCLifetime(clang.Qualifiers other)
            {
                var arg0 = ReferenceEquals(other, null) ? new clang.Qualifiers.Internal() : *(clang.Qualifiers.Internal*) (other.__Instance);
                var __ret = Internal.compatiblyIncludesObjCLifetime_0(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Determine whether this set of qualifiers is a strict superset of
            /// another set of qualifiers, not considering qualifier compatibility.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine whether this set of qualifiers is a strict
            /// superset of</para>
            /// <para>  /// another set of qualifiers, not considering qualifier
            /// compatibility.</para>
            /// </remarks>
            public bool isStrictSupersetOf(clang.Qualifiers Other)
            {
                var arg0 = ReferenceEquals(Other, null) ? new clang.Qualifiers.Internal() : *(clang.Qualifiers.Internal*) (Other.__Instance);
                var __ret = Internal.isStrictSupersetOf_0(__Instance, arg0);
                return __ret;
            }

            public static bool operator ==(clang.Qualifiers __op, clang.Qualifiers Other)
            {
                bool __opNull = ReferenceEquals(__op, null);
                bool OtherNull = ReferenceEquals(Other, null);
                if (__opNull || OtherNull)
                    return __opNull && OtherNull;
                var arg0 = __op.__Instance;
                var arg1 = ReferenceEquals(Other, null) ? new clang.Qualifiers.Internal() : *(clang.Qualifiers.Internal*) (Other.__Instance);
                var __ret = Internal.OperatorEqualEqual_0(arg0, arg1);
                return __ret;
            }

            public override bool Equals(object obj)
            {
                return this == obj as Qualifiers;
            }

            public static bool operator !=(clang.Qualifiers __op, clang.Qualifiers Other)
            {
                var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
                var arg1 = ReferenceEquals(Other, null) ? new clang.Qualifiers.Internal() : *(clang.Qualifiers.Internal*) (Other.__Instance);
                var __ret = Internal.OperatorExclaimEqual_0(arg0, arg1);
                return __ret;
            }

            public static implicit operator bool(clang.Qualifiers __op)
            {
                var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
                var __ret = Internal.OperatorConversion_0(arg0);
                return __ret;
            }

            public bool isEmptyWhenPrinted(clang.PrintingPolicy Policy)
            {
                var arg0 = ReferenceEquals(Policy, null) ? global::System.IntPtr.Zero : Policy.__Instance;
                var __ret = Internal.isEmptyWhenPrinted_0(__Instance, arg0);
                return __ret;
            }

            public void print(llvm.raw_ostream OS, clang.PrintingPolicy Policy, bool appendSpaceIfNonEmpty)
            {
                var arg0 = ReferenceEquals(OS, null) ? global::System.IntPtr.Zero : OS.__Instance;
                var arg1 = ReferenceEquals(Policy, null) ? global::System.IntPtr.Zero : Policy.__Instance;
                Internal.print_0(__Instance, arg0, arg1, appendSpaceIfNonEmpty);
            }

            public void Profile(llvm.FoldingSetNodeID ID)
            {
                var arg0 = ReferenceEquals(ID, null) ? global::System.IntPtr.Zero : ID.__Instance;
                Internal.Profile_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>Returns the common set of qualifiers while removing them from the
            /// given sets.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Returns the common set of qualifiers while removing
            /// them from</para>
            /// <para>  /// the given sets.</para>
            /// </remarks>
            public static clang.Qualifiers removeCommonQualifiers(clang.Qualifiers L, clang.Qualifiers R)
            {
                var arg0 = ReferenceEquals(L, null) ? global::System.IntPtr.Zero : L.__Instance;
                var arg1 = ReferenceEquals(R, null) ? global::System.IntPtr.Zero : R.__Instance;
                var __ret = Internal.removeCommonQualifiers_0(arg0, arg1);
                return clang.Qualifiers.__CreateInstance(__ret);
            }

            public static clang.Qualifiers fromFastMask(uint Mask)
            {
                var __ret = Internal.fromFastMask_0(Mask);
                return clang.Qualifiers.__CreateInstance(__ret);
            }

            public static clang.Qualifiers fromCVRMask(uint CVR)
            {
                var __ret = Internal.fromCVRMask_0(CVR);
                return clang.Qualifiers.__CreateInstance(__ret);
            }

            public static clang.Qualifiers fromOpaqueValue(uint opaque)
            {
                var __ret = Internal.fromOpaqueValue_0(opaque);
                return clang.Qualifiers.__CreateInstance(__ret);
            }

            public static clang.Qualifiers operator +(clang.Qualifiers L, clang.Qualifiers R)
            {
                var arg0 = ReferenceEquals(L, null) ? new clang.Qualifiers.Internal() : *(clang.Qualifiers.Internal*) (L.__Instance);
                var arg1 = ReferenceEquals(R, null) ? new clang.Qualifiers.Internal() : *(clang.Qualifiers.Internal*) (R.__Instance);
                var __ret = Internal.OperatorPlus_0(arg0, arg1);
                return clang.Qualifiers.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Compute the difference between two qualifier sets.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Compute the difference between two qualifier
            /// sets.</para>
            /// </remarks>
            public static clang.Qualifiers operator -(clang.Qualifiers L, clang.Qualifiers R)
            {
                var arg0 = ReferenceEquals(L, null) ? new clang.Qualifiers.Internal() : *(clang.Qualifiers.Internal*) (L.__Instance);
                var arg1 = ReferenceEquals(R, null) ? new clang.Qualifiers.Internal() : *(clang.Qualifiers.Internal*) (R.__Instance);
                var __ret = Internal.OperatorMinus_0(arg0, arg1);
                return clang.Qualifiers.__CreateInstance(__ret);
            }
        }

        /// <summary>
        /// <para>A std::pair-like structure for storing a qualified type split
        /// into its local qualifiers and its locally-unqualified type.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// A std::pair-like structure for storing a qualified type
        /// split</para>
        /// <para>/// into its local qualifiers and its locally-unqualified
        /// type.</para>
        /// </remarks>
        public unsafe partial class SplitQualType : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr Ty;

                [FieldOffset(8)]
                public clang.Qualifiers.Internal Quals;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13SplitQualTypeC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13SplitQualTypeC2EPKNS_4TypeENS_10QualifiersE")]
                internal static extern void ctor_1(global::System.IntPtr instance, global::System.IntPtr ty, clang.Qualifiers.Internal qs);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13SplitQualTypeC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13SplitQualType26getSingleStepDesugaredTypeEv")]
                internal static extern clang.SplitQualType.Internal getSingleStepDesugaredType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clangeqENS_13SplitQualTypeES0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorEqualEqual_0(clang.SplitQualType.Internal a, clang.SplitQualType.Internal b);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clangneENS_13SplitQualTypeES0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorExclaimEqual_0(clang.SplitQualType.Internal a, clang.SplitQualType.Internal b);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, SplitQualType> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, SplitQualType>();

            private readonly bool __ownsNativeInstance;

            public static SplitQualType __CreateInstance(global::System.IntPtr native)
            {
                return new SplitQualType((SplitQualType.Internal*) native);
            }

            public static SplitQualType __CreateInstance(SplitQualType.Internal native)
            {
                return new SplitQualType(native);
            }

            private static SplitQualType.Internal* __CopyValue(SplitQualType.Internal native)
            {
                var ret = (SplitQualType.Internal*) Marshal.AllocHGlobal(16);
                *ret = native;
                return ret;
            }

            private SplitQualType(SplitQualType.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected SplitQualType(SplitQualType.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public SplitQualType()
            {
                __Instance = Marshal.AllocHGlobal(16);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public SplitQualType(clang.Type ty, clang.Qualifiers qs)
            {
                __Instance = Marshal.AllocHGlobal(16);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(ty, null) ? global::System.IntPtr.Zero : ty.__Instance;
                var arg1 = ReferenceEquals(qs, null) ? new clang.Qualifiers.Internal() : *(clang.Qualifiers.Internal*) (qs.__Instance);
                Internal.ctor_1(__Instance, arg0, arg1);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.SplitQualType __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.SplitQualType getSingleStepDesugaredType()
            {
                var __ret = Internal.getSingleStepDesugaredType_0(__Instance);
                return clang.SplitQualType.__CreateInstance(__ret);
            }

            public static bool operator ==(clang.SplitQualType a, clang.SplitQualType b)
            {
                bool aNull = ReferenceEquals(a, null);
                bool bNull = ReferenceEquals(b, null);
                if (aNull || bNull)
                    return aNull && bNull;
                var arg0 = ReferenceEquals(a, null) ? new clang.SplitQualType.Internal() : *(clang.SplitQualType.Internal*) (a.__Instance);
                var arg1 = ReferenceEquals(b, null) ? new clang.SplitQualType.Internal() : *(clang.SplitQualType.Internal*) (b.__Instance);
                var __ret = Internal.OperatorEqualEqual_0(arg0, arg1);
                return __ret;
            }

            public override bool Equals(object obj)
            {
                return this == obj as SplitQualType;
            }

            public static bool operator !=(clang.SplitQualType a, clang.SplitQualType b)
            {
                var arg0 = ReferenceEquals(a, null) ? new clang.SplitQualType.Internal() : *(clang.SplitQualType.Internal*) (a.__Instance);
                var arg1 = ReferenceEquals(b, null) ? new clang.SplitQualType.Internal() : *(clang.SplitQualType.Internal*) (b.__Instance);
                var __ret = Internal.OperatorExclaimEqual_0(arg0, arg1);
                return __ret;
            }

            public clang.Type Ty
            {
                get
                {
                    clang.Type __result0;
                    if (((Internal*) __Instance)->Ty == IntPtr.Zero) __result0 = null;
                    else if (clang.Type.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->Ty))
                        __result0 = (clang.Type) clang.Type.NativeToManagedMap[((Internal*) __Instance)->Ty];
                    else __result0 = clang.Type.__CreateInstance(((Internal*) __Instance)->Ty);
                    return __result0;
                }

                set
                {
                    ((Internal*) __Instance)->Ty = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                }
            }

            public clang.Qualifiers Quals
            {
                get
                {
                    return clang.Qualifiers.__CreateInstance(((Internal*) __Instance)->Quals);
                }

                set
                {
                    ((Internal*) __Instance)->Quals = ReferenceEquals(value, null) ? new clang.Qualifiers.Internal() : *(clang.Qualifiers.Internal*) (value.__Instance);
                }
            }
        }

        /// <summary>
        /// <para>QualType - For efficiency, we don't store CV-qualified types as
        /// nodes on their own: instead each reference to a type stores the qualifiers.
        /// This greatly reduces the number of nodes we need to allocate for types (for
        /// example we only need one for 'int', 'const int', 'volatile int', 'const
        /// volatile int', etc).</para>
        /// </summary>
        /// <remarks>
        /// <para>/// QualType - For efficiency, we don't store CV-qualified types
        /// as nodes on</para>
        /// <para>/// their own: instead each reference to a type stores the
        /// qualifiers.  This</para>
        /// <para>/// greatly reduces the number of nodes we need to allocate for
        /// types (for</para>
        /// <para>/// example we only need one for 'int', 'const int', 'volatile
        /// int',</para>
        /// <para>/// 'const volatile int', etc).</para>
        /// <para>///</para>
        /// <para>/// As an added efficiency bonus, instead of making this a pair,
        /// we</para>
        /// <para>/// just store the two bits we care about in the low bits of
        /// the</para>
        /// <para>/// pointer.  To handle the packing/unpacking, we make QualType
        /// be a</para>
        /// <para>/// simple wrapper class that acts like a smart pointer.  A third
        /// bit</para>
        /// <para>/// indicates whether there are extended qualifiers present, in
        /// which</para>
        /// <para>/// case the pointer points to a special structure.</para>
        /// </remarks>
        public unsafe partial class QualType : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 8)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                internal llvm.PointerIntPair.Internal Value;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8QualTypeC2Ev")]
                internal static extern void ctor_1(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8QualTypeC2EPKNS_4TypeEj")]
                internal static extern void ctor_2(global::System.IntPtr instance, global::System.IntPtr Ptr, uint Quals);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8QualTypeC2EPKNS_8ExtQualsEj")]
                internal static extern void ctor_3(global::System.IntPtr instance, global::System.IntPtr Ptr, uint Quals);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8QualTypeC2ERKS0_")]
                internal static extern void cctor_4(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8QualType22getLocalFastQualifiersEv")]
                internal static extern uint getLocalFastQualifiers_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8QualType22setLocalFastQualifiersEj")]
                internal static extern void setLocalFastQualifiers_0(global::System.IntPtr instance, uint Quals);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8QualType10getTypePtrEv")]
                internal static extern global::System.IntPtr getTypePtr_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8QualType16getTypePtrOrNullEv")]
                internal static extern global::System.IntPtr getTypePtrOrNull_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8QualType21getBaseTypeIdentifierEv")]
                internal static extern global::System.IntPtr getBaseTypeIdentifier_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8QualType5splitEv")]
                internal static extern clang.SplitQualType.Internal split_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8QualType14getAsOpaquePtrEv")]
                internal static extern global::System.IntPtr getAsOpaquePtr_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8QualType16getFromOpaquePtrEPKv")]
                internal static extern clang.QualType.Internal getFromOpaquePtr_0(global::System.IntPtr Ptr);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8QualType11isCanonicalEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isCanonical_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8QualType18isCanonicalAsParamEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isCanonicalAsParam_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8QualType6isNullEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isNull_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8QualType21isLocalConstQualifiedEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isLocalConstQualified_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8QualType16isConstQualifiedEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isConstQualified_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8QualType24isLocalRestrictQualifiedEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isLocalRestrictQualified_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8QualType19isRestrictQualifiedEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isRestrictQualified_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8QualType24isLocalVolatileQualifiedEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isLocalVolatileQualified_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8QualType19isVolatileQualifiedEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isVolatileQualified_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8QualType18hasLocalQualifiersEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasLocalQualifiers_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8QualType13hasQualifiersEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasQualifiers_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8QualType25hasLocalNonFastQualifiersEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasLocalNonFastQualifiers_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8QualType18getLocalQualifiersEv")]
                internal static extern clang.Qualifiers.Internal getLocalQualifiers_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8QualType13getQualifiersEv")]
                internal static extern clang.Qualifiers.Internal getQualifiers_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8QualType21getLocalCVRQualifiersEv")]
                internal static extern uint getLocalCVRQualifiers_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8QualType16getCVRQualifiersEv")]
                internal static extern uint getCVRQualifiers_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8QualType10isConstantERNS_10ASTContextE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isConstant_0(global::System.IntPtr instance, global::System.IntPtr Ctx);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8QualType9isPODTypeERNS_10ASTContextE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isPODType_0(global::System.IntPtr instance, global::System.IntPtr Context);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8QualType14isCXX98PODTypeERNS_10ASTContextE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isCXX98PODType_0(global::System.IntPtr instance, global::System.IntPtr Context);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8QualType14isCXX11PODTypeERNS_10ASTContextE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isCXX11PODType_0(global::System.IntPtr instance, global::System.IntPtr Context);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8QualType13isTrivialTypeERNS_10ASTContextE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isTrivialType_0(global::System.IntPtr instance, global::System.IntPtr Context);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8QualType23isTriviallyCopyableTypeERNS_10ASTContextE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isTriviallyCopyableType_0(global::System.IntPtr instance, global::System.IntPtr Context);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8QualType8addConstEv")]
                internal static extern void addConst_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8QualType9withConstEv")]
                internal static extern clang.QualType.Internal withConst_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8QualType11addVolatileEv")]
                internal static extern void addVolatile_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8QualType12withVolatileEv")]
                internal static extern clang.QualType.Internal withVolatile_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8QualType11addRestrictEv")]
                internal static extern void addRestrict_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8QualType12withRestrictEv")]
                internal static extern clang.QualType.Internal withRestrict_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8QualType17withCVRQualifiersEj")]
                internal static extern clang.QualType.Internal withCVRQualifiers_0(global::System.IntPtr instance, uint CVR);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8QualType17addFastQualifiersEj")]
                internal static extern void addFastQualifiers_0(global::System.IntPtr instance, uint TQs);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8QualType16removeLocalConstEv")]
                internal static extern void removeLocalConst_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8QualType19removeLocalVolatileEv")]
                internal static extern void removeLocalVolatile_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8QualType19removeLocalRestrictEv")]
                internal static extern void removeLocalRestrict_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8QualType24removeLocalCVRQualifiersEj")]
                internal static extern void removeLocalCVRQualifiers_0(global::System.IntPtr instance, uint Mask);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8QualType25removeLocalFastQualifiersEv")]
                internal static extern void removeLocalFastQualifiers_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8QualType25removeLocalFastQualifiersEj")]
                internal static extern void removeLocalFastQualifiers_1(global::System.IntPtr instance, uint Mask);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8QualType18withFastQualifiersEj")]
                internal static extern clang.QualType.Internal withFastQualifiers_0(global::System.IntPtr instance, uint TQs);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8QualType28withExactLocalFastQualifiersEj")]
                internal static extern clang.QualType.Internal withExactLocalFastQualifiers_0(global::System.IntPtr instance, uint TQs);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8QualType26withoutLocalFastQualifiersEv")]
                internal static extern clang.QualType.Internal withoutLocalFastQualifiers_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8QualType16getCanonicalTypeEv")]
                internal static extern clang.QualType.Internal getCanonicalType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8QualType23getLocalUnqualifiedTypeEv")]
                internal static extern clang.QualType.Internal getLocalUnqualifiedType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8QualType18getUnqualifiedTypeEv")]
                internal static extern clang.QualType.Internal getUnqualifiedType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8QualType23getSplitUnqualifiedTypeEv")]
                internal static extern clang.SplitQualType.Internal getSplitUnqualifiedType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8QualType19isMoreQualifiedThanES0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isMoreQualifiedThan_0(global::System.IntPtr instance, clang.QualType.Internal Other);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8QualType22isAtLeastAsQualifiedAsES0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isAtLeastAsQualifiedAs_0(global::System.IntPtr instance, clang.QualType.Internal Other);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8QualType19getNonReferenceTypeEv")]
                internal static extern clang.QualType.Internal getNonReferenceType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8QualType20getNonLValueExprTypeERKNS_10ASTContextE")]
                internal static extern clang.QualType.Internal getNonLValueExprType_0(global::System.IntPtr instance, global::System.IntPtr Context);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8QualType16getDesugaredTypeERKNS_10ASTContextE")]
                internal static extern clang.QualType.Internal getDesugaredType_0(global::System.IntPtr instance, global::System.IntPtr Context);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8QualType21getSplitDesugaredTypeEv")]
                internal static extern clang.SplitQualType.Internal getSplitDesugaredType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8QualType26getSingleStepDesugaredTypeERKNS_10ASTContextE")]
                internal static extern clang.QualType.Internal getSingleStepDesugaredType_0(global::System.IntPtr instance, global::System.IntPtr Context);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8QualType12IgnoreParensEv")]
                internal static extern clang.QualType.Internal IgnoreParens_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8QualType5printERN4llvm11raw_ostreamERKNS_14PrintingPolicyERKNS1_5TwineE")]
                internal static extern void print_0(global::System.IntPtr instance, global::System.IntPtr OS, global::System.IntPtr Policy, global::System.IntPtr PlaceHolder);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8QualType5printENS_13SplitQualTypeERN4llvm11raw_ostreamERKNS_14PrintingPolicyERKNS2_5TwineE")]
                internal static extern void print_1(clang.SplitQualType.Internal split, global::System.IntPtr OS, global::System.IntPtr policy, global::System.IntPtr PlaceHolder);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8QualType5printEPKNS_4TypeENS_10QualifiersERN4llvm11raw_ostreamERKNS_14PrintingPolicyERKNS5_5TwineE")]
                internal static extern void print_2(global::System.IntPtr ty, clang.Qualifiers.Internal qs, global::System.IntPtr OS, global::System.IntPtr policy, global::System.IntPtr PlaceHolder);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8QualType6streamERKNS_14PrintingPolicyERKN4llvm5TwineE")]
                internal static extern void stream_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr Policy, global::System.IntPtr PlaceHolder);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8QualType4dumpEPKc")]
                internal static extern void dump_0(global::System.IntPtr instance, global::System.IntPtr s);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8QualType4dumpEv")]
                internal static extern void dump_1(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8QualType7ProfileERN4llvm16FoldingSetNodeIDE")]
                internal static extern void Profile_0(global::System.IntPtr instance, global::System.IntPtr ID);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8QualType15getAddressSpaceEv")]
                internal static extern uint getAddressSpace_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8QualType13getObjCGCAttrEv")]
                internal static extern clang.Qualifiers.GC getObjCGCAttr_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8QualType12isObjCGCWeakEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isObjCGCWeak_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8QualType14isObjCGCStrongEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isObjCGCStrong_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8QualType15getObjCLifetimeEv")]
                internal static extern clang.Qualifiers.ObjCLifetime getObjCLifetime_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8QualType25hasNonTrivialObjCLifetimeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasNonTrivialObjCLifetime_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8QualType27hasStrongOrWeakObjCLifetimeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasStrongOrWeakObjCLifetime_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8QualType16isDestructedTypeEv")]
                internal static extern clang.QualType.DestructionKind isDestructedType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8QualType22isCForbiddenLValueTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isCForbiddenLValueType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clangeqERKNS_8QualTypeES2_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorEqualEqual_0(global::System.IntPtr LHS, global::System.IntPtr RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clangneERKNS_8QualTypeES2_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorExclaimEqual_0(global::System.IntPtr LHS, global::System.IntPtr RHS);
            }

            public enum DestructionKind : uint
            {
                DK_none = 0,
                DK_cxx_destructor = 1,
                DK_objc_strong_lifetime = 2,
                DK_objc_weak_lifetime = 3
            }

            public unsafe partial class StreamedQualTypeHelper : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 24)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public global::System.IntPtr T;

                    [FieldOffset(8)]
                    public global::System.IntPtr Policy;

                    [FieldOffset(16)]
                    public global::System.IntPtr PlaceHolder;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang8QualType22StreamedQualTypeHelperC2ERKS0_RKNS_14PrintingPolicyERKN4llvm5TwineE")]
                    internal static extern void ctor_0(global::System.IntPtr instance, global::System.IntPtr T, global::System.IntPtr Policy, global::System.IntPtr PlaceHolder);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang8QualType22StreamedQualTypeHelperC2ERKS1_")]
                    internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, StreamedQualTypeHelper> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, StreamedQualTypeHelper>();

                private readonly bool __ownsNativeInstance;

                public static StreamedQualTypeHelper __CreateInstance(global::System.IntPtr native)
                {
                    return new StreamedQualTypeHelper((StreamedQualTypeHelper.Internal*) native);
                }

                public static StreamedQualTypeHelper __CreateInstance(StreamedQualTypeHelper.Internal native)
                {
                    return new StreamedQualTypeHelper(native);
                }

                private static StreamedQualTypeHelper.Internal* __CopyValue(StreamedQualTypeHelper.Internal native)
                {
                    var ret = (StreamedQualTypeHelper.Internal*) Marshal.AllocHGlobal(24);
                    *ret = native;
                    return ret;
                }

                private StreamedQualTypeHelper(StreamedQualTypeHelper.Internal native)
                    : this(__CopyValue(native))
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected StreamedQualTypeHelper(StreamedQualTypeHelper.Internal* native, bool isInternalImpl = false)
                {
                    __Instance = new global::System.IntPtr(native);
                }

                public StreamedQualTypeHelper(clang.QualType T, clang.PrintingPolicy Policy, llvm.Twine PlaceHolder)
                {
                    __Instance = Marshal.AllocHGlobal(24);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                    var arg1 = ReferenceEquals(Policy, null) ? global::System.IntPtr.Zero : Policy.__Instance;
                    var arg2 = ReferenceEquals(PlaceHolder, null) ? global::System.IntPtr.Zero : PlaceHolder.__Instance;
                    Internal.ctor_0(__Instance, arg0, arg1, arg2);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    DestroyNativeInstance(false);
                }

                public virtual void DestroyNativeInstance()
                {
                    DestroyNativeInstance(true);
                }

                private void DestroyNativeInstance(bool force)
                {
                    clang.QualType.StreamedQualTypeHelper __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, QualType> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, QualType>();

            private readonly bool __ownsNativeInstance;

            public static QualType __CreateInstance(global::System.IntPtr native)
            {
                return new QualType((QualType.Internal*) native);
            }

            public static QualType __CreateInstance(QualType.Internal native)
            {
                return new QualType(native);
            }

            private static QualType.Internal* __CopyValue(QualType.Internal native)
            {
                var ret = (QualType.Internal*) Marshal.AllocHGlobal(8);
                *ret = native;
                return ret;
            }

            private QualType(QualType.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected QualType(QualType.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public QualType()
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_1(__Instance);
            }

            public QualType(clang.Type Ptr, uint Quals)
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(Ptr, null) ? global::System.IntPtr.Zero : Ptr.__Instance;
                Internal.ctor_2(__Instance, arg0, Quals);
            }

            public QualType(clang.ExtQuals Ptr, uint Quals)
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(Ptr, null) ? global::System.IntPtr.Zero : Ptr.__Instance;
                Internal.ctor_3(__Instance, arg0, Quals);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.QualType __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public uint getLocalFastQualifiers()
            {
                var __ret = Internal.getLocalFastQualifiers_0(__Instance);
                return __ret;
            }

            public void setLocalFastQualifiers(uint Quals)
            {
                Internal.setLocalFastQualifiers_0(__Instance, Quals);
            }

            /// <summary>
            /// <para>Retrieves a pointer to the underlying (unqualified) type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Retrieves a pointer to the underlying (unqualified)
            /// type.</para>
            /// <para>  ///</para>
            /// <para>  /// This function requires that the type not be NULL. If the
            /// type might be</para>
            /// <para>  /// NULL, use the (slightly less efficient) \c
            /// getTypePtrOrNull().</para>
            /// </remarks>
            public clang.Type getTypePtr()
            {
                var __ret = Internal.getTypePtr_0(__Instance);
                clang.Type __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Type.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Type) clang.Type.NativeToManagedMap[__ret];
                else __result0 = clang.Type.__CreateInstance(__ret);
                return __result0;
            }

            public clang.Type getTypePtrOrNull()
            {
                var __ret = Internal.getTypePtrOrNull_0(__Instance);
                clang.Type __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Type.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Type) clang.Type.NativeToManagedMap[__ret];
                else __result0 = clang.Type.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Retrieves a pointer to the name of the base type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Retrieves a pointer to the name of the base type.</para>
            /// </remarks>
            public clang.IdentifierInfo getBaseTypeIdentifier()
            {
                var __ret = Internal.getBaseTypeIdentifier_0(__Instance);
                clang.IdentifierInfo __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.IdentifierInfo.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.IdentifierInfo) clang.IdentifierInfo.NativeToManagedMap[__ret];
                else __result0 = clang.IdentifierInfo.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Divides a QualType into its unqualified type and a set of local
            /// qualifiers.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Divides a QualType into its unqualified type and a set of
            /// local</para>
            /// <para>  /// qualifiers.</para>
            /// </remarks>
            public clang.SplitQualType split()
            {
                var __ret = Internal.split_0(__Instance);
                return clang.SplitQualType.__CreateInstance(__ret);
            }

            public global::System.IntPtr getAsOpaquePtr()
            {
                var __ret = Internal.getAsOpaquePtr_0(__Instance);
                return __ret;
            }

            public bool isCanonical()
            {
                var __ret = Internal.isCanonical_0(__Instance);
                return __ret;
            }

            public bool isCanonicalAsParam()
            {
                var __ret = Internal.isCanonicalAsParam_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>isNull - Return true if this QualType doesn't point to a type
            /// yet.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// isNull - Return true if this QualType doesn't point to a type
            /// yet.</para>
            /// </remarks>
            public bool isNull()
            {
                var __ret = Internal.isNull_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determine whether this particular QualType instance has the
            /// &quot;const&quot; qualifier set, without looking through typedefs that may
            /// have added &quot;const&quot; at a different level.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine whether this particular QualType instance
            /// has the</para>
            /// <para>  /// &quot;const&quot; qualifier set, without looking through
            /// typedefs that may have</para>
            /// <para>  /// added &quot;const&quot; at a different level.</para>
            /// </remarks>
            public bool isLocalConstQualified()
            {
                var __ret = Internal.isLocalConstQualified_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determine whether this type is const-qualified.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine whether this type is const-qualified.</para>
            /// </remarks>
            public bool isConstQualified()
            {
                var __ret = Internal.isConstQualified_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determine whether this particular QualType instance has the
            /// &quot;restrict&quot; qualifier set, without looking through typedefs that
            /// may have added &quot;restrict&quot; at a different level.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine whether this particular QualType instance
            /// has the</para>
            /// <para>  /// &quot;restrict&quot; qualifier set, without looking through
            /// typedefs that may have</para>
            /// <para>  /// added &quot;restrict&quot; at a different level.</para>
            /// </remarks>
            public bool isLocalRestrictQualified()
            {
                var __ret = Internal.isLocalRestrictQualified_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determine whether this type is restrict-qualified.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine whether this type is
            /// restrict-qualified.</para>
            /// </remarks>
            public bool isRestrictQualified()
            {
                var __ret = Internal.isRestrictQualified_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determine whether this particular QualType instance has the
            /// &quot;volatile&quot; qualifier set, without looking through typedefs that
            /// may have added &quot;volatile&quot; at a different level.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine whether this particular QualType instance
            /// has the</para>
            /// <para>  /// &quot;volatile&quot; qualifier set, without looking through
            /// typedefs that may have</para>
            /// <para>  /// added &quot;volatile&quot; at a different level.</para>
            /// </remarks>
            public bool isLocalVolatileQualified()
            {
                var __ret = Internal.isLocalVolatileQualified_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determine whether this type is volatile-qualified.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine whether this type is
            /// volatile-qualified.</para>
            /// </remarks>
            public bool isVolatileQualified()
            {
                var __ret = Internal.isVolatileQualified_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determine whether this particular QualType instance has any
            /// qualifiers, without looking through any typedefs that might add qualifiers
            /// at a different level.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine whether this particular QualType instance
            /// has any</para>
            /// <para>  /// qualifiers, without looking through any typedefs that might
            /// add</para>
            /// <para>  /// qualifiers at a different level.</para>
            /// </remarks>
            public bool hasLocalQualifiers()
            {
                var __ret = Internal.hasLocalQualifiers_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determine whether this type has any qualifiers.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine whether this type has any qualifiers.</para>
            /// </remarks>
            public bool hasQualifiers()
            {
                var __ret = Internal.hasQualifiers_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determine whether this particular QualType instance has any
            /// &quot;non-fast&quot; qualifiers, e.g., those that are stored in an
            /// ExtQualType instance.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine whether this particular QualType instance
            /// has any</para>
            /// <para>  /// &quot;non-fast&quot; qualifiers, e.g., those that are
            /// stored in an ExtQualType</para>
            /// <para>  /// instance.</para>
            /// </remarks>
            public bool hasLocalNonFastQualifiers()
            {
                var __ret = Internal.hasLocalNonFastQualifiers_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Retrieve the set of qualifiers local to this particular QualType
            /// instance, not including any qualifiers acquired through typedefs or other
            /// sugar.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the set of qualifiers local to this
            /// particular QualType</para>
            /// <para>  /// instance, not including any qualifiers acquired through
            /// typedefs or</para>
            /// <para>  /// other sugar.</para>
            /// </remarks>
            public clang.Qualifiers getLocalQualifiers()
            {
                var __ret = Internal.getLocalQualifiers_0(__Instance);
                return clang.Qualifiers.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Retrieve the set of qualifiers applied to this type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the set of qualifiers applied to this
            /// type.</para>
            /// </remarks>
            public clang.Qualifiers getQualifiers()
            {
                var __ret = Internal.getQualifiers_0(__Instance);
                return clang.Qualifiers.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Retrieve the set of CVR (const-volatile-restrict) qualifiers
            /// local to this particular QualType instance, not including any qualifiers
            /// acquired through typedefs or other sugar.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the set of CVR (const-volatile-restrict)
            /// qualifiers</para>
            /// <para>  /// local to this particular QualType instance, not including
            /// any qualifiers</para>
            /// <para>  /// acquired through typedefs or other sugar.</para>
            /// </remarks>
            public uint getLocalCVRQualifiers()
            {
                var __ret = Internal.getLocalCVRQualifiers_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Retrieve the set of CVR (const-volatile-restrict) qualifiers
            /// applied to this type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the set of CVR (const-volatile-restrict)
            /// qualifiers</para>
            /// <para>  /// applied to this type.</para>
            /// </remarks>
            public uint getCVRQualifiers()
            {
                var __ret = Internal.getCVRQualifiers_0(__Instance);
                return __ret;
            }

            public bool isConstant(clang.ASTContext Ctx)
            {
                var arg0 = ReferenceEquals(Ctx, null) ? global::System.IntPtr.Zero : Ctx.__Instance;
                var __ret = Internal.isConstant_0(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Determine whether this is a Plain Old Data (POD) type (C++
            /// 3.9p10).</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine whether this is a Plain Old Data (POD) type
            /// (C++ 3.9p10).</para>
            /// </remarks>
            public bool isPODType(clang.ASTContext Context)
            {
                var arg0 = ReferenceEquals(Context, null) ? global::System.IntPtr.Zero : Context.__Instance;
                var __ret = Internal.isPODType_0(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>isCXX98PODType() - Return true if this is a POD type according to
            /// the rules of the C++98 standard, regardless of the current compilation's
            /// language.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// isCXX98PODType() - Return true if this is a POD type
            /// according to the</para>
            /// <para>  /// rules of the C++98 standard, regardless of the current
            /// compilation's</para>
            /// <para>  /// language.</para>
            /// </remarks>
            public bool isCXX98PODType(clang.ASTContext Context)
            {
                var arg0 = ReferenceEquals(Context, null) ? global::System.IntPtr.Zero : Context.__Instance;
                var __ret = Internal.isCXX98PODType_0(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>isCXX11PODType() - Return true if this is a POD type according to
            /// the more relaxed rules of the C++11 standard, regardless of the current
            /// compilation's language. (C++0x [basic.types]p9)</para>
            /// </summary>
            /// <remarks>
            /// <para>/// isCXX11PODType() - Return true if this is a POD type
            /// according to the</para>
            /// <para>  /// more relaxed rules of the C++11 standard, regardless of the
            /// current</para>
            /// <para>  /// compilation's language.</para>
            /// <para>  /// (C++0x [basic.types]p9)</para>
            /// </remarks>
            public bool isCXX11PODType(clang.ASTContext Context)
            {
                var arg0 = ReferenceEquals(Context, null) ? global::System.IntPtr.Zero : Context.__Instance;
                var __ret = Internal.isCXX11PODType_0(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>isTrivialType - Return true if this is a trivial type (C++0x
            /// [basic.types]p9)</para>
            /// </summary>
            /// <remarks>
            /// <para>/// isTrivialType - Return true if this is a trivial type</para>
            /// <para>  /// (C++0x [basic.types]p9)</para>
            /// </remarks>
            public bool isTrivialType(clang.ASTContext Context)
            {
                var arg0 = ReferenceEquals(Context, null) ? global::System.IntPtr.Zero : Context.__Instance;
                var __ret = Internal.isTrivialType_0(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>isTriviallyCopyableType - Return true if this is a trivially
            /// copyable type (C++0x [basic.types]p9)</para>
            /// </summary>
            /// <remarks>
            /// <para>/// isTriviallyCopyableType - Return true if this is a
            /// trivially</para>
            /// <para>  /// copyable type (C++0x [basic.types]p9)</para>
            /// </remarks>
            public bool isTriviallyCopyableType(clang.ASTContext Context)
            {
                var arg0 = ReferenceEquals(Context, null) ? global::System.IntPtr.Zero : Context.__Instance;
                var __ret = Internal.isTriviallyCopyableType_0(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>addConst - add the specified type qualifier to this
            /// QualType.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// addConst - add the specified type qualifier to this
            /// QualType.</para>
            /// </remarks>
            public void addConst()
            {
                Internal.addConst_0(__Instance);
            }

            public clang.QualType withConst()
            {
                var __ret = Internal.withConst_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>addVolatile - add the specified type qualifier to this
            /// QualType.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// addVolatile - add the specified type qualifier to this
            /// QualType.</para>
            /// </remarks>
            public void addVolatile()
            {
                Internal.addVolatile_0(__Instance);
            }

            public clang.QualType withVolatile()
            {
                var __ret = Internal.withVolatile_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Add the restrict qualifier to this QualType.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Add the restrict qualifier to this QualType.</para>
            /// </remarks>
            public void addRestrict()
            {
                Internal.addRestrict_0(__Instance);
            }

            public clang.QualType withRestrict()
            {
                var __ret = Internal.withRestrict_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            public clang.QualType withCVRQualifiers(uint CVR)
            {
                var __ret = Internal.withCVRQualifiers_0(__Instance, CVR);
                return clang.QualType.__CreateInstance(__ret);
            }

            public void addFastQualifiers(uint TQs)
            {
                Internal.addFastQualifiers_0(__Instance, TQs);
            }

            public void removeLocalConst()
            {
                Internal.removeLocalConst_0(__Instance);
            }

            public void removeLocalVolatile()
            {
                Internal.removeLocalVolatile_0(__Instance);
            }

            public void removeLocalRestrict()
            {
                Internal.removeLocalRestrict_0(__Instance);
            }

            public void removeLocalCVRQualifiers(uint Mask)
            {
                Internal.removeLocalCVRQualifiers_0(__Instance, Mask);
            }

            public void removeLocalFastQualifiers()
            {
                Internal.removeLocalFastQualifiers_0(__Instance);
            }

            public void removeLocalFastQualifiers(uint Mask)
            {
                Internal.removeLocalFastQualifiers_1(__Instance, Mask);
            }

            public clang.QualType withFastQualifiers(uint TQs)
            {
                var __ret = Internal.withFastQualifiers_0(__Instance, TQs);
                return clang.QualType.__CreateInstance(__ret);
            }

            public clang.QualType withExactLocalFastQualifiers(uint TQs)
            {
                var __ret = Internal.withExactLocalFastQualifiers_0(__Instance, TQs);
                return clang.QualType.__CreateInstance(__ret);
            }

            public clang.QualType withoutLocalFastQualifiers()
            {
                var __ret = Internal.withoutLocalFastQualifiers_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            public clang.QualType getCanonicalType()
            {
                var __ret = Internal.getCanonicalType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Return this type with all of the instance-specific qualifiers
            /// removed, but without removing any qualifiers that may have been applied
            /// through typedefs.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return this type with all of the instance-specific
            /// qualifiers</para>
            /// <para>  /// removed, but without removing any qualifiers that may have
            /// been applied</para>
            /// <para>  /// through typedefs.</para>
            /// </remarks>
            public clang.QualType getLocalUnqualifiedType()
            {
                var __ret = Internal.getLocalUnqualifiedType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Retrieve the unqualified variant of the given type, removing as
            /// little sugar as possible.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the unqualified variant of the given
            /// type,</para>
            /// <para>  /// removing as little sugar as possible.</para>
            /// <para>  ///</para>
            /// <para>  /// This routine looks through various kinds of sugar to find
            /// the</para>
            /// <para>  /// least-desugared type that is unqualified. For example,
            /// given:</para>
            /// <para>  ///</para>
            /// <para>  /// \code</para>
            /// <para>  /// typedef int Integer;</para>
            /// <para>  /// typedef const Integer CInteger;</para>
            /// <para>  /// typedef CInteger DifferenceType;</para>
            /// <para>  /// \endcode</para>
            /// <para>  ///</para>
            /// <para>  /// Executing \c getUnqualifiedType() on the type \c
            /// DifferenceType will</para>
            /// <para>  /// desugar until we hit the type \c Integer, which has no
            /// qualifiers on it.</para>
            /// <para>  ///</para>
            /// <para>  /// The resulting type might still be qualified if it's sugar
            /// for an array</para>
            /// <para>  /// type.  To strip qualifiers even from within a sugared array
            /// type, use</para>
            /// <para>  /// ASTContext::getUnqualifiedArrayType.</para>
            /// </remarks>
            public clang.QualType getUnqualifiedType()
            {
                var __ret = Internal.getUnqualifiedType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>getSplitUnqualifiedType - Retrieve the unqualified variant of the
            /// given type, removing as little sugar as possible.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getSplitUnqualifiedType - Retrieve the unqualified variant of
            /// the</para>
            /// <para>  /// given type, removing as little sugar as possible.</para>
            /// <para>  ///</para>
            /// <para>  /// Like getUnqualifiedType(), but also returns the set
            /// of</para>
            /// <para>  /// qualifiers that were built up.</para>
            /// <para>  ///</para>
            /// <para>  /// The resulting type might still be qualified if it's sugar
            /// for an array</para>
            /// <para>  /// type.  To strip qualifiers even from within a sugared array
            /// type, use</para>
            /// <para>  /// ASTContext::getUnqualifiedArrayType.</para>
            /// </remarks>
            public clang.SplitQualType getSplitUnqualifiedType()
            {
                var __ret = Internal.getSplitUnqualifiedType_0(__Instance);
                return clang.SplitQualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Determine whether this type is more qualified than the other
            /// given type, requiring exact equality for non-CVR qualifiers.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine whether this type is more qualified than the
            /// other</para>
            /// <para>  /// given type, requiring exact equality for non-CVR
            /// qualifiers.</para>
            /// </remarks>
            public bool isMoreQualifiedThan(clang.QualType Other)
            {
                var arg0 = ReferenceEquals(Other, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (Other.__Instance);
                var __ret = Internal.isMoreQualifiedThan_0(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Determine whether this type is at least as qualified as the other
            /// given type, requiring exact equality for non-CVR qualifiers.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine whether this type is at least as qualified
            /// as the other</para>
            /// <para>  /// given type, requiring exact equality for non-CVR
            /// qualifiers.</para>
            /// </remarks>
            public bool isAtLeastAsQualifiedAs(clang.QualType Other)
            {
                var arg0 = ReferenceEquals(Other, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (Other.__Instance);
                var __ret = Internal.isAtLeastAsQualifiedAs_0(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>getNonReferenceType - If Type is a reference type (e.g., const
            /// int&amp;), returns the type that the reference refers to (&quot;const
            /// int&quot;). Otherwise, returns the type itself. This routine is used
            /// throughout Sema to implement C++ 5p6:</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getNonReferenceType - If Type is a reference type (e.g.,
            /// const</para>
            /// <para>/// int&amp;), returns the type that the reference refers to
            /// (&quot;const</para>
            /// <para>/// int&quot;). Otherwise, returns the type itself. This routine
            /// is used</para>
            /// <para>/// throughout Sema to implement C++ 5p6:</para>
            /// <para>///</para>
            /// <para>///   If an expression initially has the type &quot;reference to
            /// T&quot; (8.3.2,</para>
            /// <para>///   8.5.3), the type is adjusted to &quot;T&quot; prior to any
            /// further</para>
            /// <para>///   analysis, the expression designates the object or
            /// function</para>
            /// <para>///   denoted by the reference, and the expression is an
            /// lvalue.</para>
            /// </remarks>
            public clang.QualType getNonReferenceType()
            {
                var __ret = Internal.getNonReferenceType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Determine the type of a (typically non-lvalue) expression with
            /// the specified result type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine the type of a (typically non-lvalue)
            /// expression with the</para>
            /// <para>  /// specified result type.</para>
            /// <para>  ///</para>
            /// <para>  /// This routine should be used for expressions for which the
            /// return type is</para>
            /// <para>  /// explicitly specified (e.g., in a cast or call) and isn't
            /// necessarily</para>
            /// <para>  /// an lvalue. It removes a top-level reference (since there
            /// are no</para>
            /// <para>  /// expressions of reference type) and deletes top-level
            /// cvr-qualifiers</para>
            /// <para>  /// from non-class types (in C++) or all types (in C).</para>
            /// </remarks>
            public clang.QualType getNonLValueExprType(clang.ASTContext Context)
            {
                var arg0 = ReferenceEquals(Context, null) ? global::System.IntPtr.Zero : Context.__Instance;
                var __ret = Internal.getNonLValueExprType_0(__Instance, arg0);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>getDesugaredType - Return the specified type with any
            /// &quot;sugar&quot; removed from the type. This takes off typedefs, typeof's
            /// etc. If the outer level of the type is already concrete, it returns it
            /// unmodified. This is similar to getting the canonical type, but it doesn't
            /// remove *all* typedefs. For example, it returns &quot;T*&quot; as
            /// &quot;T*&quot;, (not as &quot;int*&quot;), because the pointer is
            /// concrete.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getDesugaredType - Return the specified type with any
            /// &quot;sugar&quot; removed from</para>
            /// <para>  /// the type.  This takes off typedefs, typeof's etc.  If the
            /// outer level of</para>
            /// <para>  /// the type is already concrete, it returns it unmodified.
            /// This is similar</para>
            /// <para>  /// to getting the canonical type, but it doesn't remove *all*
            /// typedefs.  For</para>
            /// <para>  /// example, it returns &quot;T*&quot; as &quot;T*&quot;, (not
            /// as &quot;int*&quot;), because the pointer is</para>
            /// <para>  /// concrete.</para>
            /// <para>  ///</para>
            /// <para>  /// Qualifiers are left in place.</para>
            /// </remarks>
            public clang.QualType getDesugaredType(clang.ASTContext Context)
            {
                var arg0 = ReferenceEquals(Context, null) ? global::System.IntPtr.Zero : Context.__Instance;
                var __ret = Internal.getDesugaredType_0(__Instance, arg0);
                return clang.QualType.__CreateInstance(__ret);
            }

            public clang.SplitQualType getSplitDesugaredType()
            {
                var __ret = Internal.getSplitDesugaredType_0(__Instance);
                return clang.SplitQualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Return the specified type with one level of &quot;sugar&quot;
            /// removed from the type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the specified type with one level of
            /// &quot;sugar&quot; removed from</para>
            /// <para>  /// the type.</para>
            /// <para>  ///</para>
            /// <para>  /// This routine takes off the first typedef, typeof, etc. If
            /// the outer level</para>
            /// <para>  /// of the type is already concrete, it returns it
            /// unmodified.</para>
            /// </remarks>
            public clang.QualType getSingleStepDesugaredType(clang.ASTContext Context)
            {
                var arg0 = ReferenceEquals(Context, null) ? global::System.IntPtr.Zero : Context.__Instance;
                var __ret = Internal.getSingleStepDesugaredType_0(__Instance, arg0);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>IgnoreParens - Returns the specified type after dropping any
            /// outer-level parentheses.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// IgnoreParens - Returns the specified type after dropping
            /// any</para>
            /// <para>  /// outer-level parentheses.</para>
            /// </remarks>
            public clang.QualType IgnoreParens()
            {
                var __ret = Internal.IgnoreParens_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            public void print(llvm.raw_ostream OS, clang.PrintingPolicy Policy, llvm.Twine PlaceHolder)
            {
                var arg0 = ReferenceEquals(OS, null) ? global::System.IntPtr.Zero : OS.__Instance;
                var arg1 = ReferenceEquals(Policy, null) ? global::System.IntPtr.Zero : Policy.__Instance;
                var arg2 = ReferenceEquals(PlaceHolder, null) ? global::System.IntPtr.Zero : PlaceHolder.__Instance;
                Internal.print_0(__Instance, arg0, arg1, arg2);
            }

            public clang.QualType.StreamedQualTypeHelper stream(clang.PrintingPolicy Policy, llvm.Twine PlaceHolder)
            {
                var arg0 = ReferenceEquals(Policy, null) ? global::System.IntPtr.Zero : Policy.__Instance;
                var arg1 = ReferenceEquals(PlaceHolder, null) ? global::System.IntPtr.Zero : PlaceHolder.__Instance;
                var __ret = new clang.QualType.StreamedQualTypeHelper.Internal();
                Internal.stream_0(new IntPtr(&__ret), __Instance, arg0, arg1);
                return clang.QualType.StreamedQualTypeHelper.__CreateInstance(__ret);
            }

            public void dump(string s)
            {
                var arg0 = Marshal.StringToHGlobalAnsi(s);
                Internal.dump_0(__Instance, arg0);
                Marshal.FreeHGlobal(arg0);
            }

            public void dump()
            {
                Internal.dump_1(__Instance);
            }

            public void Profile(llvm.FoldingSetNodeID ID)
            {
                var arg0 = ReferenceEquals(ID, null) ? global::System.IntPtr.Zero : ID.__Instance;
                Internal.Profile_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>getAddressSpace - Return the address space of this type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getAddressSpace - Return the address space of this
            /// type.</para>
            /// </remarks>
            public uint getAddressSpace()
            {
                var __ret = Internal.getAddressSpace_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>getObjCGCAttr - Returns gc attribute of this type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getObjCGCAttr - Returns gc attribute of this type.</para>
            /// </remarks>
            public clang.Qualifiers.GC getObjCGCAttr()
            {
                var __ret = Internal.getObjCGCAttr_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>isObjCGCWeak true when Type is objc's weak.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// isObjCGCWeak true when Type is objc's weak.</para>
            /// </remarks>
            public bool isObjCGCWeak()
            {
                var __ret = Internal.isObjCGCWeak_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>isObjCGCStrong true when Type is objc's strong.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// isObjCGCStrong true when Type is objc's strong.</para>
            /// </remarks>
            public bool isObjCGCStrong()
            {
                var __ret = Internal.isObjCGCStrong_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>getObjCLifetime - Returns lifetime attribute of this type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getObjCLifetime - Returns lifetime attribute of this
            /// type.</para>
            /// </remarks>
            public clang.Qualifiers.ObjCLifetime getObjCLifetime()
            {
                var __ret = Internal.getObjCLifetime_0(__Instance);
                return __ret;
            }

            public bool hasNonTrivialObjCLifetime()
            {
                var __ret = Internal.hasNonTrivialObjCLifetime_0(__Instance);
                return __ret;
            }

            public bool hasStrongOrWeakObjCLifetime()
            {
                var __ret = Internal.hasStrongOrWeakObjCLifetime_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>isDestructedType - nonzero if objects of this type require
            /// non-trivial work to clean up after. Non-zero because it's conceivable that
            /// qualifiers (objc_gc(weak)?) could make something require
            /// destruction.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// isDestructedType - nonzero if objects of this type
            /// require</para>
            /// <para>  /// non-trivial work to clean up after.  Non-zero because
            /// it's</para>
            /// <para>  /// conceivable that qualifiers (objc_gc(weak)?) could
            /// make</para>
            /// <para>  /// something require destruction.</para>
            /// </remarks>
            public clang.QualType.DestructionKind isDestructedType()
            {
                var __ret = Internal.isDestructedType_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determine whether expressions of the given type are forbidden
            /// from being lvalues in C.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine whether expressions of the given type are
            /// forbidden</para>
            /// <para>  /// from being lvalues in C.</para>
            /// <para>  ///</para>
            /// <para>  /// The expression types that are forbidden to be lvalues
            /// are:</para>
            /// <para>  ///   - 'void', but not qualified void</para>
            /// <para>  ///   - function types</para>
            /// <para>  ///</para>
            /// <para>  /// The exact rule here is C99 6.3.2.1:</para>
            /// <para>  ///   An lvalue is an expression with an object type or an
            /// incomplete</para>
            /// <para>  ///   type other than void.</para>
            /// </remarks>
            public bool isCForbiddenLValueType()
            {
                var __ret = Internal.isCForbiddenLValueType_0(__Instance);
                return __ret;
            }

            public static clang.QualType getFromOpaquePtr(global::System.IntPtr Ptr)
            {
                var arg0 = Ptr;
                var __ret = Internal.getFromOpaquePtr_0(arg0);
                return clang.QualType.__CreateInstance(__ret);
            }

            public static void print(clang.SplitQualType split, llvm.raw_ostream OS, clang.PrintingPolicy policy, llvm.Twine PlaceHolder)
            {
                var arg0 = ReferenceEquals(split, null) ? new clang.SplitQualType.Internal() : *(clang.SplitQualType.Internal*) (split.__Instance);
                var arg1 = ReferenceEquals(OS, null) ? global::System.IntPtr.Zero : OS.__Instance;
                var arg2 = ReferenceEquals(policy, null) ? global::System.IntPtr.Zero : policy.__Instance;
                var arg3 = ReferenceEquals(PlaceHolder, null) ? global::System.IntPtr.Zero : PlaceHolder.__Instance;
                Internal.print_1(arg0, arg1, arg2, arg3);
            }

            public static void print(clang.Type ty, clang.Qualifiers qs, llvm.raw_ostream OS, clang.PrintingPolicy policy, llvm.Twine PlaceHolder)
            {
                var arg0 = ReferenceEquals(ty, null) ? global::System.IntPtr.Zero : ty.__Instance;
                var arg1 = ReferenceEquals(qs, null) ? new clang.Qualifiers.Internal() : *(clang.Qualifiers.Internal*) (qs.__Instance);
                var arg2 = ReferenceEquals(OS, null) ? global::System.IntPtr.Zero : OS.__Instance;
                var arg3 = ReferenceEquals(policy, null) ? global::System.IntPtr.Zero : policy.__Instance;
                var arg4 = ReferenceEquals(PlaceHolder, null) ? global::System.IntPtr.Zero : PlaceHolder.__Instance;
                Internal.print_2(arg0, arg1, arg2, arg3, arg4);
            }

            /// <summary>
            /// <para>operator==/!= - Indicate whether the specified types and
            /// qualifiers are identical.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// operator==/!= - Indicate whether the specified types and
            /// qualifiers are</para>
            /// <para>  /// identical.</para>
            /// </remarks>
            public static bool operator ==(clang.QualType LHS, clang.QualType RHS)
            {
                bool LHSNull = ReferenceEquals(LHS, null);
                bool RHSNull = ReferenceEquals(RHS, null);
                if (LHSNull || RHSNull)
                    return LHSNull && RHSNull;
                var arg0 = LHS.__Instance;
                var arg1 = RHS.__Instance;
                var __ret = Internal.OperatorEqualEqual_0(arg0, arg1);
                return __ret;
            }

            public override bool Equals(object obj)
            {
                return this == obj as QualType;
            }

            public static bool operator !=(clang.QualType LHS, clang.QualType RHS)
            {
                var arg0 = ReferenceEquals(LHS, null) ? global::System.IntPtr.Zero : LHS.__Instance;
                var arg1 = ReferenceEquals(RHS, null) ? global::System.IntPtr.Zero : RHS.__Instance;
                var __ret = Internal.OperatorExclaimEqual_0(arg0, arg1);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Base class that is common to both the ExtQuals and Type classes,
        /// which allows QualType to access the common fields between the two.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief Base class that is common to both the \c ExtQuals and
        /// \c Type</para>
        /// <para>/// classes, which allows \c QualType to access the common fields
        /// between the</para>
        /// <para>/// two.</para>
        /// <para>///</para>
        /// </remarks>
        public unsafe partial class ExtQualsTypeCommonBase : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr BaseType;

                [FieldOffset(8)]
                public clang.QualType.Internal CanonicalType;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang22ExtQualsTypeCommonBaseC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ExtQualsTypeCommonBase> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ExtQualsTypeCommonBase>();

            private readonly bool __ownsNativeInstance;

            public static ExtQualsTypeCommonBase __CreateInstance(global::System.IntPtr native)
            {
                return new ExtQualsTypeCommonBase((ExtQualsTypeCommonBase.Internal*) native);
            }

            public static ExtQualsTypeCommonBase __CreateInstance(ExtQualsTypeCommonBase.Internal native)
            {
                return new ExtQualsTypeCommonBase(native);
            }

            private static ExtQualsTypeCommonBase.Internal* __CopyValue(ExtQualsTypeCommonBase.Internal native)
            {
                var ret = (ExtQualsTypeCommonBase.Internal*) Marshal.AllocHGlobal(16);
                *ret = native;
                return ret;
            }

            private ExtQualsTypeCommonBase(ExtQualsTypeCommonBase.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected ExtQualsTypeCommonBase(ExtQualsTypeCommonBase.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.ExtQualsTypeCommonBase __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>ExtQuals - We can encode up to four bits in the low bits of a
        /// type pointer, but there are many more type qualifiers that we want to be
        /// able to apply to an arbitrary type. Therefore we have this struct, intended
        /// to be heap-allocated and used by QualType to store qualifiers.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// ExtQuals - We can encode up to four bits in the low bits of
        /// a</para>
        /// <para>/// type pointer, but there are many more type qualifiers that we
        /// want</para>
        /// <para>/// to be able to apply to an arbitrary type.  Therefore we have
        /// this</para>
        /// <para>/// struct, intended to be heap-allocated and used by QualType
        /// to</para>
        /// <para>/// store qualifiers.</para>
        /// <para>///</para>
        /// <para>/// The current design tags the 'const', 'restrict', and
        /// 'volatile' qualifiers</para>
        /// <para>/// in three low bits on the QualType pointer; a fourth bit
        /// records whether</para>
        /// <para>/// the pointer is an ExtQuals node. The extended qualifiers
        /// (address spaces,</para>
        /// <para>/// Objective-C GC attributes) are much more rare.</para>
        /// </remarks>
        public unsafe partial class ExtQuals : clang.ExtQualsTypeCommonBase, llvm.FoldingSetImpl.Node, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 32)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr BaseType;

                [FieldOffset(8)]
                public clang.QualType.Internal CanonicalType;

                [FieldOffset(0)]
                public global::System.IntPtr NextInFoldingSetBucket;

                [FieldOffset(24)]
                public clang.Qualifiers.Internal Quals;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8ExtQualsC2EPKNS_4TypeENS_8QualTypeENS_10QualifiersE")]
                internal static extern void ctor_0(global::System.IntPtr instance, global::System.IntPtr baseType, clang.QualType.Internal canon, clang.Qualifiers.Internal quals);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8ExtQualsC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8ExtQuals13getQualifiersEv")]
                internal static extern clang.Qualifiers.Internal getQualifiers_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8ExtQuals13hasObjCGCAttrEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasObjCGCAttr_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8ExtQuals13getObjCGCAttrEv")]
                internal static extern clang.Qualifiers.GC getObjCGCAttr_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8ExtQuals15hasObjCLifetimeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasObjCLifetime_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8ExtQuals15getObjCLifetimeEv")]
                internal static extern clang.Qualifiers.ObjCLifetime getObjCLifetime_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8ExtQuals15hasAddressSpaceEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasAddressSpace_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8ExtQuals15getAddressSpaceEv")]
                internal static extern uint getAddressSpace_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8ExtQuals11getBaseTypeEv")]
                internal static extern global::System.IntPtr getBaseType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8ExtQuals7ProfileERN4llvm16FoldingSetNodeIDE")]
                internal static extern void Profile_0(global::System.IntPtr instance, global::System.IntPtr ID);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8ExtQuals7ProfileERN4llvm16FoldingSetNodeIDEPKNS_4TypeENS_10QualifiersE")]
                internal static extern void Profile_1(global::System.IntPtr ID, global::System.IntPtr BaseType, clang.Qualifiers.Internal Quals);
            }

            private readonly bool __ownsNativeInstance;

            public static new ExtQuals __CreateInstance(global::System.IntPtr native)
            {
                return new ExtQuals((ExtQuals.Internal*) native);
            }

            public static ExtQuals __CreateInstance(ExtQuals.Internal native)
            {
                return new ExtQuals(native);
            }

            private static ExtQuals.Internal* __CopyValue(ExtQuals.Internal native)
            {
                var ret = (ExtQuals.Internal*) Marshal.AllocHGlobal(32);
                *ret = native;
                return ret;
            }

            private ExtQuals(ExtQuals.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected ExtQuals(ExtQuals.Internal* native, bool isInternalImpl = false)
                : base((clang.ExtQualsTypeCommonBase.Internal*) native)
            {
            }

            public ExtQuals(clang.Type baseType, clang.QualType canon, clang.Qualifiers quals)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(32);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(baseType, null) ? global::System.IntPtr.Zero : baseType.__Instance;
                var arg1 = ReferenceEquals(canon, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (canon.__Instance);
                var arg2 = ReferenceEquals(quals, null) ? new clang.Qualifiers.Internal() : *(clang.Qualifiers.Internal*) (quals.__Instance);
                Internal.ctor_0(__Instance, arg0, arg1, arg2);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.ExtQualsTypeCommonBase __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.Qualifiers getQualifiers()
            {
                var __ret = Internal.getQualifiers_0(__Instance);
                return clang.Qualifiers.__CreateInstance(__ret);
            }

            public bool hasObjCGCAttr()
            {
                var __ret = Internal.hasObjCGCAttr_0(__Instance);
                return __ret;
            }

            public clang.Qualifiers.GC getObjCGCAttr()
            {
                var __ret = Internal.getObjCGCAttr_0(__Instance);
                return __ret;
            }

            public bool hasObjCLifetime()
            {
                var __ret = Internal.hasObjCLifetime_0(__Instance);
                return __ret;
            }

            public clang.Qualifiers.ObjCLifetime getObjCLifetime()
            {
                var __ret = Internal.getObjCLifetime_0(__Instance);
                return __ret;
            }

            public bool hasAddressSpace()
            {
                var __ret = Internal.hasAddressSpace_0(__Instance);
                return __ret;
            }

            public uint getAddressSpace()
            {
                var __ret = Internal.getAddressSpace_0(__Instance);
                return __ret;
            }

            public clang.Type getBaseType()
            {
                var __ret = Internal.getBaseType_0(__Instance);
                clang.Type __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Type.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Type) clang.Type.NativeToManagedMap[__ret];
                else __result0 = clang.Type.__CreateInstance(__ret);
                return __result0;
            }

            public void Profile(llvm.FoldingSetNodeID ID)
            {
                var arg0 = ReferenceEquals(ID, null) ? global::System.IntPtr.Zero : ID.__Instance;
                Internal.Profile_0(__Instance, arg0);
            }

            public static void Profile(llvm.FoldingSetNodeID ID, clang.Type BaseType, clang.Qualifiers Quals)
            {
                var arg0 = ReferenceEquals(ID, null) ? global::System.IntPtr.Zero : ID.__Instance;
                var arg1 = ReferenceEquals(BaseType, null) ? global::System.IntPtr.Zero : BaseType.__Instance;
                var arg2 = ReferenceEquals(Quals, null) ? new clang.Qualifiers.Internal() : *(clang.Qualifiers.Internal*) (Quals.__Instance);
                Internal.Profile_1(arg0, arg1, arg2);
            }
        }

        /// <summary>
        /// <para>Type - This is the base class of the type hierarchy. A central
        /// concept with types is that each type always has a canonical type. A
        /// canonical type is the type with any typedef names stripped out of it or the
        /// types it references. For example, consider:</para>
        /// </summary>
        /// <remarks>
        /// <para>/// Type - This is the base class of the type hierarchy.  A
        /// central concept</para>
        /// <para>/// with types is that each type always has a canonical type.  A
        /// canonical type</para>
        /// <para>/// is the type with any typedef names stripped out of it or the
        /// types it</para>
        /// <para>/// references.  For example, consider:</para>
        /// <para>///</para>
        /// <para>///  typedef int  foo;</para>
        /// <para>///  typedef foo* bar;</para>
        /// <para>///    'int *'    'foo *'    'bar'</para>
        /// <para>///</para>
        /// <para>/// There will be a Type object created for 'int'.  Since int is
        /// canonical, its</para>
        /// <para>/// canonicaltype pointer points to itself.  There is also a Type
        /// for 'foo' (a</para>
        /// <para>/// TypedefType).  Its CanonicalType pointer points to the 'int'
        /// Type.  Next</para>
        /// <para>/// there is a PointerType that represents 'int*', which, like
        /// 'int', is</para>
        /// <para>/// canonical.  Finally, there is a PointerType type for 'foo*'
        /// whose canonical</para>
        /// <para>/// type is 'int*', and there is a TypedefType for 'bar', whose
        /// canonical type</para>
        /// <para>/// is also 'int*'.</para>
        /// <para>///</para>
        /// <para>/// Non-canonical types are useful for emitting diagnostics,
        /// without losing</para>
        /// <para>/// information about typedefs being used.  Canonical types are
        /// useful for type</para>
        /// <para>/// comparisons (they allow by-pointer equality tests) and useful
        /// for reasoning</para>
        /// <para>/// about whether something has a particular form (e.g. is a
        /// function type),</para>
        /// <para>/// because they implicitly, recursively, strip all typedefs out
        /// of a type.</para>
        /// <para>///</para>
        /// <para>/// Types, once created, are immutable.</para>
        /// <para>///</para>
        /// </remarks>
        public unsafe partial class Type : clang.ExtQualsTypeCommonBase, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 24)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr BaseType;

                [FieldOffset(8)]
                public clang.QualType.Internal CanonicalType;

                [FieldOffset(16)]
                internal clang.Type._.Internal __;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang4TypeC2ENS0_9TypeClassENS_8QualTypeEbbbb")]
                internal static extern void ctor_1(global::System.IntPtr instance, clang.Type.TypeClass tc, clang.QualType.Internal canon, bool Dependent, bool InstantiationDependent, bool VariablyModified, bool ContainsUnexpandedParameterPack);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang4Type5this_Ev")]
                internal static extern global::System.IntPtr this__0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang4Type12setDependentEb")]
                internal static extern void setDependent_0(global::System.IntPtr instance, bool D);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang4Type25setInstantiationDependentEb")]
                internal static extern void setInstantiationDependent_0(global::System.IntPtr instance, bool D);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang4Type19setVariablyModifiedEb")]
                internal static extern void setVariablyModified_0(global::System.IntPtr instance, bool VM);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang4Type34setContainsUnexpandedParameterPackEb")]
                internal static extern void setContainsUnexpandedParameterPack_0(global::System.IntPtr instance, bool PP);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type12getTypeClassEv")]
                internal static extern clang.Type.TypeClass getTypeClass_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type9isFromASTEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isFromAST_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type31containsUnexpandedParameterPackEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool containsUnexpandedParameterPack_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type22isCanonicalUnqualifiedEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isCanonicalUnqualified_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type44getLocallyUnqualifiedSingleStepDesugaredTypeEv")]
                internal static extern clang.QualType.Internal getLocallyUnqualifiedSingleStepDesugaredType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type16isIncompleteTypeEPPNS_9NamedDeclE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isIncompleteType_0(global::System.IntPtr instance, global::System.IntPtr Def);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type24isIncompleteOrObjectTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isIncompleteOrObjectType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type12isObjectTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isObjectType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type13isLiteralTypeERKNS_10ASTContextE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isLiteralType_0(global::System.IntPtr instance, global::System.IntPtr Ctx);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type20isStandardLayoutTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isStandardLayoutType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type13isBuiltinTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isBuiltinType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type21isSpecificBuiltinTypeEj")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isSpecificBuiltinType_0(global::System.IntPtr instance, uint K);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type17isPlaceholderTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isPlaceholderType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type20getAsPlaceholderTypeEv")]
                internal static extern global::System.IntPtr getAsPlaceholderType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type25isSpecificPlaceholderTypeEj")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isSpecificPlaceholderType_0(global::System.IntPtr instance, uint K);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type28isNonOverloadPlaceholderTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isNonOverloadPlaceholderType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type13isIntegerTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isIntegerType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type14isEnumeralTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isEnumeralType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type13isBooleanTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isBooleanType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type10isCharTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isCharType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type14isWideCharTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isWideCharType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type12isChar16TypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isChar16Type_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type12isChar32TypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isChar32Type_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type18isAnyCharacterTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isAnyCharacterType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type14isIntegralTypeERNS_10ASTContextE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isIntegralType_0(global::System.IntPtr instance, global::System.IntPtr Ctx);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type27isIntegralOrEnumerationTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isIntegralOrEnumerationType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type35isIntegralOrUnscopedEnumerationTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isIntegralOrUnscopedEnumerationType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type18isRealFloatingTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isRealFloatingType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type13isComplexTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isComplexType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type16isAnyComplexTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isAnyComplexType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type14isFloatingTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isFloatingType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type10isHalfTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isHalfType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type10isRealTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isRealType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type16isArithmeticTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isArithmeticType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type10isVoidTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isVoidType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type12isScalarTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isScalarType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type15isAggregateTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isAggregateType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type17isFundamentalTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isFundamentalType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type14isCompoundTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isCompoundType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type14isFunctionTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isFunctionType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type21isFunctionNoProtoTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isFunctionNoProtoType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type19isFunctionProtoTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isFunctionProtoType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type13isPointerTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isPointerType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type16isAnyPointerTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isAnyPointerType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type18isBlockPointerTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isBlockPointerType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type17isVoidPointerTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isVoidPointerType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type15isReferenceTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isReferenceType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type21isLValueReferenceTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isLValueReferenceType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type21isRValueReferenceTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isRValueReferenceType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type21isFunctionPointerTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isFunctionPointerType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type19isMemberPointerTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isMemberPointerType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type27isMemberFunctionPointerTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isMemberFunctionPointerType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type23isMemberDataPointerTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isMemberDataPointerType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type11isArrayTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isArrayType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type19isConstantArrayTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isConstantArrayType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type21isIncompleteArrayTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isIncompleteArrayType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type19isVariableArrayTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isVariableArrayType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type25isDependentSizedArrayTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isDependentSizedArrayType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type12isRecordTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isRecordType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type11isClassTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isClassType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type15isStructureTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isStructureType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type15isInterfaceTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isInterfaceType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type22isStructureOrClassTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isStructureOrClassType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type11isUnionTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isUnionType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type20isComplexIntegerTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isComplexIntegerType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type12isVectorTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isVectorType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type15isExtVectorTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isExtVectorType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type23isObjCObjectPointerTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isObjCObjectPointerType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type20isObjCRetainableTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isObjCRetainableType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type18isObjCLifetimeTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isObjCLifetimeType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type26isObjCIndirectLifetimeTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isObjCIndirectLifetimeType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type18isObjCNSObjectTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isObjCNSObjectType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type16isObjCObjectTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isObjCObjectType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type28isObjCQualifiedInterfaceTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isObjCQualifiedInterfaceType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type21isObjCQualifiedIdTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isObjCQualifiedIdType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type24isObjCQualifiedClassTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isObjCQualifiedClassType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type27isObjCObjectOrInterfaceTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isObjCObjectOrInterfaceType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type12isObjCIdTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isObjCIdType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type15isObjCClassTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isObjCClassType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type13isObjCSelTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isObjCSelType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type17isObjCBuiltinTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isObjCBuiltinType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type22isObjCARCBridgableTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isObjCARCBridgableType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type19isCARCBridgableTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isCARCBridgableType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type22isTemplateTypeParmTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isTemplateTypeParmType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type13isNullPtrTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isNullPtrType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type12isAtomicTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isAtomicType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type10isImage1dTEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isImage1dT_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type15isImage1dArrayTEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isImage1dArrayT_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type16isImage1dBufferTEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isImage1dBufferT_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type10isImage2dTEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isImage2dT_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type15isImage2dArrayTEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isImage2dArrayT_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type10isImage3dTEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isImage3dT_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type11isImageTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isImageType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type10isSamplerTEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isSamplerT_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type8isEventTEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isEventT_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type20isOpenCLSpecificTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isOpenCLSpecificType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type33isObjCARCImplicitlyUnretainedTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isObjCARCImplicitlyUnretainedType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type26getObjCARCImplicitLifetimeEv")]
                internal static extern clang.Qualifiers.ObjCLifetime getObjCARCImplicitLifetime_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type17getScalarTypeKindEv")]
                internal static extern clang.Type.ScalarTypeKind getScalarTypeKind_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type15isDependentTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isDependentType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type28isInstantiationDependentTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isInstantiationDependentType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type15isUndeducedTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isUndeducedType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type22isVariablyModifiedTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isVariablyModifiedType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type15hasSizedVLATypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasSizedVLAType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type21hasUnnamedOrLocalTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasUnnamedOrLocalType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type18isOverloadableTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isOverloadableType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type25isElaboratedTypeSpecifierEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isElaboratedTypeSpecifier_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type21canDecayToPointerTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool canDecayToPointerType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type24hasPointerRepresentationEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasPointerRepresentation_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type28hasObjCPointerRepresentationEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasObjCPointerRepresentation_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type24hasIntegerRepresentationEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasIntegerRepresentation_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type30hasSignedIntegerRepresentationEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasSignedIntegerRepresentation_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type32hasUnsignedIntegerRepresentationEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasUnsignedIntegerRepresentation_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type25hasFloatingRepresentationEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasFloatingRepresentation_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type18getAsStructureTypeEv")]
                internal static extern global::System.IntPtr getAsStructureType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type14getAsUnionTypeEv")]
                internal static extern global::System.IntPtr getAsUnionType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type23getAsComplexIntegerTypeEv")]
                internal static extern global::System.IntPtr getAsComplexIntegerType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type29getAsObjCInterfacePointerTypeEv")]
                internal static extern global::System.IntPtr getAsObjCInterfacePointerType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type24getAsObjCQualifiedIdTypeEv")]
                internal static extern global::System.IntPtr getAsObjCQualifiedIdType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type27getAsObjCQualifiedClassTypeEv")]
                internal static extern global::System.IntPtr getAsObjCQualifiedClassType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type31getAsObjCQualifiedInterfaceTypeEv")]
                internal static extern global::System.IntPtr getAsObjCQualifiedInterfaceType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type12getAsTagDeclEv")]
                internal static extern global::System.IntPtr getAsTagDecl_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type20getContainedAutoTypeEv")]
                internal static extern global::System.IntPtr getContainedAutoType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type20getAsArrayTypeUnsafeEv")]
                internal static extern global::System.IntPtr getAsArrayTypeUnsafe_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type21castAsArrayTypeUnsafeEv")]
                internal static extern global::System.IntPtr castAsArrayTypeUnsafe_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type24getBaseElementTypeUnsafeEv")]
                internal static extern global::System.IntPtr getBaseElementTypeUnsafe_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type29getArrayElementTypeNoTypeQualEv")]
                internal static extern global::System.IntPtr getArrayElementTypeNoTypeQual_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type14getPointeeTypeEv")]
                internal static extern clang.QualType.Internal getPointeeType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type27getUnqualifiedDesugaredTypeEv")]
                internal static extern global::System.IntPtr getUnqualifiedDesugaredType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type23isPromotableIntegerTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isPromotableIntegerType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type19isSignedIntegerTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isSignedIntegerType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type21isUnsignedIntegerTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isUnsignedIntegerType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type32isSignedIntegerOrEnumerationTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isSignedIntegerOrEnumerationType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type34isUnsignedIntegerOrEnumerationTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isUnsignedIntegerOrEnumerationType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type18isConstantSizeTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isConstantSizeType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type15isSpecifierTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isSpecifierType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type10getLinkageEv")]
                internal static extern clang.Linkage getLinkage_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type13getVisibilityEv")]
                internal static extern clang.Visibility getVisibility_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type20isVisibilityExplicitEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isVisibilityExplicit_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type23getLinkageAndVisibilityEv")]
                internal static extern clang.LinkageInfo.Internal getLinkageAndVisibility_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type14isLinkageValidEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isLinkageValid_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type16getTypeClassNameEv")]
                internal static extern global::System.IntPtr getTypeClassName_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type24getCanonicalTypeInternalEv")]
                internal static extern clang.QualType.Internal getCanonicalTypeInternal_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang4Type4dumpEv")]
                internal static extern void dump_0(global::System.IntPtr instance);
            }

            public enum TypeClass : uint
            {
                Builtin = 0,
                Complex = 1,
                Pointer = 2,
                BlockPointer = 3,
                LValueReference = 4,
                RValueReference = 5,
                MemberPointer = 6,
                ConstantArray = 7,
                IncompleteArray = 8,
                VariableArray = 9,
                DependentSizedArray = 10,
                DependentSizedExtVector = 11,
                Vector = 12,
                ExtVector = 13,
                FunctionProto = 14,
                FunctionNoProto = 15,
                UnresolvedUsing = 16,
                Paren = 17,
                Typedef = 18,
                Adjusted = 19,
                Decayed = 20,
                TypeOfExpr = 21,
                TypeOf = 22,
                Decltype = 23,
                UnaryTransform = 24,
                Record = 25,
                Enum = 26,
                Elaborated = 27,
                Attributed = 28,
                TemplateTypeParm = 29,
                SubstTemplateTypeParm = 30,
                SubstTemplateTypeParmPack = 31,
                TemplateSpecialization = 32,
                Auto = 33,
                InjectedClassName = 34,
                DependentName = 35,
                DependentTemplateSpecialization = 36,
                PackExpansion = 37,
                ObjCObject = 38,
                ObjCInterface = 39,
                ObjCObjectPointer = 40,
                Atomic = 41,
                TypeLast = 41,
                TagFirst = 25,
                TagLast = 26
            }

            public enum ScalarTypeKind : uint
            {
                STK_CPointer = 0,
                STK_BlockPointer = 1,
                STK_ObjCObjectPointer = 2,
                STK_MemberPointer = 3,
                STK_Bool = 4,
                STK_Integral = 5,
                STK_Floating = 6,
                STK_IntegralComplex = 7,
                STK_FloatingComplex = 8
            }

            /// <summary>
            /// <para>Bitfields required by the Type class.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Bitfields required by the Type class.</para>
            /// </remarks>
            internal unsafe partial class TypeBitfields
            {
                [StructLayout(LayoutKind.Explicit, Size = 4)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public uint TC;

                    [FieldOffset(1)]
                    public uint Dependent;

                    [FieldOffset(1)]
                    public uint InstantiationDependent;

                    [FieldOffset(1)]
                    public uint VariablyModified;

                    [FieldOffset(1)]
                    public uint ContainsUnexpandedParameterPack;

                    [FieldOffset(1)]
                    public uint CacheValid;

                    [FieldOffset(1)]
                    public uint CachedLinkage;

                    [FieldOffset(2)]
                    public uint CachedLocalOrUnnamed;

                    [FieldOffset(2)]
                    public uint FromAST;
                }
            }

            protected internal unsafe partial class ArrayTypeBitfields : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 4)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public uint _0;

                    [FieldOffset(2)]
                    public uint IndexTypeQuals;

                    [FieldOffset(2)]
                    public uint SizeModifier;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang4Type18ArrayTypeBitfieldsC2ERKS1_")]
                    internal static extern void cctor_0(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ArrayTypeBitfields> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ArrayTypeBitfields>();

                private readonly bool __ownsNativeInstance;

                public static ArrayTypeBitfields __CreateInstance(global::System.IntPtr native)
                {
                    return new ArrayTypeBitfields((ArrayTypeBitfields.Internal*) native);
                }

                public static ArrayTypeBitfields __CreateInstance(ArrayTypeBitfields.Internal native)
                {
                    return new ArrayTypeBitfields(native);
                }

                private static ArrayTypeBitfields.Internal* __CopyValue(ArrayTypeBitfields.Internal native)
                {
                    var ret = (ArrayTypeBitfields.Internal*) Marshal.AllocHGlobal(4);
                    *ret = native;
                    return ret;
                }

                private ArrayTypeBitfields(ArrayTypeBitfields.Internal native)
                    : this(__CopyValue(native))
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected ArrayTypeBitfields(ArrayTypeBitfields.Internal* native, bool isInternalImpl = false)
                {
                    __Instance = new global::System.IntPtr(native);
                }

                public ArrayTypeBitfields()
                {
                    __Instance = Marshal.AllocHGlobal(4);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    DestroyNativeInstance(false);
                }

                public virtual void DestroyNativeInstance()
                {
                    DestroyNativeInstance(true);
                }

                private void DestroyNativeInstance(bool force)
                {
                    clang.Type.ArrayTypeBitfields __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }
            }

            protected internal unsafe partial class BuiltinTypeBitfields : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 4)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public uint _0;

                    [FieldOffset(2)]
                    public uint Kind;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang4Type20BuiltinTypeBitfieldsC2ERKS1_")]
                    internal static extern void cctor_0(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, BuiltinTypeBitfields> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, BuiltinTypeBitfields>();

                private readonly bool __ownsNativeInstance;

                public static BuiltinTypeBitfields __CreateInstance(global::System.IntPtr native)
                {
                    return new BuiltinTypeBitfields((BuiltinTypeBitfields.Internal*) native);
                }

                public static BuiltinTypeBitfields __CreateInstance(BuiltinTypeBitfields.Internal native)
                {
                    return new BuiltinTypeBitfields(native);
                }

                private static BuiltinTypeBitfields.Internal* __CopyValue(BuiltinTypeBitfields.Internal native)
                {
                    var ret = (BuiltinTypeBitfields.Internal*) Marshal.AllocHGlobal(4);
                    *ret = native;
                    return ret;
                }

                private BuiltinTypeBitfields(BuiltinTypeBitfields.Internal native)
                    : this(__CopyValue(native))
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected BuiltinTypeBitfields(BuiltinTypeBitfields.Internal* native, bool isInternalImpl = false)
                {
                    __Instance = new global::System.IntPtr(native);
                }

                public BuiltinTypeBitfields()
                {
                    __Instance = Marshal.AllocHGlobal(4);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    DestroyNativeInstance(false);
                }

                public virtual void DestroyNativeInstance()
                {
                    DestroyNativeInstance(true);
                }

                private void DestroyNativeInstance(bool force)
                {
                    clang.Type.BuiltinTypeBitfields __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }
            }

            protected internal unsafe partial class FunctionTypeBitfields : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 4)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public uint _0;

                    [FieldOffset(2)]
                    public uint ExtInfo;

                    [FieldOffset(3)]
                    public uint TypeQuals;

                    [FieldOffset(3)]
                    public uint RefQualifier;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang4Type21FunctionTypeBitfieldsC2ERKS1_")]
                    internal static extern void cctor_0(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, FunctionTypeBitfields> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, FunctionTypeBitfields>();

                private readonly bool __ownsNativeInstance;

                public static FunctionTypeBitfields __CreateInstance(global::System.IntPtr native)
                {
                    return new FunctionTypeBitfields((FunctionTypeBitfields.Internal*) native);
                }

                public static FunctionTypeBitfields __CreateInstance(FunctionTypeBitfields.Internal native)
                {
                    return new FunctionTypeBitfields(native);
                }

                private static FunctionTypeBitfields.Internal* __CopyValue(FunctionTypeBitfields.Internal native)
                {
                    var ret = (FunctionTypeBitfields.Internal*) Marshal.AllocHGlobal(4);
                    *ret = native;
                    return ret;
                }

                private FunctionTypeBitfields(FunctionTypeBitfields.Internal native)
                    : this(__CopyValue(native))
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected FunctionTypeBitfields(FunctionTypeBitfields.Internal* native, bool isInternalImpl = false)
                {
                    __Instance = new global::System.IntPtr(native);
                }

                public FunctionTypeBitfields()
                {
                    __Instance = Marshal.AllocHGlobal(4);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    DestroyNativeInstance(false);
                }

                public virtual void DestroyNativeInstance()
                {
                    DestroyNativeInstance(true);
                }

                private void DestroyNativeInstance(bool force)
                {
                    clang.Type.FunctionTypeBitfields __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }
            }

            protected internal unsafe partial class ObjCObjectTypeBitfields : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 4)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public uint _0;

                    [FieldOffset(2)]
                    public uint NumProtocols;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang4Type23ObjCObjectTypeBitfieldsC2ERKS1_")]
                    internal static extern void cctor_0(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ObjCObjectTypeBitfields> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ObjCObjectTypeBitfields>();

                private readonly bool __ownsNativeInstance;

                public static ObjCObjectTypeBitfields __CreateInstance(global::System.IntPtr native)
                {
                    return new ObjCObjectTypeBitfields((ObjCObjectTypeBitfields.Internal*) native);
                }

                public static ObjCObjectTypeBitfields __CreateInstance(ObjCObjectTypeBitfields.Internal native)
                {
                    return new ObjCObjectTypeBitfields(native);
                }

                private static ObjCObjectTypeBitfields.Internal* __CopyValue(ObjCObjectTypeBitfields.Internal native)
                {
                    var ret = (ObjCObjectTypeBitfields.Internal*) Marshal.AllocHGlobal(4);
                    *ret = native;
                    return ret;
                }

                private ObjCObjectTypeBitfields(ObjCObjectTypeBitfields.Internal native)
                    : this(__CopyValue(native))
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected ObjCObjectTypeBitfields(ObjCObjectTypeBitfields.Internal* native, bool isInternalImpl = false)
                {
                    __Instance = new global::System.IntPtr(native);
                }

                public ObjCObjectTypeBitfields()
                {
                    __Instance = Marshal.AllocHGlobal(4);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    DestroyNativeInstance(false);
                }

                public virtual void DestroyNativeInstance()
                {
                    DestroyNativeInstance(true);
                }

                private void DestroyNativeInstance(bool force)
                {
                    clang.Type.ObjCObjectTypeBitfields __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }
            }

            protected internal unsafe partial class ReferenceTypeBitfields : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 4)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public uint _0;

                    [FieldOffset(2)]
                    public uint SpelledAsLValue;

                    [FieldOffset(2)]
                    public uint InnerRef;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang4Type22ReferenceTypeBitfieldsC2ERKS1_")]
                    internal static extern void cctor_0(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ReferenceTypeBitfields> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ReferenceTypeBitfields>();

                private readonly bool __ownsNativeInstance;

                public static ReferenceTypeBitfields __CreateInstance(global::System.IntPtr native)
                {
                    return new ReferenceTypeBitfields((ReferenceTypeBitfields.Internal*) native);
                }

                public static ReferenceTypeBitfields __CreateInstance(ReferenceTypeBitfields.Internal native)
                {
                    return new ReferenceTypeBitfields(native);
                }

                private static ReferenceTypeBitfields.Internal* __CopyValue(ReferenceTypeBitfields.Internal native)
                {
                    var ret = (ReferenceTypeBitfields.Internal*) Marshal.AllocHGlobal(4);
                    *ret = native;
                    return ret;
                }

                private ReferenceTypeBitfields(ReferenceTypeBitfields.Internal native)
                    : this(__CopyValue(native))
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected ReferenceTypeBitfields(ReferenceTypeBitfields.Internal* native, bool isInternalImpl = false)
                {
                    __Instance = new global::System.IntPtr(native);
                }

                public ReferenceTypeBitfields()
                {
                    __Instance = Marshal.AllocHGlobal(4);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    DestroyNativeInstance(false);
                }

                public virtual void DestroyNativeInstance()
                {
                    DestroyNativeInstance(true);
                }

                private void DestroyNativeInstance(bool force)
                {
                    clang.Type.ReferenceTypeBitfields __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }
            }

            protected internal unsafe partial class TypeWithKeywordBitfields : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 4)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public uint _0;

                    [FieldOffset(2)]
                    public uint Keyword;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang4Type24TypeWithKeywordBitfieldsC2ERKS1_")]
                    internal static extern void cctor_0(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, TypeWithKeywordBitfields> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, TypeWithKeywordBitfields>();

                private readonly bool __ownsNativeInstance;

                public static TypeWithKeywordBitfields __CreateInstance(global::System.IntPtr native)
                {
                    return new TypeWithKeywordBitfields((TypeWithKeywordBitfields.Internal*) native);
                }

                public static TypeWithKeywordBitfields __CreateInstance(TypeWithKeywordBitfields.Internal native)
                {
                    return new TypeWithKeywordBitfields(native);
                }

                private static TypeWithKeywordBitfields.Internal* __CopyValue(TypeWithKeywordBitfields.Internal native)
                {
                    var ret = (TypeWithKeywordBitfields.Internal*) Marshal.AllocHGlobal(4);
                    *ret = native;
                    return ret;
                }

                private TypeWithKeywordBitfields(TypeWithKeywordBitfields.Internal native)
                    : this(__CopyValue(native))
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected TypeWithKeywordBitfields(TypeWithKeywordBitfields.Internal* native, bool isInternalImpl = false)
                {
                    __Instance = new global::System.IntPtr(native);
                }

                public TypeWithKeywordBitfields()
                {
                    __Instance = Marshal.AllocHGlobal(4);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    DestroyNativeInstance(false);
                }

                public virtual void DestroyNativeInstance()
                {
                    DestroyNativeInstance(true);
                }

                private void DestroyNativeInstance(bool force)
                {
                    clang.Type.TypeWithKeywordBitfields __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }
            }

            protected internal unsafe partial class VectorTypeBitfields : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 4)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public uint _0;

                    [FieldOffset(2)]
                    public uint VecKind;

                    [FieldOffset(2)]
                    public uint NumElements;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang4Type19VectorTypeBitfieldsC2ERKS1_")]
                    internal static extern void cctor_0(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, VectorTypeBitfields> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, VectorTypeBitfields>();

                private readonly bool __ownsNativeInstance;

                public static VectorTypeBitfields __CreateInstance(global::System.IntPtr native)
                {
                    return new VectorTypeBitfields((VectorTypeBitfields.Internal*) native);
                }

                public static VectorTypeBitfields __CreateInstance(VectorTypeBitfields.Internal native)
                {
                    return new VectorTypeBitfields(native);
                }

                private static VectorTypeBitfields.Internal* __CopyValue(VectorTypeBitfields.Internal native)
                {
                    var ret = (VectorTypeBitfields.Internal*) Marshal.AllocHGlobal(4);
                    *ret = native;
                    return ret;
                }

                private VectorTypeBitfields(VectorTypeBitfields.Internal native)
                    : this(__CopyValue(native))
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected VectorTypeBitfields(VectorTypeBitfields.Internal* native, bool isInternalImpl = false)
                {
                    __Instance = new global::System.IntPtr(native);
                }

                public VectorTypeBitfields()
                {
                    __Instance = Marshal.AllocHGlobal(4);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    DestroyNativeInstance(false);
                }

                public virtual void DestroyNativeInstance()
                {
                    DestroyNativeInstance(true);
                }

                private void DestroyNativeInstance(bool force)
                {
                    clang.Type.VectorTypeBitfields __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }
            }

            protected internal unsafe partial class AttributedTypeBitfields : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 4)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public uint _0;

                    [FieldOffset(2)]
                    public uint AttrKind;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang4Type23AttributedTypeBitfieldsC2ERKS1_")]
                    internal static extern void cctor_0(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, AttributedTypeBitfields> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, AttributedTypeBitfields>();

                private readonly bool __ownsNativeInstance;

                public static AttributedTypeBitfields __CreateInstance(global::System.IntPtr native)
                {
                    return new AttributedTypeBitfields((AttributedTypeBitfields.Internal*) native);
                }

                public static AttributedTypeBitfields __CreateInstance(AttributedTypeBitfields.Internal native)
                {
                    return new AttributedTypeBitfields(native);
                }

                private static AttributedTypeBitfields.Internal* __CopyValue(AttributedTypeBitfields.Internal native)
                {
                    var ret = (AttributedTypeBitfields.Internal*) Marshal.AllocHGlobal(4);
                    *ret = native;
                    return ret;
                }

                private AttributedTypeBitfields(AttributedTypeBitfields.Internal native)
                    : this(__CopyValue(native))
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected AttributedTypeBitfields(AttributedTypeBitfields.Internal* native, bool isInternalImpl = false)
                {
                    __Instance = new global::System.IntPtr(native);
                }

                public AttributedTypeBitfields()
                {
                    __Instance = Marshal.AllocHGlobal(4);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    DestroyNativeInstance(false);
                }

                public virtual void DestroyNativeInstance()
                {
                    DestroyNativeInstance(true);
                }

                private void DestroyNativeInstance(bool force)
                {
                    clang.Type.AttributedTypeBitfields __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }
            }

            protected internal unsafe partial class AutoTypeBitfields : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 4)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public uint _0;

                    [FieldOffset(2)]
                    public uint IsDecltypeAuto;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang4Type17AutoTypeBitfieldsC2ERKS1_")]
                    internal static extern void cctor_0(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, AutoTypeBitfields> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, AutoTypeBitfields>();

                private readonly bool __ownsNativeInstance;

                public static AutoTypeBitfields __CreateInstance(global::System.IntPtr native)
                {
                    return new AutoTypeBitfields((AutoTypeBitfields.Internal*) native);
                }

                public static AutoTypeBitfields __CreateInstance(AutoTypeBitfields.Internal native)
                {
                    return new AutoTypeBitfields(native);
                }

                private static AutoTypeBitfields.Internal* __CopyValue(AutoTypeBitfields.Internal native)
                {
                    var ret = (AutoTypeBitfields.Internal*) Marshal.AllocHGlobal(4);
                    *ret = native;
                    return ret;
                }

                private AutoTypeBitfields(AutoTypeBitfields.Internal native)
                    : this(__CopyValue(native))
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected AutoTypeBitfields(AutoTypeBitfields.Internal* native, bool isInternalImpl = false)
                {
                    __Instance = new global::System.IntPtr(native);
                }

                public AutoTypeBitfields()
                {
                    __Instance = Marshal.AllocHGlobal(4);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    DestroyNativeInstance(false);
                }

                public virtual void DestroyNativeInstance()
                {
                    DestroyNativeInstance(true);
                }

                private void DestroyNativeInstance(bool force)
                {
                    clang.Type.AutoTypeBitfields __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }
            }

            protected internal unsafe partial struct _
            {
                [StructLayout(LayoutKind.Explicit, Size = 4)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    internal clang.Type.TypeBitfields.Internal TypeBits;

                    [FieldOffset(0)]
                    public clang.Type.ArrayTypeBitfields.Internal ArrayTypeBits;

                    [FieldOffset(0)]
                    public clang.Type.AttributedTypeBitfields.Internal AttributedTypeBits;

                    [FieldOffset(0)]
                    public clang.Type.AutoTypeBitfields.Internal AutoTypeBits;

                    [FieldOffset(0)]
                    public clang.Type.BuiltinTypeBitfields.Internal BuiltinTypeBits;

                    [FieldOffset(0)]
                    public clang.Type.FunctionTypeBitfields.Internal FunctionTypeBits;

                    [FieldOffset(0)]
                    public clang.Type.ObjCObjectTypeBitfields.Internal ObjCObjectTypeBits;

                    [FieldOffset(0)]
                    public clang.Type.ReferenceTypeBitfields.Internal ReferenceTypeBits;

                    [FieldOffset(0)]
                    public clang.Type.TypeWithKeywordBitfields.Internal TypeWithKeywordBits;

                    [FieldOffset(0)]
                    public clang.Type.VectorTypeBitfields.Internal VectorTypeBits;
                }
            }

            private readonly bool __ownsNativeInstance;

            public static new Type __CreateInstance(global::System.IntPtr native)
            {
                return new Type((Type.Internal*) native);
            }

            public static Type __CreateInstance(Type.Internal native)
            {
                return new Type(native);
            }

            private static Type.Internal* __CopyValue(Type.Internal native)
            {
                var ret = (Type.Internal*) Marshal.AllocHGlobal(24);
                *ret = native;
                return ret;
            }

            private Type(Type.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected Type(Type.Internal* native, bool isInternalImpl = false)
                : base((clang.ExtQualsTypeCommonBase.Internal*) native)
            {
            }

            protected Type(clang.Type.TypeClass tc, clang.QualType canon, bool Dependent, bool InstantiationDependent, bool VariablyModified, bool ContainsUnexpandedParameterPack)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(24);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = tc;
                var arg1 = ReferenceEquals(canon, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (canon.__Instance);
                Internal.ctor_1(__Instance, arg0, arg1, Dependent, InstantiationDependent, VariablyModified, ContainsUnexpandedParameterPack);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.ExtQualsTypeCommonBase __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            protected clang.Type this_()
            {
                var __ret = Internal.this__0(__Instance);
                clang.Type __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Type.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Type) clang.Type.NativeToManagedMap[__ret];
                else __result0 = clang.Type.__CreateInstance(__ret);
                return __result0;
            }

            protected void setDependent(bool D)
            {
                Internal.setDependent_0(__Instance, D);
            }

            protected void setInstantiationDependent(bool D)
            {
                Internal.setInstantiationDependent_0(__Instance, D);
            }

            protected void setVariablyModified(bool VM)
            {
                Internal.setVariablyModified_0(__Instance, VM);
            }

            protected void setContainsUnexpandedParameterPack(bool PP)
            {
                Internal.setContainsUnexpandedParameterPack_0(__Instance, PP);
            }

            public clang.Type.TypeClass getTypeClass()
            {
                var __ret = Internal.getTypeClass_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Whether this type comes from an AST file.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Whether this type comes from an AST file.</para>
            /// </remarks>
            public bool isFromAST()
            {
                var __ret = Internal.isFromAST_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Whether this type is or contains an unexpanded parameter pack,
            /// used to support C++0x variadic templates.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Whether this type is or contains an unexpanded
            /// parameter</para>
            /// <para>  /// pack, used to support C++0x variadic templates.</para>
            /// <para>  ///</para>
            /// <para>  /// A type that contains a parameter pack shall be expanded by
            /// the</para>
            /// <para>  /// ellipsis operator at some point. For example, the typedef
            /// in the</para>
            /// <para>  /// following example contains an unexpanded parameter pack
            /// 'T':</para>
            /// <para>  ///</para>
            /// <para>  /// \code</para>
            /// <para>  /// template&lt;typename ...T&gt;</para>
            /// <para>  /// struct X {</para>
            /// <para>  ///   typedef T* pointer_types; // ill-formed; T is a parameter
            /// pack.</para>
            /// <para>  /// };</para>
            /// <para>  /// \endcode</para>
            /// <para>  ///</para>
            /// <para>  /// Note that this routine does not specify which</para>
            /// </remarks>
            public bool containsUnexpandedParameterPack()
            {
                var __ret = Internal.containsUnexpandedParameterPack_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determines if this type would be canonical if it had no further
            /// qualification.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Determines if this type would be canonical if it had no
            /// further</para>
            /// <para>  /// qualification.</para>
            /// </remarks>
            public bool isCanonicalUnqualified()
            {
                var __ret = Internal.isCanonicalUnqualified_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Pull a single level of sugar off of this locally-unqualified
            /// type. Users should generally prefer
            /// SplitQualType::getSingleStepDesugaredType() or
            /// QualType::getSingleStepDesugaredType(const ASTContext&amp;).</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Pull a single level of sugar off of this locally-unqualified
            /// type.</para>
            /// <para>  /// Users should generally prefer
            /// SplitQualType::getSingleStepDesugaredType()</para>
            /// <para>  /// or QualType::getSingleStepDesugaredType(const
            /// ASTContext&amp;).</para>
            /// </remarks>
            public clang.QualType getLocallyUnqualifiedSingleStepDesugaredType()
            {
                var __ret = Internal.getLocallyUnqualifiedSingleStepDesugaredType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Def If non-NULL, and the type refers to some kind of declaration
            /// that can be completed (such as a C struct, C++ class, or Objective-C
            /// class), will be set to the declaration.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// isIncompleteType - Return true if this is an incomplete
            /// type.</para>
            /// <para>  /// A type that can describe objects, but which lacks
            /// information needed to</para>
            /// <para>  /// determine its size (e.g. void, or a fwd declared struct).
            /// Clients of this</para>
            /// <para>  /// routine will need to determine if the size is actually
            /// required.</para>
            /// <para>  ///</para>
            /// <para>  /// \brief Def If non-NULL, and the type refers to some kind of
            /// declaration</para>
            /// <para>  /// that can be completed (such as a C struct, C++ class, or
            /// Objective-C</para>
            /// <para>  /// class), will be set to the declaration.</para>
            /// </remarks>
            public bool isIncompleteType(clang.NamedDecl Def)
            {
                var arg0 = ReferenceEquals(Def, null) ? global::System.IntPtr.Zero : Def.__Instance;
                var __ret = Internal.isIncompleteType_0(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>isIncompleteOrObjectType - Return true if this is an incomplete
            /// or object type, in other words, not a function type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// isIncompleteOrObjectType - Return true if this is an
            /// incomplete or object</para>
            /// <para>  /// type, in other words, not a function type.</para>
            /// </remarks>
            public bool isIncompleteOrObjectType()
            {
                var __ret = Internal.isIncompleteOrObjectType_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determine whether this type is an object type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine whether this type is an object type.</para>
            /// </remarks>
            public bool isObjectType()
            {
                var __ret = Internal.isObjectType_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>isLiteralType - Return true if this is a literal type (C++11
            /// [basic.types]p10)</para>
            /// </summary>
            /// <remarks>
            /// <para>/// isLiteralType - Return true if this is a literal type</para>
            /// <para>  /// (C++11 [basic.types]p10)</para>
            /// </remarks>
            public bool isLiteralType(clang.ASTContext Ctx)
            {
                var arg0 = ReferenceEquals(Ctx, null) ? global::System.IntPtr.Zero : Ctx.__Instance;
                var __ret = Internal.isLiteralType_0(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Test if this type is a standard-layout type. (C++0x
            /// [basic.type]p9)</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Test if this type is a standard-layout type.</para>
            /// <para>  /// (C++0x [basic.type]p9)</para>
            /// </remarks>
            public bool isStandardLayoutType()
            {
                var __ret = Internal.isStandardLayoutType_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>isBuiltinType - returns true if the type is a builtin
            /// type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// isBuiltinType - returns true if the type is a builtin
            /// type.</para>
            /// </remarks>
            public bool isBuiltinType()
            {
                var __ret = Internal.isBuiltinType_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>isSpecificBuiltinType - Test for a particular builtin
            /// type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// isSpecificBuiltinType - Test for a particular builtin
            /// type.</para>
            /// </remarks>
            public bool isSpecificBuiltinType(uint K)
            {
                var __ret = Internal.isSpecificBuiltinType_0(__Instance, K);
                return __ret;
            }

            /// <summary>
            /// <para>isPlaceholderType - Test for a type which does not represent an
            /// actual type-system type but is instead used as a placeholder for various
            /// convenient purposes within Clang. All such types are BuiltinTypes.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// isPlaceholderType - Test for a type which does not represent
            /// an</para>
            /// <para>  /// actual type-system type but is instead used as a
            /// placeholder for</para>
            /// <para>  /// various convenient purposes within Clang.  All such types
            /// are</para>
            /// <para>  /// BuiltinTypes.</para>
            /// </remarks>
            public bool isPlaceholderType()
            {
                var __ret = Internal.isPlaceholderType_0(__Instance);
                return __ret;
            }

            public clang.BuiltinType getAsPlaceholderType()
            {
                var __ret = Internal.getAsPlaceholderType_0(__Instance);
                clang.BuiltinType __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.BuiltinType.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.BuiltinType) clang.BuiltinType.NativeToManagedMap[__ret];
                else __result0 = clang.BuiltinType.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>isSpecificPlaceholderType - Test for a specific placeholder
            /// type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// isSpecificPlaceholderType - Test for a specific placeholder
            /// type.</para>
            /// </remarks>
            public bool isSpecificPlaceholderType(uint K)
            {
                var __ret = Internal.isSpecificPlaceholderType_0(__Instance, K);
                return __ret;
            }

            /// <summary>
            /// <para>isNonOverloadPlaceholderType - Test for a placeholder type other
            /// than Overload; see BuiltinType::isNonOverloadPlaceholderType.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// isNonOverloadPlaceholderType - Test for a placeholder
            /// type</para>
            /// <para>  /// other than Overload;  see
            /// BuiltinType::isNonOverloadPlaceholderType.</para>
            /// </remarks>
            public bool isNonOverloadPlaceholderType()
            {
                var __ret = Internal.isNonOverloadPlaceholderType_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>isIntegerType() does *not* include complex integers (a GCC
            /// extension). isComplexIntegerType() can be used to test for complex
            /// integers.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// isIntegerType() does *not* include complex integers (a GCC
            /// extension).</para>
            /// <para>  /// isComplexIntegerType() can be used to test for complex
            /// integers.</para>
            /// </remarks>
            public bool isIntegerType()
            {
                var __ret = Internal.isIntegerType_0(__Instance);
                return __ret;
            }

            public bool isEnumeralType()
            {
                var __ret = Internal.isEnumeralType_0(__Instance);
                return __ret;
            }

            public bool isBooleanType()
            {
                var __ret = Internal.isBooleanType_0(__Instance);
                return __ret;
            }

            public bool isCharType()
            {
                var __ret = Internal.isCharType_0(__Instance);
                return __ret;
            }

            public bool isWideCharType()
            {
                var __ret = Internal.isWideCharType_0(__Instance);
                return __ret;
            }

            public bool isChar16Type()
            {
                var __ret = Internal.isChar16Type_0(__Instance);
                return __ret;
            }

            public bool isChar32Type()
            {
                var __ret = Internal.isChar32Type_0(__Instance);
                return __ret;
            }

            public bool isAnyCharacterType()
            {
                var __ret = Internal.isAnyCharacterType_0(__Instance);
                return __ret;
            }

            public bool isIntegralType(clang.ASTContext Ctx)
            {
                var arg0 = ReferenceEquals(Ctx, null) ? global::System.IntPtr.Zero : Ctx.__Instance;
                var __ret = Internal.isIntegralType_0(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Determine whether this type is an integral or enumeration
            /// type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine whether this type is an integral or
            /// enumeration type.</para>
            /// </remarks>
            public bool isIntegralOrEnumerationType()
            {
                var __ret = Internal.isIntegralOrEnumerationType_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determine whether this type is an integral or unscoped
            /// enumeration type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine whether this type is an integral or unscoped
            /// enumeration</para>
            /// <para>  /// type.</para>
            /// </remarks>
            public bool isIntegralOrUnscopedEnumerationType()
            {
                var __ret = Internal.isIntegralOrUnscopedEnumerationType_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Floating point categories.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Floating point categories.</para>
            /// </remarks>
            public bool isRealFloatingType()
            {
                var __ret = Internal.isRealFloatingType_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>isComplexType() does *not* include complex integers (a GCC
            /// extension). isComplexIntegerType() can be used to test for complex
            /// integers.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// isComplexType() does *not* include complex integers (a GCC
            /// extension).</para>
            /// <para>  /// isComplexIntegerType() can be used to test for complex
            /// integers.</para>
            /// </remarks>
            public bool isComplexType()
            {
                var __ret = Internal.isComplexType_0(__Instance);
                return __ret;
            }

            public bool isAnyComplexType()
            {
                var __ret = Internal.isAnyComplexType_0(__Instance);
                return __ret;
            }

            public bool isFloatingType()
            {
                var __ret = Internal.isFloatingType_0(__Instance);
                return __ret;
            }

            public bool isHalfType()
            {
                var __ret = Internal.isHalfType_0(__Instance);
                return __ret;
            }

            public bool isRealType()
            {
                var __ret = Internal.isRealType_0(__Instance);
                return __ret;
            }

            public bool isArithmeticType()
            {
                var __ret = Internal.isArithmeticType_0(__Instance);
                return __ret;
            }

            public bool isVoidType()
            {
                var __ret = Internal.isVoidType_0(__Instance);
                return __ret;
            }

            public bool isScalarType()
            {
                var __ret = Internal.isScalarType_0(__Instance);
                return __ret;
            }

            public bool isAggregateType()
            {
                var __ret = Internal.isAggregateType_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Tests whether the type is categorized as a fundamental
            /// type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Tests whether the type is categorized as a fundamental
            /// type.</para>
            /// <para>///</para>
            /// <para>/// \returns True for types specified in C++0x
            /// [basic.fundamental].</para>
            /// </remarks>
            public bool isFundamentalType()
            {
                var __ret = Internal.isFundamentalType_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Tests whether the type is categorized as a compound type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Tests whether the type is categorized as a compound
            /// type.</para>
            /// <para>///</para>
            /// <para>/// \returns True for types specified in C++0x
            /// [basic.compound].</para>
            /// </remarks>
            public bool isCompoundType()
            {
                var __ret = Internal.isCompoundType_0(__Instance);
                return __ret;
            }

            public bool isFunctionType()
            {
                var __ret = Internal.isFunctionType_0(__Instance);
                return __ret;
            }

            public bool isFunctionNoProtoType()
            {
                var __ret = Internal.isFunctionNoProtoType_0(__Instance);
                return __ret;
            }

            public bool isFunctionProtoType()
            {
                var __ret = Internal.isFunctionProtoType_0(__Instance);
                return __ret;
            }

            public bool isPointerType()
            {
                var __ret = Internal.isPointerType_0(__Instance);
                return __ret;
            }

            public bool isAnyPointerType()
            {
                var __ret = Internal.isAnyPointerType_0(__Instance);
                return __ret;
            }

            public bool isBlockPointerType()
            {
                var __ret = Internal.isBlockPointerType_0(__Instance);
                return __ret;
            }

            public bool isVoidPointerType()
            {
                var __ret = Internal.isVoidPointerType_0(__Instance);
                return __ret;
            }

            public bool isReferenceType()
            {
                var __ret = Internal.isReferenceType_0(__Instance);
                return __ret;
            }

            public bool isLValueReferenceType()
            {
                var __ret = Internal.isLValueReferenceType_0(__Instance);
                return __ret;
            }

            public bool isRValueReferenceType()
            {
                var __ret = Internal.isRValueReferenceType_0(__Instance);
                return __ret;
            }

            public bool isFunctionPointerType()
            {
                var __ret = Internal.isFunctionPointerType_0(__Instance);
                return __ret;
            }

            public bool isMemberPointerType()
            {
                var __ret = Internal.isMemberPointerType_0(__Instance);
                return __ret;
            }

            public bool isMemberFunctionPointerType()
            {
                var __ret = Internal.isMemberFunctionPointerType_0(__Instance);
                return __ret;
            }

            public bool isMemberDataPointerType()
            {
                var __ret = Internal.isMemberDataPointerType_0(__Instance);
                return __ret;
            }

            public bool isArrayType()
            {
                var __ret = Internal.isArrayType_0(__Instance);
                return __ret;
            }

            public bool isConstantArrayType()
            {
                var __ret = Internal.isConstantArrayType_0(__Instance);
                return __ret;
            }

            public bool isIncompleteArrayType()
            {
                var __ret = Internal.isIncompleteArrayType_0(__Instance);
                return __ret;
            }

            public bool isVariableArrayType()
            {
                var __ret = Internal.isVariableArrayType_0(__Instance);
                return __ret;
            }

            public bool isDependentSizedArrayType()
            {
                var __ret = Internal.isDependentSizedArrayType_0(__Instance);
                return __ret;
            }

            public bool isRecordType()
            {
                var __ret = Internal.isRecordType_0(__Instance);
                return __ret;
            }

            public bool isClassType()
            {
                var __ret = Internal.isClassType_0(__Instance);
                return __ret;
            }

            public bool isStructureType()
            {
                var __ret = Internal.isStructureType_0(__Instance);
                return __ret;
            }

            public bool isInterfaceType()
            {
                var __ret = Internal.isInterfaceType_0(__Instance);
                return __ret;
            }

            public bool isStructureOrClassType()
            {
                var __ret = Internal.isStructureOrClassType_0(__Instance);
                return __ret;
            }

            public bool isUnionType()
            {
                var __ret = Internal.isUnionType_0(__Instance);
                return __ret;
            }

            public bool isComplexIntegerType()
            {
                var __ret = Internal.isComplexIntegerType_0(__Instance);
                return __ret;
            }

            public bool isVectorType()
            {
                var __ret = Internal.isVectorType_0(__Instance);
                return __ret;
            }

            public bool isExtVectorType()
            {
                var __ret = Internal.isExtVectorType_0(__Instance);
                return __ret;
            }

            public bool isObjCObjectPointerType()
            {
                var __ret = Internal.isObjCObjectPointerType_0(__Instance);
                return __ret;
            }

            public bool isObjCRetainableType()
            {
                var __ret = Internal.isObjCRetainableType_0(__Instance);
                return __ret;
            }

            public bool isObjCLifetimeType()
            {
                var __ret = Internal.isObjCLifetimeType_0(__Instance);
                return __ret;
            }

            public bool isObjCIndirectLifetimeType()
            {
                var __ret = Internal.isObjCIndirectLifetimeType_0(__Instance);
                return __ret;
            }

            public bool isObjCNSObjectType()
            {
                var __ret = Internal.isObjCNSObjectType_0(__Instance);
                return __ret;
            }

            public bool isObjCObjectType()
            {
                var __ret = Internal.isObjCObjectType_0(__Instance);
                return __ret;
            }

            public bool isObjCQualifiedInterfaceType()
            {
                var __ret = Internal.isObjCQualifiedInterfaceType_0(__Instance);
                return __ret;
            }

            public bool isObjCQualifiedIdType()
            {
                var __ret = Internal.isObjCQualifiedIdType_0(__Instance);
                return __ret;
            }

            public bool isObjCQualifiedClassType()
            {
                var __ret = Internal.isObjCQualifiedClassType_0(__Instance);
                return __ret;
            }

            public bool isObjCObjectOrInterfaceType()
            {
                var __ret = Internal.isObjCObjectOrInterfaceType_0(__Instance);
                return __ret;
            }

            public bool isObjCIdType()
            {
                var __ret = Internal.isObjCIdType_0(__Instance);
                return __ret;
            }

            public bool isObjCClassType()
            {
                var __ret = Internal.isObjCClassType_0(__Instance);
                return __ret;
            }

            public bool isObjCSelType()
            {
                var __ret = Internal.isObjCSelType_0(__Instance);
                return __ret;
            }

            public bool isObjCBuiltinType()
            {
                var __ret = Internal.isObjCBuiltinType_0(__Instance);
                return __ret;
            }

            public bool isObjCARCBridgableType()
            {
                var __ret = Internal.isObjCARCBridgableType_0(__Instance);
                return __ret;
            }

            public bool isCARCBridgableType()
            {
                var __ret = Internal.isCARCBridgableType_0(__Instance);
                return __ret;
            }

            public bool isTemplateTypeParmType()
            {
                var __ret = Internal.isTemplateTypeParmType_0(__Instance);
                return __ret;
            }

            public bool isNullPtrType()
            {
                var __ret = Internal.isNullPtrType_0(__Instance);
                return __ret;
            }

            public bool isAtomicType()
            {
                var __ret = Internal.isAtomicType_0(__Instance);
                return __ret;
            }

            public bool isImage1dT()
            {
                var __ret = Internal.isImage1dT_0(__Instance);
                return __ret;
            }

            public bool isImage1dArrayT()
            {
                var __ret = Internal.isImage1dArrayT_0(__Instance);
                return __ret;
            }

            public bool isImage1dBufferT()
            {
                var __ret = Internal.isImage1dBufferT_0(__Instance);
                return __ret;
            }

            public bool isImage2dT()
            {
                var __ret = Internal.isImage2dT_0(__Instance);
                return __ret;
            }

            public bool isImage2dArrayT()
            {
                var __ret = Internal.isImage2dArrayT_0(__Instance);
                return __ret;
            }

            public bool isImage3dT()
            {
                var __ret = Internal.isImage3dT_0(__Instance);
                return __ret;
            }

            public bool isImageType()
            {
                var __ret = Internal.isImageType_0(__Instance);
                return __ret;
            }

            public bool isSamplerT()
            {
                var __ret = Internal.isSamplerT_0(__Instance);
                return __ret;
            }

            public bool isEventT()
            {
                var __ret = Internal.isEventT_0(__Instance);
                return __ret;
            }

            public bool isOpenCLSpecificType()
            {
                var __ret = Internal.isOpenCLSpecificType_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determines if this type, which must satisfy isObjCLifetimeType(),
            /// is implicitly __unsafe_unretained rather than implicitly __strong.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Determines if this type, which must satisfy</para>
            /// <para>  /// isObjCLifetimeType(), is implicitly __unsafe_unretained
            /// rather</para>
            /// <para>  /// than implicitly __strong.</para>
            /// </remarks>
            public bool isObjCARCImplicitlyUnretainedType()
            {
                var __ret = Internal.isObjCARCImplicitlyUnretainedType_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Return the implicit lifetime for this type, which must not be
            /// dependent.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Return the implicit lifetime for this type, which must not be
            /// dependent.</para>
            /// </remarks>
            public clang.Qualifiers.ObjCLifetime getObjCARCImplicitLifetime()
            {
                var __ret = Internal.getObjCARCImplicitLifetime_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>getScalarTypeKind - Given that this is a scalar type, classify
            /// it.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getScalarTypeKind - Given that this is a scalar type,
            /// classify it.</para>
            /// </remarks>
            public clang.Type.ScalarTypeKind getScalarTypeKind()
            {
                var __ret = Internal.getScalarTypeKind_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>isDependentType - Whether this type is a dependent type, meaning
            /// that its definition somehow depends on a template parameter (C++
            /// [temp.dep.type]).</para>
            /// </summary>
            /// <remarks>
            /// <para>/// isDependentType - Whether this type is a dependent type,
            /// meaning</para>
            /// <para>  /// that its definition somehow depends on a template
            /// parameter</para>
            /// <para>  /// (C++ [temp.dep.type]).</para>
            /// </remarks>
            public bool isDependentType()
            {
                var __ret = Internal.isDependentType_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determine whether this type is an instantiation-dependent type,
            /// meaning that the type involves a template parameter (even if the definition
            /// does not actually depend on the type substituted for that template
            /// parameter).</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine whether this type is an
            /// instantiation-dependent type,</para>
            /// <para>  /// meaning that the type involves a template parameter (even
            /// if the</para>
            /// <para>  /// definition does not actually depend on the type substituted
            /// for that</para>
            /// <para>  /// template parameter).</para>
            /// </remarks>
            public bool isInstantiationDependentType()
            {
                var __ret = Internal.isInstantiationDependentType_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determine whether this type is an undeduced type, meaning that it
            /// somehow involves a C++11 'auto' type which has not yet been deduced.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine whether this type is an undeduced type,
            /// meaning that</para>
            /// <para>  /// it somehow involves a C++11 'auto' type which has not yet
            /// been deduced.</para>
            /// </remarks>
            public bool isUndeducedType()
            {
                var __ret = Internal.isUndeducedType_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Whether this type is a variably-modified type (C99 6.7.5).</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Whether this type is a variably-modified type (C99
            /// 6.7.5).</para>
            /// </remarks>
            public bool isVariablyModifiedType()
            {
                var __ret = Internal.isVariablyModifiedType_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Whether this type involves a variable-length array type with a
            /// definite size.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Whether this type involves a variable-length array
            /// type</para>
            /// <para>  /// with a definite size.</para>
            /// </remarks>
            public bool hasSizedVLAType()
            {
                var __ret = Internal.hasSizedVLAType_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Whether this type is or contains a local or unnamed type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Whether this type is or contains a local or unnamed
            /// type.</para>
            /// </remarks>
            public bool hasUnnamedOrLocalType()
            {
                var __ret = Internal.hasUnnamedOrLocalType_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determines whether this is a type for which one can define an
            /// overloaded operator.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determines whether this is a type for which one can
            /// define</para>
            /// <para>/// an overloaded operator.</para>
            /// </remarks>
            public bool isOverloadableType()
            {
                var __ret = Internal.isOverloadableType_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determine wither this type is a C++
            /// elaborated-type-specifier.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine wither this type is a C++
            /// elaborated-type-specifier.</para>
            /// </remarks>
            public bool isElaboratedTypeSpecifier()
            {
                var __ret = Internal.isElaboratedTypeSpecifier_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determines whether this type can decay to a pointer type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determines whether this type can decay to a pointer
            /// type.</para>
            /// </remarks>
            public bool canDecayToPointerType()
            {
                var __ret = Internal.canDecayToPointerType_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>hasPointerRepresentation - Whether this type is represented
            /// natively as a pointer; this includes pointers, references, block pointers,
            /// and Objective-C interface, qualified id, and qualified interface types, as
            /// well as nullptr_t.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// hasPointerRepresentation - Whether this type is
            /// represented</para>
            /// <para>  /// natively as a pointer; this includes pointers, references,
            /// block</para>
            /// <para>  /// pointers, and Objective-C interface, qualified id, and
            /// qualified</para>
            /// <para>  /// interface types, as well as nullptr_t.</para>
            /// </remarks>
            public bool hasPointerRepresentation()
            {
                var __ret = Internal.hasPointerRepresentation_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>hasObjCPointerRepresentation - Whether this type can represent an
            /// objective pointer type for the purpose of GC'ability</para>
            /// </summary>
            /// <remarks>
            /// <para>/// hasObjCPointerRepresentation - Whether this type can
            /// represent</para>
            /// <para>  /// an objective pointer type for the purpose of
            /// GC'ability</para>
            /// </remarks>
            public bool hasObjCPointerRepresentation()
            {
                var __ret = Internal.hasObjCPointerRepresentation_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determine whether this type has an integer representation of some
            /// sort, e.g., it is an integer type or a vector.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine whether this type has an integer
            /// representation</para>
            /// <para>  /// of some sort, e.g., it is an integer type or a
            /// vector.</para>
            /// </remarks>
            public bool hasIntegerRepresentation()
            {
                var __ret = Internal.hasIntegerRepresentation_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determine whether this type has an signed integer representation
            /// of some sort, e.g., it is an signed integer type or a vector.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine whether this type has an signed integer
            /// representation</para>
            /// <para>  /// of some sort, e.g., it is an signed integer type or a
            /// vector.</para>
            /// </remarks>
            public bool hasSignedIntegerRepresentation()
            {
                var __ret = Internal.hasSignedIntegerRepresentation_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determine whether this type has an unsigned integer
            /// representation of some sort, e.g., it is an unsigned integer type or a
            /// vector.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine whether this type has an unsigned integer
            /// representation</para>
            /// <para>  /// of some sort, e.g., it is an unsigned integer type or a
            /// vector.</para>
            /// </remarks>
            public bool hasUnsignedIntegerRepresentation()
            {
                var __ret = Internal.hasUnsignedIntegerRepresentation_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determine whether this type has a floating-point representation
            /// of some sort, e.g., it is a floating-point type or a vector thereof.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine whether this type has a floating-point
            /// representation</para>
            /// <para>  /// of some sort, e.g., it is a floating-point type or a vector
            /// thereof.</para>
            /// </remarks>
            public bool hasFloatingRepresentation()
            {
                var __ret = Internal.hasFloatingRepresentation_0(__Instance);
                return __ret;
            }

            public clang.RecordType getAsStructureType()
            {
                var __ret = Internal.getAsStructureType_0(__Instance);
                clang.RecordType __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.RecordType.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.RecordType) clang.RecordType.NativeToManagedMap[__ret];
                else __result0 = clang.RecordType.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>NOTE: getAs*ArrayType are methods on ASTContext.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// NOTE: getAs*ArrayType are methods on ASTContext.</para>
            /// </remarks>
            public clang.RecordType getAsUnionType()
            {
                var __ret = Internal.getAsUnionType_0(__Instance);
                clang.RecordType __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.RecordType.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.RecordType) clang.RecordType.NativeToManagedMap[__ret];
                else __result0 = clang.RecordType.__CreateInstance(__ret);
                return __result0;
            }

            public clang.ComplexType getAsComplexIntegerType()
            {
                var __ret = Internal.getAsComplexIntegerType_0(__Instance);
                clang.ComplexType __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.ComplexType.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.ComplexType) clang.ComplexType.NativeToManagedMap[__ret];
                else __result0 = clang.ComplexType.__CreateInstance(__ret);
                return __result0;
            }

            public clang.ObjCObjectPointerType getAsObjCInterfacePointerType()
            {
                var __ret = Internal.getAsObjCInterfacePointerType_0(__Instance);
                clang.ObjCObjectPointerType __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.ObjCObjectPointerType.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.ObjCObjectPointerType) clang.ObjCObjectPointerType.NativeToManagedMap[__ret];
                else __result0 = clang.ObjCObjectPointerType.__CreateInstance(__ret);
                return __result0;
            }

            public clang.ObjCObjectPointerType getAsObjCQualifiedIdType()
            {
                var __ret = Internal.getAsObjCQualifiedIdType_0(__Instance);
                clang.ObjCObjectPointerType __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.ObjCObjectPointerType.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.ObjCObjectPointerType) clang.ObjCObjectPointerType.NativeToManagedMap[__ret];
                else __result0 = clang.ObjCObjectPointerType.__CreateInstance(__ret);
                return __result0;
            }

            public clang.ObjCObjectPointerType getAsObjCQualifiedClassType()
            {
                var __ret = Internal.getAsObjCQualifiedClassType_0(__Instance);
                clang.ObjCObjectPointerType __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.ObjCObjectPointerType.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.ObjCObjectPointerType) clang.ObjCObjectPointerType.NativeToManagedMap[__ret];
                else __result0 = clang.ObjCObjectPointerType.__CreateInstance(__ret);
                return __result0;
            }

            public clang.ObjCObjectType getAsObjCQualifiedInterfaceType()
            {
                var __ret = Internal.getAsObjCQualifiedInterfaceType_0(__Instance);
                clang.ObjCObjectType __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.ObjCObjectType.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.ObjCObjectType) clang.ObjCObjectType.NativeToManagedMap[__ret];
                else __result0 = clang.ObjCObjectType.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Retrieves the TagDecl that this type refers to, either because
            /// the type is a TagType or because it is the injected-class-name type of a
            /// class template or class template partial specialization.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieves the TagDecl that this type refers to,
            /// either</para>
            /// <para>  /// because the type is a TagType or because it is the
            /// injected-class-name</para>
            /// <para>  /// type of a class template or class template partial
            /// specialization.</para>
            /// </remarks>
            public clang.TagDecl getAsTagDecl()
            {
                var __ret = Internal.getAsTagDecl_0(__Instance);
                clang.TagDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.TagDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.TagDecl) clang.TagDecl.NativeToManagedMap[__ret];
                else clang.TagDecl.NativeToManagedMap[__ret] = __result0 = (clang.TagDecl) clang.TagDecl.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Get the AutoType whose type will be deduced for a variable with
            /// an initializer of this type. This looks through declarators like pointer
            /// types, but not through decltype or typedefs.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Get the AutoType whose type will be deduced for a
            /// variable with</para>
            /// <para>  /// an initializer of this type. This looks through declarators
            /// like pointer</para>
            /// <para>  /// types, but not through decltype or typedefs.</para>
            /// </remarks>
            public clang.AutoType getContainedAutoType()
            {
                var __ret = Internal.getContainedAutoType_0(__Instance);
                clang.AutoType __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.AutoType.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.AutoType) clang.AutoType.NativeToManagedMap[__ret];
                else __result0 = clang.AutoType.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>A variant of getAs&lt;&gt; for array types which silently
            /// discards qualifiers from the outermost type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// A variant of getAs&lt;&gt; for array types which silently
            /// discards</para>
            /// <para>  /// qualifiers from the outermost type.</para>
            /// </remarks>
            public clang.ArrayType getAsArrayTypeUnsafe()
            {
                var __ret = Internal.getAsArrayTypeUnsafe_0(__Instance);
                clang.ArrayType __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.ArrayType.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.ArrayType) clang.ArrayType.NativeToManagedMap[__ret];
                else __result0 = clang.ArrayType.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>A variant of castAs&lt;&gt; for array type which silently
            /// discards qualifiers from the outermost type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// A variant of castAs&lt;&gt; for array type which silently
            /// discards</para>
            /// <para>  /// qualifiers from the outermost type.</para>
            /// </remarks>
            public clang.ArrayType castAsArrayTypeUnsafe()
            {
                var __ret = Internal.castAsArrayTypeUnsafe_0(__Instance);
                clang.ArrayType __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.ArrayType.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.ArrayType) clang.ArrayType.NativeToManagedMap[__ret];
                else __result0 = clang.ArrayType.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>getBaseElementTypeUnsafe - Get the base element type of this
            /// type, potentially discarding type qualifiers. This method should never be
            /// used when type qualifiers are meaningful.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getBaseElementTypeUnsafe - Get the base element type of
            /// this</para>
            /// <para>  /// type, potentially discarding type qualifiers.  This
            /// method</para>
            /// <para>  /// should never be used when type qualifiers are
            /// meaningful.</para>
            /// </remarks>
            public clang.Type getBaseElementTypeUnsafe()
            {
                var __ret = Internal.getBaseElementTypeUnsafe_0(__Instance);
                clang.Type __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Type.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Type) clang.Type.NativeToManagedMap[__ret];
                else __result0 = clang.Type.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>getArrayElementTypeNoTypeQual - If this is an array type, return
            /// the element type of the array, potentially with type qualifiers missing.
            /// This method should never be used when type qualifiers are
            /// meaningful.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getArrayElementTypeNoTypeQual - If this is an array type,
            /// return the</para>
            /// <para>  /// element type of the array, potentially with type qualifiers
            /// missing.</para>
            /// <para>  /// This method should never be used when type qualifiers are
            /// meaningful.</para>
            /// </remarks>
            public clang.Type getArrayElementTypeNoTypeQual()
            {
                var __ret = Internal.getArrayElementTypeNoTypeQual_0(__Instance);
                clang.Type __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Type.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Type) clang.Type.NativeToManagedMap[__ret];
                else __result0 = clang.Type.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>getPointeeType - If this is a pointer, ObjC object pointer, or
            /// block pointer, this returns the respective pointee.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getPointeeType - If this is a pointer, ObjC object pointer,
            /// or block</para>
            /// <para>  /// pointer, this returns the respective pointee.</para>
            /// </remarks>
            public clang.QualType getPointeeType()
            {
                var __ret = Internal.getPointeeType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>getUnqualifiedDesugaredType() - Return the specified type with
            /// any &quot;sugar&quot; removed from the type, removing any typedefs,
            /// typeofs, etc., as well as any qualifiers.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getUnqualifiedDesugaredType() - Return the specified type
            /// with</para>
            /// <para>  /// any &quot;sugar&quot; removed from the type, removing any
            /// typedefs,</para>
            /// <para>  /// typeofs, etc., as well as any qualifiers.</para>
            /// </remarks>
            public clang.Type getUnqualifiedDesugaredType()
            {
                var __ret = Internal.getUnqualifiedDesugaredType_0(__Instance);
                clang.Type __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Type.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Type) clang.Type.NativeToManagedMap[__ret];
                else __result0 = clang.Type.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>More type predicates useful for type checking/promotion</para>
            /// </summary>
            /// <remarks>
            /// <para>/// More type predicates useful for type
            /// checking/promotion</para>
            /// </remarks>
            public bool isPromotableIntegerType()
            {
                var __ret = Internal.isPromotableIntegerType_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>isSignedIntegerType - Return true if this is an integer type that
            /// is signed, according to C99 6.2.5p4 [char, signed char, short, int,
            /// long..], or an enum decl which has a signed representation.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// isSignedIntegerType - Return true if this is an integer type
            /// that is</para>
            /// <para>  /// signed, according to C99 6.2.5p4 [char, signed char, short,
            /// int, long..],</para>
            /// <para>  /// or an enum decl which has a signed representation.</para>
            /// </remarks>
            public bool isSignedIntegerType()
            {
                var __ret = Internal.isSignedIntegerType_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>isUnsignedIntegerType - Return true if this is an integer type
            /// that is unsigned, according to C99 6.2.5p6 [which returns true for _Bool],
            /// or an enum decl which has an unsigned representation.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// isUnsignedIntegerType - Return true if this is an integer
            /// type that is</para>
            /// <para>  /// unsigned, according to C99 6.2.5p6 [which returns true for
            /// _Bool],</para>
            /// <para>  /// or an enum decl which has an unsigned
            /// representation.</para>
            /// </remarks>
            public bool isUnsignedIntegerType()
            {
                var __ret = Internal.isUnsignedIntegerType_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determines whether this is an integer type that is signed or an
            /// enumeration types whose underlying type is a signed integer type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Determines whether this is an integer type that is signed or
            /// an</para>
            /// <para>  /// enumeration types whose underlying type is a signed integer
            /// type.</para>
            /// </remarks>
            public bool isSignedIntegerOrEnumerationType()
            {
                var __ret = Internal.isSignedIntegerOrEnumerationType_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determines whether this is an integer type that is unsigned or an
            /// enumeration types whose underlying type is a unsigned integer type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Determines whether this is an integer type that is unsigned
            /// or an</para>
            /// <para>  /// enumeration types whose underlying type is a unsigned
            /// integer type.</para>
            /// </remarks>
            public bool isUnsignedIntegerOrEnumerationType()
            {
                var __ret = Internal.isUnsignedIntegerOrEnumerationType_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>isConstantSizeType - Return true if this is not a variable sized
            /// type, according to the rules of C99 6.7.5p3. It is not legal to call this
            /// on incomplete types.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// isConstantSizeType - Return true if this is not a variable
            /// sized type,</para>
            /// <para>  /// according to the rules of C99 6.7.5p3.  It is not legal to
            /// call this on</para>
            /// <para>  /// incomplete types.</para>
            /// </remarks>
            public bool isConstantSizeType()
            {
                var __ret = Internal.isConstantSizeType_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>isSpecifierType - Returns true if this type can be represented by
            /// some set of type specifiers.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// isSpecifierType - Returns true if this type can be
            /// represented by some</para>
            /// <para>  /// set of type specifiers.</para>
            /// </remarks>
            public bool isSpecifierType()
            {
                var __ret = Internal.isSpecifierType_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determine the linkage of this type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine the linkage of this type.</para>
            /// </remarks>
            public clang.Linkage getLinkage()
            {
                var __ret = Internal.getLinkage_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determine the visibility of this type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine the visibility of this type.</para>
            /// </remarks>
            public clang.Visibility getVisibility()
            {
                var __ret = Internal.getVisibility_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Return true if the visibility was explicitly set is the
            /// code.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return true if the visibility was explicitly set is
            /// the code.</para>
            /// </remarks>
            public bool isVisibilityExplicit()
            {
                var __ret = Internal.isVisibilityExplicit_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determine the linkage and visibility of this type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine the linkage and visibility of this
            /// type.</para>
            /// </remarks>
            public clang.LinkageInfo getLinkageAndVisibility()
            {
                var __ret = Internal.getLinkageAndVisibility_0(__Instance);
                return clang.LinkageInfo.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>True if the computed linkage is valid. Used for consistency
            /// checking. Should always return true.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief True if the computed linkage is valid. Used for
            /// consistency</para>
            /// <para>  /// checking. Should always return true.</para>
            /// </remarks>
            public bool isLinkageValid()
            {
                var __ret = Internal.isLinkageValid_0(__Instance);
                return __ret;
            }

            public string getTypeClassName()
            {
                var __ret = Internal.getTypeClassName_0(__Instance);
                return Marshal.PtrToStringAnsi(__ret);
            }

            public clang.QualType getCanonicalTypeInternal()
            {
                var __ret = Internal.getCanonicalTypeInternal_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            public void dump()
            {
                Internal.dump_0(__Instance);
            }
        }

        /// <summary>
        /// <para>BuiltinType - This class is used for builtin types like 'int'.
        /// Builtin types are always canonical and have a literal name field.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// BuiltinType - This class is used for builtin types like
        /// 'int'.  Builtin</para>
        /// <para>/// types are always canonical and have a literal name
        /// field.</para>
        /// </remarks>
        public unsafe partial class BuiltinType : clang.Type, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 24)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr BaseType;

                [FieldOffset(8)]
                public clang.QualType.Internal CanonicalType;

                [FieldOffset(16)]
                internal clang.Type._.Internal __;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11BuiltinTypeC2ENS0_4KindE")]
                internal static extern void ctor_0(global::System.IntPtr instance, clang.BuiltinType.Kind K);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11BuiltinTypeC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11BuiltinType7getKindEv")]
                internal static extern clang.BuiltinType.Kind getKind_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11BuiltinType7getNameERKNS_14PrintingPolicyE")]
                internal static extern llvm.StringRef.Internal getName_0(global::System.IntPtr instance, global::System.IntPtr Policy);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11BuiltinType16getNameAsCStringERKNS_14PrintingPolicyE")]
                internal static extern global::System.IntPtr getNameAsCString_0(global::System.IntPtr instance, global::System.IntPtr Policy);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11BuiltinType9isSugaredEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isSugared_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11BuiltinType7desugarEv")]
                internal static extern clang.QualType.Internal desugar_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11BuiltinType9isIntegerEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isInteger_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11BuiltinType15isSignedIntegerEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isSignedInteger_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11BuiltinType17isUnsignedIntegerEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isUnsignedInteger_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11BuiltinType15isFloatingPointEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isFloatingPoint_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11BuiltinType21isPlaceholderTypeKindENS0_4KindE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isPlaceholderTypeKind_0(clang.BuiltinType.Kind K);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11BuiltinType17isPlaceholderTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isPlaceholderType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11BuiltinType28isNonOverloadPlaceholderTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isNonOverloadPlaceholderType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11BuiltinType7classofEPKNS_4TypeE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);
            }

            public enum Kind : uint
            {
                Void = 0,
                Bool = 1,
                Char_U = 2,
                UChar = 3,
                WChar_U = 4,
                Char16 = 5,
                Char32 = 6,
                UShort = 7,
                UInt = 8,
                ULong = 9,
                ULongLong = 10,
                UInt128 = 11,
                Char_S = 12,
                SChar = 13,
                WChar_S = 14,
                Short = 15,
                Int = 16,
                Long = 17,
                LongLong = 18,
                Int128 = 19,
                Half = 20,
                Float = 21,
                Double = 22,
                LongDouble = 23,
                NullPtr = 24,
                ObjCId = 25,
                ObjCClass = 26,
                ObjCSel = 27,
                OCLImage1d = 28,
                OCLImage1dArray = 29,
                OCLImage1dBuffer = 30,
                OCLImage2d = 31,
                OCLImage2dArray = 32,
                OCLImage3d = 33,
                OCLSampler = 34,
                OCLEvent = 35,
                Dependent = 36,
                Overload = 37,
                BoundMember = 38,
                PseudoObject = 39,
                UnknownAny = 40,
                BuiltinFn = 41,
                ARCUnbridgedCast = 42,
                LastKind = 42
            }

            private readonly bool __ownsNativeInstance;

            public static new BuiltinType __CreateInstance(global::System.IntPtr native)
            {
                return new BuiltinType((BuiltinType.Internal*) native);
            }

            public static BuiltinType __CreateInstance(BuiltinType.Internal native)
            {
                return new BuiltinType(native);
            }

            private static BuiltinType.Internal* __CopyValue(BuiltinType.Internal native)
            {
                var ret = (BuiltinType.Internal*) Marshal.AllocHGlobal(24);
                *ret = native;
                return ret;
            }

            private BuiltinType(BuiltinType.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected BuiltinType(BuiltinType.Internal* native, bool isInternalImpl = false)
                : base((clang.Type.Internal*) native)
            {
            }

            public BuiltinType(clang.BuiltinType.Kind K)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(24);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = K;
                Internal.ctor_0(__Instance, arg0);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.ExtQualsTypeCommonBase __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.BuiltinType.Kind getKind()
            {
                var __ret = Internal.getKind_0(__Instance);
                return __ret;
            }

            public llvm.StringRef getName(clang.PrintingPolicy Policy)
            {
                var arg0 = ReferenceEquals(Policy, null) ? global::System.IntPtr.Zero : Policy.__Instance;
                var __ret = Internal.getName_0(__Instance, arg0);
                return llvm.StringRef.__CreateInstance(__ret);
            }

            public string getNameAsCString(clang.PrintingPolicy Policy)
            {
                var arg0 = ReferenceEquals(Policy, null) ? global::System.IntPtr.Zero : Policy.__Instance;
                var __ret = Internal.getNameAsCString_0(__Instance, arg0);
                return Marshal.PtrToStringAnsi(__ret);
            }

            public bool isSugared()
            {
                var __ret = Internal.isSugared_0(__Instance);
                return __ret;
            }

            public clang.QualType desugar()
            {
                var __ret = Internal.desugar_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            public bool isInteger()
            {
                var __ret = Internal.isInteger_0(__Instance);
                return __ret;
            }

            public bool isSignedInteger()
            {
                var __ret = Internal.isSignedInteger_0(__Instance);
                return __ret;
            }

            public bool isUnsignedInteger()
            {
                var __ret = Internal.isUnsignedInteger_0(__Instance);
                return __ret;
            }

            public bool isFloatingPoint()
            {
                var __ret = Internal.isFloatingPoint_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determines whether this type is a placeholder type, i.e. a type
            /// which cannot appear in arbitrary positions in a fully-formed
            /// expression.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Determines whether this type is a placeholder type, i.e. a
            /// type</para>
            /// <para>  /// which cannot appear in arbitrary positions in a
            /// fully-formed</para>
            /// <para>  /// expression.</para>
            /// </remarks>
            public bool isPlaceholderType()
            {
                var __ret = Internal.isPlaceholderType_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determines whether this type is a placeholder type other than
            /// Overload. Most placeholder types require only syntactic information about
            /// their context in order to be resolved (e.g. whether it is a call
            /// expression), which means they can (and should) be resolved in an earlier
            /// &quot;phase&quot; of analysis. Overload expressions sometimes pick up
            /// further information from their context, like whether the context expects a
            /// specific function-pointer type, and so frequently need special
            /// treatment.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Determines whether this type is a placeholder type other
            /// than</para>
            /// <para>  /// Overload.  Most placeholder types require only
            /// syntactic</para>
            /// <para>  /// information about their context in order to be resolved
            /// (e.g.</para>
            /// <para>  /// whether it is a call expression), which means they can
            /// (and</para>
            /// <para>  /// should) be resolved in an earlier &quot;phase&quot; of
            /// analysis.</para>
            /// <para>  /// Overload expressions sometimes pick up further
            /// information</para>
            /// <para>  /// from their context, like whether the context expects
            /// a</para>
            /// <para>  /// specific function-pointer type, and so frequently
            /// need</para>
            /// <para>  /// special treatment.</para>
            /// </remarks>
            public bool isNonOverloadPlaceholderType()
            {
                var __ret = Internal.isNonOverloadPlaceholderType_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determines whether the given kind corresponds to a placeholder
            /// type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Determines whether the given kind corresponds to a
            /// placeholder type.</para>
            /// </remarks>
            public static bool isPlaceholderTypeKind(clang.BuiltinType.Kind K)
            {
                var arg0 = K;
                var __ret = Internal.isPlaceholderTypeKind_0(arg0);
                return __ret;
            }

            public static bool classof(clang.Type T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>ComplexType - C99 6.2.5p11 - Complex values. This supports the
        /// C99 complex types (_Complex float etc) as well as the GCC integer complex
        /// extensions.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// ComplexType - C99 6.2.5p11 - Complex values.  This supports
        /// the C99 complex</para>
        /// <para>/// types (_Complex float etc) as well as the GCC integer complex
        /// extensions.</para>
        /// <para>///</para>
        /// </remarks>
        public unsafe partial class ComplexType : clang.Type, llvm.FoldingSetImpl.Node, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 40)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr BaseType;

                [FieldOffset(8)]
                public clang.QualType.Internal CanonicalType;

                [FieldOffset(16)]
                internal clang.Type._.Internal __;

                [FieldOffset(0)]
                public global::System.IntPtr NextInFoldingSetBucket;

                [FieldOffset(32)]
                public clang.QualType.Internal ElementType;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11ComplexTypeC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11ComplexType14getElementTypeEv")]
                internal static extern clang.QualType.Internal getElementType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11ComplexType9isSugaredEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isSugared_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11ComplexType7desugarEv")]
                internal static extern clang.QualType.Internal desugar_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11ComplexType7ProfileERN4llvm16FoldingSetNodeIDE")]
                internal static extern void Profile_0(global::System.IntPtr instance, global::System.IntPtr ID);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11ComplexType7ProfileERN4llvm16FoldingSetNodeIDENS_8QualTypeE")]
                internal static extern void Profile_1(global::System.IntPtr ID, clang.QualType.Internal Element);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11ComplexType7classofEPKNS_4TypeE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);
            }

            private readonly bool __ownsNativeInstance;

            public static new ComplexType __CreateInstance(global::System.IntPtr native)
            {
                return new ComplexType((ComplexType.Internal*) native);
            }

            public static ComplexType __CreateInstance(ComplexType.Internal native)
            {
                return new ComplexType(native);
            }

            private static ComplexType.Internal* __CopyValue(ComplexType.Internal native)
            {
                var ret = (ComplexType.Internal*) Marshal.AllocHGlobal(40);
                *ret = native;
                return ret;
            }

            private ComplexType(ComplexType.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected ComplexType(ComplexType.Internal* native, bool isInternalImpl = false)
                : base((clang.Type.Internal*) native)
            {
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.ExtQualsTypeCommonBase __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.QualType getElementType()
            {
                var __ret = Internal.getElementType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            public bool isSugared()
            {
                var __ret = Internal.isSugared_0(__Instance);
                return __ret;
            }

            public clang.QualType desugar()
            {
                var __ret = Internal.desugar_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            public void Profile(llvm.FoldingSetNodeID ID)
            {
                var arg0 = ReferenceEquals(ID, null) ? global::System.IntPtr.Zero : ID.__Instance;
                Internal.Profile_0(__Instance, arg0);
            }

            public static void Profile(llvm.FoldingSetNodeID ID, clang.QualType Element)
            {
                var arg0 = ReferenceEquals(ID, null) ? global::System.IntPtr.Zero : ID.__Instance;
                var arg1 = ReferenceEquals(Element, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (Element.__Instance);
                Internal.Profile_1(arg0, arg1);
            }

            public static bool classof(clang.Type T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>ParenType - Sugar for parentheses used when specifying
        /// types.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// ParenType - Sugar for parentheses used when specifying
        /// types.</para>
        /// <para>///</para>
        /// </remarks>
        public unsafe partial class ParenType : clang.Type, llvm.FoldingSetImpl.Node, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 40)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr BaseType;

                [FieldOffset(8)]
                public clang.QualType.Internal CanonicalType;

                [FieldOffset(16)]
                internal clang.Type._.Internal __;

                [FieldOffset(0)]
                public global::System.IntPtr NextInFoldingSetBucket;

                [FieldOffset(32)]
                public clang.QualType.Internal Inner;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9ParenTypeC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9ParenType12getInnerTypeEv")]
                internal static extern clang.QualType.Internal getInnerType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9ParenType9isSugaredEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isSugared_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9ParenType7desugarEv")]
                internal static extern clang.QualType.Internal desugar_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9ParenType7ProfileERN4llvm16FoldingSetNodeIDE")]
                internal static extern void Profile_0(global::System.IntPtr instance, global::System.IntPtr ID);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9ParenType7ProfileERN4llvm16FoldingSetNodeIDENS_8QualTypeE")]
                internal static extern void Profile_1(global::System.IntPtr ID, clang.QualType.Internal Inner);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9ParenType7classofEPKNS_4TypeE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);
            }

            private readonly bool __ownsNativeInstance;

            public static new ParenType __CreateInstance(global::System.IntPtr native)
            {
                return new ParenType((ParenType.Internal*) native);
            }

            public static ParenType __CreateInstance(ParenType.Internal native)
            {
                return new ParenType(native);
            }

            private static ParenType.Internal* __CopyValue(ParenType.Internal native)
            {
                var ret = (ParenType.Internal*) Marshal.AllocHGlobal(40);
                *ret = native;
                return ret;
            }

            private ParenType(ParenType.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected ParenType(ParenType.Internal* native, bool isInternalImpl = false)
                : base((clang.Type.Internal*) native)
            {
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.ExtQualsTypeCommonBase __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.QualType getInnerType()
            {
                var __ret = Internal.getInnerType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            public bool isSugared()
            {
                var __ret = Internal.isSugared_0(__Instance);
                return __ret;
            }

            public clang.QualType desugar()
            {
                var __ret = Internal.desugar_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            public void Profile(llvm.FoldingSetNodeID ID)
            {
                var arg0 = ReferenceEquals(ID, null) ? global::System.IntPtr.Zero : ID.__Instance;
                Internal.Profile_0(__Instance, arg0);
            }

            public static void Profile(llvm.FoldingSetNodeID ID, clang.QualType Inner)
            {
                var arg0 = ReferenceEquals(ID, null) ? global::System.IntPtr.Zero : ID.__Instance;
                var arg1 = ReferenceEquals(Inner, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (Inner.__Instance);
                Internal.Profile_1(arg0, arg1);
            }

            public static bool classof(clang.Type T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>PointerType - C99 6.7.5.1 - Pointer Declarators.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// PointerType - C99 6.7.5.1 - Pointer Declarators.</para>
        /// <para>///</para>
        /// </remarks>
        public unsafe partial class PointerType : clang.Type, llvm.FoldingSetImpl.Node, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 40)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr BaseType;

                [FieldOffset(8)]
                public clang.QualType.Internal CanonicalType;

                [FieldOffset(16)]
                internal clang.Type._.Internal __;

                [FieldOffset(0)]
                public global::System.IntPtr NextInFoldingSetBucket;

                [FieldOffset(32)]
                public clang.QualType.Internal PointeeType;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11PointerTypeC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11PointerType14getPointeeTypeEv")]
                internal static extern clang.QualType.Internal getPointeeType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11PointerType25isAddressSpaceOverlappingERKS0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isAddressSpaceOverlapping_0(global::System.IntPtr instance, global::System.IntPtr other);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11PointerType9isSugaredEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isSugared_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11PointerType7desugarEv")]
                internal static extern clang.QualType.Internal desugar_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11PointerType7ProfileERN4llvm16FoldingSetNodeIDE")]
                internal static extern void Profile_0(global::System.IntPtr instance, global::System.IntPtr ID);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11PointerType7ProfileERN4llvm16FoldingSetNodeIDENS_8QualTypeE")]
                internal static extern void Profile_1(global::System.IntPtr ID, clang.QualType.Internal Pointee);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11PointerType7classofEPKNS_4TypeE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);
            }

            private readonly bool __ownsNativeInstance;

            public static new PointerType __CreateInstance(global::System.IntPtr native)
            {
                return new PointerType((PointerType.Internal*) native);
            }

            public static PointerType __CreateInstance(PointerType.Internal native)
            {
                return new PointerType(native);
            }

            private static PointerType.Internal* __CopyValue(PointerType.Internal native)
            {
                var ret = (PointerType.Internal*) Marshal.AllocHGlobal(40);
                *ret = native;
                return ret;
            }

            private PointerType(PointerType.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected PointerType(PointerType.Internal* native, bool isInternalImpl = false)
                : base((clang.Type.Internal*) native)
            {
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.ExtQualsTypeCommonBase __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.QualType getPointeeType()
            {
                var __ret = Internal.getPointeeType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Returns true if address spaces of pointers overlap. OpenCL v2.0
            /// defines conversion rules for pointers to different address spaces (OpenCLC
            /// v2.0 s6.5.5) and notion of overlapping address spaces. CL1.1 or CL1.2:
            /// address spaces overlap iff they are they same. CL2.0 adds: __generic
            /// overlaps with any address space except for __constant.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Returns true if address spaces of pointers
            /// overlap.</para>
            /// <para>  /// OpenCL v2.0 defines conversion rules for pointers to
            /// different</para>
            /// <para>  /// address spaces (OpenCLC v2.0 s6.5.5) and notion of
            /// overlapping</para>
            /// <para>  /// address spaces.</para>
            /// <para>  /// CL1.1 or CL1.2:</para>
            /// <para>  ///   address spaces overlap iff they are they same.</para>
            /// <para>  /// CL2.0 adds:</para>
            /// <para>  ///   __generic overlaps with any address space except for
            /// __constant.</para>
            /// </remarks>
            public bool isAddressSpaceOverlapping(clang.PointerType other)
            {
                var arg0 = ReferenceEquals(other, null) ? global::System.IntPtr.Zero : other.__Instance;
                var __ret = Internal.isAddressSpaceOverlapping_0(__Instance, arg0);
                return __ret;
            }

            public bool isSugared()
            {
                var __ret = Internal.isSugared_0(__Instance);
                return __ret;
            }

            public clang.QualType desugar()
            {
                var __ret = Internal.desugar_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            public void Profile(llvm.FoldingSetNodeID ID)
            {
                var arg0 = ReferenceEquals(ID, null) ? global::System.IntPtr.Zero : ID.__Instance;
                Internal.Profile_0(__Instance, arg0);
            }

            public static void Profile(llvm.FoldingSetNodeID ID, clang.QualType Pointee)
            {
                var arg0 = ReferenceEquals(ID, null) ? global::System.IntPtr.Zero : ID.__Instance;
                var arg1 = ReferenceEquals(Pointee, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (Pointee.__Instance);
                Internal.Profile_1(arg0, arg1);
            }

            public static bool classof(clang.Type T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Represents a type which was implicitly adjusted by the semantic
        /// engine for arbitrary reasons. For example, array and function types can
        /// decay, and function types can have their calling conventions
        /// adjusted.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief Represents a type which was implicitly adjusted by the
        /// semantic</para>
        /// <para>/// engine for arbitrary reasons.  For example, array and
        /// function types can</para>
        /// <para>/// decay, and function types can have their calling conventions
        /// adjusted.</para>
        /// </remarks>
        public unsafe partial class AdjustedType : clang.Type, llvm.FoldingSetImpl.Node, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 48)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr BaseType;

                [FieldOffset(8)]
                public clang.QualType.Internal CanonicalType;

                [FieldOffset(16)]
                internal clang.Type._.Internal __;

                [FieldOffset(0)]
                public global::System.IntPtr NextInFoldingSetBucket;

                [FieldOffset(32)]
                public clang.QualType.Internal OriginalTy;

                [FieldOffset(40)]
                public clang.QualType.Internal AdjustedTy;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12AdjustedTypeC2ENS_4Type9TypeClassENS_8QualTypeES3_S3_")]
                internal static extern void ctor_0(global::System.IntPtr instance, clang.Type.TypeClass TC, clang.QualType.Internal OriginalTy, clang.QualType.Internal AdjustedTy, clang.QualType.Internal CanonicalPtr);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12AdjustedTypeC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12AdjustedType15getOriginalTypeEv")]
                internal static extern clang.QualType.Internal getOriginalType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12AdjustedType15getAdjustedTypeEv")]
                internal static extern clang.QualType.Internal getAdjustedType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12AdjustedType9isSugaredEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isSugared_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12AdjustedType7desugarEv")]
                internal static extern clang.QualType.Internal desugar_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12AdjustedType7ProfileERN4llvm16FoldingSetNodeIDE")]
                internal static extern void Profile_0(global::System.IntPtr instance, global::System.IntPtr ID);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12AdjustedType7ProfileERN4llvm16FoldingSetNodeIDENS_8QualTypeES4_")]
                internal static extern void Profile_1(global::System.IntPtr ID, clang.QualType.Internal Orig, clang.QualType.Internal New);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12AdjustedType7classofEPKNS_4TypeE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);
            }

            private readonly bool __ownsNativeInstance;

            public static new AdjustedType __CreateInstance(global::System.IntPtr native)
            {
                return new AdjustedType((AdjustedType.Internal*) native);
            }

            public static AdjustedType __CreateInstance(AdjustedType.Internal native)
            {
                return new AdjustedType(native);
            }

            private static AdjustedType.Internal* __CopyValue(AdjustedType.Internal native)
            {
                var ret = (AdjustedType.Internal*) Marshal.AllocHGlobal(48);
                *ret = native;
                return ret;
            }

            private AdjustedType(AdjustedType.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected AdjustedType(AdjustedType.Internal* native, bool isInternalImpl = false)
                : base((clang.Type.Internal*) native)
            {
            }

            protected AdjustedType(clang.Type.TypeClass TC, clang.QualType OriginalTy, clang.QualType AdjustedTy, clang.QualType CanonicalPtr)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(48);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = TC;
                var arg1 = ReferenceEquals(OriginalTy, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (OriginalTy.__Instance);
                var arg2 = ReferenceEquals(AdjustedTy, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (AdjustedTy.__Instance);
                var arg3 = ReferenceEquals(CanonicalPtr, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (CanonicalPtr.__Instance);
                Internal.ctor_0(__Instance, arg0, arg1, arg2, arg3);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.ExtQualsTypeCommonBase __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.QualType getOriginalType()
            {
                var __ret = Internal.getOriginalType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            public clang.QualType getAdjustedType()
            {
                var __ret = Internal.getAdjustedType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            public bool isSugared()
            {
                var __ret = Internal.isSugared_0(__Instance);
                return __ret;
            }

            public clang.QualType desugar()
            {
                var __ret = Internal.desugar_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            public void Profile(llvm.FoldingSetNodeID ID)
            {
                var arg0 = ReferenceEquals(ID, null) ? global::System.IntPtr.Zero : ID.__Instance;
                Internal.Profile_0(__Instance, arg0);
            }

            public static void Profile(llvm.FoldingSetNodeID ID, clang.QualType Orig, clang.QualType New)
            {
                var arg0 = ReferenceEquals(ID, null) ? global::System.IntPtr.Zero : ID.__Instance;
                var arg1 = ReferenceEquals(Orig, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (Orig.__Instance);
                var arg2 = ReferenceEquals(New, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (New.__Instance);
                Internal.Profile_1(arg0, arg1, arg2);
            }

            public static bool classof(clang.Type T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Represents a pointer type decayed from an array or function
        /// type.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief Represents a pointer type decayed from an array or
        /// function type.</para>
        /// </remarks>
        public unsafe partial class DecayedType : clang.AdjustedType, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 48)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr BaseType;

                [FieldOffset(8)]
                public clang.QualType.Internal CanonicalType;

                [FieldOffset(16)]
                internal clang.Type._.Internal __;

                [FieldOffset(0)]
                public global::System.IntPtr NextInFoldingSetBucket;

                [FieldOffset(32)]
                public clang.QualType.Internal OriginalTy;

                [FieldOffset(40)]
                public clang.QualType.Internal AdjustedTy;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11DecayedTypeC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11DecayedType14getDecayedTypeEv")]
                internal static extern clang.QualType.Internal getDecayedType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11DecayedType14getPointeeTypeEv")]
                internal static extern clang.QualType.Internal getPointeeType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11DecayedType7classofEPKNS_4TypeE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);
            }

            private readonly bool __ownsNativeInstance;

            public static new DecayedType __CreateInstance(global::System.IntPtr native)
            {
                return new DecayedType((DecayedType.Internal*) native);
            }

            public static DecayedType __CreateInstance(DecayedType.Internal native)
            {
                return new DecayedType(native);
            }

            private static DecayedType.Internal* __CopyValue(DecayedType.Internal native)
            {
                var ret = (DecayedType.Internal*) Marshal.AllocHGlobal(48);
                *ret = native;
                return ret;
            }

            private DecayedType(DecayedType.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected DecayedType(DecayedType.Internal* native, bool isInternalImpl = false)
                : base((clang.AdjustedType.Internal*) native)
            {
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.ExtQualsTypeCommonBase __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.QualType getDecayedType()
            {
                var __ret = Internal.getDecayedType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            public clang.QualType getPointeeType()
            {
                var __ret = Internal.getPointeeType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            public static bool classof(clang.Type T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>BlockPointerType - pointer to a block type. This type is to
        /// represent types syntactically represented as &quot;void (^)(int)&quot;,
        /// etc. Pointee is required to always be a function type.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// BlockPointerType - pointer to a block type.</para>
        /// <para>/// This type is to represent types syntactically represented
        /// as</para>
        /// <para>/// &quot;void (^)(int)&quot;, etc. Pointee is required to always
        /// be a function type.</para>
        /// <para>///</para>
        /// </remarks>
        public unsafe partial class BlockPointerType : clang.Type, llvm.FoldingSetImpl.Node, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 40)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr BaseType;

                [FieldOffset(8)]
                public clang.QualType.Internal CanonicalType;

                [FieldOffset(16)]
                internal clang.Type._.Internal __;

                [FieldOffset(0)]
                public global::System.IntPtr NextInFoldingSetBucket;

                [FieldOffset(32)]
                public clang.QualType.Internal PointeeType;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16BlockPointerTypeC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang16BlockPointerType14getPointeeTypeEv")]
                internal static extern clang.QualType.Internal getPointeeType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang16BlockPointerType9isSugaredEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isSugared_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang16BlockPointerType7desugarEv")]
                internal static extern clang.QualType.Internal desugar_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16BlockPointerType7ProfileERN4llvm16FoldingSetNodeIDE")]
                internal static extern void Profile_0(global::System.IntPtr instance, global::System.IntPtr ID);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16BlockPointerType7ProfileERN4llvm16FoldingSetNodeIDENS_8QualTypeE")]
                internal static extern void Profile_1(global::System.IntPtr ID, clang.QualType.Internal Pointee);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16BlockPointerType7classofEPKNS_4TypeE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);
            }

            private readonly bool __ownsNativeInstance;

            public static new BlockPointerType __CreateInstance(global::System.IntPtr native)
            {
                return new BlockPointerType((BlockPointerType.Internal*) native);
            }

            public static BlockPointerType __CreateInstance(BlockPointerType.Internal native)
            {
                return new BlockPointerType(native);
            }

            private static BlockPointerType.Internal* __CopyValue(BlockPointerType.Internal native)
            {
                var ret = (BlockPointerType.Internal*) Marshal.AllocHGlobal(40);
                *ret = native;
                return ret;
            }

            private BlockPointerType(BlockPointerType.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected BlockPointerType(BlockPointerType.Internal* native, bool isInternalImpl = false)
                : base((clang.Type.Internal*) native)
            {
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.ExtQualsTypeCommonBase __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.QualType getPointeeType()
            {
                var __ret = Internal.getPointeeType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            public bool isSugared()
            {
                var __ret = Internal.isSugared_0(__Instance);
                return __ret;
            }

            public clang.QualType desugar()
            {
                var __ret = Internal.desugar_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            public void Profile(llvm.FoldingSetNodeID ID)
            {
                var arg0 = ReferenceEquals(ID, null) ? global::System.IntPtr.Zero : ID.__Instance;
                Internal.Profile_0(__Instance, arg0);
            }

            public static void Profile(llvm.FoldingSetNodeID ID, clang.QualType Pointee)
            {
                var arg0 = ReferenceEquals(ID, null) ? global::System.IntPtr.Zero : ID.__Instance;
                var arg1 = ReferenceEquals(Pointee, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (Pointee.__Instance);
                Internal.Profile_1(arg0, arg1);
            }

            public static bool classof(clang.Type T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>ReferenceType - Base for LValueReferenceType and
        /// RValueReferenceType</para>
        /// </summary>
        /// <remarks>
        /// <para>/// ReferenceType - Base for LValueReferenceType and
        /// RValueReferenceType</para>
        /// <para>///</para>
        /// </remarks>
        public unsafe partial class ReferenceType : clang.Type, llvm.FoldingSetImpl.Node, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 40)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr BaseType;

                [FieldOffset(8)]
                public clang.QualType.Internal CanonicalType;

                [FieldOffset(16)]
                internal clang.Type._.Internal __;

                [FieldOffset(0)]
                public global::System.IntPtr NextInFoldingSetBucket;

                [FieldOffset(32)]
                public clang.QualType.Internal PointeeType;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13ReferenceTypeC2ENS_4Type9TypeClassENS_8QualTypeES3_b")]
                internal static extern void ctor_0(global::System.IntPtr instance, clang.Type.TypeClass tc, clang.QualType.Internal Referencee, clang.QualType.Internal CanonicalRef, bool SpelledAsLValue);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13ReferenceTypeC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13ReferenceType17isSpelledAsLValueEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isSpelledAsLValue_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13ReferenceType10isInnerRefEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isInnerRef_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13ReferenceType23getPointeeTypeAsWrittenEv")]
                internal static extern clang.QualType.Internal getPointeeTypeAsWritten_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13ReferenceType14getPointeeTypeEv")]
                internal static extern clang.QualType.Internal getPointeeType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13ReferenceType7ProfileERN4llvm16FoldingSetNodeIDE")]
                internal static extern void Profile_0(global::System.IntPtr instance, global::System.IntPtr ID);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13ReferenceType7ProfileERN4llvm16FoldingSetNodeIDENS_8QualTypeEb")]
                internal static extern void Profile_1(global::System.IntPtr ID, clang.QualType.Internal Referencee, bool SpelledAsLValue);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13ReferenceType7classofEPKNS_4TypeE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);
            }

            private readonly bool __ownsNativeInstance;

            public static new ReferenceType __CreateInstance(global::System.IntPtr native)
            {
                return new ReferenceType((ReferenceType.Internal*) native);
            }

            public static ReferenceType __CreateInstance(ReferenceType.Internal native)
            {
                return new ReferenceType(native);
            }

            private static ReferenceType.Internal* __CopyValue(ReferenceType.Internal native)
            {
                var ret = (ReferenceType.Internal*) Marshal.AllocHGlobal(40);
                *ret = native;
                return ret;
            }

            private ReferenceType(ReferenceType.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected ReferenceType(ReferenceType.Internal* native, bool isInternalImpl = false)
                : base((clang.Type.Internal*) native)
            {
            }

            protected ReferenceType(clang.Type.TypeClass tc, clang.QualType Referencee, clang.QualType CanonicalRef, bool SpelledAsLValue)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(40);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = tc;
                var arg1 = ReferenceEquals(Referencee, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (Referencee.__Instance);
                var arg2 = ReferenceEquals(CanonicalRef, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (CanonicalRef.__Instance);
                Internal.ctor_0(__Instance, arg0, arg1, arg2, SpelledAsLValue);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.ExtQualsTypeCommonBase __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public bool isSpelledAsLValue()
            {
                var __ret = Internal.isSpelledAsLValue_0(__Instance);
                return __ret;
            }

            public bool isInnerRef()
            {
                var __ret = Internal.isInnerRef_0(__Instance);
                return __ret;
            }

            public clang.QualType getPointeeTypeAsWritten()
            {
                var __ret = Internal.getPointeeTypeAsWritten_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            public clang.QualType getPointeeType()
            {
                var __ret = Internal.getPointeeType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            public void Profile(llvm.FoldingSetNodeID ID)
            {
                var arg0 = ReferenceEquals(ID, null) ? global::System.IntPtr.Zero : ID.__Instance;
                Internal.Profile_0(__Instance, arg0);
            }

            public static void Profile(llvm.FoldingSetNodeID ID, clang.QualType Referencee, bool SpelledAsLValue)
            {
                var arg0 = ReferenceEquals(ID, null) ? global::System.IntPtr.Zero : ID.__Instance;
                var arg1 = ReferenceEquals(Referencee, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (Referencee.__Instance);
                Internal.Profile_1(arg0, arg1, SpelledAsLValue);
            }

            public static bool classof(clang.Type T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>LValueReferenceType - C++ [dcl.ref] - Lvalue reference</para>
        /// </summary>
        /// <remarks>
        /// <para>/// LValueReferenceType - C++ [dcl.ref] - Lvalue reference</para>
        /// <para>///</para>
        /// </remarks>
        public unsafe partial class LValueReferenceType : clang.ReferenceType, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 40)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr BaseType;

                [FieldOffset(8)]
                public clang.QualType.Internal CanonicalType;

                [FieldOffset(16)]
                internal clang.Type._.Internal __;

                [FieldOffset(0)]
                public global::System.IntPtr NextInFoldingSetBucket;

                [FieldOffset(32)]
                public clang.QualType.Internal PointeeType;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang19LValueReferenceTypeC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang19LValueReferenceType9isSugaredEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isSugared_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang19LValueReferenceType7desugarEv")]
                internal static extern clang.QualType.Internal desugar_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang19LValueReferenceType7classofEPKNS_4TypeE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);
            }

            private readonly bool __ownsNativeInstance;

            public static new LValueReferenceType __CreateInstance(global::System.IntPtr native)
            {
                return new LValueReferenceType((LValueReferenceType.Internal*) native);
            }

            public static LValueReferenceType __CreateInstance(LValueReferenceType.Internal native)
            {
                return new LValueReferenceType(native);
            }

            private static LValueReferenceType.Internal* __CopyValue(LValueReferenceType.Internal native)
            {
                var ret = (LValueReferenceType.Internal*) Marshal.AllocHGlobal(40);
                *ret = native;
                return ret;
            }

            private LValueReferenceType(LValueReferenceType.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected LValueReferenceType(LValueReferenceType.Internal* native, bool isInternalImpl = false)
                : base((clang.ReferenceType.Internal*) native)
            {
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.ExtQualsTypeCommonBase __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public bool isSugared()
            {
                var __ret = Internal.isSugared_0(__Instance);
                return __ret;
            }

            public clang.QualType desugar()
            {
                var __ret = Internal.desugar_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            public static bool classof(clang.Type T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>RValueReferenceType - C++0x [dcl.ref] - Rvalue reference</para>
        /// </summary>
        /// <remarks>
        /// <para>/// RValueReferenceType - C++0x [dcl.ref] - Rvalue
        /// reference</para>
        /// <para>///</para>
        /// </remarks>
        public unsafe partial class RValueReferenceType : clang.ReferenceType, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 40)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr BaseType;

                [FieldOffset(8)]
                public clang.QualType.Internal CanonicalType;

                [FieldOffset(16)]
                internal clang.Type._.Internal __;

                [FieldOffset(0)]
                public global::System.IntPtr NextInFoldingSetBucket;

                [FieldOffset(32)]
                public clang.QualType.Internal PointeeType;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang19RValueReferenceTypeC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang19RValueReferenceType9isSugaredEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isSugared_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang19RValueReferenceType7desugarEv")]
                internal static extern clang.QualType.Internal desugar_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang19RValueReferenceType7classofEPKNS_4TypeE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);
            }

            private readonly bool __ownsNativeInstance;

            public static new RValueReferenceType __CreateInstance(global::System.IntPtr native)
            {
                return new RValueReferenceType((RValueReferenceType.Internal*) native);
            }

            public static RValueReferenceType __CreateInstance(RValueReferenceType.Internal native)
            {
                return new RValueReferenceType(native);
            }

            private static RValueReferenceType.Internal* __CopyValue(RValueReferenceType.Internal native)
            {
                var ret = (RValueReferenceType.Internal*) Marshal.AllocHGlobal(40);
                *ret = native;
                return ret;
            }

            private RValueReferenceType(RValueReferenceType.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected RValueReferenceType(RValueReferenceType.Internal* native, bool isInternalImpl = false)
                : base((clang.ReferenceType.Internal*) native)
            {
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.ExtQualsTypeCommonBase __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public bool isSugared()
            {
                var __ret = Internal.isSugared_0(__Instance);
                return __ret;
            }

            public clang.QualType desugar()
            {
                var __ret = Internal.desugar_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            public static bool classof(clang.Type T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>MemberPointerType - C++ 8.3.3 - Pointers to members</para>
        /// </summary>
        /// <remarks>
        /// <para>/// MemberPointerType - C++ 8.3.3 - Pointers to members</para>
        /// <para>///</para>
        /// </remarks>
        public unsafe partial class MemberPointerType : clang.Type, llvm.FoldingSetImpl.Node, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 48)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr BaseType;

                [FieldOffset(8)]
                public clang.QualType.Internal CanonicalType;

                [FieldOffset(16)]
                internal clang.Type._.Internal __;

                [FieldOffset(0)]
                public global::System.IntPtr NextInFoldingSetBucket;

                [FieldOffset(32)]
                public clang.QualType.Internal PointeeType;

                [FieldOffset(40)]
                public global::System.IntPtr Class;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17MemberPointerTypeC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17MemberPointerType14getPointeeTypeEv")]
                internal static extern clang.QualType.Internal getPointeeType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17MemberPointerType23isMemberFunctionPointerEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isMemberFunctionPointer_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17MemberPointerType19isMemberDataPointerEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isMemberDataPointer_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17MemberPointerType8getClassEv")]
                internal static extern global::System.IntPtr getClass_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17MemberPointerType9isSugaredEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isSugared_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17MemberPointerType7desugarEv")]
                internal static extern clang.QualType.Internal desugar_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17MemberPointerType7ProfileERN4llvm16FoldingSetNodeIDE")]
                internal static extern void Profile_0(global::System.IntPtr instance, global::System.IntPtr ID);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17MemberPointerType7ProfileERN4llvm16FoldingSetNodeIDENS_8QualTypeEPKNS_4TypeE")]
                internal static extern void Profile_1(global::System.IntPtr ID, clang.QualType.Internal Pointee, global::System.IntPtr Class);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17MemberPointerType7classofEPKNS_4TypeE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);
            }

            private readonly bool __ownsNativeInstance;

            public static new MemberPointerType __CreateInstance(global::System.IntPtr native)
            {
                return new MemberPointerType((MemberPointerType.Internal*) native);
            }

            public static MemberPointerType __CreateInstance(MemberPointerType.Internal native)
            {
                return new MemberPointerType(native);
            }

            private static MemberPointerType.Internal* __CopyValue(MemberPointerType.Internal native)
            {
                var ret = (MemberPointerType.Internal*) Marshal.AllocHGlobal(48);
                *ret = native;
                return ret;
            }

            private MemberPointerType(MemberPointerType.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected MemberPointerType(MemberPointerType.Internal* native, bool isInternalImpl = false)
                : base((clang.Type.Internal*) native)
            {
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.ExtQualsTypeCommonBase __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.QualType getPointeeType()
            {
                var __ret = Internal.getPointeeType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Returns true if the member type (i.e. the pointee type) is a
            /// function type rather than a data-member type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Returns true if the member type (i.e. the pointee type) is
            /// a</para>
            /// <para>  /// function type rather than a data-member type.</para>
            /// </remarks>
            public bool isMemberFunctionPointer()
            {
                var __ret = Internal.isMemberFunctionPointer_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Returns true if the member type (i.e. the pointee type) is a data
            /// type rather than a function type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Returns true if the member type (i.e. the pointee type) is
            /// a</para>
            /// <para>  /// data type rather than a function type.</para>
            /// </remarks>
            public bool isMemberDataPointer()
            {
                var __ret = Internal.isMemberDataPointer_0(__Instance);
                return __ret;
            }

            public clang.Type getClass()
            {
                var __ret = Internal.getClass_0(__Instance);
                clang.Type __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Type.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Type) clang.Type.NativeToManagedMap[__ret];
                else __result0 = clang.Type.__CreateInstance(__ret);
                return __result0;
            }

            public bool isSugared()
            {
                var __ret = Internal.isSugared_0(__Instance);
                return __ret;
            }

            public clang.QualType desugar()
            {
                var __ret = Internal.desugar_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            public void Profile(llvm.FoldingSetNodeID ID)
            {
                var arg0 = ReferenceEquals(ID, null) ? global::System.IntPtr.Zero : ID.__Instance;
                Internal.Profile_0(__Instance, arg0);
            }

            public static void Profile(llvm.FoldingSetNodeID ID, clang.QualType Pointee, clang.Type Class)
            {
                var arg0 = ReferenceEquals(ID, null) ? global::System.IntPtr.Zero : ID.__Instance;
                var arg1 = ReferenceEquals(Pointee, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (Pointee.__Instance);
                var arg2 = ReferenceEquals(Class, null) ? global::System.IntPtr.Zero : Class.__Instance;
                Internal.Profile_1(arg0, arg1, arg2);
            }

            public static bool classof(clang.Type T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>ArrayType - C99 6.7.5.2 - Array Declarators.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// ArrayType - C99 6.7.5.2 - Array Declarators.</para>
        /// <para>///</para>
        /// </remarks>
        public unsafe partial class ArrayType : clang.Type, llvm.FoldingSetImpl.Node, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 40)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr BaseType;

                [FieldOffset(8)]
                public clang.QualType.Internal CanonicalType;

                [FieldOffset(16)]
                internal clang.Type._.Internal __;

                [FieldOffset(0)]
                public global::System.IntPtr NextInFoldingSetBucket;

                [FieldOffset(32)]
                public clang.QualType.Internal ElementType;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9ArrayTypeC2ENS_4Type9TypeClassENS_8QualTypeES3_NS0_17ArraySizeModifierEjb")]
                internal static extern void ctor_0(global::System.IntPtr instance, clang.Type.TypeClass tc, clang.QualType.Internal et, clang.QualType.Internal can, clang.ArrayType.ArraySizeModifier sm, uint tq, bool ContainsUnexpandedParameterPack);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9ArrayTypeC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9ArrayType14getElementTypeEv")]
                internal static extern clang.QualType.Internal getElementType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9ArrayType15getSizeModifierEv")]
                internal static extern clang.ArrayType.ArraySizeModifier getSizeModifier_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9ArrayType22getIndexTypeQualifiersEv")]
                internal static extern clang.Qualifiers.Internal getIndexTypeQualifiers_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9ArrayType25getIndexTypeCVRQualifiersEv")]
                internal static extern uint getIndexTypeCVRQualifiers_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9ArrayType7classofEPKNS_4TypeE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);
            }

            /// <summary>
            /// <para>ArraySizeModifier - Capture whether this is a normal array (e.g.
            /// int X[4]) an array with a static size (e.g. int X[static 4]), or an array
            /// with a star size (e.g. int X[*]). 'static' is only allowed on function
            /// parameters.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// ArraySizeModifier - Capture whether this is a normal array
            /// (e.g. int X[4])</para>
            /// <para>  /// an array with a static size (e.g. int X[static 4]), or an
            /// array</para>
            /// <para>  /// with a star size (e.g. int X[*]).</para>
            /// <para>  /// 'static' is only allowed on function parameters.</para>
            /// </remarks>
            public enum ArraySizeModifier : uint
            {
                Normal = 0,
                Static = 1,
                Star = 2
            }

            private readonly bool __ownsNativeInstance;

            public static new ArrayType __CreateInstance(global::System.IntPtr native)
            {
                return new ArrayType((ArrayType.Internal*) native);
            }

            public static ArrayType __CreateInstance(ArrayType.Internal native)
            {
                return new ArrayType(native);
            }

            private static ArrayType.Internal* __CopyValue(ArrayType.Internal native)
            {
                var ret = (ArrayType.Internal*) Marshal.AllocHGlobal(40);
                *ret = native;
                return ret;
            }

            private ArrayType(ArrayType.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected ArrayType(ArrayType.Internal* native, bool isInternalImpl = false)
                : base((clang.Type.Internal*) native)
            {
            }

            protected ArrayType(clang.Type.TypeClass tc, clang.QualType et, clang.QualType can, clang.ArrayType.ArraySizeModifier sm, uint tq, bool ContainsUnexpandedParameterPack)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(40);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = tc;
                var arg1 = ReferenceEquals(et, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (et.__Instance);
                var arg2 = ReferenceEquals(can, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (can.__Instance);
                var arg3 = sm;
                Internal.ctor_0(__Instance, arg0, arg1, arg2, arg3, tq, ContainsUnexpandedParameterPack);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.ExtQualsTypeCommonBase __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.QualType getElementType()
            {
                var __ret = Internal.getElementType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            public clang.ArrayType.ArraySizeModifier getSizeModifier()
            {
                var __ret = Internal.getSizeModifier_0(__Instance);
                return __ret;
            }

            public clang.Qualifiers getIndexTypeQualifiers()
            {
                var __ret = Internal.getIndexTypeQualifiers_0(__Instance);
                return clang.Qualifiers.__CreateInstance(__ret);
            }

            public uint getIndexTypeCVRQualifiers()
            {
                var __ret = Internal.getIndexTypeCVRQualifiers_0(__Instance);
                return __ret;
            }

            public static bool classof(clang.Type T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>ConstantArrayType - This class represents the canonical version
        /// of C arrays with a specified constant size. For example, the canonical type
        /// for 'int A[4 + 4*100]' is a ConstantArrayType where the element type is
        /// 'int' and the size is 404.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// ConstantArrayType - This class represents the canonical
        /// version of</para>
        /// <para>/// C arrays with a specified constant size.  For example, the
        /// canonical</para>
        /// <para>/// type for 'int A[4 + 4*100]' is a ConstantArrayType where the
        /// element</para>
        /// <para>/// type is 'int' and the size is 404.</para>
        /// </remarks>
        public unsafe partial class ConstantArrayType : clang.ArrayType, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 56)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr BaseType;

                [FieldOffset(8)]
                public clang.QualType.Internal CanonicalType;

                [FieldOffset(16)]
                internal clang.Type._.Internal __;

                [FieldOffset(0)]
                public global::System.IntPtr NextInFoldingSetBucket;

                [FieldOffset(32)]
                public clang.QualType.Internal ElementType;

                [FieldOffset(40)]
                public llvm.APInt.Internal Size;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17ConstantArrayTypeC2ENS_4Type9TypeClassENS_8QualTypeES3_RKN4llvm5APIntENS_9ArrayType17ArraySizeModifierEj")]
                internal static extern void ctor_1(global::System.IntPtr instance, clang.Type.TypeClass tc, clang.QualType.Internal et, clang.QualType.Internal can, global::System.IntPtr size, clang.ArrayType.ArraySizeModifier sm, uint tq);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17ConstantArrayTypeC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17ConstantArrayTypeD2Ev")]
                internal static extern void dtor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17ConstantArrayType7getSizeEv")]
                internal static extern global::System.IntPtr getSize_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17ConstantArrayType9isSugaredEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isSugared_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17ConstantArrayType7desugarEv")]
                internal static extern clang.QualType.Internal desugar_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17ConstantArrayType20getNumAddressingBitsERNS_10ASTContextENS_8QualTypeERKN4llvm5APIntE")]
                internal static extern uint getNumAddressingBits_0(global::System.IntPtr Context, clang.QualType.Internal ElementType, global::System.IntPtr NumElements);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17ConstantArrayType14getMaxSizeBitsERNS_10ASTContextE")]
                internal static extern uint getMaxSizeBits_0(global::System.IntPtr Context);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17ConstantArrayType7ProfileERN4llvm16FoldingSetNodeIDE")]
                internal static extern void Profile_0(global::System.IntPtr instance, global::System.IntPtr ID);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17ConstantArrayType7ProfileERN4llvm16FoldingSetNodeIDENS_8QualTypeERKNS1_5APIntENS_9ArrayType17ArraySizeModifierEj")]
                internal static extern void Profile_1(global::System.IntPtr ID, clang.QualType.Internal ET, global::System.IntPtr ArraySize, clang.ArrayType.ArraySizeModifier SizeMod, uint TypeQuals);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17ConstantArrayType7classofEPKNS_4TypeE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);
            }

            private readonly bool __ownsNativeInstance;

            public static new ConstantArrayType __CreateInstance(global::System.IntPtr native)
            {
                return new ConstantArrayType((ConstantArrayType.Internal*) native);
            }

            public static ConstantArrayType __CreateInstance(ConstantArrayType.Internal native)
            {
                return new ConstantArrayType(native);
            }

            private static ConstantArrayType.Internal* __CopyValue(ConstantArrayType.Internal native)
            {
                var ret = (ConstantArrayType.Internal*) Marshal.AllocHGlobal(56);
                *ret = native;
                return ret;
            }

            private ConstantArrayType(ConstantArrayType.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected ConstantArrayType(ConstantArrayType.Internal* native, bool isInternalImpl = false)
                : base((clang.ArrayType.Internal*) native)
            {
            }

            protected ConstantArrayType(clang.Type.TypeClass tc, clang.QualType et, clang.QualType can, llvm.APInt size, clang.ArrayType.ArraySizeModifier sm, uint tq)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(56);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = tc;
                var arg1 = ReferenceEquals(et, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (et.__Instance);
                var arg2 = ReferenceEquals(can, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (can.__Instance);
                var arg3 = ReferenceEquals(size, null) ? global::System.IntPtr.Zero : size.__Instance;
                var arg4 = sm;
                Internal.ctor_1(__Instance, arg0, arg1, arg2, arg3, arg4, tq);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.ExtQualsTypeCommonBase __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public llvm.APInt getSize()
            {
                var __ret = Internal.getSize_0(__Instance);
                llvm.APInt __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (llvm.APInt.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (llvm.APInt) llvm.APInt.NativeToManagedMap[__ret];
                else __result0 = llvm.APInt.__CreateInstance(__ret);
                return __result0;
            }

            public bool isSugared()
            {
                var __ret = Internal.isSugared_0(__Instance);
                return __ret;
            }

            public clang.QualType desugar()
            {
                var __ret = Internal.desugar_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            public void Profile(llvm.FoldingSetNodeID ID)
            {
                var arg0 = ReferenceEquals(ID, null) ? global::System.IntPtr.Zero : ID.__Instance;
                Internal.Profile_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>Determine the number of bits required to address a member
            /// of</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine the number of bits required to address a
            /// member of</para>
            /// </remarks>
            public static uint getNumAddressingBits(clang.ASTContext Context, clang.QualType ElementType, llvm.APInt NumElements)
            {
                var arg0 = ReferenceEquals(Context, null) ? global::System.IntPtr.Zero : Context.__Instance;
                var arg1 = ReferenceEquals(ElementType, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (ElementType.__Instance);
                var arg2 = ReferenceEquals(NumElements, null) ? global::System.IntPtr.Zero : NumElements.__Instance;
                var __ret = Internal.getNumAddressingBits_0(arg0, arg1, arg2);
                return __ret;
            }

            /// <summary>
            /// <para>Determine the maximum number of active bits that an array's size
            /// can require, which limits the maximum size of the array.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine the maximum number of active bits that an
            /// array's size</para>
            /// <para>  /// can require, which limits the maximum size of the
            /// array.</para>
            /// </remarks>
            public static uint getMaxSizeBits(clang.ASTContext Context)
            {
                var arg0 = ReferenceEquals(Context, null) ? global::System.IntPtr.Zero : Context.__Instance;
                var __ret = Internal.getMaxSizeBits_0(arg0);
                return __ret;
            }

            public static void Profile(llvm.FoldingSetNodeID ID, clang.QualType ET, llvm.APInt ArraySize, clang.ArrayType.ArraySizeModifier SizeMod, uint TypeQuals)
            {
                var arg0 = ReferenceEquals(ID, null) ? global::System.IntPtr.Zero : ID.__Instance;
                var arg1 = ReferenceEquals(ET, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (ET.__Instance);
                var arg2 = ReferenceEquals(ArraySize, null) ? global::System.IntPtr.Zero : ArraySize.__Instance;
                var arg3 = SizeMod;
                Internal.Profile_1(arg0, arg1, arg2, arg3, TypeQuals);
            }

            public static bool classof(clang.Type T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>IncompleteArrayType - This class represents C arrays with an
        /// unspecified size. For example 'int A[]' has an IncompleteArrayType where
        /// the element type is 'int' and the size is unspecified.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// IncompleteArrayType - This class represents C arrays with an
        /// unspecified</para>
        /// <para>/// size.  For example 'int A[]' has an IncompleteArrayType where
        /// the element</para>
        /// <para>/// type is 'int' and the size is unspecified.</para>
        /// </remarks>
        public unsafe partial class IncompleteArrayType : clang.ArrayType, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 40)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr BaseType;

                [FieldOffset(8)]
                public clang.QualType.Internal CanonicalType;

                [FieldOffset(16)]
                internal clang.Type._.Internal __;

                [FieldOffset(0)]
                public global::System.IntPtr NextInFoldingSetBucket;

                [FieldOffset(32)]
                public clang.QualType.Internal ElementType;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang19IncompleteArrayTypeC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang19IncompleteArrayType9isSugaredEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isSugared_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang19IncompleteArrayType7desugarEv")]
                internal static extern clang.QualType.Internal desugar_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang19IncompleteArrayType7classofEPKNS_4TypeE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang19IncompleteArrayType7ProfileERN4llvm16FoldingSetNodeIDE")]
                internal static extern void Profile_0(global::System.IntPtr instance, global::System.IntPtr ID);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang19IncompleteArrayType7ProfileERN4llvm16FoldingSetNodeIDENS_8QualTypeENS_9ArrayType17ArraySizeModifierEj")]
                internal static extern void Profile_1(global::System.IntPtr ID, clang.QualType.Internal ET, clang.ArrayType.ArraySizeModifier SizeMod, uint TypeQuals);
            }

            private readonly bool __ownsNativeInstance;

            public static new IncompleteArrayType __CreateInstance(global::System.IntPtr native)
            {
                return new IncompleteArrayType((IncompleteArrayType.Internal*) native);
            }

            public static IncompleteArrayType __CreateInstance(IncompleteArrayType.Internal native)
            {
                return new IncompleteArrayType(native);
            }

            private static IncompleteArrayType.Internal* __CopyValue(IncompleteArrayType.Internal native)
            {
                var ret = (IncompleteArrayType.Internal*) Marshal.AllocHGlobal(40);
                *ret = native;
                return ret;
            }

            private IncompleteArrayType(IncompleteArrayType.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected IncompleteArrayType(IncompleteArrayType.Internal* native, bool isInternalImpl = false)
                : base((clang.ArrayType.Internal*) native)
            {
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.ExtQualsTypeCommonBase __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public bool isSugared()
            {
                var __ret = Internal.isSugared_0(__Instance);
                return __ret;
            }

            public clang.QualType desugar()
            {
                var __ret = Internal.desugar_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            public void Profile(llvm.FoldingSetNodeID ID)
            {
                var arg0 = ReferenceEquals(ID, null) ? global::System.IntPtr.Zero : ID.__Instance;
                Internal.Profile_0(__Instance, arg0);
            }

            public static bool classof(clang.Type T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }

            public static void Profile(llvm.FoldingSetNodeID ID, clang.QualType ET, clang.ArrayType.ArraySizeModifier SizeMod, uint TypeQuals)
            {
                var arg0 = ReferenceEquals(ID, null) ? global::System.IntPtr.Zero : ID.__Instance;
                var arg1 = ReferenceEquals(ET, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (ET.__Instance);
                var arg2 = SizeMod;
                Internal.Profile_1(arg0, arg1, arg2, TypeQuals);
            }
        }

        /// <summary>
        /// <para>VariableArrayType - This class represents C arrays with a
        /// specified size which is not an integer-constant-expression. For example,
        /// 'int s[x+foo()]'. Since the size expression is an arbitrary expression, we
        /// store it as such.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// VariableArrayType - This class represents C arrays with a
        /// specified size</para>
        /// <para>/// which is not an integer-constant-expression.  For example,
        /// 'int s[x+foo()]'.</para>
        /// <para>/// Since the size expression is an arbitrary expression, we
        /// store it as such.</para>
        /// <para>///</para>
        /// <para>/// Note: VariableArrayType's aren't uniqued (since the
        /// expressions aren't) and</para>
        /// <para>/// should not be: two lexically equivalent variable array types
        /// could mean</para>
        /// <para>/// different things, for example, these variables do not have
        /// the same type</para>
        /// <para>/// dynamically:</para>
        /// <para>///</para>
        /// <para>/// void foo(int x) {</para>
        /// <para>///   int Y[x];</para>
        /// <para>///   ++x;</para>
        /// <para>///   int Z[x];</para>
        /// <para>/// }</para>
        /// <para>///</para>
        /// </remarks>
        public unsafe partial class VariableArrayType : clang.ArrayType, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 56)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr BaseType;

                [FieldOffset(8)]
                public clang.QualType.Internal CanonicalType;

                [FieldOffset(16)]
                internal clang.Type._.Internal __;

                [FieldOffset(0)]
                public global::System.IntPtr NextInFoldingSetBucket;

                [FieldOffset(32)]
                public clang.QualType.Internal ElementType;

                [FieldOffset(40)]
                public global::System.IntPtr SizeExpr;

                [FieldOffset(48)]
                public clang.SourceRange.Internal Brackets;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17VariableArrayTypeC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17VariableArrayType16getBracketsRangeEv")]
                internal static extern clang.SourceRange.Internal getBracketsRange_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17VariableArrayType14getLBracketLocEv")]
                internal static extern clang.SourceLocation.Internal getLBracketLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17VariableArrayType14getRBracketLocEv")]
                internal static extern clang.SourceLocation.Internal getRBracketLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17VariableArrayType9isSugaredEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isSugared_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17VariableArrayType7desugarEv")]
                internal static extern clang.QualType.Internal desugar_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17VariableArrayType7classofEPKNS_4TypeE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17VariableArrayType7ProfileERN4llvm16FoldingSetNodeIDE")]
                internal static extern void Profile_0(global::System.IntPtr instance, global::System.IntPtr ID);
            }

            private readonly bool __ownsNativeInstance;

            public static new VariableArrayType __CreateInstance(global::System.IntPtr native)
            {
                return new VariableArrayType((VariableArrayType.Internal*) native);
            }

            public static VariableArrayType __CreateInstance(VariableArrayType.Internal native)
            {
                return new VariableArrayType(native);
            }

            private static VariableArrayType.Internal* __CopyValue(VariableArrayType.Internal native)
            {
                var ret = (VariableArrayType.Internal*) Marshal.AllocHGlobal(56);
                *ret = native;
                return ret;
            }

            private VariableArrayType(VariableArrayType.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected VariableArrayType(VariableArrayType.Internal* native, bool isInternalImpl = false)
                : base((clang.ArrayType.Internal*) native)
            {
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.ExtQualsTypeCommonBase __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.SourceRange getBracketsRange()
            {
                var __ret = Internal.getBracketsRange_0(__Instance);
                return clang.SourceRange.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLBracketLoc()
            {
                var __ret = Internal.getLBracketLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getRBracketLoc()
            {
                var __ret = Internal.getRBracketLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public bool isSugared()
            {
                var __ret = Internal.isSugared_0(__Instance);
                return __ret;
            }

            public clang.QualType desugar()
            {
                var __ret = Internal.desugar_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            public void Profile(llvm.FoldingSetNodeID ID)
            {
                var arg0 = ReferenceEquals(ID, null) ? global::System.IntPtr.Zero : ID.__Instance;
                Internal.Profile_0(__Instance, arg0);
            }

            public static bool classof(clang.Type T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>DependentSizedArrayType - This type represents an array type in
        /// C++ whose size is a value-dependent expression. For example:</para>
        /// </summary>
        /// <remarks>
        /// <para>/// DependentSizedArrayType - This type represents an array type
        /// in</para>
        /// <para>/// C++ whose size is a value-dependent expression. For
        /// example:</para>
        /// <para>///</para>
        /// <para>/// \code</para>
        /// <para>/// template&lt;typename T, int Size&gt;</para>
        /// <para>/// class array {</para>
        /// <para>///   T data[Size];</para>
        /// <para>/// };</para>
        /// <para>/// \endcode</para>
        /// <para>///</para>
        /// <para>/// For these types, we won't actually know what the array bound
        /// is</para>
        /// <para>/// until template instantiation occurs, at which point this
        /// will</para>
        /// <para>/// become either a ConstantArrayType or a
        /// VariableArrayType.</para>
        /// </remarks>
        public unsafe partial class DependentSizedArrayType : clang.ArrayType, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 64)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr BaseType;

                [FieldOffset(8)]
                public clang.QualType.Internal CanonicalType;

                [FieldOffset(16)]
                internal clang.Type._.Internal __;

                [FieldOffset(0)]
                public global::System.IntPtr NextInFoldingSetBucket;

                [FieldOffset(32)]
                public clang.QualType.Internal ElementType;

                [FieldOffset(40)]
                public global::System.IntPtr Context;

                [FieldOffset(48)]
                public global::System.IntPtr SizeExpr;

                [FieldOffset(56)]
                public clang.SourceRange.Internal Brackets;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang23DependentSizedArrayTypeC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang23DependentSizedArrayType16getBracketsRangeEv")]
                internal static extern clang.SourceRange.Internal getBracketsRange_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang23DependentSizedArrayType14getLBracketLocEv")]
                internal static extern clang.SourceLocation.Internal getLBracketLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang23DependentSizedArrayType14getRBracketLocEv")]
                internal static extern clang.SourceLocation.Internal getRBracketLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang23DependentSizedArrayType9isSugaredEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isSugared_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang23DependentSizedArrayType7desugarEv")]
                internal static extern clang.QualType.Internal desugar_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang23DependentSizedArrayType7classofEPKNS_4TypeE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang23DependentSizedArrayType7ProfileERN4llvm16FoldingSetNodeIDE")]
                internal static extern void Profile_0(global::System.IntPtr instance, global::System.IntPtr ID);
            }

            private readonly bool __ownsNativeInstance;

            public static new DependentSizedArrayType __CreateInstance(global::System.IntPtr native)
            {
                return new DependentSizedArrayType((DependentSizedArrayType.Internal*) native);
            }

            public static DependentSizedArrayType __CreateInstance(DependentSizedArrayType.Internal native)
            {
                return new DependentSizedArrayType(native);
            }

            private static DependentSizedArrayType.Internal* __CopyValue(DependentSizedArrayType.Internal native)
            {
                var ret = (DependentSizedArrayType.Internal*) Marshal.AllocHGlobal(64);
                *ret = native;
                return ret;
            }

            private DependentSizedArrayType(DependentSizedArrayType.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected DependentSizedArrayType(DependentSizedArrayType.Internal* native, bool isInternalImpl = false)
                : base((clang.ArrayType.Internal*) native)
            {
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.ExtQualsTypeCommonBase __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.SourceRange getBracketsRange()
            {
                var __ret = Internal.getBracketsRange_0(__Instance);
                return clang.SourceRange.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLBracketLoc()
            {
                var __ret = Internal.getLBracketLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getRBracketLoc()
            {
                var __ret = Internal.getRBracketLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public bool isSugared()
            {
                var __ret = Internal.isSugared_0(__Instance);
                return __ret;
            }

            public clang.QualType desugar()
            {
                var __ret = Internal.desugar_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            public void Profile(llvm.FoldingSetNodeID ID)
            {
                var arg0 = ReferenceEquals(ID, null) ? global::System.IntPtr.Zero : ID.__Instance;
                Internal.Profile_0(__Instance, arg0);
            }

            public static bool classof(clang.Type T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>DependentSizedExtVectorType - This type represent an extended
        /// vector type where either the type or size is dependent. For example:</para>
        /// </summary>
        /// <remarks>
        /// <para>/// DependentSizedExtVectorType - This type represent an extended
        /// vector type</para>
        /// <para>/// where either the type or size is dependent. For
        /// example:</para>
        /// <para>/// @code</para>
        /// <para>/// template&lt;typename T, int Size&gt;</para>
        /// <para>/// class vector {</para>
        /// <para>///   typedef T __attribute__((ext_vector_type(Size)))
        /// type;</para>
        /// <para>/// }</para>
        /// <para>/// @endcode</para>
        /// </remarks>
        public unsafe partial class DependentSizedExtVectorType : clang.Type, llvm.FoldingSetImpl.Node, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 64)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr BaseType;

                [FieldOffset(8)]
                public clang.QualType.Internal CanonicalType;

                [FieldOffset(16)]
                internal clang.Type._.Internal __;

                [FieldOffset(0)]
                public global::System.IntPtr NextInFoldingSetBucket;

                [FieldOffset(32)]
                public global::System.IntPtr Context;

                [FieldOffset(40)]
                public global::System.IntPtr SizeExpr;

                [FieldOffset(48)]
                public clang.QualType.Internal ElementType;

                [FieldOffset(56)]
                public clang.SourceLocation.Internal loc;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang27DependentSizedExtVectorTypeC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang27DependentSizedExtVectorType14getElementTypeEv")]
                internal static extern clang.QualType.Internal getElementType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang27DependentSizedExtVectorType15getAttributeLocEv")]
                internal static extern clang.SourceLocation.Internal getAttributeLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang27DependentSizedExtVectorType9isSugaredEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isSugared_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang27DependentSizedExtVectorType7desugarEv")]
                internal static extern clang.QualType.Internal desugar_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang27DependentSizedExtVectorType7classofEPKNS_4TypeE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang27DependentSizedExtVectorType7ProfileERN4llvm16FoldingSetNodeIDE")]
                internal static extern void Profile_0(global::System.IntPtr instance, global::System.IntPtr ID);
            }

            private readonly bool __ownsNativeInstance;

            public static new DependentSizedExtVectorType __CreateInstance(global::System.IntPtr native)
            {
                return new DependentSizedExtVectorType((DependentSizedExtVectorType.Internal*) native);
            }

            public static DependentSizedExtVectorType __CreateInstance(DependentSizedExtVectorType.Internal native)
            {
                return new DependentSizedExtVectorType(native);
            }

            private static DependentSizedExtVectorType.Internal* __CopyValue(DependentSizedExtVectorType.Internal native)
            {
                var ret = (DependentSizedExtVectorType.Internal*) Marshal.AllocHGlobal(64);
                *ret = native;
                return ret;
            }

            private DependentSizedExtVectorType(DependentSizedExtVectorType.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected DependentSizedExtVectorType(DependentSizedExtVectorType.Internal* native, bool isInternalImpl = false)
                : base((clang.Type.Internal*) native)
            {
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.ExtQualsTypeCommonBase __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.QualType getElementType()
            {
                var __ret = Internal.getElementType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            public clang.SourceLocation getAttributeLoc()
            {
                var __ret = Internal.getAttributeLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public bool isSugared()
            {
                var __ret = Internal.isSugared_0(__Instance);
                return __ret;
            }

            public clang.QualType desugar()
            {
                var __ret = Internal.desugar_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            public void Profile(llvm.FoldingSetNodeID ID)
            {
                var arg0 = ReferenceEquals(ID, null) ? global::System.IntPtr.Zero : ID.__Instance;
                Internal.Profile_0(__Instance, arg0);
            }

            public static bool classof(clang.Type T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>VectorType - GCC generic vector type. This type is created using
        /// __attribute__((vector_size(n)), where &quot;n&quot; specifies the vector
        /// size in bytes; or from an Altivec __vector or vector declaration. Since the
        /// constructor takes the number of vector elements, the client is responsible
        /// for converting the size into the number of elements.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// VectorType - GCC generic vector type. This type is created
        /// using</para>
        /// <para>/// __attribute__((vector_size(n)), where &quot;n&quot; specifies
        /// the vector size in</para>
        /// <para>/// bytes; or from an Altivec __vector or vector
        /// declaration.</para>
        /// <para>/// Since the constructor takes the number of vector elements,
        /// the</para>
        /// <para>/// client is responsible for converting the size into the number
        /// of elements.</para>
        /// </remarks>
        public unsafe partial class VectorType : clang.Type, llvm.FoldingSetImpl.Node, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 40)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr BaseType;

                [FieldOffset(8)]
                public clang.QualType.Internal CanonicalType;

                [FieldOffset(16)]
                internal clang.Type._.Internal __;

                [FieldOffset(0)]
                public global::System.IntPtr NextInFoldingSetBucket;

                [FieldOffset(32)]
                public clang.QualType.Internal ElementType;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10VectorTypeC2ENS_8QualTypeEjS1_NS0_10VectorKindE")]
                internal static extern void ctor_0(global::System.IntPtr instance, clang.QualType.Internal vecType, uint nElements, clang.QualType.Internal canonType, clang.VectorType.VectorKind vecKind);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10VectorTypeC2ENS_4Type9TypeClassENS_8QualTypeEjS3_NS0_10VectorKindE")]
                internal static extern void ctor_1(global::System.IntPtr instance, clang.Type.TypeClass tc, clang.QualType.Internal vecType, uint nElements, clang.QualType.Internal canonType, clang.VectorType.VectorKind vecKind);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10VectorTypeC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10VectorType14getElementTypeEv")]
                internal static extern clang.QualType.Internal getElementType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10VectorType14getNumElementsEv")]
                internal static extern uint getNumElements_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10VectorType20isVectorSizeTooLargeEj")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isVectorSizeTooLarge_0(uint NumElements);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10VectorType9isSugaredEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isSugared_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10VectorType7desugarEv")]
                internal static extern clang.QualType.Internal desugar_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10VectorType13getVectorKindEv")]
                internal static extern clang.VectorType.VectorKind getVectorKind_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10VectorType7ProfileERN4llvm16FoldingSetNodeIDE")]
                internal static extern void Profile_0(global::System.IntPtr instance, global::System.IntPtr ID);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10VectorType7ProfileERN4llvm16FoldingSetNodeIDENS_8QualTypeEjNS_4Type9TypeClassENS0_10VectorKindE")]
                internal static extern void Profile_1(global::System.IntPtr ID, clang.QualType.Internal ElementType, uint NumElements, clang.Type.TypeClass TypeClass, clang.VectorType.VectorKind VecKind);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10VectorType7classofEPKNS_4TypeE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);
            }

            public enum VectorKind : uint
            {
                GenericVector = 0,
                AltiVecVector = 1,
                AltiVecPixel = 2,
                AltiVecBool = 3,
                NeonVector = 4,
                NeonPolyVector = 5
            }

            private readonly bool __ownsNativeInstance;

            public static new VectorType __CreateInstance(global::System.IntPtr native)
            {
                return new VectorType((VectorType.Internal*) native);
            }

            public static VectorType __CreateInstance(VectorType.Internal native)
            {
                return new VectorType(native);
            }

            private static VectorType.Internal* __CopyValue(VectorType.Internal native)
            {
                var ret = (VectorType.Internal*) Marshal.AllocHGlobal(40);
                *ret = native;
                return ret;
            }

            private VectorType(VectorType.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected VectorType(VectorType.Internal* native, bool isInternalImpl = false)
                : base((clang.Type.Internal*) native)
            {
            }

            protected VectorType(clang.QualType vecType, uint nElements, clang.QualType canonType, clang.VectorType.VectorKind vecKind)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(40);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(vecType, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (vecType.__Instance);
                var arg2 = ReferenceEquals(canonType, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (canonType.__Instance);
                var arg3 = vecKind;
                Internal.ctor_0(__Instance, arg0, nElements, arg2, arg3);
            }

            protected VectorType(clang.Type.TypeClass tc, clang.QualType vecType, uint nElements, clang.QualType canonType, clang.VectorType.VectorKind vecKind)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(40);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = tc;
                var arg1 = ReferenceEquals(vecType, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (vecType.__Instance);
                var arg3 = ReferenceEquals(canonType, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (canonType.__Instance);
                var arg4 = vecKind;
                Internal.ctor_1(__Instance, arg0, arg1, nElements, arg3, arg4);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.ExtQualsTypeCommonBase __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.QualType getElementType()
            {
                var __ret = Internal.getElementType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            public uint getNumElements()
            {
                var __ret = Internal.getNumElements_0(__Instance);
                return __ret;
            }

            public bool isSugared()
            {
                var __ret = Internal.isSugared_0(__Instance);
                return __ret;
            }

            public clang.QualType desugar()
            {
                var __ret = Internal.desugar_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            public clang.VectorType.VectorKind getVectorKind()
            {
                var __ret = Internal.getVectorKind_0(__Instance);
                return __ret;
            }

            public void Profile(llvm.FoldingSetNodeID ID)
            {
                var arg0 = ReferenceEquals(ID, null) ? global::System.IntPtr.Zero : ID.__Instance;
                Internal.Profile_0(__Instance, arg0);
            }

            public static bool isVectorSizeTooLarge(uint NumElements)
            {
                var __ret = Internal.isVectorSizeTooLarge_0(NumElements);
                return __ret;
            }

            public static void Profile(llvm.FoldingSetNodeID ID, clang.QualType ElementType, uint NumElements, clang.Type.TypeClass TypeClass, clang.VectorType.VectorKind VecKind)
            {
                var arg0 = ReferenceEquals(ID, null) ? global::System.IntPtr.Zero : ID.__Instance;
                var arg1 = ReferenceEquals(ElementType, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (ElementType.__Instance);
                var arg3 = TypeClass;
                var arg4 = VecKind;
                Internal.Profile_1(arg0, arg1, NumElements, arg3, arg4);
            }

            public static bool classof(clang.Type T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }

            protected clang.QualType ElementType
            {
                get
                {
                    return clang.QualType.__CreateInstance(((Internal*) __Instance)->ElementType);
                }

                set
                {
                    ((Internal*) __Instance)->ElementType = ReferenceEquals(value, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (value.__Instance);
                }
            }
        }

        /// <summary>
        /// <para>ExtVectorType - Extended vector type. This type is created using
        /// __attribute__((ext_vector_type(n)), where &quot;n&quot; is the number of
        /// elements. Unlike vector_size, ext_vector_type is only allowed on typedef's.
        /// This class enables syntactic extensions, like Vector Components for
        /// accessing points, colors, and textures (modeled after OpenGL Shading
        /// Language).</para>
        /// </summary>
        /// <remarks>
        /// <para>/// ExtVectorType - Extended vector type. This type is created
        /// using</para>
        /// <para>/// __attribute__((ext_vector_type(n)), where &quot;n&quot; is
        /// the number of elements.</para>
        /// <para>/// Unlike vector_size, ext_vector_type is only allowed on
        /// typedef's. This</para>
        /// <para>/// class enables syntactic extensions, like Vector Components
        /// for accessing</para>
        /// <para>/// points, colors, and textures (modeled after OpenGL Shading
        /// Language).</para>
        /// </remarks>
        public unsafe partial class ExtVectorType : clang.VectorType, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 40)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr BaseType;

                [FieldOffset(8)]
                public clang.QualType.Internal CanonicalType;

                [FieldOffset(16)]
                internal clang.Type._.Internal __;

                [FieldOffset(0)]
                public global::System.IntPtr NextInFoldingSetBucket;

                [FieldOffset(32)]
                public clang.QualType.Internal ElementType;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13ExtVectorTypeC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13ExtVectorType19getPointAccessorIdxEc")]
                internal static extern int getPointAccessorIdx_0(sbyte c);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13ExtVectorType21getNumericAccessorIdxEc")]
                internal static extern int getNumericAccessorIdx_0(sbyte c);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13ExtVectorType14getAccessorIdxEc")]
                internal static extern int getAccessorIdx_0(sbyte c);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13ExtVectorType27isAccessorWithinNumElementsEc")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isAccessorWithinNumElements_0(global::System.IntPtr instance, sbyte c);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13ExtVectorType9isSugaredEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isSugared_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13ExtVectorType7desugarEv")]
                internal static extern clang.QualType.Internal desugar_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13ExtVectorType7classofEPKNS_4TypeE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);
            }

            private readonly bool __ownsNativeInstance;

            public static new ExtVectorType __CreateInstance(global::System.IntPtr native)
            {
                return new ExtVectorType((ExtVectorType.Internal*) native);
            }

            public static ExtVectorType __CreateInstance(ExtVectorType.Internal native)
            {
                return new ExtVectorType(native);
            }

            private static ExtVectorType.Internal* __CopyValue(ExtVectorType.Internal native)
            {
                var ret = (ExtVectorType.Internal*) Marshal.AllocHGlobal(40);
                *ret = native;
                return ret;
            }

            private ExtVectorType(ExtVectorType.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected ExtVectorType(ExtVectorType.Internal* native, bool isInternalImpl = false)
                : base((clang.VectorType.Internal*) native)
            {
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.ExtQualsTypeCommonBase __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public bool isAccessorWithinNumElements(sbyte c)
            {
                var __ret = Internal.isAccessorWithinNumElements_0(__Instance, c);
                return __ret;
            }

            public bool isSugared()
            {
                var __ret = Internal.isSugared_0(__Instance);
                return __ret;
            }

            public clang.QualType desugar()
            {
                var __ret = Internal.desugar_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            public static int getPointAccessorIdx(sbyte c)
            {
                var __ret = Internal.getPointAccessorIdx_0(c);
                return __ret;
            }

            public static int getNumericAccessorIdx(sbyte c)
            {
                var __ret = Internal.getNumericAccessorIdx_0(c);
                return __ret;
            }

            public static int getAccessorIdx(sbyte c)
            {
                var __ret = Internal.getAccessorIdx_0(c);
                return __ret;
            }

            public static bool classof(clang.Type T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>FunctionType - C99 6.7.5.3 - Function Declarators. This is the
        /// common base class of FunctionNoProtoType and FunctionProtoType.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// FunctionType - C99 6.7.5.3 - Function Declarators.  This is
        /// the common base</para>
        /// <para>/// class of FunctionNoProtoType and FunctionProtoType.</para>
        /// <para>///</para>
        /// </remarks>
        public unsafe partial class FunctionType : clang.Type, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 32)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr BaseType;

                [FieldOffset(8)]
                public clang.QualType.Internal CanonicalType;

                [FieldOffset(16)]
                internal clang.Type._.Internal __;

                [FieldOffset(24)]
                public clang.QualType.Internal ResultType;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12FunctionTypeC2ENS_4Type9TypeClassENS_8QualTypeES3_bbbbNS0_7ExtInfoE")]
                internal static extern void ctor_0(global::System.IntPtr instance, clang.Type.TypeClass tc, clang.QualType.Internal res, clang.QualType.Internal Canonical, bool Dependent, bool InstantiationDependent, bool VariablyModified, bool ContainsUnexpandedParameterPack, clang.FunctionType.ExtInfo.Internal Info);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12FunctionTypeC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12FunctionType12getTypeQualsEv")]
                internal static extern uint getTypeQuals_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12FunctionType13getReturnTypeEv")]
                internal static extern clang.QualType.Internal getReturnType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12FunctionType13getHasRegParmEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool getHasRegParm_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12FunctionType14getRegParmTypeEv")]
                internal static extern uint getRegParmType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12FunctionType15getNoReturnAttrEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool getNoReturnAttr_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12FunctionType11getCallConvEv")]
                internal static extern clang.CallingConv getCallConv_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12FunctionType10getExtInfoEv")]
                internal static extern clang.FunctionType.ExtInfo.Internal getExtInfo_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12FunctionType7isConstEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isConst_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12FunctionType10isVolatileEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isVolatile_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12FunctionType10isRestrictEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isRestrict_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12FunctionType17getCallResultTypeERNS_10ASTContextE")]
                internal static extern clang.QualType.Internal getCallResultType_0(global::System.IntPtr instance, global::System.IntPtr Context);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12FunctionType18getNameForCallConvENS_11CallingConvE")]
                internal static extern llvm.StringRef.Internal getNameForCallConv_0(clang.CallingConv CC);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12FunctionType7classofEPKNS_4TypeE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);
            }

            /// <summary>
            /// <para>ExtInfo - A class which abstracts out some details necessary for
            /// making a call.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// ExtInfo - A class which abstracts out some details necessary
            /// for</para>
            /// <para>  /// making a call.</para>
            /// <para>  ///</para>
            /// <para>  /// It is not actually used directly for storing this
            /// information in</para>
            /// <para>  /// a FunctionType, although FunctionType does currently use
            /// the</para>
            /// <para>  /// same bit-pattern.</para>
            /// <para>  ///</para>
            /// </remarks>
            public unsafe partial class ExtInfo : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 2)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public ushort Bits;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang12FunctionType7ExtInfoC2EbbjNS_11CallingConvEb")]
                    internal static extern void ctor_1(global::System.IntPtr instance, bool noReturn, bool hasRegParm, uint regParm, clang.CallingConv cc, bool producesResult);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang12FunctionType7ExtInfoC2Ev")]
                    internal static extern void ctor_2(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang12FunctionType7ExtInfoC2ENS_11CallingConvE")]
                    internal static extern void ctor_3(global::System.IntPtr instance, clang.CallingConv CC);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang12FunctionType7ExtInfoC2ERKS1_")]
                    internal static extern void cctor_4(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang12FunctionType7ExtInfo11getNoReturnEv")]
                    [return: MarshalAsAttribute(UnmanagedType.I1)]
                    internal static extern bool getNoReturn_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang12FunctionType7ExtInfo17getProducesResultEv")]
                    [return: MarshalAsAttribute(UnmanagedType.I1)]
                    internal static extern bool getProducesResult_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang12FunctionType7ExtInfo13getHasRegParmEv")]
                    [return: MarshalAsAttribute(UnmanagedType.I1)]
                    internal static extern bool getHasRegParm_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang12FunctionType7ExtInfo10getRegParmEv")]
                    internal static extern uint getRegParm_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang12FunctionType7ExtInfo5getCCEv")]
                    internal static extern clang.CallingConv getCC_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang12FunctionType7ExtInfoeqES1_")]
                    [return: MarshalAsAttribute(UnmanagedType.I1)]
                    internal static extern bool OperatorEqualEqual_0(global::System.IntPtr instance, clang.FunctionType.ExtInfo.Internal Other);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang12FunctionType7ExtInfoneES1_")]
                    [return: MarshalAsAttribute(UnmanagedType.I1)]
                    internal static extern bool OperatorExclaimEqual_0(global::System.IntPtr instance, clang.FunctionType.ExtInfo.Internal Other);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang12FunctionType7ExtInfo12withNoReturnEb")]
                    internal static extern clang.FunctionType.ExtInfo.Internal withNoReturn_0(global::System.IntPtr instance, bool noReturn);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang12FunctionType7ExtInfo18withProducesResultEb")]
                    internal static extern clang.FunctionType.ExtInfo.Internal withProducesResult_0(global::System.IntPtr instance, bool producesResult);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang12FunctionType7ExtInfo11withRegParmEj")]
                    internal static extern clang.FunctionType.ExtInfo.Internal withRegParm_0(global::System.IntPtr instance, uint RegParm);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang12FunctionType7ExtInfo15withCallingConvENS_11CallingConvE")]
                    internal static extern clang.FunctionType.ExtInfo.Internal withCallingConv_0(global::System.IntPtr instance, clang.CallingConv cc);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang12FunctionType7ExtInfo7ProfileERN4llvm16FoldingSetNodeIDE")]
                    internal static extern void Profile_0(global::System.IntPtr instance, global::System.IntPtr ID);
                }

                public global::System.IntPtr __Instance { get; protected set; }
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ExtInfo> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ExtInfo>();

                private readonly bool __ownsNativeInstance;

                public static ExtInfo __CreateInstance(global::System.IntPtr native)
                {
                    return new ExtInfo((ExtInfo.Internal*) native);
                }

                public static ExtInfo __CreateInstance(ExtInfo.Internal native)
                {
                    return new ExtInfo(native);
                }

                private static ExtInfo.Internal* __CopyValue(ExtInfo.Internal native)
                {
                    var ret = (ExtInfo.Internal*) Marshal.AllocHGlobal(2);
                    *ret = native;
                    return ret;
                }

                private ExtInfo(ExtInfo.Internal native)
                    : this(__CopyValue(native))
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected ExtInfo(ExtInfo.Internal* native, bool isInternalImpl = false)
                {
                    __Instance = new global::System.IntPtr(native);
                }

                public ExtInfo(bool noReturn, bool hasRegParm, uint regParm, clang.CallingConv cc, bool producesResult)
                {
                    __Instance = Marshal.AllocHGlobal(2);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    var arg3 = cc;
                    Internal.ctor_1(__Instance, noReturn, hasRegParm, regParm, arg3, producesResult);
                }

                public ExtInfo()
                {
                    __Instance = Marshal.AllocHGlobal(2);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_2(__Instance);
                }

                public ExtInfo(clang.CallingConv CC)
                {
                    __Instance = Marshal.AllocHGlobal(2);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    var arg0 = CC;
                    Internal.ctor_3(__Instance, arg0);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    DestroyNativeInstance(false);
                }

                public virtual void DestroyNativeInstance()
                {
                    DestroyNativeInstance(true);
                }

                private void DestroyNativeInstance(bool force)
                {
                    clang.FunctionType.ExtInfo __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public bool getNoReturn()
                {
                    var __ret = Internal.getNoReturn_0(__Instance);
                    return __ret;
                }

                public bool getProducesResult()
                {
                    var __ret = Internal.getProducesResult_0(__Instance);
                    return __ret;
                }

                public bool getHasRegParm()
                {
                    var __ret = Internal.getHasRegParm_0(__Instance);
                    return __ret;
                }

                public uint getRegParm()
                {
                    var __ret = Internal.getRegParm_0(__Instance);
                    return __ret;
                }

                public clang.CallingConv getCC()
                {
                    var __ret = Internal.getCC_0(__Instance);
                    return __ret;
                }

                public static bool operator ==(clang.FunctionType.ExtInfo __op, clang.FunctionType.ExtInfo Other)
                {
                    bool __opNull = ReferenceEquals(__op, null);
                    bool OtherNull = ReferenceEquals(Other, null);
                    if (__opNull || OtherNull)
                        return __opNull && OtherNull;
                    var arg0 = __op.__Instance;
                    var arg1 = ReferenceEquals(Other, null) ? new clang.FunctionType.ExtInfo.Internal() : *(clang.FunctionType.ExtInfo.Internal*) (Other.__Instance);
                    var __ret = Internal.OperatorEqualEqual_0(arg0, arg1);
                    return __ret;
                }

                public override bool Equals(object obj)
                {
                    return this == obj as ExtInfo;
                }

                public static bool operator !=(clang.FunctionType.ExtInfo __op, clang.FunctionType.ExtInfo Other)
                {
                    var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
                    var arg1 = ReferenceEquals(Other, null) ? new clang.FunctionType.ExtInfo.Internal() : *(clang.FunctionType.ExtInfo.Internal*) (Other.__Instance);
                    var __ret = Internal.OperatorExclaimEqual_0(arg0, arg1);
                    return __ret;
                }

                public clang.FunctionType.ExtInfo withNoReturn(bool noReturn)
                {
                    var __ret = Internal.withNoReturn_0(__Instance, noReturn);
                    return clang.FunctionType.ExtInfo.__CreateInstance(__ret);
                }

                public clang.FunctionType.ExtInfo withProducesResult(bool producesResult)
                {
                    var __ret = Internal.withProducesResult_0(__Instance, producesResult);
                    return clang.FunctionType.ExtInfo.__CreateInstance(__ret);
                }

                public clang.FunctionType.ExtInfo withRegParm(uint RegParm)
                {
                    var __ret = Internal.withRegParm_0(__Instance, RegParm);
                    return clang.FunctionType.ExtInfo.__CreateInstance(__ret);
                }

                public clang.FunctionType.ExtInfo withCallingConv(clang.CallingConv cc)
                {
                    var arg0 = cc;
                    var __ret = Internal.withCallingConv_0(__Instance, arg0);
                    return clang.FunctionType.ExtInfo.__CreateInstance(__ret);
                }

                public void Profile(llvm.FoldingSetNodeID ID)
                {
                    var arg0 = ReferenceEquals(ID, null) ? global::System.IntPtr.Zero : ID.__Instance;
                    Internal.Profile_0(__Instance, arg0);
                }
            }

            private readonly bool __ownsNativeInstance;

            public static new FunctionType __CreateInstance(global::System.IntPtr native)
            {
                return new FunctionType((FunctionType.Internal*) native);
            }

            public static FunctionType __CreateInstance(FunctionType.Internal native)
            {
                return new FunctionType(native);
            }

            private static FunctionType.Internal* __CopyValue(FunctionType.Internal native)
            {
                var ret = (FunctionType.Internal*) Marshal.AllocHGlobal(32);
                *ret = native;
                return ret;
            }

            private FunctionType(FunctionType.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected FunctionType(FunctionType.Internal* native, bool isInternalImpl = false)
                : base((clang.Type.Internal*) native)
            {
            }

            protected FunctionType(clang.Type.TypeClass tc, clang.QualType res, clang.QualType Canonical, bool Dependent, bool InstantiationDependent, bool VariablyModified, bool ContainsUnexpandedParameterPack, clang.FunctionType.ExtInfo Info)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(32);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = tc;
                var arg1 = ReferenceEquals(res, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (res.__Instance);
                var arg2 = ReferenceEquals(Canonical, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (Canonical.__Instance);
                var arg7 = ReferenceEquals(Info, null) ? new clang.FunctionType.ExtInfo.Internal() : *(clang.FunctionType.ExtInfo.Internal*) (Info.__Instance);
                Internal.ctor_0(__Instance, arg0, arg1, arg2, Dependent, InstantiationDependent, VariablyModified, ContainsUnexpandedParameterPack, arg7);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.ExtQualsTypeCommonBase __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            protected uint getTypeQuals()
            {
                var __ret = Internal.getTypeQuals_0(__Instance);
                return __ret;
            }

            public clang.QualType getReturnType()
            {
                var __ret = Internal.getReturnType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            public bool getHasRegParm()
            {
                var __ret = Internal.getHasRegParm_0(__Instance);
                return __ret;
            }

            public uint getRegParmType()
            {
                var __ret = Internal.getRegParmType_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determine whether this function type includes the GNU noreturn
            /// attribute. The C++11 [[noreturn]] attribute does not affect the function
            /// type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine whether this function type includes the GNU
            /// noreturn</para>
            /// <para>  /// attribute. The C++11 [[noreturn]] attribute does not affect
            /// the function</para>
            /// <para>  /// type.</para>
            /// </remarks>
            public bool getNoReturnAttr()
            {
                var __ret = Internal.getNoReturnAttr_0(__Instance);
                return __ret;
            }

            public clang.CallingConv getCallConv()
            {
                var __ret = Internal.getCallConv_0(__Instance);
                return __ret;
            }

            public clang.FunctionType.ExtInfo getExtInfo()
            {
                var __ret = Internal.getExtInfo_0(__Instance);
                return clang.FunctionType.ExtInfo.__CreateInstance(__ret);
            }

            public bool isConst()
            {
                var __ret = Internal.isConst_0(__Instance);
                return __ret;
            }

            public bool isVolatile()
            {
                var __ret = Internal.isVolatile_0(__Instance);
                return __ret;
            }

            public bool isRestrict()
            {
                var __ret = Internal.isRestrict_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determine the type of an expression that calls a function of this
            /// type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine the type of an expression that calls a
            /// function of</para>
            /// <para>  /// this type.</para>
            /// </remarks>
            public clang.QualType getCallResultType(clang.ASTContext Context)
            {
                var arg0 = ReferenceEquals(Context, null) ? global::System.IntPtr.Zero : Context.__Instance;
                var __ret = Internal.getCallResultType_0(__Instance, arg0);
                return clang.QualType.__CreateInstance(__ret);
            }

            public static llvm.StringRef getNameForCallConv(clang.CallingConv CC)
            {
                var arg0 = CC;
                var __ret = Internal.getNameForCallConv_0(arg0);
                return llvm.StringRef.__CreateInstance(__ret);
            }

            public static bool classof(clang.Type T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>FunctionNoProtoType - Represents a K&amp;R-style 'int foo()'
        /// function, which has no information available about its arguments.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// FunctionNoProtoType - Represents a K&amp;R-style 'int foo()'
        /// function, which has</para>
        /// <para>/// no information available about its arguments.</para>
        /// </remarks>
        public unsafe partial class FunctionNoProtoType : clang.FunctionType, llvm.FoldingSetImpl.Node, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 40)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr BaseType;

                [FieldOffset(8)]
                public clang.QualType.Internal CanonicalType;

                [FieldOffset(16)]
                internal clang.Type._.Internal __;

                [FieldOffset(24)]
                public clang.QualType.Internal ResultType;

                [FieldOffset(0)]
                public global::System.IntPtr NextInFoldingSetBucket;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang19FunctionNoProtoTypeC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang19FunctionNoProtoType9isSugaredEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isSugared_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang19FunctionNoProtoType7desugarEv")]
                internal static extern clang.QualType.Internal desugar_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang19FunctionNoProtoType7ProfileERN4llvm16FoldingSetNodeIDE")]
                internal static extern void Profile_0(global::System.IntPtr instance, global::System.IntPtr ID);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang19FunctionNoProtoType7ProfileERN4llvm16FoldingSetNodeIDENS_8QualTypeENS_12FunctionType7ExtInfoE")]
                internal static extern void Profile_1(global::System.IntPtr ID, clang.QualType.Internal ResultType, clang.FunctionType.ExtInfo.Internal Info);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang19FunctionNoProtoType7classofEPKNS_4TypeE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);
            }

            private readonly bool __ownsNativeInstance;

            public static new FunctionNoProtoType __CreateInstance(global::System.IntPtr native)
            {
                return new FunctionNoProtoType((FunctionNoProtoType.Internal*) native);
            }

            public static FunctionNoProtoType __CreateInstance(FunctionNoProtoType.Internal native)
            {
                return new FunctionNoProtoType(native);
            }

            private static FunctionNoProtoType.Internal* __CopyValue(FunctionNoProtoType.Internal native)
            {
                var ret = (FunctionNoProtoType.Internal*) Marshal.AllocHGlobal(40);
                *ret = native;
                return ret;
            }

            private FunctionNoProtoType(FunctionNoProtoType.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected FunctionNoProtoType(FunctionNoProtoType.Internal* native, bool isInternalImpl = false)
                : base((clang.FunctionType.Internal*) native)
            {
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.ExtQualsTypeCommonBase __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public bool isSugared()
            {
                var __ret = Internal.isSugared_0(__Instance);
                return __ret;
            }

            public clang.QualType desugar()
            {
                var __ret = Internal.desugar_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            public void Profile(llvm.FoldingSetNodeID ID)
            {
                var arg0 = ReferenceEquals(ID, null) ? global::System.IntPtr.Zero : ID.__Instance;
                Internal.Profile_0(__Instance, arg0);
            }

            public static void Profile(llvm.FoldingSetNodeID ID, clang.QualType ResultType, clang.FunctionType.ExtInfo Info)
            {
                var arg0 = ReferenceEquals(ID, null) ? global::System.IntPtr.Zero : ID.__Instance;
                var arg1 = ReferenceEquals(ResultType, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (ResultType.__Instance);
                var arg2 = ReferenceEquals(Info, null) ? new clang.FunctionType.ExtInfo.Internal() : *(clang.FunctionType.ExtInfo.Internal*) (Info.__Instance);
                Internal.Profile_1(arg0, arg1, arg2);
            }

            public static bool classof(clang.Type T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>FunctionProtoType - Represents a prototype with parameter type
        /// info, e.g. 'int foo(int)' or 'int foo(void)'. 'void' is represented as
        /// having no parameters, not as having a single void parameter. Such a type
        /// can have an exception specification, but this specification is not part of
        /// the canonical type.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// FunctionProtoType - Represents a prototype with parameter
        /// type info, e.g.</para>
        /// <para>/// 'int foo(int)' or 'int foo(void)'.  'void' is represented as
        /// having no</para>
        /// <para>/// parameters, not as having a single void parameter. Such a
        /// type can have an</para>
        /// <para>/// exception specification, but this specification is not part
        /// of the canonical</para>
        /// <para>/// type.</para>
        /// </remarks>
        public unsafe partial class FunctionProtoType : clang.FunctionType, llvm.FoldingSetImpl.Node, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 48)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr BaseType;

                [FieldOffset(8)]
                public clang.QualType.Internal CanonicalType;

                [FieldOffset(16)]
                internal clang.Type._.Internal __;

                [FieldOffset(24)]
                public clang.QualType.Internal ResultType;

                [FieldOffset(0)]
                public global::System.IntPtr NextInFoldingSetBucket;

                [FieldOffset(40)]
                public uint NumParams;

                [FieldOffset(41)]
                public uint NumExceptions;

                [FieldOffset(43)]
                public uint ExceptionSpecType;

                [FieldOffset(43)]
                public uint HasAnyConsumedParams;

                [FieldOffset(43)]
                public uint Variadic;

                [FieldOffset(43)]
                public uint HasTrailingReturn;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17FunctionProtoTypeC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17FunctionProtoType12getNumParamsEv")]
                internal static extern uint getNumParams_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17FunctionProtoType12getParamTypeEj")]
                internal static extern clang.QualType.Internal getParamType_0(global::System.IntPtr instance, uint i);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17FunctionProtoType15getExtProtoInfoEv")]
                internal static extern void getExtProtoInfo_0(global::System.IntPtr @return, global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17FunctionProtoType20getExceptionSpecTypeEv")]
                internal static extern clang.ExceptionSpecificationType getExceptionSpecType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17FunctionProtoType16hasExceptionSpecEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasExceptionSpec_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17FunctionProtoType23hasDynamicExceptionSpecEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasDynamicExceptionSpec_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17FunctionProtoType24hasNoexceptExceptionSpecEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasNoexceptExceptionSpec_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17FunctionProtoType25hasDependentExceptionSpecEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasDependentExceptionSpec_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17FunctionProtoType15getNoexceptSpecERKNS_10ASTContextE")]
                internal static extern clang.FunctionProtoType.NoexceptResult getNoexceptSpec_0(global::System.IntPtr instance, global::System.IntPtr Ctx);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17FunctionProtoType16getNumExceptionsEv")]
                internal static extern uint getNumExceptions_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17FunctionProtoType16getExceptionTypeEj")]
                internal static extern clang.QualType.Internal getExceptionType_0(global::System.IntPtr instance, uint i);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17FunctionProtoType20getExceptionSpecDeclEv")]
                internal static extern global::System.IntPtr getExceptionSpecDecl_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17FunctionProtoType24getExceptionSpecTemplateEv")]
                internal static extern global::System.IntPtr getExceptionSpecTemplate_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17FunctionProtoType9isNothrowERKNS_10ASTContextEb")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isNothrow_0(global::System.IntPtr instance, global::System.IntPtr Ctx, bool ResultIfDependent);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17FunctionProtoType10isVariadicEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isVariadic_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17FunctionProtoType18isTemplateVariadicEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isTemplateVariadic_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17FunctionProtoType17hasTrailingReturnEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasTrailingReturn_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17FunctionProtoType12getTypeQualsEv")]
                internal static extern uint getTypeQuals_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17FunctionProtoType15getRefQualifierEv")]
                internal static extern clang.RefQualifierKind getRefQualifier_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17FunctionProtoType16param_type_beginEv")]
                internal static extern global::System.IntPtr param_type_begin_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17FunctionProtoType14param_type_endEv")]
                internal static extern global::System.IntPtr param_type_end_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17FunctionProtoType15exception_beginEv")]
                internal static extern global::System.IntPtr exception_begin_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17FunctionProtoType13exception_endEv")]
                internal static extern global::System.IntPtr exception_end_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17FunctionProtoType20hasAnyConsumedParamsEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasAnyConsumedParams_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17FunctionProtoType15isParamConsumedEj")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isParamConsumed_0(global::System.IntPtr instance, uint I);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17FunctionProtoType9isSugaredEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isSugared_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17FunctionProtoType7desugarEv")]
                internal static extern clang.QualType.Internal desugar_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17FunctionProtoType27printExceptionSpecificationERN4llvm11raw_ostreamERKNS_14PrintingPolicyE")]
                internal static extern void printExceptionSpecification_0(global::System.IntPtr instance, global::System.IntPtr OS, global::System.IntPtr Policy);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17FunctionProtoType7classofEPKNS_4TypeE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17FunctionProtoType7ProfileERN4llvm16FoldingSetNodeIDERKNS_10ASTContextE")]
                internal static extern void Profile_0(global::System.IntPtr instance, global::System.IntPtr ID, global::System.IntPtr Ctx);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17FunctionProtoType7ProfileERN4llvm16FoldingSetNodeIDENS_8QualTypeEPKS4_jRKNS0_12ExtProtoInfoERKNS_10ASTContextE")]
                internal static extern void Profile_1(global::System.IntPtr ID, clang.QualType.Internal Result, global::System.IntPtr ArgTys, uint NumArgs, global::System.IntPtr EPI, global::System.IntPtr Context);
            }

            /// <summary>
            /// <para>Result type of getNoexceptSpec().</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Result type of getNoexceptSpec().</para>
            /// </remarks>
            public enum NoexceptResult : uint
            {
                /// <summary>There is no noexcept specifier.</summary>
                NR_NoNoexcept = 0,
                /// <summary>The noexcept specifier has a bad expression.</summary>
                NR_BadNoexcept = 1,
                /// <summary>The noexcept specifier is dependent.</summary>
                NR_Dependent = 2,
                /// <summary>The noexcept specifier evaluates to false.</summary>
                NR_Throw = 3,
                /// <summary>The noexcept specifier evaluates to true.</summary>
                NR_Nothrow = 4
            }

            public class param_type_iterator { }

            public class exception_iterator { }

            public unsafe partial class ExceptionSpecInfo : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 48)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public clang.ExceptionSpecificationType Type;

                    [FieldOffset(8)]
                    internal llvm.ArrayRef.Internal Exceptions;

                    [FieldOffset(24)]
                    public global::System.IntPtr NoexceptExpr;

                    [FieldOffset(32)]
                    public global::System.IntPtr SourceDecl;

                    [FieldOffset(40)]
                    public global::System.IntPtr SourceTemplate;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang17FunctionProtoType17ExceptionSpecInfoC2Ev")]
                    internal static extern void ctor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang17FunctionProtoType17ExceptionSpecInfoC2ENS_26ExceptionSpecificationTypeE")]
                    internal static extern void ctor_1(global::System.IntPtr instance, clang.ExceptionSpecificationType EST);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang17FunctionProtoType17ExceptionSpecInfoC2ERKS1_")]
                    internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ExceptionSpecInfo> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ExceptionSpecInfo>();

                private readonly bool __ownsNativeInstance;

                public static ExceptionSpecInfo __CreateInstance(global::System.IntPtr native)
                {
                    return new ExceptionSpecInfo((ExceptionSpecInfo.Internal*) native);
                }

                public static ExceptionSpecInfo __CreateInstance(ExceptionSpecInfo.Internal native)
                {
                    return new ExceptionSpecInfo(native);
                }

                private static ExceptionSpecInfo.Internal* __CopyValue(ExceptionSpecInfo.Internal native)
                {
                    var ret = (ExceptionSpecInfo.Internal*) Marshal.AllocHGlobal(48);
                    *ret = native;
                    return ret;
                }

                private ExceptionSpecInfo(ExceptionSpecInfo.Internal native)
                    : this(__CopyValue(native))
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected ExceptionSpecInfo(ExceptionSpecInfo.Internal* native, bool isInternalImpl = false)
                {
                    __Instance = new global::System.IntPtr(native);
                }

                public ExceptionSpecInfo()
                {
                    __Instance = Marshal.AllocHGlobal(48);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_0(__Instance);
                }

                public ExceptionSpecInfo(clang.ExceptionSpecificationType EST)
                {
                    __Instance = Marshal.AllocHGlobal(48);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    var arg0 = EST;
                    Internal.ctor_1(__Instance, arg0);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    DestroyNativeInstance(false);
                }

                public virtual void DestroyNativeInstance()
                {
                    DestroyNativeInstance(true);
                }

                private void DestroyNativeInstance(bool force)
                {
                    clang.FunctionProtoType.ExceptionSpecInfo __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public clang.ExceptionSpecificationType Type
                {
                    get
                    {
                        return ((Internal*) __Instance)->Type;
                    }

                    set
                    {
                        ((Internal*) __Instance)->Type = value;
                    }
                }

                public clang.FunctionDecl SourceDecl
                {
                    get
                    {
                        clang.FunctionDecl __result0;
                        if (((Internal*) __Instance)->SourceDecl == IntPtr.Zero) __result0 = null;
                        else if (clang.FunctionDecl.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->SourceDecl))
                            __result0 = (clang.FunctionDecl) clang.FunctionDecl.NativeToManagedMap[((Internal*) __Instance)->SourceDecl];
                        else clang.FunctionDecl.NativeToManagedMap[((Internal*) __Instance)->SourceDecl] = __result0 = (clang.FunctionDecl) clang.FunctionDecl.__CreateInstance(((Internal*) __Instance)->SourceDecl);
                        return __result0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->SourceDecl = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public clang.FunctionDecl SourceTemplate
                {
                    get
                    {
                        clang.FunctionDecl __result0;
                        if (((Internal*) __Instance)->SourceTemplate == IntPtr.Zero) __result0 = null;
                        else if (clang.FunctionDecl.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->SourceTemplate))
                            __result0 = (clang.FunctionDecl) clang.FunctionDecl.NativeToManagedMap[((Internal*) __Instance)->SourceTemplate];
                        else clang.FunctionDecl.NativeToManagedMap[((Internal*) __Instance)->SourceTemplate] = __result0 = (clang.FunctionDecl) clang.FunctionDecl.__CreateInstance(((Internal*) __Instance)->SourceTemplate);
                        return __result0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->SourceTemplate = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }
            }

            /// <summary>
            /// <para>ExtProtoInfo - Extra information about a function
            /// prototype.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// ExtProtoInfo - Extra information about a function
            /// prototype.</para>
            /// </remarks>
            public unsafe partial class ExtProtoInfo : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 64)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public clang.FunctionType.ExtInfo.Internal ExtInfo;

                    [FieldOffset(2)]
                    public bool Variadic;

                    [FieldOffset(2)]
                    public bool HasTrailingReturn;

                    [FieldOffset(3)]
                    public byte TypeQuals;

                    [FieldOffset(4)]
                    public clang.RefQualifierKind RefQualifier;

                    [FieldOffset(8)]
                    public clang.FunctionProtoType.ExceptionSpecInfo.Internal ExceptionSpec;

                    [FieldOffset(56)]
                    public bool* ConsumedParameters;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang17FunctionProtoType12ExtProtoInfoC2Ev")]
                    internal static extern void ctor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang17FunctionProtoType12ExtProtoInfoC2ENS_11CallingConvE")]
                    internal static extern void ctor_1(global::System.IntPtr instance, clang.CallingConv CC);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang17FunctionProtoType12ExtProtoInfoC2ERKS1_")]
                    internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang17FunctionProtoType12ExtProtoInfo17withExceptionSpecERKNS0_17ExceptionSpecInfoE")]
                    internal static extern void withExceptionSpec_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr O);
                }

                public global::System.IntPtr __Instance { get; protected set; }
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ExtProtoInfo> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ExtProtoInfo>();

                private readonly bool __ownsNativeInstance;

                public static ExtProtoInfo __CreateInstance(global::System.IntPtr native)
                {
                    return new ExtProtoInfo((ExtProtoInfo.Internal*) native);
                }

                public static ExtProtoInfo __CreateInstance(ExtProtoInfo.Internal native)
                {
                    return new ExtProtoInfo(native);
                }

                private static ExtProtoInfo.Internal* __CopyValue(ExtProtoInfo.Internal native)
                {
                    var ret = (ExtProtoInfo.Internal*) Marshal.AllocHGlobal(64);
                    *ret = native;
                    return ret;
                }

                private ExtProtoInfo(ExtProtoInfo.Internal native)
                    : this(__CopyValue(native))
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected ExtProtoInfo(ExtProtoInfo.Internal* native, bool isInternalImpl = false)
                {
                    __Instance = new global::System.IntPtr(native);
                }

                public ExtProtoInfo()
                {
                    __Instance = Marshal.AllocHGlobal(64);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_0(__Instance);
                }

                public ExtProtoInfo(clang.CallingConv CC)
                {
                    __Instance = Marshal.AllocHGlobal(64);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    var arg0 = CC;
                    Internal.ctor_1(__Instance, arg0);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    DestroyNativeInstance(false);
                }

                public virtual void DestroyNativeInstance()
                {
                    DestroyNativeInstance(true);
                }

                private void DestroyNativeInstance(bool force)
                {
                    clang.FunctionProtoType.ExtProtoInfo __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public clang.FunctionProtoType.ExtProtoInfo withExceptionSpec(clang.FunctionProtoType.ExceptionSpecInfo O)
                {
                    var arg0 = ReferenceEquals(O, null) ? global::System.IntPtr.Zero : O.__Instance;
                    var __ret = new clang.FunctionProtoType.ExtProtoInfo.Internal();
                    Internal.withExceptionSpec_0(new IntPtr(&__ret), __Instance, arg0);
                    return clang.FunctionProtoType.ExtProtoInfo.__CreateInstance(__ret);
                }

                public clang.FunctionType.ExtInfo ExtInfo
                {
                    get
                    {
                        return clang.FunctionType.ExtInfo.__CreateInstance(((Internal*) __Instance)->ExtInfo);
                    }

                    set
                    {
                        ((Internal*) __Instance)->ExtInfo = ReferenceEquals(value, null) ? new clang.FunctionType.ExtInfo.Internal() : *(clang.FunctionType.ExtInfo.Internal*) (value.__Instance);
                    }
                }

                public bool Variadic
                {
                    get
                    {
                        return ((Internal*) __Instance)->Variadic;
                    }

                    set
                    {
                        ((Internal*) __Instance)->Variadic = value;
                    }
                }

                public bool HasTrailingReturn
                {
                    get
                    {
                        return ((Internal*) __Instance)->HasTrailingReturn;
                    }

                    set
                    {
                        ((Internal*) __Instance)->HasTrailingReturn = value;
                    }
                }

                public byte TypeQuals
                {
                    get
                    {
                        return ((Internal*) __Instance)->TypeQuals;
                    }

                    set
                    {
                        ((Internal*) __Instance)->TypeQuals = value;
                    }
                }

                public clang.RefQualifierKind RefQualifier
                {
                    get
                    {
                        return ((Internal*) __Instance)->RefQualifier;
                    }

                    set
                    {
                        ((Internal*) __Instance)->RefQualifier = value;
                    }
                }

                public clang.FunctionProtoType.ExceptionSpecInfo ExceptionSpec
                {
                    get
                    {
                        return clang.FunctionProtoType.ExceptionSpecInfo.__CreateInstance(((Internal*) __Instance)->ExceptionSpec);
                    }

                    set
                    {
                        ((Internal*) __Instance)->ExceptionSpec = ReferenceEquals(value, null) ? new clang.FunctionProtoType.ExceptionSpecInfo.Internal() : *(clang.FunctionProtoType.ExceptionSpecInfo.Internal*) (value.__Instance);
                    }
                }

                public bool* ConsumedParameters
                {
                    get
                    {
                        return ((Internal*) __Instance)->ConsumedParameters;
                    }

                    set
                    {
                        ((Internal*) __Instance)->ConsumedParameters = value;
                    }
                }
            }

            private readonly bool __ownsNativeInstance;

            public static new FunctionProtoType __CreateInstance(global::System.IntPtr native)
            {
                return new FunctionProtoType((FunctionProtoType.Internal*) native);
            }

            public static FunctionProtoType __CreateInstance(FunctionProtoType.Internal native)
            {
                return new FunctionProtoType(native);
            }

            private static FunctionProtoType.Internal* __CopyValue(FunctionProtoType.Internal native)
            {
                var ret = (FunctionProtoType.Internal*) Marshal.AllocHGlobal(48);
                *ret = native;
                return ret;
            }

            private FunctionProtoType(FunctionProtoType.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected FunctionProtoType(FunctionProtoType.Internal* native, bool isInternalImpl = false)
                : base((clang.FunctionType.Internal*) native)
            {
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.ExtQualsTypeCommonBase __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public uint getNumParams()
            {
                var __ret = Internal.getNumParams_0(__Instance);
                return __ret;
            }

            public clang.QualType getParamType(uint i)
            {
                var __ret = Internal.getParamType_0(__Instance, i);
                return clang.QualType.__CreateInstance(__ret);
            }

            public clang.FunctionProtoType.ExtProtoInfo getExtProtoInfo()
            {
                var __ret = new clang.FunctionProtoType.ExtProtoInfo.Internal();
                Internal.getExtProtoInfo_0(new IntPtr(&__ret), __Instance);
                return clang.FunctionProtoType.ExtProtoInfo.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Get the kind of exception specification on this function.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Get the kind of exception specification on this
            /// function.</para>
            /// </remarks>
            public clang.ExceptionSpecificationType getExceptionSpecType()
            {
                var __ret = Internal.getExceptionSpecType_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Return whether this function has any kind of exception
            /// spec.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return whether this function has any kind of exception
            /// spec.</para>
            /// </remarks>
            public bool hasExceptionSpec()
            {
                var __ret = Internal.hasExceptionSpec_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Return whether this function has a dynamic (throw) exception
            /// spec.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return whether this function has a dynamic (throw)
            /// exception spec.</para>
            /// </remarks>
            public bool hasDynamicExceptionSpec()
            {
                var __ret = Internal.hasDynamicExceptionSpec_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Return whether this function has a noexcept exception
            /// spec.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return whether this function has a noexcept exception
            /// spec.</para>
            /// </remarks>
            public bool hasNoexceptExceptionSpec()
            {
                var __ret = Internal.hasNoexceptExceptionSpec_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Return whether this function has a dependent exception
            /// spec.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return whether this function has a dependent exception
            /// spec.</para>
            /// </remarks>
            public bool hasDependentExceptionSpec()
            {
                var __ret = Internal.hasDependentExceptionSpec_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Get the meaning of the noexcept spec on this function, if
            /// any.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Get the meaning of the noexcept spec on this function,
            /// if any.</para>
            /// </remarks>
            public clang.FunctionProtoType.NoexceptResult getNoexceptSpec(clang.ASTContext Ctx)
            {
                var arg0 = ReferenceEquals(Ctx, null) ? global::System.IntPtr.Zero : Ctx.__Instance;
                var __ret = Internal.getNoexceptSpec_0(__Instance, arg0);
                return __ret;
            }

            public uint getNumExceptions()
            {
                var __ret = Internal.getNumExceptions_0(__Instance);
                return __ret;
            }

            public clang.QualType getExceptionType(uint i)
            {
                var __ret = Internal.getExceptionType_0(__Instance, i);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>If this function type has an exception specification which hasn't
            /// been determined yet (either because it has not been evaluated or because it
            /// has not been instantiated), this is the function whose exception
            /// specification is represented by this type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief If this function type has an exception specification
            /// which hasn't</para>
            /// <para>  /// been determined yet (either because it has not been
            /// evaluated or because</para>
            /// <para>  /// it has not been instantiated), this is the function whose
            /// exception</para>
            /// <para>  /// specification is represented by this type.</para>
            /// </remarks>
            public clang.FunctionDecl getExceptionSpecDecl()
            {
                var __ret = Internal.getExceptionSpecDecl_0(__Instance);
                clang.FunctionDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.FunctionDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.FunctionDecl) clang.FunctionDecl.NativeToManagedMap[__ret];
                else clang.FunctionDecl.NativeToManagedMap[__ret] = __result0 = (clang.FunctionDecl) clang.FunctionDecl.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>If this function type has an uninstantiated exception
            /// specification, this is the function whose exception specification should be
            /// instantiated to find the exception specification for this type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief If this function type has an uninstantiated
            /// exception</para>
            /// <para>  /// specification, this is the function whose exception
            /// specification</para>
            /// <para>  /// should be instantiated to find the exception specification
            /// for</para>
            /// <para>  /// this type.</para>
            /// </remarks>
            public clang.FunctionDecl getExceptionSpecTemplate()
            {
                var __ret = Internal.getExceptionSpecTemplate_0(__Instance);
                clang.FunctionDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.FunctionDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.FunctionDecl) clang.FunctionDecl.NativeToManagedMap[__ret];
                else clang.FunctionDecl.NativeToManagedMap[__ret] = __result0 = (clang.FunctionDecl) clang.FunctionDecl.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Determine whether this function type has a non-throwing exception
            /// specification. If this depends on template arguments, returns
            /// ResultIfDependent.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine whether this function type has a
            /// non-throwing exception</para>
            /// <para>  /// specification. If this depends on template arguments,
            /// returns</para>
            /// <para>  /// \c ResultIfDependent.</para>
            /// </remarks>
            public bool isNothrow(clang.ASTContext Ctx, bool ResultIfDependent)
            {
                var arg0 = ReferenceEquals(Ctx, null) ? global::System.IntPtr.Zero : Ctx.__Instance;
                var __ret = Internal.isNothrow_0(__Instance, arg0, ResultIfDependent);
                return __ret;
            }

            public bool isVariadic()
            {
                var __ret = Internal.isVariadic_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determines whether this function prototype contains a parameter
            /// pack at the end.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determines whether this function prototype contains
            /// a</para>
            /// <para>  /// parameter pack at the end.</para>
            /// <para>  ///</para>
            /// <para>  /// A function template whose last parameter is a parameter
            /// pack can be</para>
            /// <para>  /// called with an arbitrary number of arguments, much like a
            /// variadic</para>
            /// <para>  /// function.</para>
            /// </remarks>
            public bool isTemplateVariadic()
            {
                var __ret = Internal.isTemplateVariadic_0(__Instance);
                return __ret;
            }

            public bool hasTrailingReturn()
            {
                var __ret = Internal.hasTrailingReturn_0(__Instance);
                return __ret;
            }

            public uint getTypeQuals()
            {
                var __ret = Internal.getTypeQuals_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Retrieve the ref-qualifier associated with this function
            /// type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the ref-qualifier associated with this
            /// function type.</para>
            /// </remarks>
            public clang.RefQualifierKind getRefQualifier()
            {
                var __ret = Internal.getRefQualifier_0(__Instance);
                return __ret;
            }

            public clang.QualType param_type_begin()
            {
                var __ret = Internal.param_type_begin_0(__Instance);
                clang.QualType __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.QualType.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.QualType) clang.QualType.NativeToManagedMap[__ret];
                else __result0 = clang.QualType.__CreateInstance(__ret);
                return __result0;
            }

            public clang.QualType param_type_end()
            {
                var __ret = Internal.param_type_end_0(__Instance);
                clang.QualType __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.QualType.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.QualType) clang.QualType.NativeToManagedMap[__ret];
                else __result0 = clang.QualType.__CreateInstance(__ret);
                return __result0;
            }

            public clang.QualType exception_begin()
            {
                var __ret = Internal.exception_begin_0(__Instance);
                clang.QualType __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.QualType.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.QualType) clang.QualType.NativeToManagedMap[__ret];
                else __result0 = clang.QualType.__CreateInstance(__ret);
                return __result0;
            }

            public clang.QualType exception_end()
            {
                var __ret = Internal.exception_end_0(__Instance);
                clang.QualType __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.QualType.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.QualType) clang.QualType.NativeToManagedMap[__ret];
                else __result0 = clang.QualType.__CreateInstance(__ret);
                return __result0;
            }

            public bool hasAnyConsumedParams()
            {
                var __ret = Internal.hasAnyConsumedParams_0(__Instance);
                return __ret;
            }

            public bool isParamConsumed(uint I)
            {
                var __ret = Internal.isParamConsumed_0(__Instance, I);
                return __ret;
            }

            public bool isSugared()
            {
                var __ret = Internal.isSugared_0(__Instance);
                return __ret;
            }

            public clang.QualType desugar()
            {
                var __ret = Internal.desugar_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            public void printExceptionSpecification(llvm.raw_ostream OS, clang.PrintingPolicy Policy)
            {
                var arg0 = ReferenceEquals(OS, null) ? global::System.IntPtr.Zero : OS.__Instance;
                var arg1 = ReferenceEquals(Policy, null) ? global::System.IntPtr.Zero : Policy.__Instance;
                Internal.printExceptionSpecification_0(__Instance, arg0, arg1);
            }

            public void Profile(llvm.FoldingSetNodeID ID, clang.ASTContext Ctx)
            {
                var arg0 = ReferenceEquals(ID, null) ? global::System.IntPtr.Zero : ID.__Instance;
                var arg1 = ReferenceEquals(Ctx, null) ? global::System.IntPtr.Zero : Ctx.__Instance;
                Internal.Profile_0(__Instance, arg0, arg1);
            }

            public static bool classof(clang.Type T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }

            public static void Profile(llvm.FoldingSetNodeID ID, clang.QualType Result, clang.QualType ArgTys, uint NumArgs, clang.FunctionProtoType.ExtProtoInfo EPI, clang.ASTContext Context)
            {
                var arg0 = ReferenceEquals(ID, null) ? global::System.IntPtr.Zero : ID.__Instance;
                var arg1 = ReferenceEquals(Result, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (Result.__Instance);
                var arg2 = ReferenceEquals(ArgTys, null) ? global::System.IntPtr.Zero : ArgTys.__Instance;
                var arg4 = ReferenceEquals(EPI, null) ? global::System.IntPtr.Zero : EPI.__Instance;
                var arg5 = ReferenceEquals(Context, null) ? global::System.IntPtr.Zero : Context.__Instance;
                Internal.Profile_1(arg0, arg1, arg2, NumArgs, arg4, arg5);
            }
        }

        /// <summary>
        /// <para>Represents the dependent type named by a dependently-scoped
        /// typename using declaration, e.g. using typename Base&lt;T&gt;::foo;
        /// Template instantiation turns these into the underlying type.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief Represents the dependent type named by a
        /// dependently-scoped</para>
        /// <para>/// typename using declaration, e.g.</para>
        /// <para>///   using typename Base&lt;T&gt;::foo;</para>
        /// <para>/// Template instantiation turns these into the underlying
        /// type.</para>
        /// </remarks>
        public unsafe partial class UnresolvedUsingType : clang.Type, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 32)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr BaseType;

                [FieldOffset(8)]
                public clang.QualType.Internal CanonicalType;

                [FieldOffset(16)]
                internal clang.Type._.Internal __;

                [FieldOffset(24)]
                public global::System.IntPtr Decl;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang19UnresolvedUsingTypeC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang19UnresolvedUsingType9isSugaredEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isSugared_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang19UnresolvedUsingType7desugarEv")]
                internal static extern clang.QualType.Internal desugar_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang19UnresolvedUsingType7classofEPKNS_4TypeE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang19UnresolvedUsingType7ProfileERN4llvm16FoldingSetNodeIDE")]
                internal static extern void Profile_0(global::System.IntPtr instance, global::System.IntPtr ID);
            }

            private readonly bool __ownsNativeInstance;

            public static new UnresolvedUsingType __CreateInstance(global::System.IntPtr native)
            {
                return new UnresolvedUsingType((UnresolvedUsingType.Internal*) native);
            }

            public static UnresolvedUsingType __CreateInstance(UnresolvedUsingType.Internal native)
            {
                return new UnresolvedUsingType(native);
            }

            private static UnresolvedUsingType.Internal* __CopyValue(UnresolvedUsingType.Internal native)
            {
                var ret = (UnresolvedUsingType.Internal*) Marshal.AllocHGlobal(32);
                *ret = native;
                return ret;
            }

            private UnresolvedUsingType(UnresolvedUsingType.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected UnresolvedUsingType(UnresolvedUsingType.Internal* native, bool isInternalImpl = false)
                : base((clang.Type.Internal*) native)
            {
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.ExtQualsTypeCommonBase __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public bool isSugared()
            {
                var __ret = Internal.isSugared_0(__Instance);
                return __ret;
            }

            public clang.QualType desugar()
            {
                var __ret = Internal.desugar_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            public void Profile(llvm.FoldingSetNodeID ID)
            {
                var arg0 = ReferenceEquals(ID, null) ? global::System.IntPtr.Zero : ID.__Instance;
                Internal.Profile_0(__Instance, arg0);
            }

            public static bool classof(clang.Type T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        public unsafe partial class TypedefType : clang.Type, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 32)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr BaseType;

                [FieldOffset(8)]
                public clang.QualType.Internal CanonicalType;

                [FieldOffset(16)]
                internal clang.Type._.Internal __;

                [FieldOffset(24)]
                public global::System.IntPtr Decl;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11TypedefTypeC2ENS_4Type9TypeClassEPKNS_15TypedefNameDeclENS_8QualTypeE")]
                internal static extern void ctor_0(global::System.IntPtr instance, clang.Type.TypeClass tc, global::System.IntPtr D, clang.QualType.Internal can);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11TypedefTypeC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11TypedefType7getDeclEv")]
                internal static extern global::System.IntPtr getDecl_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11TypedefType9isSugaredEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isSugared_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11TypedefType7desugarEv")]
                internal static extern clang.QualType.Internal desugar_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11TypedefType7classofEPKNS_4TypeE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);
            }

            private readonly bool __ownsNativeInstance;

            public static new TypedefType __CreateInstance(global::System.IntPtr native)
            {
                return new TypedefType((TypedefType.Internal*) native);
            }

            public static TypedefType __CreateInstance(TypedefType.Internal native)
            {
                return new TypedefType(native);
            }

            private static TypedefType.Internal* __CopyValue(TypedefType.Internal native)
            {
                var ret = (TypedefType.Internal*) Marshal.AllocHGlobal(32);
                *ret = native;
                return ret;
            }

            private TypedefType(TypedefType.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected TypedefType(TypedefType.Internal* native, bool isInternalImpl = false)
                : base((clang.Type.Internal*) native)
            {
            }

            protected TypedefType(clang.Type.TypeClass tc, clang.TypedefNameDecl D, clang.QualType can)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(32);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = tc;
                var arg1 = ReferenceEquals(D, null) ? global::System.IntPtr.Zero : D.__Instance;
                var arg2 = ReferenceEquals(can, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (can.__Instance);
                Internal.ctor_0(__Instance, arg0, arg1, arg2);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.ExtQualsTypeCommonBase __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.TypedefNameDecl getDecl()
            {
                var __ret = Internal.getDecl_0(__Instance);
                clang.TypedefNameDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.TypedefNameDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.TypedefNameDecl) clang.TypedefNameDecl.NativeToManagedMap[__ret];
                else clang.TypedefNameDecl.NativeToManagedMap[__ret] = __result0 = (clang.TypedefNameDecl) clang.TypedefNameDecl.__CreateInstance(__ret);
                return __result0;
            }

            public bool isSugared()
            {
                var __ret = Internal.isSugared_0(__Instance);
                return __ret;
            }

            public clang.QualType desugar()
            {
                var __ret = Internal.desugar_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            public static bool classof(clang.Type T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>TypeOfExprType (GCC extension).</para>
        /// </summary>
        /// <remarks>
        /// <para>/// TypeOfExprType (GCC extension).</para>
        /// </remarks>
        public unsafe partial class TypeOfExprType : clang.Type, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 32)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr BaseType;

                [FieldOffset(8)]
                public clang.QualType.Internal CanonicalType;

                [FieldOffset(16)]
                internal clang.Type._.Internal __;

                [FieldOffset(24)]
                public global::System.IntPtr TOExpr;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14TypeOfExprTypeC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14TypeOfExprType7desugarEv")]
                internal static extern clang.QualType.Internal desugar_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14TypeOfExprType9isSugaredEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isSugared_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14TypeOfExprType7classofEPKNS_4TypeE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);
            }

            private readonly bool __ownsNativeInstance;

            public static new TypeOfExprType __CreateInstance(global::System.IntPtr native)
            {
                return new TypeOfExprType((TypeOfExprType.Internal*) native);
            }

            public static TypeOfExprType __CreateInstance(TypeOfExprType.Internal native)
            {
                return new TypeOfExprType(native);
            }

            private static TypeOfExprType.Internal* __CopyValue(TypeOfExprType.Internal native)
            {
                var ret = (TypeOfExprType.Internal*) Marshal.AllocHGlobal(32);
                *ret = native;
                return ret;
            }

            private TypeOfExprType(TypeOfExprType.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected TypeOfExprType(TypeOfExprType.Internal* native, bool isInternalImpl = false)
                : base((clang.Type.Internal*) native)
            {
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.ExtQualsTypeCommonBase __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            /// <summary>
            /// <para>Remove a single level of sugar.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Remove a single level of sugar.</para>
            /// </remarks>
            public clang.QualType desugar()
            {
                var __ret = Internal.desugar_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Returns whether this type directly provides sugar.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Returns whether this type directly provides
            /// sugar.</para>
            /// </remarks>
            public bool isSugared()
            {
                var __ret = Internal.isSugared_0(__Instance);
                return __ret;
            }

            public static bool classof(clang.Type T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Internal representation of canonical, dependent typeof(expr)
        /// types.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief Internal representation of canonical, dependent</para>
        /// <para>/// typeof(expr) types.</para>
        /// <para>///</para>
        /// <para>/// This class is used internally by the ASTContext to
        /// manage</para>
        /// <para>/// canonical, dependent types, only. Clients will only see
        /// instances</para>
        /// <para>/// of this class via TypeOfExprType nodes.</para>
        /// </remarks>
        public unsafe partial class DependentTypeOfExprType : clang.TypeOfExprType, llvm.FoldingSetImpl.Node, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 48)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr BaseType;

                [FieldOffset(8)]
                public clang.QualType.Internal CanonicalType;

                [FieldOffset(16)]
                internal clang.Type._.Internal __;

                [FieldOffset(24)]
                public global::System.IntPtr TOExpr;

                [FieldOffset(0)]
                public global::System.IntPtr NextInFoldingSetBucket;

                [FieldOffset(40)]
                public global::System.IntPtr Context;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang23DependentTypeOfExprTypeC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang23DependentTypeOfExprType7ProfileERN4llvm16FoldingSetNodeIDE")]
                internal static extern void Profile_0(global::System.IntPtr instance, global::System.IntPtr ID);
            }

            private readonly bool __ownsNativeInstance;

            public static new DependentTypeOfExprType __CreateInstance(global::System.IntPtr native)
            {
                return new DependentTypeOfExprType((DependentTypeOfExprType.Internal*) native);
            }

            public static DependentTypeOfExprType __CreateInstance(DependentTypeOfExprType.Internal native)
            {
                return new DependentTypeOfExprType(native);
            }

            private static DependentTypeOfExprType.Internal* __CopyValue(DependentTypeOfExprType.Internal native)
            {
                var ret = (DependentTypeOfExprType.Internal*) Marshal.AllocHGlobal(48);
                *ret = native;
                return ret;
            }

            private DependentTypeOfExprType(DependentTypeOfExprType.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected DependentTypeOfExprType(DependentTypeOfExprType.Internal* native, bool isInternalImpl = false)
                : base((clang.TypeOfExprType.Internal*) native)
            {
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.ExtQualsTypeCommonBase __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public void Profile(llvm.FoldingSetNodeID ID)
            {
                var arg0 = ReferenceEquals(ID, null) ? global::System.IntPtr.Zero : ID.__Instance;
                Internal.Profile_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>TypeOfType (GCC extension).</para>
        /// </summary>
        /// <remarks>
        /// <para>/// TypeOfType (GCC extension).</para>
        /// </remarks>
        public unsafe partial class TypeOfType : clang.Type, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 32)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr BaseType;

                [FieldOffset(8)]
                public clang.QualType.Internal CanonicalType;

                [FieldOffset(16)]
                internal clang.Type._.Internal __;

                [FieldOffset(24)]
                public clang.QualType.Internal TOType;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10TypeOfTypeC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10TypeOfType17getUnderlyingTypeEv")]
                internal static extern clang.QualType.Internal getUnderlyingType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10TypeOfType7desugarEv")]
                internal static extern clang.QualType.Internal desugar_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10TypeOfType9isSugaredEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isSugared_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10TypeOfType7classofEPKNS_4TypeE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);
            }

            private readonly bool __ownsNativeInstance;

            public static new TypeOfType __CreateInstance(global::System.IntPtr native)
            {
                return new TypeOfType((TypeOfType.Internal*) native);
            }

            public static TypeOfType __CreateInstance(TypeOfType.Internal native)
            {
                return new TypeOfType(native);
            }

            private static TypeOfType.Internal* __CopyValue(TypeOfType.Internal native)
            {
                var ret = (TypeOfType.Internal*) Marshal.AllocHGlobal(32);
                *ret = native;
                return ret;
            }

            private TypeOfType(TypeOfType.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected TypeOfType(TypeOfType.Internal* native, bool isInternalImpl = false)
                : base((clang.Type.Internal*) native)
            {
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.ExtQualsTypeCommonBase __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.QualType getUnderlyingType()
            {
                var __ret = Internal.getUnderlyingType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Remove a single level of sugar.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Remove a single level of sugar.</para>
            /// </remarks>
            public clang.QualType desugar()
            {
                var __ret = Internal.desugar_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Returns whether this type directly provides sugar.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Returns whether this type directly provides
            /// sugar.</para>
            /// </remarks>
            public bool isSugared()
            {
                var __ret = Internal.isSugared_0(__Instance);
                return __ret;
            }

            public static bool classof(clang.Type T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>DecltypeType (C++0x)</para>
        /// </summary>
        /// <remarks>
        /// <para>/// DecltypeType (C++0x)</para>
        /// </remarks>
        public unsafe partial class DecltypeType : clang.Type, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 40)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr BaseType;

                [FieldOffset(8)]
                public clang.QualType.Internal CanonicalType;

                [FieldOffset(16)]
                internal clang.Type._.Internal __;

                [FieldOffset(24)]
                public global::System.IntPtr E;

                [FieldOffset(32)]
                public clang.QualType.Internal UnderlyingType;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12DecltypeTypeC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12DecltypeType17getUnderlyingTypeEv")]
                internal static extern clang.QualType.Internal getUnderlyingType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12DecltypeType7desugarEv")]
                internal static extern clang.QualType.Internal desugar_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12DecltypeType9isSugaredEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isSugared_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12DecltypeType7classofEPKNS_4TypeE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);
            }

            private readonly bool __ownsNativeInstance;

            public static new DecltypeType __CreateInstance(global::System.IntPtr native)
            {
                return new DecltypeType((DecltypeType.Internal*) native);
            }

            public static DecltypeType __CreateInstance(DecltypeType.Internal native)
            {
                return new DecltypeType(native);
            }

            private static DecltypeType.Internal* __CopyValue(DecltypeType.Internal native)
            {
                var ret = (DecltypeType.Internal*) Marshal.AllocHGlobal(40);
                *ret = native;
                return ret;
            }

            private DecltypeType(DecltypeType.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected DecltypeType(DecltypeType.Internal* native, bool isInternalImpl = false)
                : base((clang.Type.Internal*) native)
            {
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.ExtQualsTypeCommonBase __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.QualType getUnderlyingType()
            {
                var __ret = Internal.getUnderlyingType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Remove a single level of sugar.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Remove a single level of sugar.</para>
            /// </remarks>
            public clang.QualType desugar()
            {
                var __ret = Internal.desugar_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Returns whether this type directly provides sugar.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Returns whether this type directly provides
            /// sugar.</para>
            /// </remarks>
            public bool isSugared()
            {
                var __ret = Internal.isSugared_0(__Instance);
                return __ret;
            }

            public static bool classof(clang.Type T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Internal representation of canonical, dependent decltype(expr)
        /// types.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief Internal representation of canonical, dependent</para>
        /// <para>/// decltype(expr) types.</para>
        /// <para>///</para>
        /// <para>/// This class is used internally by the ASTContext to
        /// manage</para>
        /// <para>/// canonical, dependent types, only. Clients will only see
        /// instances</para>
        /// <para>/// of this class via DecltypeType nodes.</para>
        /// </remarks>
        public unsafe partial class DependentDecltypeType : clang.DecltypeType, llvm.FoldingSetImpl.Node, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 56)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr BaseType;

                [FieldOffset(8)]
                public clang.QualType.Internal CanonicalType;

                [FieldOffset(16)]
                internal clang.Type._.Internal __;

                [FieldOffset(24)]
                public global::System.IntPtr E;

                [FieldOffset(32)]
                public clang.QualType.Internal UnderlyingType;

                [FieldOffset(0)]
                public global::System.IntPtr NextInFoldingSetBucket;

                [FieldOffset(48)]
                public global::System.IntPtr Context;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang21DependentDecltypeTypeC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang21DependentDecltypeType7ProfileERN4llvm16FoldingSetNodeIDE")]
                internal static extern void Profile_0(global::System.IntPtr instance, global::System.IntPtr ID);
            }

            private readonly bool __ownsNativeInstance;

            public static new DependentDecltypeType __CreateInstance(global::System.IntPtr native)
            {
                return new DependentDecltypeType((DependentDecltypeType.Internal*) native);
            }

            public static DependentDecltypeType __CreateInstance(DependentDecltypeType.Internal native)
            {
                return new DependentDecltypeType(native);
            }

            private static DependentDecltypeType.Internal* __CopyValue(DependentDecltypeType.Internal native)
            {
                var ret = (DependentDecltypeType.Internal*) Marshal.AllocHGlobal(56);
                *ret = native;
                return ret;
            }

            private DependentDecltypeType(DependentDecltypeType.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected DependentDecltypeType(DependentDecltypeType.Internal* native, bool isInternalImpl = false)
                : base((clang.DecltypeType.Internal*) native)
            {
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.ExtQualsTypeCommonBase __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public void Profile(llvm.FoldingSetNodeID ID)
            {
                var arg0 = ReferenceEquals(ID, null) ? global::System.IntPtr.Zero : ID.__Instance;
                Internal.Profile_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>A unary type transform, which is a type constructed from
        /// another</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief A unary type transform, which is a type constructed
        /// from another</para>
        /// </remarks>
        public unsafe partial class UnaryTransformType : clang.Type, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 48)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr BaseType;

                [FieldOffset(8)]
                public clang.QualType.Internal CanonicalType;

                [FieldOffset(16)]
                internal clang.Type._.Internal __;

                [FieldOffset(24)]
                public clang.QualType.Internal BaseType;

                [FieldOffset(32)]
                public clang.QualType.Internal UnderlyingType;

                [FieldOffset(40)]
                public clang.UnaryTransformType.UTTKind UKind;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang18UnaryTransformTypeC2ENS_8QualTypeES1_NS0_7UTTKindES1_")]
                internal static extern void ctor_0(global::System.IntPtr instance, clang.QualType.Internal BaseTy, clang.QualType.Internal UnderlyingTy, clang.UnaryTransformType.UTTKind UKind, clang.QualType.Internal CanonicalTy);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang18UnaryTransformTypeC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang18UnaryTransformType9isSugaredEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isSugared_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang18UnaryTransformType7desugarEv")]
                internal static extern clang.QualType.Internal desugar_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang18UnaryTransformType17getUnderlyingTypeEv")]
                internal static extern clang.QualType.Internal getUnderlyingType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang18UnaryTransformType11getBaseTypeEv")]
                internal static extern clang.QualType.Internal getBaseType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang18UnaryTransformType10getUTTKindEv")]
                internal static extern clang.UnaryTransformType.UTTKind getUTTKind_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang18UnaryTransformType7classofEPKNS_4TypeE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);
            }

            public enum UTTKind : uint
            {
                EnumUnderlyingType = 0
            }

            private readonly bool __ownsNativeInstance;

            public static new UnaryTransformType __CreateInstance(global::System.IntPtr native)
            {
                return new UnaryTransformType((UnaryTransformType.Internal*) native);
            }

            public static UnaryTransformType __CreateInstance(UnaryTransformType.Internal native)
            {
                return new UnaryTransformType(native);
            }

            private static UnaryTransformType.Internal* __CopyValue(UnaryTransformType.Internal native)
            {
                var ret = (UnaryTransformType.Internal*) Marshal.AllocHGlobal(48);
                *ret = native;
                return ret;
            }

            private UnaryTransformType(UnaryTransformType.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected UnaryTransformType(UnaryTransformType.Internal* native, bool isInternalImpl = false)
                : base((clang.Type.Internal*) native)
            {
            }

            protected UnaryTransformType(clang.QualType BaseTy, clang.QualType UnderlyingTy, clang.UnaryTransformType.UTTKind UKind, clang.QualType CanonicalTy)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(48);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(BaseTy, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (BaseTy.__Instance);
                var arg1 = ReferenceEquals(UnderlyingTy, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (UnderlyingTy.__Instance);
                var arg2 = UKind;
                var arg3 = ReferenceEquals(CanonicalTy, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (CanonicalTy.__Instance);
                Internal.ctor_0(__Instance, arg0, arg1, arg2, arg3);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.ExtQualsTypeCommonBase __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public bool isSugared()
            {
                var __ret = Internal.isSugared_0(__Instance);
                return __ret;
            }

            public clang.QualType desugar()
            {
                var __ret = Internal.desugar_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            public clang.QualType getUnderlyingType()
            {
                var __ret = Internal.getUnderlyingType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            public clang.QualType getBaseType()
            {
                var __ret = Internal.getBaseType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            public clang.UnaryTransformType.UTTKind getUTTKind()
            {
                var __ret = Internal.getUTTKind_0(__Instance);
                return __ret;
            }

            public static bool classof(clang.Type T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        public unsafe partial class TagType : clang.Type, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 32)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr BaseType;

                [FieldOffset(8)]
                public clang.QualType.Internal CanonicalType;

                [FieldOffset(16)]
                internal clang.Type._.Internal __;

                [FieldOffset(24)]
                public global::System.IntPtr decl;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang7TagTypeC2ENS_4Type9TypeClassEPKNS_7TagDeclENS_8QualTypeE")]
                internal static extern void ctor_0(global::System.IntPtr instance, clang.Type.TypeClass TC, global::System.IntPtr D, clang.QualType.Internal can);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang7TagTypeC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7TagType7getDeclEv")]
                internal static extern global::System.IntPtr getDecl_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7TagType14isBeingDefinedEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isBeingDefined_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang7TagType7classofEPKNS_4TypeE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);
            }

            private readonly bool __ownsNativeInstance;

            public static new TagType __CreateInstance(global::System.IntPtr native)
            {
                return new TagType((TagType.Internal*) native);
            }

            public static TagType __CreateInstance(TagType.Internal native)
            {
                return new TagType(native);
            }

            private static TagType.Internal* __CopyValue(TagType.Internal native)
            {
                var ret = (TagType.Internal*) Marshal.AllocHGlobal(32);
                *ret = native;
                return ret;
            }

            private TagType(TagType.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected TagType(TagType.Internal* native, bool isInternalImpl = false)
                : base((clang.Type.Internal*) native)
            {
            }

            protected TagType(clang.Type.TypeClass TC, clang.TagDecl D, clang.QualType can)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(32);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = TC;
                var arg1 = ReferenceEquals(D, null) ? global::System.IntPtr.Zero : D.__Instance;
                var arg2 = ReferenceEquals(can, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (can.__Instance);
                Internal.ctor_0(__Instance, arg0, arg1, arg2);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.ExtQualsTypeCommonBase __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.TagDecl getDecl()
            {
                var __ret = Internal.getDecl_0(__Instance);
                clang.TagDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.TagDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.TagDecl) clang.TagDecl.NativeToManagedMap[__ret];
                else clang.TagDecl.NativeToManagedMap[__ret] = __result0 = (clang.TagDecl) clang.TagDecl.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Determines whether this type is in the process of being
            /// defined.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// @brief Determines whether this type is in the process of
            /// being</para>
            /// <para>  /// defined.</para>
            /// </remarks>
            public bool isBeingDefined()
            {
                var __ret = Internal.isBeingDefined_0(__Instance);
                return __ret;
            }

            public static bool classof(clang.Type T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>RecordType - This is a helper class that allows the use of
        /// isa/cast/dyncast to detect TagType objects of
        /// structs/unions/classes.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// RecordType - This is a helper class that allows the use of
        /// isa/cast/dyncast</para>
        /// <para>/// to detect TagType objects of structs/unions/classes.</para>
        /// </remarks>
        public unsafe partial class RecordType : clang.TagType, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 32)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr BaseType;

                [FieldOffset(8)]
                public clang.QualType.Internal CanonicalType;

                [FieldOffset(16)]
                internal clang.Type._.Internal __;

                [FieldOffset(24)]
                public global::System.IntPtr decl;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10RecordTypeC2EPKNS_10RecordDeclE")]
                internal static extern void ctor_0(global::System.IntPtr instance, global::System.IntPtr D);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10RecordTypeC2ENS_4Type9TypeClassEPNS_10RecordDeclE")]
                internal static extern void ctor_1(global::System.IntPtr instance, clang.Type.TypeClass TC, global::System.IntPtr D);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10RecordTypeC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10RecordType7getDeclEv")]
                internal static extern global::System.IntPtr getDecl_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10RecordType14hasConstFieldsEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasConstFields_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10RecordType9isSugaredEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isSugared_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10RecordType7desugarEv")]
                internal static extern clang.QualType.Internal desugar_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10RecordType7classofEPKNS_4TypeE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);
            }

            private readonly bool __ownsNativeInstance;

            public static new RecordType __CreateInstance(global::System.IntPtr native)
            {
                return new RecordType((RecordType.Internal*) native);
            }

            public static RecordType __CreateInstance(RecordType.Internal native)
            {
                return new RecordType(native);
            }

            private static RecordType.Internal* __CopyValue(RecordType.Internal native)
            {
                var ret = (RecordType.Internal*) Marshal.AllocHGlobal(32);
                *ret = native;
                return ret;
            }

            private RecordType(RecordType.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected RecordType(RecordType.Internal* native, bool isInternalImpl = false)
                : base((clang.TagType.Internal*) native)
            {
            }

            protected RecordType(clang.RecordDecl D)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(32);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(D, null) ? global::System.IntPtr.Zero : D.__Instance;
                Internal.ctor_0(__Instance, arg0);
            }

            protected RecordType(clang.Type.TypeClass TC, clang.RecordDecl D)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(32);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = TC;
                var arg1 = ReferenceEquals(D, null) ? global::System.IntPtr.Zero : D.__Instance;
                Internal.ctor_1(__Instance, arg0, arg1);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.ExtQualsTypeCommonBase __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.RecordDecl getDecl()
            {
                var __ret = Internal.getDecl_0(__Instance);
                clang.RecordDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.RecordDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.RecordDecl) clang.RecordDecl.NativeToManagedMap[__ret];
                else clang.RecordDecl.NativeToManagedMap[__ret] = __result0 = (clang.RecordDecl) clang.RecordDecl.__CreateInstance(__ret);
                return __result0;
            }

            public bool hasConstFields()
            {
                var __ret = Internal.hasConstFields_0(__Instance);
                return __ret;
            }

            public bool isSugared()
            {
                var __ret = Internal.isSugared_0(__Instance);
                return __ret;
            }

            public clang.QualType desugar()
            {
                var __ret = Internal.desugar_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            public static bool classof(clang.Type T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>EnumType - This is a helper class that allows the use of
        /// isa/cast/dyncast to detect TagType objects of enums.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// EnumType - This is a helper class that allows the use of
        /// isa/cast/dyncast</para>
        /// <para>/// to detect TagType objects of enums.</para>
        /// </remarks>
        public unsafe partial class EnumType : clang.TagType, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 32)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr BaseType;

                [FieldOffset(8)]
                public clang.QualType.Internal CanonicalType;

                [FieldOffset(16)]
                internal clang.Type._.Internal __;

                [FieldOffset(24)]
                public global::System.IntPtr decl;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8EnumTypeC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8EnumType7getDeclEv")]
                internal static extern global::System.IntPtr getDecl_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8EnumType9isSugaredEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isSugared_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8EnumType7desugarEv")]
                internal static extern clang.QualType.Internal desugar_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8EnumType7classofEPKNS_4TypeE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);
            }

            private readonly bool __ownsNativeInstance;

            public static new EnumType __CreateInstance(global::System.IntPtr native)
            {
                return new EnumType((EnumType.Internal*) native);
            }

            public static EnumType __CreateInstance(EnumType.Internal native)
            {
                return new EnumType(native);
            }

            private static EnumType.Internal* __CopyValue(EnumType.Internal native)
            {
                var ret = (EnumType.Internal*) Marshal.AllocHGlobal(32);
                *ret = native;
                return ret;
            }

            private EnumType(EnumType.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected EnumType(EnumType.Internal* native, bool isInternalImpl = false)
                : base((clang.TagType.Internal*) native)
            {
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.ExtQualsTypeCommonBase __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.EnumDecl getDecl()
            {
                var __ret = Internal.getDecl_0(__Instance);
                clang.EnumDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.EnumDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.EnumDecl) clang.EnumDecl.NativeToManagedMap[__ret];
                else clang.EnumDecl.NativeToManagedMap[__ret] = __result0 = (clang.EnumDecl) clang.EnumDecl.__CreateInstance(__ret);
                return __result0;
            }

            public bool isSugared()
            {
                var __ret = Internal.isSugared_0(__Instance);
                return __ret;
            }

            public clang.QualType desugar()
            {
                var __ret = Internal.desugar_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            public static bool classof(clang.Type T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>AttributedType - An attributed type is a type to which a type
        /// attribute has been applied. The &quot;modified type&quot; is the
        /// fully-sugared type to which the attributed type was applied; generally it
        /// is not canonically equivalent to the attributed type. The &quot;equivalent
        /// type&quot; is the minimally-desugared type which the type is canonically
        /// equivalent to.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// AttributedType - An attributed type is a type to which a
        /// type</para>
        /// <para>/// attribute has been applied.  The &quot;modified type&quot; is
        /// the</para>
        /// <para>/// fully-sugared type to which the attributed type was
        /// applied;</para>
        /// <para>/// generally it is not canonically equivalent to the attributed
        /// type.</para>
        /// <para>/// The &quot;equivalent type&quot; is the minimally-desugared
        /// type which the</para>
        /// <para>/// type is canonically equivalent to.</para>
        /// <para>///</para>
        /// <para>/// For example, in the following attributed type:</para>
        /// <para>///     int32_t __attribute__((vector_size(16)))</para>
        /// <para>///   - the modified type is the TypedefType for int32_t</para>
        /// <para>///   - the equivalent type is VectorType(16, int32_t)</para>
        /// <para>///   - the canonical type is VectorType(16, int)</para>
        /// </remarks>
        public unsafe partial class AttributedType : clang.Type, llvm.FoldingSetImpl.Node, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 48)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr BaseType;

                [FieldOffset(8)]
                public clang.QualType.Internal CanonicalType;

                [FieldOffset(16)]
                internal clang.Type._.Internal __;

                [FieldOffset(0)]
                public global::System.IntPtr NextInFoldingSetBucket;

                [FieldOffset(32)]
                public clang.QualType.Internal ModifiedType;

                [FieldOffset(40)]
                public clang.QualType.Internal EquivalentType;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14AttributedTypeC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14AttributedType11getAttrKindEv")]
                internal static extern clang.AttributedType.Kind getAttrKind_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14AttributedType15getModifiedTypeEv")]
                internal static extern clang.QualType.Internal getModifiedType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14AttributedType17getEquivalentTypeEv")]
                internal static extern clang.QualType.Internal getEquivalentType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14AttributedType9isSugaredEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isSugared_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14AttributedType7desugarEv")]
                internal static extern clang.QualType.Internal desugar_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14AttributedType12isMSTypeSpecEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isMSTypeSpec_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14AttributedType13isCallingConvEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isCallingConv_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14AttributedType7ProfileERN4llvm16FoldingSetNodeIDE")]
                internal static extern void Profile_0(global::System.IntPtr instance, global::System.IntPtr ID);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14AttributedType7ProfileERN4llvm16FoldingSetNodeIDENS0_4KindENS_8QualTypeES5_")]
                internal static extern void Profile_1(global::System.IntPtr ID, clang.AttributedType.Kind attrKind, clang.QualType.Internal modified, clang.QualType.Internal equivalent);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14AttributedType7classofEPKNS_4TypeE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);
            }

            public enum Kind : uint
            {
                attr_address_space = 0,
                attr_regparm = 1,
                attr_vector_size = 2,
                attr_neon_vector_type = 3,
                attr_neon_polyvector_type = 4,
                FirstExprOperandKind = 0,
                LastExprOperandKind = 4,
                attr_objc_gc = 5,
                attr_objc_ownership = 6,
                attr_pcs = 7,
                attr_pcs_vfp = 8,
                FirstEnumOperandKind = 5,
                LastEnumOperandKind = 8,
                attr_noreturn = 9,
                attr_cdecl = 10,
                attr_fastcall = 11,
                attr_stdcall = 12,
                attr_thiscall = 13,
                attr_pascal = 14,
                attr_vectorcall = 15,
                attr_inteloclbicc = 16,
                attr_ms_abi = 17,
                attr_sysv_abi = 18,
                attr_ptr32 = 19,
                attr_ptr64 = 20,
                attr_sptr = 21,
                attr_uptr = 22
            }

            private readonly bool __ownsNativeInstance;

            public static new AttributedType __CreateInstance(global::System.IntPtr native)
            {
                return new AttributedType((AttributedType.Internal*) native);
            }

            public static AttributedType __CreateInstance(AttributedType.Internal native)
            {
                return new AttributedType(native);
            }

            private static AttributedType.Internal* __CopyValue(AttributedType.Internal native)
            {
                var ret = (AttributedType.Internal*) Marshal.AllocHGlobal(48);
                *ret = native;
                return ret;
            }

            private AttributedType(AttributedType.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected AttributedType(AttributedType.Internal* native, bool isInternalImpl = false)
                : base((clang.Type.Internal*) native)
            {
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.ExtQualsTypeCommonBase __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.AttributedType.Kind getAttrKind()
            {
                var __ret = Internal.getAttrKind_0(__Instance);
                return __ret;
            }

            public clang.QualType getModifiedType()
            {
                var __ret = Internal.getModifiedType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            public clang.QualType getEquivalentType()
            {
                var __ret = Internal.getEquivalentType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            public bool isSugared()
            {
                var __ret = Internal.isSugared_0(__Instance);
                return __ret;
            }

            public clang.QualType desugar()
            {
                var __ret = Internal.desugar_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            public bool isMSTypeSpec()
            {
                var __ret = Internal.isMSTypeSpec_0(__Instance);
                return __ret;
            }

            public bool isCallingConv()
            {
                var __ret = Internal.isCallingConv_0(__Instance);
                return __ret;
            }

            public void Profile(llvm.FoldingSetNodeID ID)
            {
                var arg0 = ReferenceEquals(ID, null) ? global::System.IntPtr.Zero : ID.__Instance;
                Internal.Profile_0(__Instance, arg0);
            }

            public static void Profile(llvm.FoldingSetNodeID ID, clang.AttributedType.Kind attrKind, clang.QualType modified, clang.QualType equivalent)
            {
                var arg0 = ReferenceEquals(ID, null) ? global::System.IntPtr.Zero : ID.__Instance;
                var arg1 = attrKind;
                var arg2 = ReferenceEquals(modified, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (modified.__Instance);
                var arg3 = ReferenceEquals(equivalent, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (equivalent.__Instance);
                Internal.Profile_1(arg0, arg1, arg2, arg3);
            }

            public static bool classof(clang.Type T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        public unsafe partial class TemplateTypeParmType : clang.Type, llvm.FoldingSetImpl.Node, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 40)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr BaseType;

                [FieldOffset(8)]
                public clang.QualType.Internal CanonicalType;

                [FieldOffset(16)]
                internal clang.Type._.Internal __;

                [FieldOffset(0)]
                public global::System.IntPtr NextInFoldingSetBucket;

                [FieldOffset(32)]
                internal clang.TemplateTypeParmType._.Internal _0;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang20TemplateTypeParmTypeC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang20TemplateTypeParmType8getDepthEv")]
                internal static extern uint getDepth_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang20TemplateTypeParmType8getIndexEv")]
                internal static extern uint getIndex_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang20TemplateTypeParmType15isParameterPackEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isParameterPack_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang20TemplateTypeParmType13getIdentifierEv")]
                internal static extern global::System.IntPtr getIdentifier_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang20TemplateTypeParmType9isSugaredEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isSugared_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang20TemplateTypeParmType7desugarEv")]
                internal static extern clang.QualType.Internal desugar_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang20TemplateTypeParmType7ProfileERN4llvm16FoldingSetNodeIDE")]
                internal static extern void Profile_0(global::System.IntPtr instance, global::System.IntPtr ID);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang20TemplateTypeParmType7classofEPKNS_4TypeE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);
            }

            internal unsafe partial class CanonicalTTPTInfo
            {
                [StructLayout(LayoutKind.Explicit, Size = 4)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public uint Depth;

                    [FieldOffset(1)]
                    public uint ParameterPack;

                    [FieldOffset(2)]
                    public uint Index;
                }
            }

            internal unsafe partial struct _
            {
                [StructLayout(LayoutKind.Explicit, Size = 8)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    internal clang.TemplateTypeParmType.CanonicalTTPTInfo.Internal CanTTPTInfo;

                    [FieldOffset(0)]
                    public global::System.IntPtr TTPDecl;
                }
            }

            private readonly bool __ownsNativeInstance;

            public static new TemplateTypeParmType __CreateInstance(global::System.IntPtr native)
            {
                return new TemplateTypeParmType((TemplateTypeParmType.Internal*) native);
            }

            public static TemplateTypeParmType __CreateInstance(TemplateTypeParmType.Internal native)
            {
                return new TemplateTypeParmType(native);
            }

            private static TemplateTypeParmType.Internal* __CopyValue(TemplateTypeParmType.Internal native)
            {
                var ret = (TemplateTypeParmType.Internal*) Marshal.AllocHGlobal(40);
                *ret = native;
                return ret;
            }

            private TemplateTypeParmType(TemplateTypeParmType.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected TemplateTypeParmType(TemplateTypeParmType.Internal* native, bool isInternalImpl = false)
                : base((clang.Type.Internal*) native)
            {
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.ExtQualsTypeCommonBase __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public uint getDepth()
            {
                var __ret = Internal.getDepth_0(__Instance);
                return __ret;
            }

            public uint getIndex()
            {
                var __ret = Internal.getIndex_0(__Instance);
                return __ret;
            }

            public bool isParameterPack()
            {
                var __ret = Internal.isParameterPack_0(__Instance);
                return __ret;
            }

            public clang.IdentifierInfo getIdentifier()
            {
                var __ret = Internal.getIdentifier_0(__Instance);
                clang.IdentifierInfo __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.IdentifierInfo.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.IdentifierInfo) clang.IdentifierInfo.NativeToManagedMap[__ret];
                else __result0 = clang.IdentifierInfo.__CreateInstance(__ret);
                return __result0;
            }

            public bool isSugared()
            {
                var __ret = Internal.isSugared_0(__Instance);
                return __ret;
            }

            public clang.QualType desugar()
            {
                var __ret = Internal.desugar_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            public void Profile(llvm.FoldingSetNodeID ID)
            {
                var arg0 = ReferenceEquals(ID, null) ? global::System.IntPtr.Zero : ID.__Instance;
                Internal.Profile_0(__Instance, arg0);
            }

            public static bool classof(clang.Type T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Represents the result of substituting a type for a template type
        /// parameter.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief Represents the result of substituting a type for a
        /// template</para>
        /// <para>/// type parameter.</para>
        /// <para>///</para>
        /// <para>/// Within an instantiated template, all template type parameters
        /// have</para>
        /// <para>/// been replaced with these.  They are used solely to record
        /// that a</para>
        /// <para>/// type was originally written as a template type
        /// parameter;</para>
        /// <para>/// therefore they are never canonical.</para>
        /// </remarks>
        public unsafe partial class SubstTemplateTypeParmType : clang.Type, llvm.FoldingSetImpl.Node, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 40)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr BaseType;

                [FieldOffset(8)]
                public clang.QualType.Internal CanonicalType;

                [FieldOffset(16)]
                internal clang.Type._.Internal __;

                [FieldOffset(0)]
                public global::System.IntPtr NextInFoldingSetBucket;

                [FieldOffset(32)]
                public global::System.IntPtr Replaced;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang25SubstTemplateTypeParmTypeC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang25SubstTemplateTypeParmType20getReplacedParameterEv")]
                internal static extern global::System.IntPtr getReplacedParameter_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang25SubstTemplateTypeParmType18getReplacementTypeEv")]
                internal static extern clang.QualType.Internal getReplacementType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang25SubstTemplateTypeParmType9isSugaredEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isSugared_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang25SubstTemplateTypeParmType7desugarEv")]
                internal static extern clang.QualType.Internal desugar_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang25SubstTemplateTypeParmType7ProfileERN4llvm16FoldingSetNodeIDE")]
                internal static extern void Profile_0(global::System.IntPtr instance, global::System.IntPtr ID);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang25SubstTemplateTypeParmType7ProfileERN4llvm16FoldingSetNodeIDEPKNS_20TemplateTypeParmTypeENS_8QualTypeE")]
                internal static extern void Profile_1(global::System.IntPtr ID, global::System.IntPtr Replaced, clang.QualType.Internal Replacement);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang25SubstTemplateTypeParmType7classofEPKNS_4TypeE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);
            }

            private readonly bool __ownsNativeInstance;

            public static new SubstTemplateTypeParmType __CreateInstance(global::System.IntPtr native)
            {
                return new SubstTemplateTypeParmType((SubstTemplateTypeParmType.Internal*) native);
            }

            public static SubstTemplateTypeParmType __CreateInstance(SubstTemplateTypeParmType.Internal native)
            {
                return new SubstTemplateTypeParmType(native);
            }

            private static SubstTemplateTypeParmType.Internal* __CopyValue(SubstTemplateTypeParmType.Internal native)
            {
                var ret = (SubstTemplateTypeParmType.Internal*) Marshal.AllocHGlobal(40);
                *ret = native;
                return ret;
            }

            private SubstTemplateTypeParmType(SubstTemplateTypeParmType.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected SubstTemplateTypeParmType(SubstTemplateTypeParmType.Internal* native, bool isInternalImpl = false)
                : base((clang.Type.Internal*) native)
            {
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.ExtQualsTypeCommonBase __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            /// <summary>
            /// <para>Gets the template parameter that was substituted for.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Gets the template parameter that was substituted for.</para>
            /// </remarks>
            public clang.TemplateTypeParmType getReplacedParameter()
            {
                var __ret = Internal.getReplacedParameter_0(__Instance);
                clang.TemplateTypeParmType __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.TemplateTypeParmType.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.TemplateTypeParmType) clang.TemplateTypeParmType.NativeToManagedMap[__ret];
                else __result0 = clang.TemplateTypeParmType.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Gets the type that was substituted for the template
            /// parameter.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Gets the type that was substituted for the template</para>
            /// <para>  /// parameter.</para>
            /// </remarks>
            public clang.QualType getReplacementType()
            {
                var __ret = Internal.getReplacementType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            public bool isSugared()
            {
                var __ret = Internal.isSugared_0(__Instance);
                return __ret;
            }

            public clang.QualType desugar()
            {
                var __ret = Internal.desugar_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            public void Profile(llvm.FoldingSetNodeID ID)
            {
                var arg0 = ReferenceEquals(ID, null) ? global::System.IntPtr.Zero : ID.__Instance;
                Internal.Profile_0(__Instance, arg0);
            }

            public static void Profile(llvm.FoldingSetNodeID ID, clang.TemplateTypeParmType Replaced, clang.QualType Replacement)
            {
                var arg0 = ReferenceEquals(ID, null) ? global::System.IntPtr.Zero : ID.__Instance;
                var arg1 = ReferenceEquals(Replaced, null) ? global::System.IntPtr.Zero : Replaced.__Instance;
                var arg2 = ReferenceEquals(Replacement, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (Replacement.__Instance);
                Internal.Profile_1(arg0, arg1, arg2);
            }

            public static bool classof(clang.Type T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Represents the result of substituting a set of types for a
        /// template type parameter pack.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief Represents the result of substituting a set of types
        /// for a template</para>
        /// <para>/// type parameter pack.</para>
        /// <para>///</para>
        /// <para>/// When a pack expansion in the source code contains multiple
        /// parameter packs</para>
        /// <para>/// and those parameter packs correspond to different levels of
        /// template</para>
        /// <para>/// parameter lists, this type node is used to represent a
        /// template type</para>
        /// <para>/// parameter pack from an outer level, which has already had its
        /// argument pack</para>
        /// <para>/// substituted but that still lives within a pack expansion that
        /// itself</para>
        /// <para>/// could not be instantiated. When actually performing a
        /// substitution into</para>
        /// <para>/// that pack expansion (e.g., when all template parameters have
        /// corresponding</para>
        /// <para>/// arguments), this type will be replaced with the \c
        /// SubstTemplateTypeParmType</para>
        /// <para>/// at the current pack substitution index.</para>
        /// </remarks>
        public unsafe partial class SubstTemplateTypeParmPackType : clang.Type, llvm.FoldingSetImpl.Node, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 56)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr BaseType;

                [FieldOffset(8)]
                public clang.QualType.Internal CanonicalType;

                [FieldOffset(16)]
                internal clang.Type._.Internal __;

                [FieldOffset(0)]
                public global::System.IntPtr NextInFoldingSetBucket;

                [FieldOffset(32)]
                public global::System.IntPtr Replaced;

                [FieldOffset(40)]
                public global::System.IntPtr Arguments;

                [FieldOffset(48)]
                public uint NumArguments;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang29SubstTemplateTypeParmPackTypeC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang29SubstTemplateTypeParmPackType13getIdentifierEv")]
                internal static extern global::System.IntPtr getIdentifier_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang29SubstTemplateTypeParmPackType20getReplacedParameterEv")]
                internal static extern global::System.IntPtr getReplacedParameter_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang29SubstTemplateTypeParmPackType9isSugaredEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isSugared_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang29SubstTemplateTypeParmPackType7desugarEv")]
                internal static extern clang.QualType.Internal desugar_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang29SubstTemplateTypeParmPackType15getArgumentPackEv")]
                internal static extern void getArgumentPack_0(global::System.IntPtr @return, global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang29SubstTemplateTypeParmPackType7ProfileERN4llvm16FoldingSetNodeIDE")]
                internal static extern void Profile_0(global::System.IntPtr instance, global::System.IntPtr ID);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang29SubstTemplateTypeParmPackType7ProfileERN4llvm16FoldingSetNodeIDEPKNS_20TemplateTypeParmTypeERKNS_16TemplateArgumentE")]
                internal static extern void Profile_1(global::System.IntPtr ID, global::System.IntPtr Replaced, global::System.IntPtr ArgPack);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang29SubstTemplateTypeParmPackType7classofEPKNS_4TypeE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);
            }

            private readonly bool __ownsNativeInstance;

            public static new SubstTemplateTypeParmPackType __CreateInstance(global::System.IntPtr native)
            {
                return new SubstTemplateTypeParmPackType((SubstTemplateTypeParmPackType.Internal*) native);
            }

            public static SubstTemplateTypeParmPackType __CreateInstance(SubstTemplateTypeParmPackType.Internal native)
            {
                return new SubstTemplateTypeParmPackType(native);
            }

            private static SubstTemplateTypeParmPackType.Internal* __CopyValue(SubstTemplateTypeParmPackType.Internal native)
            {
                var ret = (SubstTemplateTypeParmPackType.Internal*) Marshal.AllocHGlobal(56);
                *ret = native;
                return ret;
            }

            private SubstTemplateTypeParmPackType(SubstTemplateTypeParmPackType.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected SubstTemplateTypeParmPackType(SubstTemplateTypeParmPackType.Internal* native, bool isInternalImpl = false)
                : base((clang.Type.Internal*) native)
            {
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.ExtQualsTypeCommonBase __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.IdentifierInfo getIdentifier()
            {
                var __ret = Internal.getIdentifier_0(__Instance);
                clang.IdentifierInfo __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.IdentifierInfo.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.IdentifierInfo) clang.IdentifierInfo.NativeToManagedMap[__ret];
                else __result0 = clang.IdentifierInfo.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Gets the template parameter that was substituted for.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Gets the template parameter that was substituted for.</para>
            /// </remarks>
            public clang.TemplateTypeParmType getReplacedParameter()
            {
                var __ret = Internal.getReplacedParameter_0(__Instance);
                clang.TemplateTypeParmType __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.TemplateTypeParmType.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.TemplateTypeParmType) clang.TemplateTypeParmType.NativeToManagedMap[__ret];
                else __result0 = clang.TemplateTypeParmType.__CreateInstance(__ret);
                return __result0;
            }

            public bool isSugared()
            {
                var __ret = Internal.isSugared_0(__Instance);
                return __ret;
            }

            public clang.QualType desugar()
            {
                var __ret = Internal.desugar_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            public clang.TemplateArgument getArgumentPack()
            {
                var __ret = new clang.TemplateArgument.Internal();
                Internal.getArgumentPack_0(new IntPtr(&__ret), __Instance);
                return clang.TemplateArgument.__CreateInstance(__ret);
            }

            public void Profile(llvm.FoldingSetNodeID ID)
            {
                var arg0 = ReferenceEquals(ID, null) ? global::System.IntPtr.Zero : ID.__Instance;
                Internal.Profile_0(__Instance, arg0);
            }

            public static void Profile(llvm.FoldingSetNodeID ID, clang.TemplateTypeParmType Replaced, clang.TemplateArgument ArgPack)
            {
                var arg0 = ReferenceEquals(ID, null) ? global::System.IntPtr.Zero : ID.__Instance;
                var arg1 = ReferenceEquals(Replaced, null) ? global::System.IntPtr.Zero : Replaced.__Instance;
                var arg2 = ReferenceEquals(ArgPack, null) ? global::System.IntPtr.Zero : ArgPack.__Instance;
                Internal.Profile_1(arg0, arg1, arg2);
            }

            public static bool classof(clang.Type T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Represents a C++11 auto or C++1y decltype(auto) type.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief Represents a C++11 auto or C++1y decltype(auto)
        /// type.</para>
        /// <para>///</para>
        /// <para>/// These types are usually a placeholder for a deduced type.
        /// However, before</para>
        /// <para>/// the initializer is attached, or if the initializer is
        /// type-dependent, there</para>
        /// <para>/// is no deduced type and an auto type is canonical. In the
        /// latter case, it is</para>
        /// <para>/// also a dependent type.</para>
        /// </remarks>
        public unsafe partial class AutoType : clang.Type, llvm.FoldingSetImpl.Node, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 32)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr BaseType;

                [FieldOffset(8)]
                public clang.QualType.Internal CanonicalType;

                [FieldOffset(16)]
                internal clang.Type._.Internal __;

                [FieldOffset(0)]
                public global::System.IntPtr NextInFoldingSetBucket;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8AutoTypeC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8AutoType14isDecltypeAutoEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isDecltypeAuto_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8AutoType9isSugaredEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isSugared_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8AutoType7desugarEv")]
                internal static extern clang.QualType.Internal desugar_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8AutoType14getDeducedTypeEv")]
                internal static extern clang.QualType.Internal getDeducedType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8AutoType9isDeducedEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isDeduced_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8AutoType7ProfileERN4llvm16FoldingSetNodeIDE")]
                internal static extern void Profile_0(global::System.IntPtr instance, global::System.IntPtr ID);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8AutoType7ProfileERN4llvm16FoldingSetNodeIDENS_8QualTypeEbb")]
                internal static extern void Profile_1(global::System.IntPtr ID, clang.QualType.Internal Deduced, bool IsDecltypeAuto, bool IsDependent);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8AutoType7classofEPKNS_4TypeE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);
            }

            private readonly bool __ownsNativeInstance;

            public static new AutoType __CreateInstance(global::System.IntPtr native)
            {
                return new AutoType((AutoType.Internal*) native);
            }

            public static AutoType __CreateInstance(AutoType.Internal native)
            {
                return new AutoType(native);
            }

            private static AutoType.Internal* __CopyValue(AutoType.Internal native)
            {
                var ret = (AutoType.Internal*) Marshal.AllocHGlobal(32);
                *ret = native;
                return ret;
            }

            private AutoType(AutoType.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected AutoType(AutoType.Internal* native, bool isInternalImpl = false)
                : base((clang.Type.Internal*) native)
            {
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.ExtQualsTypeCommonBase __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public bool isDecltypeAuto()
            {
                var __ret = Internal.isDecltypeAuto_0(__Instance);
                return __ret;
            }

            public bool isSugared()
            {
                var __ret = Internal.isSugared_0(__Instance);
                return __ret;
            }

            public clang.QualType desugar()
            {
                var __ret = Internal.desugar_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Get the type deduced for this auto type, or null if it's either
            /// not been deduced or was deduced to a dependent type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Get the type deduced for this auto type, or null if
            /// it's either</para>
            /// <para>  /// not been deduced or was deduced to a dependent type.</para>
            /// </remarks>
            public clang.QualType getDeducedType()
            {
                var __ret = Internal.getDeducedType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            public bool isDeduced()
            {
                var __ret = Internal.isDeduced_0(__Instance);
                return __ret;
            }

            public void Profile(llvm.FoldingSetNodeID ID)
            {
                var arg0 = ReferenceEquals(ID, null) ? global::System.IntPtr.Zero : ID.__Instance;
                Internal.Profile_0(__Instance, arg0);
            }

            public static void Profile(llvm.FoldingSetNodeID ID, clang.QualType Deduced, bool IsDecltypeAuto, bool IsDependent)
            {
                var arg0 = ReferenceEquals(ID, null) ? global::System.IntPtr.Zero : ID.__Instance;
                var arg1 = ReferenceEquals(Deduced, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (Deduced.__Instance);
                Internal.Profile_1(arg0, arg1, IsDecltypeAuto, IsDependent);
            }

            public static bool classof(clang.Type T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Represents a type template specialization; the template must be a
        /// class template, a type alias template, or a template template parameter. A
        /// template which cannot be resolved to one of these, e.g. because it is
        /// written with a dependent scope specifier, is instead represented as a
        /// DependentTemplateSpecializationType.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief Represents a type template specialization; the
        /// template</para>
        /// <para>/// must be a class template, a type alias template, or a
        /// template</para>
        /// <para>/// template parameter.  A template which cannot be resolved to
        /// one of</para>
        /// <para>/// these, e.g. because it is written with a dependent
        /// scope</para>
        /// <para>/// specifier, is instead represented as a</para>
        /// <para>/// @c DependentTemplateSpecializationType.</para>
        /// <para>///</para>
        /// <para>/// A non-dependent template specialization type is always
        /// &quot;sugar&quot;,</para>
        /// <para>/// typically for a @c RecordType.  For example, a class
        /// template</para>
        /// <para>/// specialization type of @c vector&lt;int&gt; will refer to a
        /// tag type for</para>
        /// <para>/// the instantiation @c std::vector&lt;int,
        /// std::allocator&lt;int&gt;&gt;</para>
        /// <para>///</para>
        /// <para>/// Template specializations are dependent if either the template
        /// or</para>
        /// <para>/// any of the template arguments are dependent, in which case
        /// the</para>
        /// <para>/// type may also be canonical.</para>
        /// <para>///</para>
        /// <para>/// Instances of this type are allocated with a trailing array
        /// of</para>
        /// <para>/// TemplateArguments, followed by a QualType representing
        /// the</para>
        /// <para>/// non-canonical aliased type when the template is a type
        /// alias</para>
        /// <para>/// template.</para>
        /// </remarks>
        public unsafe partial class TemplateSpecializationType : clang.Type, llvm.FoldingSetImpl.Node, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 48)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr BaseType;

                [FieldOffset(8)]
                public clang.QualType.Internal CanonicalType;

                [FieldOffset(16)]
                internal clang.Type._.Internal __;

                [FieldOffset(0)]
                public global::System.IntPtr NextInFoldingSetBucket;

                [FieldOffset(32)]
                public clang.TemplateName.Internal Template;

                [FieldOffset(40)]
                public uint NumArgs;

                [FieldOffset(43)]
                public bool TypeAlias;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang26TemplateSpecializationTypeC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang26TemplateSpecializationType29anyDependentTemplateArgumentsEPKNS_19TemplateArgumentLocEjRb")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool anyDependentTemplateArguments_0(global::System.IntPtr Args, uint NumArgs, bool* InstantiationDependent);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang26TemplateSpecializationType29anyDependentTemplateArgumentsERKNS_24TemplateArgumentListInfoERb")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool anyDependentTemplateArguments_1(global::System.IntPtr _0, bool* InstantiationDependent);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang26TemplateSpecializationType25PrintTemplateArgumentListERN4llvm11raw_ostreamEPKNS_16TemplateArgumentEjRKNS_14PrintingPolicyEb")]
                internal static extern void PrintTemplateArgumentList_0(global::System.IntPtr OS, global::System.IntPtr Args, uint NumArgs, global::System.IntPtr Policy, bool SkipBrackets);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang26TemplateSpecializationType25PrintTemplateArgumentListERN4llvm11raw_ostreamEPKNS_19TemplateArgumentLocEjRKNS_14PrintingPolicyE")]
                internal static extern void PrintTemplateArgumentList_1(global::System.IntPtr OS, global::System.IntPtr Args, uint NumArgs, global::System.IntPtr Policy);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang26TemplateSpecializationType25PrintTemplateArgumentListERN4llvm11raw_ostreamERKNS_24TemplateArgumentListInfoERKNS_14PrintingPolicyE")]
                internal static extern void PrintTemplateArgumentList_2(global::System.IntPtr OS, global::System.IntPtr _0, global::System.IntPtr Policy);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang26TemplateSpecializationType22isCurrentInstantiationEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isCurrentInstantiation_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang26TemplateSpecializationType11isTypeAliasEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isTypeAlias_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang26TemplateSpecializationType14getAliasedTypeEv")]
                internal static extern clang.QualType.Internal getAliasedType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang26TemplateSpecializationType5beginEv")]
                internal static extern global::System.IntPtr begin_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang26TemplateSpecializationType3endEv")]
                internal static extern global::System.IntPtr end_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang26TemplateSpecializationType15getTemplateNameEv")]
                internal static extern clang.TemplateName.Internal getTemplateName_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang26TemplateSpecializationType7getArgsEv")]
                internal static extern global::System.IntPtr getArgs_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang26TemplateSpecializationType10getNumArgsEv")]
                internal static extern uint getNumArgs_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang26TemplateSpecializationType6getArgEj")]
                internal static extern global::System.IntPtr getArg_0(global::System.IntPtr instance, uint Idx);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang26TemplateSpecializationType9isSugaredEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isSugared_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang26TemplateSpecializationType7desugarEv")]
                internal static extern clang.QualType.Internal desugar_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang26TemplateSpecializationType7ProfileERN4llvm16FoldingSetNodeIDERKNS_10ASTContextE")]
                internal static extern void Profile_0(global::System.IntPtr instance, global::System.IntPtr ID, global::System.IntPtr Ctx);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang26TemplateSpecializationType7ProfileERN4llvm16FoldingSetNodeIDENS_12TemplateNameEPKNS_16TemplateArgumentEjRKNS_10ASTContextE")]
                internal static extern void Profile_1(global::System.IntPtr ID, clang.TemplateName.Internal T, global::System.IntPtr Args, uint NumArgs, global::System.IntPtr Context);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang26TemplateSpecializationType7classofEPKNS_4TypeE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);
            }

            public class iterator { }

            private readonly bool __ownsNativeInstance;

            public static new TemplateSpecializationType __CreateInstance(global::System.IntPtr native)
            {
                return new TemplateSpecializationType((TemplateSpecializationType.Internal*) native);
            }

            public static TemplateSpecializationType __CreateInstance(TemplateSpecializationType.Internal native)
            {
                return new TemplateSpecializationType(native);
            }

            private static TemplateSpecializationType.Internal* __CopyValue(TemplateSpecializationType.Internal native)
            {
                var ret = (TemplateSpecializationType.Internal*) Marshal.AllocHGlobal(48);
                *ret = native;
                return ret;
            }

            private TemplateSpecializationType(TemplateSpecializationType.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected TemplateSpecializationType(TemplateSpecializationType.Internal* native, bool isInternalImpl = false)
                : base((clang.Type.Internal*) native)
            {
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.ExtQualsTypeCommonBase __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            /// <summary>
            /// <para>True if this template specialization type matches a current
            /// instantiation in the context in which it is found.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// True if this template specialization type matches a
            /// current</para>
            /// <para>  /// instantiation in the context in which it is found.</para>
            /// </remarks>
            public bool isCurrentInstantiation()
            {
                var __ret = Internal.isCurrentInstantiation_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determine if this template specialization type is for a type
            /// alias template that has been substituted.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine if this template specialization type is for
            /// a type alias</para>
            /// <para>  /// template that has been substituted.</para>
            /// <para>  ///</para>
            /// <para>  /// Nearly every template specialization type whose template is
            /// an alias</para>
            /// <para>  /// template will be substituted. However, this is not the case
            /// when</para>
            /// <para>  /// the specialization contains a pack expansion but the
            /// template alias</para>
            /// <para>  /// does not have a corresponding parameter pack, e.g.,</para>
            /// <para>  ///</para>
            /// <para>  /// \code</para>
            /// <para>  /// template&lt;typename T, typename U, typename V&gt; struct
            /// S;</para>
            /// <para>  /// template&lt;typename T, typename U&gt; using A = S&lt;T,
            /// int, U&gt;;</para>
            /// <para>  /// template&lt;typename... Ts&gt; struct X {</para>
            /// <para>  ///   typedef A&lt;Ts...&gt; type; // not a type alias</para>
            /// <para>  /// };</para>
            /// <para>  /// \endcode</para>
            /// </remarks>
            public bool isTypeAlias()
            {
                var __ret = Internal.isTypeAlias_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Get the aliased type, if this is a specialization of a type alias
            /// template.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Get the aliased type, if this is a specialization of a type
            /// alias</para>
            /// <para>  /// template.</para>
            /// </remarks>
            public clang.QualType getAliasedType()
            {
                var __ret = Internal.getAliasedType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            public clang.TemplateArgument begin()
            {
                var __ret = Internal.begin_0(__Instance);
                clang.TemplateArgument __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.TemplateArgument.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.TemplateArgument) clang.TemplateArgument.NativeToManagedMap[__ret];
                else __result0 = clang.TemplateArgument.__CreateInstance(__ret);
                return __result0;
            }

            public clang.TemplateArgument end()
            {
                var __ret = Internal.end_0(__Instance);
                clang.TemplateArgument __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.TemplateArgument.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.TemplateArgument) clang.TemplateArgument.NativeToManagedMap[__ret];
                else __result0 = clang.TemplateArgument.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Retrieve the name of the template that we are
            /// specializing.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the name of the template that we are
            /// specializing.</para>
            /// </remarks>
            public clang.TemplateName getTemplateName()
            {
                var __ret = Internal.getTemplateName_0(__Instance);
                return clang.TemplateName.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Retrieve the template arguments.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the template arguments.</para>
            /// </remarks>
            public clang.TemplateArgument getArgs()
            {
                var __ret = Internal.getArgs_0(__Instance);
                clang.TemplateArgument __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.TemplateArgument.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.TemplateArgument) clang.TemplateArgument.NativeToManagedMap[__ret];
                else __result0 = clang.TemplateArgument.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Retrieve the number of template arguments.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the number of template arguments.</para>
            /// </remarks>
            public uint getNumArgs()
            {
                var __ret = Internal.getNumArgs_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Retrieve a specific template argument as a type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve a specific template argument as a
            /// type.</para>
            /// <para>  /// \pre @c isArgType(Arg)</para>
            /// </remarks>
            public clang.TemplateArgument getArg(uint Idx)
            {
                var __ret = Internal.getArg_0(__Instance, Idx);
                clang.TemplateArgument __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.TemplateArgument.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.TemplateArgument) clang.TemplateArgument.NativeToManagedMap[__ret];
                else __result0 = clang.TemplateArgument.__CreateInstance(__ret);
                return __result0;
            }

            public bool isSugared()
            {
                var __ret = Internal.isSugared_0(__Instance);
                return __ret;
            }

            public clang.QualType desugar()
            {
                var __ret = Internal.desugar_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            public void Profile(llvm.FoldingSetNodeID ID, clang.ASTContext Ctx)
            {
                var arg0 = ReferenceEquals(ID, null) ? global::System.IntPtr.Zero : ID.__Instance;
                var arg1 = ReferenceEquals(Ctx, null) ? global::System.IntPtr.Zero : Ctx.__Instance;
                Internal.Profile_0(__Instance, arg0, arg1);
            }

            /// <summary>
            /// <para>Determine whether any of the given template arguments are
            /// dependent.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine whether any of the given template arguments
            /// are</para>
            /// <para>  /// dependent.</para>
            /// </remarks>
            public static bool anyDependentTemplateArguments(clang.TemplateArgumentLoc Args, uint NumArgs, ref bool InstantiationDependent)
            {
                var arg0 = ReferenceEquals(Args, null) ? global::System.IntPtr.Zero : Args.__Instance;
                fixed (bool* arg2 = &InstantiationDependent)
                {
                    var __ret = Internal.anyDependentTemplateArguments_0(arg0, NumArgs, arg2);
                    return __ret;
                }
            }

            public static bool anyDependentTemplateArguments(clang.TemplateArgumentListInfo _0, ref bool InstantiationDependent)
            {
                var arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
                fixed (bool* arg1 = &InstantiationDependent)
                {
                    var __ret = Internal.anyDependentTemplateArguments_1(arg0, arg1);
                    return __ret;
                }
            }

            /// <summary>
            /// <para>Print a template argument list, including the '&lt;' and '&gt;'
            /// enclosing the template arguments.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Print a template argument list, including the '&lt;'
            /// and '&gt;'</para>
            /// <para>  /// enclosing the template arguments.</para>
            /// </remarks>
            public static void PrintTemplateArgumentList(llvm.raw_ostream OS, clang.TemplateArgument Args, uint NumArgs, clang.PrintingPolicy Policy, bool SkipBrackets)
            {
                var arg0 = ReferenceEquals(OS, null) ? global::System.IntPtr.Zero : OS.__Instance;
                var arg1 = ReferenceEquals(Args, null) ? global::System.IntPtr.Zero : Args.__Instance;
                var arg3 = ReferenceEquals(Policy, null) ? global::System.IntPtr.Zero : Policy.__Instance;
                Internal.PrintTemplateArgumentList_0(arg0, arg1, NumArgs, arg3, SkipBrackets);
            }

            public static void PrintTemplateArgumentList(llvm.raw_ostream OS, clang.TemplateArgumentLoc Args, uint NumArgs, clang.PrintingPolicy Policy)
            {
                var arg0 = ReferenceEquals(OS, null) ? global::System.IntPtr.Zero : OS.__Instance;
                var arg1 = ReferenceEquals(Args, null) ? global::System.IntPtr.Zero : Args.__Instance;
                var arg3 = ReferenceEquals(Policy, null) ? global::System.IntPtr.Zero : Policy.__Instance;
                Internal.PrintTemplateArgumentList_1(arg0, arg1, NumArgs, arg3);
            }

            public static void PrintTemplateArgumentList(llvm.raw_ostream OS, clang.TemplateArgumentListInfo _0, clang.PrintingPolicy Policy)
            {
                var arg0 = ReferenceEquals(OS, null) ? global::System.IntPtr.Zero : OS.__Instance;
                var arg1 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
                var arg2 = ReferenceEquals(Policy, null) ? global::System.IntPtr.Zero : Policy.__Instance;
                Internal.PrintTemplateArgumentList_2(arg0, arg1, arg2);
            }

            public static void Profile(llvm.FoldingSetNodeID ID, clang.TemplateName T, clang.TemplateArgument Args, uint NumArgs, clang.ASTContext Context)
            {
                var arg0 = ReferenceEquals(ID, null) ? global::System.IntPtr.Zero : ID.__Instance;
                var arg1 = ReferenceEquals(T, null) ? new clang.TemplateName.Internal() : *(clang.TemplateName.Internal*) (T.__Instance);
                var arg2 = ReferenceEquals(Args, null) ? global::System.IntPtr.Zero : Args.__Instance;
                var arg4 = ReferenceEquals(Context, null) ? global::System.IntPtr.Zero : Context.__Instance;
                Internal.Profile_1(arg0, arg1, arg2, NumArgs, arg4);
            }

            public static bool classof(clang.Type T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>The injected class name of a C++ class template or class template
        /// partial specialization. Used to record that a type was spelled with a bare
        /// identifier rather than as a template-id; the equivalent for non-templated
        /// classes is just RecordType.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief The injected class name of a C++ class template or
        /// class</para>
        /// <para>/// template partial specialization.  Used to record that a type
        /// was</para>
        /// <para>/// spelled with a bare identifier rather than as a template-id;
        /// the</para>
        /// <para>/// equivalent for non-templated classes is just
        /// RecordType.</para>
        /// <para>///</para>
        /// <para>/// Injected class name types are always dependent.
        /// Template</para>
        /// <para>/// instantiation turns these into RecordTypes.</para>
        /// <para>///</para>
        /// <para>/// Injected class name types are always canonical.  This
        /// works</para>
        /// <para>/// because it is impossible to compare an injected class name
        /// type</para>
        /// <para>/// with the corresponding non-injected template type, for the
        /// same</para>
        /// <para>/// reason that it is impossible to directly compare
        /// template</para>
        /// <para>/// parameters from different dependent contexts: injected class
        /// name</para>
        /// <para>/// types can only occur within the scope of a particular
        /// templated</para>
        /// <para>/// declaration, and within that scope every template
        /// specialization</para>
        /// <para>/// will canonicalize to the injected class name (when
        /// appropriate</para>
        /// <para>/// according to the rules of the language).</para>
        /// </remarks>
        public unsafe partial class InjectedClassNameType : clang.Type, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 40)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr BaseType;

                [FieldOffset(8)]
                public clang.QualType.Internal CanonicalType;

                [FieldOffset(16)]
                internal clang.Type._.Internal __;

                [FieldOffset(24)]
                public global::System.IntPtr Decl;

                [FieldOffset(32)]
                public clang.QualType.Internal InjectedType;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang21InjectedClassNameTypeC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang21InjectedClassNameType29getInjectedSpecializationTypeEv")]
                internal static extern clang.QualType.Internal getInjectedSpecializationType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang21InjectedClassNameType14getInjectedTSTEv")]
                internal static extern global::System.IntPtr getInjectedTST_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang21InjectedClassNameType9isSugaredEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isSugared_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang21InjectedClassNameType7desugarEv")]
                internal static extern clang.QualType.Internal desugar_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang21InjectedClassNameType7classofEPKNS_4TypeE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);
            }

            private readonly bool __ownsNativeInstance;

            public static new InjectedClassNameType __CreateInstance(global::System.IntPtr native)
            {
                return new InjectedClassNameType((InjectedClassNameType.Internal*) native);
            }

            public static InjectedClassNameType __CreateInstance(InjectedClassNameType.Internal native)
            {
                return new InjectedClassNameType(native);
            }

            private static InjectedClassNameType.Internal* __CopyValue(InjectedClassNameType.Internal native)
            {
                var ret = (InjectedClassNameType.Internal*) Marshal.AllocHGlobal(40);
                *ret = native;
                return ret;
            }

            private InjectedClassNameType(InjectedClassNameType.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected InjectedClassNameType(InjectedClassNameType.Internal* native, bool isInternalImpl = false)
                : base((clang.Type.Internal*) native)
            {
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.ExtQualsTypeCommonBase __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.QualType getInjectedSpecializationType()
            {
                var __ret = Internal.getInjectedSpecializationType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            public clang.TemplateSpecializationType getInjectedTST()
            {
                var __ret = Internal.getInjectedTST_0(__Instance);
                clang.TemplateSpecializationType __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.TemplateSpecializationType.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.TemplateSpecializationType) clang.TemplateSpecializationType.NativeToManagedMap[__ret];
                else __result0 = clang.TemplateSpecializationType.__CreateInstance(__ret);
                return __result0;
            }

            public bool isSugared()
            {
                var __ret = Internal.isSugared_0(__Instance);
                return __ret;
            }

            public clang.QualType desugar()
            {
                var __ret = Internal.desugar_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            public static bool classof(clang.Type T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>A helper class for Type nodes having an ElaboratedTypeKeyword.
        /// The keyword in stored in the free bits of the base class. Also provides a
        /// few static helpers for converting and printing elaborated type keyword and
        /// tag type kind enumerations.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// A helper class for Type nodes having an
        /// ElaboratedTypeKeyword.</para>
        /// <para>/// The keyword in stored in the free bits of the base
        /// class.</para>
        /// <para>/// Also provides a few static helpers for converting and
        /// printing</para>
        /// <para>/// elaborated type keyword and tag type kind
        /// enumerations.</para>
        /// </remarks>
        public unsafe partial class TypeWithKeyword : clang.Type, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 24)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr BaseType;

                [FieldOffset(8)]
                public clang.QualType.Internal CanonicalType;

                [FieldOffset(16)]
                internal clang.Type._.Internal __;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang15TypeWithKeywordC2ENS_21ElaboratedTypeKeywordENS_4Type9TypeClassENS_8QualTypeEbbbb")]
                internal static extern void ctor_0(global::System.IntPtr instance, clang.ElaboratedTypeKeyword Keyword, clang.Type.TypeClass tc, clang.QualType.Internal Canonical, bool Dependent, bool InstantiationDependent, bool VariablyModified, bool ContainsUnexpandedParameterPack);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang15TypeWithKeywordC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang15TypeWithKeyword10getKeywordEv")]
                internal static extern clang.ElaboratedTypeKeyword getKeyword_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang15TypeWithKeyword21getKeywordForTypeSpecEj")]
                internal static extern clang.ElaboratedTypeKeyword getKeywordForTypeSpec_0(uint TypeSpec);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang15TypeWithKeyword25getTagTypeKindForTypeSpecEj")]
                internal static extern clang.TagTypeKind getTagTypeKindForTypeSpec_0(uint TypeSpec);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang15TypeWithKeyword24getKeywordForTagTypeKindENS_11TagTypeKindE")]
                internal static extern clang.ElaboratedTypeKeyword getKeywordForTagTypeKind_0(clang.TagTypeKind Tag);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang15TypeWithKeyword24getTagTypeKindForKeywordENS_21ElaboratedTypeKeywordE")]
                internal static extern clang.TagTypeKind getTagTypeKindForKeyword_0(clang.ElaboratedTypeKeyword Keyword);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang15TypeWithKeyword20KeywordIsTagTypeKindENS_21ElaboratedTypeKeywordE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool KeywordIsTagTypeKind_0(clang.ElaboratedTypeKeyword Keyword);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang15TypeWithKeyword14getKeywordNameENS_21ElaboratedTypeKeywordE")]
                internal static extern llvm.StringRef.Internal getKeywordName_0(clang.ElaboratedTypeKeyword Keyword);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang15TypeWithKeyword18getTagTypeKindNameENS_11TagTypeKindE")]
                internal static extern llvm.StringRef.Internal getTagTypeKindName_0(clang.TagTypeKind Kind);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang15TypeWithKeyword7classofEPKNS_4TypeE")]
                internal static extern clang.TypeWithKeyword.CannotCastToThisType.Internal classof_0(global::System.IntPtr _0);
            }

            public unsafe partial class CannotCastToThisType : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 0)]
                public partial struct Internal
                {
                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang15TypeWithKeyword20CannotCastToThisTypeC2ERKS1_")]
                    internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, CannotCastToThisType> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, CannotCastToThisType>();

                private readonly bool __ownsNativeInstance;

                public static CannotCastToThisType __CreateInstance(global::System.IntPtr native)
                {
                    return new CannotCastToThisType((CannotCastToThisType.Internal*) native);
                }

                public static CannotCastToThisType __CreateInstance(CannotCastToThisType.Internal native)
                {
                    return new CannotCastToThisType(native);
                }

                private static CannotCastToThisType.Internal* __CopyValue(CannotCastToThisType.Internal native)
                {
                    var ret = (CannotCastToThisType.Internal*) Marshal.AllocHGlobal(0);
                    *ret = native;
                    return ret;
                }

                private CannotCastToThisType(CannotCastToThisType.Internal native)
                    : this(__CopyValue(native))
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected CannotCastToThisType(CannotCastToThisType.Internal* native, bool isInternalImpl = false)
                {
                    __Instance = new global::System.IntPtr(native);
                }

                public CannotCastToThisType()
                {
                    __Instance = Marshal.AllocHGlobal(0);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    DestroyNativeInstance(false);
                }

                public virtual void DestroyNativeInstance()
                {
                    DestroyNativeInstance(true);
                }

                private void DestroyNativeInstance(bool force)
                {
                    clang.TypeWithKeyword.CannotCastToThisType __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }
            }

            private readonly bool __ownsNativeInstance;

            public static new TypeWithKeyword __CreateInstance(global::System.IntPtr native)
            {
                return new TypeWithKeyword((TypeWithKeyword.Internal*) native);
            }

            public static TypeWithKeyword __CreateInstance(TypeWithKeyword.Internal native)
            {
                return new TypeWithKeyword(native);
            }

            private static TypeWithKeyword.Internal* __CopyValue(TypeWithKeyword.Internal native)
            {
                var ret = (TypeWithKeyword.Internal*) Marshal.AllocHGlobal(24);
                *ret = native;
                return ret;
            }

            private TypeWithKeyword(TypeWithKeyword.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected TypeWithKeyword(TypeWithKeyword.Internal* native, bool isInternalImpl = false)
                : base((clang.Type.Internal*) native)
            {
            }

            protected TypeWithKeyword(clang.ElaboratedTypeKeyword Keyword, clang.Type.TypeClass tc, clang.QualType Canonical, bool Dependent, bool InstantiationDependent, bool VariablyModified, bool ContainsUnexpandedParameterPack)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(24);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = Keyword;
                var arg1 = tc;
                var arg2 = ReferenceEquals(Canonical, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (Canonical.__Instance);
                Internal.ctor_0(__Instance, arg0, arg1, arg2, Dependent, InstantiationDependent, VariablyModified, ContainsUnexpandedParameterPack);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.ExtQualsTypeCommonBase __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.ElaboratedTypeKeyword getKeyword()
            {
                var __ret = Internal.getKeyword_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>getKeywordForTypeSpec - Converts a type specifier (DeclSpec::TST)
            /// into an elaborated type keyword.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getKeywordForTypeSpec - Converts a type specifier
            /// (DeclSpec::TST)</para>
            /// <para>  /// into an elaborated type keyword.</para>
            /// </remarks>
            public static clang.ElaboratedTypeKeyword getKeywordForTypeSpec(uint TypeSpec)
            {
                var __ret = Internal.getKeywordForTypeSpec_0(TypeSpec);
                return __ret;
            }

            /// <summary>
            /// <para>getTagTypeKindForTypeSpec - Converts a type specifier
            /// (DeclSpec::TST) into a tag type kind. It is an error to provide a type
            /// specifier which *isn't* a tag kind here.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getTagTypeKindForTypeSpec - Converts a type specifier
            /// (DeclSpec::TST)</para>
            /// <para>  /// into a tag type kind.  It is an error to provide a type
            /// specifier</para>
            /// <para>  /// which *isn't* a tag kind here.</para>
            /// </remarks>
            public static clang.TagTypeKind getTagTypeKindForTypeSpec(uint TypeSpec)
            {
                var __ret = Internal.getTagTypeKindForTypeSpec_0(TypeSpec);
                return __ret;
            }

            /// <summary>
            /// <para>getKeywordForTagDeclKind - Converts a TagTypeKind into an
            /// elaborated type keyword.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getKeywordForTagDeclKind - Converts a TagTypeKind into
            /// an</para>
            /// <para>  /// elaborated type keyword.</para>
            /// </remarks>
            public static clang.ElaboratedTypeKeyword getKeywordForTagTypeKind(clang.TagTypeKind Tag)
            {
                var arg0 = Tag;
                var __ret = Internal.getKeywordForTagTypeKind_0(arg0);
                return __ret;
            }

            /// <summary>
            /// <para>which *isn't* a tag kind here.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// which *isn't* a tag kind here.</para>
            /// </remarks>
            public static clang.TagTypeKind getTagTypeKindForKeyword(clang.ElaboratedTypeKeyword Keyword)
            {
                var arg0 = Keyword;
                var __ret = Internal.getTagTypeKindForKeyword_0(arg0);
                return __ret;
            }

            public static bool KeywordIsTagTypeKind(clang.ElaboratedTypeKeyword Keyword)
            {
                var arg0 = Keyword;
                var __ret = Internal.KeywordIsTagTypeKind_0(arg0);
                return __ret;
            }

            public static llvm.StringRef getKeywordName(clang.ElaboratedTypeKeyword Keyword)
            {
                var arg0 = Keyword;
                var __ret = Internal.getKeywordName_0(arg0);
                return llvm.StringRef.__CreateInstance(__ret);
            }

            public static llvm.StringRef getTagTypeKindName(clang.TagTypeKind Kind)
            {
                var arg0 = Kind;
                var __ret = Internal.getTagTypeKindName_0(arg0);
                return llvm.StringRef.__CreateInstance(__ret);
            }

            public static clang.TypeWithKeyword.CannotCastToThisType classof(clang.Type _0)
            {
                var arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
                var __ret = Internal.classof_0(arg0);
                return clang.TypeWithKeyword.CannotCastToThisType.__CreateInstance(__ret);
            }
        }

        /// <summary>
        /// <para>Represents a type that was referred to using an elaborated type
        /// keyword, e.g., struct S, or via a qualified name, e.g., N::M::type, or
        /// both.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief Represents a type that was referred to using an
        /// elaborated type</para>
        /// <para>/// keyword, e.g., struct S, or via a qualified name, e.g.,
        /// N::M::type,</para>
        /// <para>/// or both.</para>
        /// <para>///</para>
        /// <para>/// This type is used to keep track of a type name as written in
        /// the</para>
        /// <para>/// source code, including tag keywords and any
        /// nested-name-specifiers.</para>
        /// <para>/// The type itself is always &quot;sugar&quot;, used to express
        /// what was written</para>
        /// <para>/// in the source code but containing no additional semantic
        /// information.</para>
        /// </remarks>
        public unsafe partial class ElaboratedType : clang.TypeWithKeyword, llvm.FoldingSetImpl.Node, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 48)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr BaseType;

                [FieldOffset(8)]
                public clang.QualType.Internal CanonicalType;

                [FieldOffset(16)]
                internal clang.Type._.Internal __;

                [FieldOffset(0)]
                public global::System.IntPtr NextInFoldingSetBucket;

                [FieldOffset(32)]
                public global::System.IntPtr NNS;

                [FieldOffset(40)]
                public clang.QualType.Internal NamedType;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14ElaboratedTypeC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14ElaboratedTypeD2Ev")]
                internal static extern void dtor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14ElaboratedType12getQualifierEv")]
                internal static extern global::System.IntPtr getQualifier_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14ElaboratedType12getNamedTypeEv")]
                internal static extern clang.QualType.Internal getNamedType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14ElaboratedType7desugarEv")]
                internal static extern clang.QualType.Internal desugar_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14ElaboratedType9isSugaredEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isSugared_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14ElaboratedType7ProfileERN4llvm16FoldingSetNodeIDE")]
                internal static extern void Profile_0(global::System.IntPtr instance, global::System.IntPtr ID);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14ElaboratedType7ProfileERN4llvm16FoldingSetNodeIDENS_21ElaboratedTypeKeywordEPNS_19NestedNameSpecifierENS_8QualTypeE")]
                internal static extern void Profile_1(global::System.IntPtr ID, clang.ElaboratedTypeKeyword Keyword, global::System.IntPtr NNS, clang.QualType.Internal NamedType);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14ElaboratedType7classofEPKNS_4TypeE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);
            }

            private readonly bool __ownsNativeInstance;

            public static new ElaboratedType __CreateInstance(global::System.IntPtr native)
            {
                return new ElaboratedType((ElaboratedType.Internal*) native);
            }

            public static ElaboratedType __CreateInstance(ElaboratedType.Internal native)
            {
                return new ElaboratedType(native);
            }

            private static ElaboratedType.Internal* __CopyValue(ElaboratedType.Internal native)
            {
                var ret = (ElaboratedType.Internal*) Marshal.AllocHGlobal(48);
                *ret = native;
                return ret;
            }

            private ElaboratedType(ElaboratedType.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected ElaboratedType(ElaboratedType.Internal* native, bool isInternalImpl = false)
                : base((clang.TypeWithKeyword.Internal*) native)
            {
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.ExtQualsTypeCommonBase __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            /// <summary>
            /// <para>Retrieve the qualification on this type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the qualification on this type.</para>
            /// </remarks>
            public clang.NestedNameSpecifier getQualifier()
            {
                var __ret = Internal.getQualifier_0(__Instance);
                clang.NestedNameSpecifier __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.NestedNameSpecifier.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.NestedNameSpecifier) clang.NestedNameSpecifier.NativeToManagedMap[__ret];
                else __result0 = clang.NestedNameSpecifier.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Retrieve the type named by the qualified-id.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the type named by the qualified-id.</para>
            /// </remarks>
            public clang.QualType getNamedType()
            {
                var __ret = Internal.getNamedType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Remove a single level of sugar.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Remove a single level of sugar.</para>
            /// </remarks>
            public clang.QualType desugar()
            {
                var __ret = Internal.desugar_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Returns whether this type directly provides sugar.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Returns whether this type directly provides
            /// sugar.</para>
            /// </remarks>
            public bool isSugared()
            {
                var __ret = Internal.isSugared_0(__Instance);
                return __ret;
            }

            public void Profile(llvm.FoldingSetNodeID ID)
            {
                var arg0 = ReferenceEquals(ID, null) ? global::System.IntPtr.Zero : ID.__Instance;
                Internal.Profile_0(__Instance, arg0);
            }

            public static void Profile(llvm.FoldingSetNodeID ID, clang.ElaboratedTypeKeyword Keyword, clang.NestedNameSpecifier NNS, clang.QualType NamedType)
            {
                var arg0 = ReferenceEquals(ID, null) ? global::System.IntPtr.Zero : ID.__Instance;
                var arg1 = Keyword;
                var arg2 = ReferenceEquals(NNS, null) ? global::System.IntPtr.Zero : NNS.__Instance;
                var arg3 = ReferenceEquals(NamedType, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (NamedType.__Instance);
                Internal.Profile_1(arg0, arg1, arg2, arg3);
            }

            public static bool classof(clang.Type T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Represents a qualified type name for which the type name is
        /// dependent.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief Represents a qualified type name for which the type
        /// name is</para>
        /// <para>/// dependent.</para>
        /// <para>///</para>
        /// <para>/// DependentNameType represents a class of dependent types that
        /// involve a</para>
        /// <para>/// possibly dependent nested-name-specifier (e.g.,
        /// &quot;T::&quot;) followed by a</para>
        /// <para>/// name of a type. The DependentNameType may start with a
        /// &quot;typename&quot; (for a</para>
        /// <para>/// typename-specifier), &quot;class&quot;, &quot;struct&quot;,
        /// &quot;union&quot;, or &quot;enum&quot; (for a</para>
        /// <para>/// dependent elaborated-type-specifier), or nothing (in contexts
        /// where we</para>
        /// <para>/// know that we must be referring to a type, e.g., in a base
        /// class specifier).</para>
        /// <para>/// Typically the nested-name-specifier is dependent, but in MSVC
        /// compatibility</para>
        /// <para>/// mode, this type is used with non-dependent names to delay
        /// name lookup until</para>
        /// <para>/// instantiation.</para>
        /// </remarks>
        public unsafe partial class DependentNameType : clang.TypeWithKeyword, llvm.FoldingSetImpl.Node, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 48)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr BaseType;

                [FieldOffset(8)]
                public clang.QualType.Internal CanonicalType;

                [FieldOffset(16)]
                internal clang.Type._.Internal __;

                [FieldOffset(0)]
                public global::System.IntPtr NextInFoldingSetBucket;

                [FieldOffset(32)]
                public global::System.IntPtr NNS;

                [FieldOffset(40)]
                public global::System.IntPtr Name;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17DependentNameTypeC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17DependentNameType12getQualifierEv")]
                internal static extern global::System.IntPtr getQualifier_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17DependentNameType13getIdentifierEv")]
                internal static extern global::System.IntPtr getIdentifier_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17DependentNameType9isSugaredEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isSugared_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17DependentNameType7desugarEv")]
                internal static extern clang.QualType.Internal desugar_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17DependentNameType7ProfileERN4llvm16FoldingSetNodeIDE")]
                internal static extern void Profile_0(global::System.IntPtr instance, global::System.IntPtr ID);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17DependentNameType7ProfileERN4llvm16FoldingSetNodeIDENS_21ElaboratedTypeKeywordEPNS_19NestedNameSpecifierEPKNS_14IdentifierInfoE")]
                internal static extern void Profile_1(global::System.IntPtr ID, clang.ElaboratedTypeKeyword Keyword, global::System.IntPtr NNS, global::System.IntPtr Name);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17DependentNameType7classofEPKNS_4TypeE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);
            }

            private readonly bool __ownsNativeInstance;

            public static new DependentNameType __CreateInstance(global::System.IntPtr native)
            {
                return new DependentNameType((DependentNameType.Internal*) native);
            }

            public static DependentNameType __CreateInstance(DependentNameType.Internal native)
            {
                return new DependentNameType(native);
            }

            private static DependentNameType.Internal* __CopyValue(DependentNameType.Internal native)
            {
                var ret = (DependentNameType.Internal*) Marshal.AllocHGlobal(48);
                *ret = native;
                return ret;
            }

            private DependentNameType(DependentNameType.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected DependentNameType(DependentNameType.Internal* native, bool isInternalImpl = false)
                : base((clang.TypeWithKeyword.Internal*) native)
            {
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.ExtQualsTypeCommonBase __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            /// <summary>
            /// <para>Retrieve the qualification on this type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the qualification on this type.</para>
            /// </remarks>
            public clang.NestedNameSpecifier getQualifier()
            {
                var __ret = Internal.getQualifier_0(__Instance);
                clang.NestedNameSpecifier __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.NestedNameSpecifier.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.NestedNameSpecifier) clang.NestedNameSpecifier.NativeToManagedMap[__ret];
                else __result0 = clang.NestedNameSpecifier.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Retrieve the type named by the typename specifier as an
            /// identifier.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the type named by the typename specifier as
            /// an</para>
            /// <para>  /// identifier.</para>
            /// <para>  ///</para>
            /// <para>  /// This routine will return a non-NULL identifier pointer when
            /// the</para>
            /// <para>  /// form of the original typename was terminated by an
            /// identifier,</para>
            /// <para>  /// e.g., &quot;typename T::type&quot;.</para>
            /// </remarks>
            public clang.IdentifierInfo getIdentifier()
            {
                var __ret = Internal.getIdentifier_0(__Instance);
                clang.IdentifierInfo __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.IdentifierInfo.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.IdentifierInfo) clang.IdentifierInfo.NativeToManagedMap[__ret];
                else __result0 = clang.IdentifierInfo.__CreateInstance(__ret);
                return __result0;
            }

            public bool isSugared()
            {
                var __ret = Internal.isSugared_0(__Instance);
                return __ret;
            }

            public clang.QualType desugar()
            {
                var __ret = Internal.desugar_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            public void Profile(llvm.FoldingSetNodeID ID)
            {
                var arg0 = ReferenceEquals(ID, null) ? global::System.IntPtr.Zero : ID.__Instance;
                Internal.Profile_0(__Instance, arg0);
            }

            public static void Profile(llvm.FoldingSetNodeID ID, clang.ElaboratedTypeKeyword Keyword, clang.NestedNameSpecifier NNS, clang.IdentifierInfo Name)
            {
                var arg0 = ReferenceEquals(ID, null) ? global::System.IntPtr.Zero : ID.__Instance;
                var arg1 = Keyword;
                var arg2 = ReferenceEquals(NNS, null) ? global::System.IntPtr.Zero : NNS.__Instance;
                var arg3 = ReferenceEquals(Name, null) ? global::System.IntPtr.Zero : Name.__Instance;
                Internal.Profile_1(arg0, arg1, arg2, arg3);
            }

            public static bool classof(clang.Type T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>DependentTemplateSpecializationType - Represents a template
        /// specialization type whose template cannot be resolved, e.g.
        /// A&lt;T&gt;::template B&lt;T&gt;</para>
        /// </summary>
        /// <remarks>
        /// <para>/// DependentTemplateSpecializationType - Represents a
        /// template</para>
        /// <para>/// specialization type whose template cannot be resolved,
        /// e.g.</para>
        /// <para>///   A&lt;T&gt;::template B&lt;T&gt;</para>
        /// </remarks>
        public unsafe partial class DependentTemplateSpecializationType : clang.TypeWithKeyword, llvm.FoldingSetImpl.Node, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 56)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr BaseType;

                [FieldOffset(8)]
                public clang.QualType.Internal CanonicalType;

                [FieldOffset(16)]
                internal clang.Type._.Internal __;

                [FieldOffset(0)]
                public global::System.IntPtr NextInFoldingSetBucket;

                [FieldOffset(32)]
                public global::System.IntPtr NNS;

                [FieldOffset(40)]
                public global::System.IntPtr Name;

                [FieldOffset(48)]
                public uint NumArgs;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang35DependentTemplateSpecializationTypeC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang35DependentTemplateSpecializationType12getQualifierEv")]
                internal static extern global::System.IntPtr getQualifier_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang35DependentTemplateSpecializationType13getIdentifierEv")]
                internal static extern global::System.IntPtr getIdentifier_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang35DependentTemplateSpecializationType7getArgsEv")]
                internal static extern global::System.IntPtr getArgs_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang35DependentTemplateSpecializationType10getNumArgsEv")]
                internal static extern uint getNumArgs_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang35DependentTemplateSpecializationType6getArgEj")]
                internal static extern global::System.IntPtr getArg_0(global::System.IntPtr instance, uint Idx);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang35DependentTemplateSpecializationType5beginEv")]
                internal static extern global::System.IntPtr begin_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang35DependentTemplateSpecializationType3endEv")]
                internal static extern global::System.IntPtr end_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang35DependentTemplateSpecializationType9isSugaredEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isSugared_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang35DependentTemplateSpecializationType7desugarEv")]
                internal static extern clang.QualType.Internal desugar_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang35DependentTemplateSpecializationType7ProfileERN4llvm16FoldingSetNodeIDERKNS_10ASTContextE")]
                internal static extern void Profile_0(global::System.IntPtr instance, global::System.IntPtr ID, global::System.IntPtr Context);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang35DependentTemplateSpecializationType7ProfileERN4llvm16FoldingSetNodeIDERKNS_10ASTContextENS_21ElaboratedTypeKeywordEPNS_19NestedNameSpecifierEPKNS_14IdentifierInfoEjPKNS_16TemplateArgumentE")]
                internal static extern void Profile_1(global::System.IntPtr ID, global::System.IntPtr Context, clang.ElaboratedTypeKeyword Keyword, global::System.IntPtr Qualifier, global::System.IntPtr Name, uint NumArgs, global::System.IntPtr Args);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang35DependentTemplateSpecializationType7classofEPKNS_4TypeE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);
            }

            public class iterator { }

            private readonly bool __ownsNativeInstance;

            public static new DependentTemplateSpecializationType __CreateInstance(global::System.IntPtr native)
            {
                return new DependentTemplateSpecializationType((DependentTemplateSpecializationType.Internal*) native);
            }

            public static DependentTemplateSpecializationType __CreateInstance(DependentTemplateSpecializationType.Internal native)
            {
                return new DependentTemplateSpecializationType(native);
            }

            private static DependentTemplateSpecializationType.Internal* __CopyValue(DependentTemplateSpecializationType.Internal native)
            {
                var ret = (DependentTemplateSpecializationType.Internal*) Marshal.AllocHGlobal(56);
                *ret = native;
                return ret;
            }

            private DependentTemplateSpecializationType(DependentTemplateSpecializationType.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected DependentTemplateSpecializationType(DependentTemplateSpecializationType.Internal* native, bool isInternalImpl = false)
                : base((clang.TypeWithKeyword.Internal*) native)
            {
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.ExtQualsTypeCommonBase __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.NestedNameSpecifier getQualifier()
            {
                var __ret = Internal.getQualifier_0(__Instance);
                clang.NestedNameSpecifier __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.NestedNameSpecifier.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.NestedNameSpecifier) clang.NestedNameSpecifier.NativeToManagedMap[__ret];
                else __result0 = clang.NestedNameSpecifier.__CreateInstance(__ret);
                return __result0;
            }

            public clang.IdentifierInfo getIdentifier()
            {
                var __ret = Internal.getIdentifier_0(__Instance);
                clang.IdentifierInfo __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.IdentifierInfo.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.IdentifierInfo) clang.IdentifierInfo.NativeToManagedMap[__ret];
                else __result0 = clang.IdentifierInfo.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Retrieve the template arguments.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the template arguments.</para>
            /// </remarks>
            public clang.TemplateArgument getArgs()
            {
                var __ret = Internal.getArgs_0(__Instance);
                clang.TemplateArgument __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.TemplateArgument.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.TemplateArgument) clang.TemplateArgument.NativeToManagedMap[__ret];
                else __result0 = clang.TemplateArgument.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Retrieve the number of template arguments.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the number of template arguments.</para>
            /// </remarks>
            public uint getNumArgs()
            {
                var __ret = Internal.getNumArgs_0(__Instance);
                return __ret;
            }

            public clang.TemplateArgument getArg(uint Idx)
            {
                var __ret = Internal.getArg_0(__Instance, Idx);
                clang.TemplateArgument __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.TemplateArgument.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.TemplateArgument) clang.TemplateArgument.NativeToManagedMap[__ret];
                else __result0 = clang.TemplateArgument.__CreateInstance(__ret);
                return __result0;
            }

            public clang.TemplateArgument begin()
            {
                var __ret = Internal.begin_0(__Instance);
                clang.TemplateArgument __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.TemplateArgument.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.TemplateArgument) clang.TemplateArgument.NativeToManagedMap[__ret];
                else __result0 = clang.TemplateArgument.__CreateInstance(__ret);
                return __result0;
            }

            public clang.TemplateArgument end()
            {
                var __ret = Internal.end_0(__Instance);
                clang.TemplateArgument __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.TemplateArgument.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.TemplateArgument) clang.TemplateArgument.NativeToManagedMap[__ret];
                else __result0 = clang.TemplateArgument.__CreateInstance(__ret);
                return __result0;
            }

            public bool isSugared()
            {
                var __ret = Internal.isSugared_0(__Instance);
                return __ret;
            }

            public clang.QualType desugar()
            {
                var __ret = Internal.desugar_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            public void Profile(llvm.FoldingSetNodeID ID, clang.ASTContext Context)
            {
                var arg0 = ReferenceEquals(ID, null) ? global::System.IntPtr.Zero : ID.__Instance;
                var arg1 = ReferenceEquals(Context, null) ? global::System.IntPtr.Zero : Context.__Instance;
                Internal.Profile_0(__Instance, arg0, arg1);
            }

            public static void Profile(llvm.FoldingSetNodeID ID, clang.ASTContext Context, clang.ElaboratedTypeKeyword Keyword, clang.NestedNameSpecifier Qualifier, clang.IdentifierInfo Name, uint NumArgs, clang.TemplateArgument Args)
            {
                var arg0 = ReferenceEquals(ID, null) ? global::System.IntPtr.Zero : ID.__Instance;
                var arg1 = ReferenceEquals(Context, null) ? global::System.IntPtr.Zero : Context.__Instance;
                var arg2 = Keyword;
                var arg3 = ReferenceEquals(Qualifier, null) ? global::System.IntPtr.Zero : Qualifier.__Instance;
                var arg4 = ReferenceEquals(Name, null) ? global::System.IntPtr.Zero : Name.__Instance;
                var arg6 = ReferenceEquals(Args, null) ? global::System.IntPtr.Zero : Args.__Instance;
                Internal.Profile_1(arg0, arg1, arg2, arg3, arg4, NumArgs, arg6);
            }

            public static bool classof(clang.Type T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Represents a pack expansion of types.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief Represents a pack expansion of types.</para>
        /// <para>///</para>
        /// <para>/// Pack expansions are part of C++0x variadic templates. A
        /// pack</para>
        /// <para>/// expansion contains a pattern, which itself contains one or
        /// more</para>
        /// <para>/// &quot;unexpanded&quot; parameter packs. When instantiated, a
        /// pack expansion</para>
        /// <para>/// produces a series of types, each instantiated from the
        /// pattern of</para>
        /// <para>/// the expansion, where the Ith instantiation of the pattern
        /// uses the</para>
        /// <para>/// Ith arguments bound to each of the unexpanded parameter
        /// packs. The</para>
        /// <para>/// pack expansion is considered to &quot;expand&quot; these
        /// unexpanded</para>
        /// <para>/// parameter packs.</para>
        /// <para>///</para>
        /// <para>/// \code</para>
        /// <para>/// template&lt;typename ...Types&gt; struct tuple;</para>
        /// <para>///</para>
        /// <para>/// template&lt;typename ...Types&gt;</para>
        /// <para>/// struct tuple_of_references {</para>
        /// <para>///   typedef tuple&lt;Types&amp;...&gt; type;</para>
        /// <para>/// };</para>
        /// <para>/// \endcode</para>
        /// <para>///</para>
        /// <para>/// Here, the pack expansion \c Types&amp;... is represented via
        /// a</para>
        /// <para>/// PackExpansionType whose pattern is Types&amp;.</para>
        /// </remarks>
        public unsafe partial class PackExpansionType : clang.Type, llvm.FoldingSetImpl.Node, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 48)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr BaseType;

                [FieldOffset(8)]
                public clang.QualType.Internal CanonicalType;

                [FieldOffset(16)]
                internal clang.Type._.Internal __;

                [FieldOffset(0)]
                public global::System.IntPtr NextInFoldingSetBucket;

                [FieldOffset(32)]
                public clang.QualType.Internal Pattern;

                [FieldOffset(40)]
                public uint NumExpansions;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17PackExpansionTypeC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17PackExpansionType10getPatternEv")]
                internal static extern clang.QualType.Internal getPattern_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17PackExpansionType9isSugaredEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isSugared_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17PackExpansionType7desugarEv")]
                internal static extern clang.QualType.Internal desugar_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17PackExpansionType7ProfileERN4llvm16FoldingSetNodeIDE")]
                internal static extern void Profile_0(global::System.IntPtr instance, global::System.IntPtr ID);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17PackExpansionType7classofEPKNS_4TypeE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);
            }

            private readonly bool __ownsNativeInstance;

            public static new PackExpansionType __CreateInstance(global::System.IntPtr native)
            {
                return new PackExpansionType((PackExpansionType.Internal*) native);
            }

            public static PackExpansionType __CreateInstance(PackExpansionType.Internal native)
            {
                return new PackExpansionType(native);
            }

            private static PackExpansionType.Internal* __CopyValue(PackExpansionType.Internal native)
            {
                var ret = (PackExpansionType.Internal*) Marshal.AllocHGlobal(48);
                *ret = native;
                return ret;
            }

            private PackExpansionType(PackExpansionType.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected PackExpansionType(PackExpansionType.Internal* native, bool isInternalImpl = false)
                : base((clang.Type.Internal*) native)
            {
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.ExtQualsTypeCommonBase __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            /// <summary>
            /// <para>Retrieve the pattern of this pack expansion, which is the type
            /// that will be repeatedly instantiated when instantiating the pack expansion
            /// itself.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the pattern of this pack expansion, which is
            /// the</para>
            /// <para>  /// type that will be repeatedly instantiated when
            /// instantiating the</para>
            /// <para>  /// pack expansion itself.</para>
            /// </remarks>
            public clang.QualType getPattern()
            {
                var __ret = Internal.getPattern_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            public bool isSugared()
            {
                var __ret = Internal.isSugared_0(__Instance);
                return __ret;
            }

            public clang.QualType desugar()
            {
                var __ret = Internal.desugar_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            public void Profile(llvm.FoldingSetNodeID ID)
            {
                var arg0 = ReferenceEquals(ID, null) ? global::System.IntPtr.Zero : ID.__Instance;
                Internal.Profile_0(__Instance, arg0);
            }

            public static bool classof(clang.Type T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>ObjCObjectType - Represents a class type in Objective C. Every
        /// Objective C type is a combination of a base type and a list of
        /// protocols.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// ObjCObjectType - Represents a class type in Objective
        /// C.</para>
        /// <para>/// Every Objective C type is a combination of a base type and
        /// a</para>
        /// <para>/// list of protocols.</para>
        /// <para>///</para>
        /// <para>/// Given the following declarations:</para>
        /// <para>/// \code</para>
        /// <para>///   \@class C;</para>
        /// <para>///   \@protocol P;</para>
        /// <para>/// \endcode</para>
        /// <para>///</para>
        /// <para>/// 'C' is an ObjCInterfaceType C.  It is sugar for an
        /// ObjCObjectType</para>
        /// <para>/// with base C and no protocols.</para>
        /// <para>///</para>
        /// <para>/// 'C&lt;P&gt;' is an ObjCObjectType with base C and protocol
        /// list [P].</para>
        /// <para>///</para>
        /// <para>/// 'id' is a TypedefType which is sugar for an
        /// ObjCObjectPointerType whose</para>
        /// <para>/// pointee is an ObjCObjectType with base
        /// BuiltinType::ObjCIdType</para>
        /// <para>/// and no protocols.</para>
        /// <para>///</para>
        /// <para>/// 'id&lt;P&gt;' is an ObjCObjectPointerType whose pointee is an
        /// ObjCObjectType</para>
        /// <para>/// with base BuiltinType::ObjCIdType and protocol list [P].
        /// Eventually</para>
        /// <para>/// this should get its own sugar class to better represent the
        /// source.</para>
        /// </remarks>
        public unsafe partial class ObjCObjectType : clang.Type, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 32)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr BaseType;

                [FieldOffset(8)]
                public clang.QualType.Internal CanonicalType;

                [FieldOffset(16)]
                internal clang.Type._.Internal __;

                [FieldOffset(24)]
                public clang.QualType.Internal BaseType;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14ObjCObjectTypeC2ENS0_19Nonce_ObjCInterfaceE")]
                internal static extern void ctor_1(global::System.IntPtr instance, clang.ObjCObjectType.Nonce_ObjCInterface _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14ObjCObjectTypeC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14ObjCObjectType11getBaseTypeEv")]
                internal static extern clang.QualType.Internal getBaseType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14ObjCObjectType8isObjCIdEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isObjCId_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14ObjCObjectType11isObjCClassEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isObjCClass_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14ObjCObjectType19isObjCUnqualifiedIdEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isObjCUnqualifiedId_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14ObjCObjectType22isObjCUnqualifiedClassEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isObjCUnqualifiedClass_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14ObjCObjectType26isObjCUnqualifiedIdOrClassEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isObjCUnqualifiedIdOrClass_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14ObjCObjectType17isObjCQualifiedIdEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isObjCQualifiedId_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14ObjCObjectType20isObjCQualifiedClassEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isObjCQualifiedClass_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14ObjCObjectType10qual_emptyEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool qual_empty_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14ObjCObjectType15getNumProtocolsEv")]
                internal static extern uint getNumProtocols_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14ObjCObjectType9isSugaredEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isSugared_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14ObjCObjectType7desugarEv")]
                internal static extern clang.QualType.Internal desugar_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14ObjCObjectType7classofEPKNS_4TypeE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);
            }

            public enum Nonce_ObjCInterface : uint
            {
                Nonce_ObjCInterface = 0
            }

            private readonly bool __ownsNativeInstance;

            public static new ObjCObjectType __CreateInstance(global::System.IntPtr native)
            {
                return new ObjCObjectType((ObjCObjectType.Internal*) native);
            }

            public static ObjCObjectType __CreateInstance(ObjCObjectType.Internal native)
            {
                return new ObjCObjectType(native);
            }

            private static ObjCObjectType.Internal* __CopyValue(ObjCObjectType.Internal native)
            {
                var ret = (ObjCObjectType.Internal*) Marshal.AllocHGlobal(32);
                *ret = native;
                return ret;
            }

            private ObjCObjectType(ObjCObjectType.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected ObjCObjectType(ObjCObjectType.Internal* native, bool isInternalImpl = false)
                : base((clang.Type.Internal*) native)
            {
            }

            protected ObjCObjectType(clang.ObjCObjectType.Nonce_ObjCInterface _0)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(32);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = _0;
                Internal.ctor_1(__Instance, arg0);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.ExtQualsTypeCommonBase __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            /// <summary>
            /// <para>getBaseType - Gets the base type of this object type. This is
            /// always (possibly sugar for) one of: - the 'id' builtin type (as opposed to
            /// the 'id' type visible to the user, which is a typedef for an
            /// ObjCObjectPointerType) - the 'Class' builtin type (same caveat) - an
            /// ObjCObjectType (currently always an ObjCInterfaceType)</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getBaseType - Gets the base type of this object type.  This
            /// is</para>
            /// <para>  /// always (possibly sugar for) one of:</para>
            /// <para>  ///  - the 'id' builtin type (as opposed to the 'id' type
            /// visible to the</para>
            /// <para>  ///    user, which is a typedef for an
            /// ObjCObjectPointerType)</para>
            /// <para>  ///  - the 'Class' builtin type (same caveat)</para>
            /// <para>  ///  - an ObjCObjectType (currently always an
            /// ObjCInterfaceType)</para>
            /// </remarks>
            public clang.QualType getBaseType()
            {
                var __ret = Internal.getBaseType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            public bool isObjCId()
            {
                var __ret = Internal.isObjCId_0(__Instance);
                return __ret;
            }

            public bool isObjCClass()
            {
                var __ret = Internal.isObjCClass_0(__Instance);
                return __ret;
            }

            public bool isObjCUnqualifiedId()
            {
                var __ret = Internal.isObjCUnqualifiedId_0(__Instance);
                return __ret;
            }

            public bool isObjCUnqualifiedClass()
            {
                var __ret = Internal.isObjCUnqualifiedClass_0(__Instance);
                return __ret;
            }

            public bool isObjCUnqualifiedIdOrClass()
            {
                var __ret = Internal.isObjCUnqualifiedIdOrClass_0(__Instance);
                return __ret;
            }

            public bool isObjCQualifiedId()
            {
                var __ret = Internal.isObjCQualifiedId_0(__Instance);
                return __ret;
            }

            public bool isObjCQualifiedClass()
            {
                var __ret = Internal.isObjCQualifiedClass_0(__Instance);
                return __ret;
            }

            public bool qual_empty()
            {
                var __ret = Internal.qual_empty_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>getNumProtocols - Return the number of qualifying protocols in
            /// this interface type, or 0 if there are none.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getNumProtocols - Return the number of qualifying protocols
            /// in this</para>
            /// <para>  /// interface type, or 0 if there are none.</para>
            /// </remarks>
            public uint getNumProtocols()
            {
                var __ret = Internal.getNumProtocols_0(__Instance);
                return __ret;
            }

            public bool isSugared()
            {
                var __ret = Internal.isSugared_0(__Instance);
                return __ret;
            }

            public clang.QualType desugar()
            {
                var __ret = Internal.desugar_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            public static bool classof(clang.Type T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>ObjCObjectTypeImpl - A class providing a concrete implementation
        /// of ObjCObjectType, so as to not increase the footprint of
        /// ObjCInterfaceType. Code outside of ASTContext and the core type system
        /// should not reference this type.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// ObjCObjectTypeImpl - A class providing a concrete
        /// implementation</para>
        /// <para>/// of ObjCObjectType, so as to not increase the footprint
        /// of</para>
        /// <para>/// ObjCInterfaceType.  Code outside of ASTContext and the core
        /// type</para>
        /// <para>/// system should not reference this type.</para>
        /// </remarks>
        public unsafe partial class ObjCObjectTypeImpl : clang.ObjCObjectType, llvm.FoldingSetImpl.Node, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 40)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr BaseType;

                [FieldOffset(8)]
                public clang.QualType.Internal CanonicalType;

                [FieldOffset(16)]
                internal clang.Type._.Internal __;

                [FieldOffset(24)]
                public clang.QualType.Internal BaseType;

                [FieldOffset(0)]
                public global::System.IntPtr NextInFoldingSetBucket;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang18ObjCObjectTypeImplC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang18ObjCObjectTypeImpl7ProfileERN4llvm16FoldingSetNodeIDE")]
                internal static extern void Profile_0(global::System.IntPtr instance, global::System.IntPtr ID);
            }

            private readonly bool __ownsNativeInstance;

            public static new ObjCObjectTypeImpl __CreateInstance(global::System.IntPtr native)
            {
                return new ObjCObjectTypeImpl((ObjCObjectTypeImpl.Internal*) native);
            }

            public static ObjCObjectTypeImpl __CreateInstance(ObjCObjectTypeImpl.Internal native)
            {
                return new ObjCObjectTypeImpl(native);
            }

            private static ObjCObjectTypeImpl.Internal* __CopyValue(ObjCObjectTypeImpl.Internal native)
            {
                var ret = (ObjCObjectTypeImpl.Internal*) Marshal.AllocHGlobal(40);
                *ret = native;
                return ret;
            }

            private ObjCObjectTypeImpl(ObjCObjectTypeImpl.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected ObjCObjectTypeImpl(ObjCObjectTypeImpl.Internal* native, bool isInternalImpl = false)
                : base((clang.ObjCObjectType.Internal*) native)
            {
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.ExtQualsTypeCommonBase __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public void Profile(llvm.FoldingSetNodeID ID)
            {
                var arg0 = ReferenceEquals(ID, null) ? global::System.IntPtr.Zero : ID.__Instance;
                Internal.Profile_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>ObjCInterfaceType - Interfaces are the core concept in
        /// Objective-C for object oriented design. They basically correspond to C++
        /// classes. There are two kinds of interface types, normal interfaces like
        /// &quot;NSString&quot; and qualified interfaces, which are qualified with a
        /// protocol list like &quot;NSString&lt;NSCopyable,
        /// NSAmazing&gt;&quot;.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// ObjCInterfaceType - Interfaces are the core concept in
        /// Objective-C for</para>
        /// <para>/// object oriented design.  They basically correspond to C++
        /// classes.  There</para>
        /// <para>/// are two kinds of interface types, normal interfaces like
        /// &quot;NSString&quot; and</para>
        /// <para>/// qualified interfaces, which are qualified with a protocol
        /// list like</para>
        /// <para>/// &quot;NSString&lt;NSCopyable, NSAmazing&gt;&quot;.</para>
        /// <para>///</para>
        /// <para>/// ObjCInterfaceType guarantees the following properties when
        /// considered</para>
        /// <para>/// as a subtype of its superclass, ObjCObjectType:</para>
        /// <para>///   - There are no protocol qualifiers.  To reinforce this,
        /// code which</para>
        /// <para>///     tries to invoke the protocol methods via an
        /// ObjCInterfaceType will</para>
        /// <para>///     fail to compile.</para>
        /// <para>///   - It is its own base type.  That is, if T is an
        /// ObjCInterfaceType*,</para>
        /// <para>///     T-&gt;getBaseType() == QualType(T, 0).</para>
        /// </remarks>
        public unsafe partial class ObjCInterfaceType : clang.ObjCObjectType, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 40)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr BaseType;

                [FieldOffset(8)]
                public clang.QualType.Internal CanonicalType;

                [FieldOffset(16)]
                internal clang.Type._.Internal __;

                [FieldOffset(24)]
                public clang.QualType.Internal BaseType;

                [FieldOffset(32)]
                public global::System.IntPtr Decl;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17ObjCInterfaceTypeC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17ObjCInterfaceType9isSugaredEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isSugared_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17ObjCInterfaceType7desugarEv")]
                internal static extern clang.QualType.Internal desugar_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17ObjCInterfaceType7classofEPKNS_4TypeE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);
            }

            public enum _0 : uint
            {
                qual_iterator = 0,
                qual_begin = 1,
                qual_end = 2,
                getNumProtocols = 3,
                getProtocol = 4
            }

            private readonly bool __ownsNativeInstance;

            public static new ObjCInterfaceType __CreateInstance(global::System.IntPtr native)
            {
                return new ObjCInterfaceType((ObjCInterfaceType.Internal*) native);
            }

            public static ObjCInterfaceType __CreateInstance(ObjCInterfaceType.Internal native)
            {
                return new ObjCInterfaceType(native);
            }

            private static ObjCInterfaceType.Internal* __CopyValue(ObjCInterfaceType.Internal native)
            {
                var ret = (ObjCInterfaceType.Internal*) Marshal.AllocHGlobal(40);
                *ret = native;
                return ret;
            }

            private ObjCInterfaceType(ObjCInterfaceType.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected ObjCInterfaceType(ObjCInterfaceType.Internal* native, bool isInternalImpl = false)
                : base((clang.ObjCObjectType.Internal*) native)
            {
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.ExtQualsTypeCommonBase __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public bool isSugared()
            {
                var __ret = Internal.isSugared_0(__Instance);
                return __ret;
            }

            public clang.QualType desugar()
            {
                var __ret = Internal.desugar_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            public static bool classof(clang.Type T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>ObjCObjectPointerType - Used to represent a pointer to an
        /// Objective C object. These are constructed from pointer declarators when the
        /// pointee type is an ObjCObjectType (or sugar for one). In addition, the 'id'
        /// and 'Class' types are typedefs for these, and the protocol-qualified types
        /// 'id&lt;P&gt;' and 'Class&lt;P&gt;' are translated into these.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// ObjCObjectPointerType - Used to represent a pointer to
        /// an</para>
        /// <para>/// Objective C object.  These are constructed from
        /// pointer</para>
        /// <para>/// declarators when the pointee type is an ObjCObjectType (or
        /// sugar</para>
        /// <para>/// for one).  In addition, the 'id' and 'Class' types are
        /// typedefs</para>
        /// <para>/// for these, and the protocol-qualified types 'id&lt;P&gt;' and
        /// 'Class&lt;P&gt;'</para>
        /// <para>/// are translated into these.</para>
        /// <para>///</para>
        /// <para>/// Pointers to pointers to Objective C objects are still
        /// PointerTypes;</para>
        /// <para>/// only the first level of pointer gets it own type
        /// implementation.</para>
        /// </remarks>
        public unsafe partial class ObjCObjectPointerType : clang.Type, llvm.FoldingSetImpl.Node, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 40)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr BaseType;

                [FieldOffset(8)]
                public clang.QualType.Internal CanonicalType;

                [FieldOffset(16)]
                internal clang.Type._.Internal __;

                [FieldOffset(0)]
                public global::System.IntPtr NextInFoldingSetBucket;

                [FieldOffset(32)]
                public clang.QualType.Internal PointeeType;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang21ObjCObjectPointerTypeC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang21ObjCObjectPointerType14getPointeeTypeEv")]
                internal static extern clang.QualType.Internal getPointeeType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang21ObjCObjectPointerType13getObjectTypeEv")]
                internal static extern global::System.IntPtr getObjectType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang21ObjCObjectPointerType16getInterfaceTypeEv")]
                internal static extern global::System.IntPtr getInterfaceType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang21ObjCObjectPointerType12isObjCIdTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isObjCIdType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang21ObjCObjectPointerType15isObjCClassTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isObjCClassType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang21ObjCObjectPointerType21isObjCQualifiedIdTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isObjCQualifiedIdType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang21ObjCObjectPointerType24isObjCQualifiedClassTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isObjCQualifiedClassType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang21ObjCObjectPointerType10qual_emptyEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool qual_empty_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang21ObjCObjectPointerType15getNumProtocolsEv")]
                internal static extern uint getNumProtocols_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang21ObjCObjectPointerType9isSugaredEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isSugared_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang21ObjCObjectPointerType7desugarEv")]
                internal static extern clang.QualType.Internal desugar_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang21ObjCObjectPointerType7ProfileERN4llvm16FoldingSetNodeIDE")]
                internal static extern void Profile_0(global::System.IntPtr instance, global::System.IntPtr ID);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang21ObjCObjectPointerType7ProfileERN4llvm16FoldingSetNodeIDENS_8QualTypeE")]
                internal static extern void Profile_1(global::System.IntPtr ID, clang.QualType.Internal T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang21ObjCObjectPointerType7classofEPKNS_4TypeE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);
            }

            private readonly bool __ownsNativeInstance;

            public static new ObjCObjectPointerType __CreateInstance(global::System.IntPtr native)
            {
                return new ObjCObjectPointerType((ObjCObjectPointerType.Internal*) native);
            }

            public static ObjCObjectPointerType __CreateInstance(ObjCObjectPointerType.Internal native)
            {
                return new ObjCObjectPointerType(native);
            }

            private static ObjCObjectPointerType.Internal* __CopyValue(ObjCObjectPointerType.Internal native)
            {
                var ret = (ObjCObjectPointerType.Internal*) Marshal.AllocHGlobal(40);
                *ret = native;
                return ret;
            }

            private ObjCObjectPointerType(ObjCObjectPointerType.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected ObjCObjectPointerType(ObjCObjectPointerType.Internal* native, bool isInternalImpl = false)
                : base((clang.Type.Internal*) native)
            {
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.ExtQualsTypeCommonBase __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            /// <summary>
            /// <para>getPointeeType - Gets the type pointed to by this ObjC pointer.
            /// The result will always be an ObjCObjectType or sugar thereof.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getPointeeType - Gets the type pointed to by this ObjC
            /// pointer.</para>
            /// <para>  /// The result will always be an ObjCObjectType or sugar
            /// thereof.</para>
            /// </remarks>
            public clang.QualType getPointeeType()
            {
                var __ret = Internal.getPointeeType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>getObjCObjectType - Gets the type pointed to by this ObjC
            /// pointer. This method always returns non-null.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getObjCObjectType - Gets the type pointed to by this
            /// ObjC</para>
            /// <para>  /// pointer.  This method always returns non-null.</para>
            /// <para>  ///</para>
            /// <para>  /// This method is equivalent to getPointeeType() except
            /// that</para>
            /// <para>  /// it discards any typedefs (or other sugar) between
            /// this</para>
            /// <para>  /// type and the &quot;outermost&quot; object type.  So
            /// for:</para>
            /// <para>  /// \code</para>
            /// <para>  ///   \@class A; \@protocol P; \@protocol Q;</para>
            /// <para>  ///   typedef A&lt;P&gt; AP;</para>
            /// <para>  ///   typedef A A1;</para>
            /// <para>  ///   typedef A1&lt;P&gt; A1P;</para>
            /// <para>  ///   typedef A1P&lt;Q&gt; A1PQ;</para>
            /// <para>  /// \endcode</para>
            /// <para>  /// For 'A*', getObjectType() will return 'A'.</para>
            /// <para>  /// For 'A&lt;P&gt;*', getObjectType() will return
            /// 'A&lt;P&gt;'.</para>
            /// <para>  /// For 'AP*', getObjectType() will return 'A&lt;P&gt;'.</para>
            /// <para>  /// For 'A1*', getObjectType() will return 'A'.</para>
            /// <para>  /// For 'A1&lt;P&gt;*', getObjectType() will return
            /// 'A1&lt;P&gt;'.</para>
            /// <para>  /// For 'A1P*', getObjectType() will return
            /// 'A1&lt;P&gt;'.</para>
            /// <para>  /// For 'A1PQ*', getObjectType() will return 'A1&lt;Q&gt;',
            /// because</para>
            /// <para>  ///   adding protocols to a protocol-qualified base discards
            /// the</para>
            /// <para>  ///   old qualifiers (for now).  But if it didn't,
            /// getObjectType()</para>
            /// <para>  ///   would return 'A1P&lt;Q&gt;' (and we'd have to make
            /// iterating over</para>
            /// <para>  ///   qualifiers more complicated).</para>
            /// </remarks>
            public clang.ObjCObjectType getObjectType()
            {
                var __ret = Internal.getObjectType_0(__Instance);
                clang.ObjCObjectType __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.ObjCObjectType.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.ObjCObjectType) clang.ObjCObjectType.NativeToManagedMap[__ret];
                else __result0 = clang.ObjCObjectType.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>getInterfaceType - If this pointer points to an Objective C
            /// @interface type, gets the type for that interface. Any protocol qualifiers
            /// on the interface are ignored.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getInterfaceType - If this pointer points to an Objective
            /// C</para>
            /// <para>  /// \@interface type, gets the type for that interface.  Any
            /// protocol</para>
            /// <para>  /// qualifiers on the interface are ignored.</para>
            /// <para>  ///</para>
            /// <para>  /// \return null if the base type for this pointer is 'id' or
            /// 'Class'</para>
            /// </remarks>
            public clang.ObjCInterfaceType getInterfaceType()
            {
                var __ret = Internal.getInterfaceType_0(__Instance);
                clang.ObjCInterfaceType __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.ObjCInterfaceType.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.ObjCInterfaceType) clang.ObjCInterfaceType.NativeToManagedMap[__ret];
                else __result0 = clang.ObjCInterfaceType.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>isObjCIdType - True if this is equivalent to the 'id' type, i.e.
            /// if its object type is the primitive 'id' type with no protocols.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// isObjCIdType - True if this is equivalent to the 'id' type,
            /// i.e. if</para>
            /// <para>  /// its object type is the primitive 'id' type with no
            /// protocols.</para>
            /// </remarks>
            public bool isObjCIdType()
            {
                var __ret = Internal.isObjCIdType_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>isObjCClassType - True if this is equivalent to the 'Class' type,
            /// i.e. if its object tive is the primitive 'Class' type with no
            /// protocols.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// isObjCClassType - True if this is equivalent to the 'Class'
            /// type,</para>
            /// <para>  /// i.e. if its object tive is the primitive 'Class' type with
            /// no protocols.</para>
            /// </remarks>
            public bool isObjCClassType()
            {
                var __ret = Internal.isObjCClassType_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>isObjCQualifiedIdType - True if this is equivalent to
            /// 'id&lt;P&gt;' for some non-empty set of protocols.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// isObjCQualifiedIdType - True if this is equivalent to
            /// 'id&lt;P&gt;' for some</para>
            /// <para>  /// non-empty set of protocols.</para>
            /// </remarks>
            public bool isObjCQualifiedIdType()
            {
                var __ret = Internal.isObjCQualifiedIdType_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>isObjCQualifiedClassType - True if this is equivalent to
            /// 'Class&lt;P&gt;' for some non-empty set of protocols.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// isObjCQualifiedClassType - True if this is equivalent to
            /// 'Class&lt;P&gt;' for</para>
            /// <para>  /// some non-empty set of protocols.</para>
            /// </remarks>
            public bool isObjCQualifiedClassType()
            {
                var __ret = Internal.isObjCQualifiedClassType_0(__Instance);
                return __ret;
            }

            public bool qual_empty()
            {
                var __ret = Internal.qual_empty_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>getNumProtocols - Return the number of qualifying protocols on
            /// the object type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getNumProtocols - Return the number of qualifying protocols
            /// on</para>
            /// <para>  /// the object type.</para>
            /// </remarks>
            public uint getNumProtocols()
            {
                var __ret = Internal.getNumProtocols_0(__Instance);
                return __ret;
            }

            public bool isSugared()
            {
                var __ret = Internal.isSugared_0(__Instance);
                return __ret;
            }

            public clang.QualType desugar()
            {
                var __ret = Internal.desugar_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            public void Profile(llvm.FoldingSetNodeID ID)
            {
                var arg0 = ReferenceEquals(ID, null) ? global::System.IntPtr.Zero : ID.__Instance;
                Internal.Profile_0(__Instance, arg0);
            }

            public static void Profile(llvm.FoldingSetNodeID ID, clang.QualType T)
            {
                var arg0 = ReferenceEquals(ID, null) ? global::System.IntPtr.Zero : ID.__Instance;
                var arg1 = ReferenceEquals(T, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (T.__Instance);
                Internal.Profile_1(arg0, arg1);
            }

            public static bool classof(clang.Type T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        public unsafe partial class AtomicType : clang.Type, llvm.FoldingSetImpl.Node, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 40)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr BaseType;

                [FieldOffset(8)]
                public clang.QualType.Internal CanonicalType;

                [FieldOffset(16)]
                internal clang.Type._.Internal __;

                [FieldOffset(0)]
                public global::System.IntPtr NextInFoldingSetBucket;

                [FieldOffset(32)]
                public clang.QualType.Internal ValueType;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10AtomicTypeC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10AtomicType12getValueTypeEv")]
                internal static extern clang.QualType.Internal getValueType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10AtomicType9isSugaredEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isSugared_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10AtomicType7desugarEv")]
                internal static extern clang.QualType.Internal desugar_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10AtomicType7ProfileERN4llvm16FoldingSetNodeIDE")]
                internal static extern void Profile_0(global::System.IntPtr instance, global::System.IntPtr ID);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10AtomicType7ProfileERN4llvm16FoldingSetNodeIDENS_8QualTypeE")]
                internal static extern void Profile_1(global::System.IntPtr ID, clang.QualType.Internal T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10AtomicType7classofEPKNS_4TypeE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr T);
            }

            private readonly bool __ownsNativeInstance;

            public static new AtomicType __CreateInstance(global::System.IntPtr native)
            {
                return new AtomicType((AtomicType.Internal*) native);
            }

            public static AtomicType __CreateInstance(AtomicType.Internal native)
            {
                return new AtomicType(native);
            }

            private static AtomicType.Internal* __CopyValue(AtomicType.Internal native)
            {
                var ret = (AtomicType.Internal*) Marshal.AllocHGlobal(40);
                *ret = native;
                return ret;
            }

            private AtomicType(AtomicType.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected AtomicType(AtomicType.Internal* native, bool isInternalImpl = false)
                : base((clang.Type.Internal*) native)
            {
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.ExtQualsTypeCommonBase __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            /// <summary>
            /// <para>getValueType - Gets the type contained by this atomic type, i.e.
            /// the type returned by performing an atomic load of this atomic type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getValueType - Gets the type contained by this atomic type,
            /// i.e.</para>
            /// <para>  /// the type returned by performing an atomic load of this
            /// atomic type.</para>
            /// </remarks>
            public clang.QualType getValueType()
            {
                var __ret = Internal.getValueType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            public bool isSugared()
            {
                var __ret = Internal.isSugared_0(__Instance);
                return __ret;
            }

            public clang.QualType desugar()
            {
                var __ret = Internal.desugar_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            public void Profile(llvm.FoldingSetNodeID ID)
            {
                var arg0 = ReferenceEquals(ID, null) ? global::System.IntPtr.Zero : ID.__Instance;
                Internal.Profile_0(__Instance, arg0);
            }

            public static void Profile(llvm.FoldingSetNodeID ID, clang.QualType T)
            {
                var arg0 = ReferenceEquals(ID, null) ? global::System.IntPtr.Zero : ID.__Instance;
                var arg1 = ReferenceEquals(T, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (T.__Instance);
                Internal.Profile_1(arg0, arg1);
            }

            public static bool classof(clang.Type T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }
        }

        /// <summary>
        /// <para>A qualifier set is used to build a set of qualifiers.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// A qualifier set is used to build a set of qualifiers.</para>
        /// </remarks>
        public unsafe partial class QualifierCollector : clang.Qualifiers, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 4)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                public uint Mask;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang18QualifierCollectorC2ENS_10QualifiersE")]
                internal static extern void ctor_0(global::System.IntPtr instance, clang.Qualifiers.Internal Qs);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang18QualifierCollectorC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang18QualifierCollector5stripENS_8QualTypeE")]
                internal static extern global::System.IntPtr strip_0(global::System.IntPtr instance, clang.QualType.Internal type);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang18QualifierCollector5applyERKNS_10ASTContextENS_8QualTypeE")]
                internal static extern clang.QualType.Internal apply_0(global::System.IntPtr instance, global::System.IntPtr Context, clang.QualType.Internal QT);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang18QualifierCollector5applyERKNS_10ASTContextEPKNS_4TypeE")]
                internal static extern clang.QualType.Internal apply_1(global::System.IntPtr instance, global::System.IntPtr Context, global::System.IntPtr T);
            }

            private readonly bool __ownsNativeInstance;

            public static new QualifierCollector __CreateInstance(global::System.IntPtr native)
            {
                return new QualifierCollector((QualifierCollector.Internal*) native);
            }

            public static QualifierCollector __CreateInstance(QualifierCollector.Internal native)
            {
                return new QualifierCollector(native);
            }

            private static QualifierCollector.Internal* __CopyValue(QualifierCollector.Internal native)
            {
                var ret = (QualifierCollector.Internal*) Marshal.AllocHGlobal(4);
                *ret = native;
                return ret;
            }

            private QualifierCollector(QualifierCollector.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected QualifierCollector(QualifierCollector.Internal* native, bool isInternalImpl = false)
                : base((clang.Qualifiers.Internal*) native)
            {
            }

            public QualifierCollector(clang.Qualifiers Qs)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(4);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(Qs, null) ? new clang.Qualifiers.Internal() : *(clang.Qualifiers.Internal*) (Qs.__Instance);
                Internal.ctor_0(__Instance, arg0);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Qualifiers __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            /// <summary>
            /// <para>Collect any qualifiers on the given type and return an
            /// unqualified type. The qualifiers are assumed to be consistent with those
            /// already in the type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Collect any qualifiers on the given type and return an</para>
            /// <para>  /// unqualified type.  The qualifiers are assumed to be
            /// consistent</para>
            /// <para>  /// with those already in the type.</para>
            /// </remarks>
            public clang.Type strip(clang.QualType type)
            {
                var arg0 = ReferenceEquals(type, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (type.__Instance);
                var __ret = Internal.strip_0(__Instance, arg0);
                clang.Type __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Type.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Type) clang.Type.NativeToManagedMap[__ret];
                else __result0 = clang.Type.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Apply the collected qualifiers to the given type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Apply the collected qualifiers to the given type.</para>
            /// </remarks>
            public clang.QualType apply(clang.ASTContext Context, clang.QualType QT)
            {
                var arg0 = ReferenceEquals(Context, null) ? global::System.IntPtr.Zero : Context.__Instance;
                var arg1 = ReferenceEquals(QT, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (QT.__Instance);
                var __ret = Internal.apply_0(__Instance, arg0, arg1);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Apply the collected qualifiers to the given type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Apply the collected qualifiers to the given type.</para>
            /// </remarks>
            public clang.QualType apply(clang.ASTContext Context, clang.Type T)
            {
                var arg0 = ReferenceEquals(Context, null) ? global::System.IntPtr.Zero : Context.__Instance;
                var arg1 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                var __ret = Internal.apply_1(__Instance, arg0, arg1);
                return clang.QualType.__CreateInstance(__ret);
            }
        }

        public unsafe partial class Type
        {
            public partial struct Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang18getFunctionExtInfoERKNS_4TypeE")]
                internal static extern clang.FunctionType.ExtInfo.Internal getFunctionExtInfo_0(global::System.IntPtr t);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang18getFunctionExtInfoENS_8QualTypeE")]
                internal static extern clang.FunctionType.ExtInfo.Internal getFunctionExtInfo_1(clang.QualType.Internal t);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang18IsEnumDeclCompleteEPNS_8EnumDeclE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool IsEnumDeclComplete_0(global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16IsEnumDeclScopedEPNS_8EnumDeclE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool IsEnumDeclScoped_0(global::System.IntPtr _0);
            }

            public static clang.FunctionType.ExtInfo getFunctionExtInfo(clang.Type t)
            {
                var arg0 = ReferenceEquals(t, null) ? global::System.IntPtr.Zero : t.__Instance;
                var __ret = Internal.getFunctionExtInfo_0(arg0);
                return clang.FunctionType.ExtInfo.__CreateInstance(__ret);
            }

            public static clang.FunctionType.ExtInfo getFunctionExtInfo(clang.QualType t)
            {
                var arg0 = ReferenceEquals(t, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (t.__Instance);
                var __ret = Internal.getFunctionExtInfo_1(arg0);
                return clang.FunctionType.ExtInfo.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Check if the given decl is complete.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Check if the given decl is complete.</para>
            /// <para>///</para>
            /// <para>/// We use this function to break a cycle between the inline
            /// definitions in</para>
            /// <para>/// Type.h and Decl.h.</para>
            /// </remarks>
            public static bool IsEnumDeclComplete(clang.EnumDecl _0)
            {
                var arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
                var __ret = Internal.IsEnumDeclComplete_0(arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Check if the given decl is scoped.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Check if the given decl is scoped.</para>
            /// <para>///</para>
            /// <para>/// We use this function to break a cycle between the inline
            /// definitions in</para>
            /// <para>/// Type.h and Decl.h.</para>
            /// </remarks>
            public static bool IsEnumDeclScoped(clang.EnumDecl _0)
            {
                var arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
                var __ret = Internal.IsEnumDeclScoped_0(arg0);
                return __ret;
            }
        }
    }

    namespace llvm
    {
    }
}
