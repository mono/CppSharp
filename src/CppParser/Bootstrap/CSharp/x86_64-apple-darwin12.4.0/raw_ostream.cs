//----------------------------------------------------------------------------
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
//----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace CppSharp
{
    public unsafe partial class raw_ostream
    {
        public partial struct Internal
        {
        }
    }

    namespace llvm
    {
        /// <summary>
        /// <para>raw_ostream - This class implements an extremely fast bulk output
        /// stream that can *only* output to a stream. It does not support seeking,
        /// reopening, rewinding, line buffered disciplines etc. It is a simple buffer
        /// that outputs a chunk at a time.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// raw_ostream - This class implements an extremely fast bulk
        /// output stream</para>
        /// <para>/// that can *only* output to a stream.  It does not support
        /// seeking, reopening,</para>
        /// <para>/// rewinding, line buffered disciplines etc. It is a simple
        /// buffer that outputs</para>
        /// <para>/// a chunk at a time.</para>
        /// </remarks>
        public unsafe abstract partial class raw_ostream : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 40)]
            public partial struct Internal
            {
                [FieldOffset(8)]
                public sbyte* OutBufStart;

                [FieldOffset(16)]
                public sbyte* OutBufEnd;

                [FieldOffset(24)]
                public sbyte* OutBufCur;

                [FieldOffset(32)]
                public llvm.raw_ostream.BufferKind BufferMode;

                [FieldOffset(0)]
                public global::System.IntPtr vfptr0;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm11raw_ostreamC2Eb")]
                internal static extern void ctor_1(global::System.IntPtr instance, bool unbuffered);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm11raw_ostreamD2Ev")]
                internal static extern void dtor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm11raw_ostream4tellEv")]
                internal static extern ulong tell_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm11raw_ostream11SetBufferedEv")]
                internal static extern void SetBuffered_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm11raw_ostream13SetBufferSizeEm")]
                internal static extern void SetBufferSize_0(global::System.IntPtr instance, ulong Size);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm11raw_ostream13GetBufferSizeEv")]
                internal static extern ulong GetBufferSize_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm11raw_ostream13SetUnbufferedEv")]
                internal static extern void SetUnbuffered_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm11raw_ostream19GetNumBytesInBufferEv")]
                internal static extern ulong GetNumBytesInBuffer_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm11raw_ostream5flushEv")]
                internal static extern void flush_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm11raw_ostreamlsEi")]
                internal static extern global::System.IntPtr OperatorLessLess_12(global::System.IntPtr instance, int N);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm11raw_ostream9write_hexEy")]
                internal static extern global::System.IntPtr write_hex_0(global::System.IntPtr instance, ulong N);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm11raw_ostream13write_escapedENS_9StringRefEb")]
                internal static extern global::System.IntPtr write_escaped_0(global::System.IntPtr instance, llvm.StringRef.Internal Str, bool UseHexEscapes);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm11raw_ostream5writeEh")]
                internal static extern global::System.IntPtr write_0(global::System.IntPtr instance, byte C);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm11raw_ostream5writeEPKcm")]
                internal static extern global::System.IntPtr write_1(global::System.IntPtr instance, global::System.IntPtr Ptr, ulong Size);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm11raw_ostream6indentEj")]
                internal static extern global::System.IntPtr indent_0(global::System.IntPtr instance, uint NumSpaces);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm11raw_ostream11changeColorENS0_6ColorsEbb")]
                internal static extern global::System.IntPtr changeColor_0(global::System.IntPtr instance, llvm.raw_ostream.Colors Color, bool Bold, bool BG);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm11raw_ostream10resetColorEv")]
                internal static extern global::System.IntPtr resetColor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm11raw_ostream12reverseColorEv")]
                internal static extern global::System.IntPtr reverseColor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm11raw_ostream12is_displayedEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool is_displayed_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm11raw_ostream10has_colorsEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool has_colors_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm11raw_ostream9SetBufferEPcm")]
                internal static extern void SetBuffer_0(global::System.IntPtr instance, sbyte* BufferStart, ulong Size);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm11raw_ostream21preferred_buffer_sizeEv")]
                internal static extern ulong preferred_buffer_size_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm11raw_ostream14getBufferStartEv")]
                internal static extern global::System.IntPtr getBufferStart_0(global::System.IntPtr instance);
            }

            public enum Colors : uint
            {
                BLACK = 0,
                RED = 1,
                GREEN = 2,
                YELLOW = 3,
                BLUE = 4,
                MAGENTA = 5,
                CYAN = 6,
                WHITE = 7,
                SAVEDCOLOR = 8
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, raw_ostream> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, raw_ostream>();

            private readonly bool __ownsNativeInstance;

            public static raw_ostream __CreateInstance(global::System.IntPtr native)
            {
                return new raw_ostreamInternal((raw_ostream.Internal*) native);
            }

            public static raw_ostream __CreateInstance(raw_ostream.Internal native)
            {
                return new raw_ostreamInternal(native);
            }

            protected raw_ostream(raw_ostream.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
                if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                    SetupVTables(__Instance);
            }

            protected raw_ostream(bool unbuffered)
            {
                __Instance = Marshal.AllocHGlobal(40);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_1(__Instance, unbuffered);
                SetupVTables(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                llvm.raw_ostream __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance || force)
                    Internal.dtor_0(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            /// <summary>
            /// <para>tell - Return the current offset with the file.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// tell - Return the current offset with the file.</para>
            /// </remarks>
            public ulong tell()
            {
                var __ret = Internal.tell_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>SetBuffered - Set the stream to be buffered, with an
            /// automatically determined buffer size.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// SetBuffered - Set the stream to be buffered, with an
            /// automatically</para>
            /// <para>  /// determined buffer size.</para>
            /// </remarks>
            public void SetBuffered()
            {
                Internal.SetBuffered_0(__Instance);
            }

            /// <summary>
            /// <para>SetBufferSize - Set the stream to be buffered, using the
            /// specified buffer size.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// SetBufferSize - Set the stream to be buffered, using
            /// the</para>
            /// <para>  /// specified buffer size.</para>
            /// </remarks>
            public void SetBufferSize(ulong Size)
            {
                var arg0 = Size;
                Internal.SetBufferSize_0(__Instance, arg0);
            }

            public ulong GetBufferSize()
            {
                var __ret = Internal.GetBufferSize_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>SetUnbuffered - Set the stream to be unbuffered. When unbuffered,
            /// the stream will flush after every write. This routine will also flush the
            /// buffer immediately when the stream is being set to unbuffered.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// SetUnbuffered - Set the stream to be unbuffered. When</para>
            /// <para>  /// unbuffered, the stream will flush after every write. This
            /// routine</para>
            /// <para>  /// will also flush the buffer immediately when the stream is
            /// being</para>
            /// <para>  /// set to unbuffered.</para>
            /// </remarks>
            public void SetUnbuffered()
            {
                Internal.SetUnbuffered_0(__Instance);
            }

            public ulong GetNumBytesInBuffer()
            {
                var __ret = Internal.GetNumBytesInBuffer_0(__Instance);
                return __ret;
            }

            public void flush()
            {
                Internal.flush_0(__Instance);
            }

            public static llvm.raw_ostream operator <<(llvm.raw_ostream __op, int N)
            {
                var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
                var __ret = Internal.OperatorLessLess_12(arg0, N);
                llvm.raw_ostream __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (llvm.raw_ostream.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (llvm.raw_ostream) llvm.raw_ostream.NativeToManagedMap[__ret];
                else llvm.raw_ostream.NativeToManagedMap[__ret] = __result0 = (llvm.raw_ostream) llvm.raw_ostream.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>write_hex - Output N in hexadecimal, without any prefix or
            /// padding.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// write_hex - Output \p N in hexadecimal, without any prefix or
            /// padding.</para>
            /// </remarks>
            public llvm.raw_ostream write_hex(ulong N)
            {
                var __ret = Internal.write_hex_0(__Instance, N);
                llvm.raw_ostream __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (llvm.raw_ostream.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (llvm.raw_ostream) llvm.raw_ostream.NativeToManagedMap[__ret];
                else llvm.raw_ostream.NativeToManagedMap[__ret] = __result0 = (llvm.raw_ostream) llvm.raw_ostream.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>write_escaped - Output Str, turning '\', '', '', '&quot;', and
            /// anything that doesn't satisfy std::isprint into an escape sequence.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// write_escaped - Output \p Str, turning '\\', '\t', '\n',
            /// '&quot;', and</para>
            /// <para>  /// anything that doesn't satisfy std::isprint into an escape
            /// sequence.</para>
            /// </remarks>
            public llvm.raw_ostream write_escaped(llvm.StringRef Str, bool UseHexEscapes)
            {
                var arg0 = ReferenceEquals(Str, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (Str.__Instance);
                var __ret = Internal.write_escaped_0(__Instance, arg0, UseHexEscapes);
                llvm.raw_ostream __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (llvm.raw_ostream.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (llvm.raw_ostream) llvm.raw_ostream.NativeToManagedMap[__ret];
                else llvm.raw_ostream.NativeToManagedMap[__ret] = __result0 = (llvm.raw_ostream) llvm.raw_ostream.__CreateInstance(__ret);
                return __result0;
            }

            public llvm.raw_ostream write(byte C)
            {
                var __ret = Internal.write_0(__Instance, C);
                llvm.raw_ostream __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (llvm.raw_ostream.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (llvm.raw_ostream) llvm.raw_ostream.NativeToManagedMap[__ret];
                else llvm.raw_ostream.NativeToManagedMap[__ret] = __result0 = (llvm.raw_ostream) llvm.raw_ostream.__CreateInstance(__ret);
                return __result0;
            }

            public llvm.raw_ostream write(string Ptr, ulong Size)
            {
                var arg0 = Marshal.StringToHGlobalAnsi(Ptr);
                var arg1 = Size;
                var __ret = Internal.write_1(__Instance, arg0, arg1);
                Marshal.FreeHGlobal(arg0);
                llvm.raw_ostream __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (llvm.raw_ostream.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (llvm.raw_ostream) llvm.raw_ostream.NativeToManagedMap[__ret];
                else llvm.raw_ostream.NativeToManagedMap[__ret] = __result0 = (llvm.raw_ostream) llvm.raw_ostream.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>indent - Insert 'NumSpaces' spaces.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// indent - Insert 'NumSpaces' spaces.</para>
            /// </remarks>
            public llvm.raw_ostream indent(uint NumSpaces)
            {
                var __ret = Internal.indent_0(__Instance, NumSpaces);
                llvm.raw_ostream __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (llvm.raw_ostream.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (llvm.raw_ostream) llvm.raw_ostream.NativeToManagedMap[__ret];
                else llvm.raw_ostream.NativeToManagedMap[__ret] = __result0 = (llvm.raw_ostream) llvm.raw_ostream.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Changes the foreground color of text that will be output from
            /// this point forward.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Changes the foreground color of text that will be output from
            /// this point</para>
            /// <para>  /// forward.</para>
            /// <para>  /// @param Color ANSI color to use, the special SAVEDCOLOR can
            /// be used to</para>
            /// <para>  /// change only the bold attribute, and keep colors
            /// untouched</para>
            /// <para>  /// @param Bold bold/brighter text, default false</para>
            /// <para>  /// @param BG if true change the background, default: change
            /// foreground</para>
            /// <para>  /// @returns itself so it can be used within &lt;&lt;
            /// invocations</para>
            /// </remarks>
            public virtual llvm.raw_ostream changeColor(llvm.raw_ostream.Colors Color, bool Bold, bool BG)
            {
                var arg0 = Color;
                var __ret = Internal.changeColor_0(__Instance, arg0, Bold, BG);
                llvm.raw_ostream __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (llvm.raw_ostream.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (llvm.raw_ostream) llvm.raw_ostream.NativeToManagedMap[__ret];
                else llvm.raw_ostream.NativeToManagedMap[__ret] = __result0 = (llvm.raw_ostream) llvm.raw_ostream.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Resets the colors to terminal defaults. Call this when you are
            /// done outputting colored text, or before program exit.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Resets the colors to terminal defaults. Call this when you
            /// are done</para>
            /// <para>  /// outputting colored text, or before program exit.</para>
            /// </remarks>
            public virtual llvm.raw_ostream resetColor()
            {
                var __ret = Internal.resetColor_0(__Instance);
                llvm.raw_ostream __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (llvm.raw_ostream.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (llvm.raw_ostream) llvm.raw_ostream.NativeToManagedMap[__ret];
                else llvm.raw_ostream.NativeToManagedMap[__ret] = __result0 = (llvm.raw_ostream) llvm.raw_ostream.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Reverses the forground and background colors.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Reverses the forground and background colors.</para>
            /// </remarks>
            public virtual llvm.raw_ostream reverseColor()
            {
                var __ret = Internal.reverseColor_0(__Instance);
                llvm.raw_ostream __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (llvm.raw_ostream.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (llvm.raw_ostream) llvm.raw_ostream.NativeToManagedMap[__ret];
                else llvm.raw_ostream.NativeToManagedMap[__ret] = __result0 = (llvm.raw_ostream) llvm.raw_ostream.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>This function determines if this stream is connected to a
            /// &quot;tty&quot; or &quot;console&quot; window. That is, the output would be
            /// displayed to the user rather than being put on a pipe or stored in a
            /// file.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// This function determines if this stream is connected to a
            /// &quot;tty&quot; or</para>
            /// <para>  /// &quot;console&quot; window. That is, the output would be
            /// displayed to the user</para>
            /// <para>  /// rather than being put on a pipe or stored in a file.</para>
            /// </remarks>
            public virtual bool is_displayed()
            {
                var __ret = Internal.is_displayed_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>This function determines if this stream is displayed and supports
            /// colors.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// This function determines if this stream is displayed and
            /// supports colors.</para>
            /// </remarks>
            public virtual bool has_colors()
            {
                var __ret = Internal.has_colors_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>SetBuffer - Use the provided buffer as the raw_ostream buffer.
            /// This is intended for use only by subclasses which can arrange for the
            /// output to go directly into the desired output buffer, instead of being
            /// copied on each flush.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// SetBuffer - Use the provided buffer as the raw_ostream
            /// buffer. This is</para>
            /// <para>  /// intended for use only by subclasses which can arrange for
            /// the output to go</para>
            /// <para>  /// directly into the desired output buffer, instead of being
            /// copied on each</para>
            /// <para>  /// flush.</para>
            /// </remarks>
            protected void SetBuffer(sbyte* BufferStart, ulong Size)
            {
                var arg0 = BufferStart;
                var arg1 = Size;
                Internal.SetBuffer_0(__Instance, arg0, arg1);
            }

            /// <summary>
            /// <para>preferred_buffer_size - Return an efficient buffer size for the
            /// underlying output mechanism.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// preferred_buffer_size - Return an efficient buffer size for
            /// the</para>
            /// <para>  /// underlying output mechanism.</para>
            /// </remarks>
            protected virtual ulong preferred_buffer_size()
            {
                var __ret = Internal.preferred_buffer_size_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>getBufferStart - Return the beginning of the current stream
            /// buffer, or 0 if the stream is unbuffered.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getBufferStart - Return the beginning of the current stream
            /// buffer, or 0</para>
            /// <para>  /// if the stream is unbuffered.</para>
            /// </remarks>
            protected string getBufferStart()
            {
                var __ret = Internal.getBufferStart_0(__Instance);
                return Marshal.PtrToStringAnsi(__ret);
            }

            #region Virtual table interop

            // virtual ~raw_ostream()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
            private static _dtor_0Delegate _dtor_0DelegateInstance;

            private static void _dtor_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (raw_ostream) _References[instance].Target;
                __target.DestroyNativeInstance();
            }

            // raw_ostream &changeColor(enum Colors Color, bool Bold = false, bool BG = false)
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _changeColor_0Delegate(global::System.IntPtr instance, llvm.raw_ostream.Colors Color, bool Bold, bool BG);
            private static _changeColor_0Delegate _changeColor_0DelegateInstance;

            private static global::System.IntPtr _changeColor_0DelegateHook(global::System.IntPtr instance, llvm.raw_ostream.Colors Color, bool Bold, bool BG)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (raw_ostream) _References[instance].Target;
                var __ret = __target.changeColor(Color, Bold, BG);
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // raw_ostream &resetColor()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _resetColor_0Delegate(global::System.IntPtr instance);
            private static _resetColor_0Delegate _resetColor_0DelegateInstance;

            private static global::System.IntPtr _resetColor_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (raw_ostream) _References[instance].Target;
                var __ret = __target.resetColor();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // raw_ostream &reverseColor()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _reverseColor_0Delegate(global::System.IntPtr instance);
            private static _reverseColor_0Delegate _reverseColor_0DelegateInstance;

            private static global::System.IntPtr _reverseColor_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (raw_ostream) _References[instance].Target;
                var __ret = __target.reverseColor();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // bool is_displayed() const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate bool _is_displayed_0Delegate(global::System.IntPtr instance);
            private static _is_displayed_0Delegate _is_displayed_0DelegateInstance;

            private static bool _is_displayed_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (raw_ostream) _References[instance].Target;
                var __ret = __target.is_displayed();
                return __ret;
            }

            // bool has_colors() const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate bool _has_colors_0Delegate(global::System.IntPtr instance);
            private static _has_colors_0Delegate _has_colors_0DelegateInstance;

            private static bool _has_colors_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (raw_ostream) _References[instance].Target;
                var __ret = __target.has_colors();
                return __ret;
            }

            // size_t preferred_buffer_size() const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate ulong _preferred_buffer_size_0Delegate(global::System.IntPtr instance);
            private static _preferred_buffer_size_0Delegate _preferred_buffer_size_0DelegateInstance;

            private static ulong _preferred_buffer_size_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (raw_ostream) _References[instance].Target;
                var __ret = __target.preferred_buffer_size();
                return __ret;
            }

            private static void*[] _OldVTables;
            private static void*[] _NewVTables;
            private static void*[] _Thunks;
            private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

            void SetupVTables(global::System.IntPtr instance)
            {
                var native = (Internal*)instance.ToPointer();

                if (_References == null)
                    _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

                if (_References.ContainsKey(instance))
                    return;

                _References[instance] = new WeakReference(this);

                if (_OldVTables == null)
                {
                    _OldVTables = new void*[1];
                    _OldVTables[0] = native->vfptr0.ToPointer();
                }

                if (_Thunks == null)
                {
                    _Thunks = new void*[7];
                    _dtor_0DelegateInstance += _dtor_0DelegateHook;
                    _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                    _changeColor_0DelegateInstance += _changeColor_0DelegateHook;
                    _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_changeColor_0DelegateInstance).ToPointer();
                    _resetColor_0DelegateInstance += _resetColor_0DelegateHook;
                    _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_resetColor_0DelegateInstance).ToPointer();
                    _reverseColor_0DelegateInstance += _reverseColor_0DelegateHook;
                    _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_reverseColor_0DelegateInstance).ToPointer();
                    _is_displayed_0DelegateInstance += _is_displayed_0DelegateHook;
                    _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_is_displayed_0DelegateInstance).ToPointer();
                    _has_colors_0DelegateInstance += _has_colors_0DelegateHook;
                    _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_has_colors_0DelegateInstance).ToPointer();
                    _preferred_buffer_size_0DelegateInstance += _preferred_buffer_size_0DelegateHook;
                    _Thunks[6] = Marshal.GetFunctionPointerForDelegate(_preferred_buffer_size_0DelegateInstance).ToPointer();
                }

                if (_NewVTables == null)
                {
                    _NewVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(10 * 8);
                    _NewVTables[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + 8) = _Thunks[0];
                    *(void**)(vfptr0 + 16) = _Thunks[1];
                    *(void**)(vfptr0 + 24) = _Thunks[2];
                    *(void**)(vfptr0 + 32) = _Thunks[3];
                    *(void**)(vfptr0 + 40) = _Thunks[4];
                    *(void**)(vfptr0 + 48) = _Thunks[5];
                    *(void**)(vfptr0 + 56) = *(void**)(native->vfptr0 + 56);
                    *(void**)(vfptr0 + 64) = *(void**)(native->vfptr0 + 64);
                    *(void**)(vfptr0 + 72) = *(void**)(native->vfptr0 + 72);
                    *(void**)(vfptr0 + 80) = _Thunks[6];
                }

                native->vfptr0 = new IntPtr(_NewVTables[0]);
            }

            #endregion
        }

        /// <summary>
        /// <para>raw_fd_ostream - A raw_ostream that writes to a file
        /// descriptor.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// raw_fd_ostream - A raw_ostream that writes to a file
        /// descriptor.</para>
        /// <para>///</para>
        /// </remarks>
        public unsafe partial class raw_fd_ostream : llvm.raw_ostream, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 56)]
            public new partial struct Internal
            {
                [FieldOffset(8)]
                public sbyte* OutBufStart;

                [FieldOffset(16)]
                public sbyte* OutBufEnd;

                [FieldOffset(24)]
                public sbyte* OutBufCur;

                [FieldOffset(32)]
                public llvm.raw_ostream.BufferKind BufferMode;

                [FieldOffset(36)]
                public int FD;

                [FieldOffset(40)]
                public bool ShouldClose;

                [FieldOffset(41)]
                public bool Error;

                [FieldOffset(42)]
                public bool UseAtomicWrites;

                [FieldOffset(48)]
                public ulong pos;

                [FieldOffset(0)]
                public global::System.IntPtr vfptr0;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm14raw_fd_ostreamC2ENS_9StringRefERNSt3__110error_codeENS_3sys2fs9OpenFlagsE")]
                internal static extern void ctor_0(global::System.IntPtr instance, llvm.StringRef.Internal Filename, global::System.IntPtr EC, llvm.sys.fs.OpenFlags Flags);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm14raw_fd_ostreamC2Eibb")]
                internal static extern void ctor_1(global::System.IntPtr instance, int fd, bool shouldClose, bool unbuffered);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm14raw_fd_ostreamC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm14raw_fd_ostreamD2Ev")]
                internal static extern void dtor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm14raw_fd_ostream21preferred_buffer_sizeEv")]
                internal static extern ulong preferred_buffer_size_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm14raw_fd_ostream5closeEv")]
                internal static extern void close_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm14raw_fd_ostream4seekEy")]
                internal static extern ulong seek_0(global::System.IntPtr instance, ulong off);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm14raw_fd_ostream18SetUseAtomicWritesEb")]
                internal static extern void SetUseAtomicWrites_0(global::System.IntPtr instance, bool Value);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm14raw_fd_ostream11changeColorENS_11raw_ostream6ColorsEbb")]
                internal static extern global::System.IntPtr changeColor_0(global::System.IntPtr instance, llvm.raw_ostream.Colors colors, bool bold, bool bg);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm14raw_fd_ostream10resetColorEv")]
                internal static extern global::System.IntPtr resetColor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm14raw_fd_ostream12reverseColorEv")]
                internal static extern global::System.IntPtr reverseColor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm14raw_fd_ostream12is_displayedEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool is_displayed_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm14raw_fd_ostream10has_colorsEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool has_colors_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm14raw_fd_ostream9has_errorEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool has_error_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm14raw_fd_ostream11clear_errorEv")]
                internal static extern void clear_error_0(global::System.IntPtr instance);
            }

            private readonly bool __ownsNativeInstance;

            public static raw_fd_ostream __CreateInstance(global::System.IntPtr native)
            {
                return new raw_fd_ostream((raw_fd_ostream.Internal*) native);
            }

            public static raw_fd_ostream __CreateInstance(raw_fd_ostream.Internal native)
            {
                return new raw_fd_ostream(native);
            }

            private static raw_fd_ostream.Internal* __CopyValue(raw_fd_ostream.Internal native)
            {
                var ret = (raw_fd_ostream.Internal*) Marshal.AllocHGlobal(56);
                *ret = native;
                return ret;
            }

            private raw_fd_ostream(raw_fd_ostream.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected raw_fd_ostream(raw_fd_ostream.Internal* native, bool isInternalImpl = false)
                : base((llvm.raw_ostream.Internal*) native)
            {
            }

            /// <summary>
            /// <para>Open the specified file for writing. If an error occurs,
            /// information about the error is put into EC, and the stream should be
            /// immediately destroyed; Flags allows optional flags to control how the file
            /// will be opened.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Open the specified file for writing. If an error occurs,
            /// information</para>
            /// <para>  /// about the error is put into EC, and the stream should be
            /// immediately</para>
            /// <para>  /// destroyed;</para>
            /// <para>  /// \p Flags allows optional flags to control how the file will
            /// be opened.</para>
            /// <para>  ///</para>
            /// <para>  /// As a special case, if Filename is &quot;-&quot;, then the
            /// stream will use</para>
            /// <para>  /// STDOUT_FILENO instead of opening a file. Note that it will
            /// still consider</para>
            /// <para>  /// itself to own the file descriptor. In particular, it will
            /// close the</para>
            /// <para>  /// file descriptor when it is done (this is necessary to
            /// detect</para>
            /// <para>  /// output errors).</para>
            /// </remarks>
            public raw_fd_ostream(llvm.StringRef Filename, std.__1.error_code EC, llvm.sys.fs.OpenFlags Flags)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(56);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(Filename, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (Filename.__Instance);
                var arg1 = ReferenceEquals(EC, null) ? global::System.IntPtr.Zero : EC.__Instance;
                var arg2 = Flags;
                Internal.ctor_0(__Instance, arg0, arg1, arg2);
                SetupVTables(__Instance);
            }

            /// <summary>
            /// <para>raw_fd_ostream ctor - FD is the file descriptor that this writes
            /// to. If ShouldClose is true, this closes the file when the stream is
            /// destroyed.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// raw_fd_ostream ctor - FD is the file descriptor that this
            /// writes to.  If</para>
            /// <para>  /// ShouldClose is true, this closes the file when the stream
            /// is destroyed.</para>
            /// </remarks>
            public raw_fd_ostream(int fd, bool shouldClose, bool unbuffered)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(56);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_1(__Instance, fd, shouldClose, unbuffered);
                SetupVTables(__Instance);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                llvm.raw_ostream __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            /// <summary>
            /// <para>preferred_buffer_size - Determine an efficient buffer
            /// size.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// preferred_buffer_size - Determine an efficient buffer
            /// size.</para>
            /// </remarks>
            protected sealed override ulong preferred_buffer_size()
            {
                var __ret = Internal.preferred_buffer_size_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>close - Manually flush the stream and close the file. Note that
            /// this does not call fsync.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// close - Manually flush the stream and close the file.</para>
            /// <para>  /// Note that this does not call fsync.</para>
            /// </remarks>
            public void close()
            {
                Internal.close_0(__Instance);
            }

            /// <summary>
            /// <para>seek - Flushes the stream and repositions the underlying file
            /// descriptor position to the offset specified from the beginning of the
            /// file.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// seek - Flushes the stream and repositions the underlying file
            /// descriptor</para>
            /// <para>  /// position to the offset specified from the beginning of the
            /// file.</para>
            /// </remarks>
            public ulong seek(ulong off)
            {
                var arg0 = off;
                var __ret = Internal.seek_0(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>SetUseAtomicWrite - Set the stream to attempt to use atomic
            /// writes for individual output routines where possible.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// SetUseAtomicWrite - Set the stream to attempt to use atomic
            /// writes for</para>
            /// <para>  /// individual output routines where possible.</para>
            /// <para>  ///</para>
            /// <para>  /// Note that because raw_ostream's are typically buffered,
            /// this flag is only</para>
            /// <para>  /// sensible when used on unbuffered streams which will flush
            /// their output</para>
            /// <para>  /// immediately.</para>
            /// </remarks>
            public void SetUseAtomicWrites(bool Value)
            {
                Internal.SetUseAtomicWrites_0(__Instance, Value);
            }

            public override llvm.raw_ostream changeColor(llvm.raw_ostream.Colors colors, bool bold, bool bg)
            {
                var arg0 = colors;
                var __ret = Internal.changeColor_0(__Instance, arg0, bold, bg);
                llvm.raw_ostream __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (llvm.raw_ostream.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (llvm.raw_ostream) llvm.raw_ostream.NativeToManagedMap[__ret];
                else llvm.raw_ostream.NativeToManagedMap[__ret] = __result0 = (llvm.raw_ostream) llvm.raw_ostream.__CreateInstance(__ret);
                return __result0;
            }

            public override llvm.raw_ostream resetColor()
            {
                var __ret = Internal.resetColor_0(__Instance);
                llvm.raw_ostream __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (llvm.raw_ostream.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (llvm.raw_ostream) llvm.raw_ostream.NativeToManagedMap[__ret];
                else llvm.raw_ostream.NativeToManagedMap[__ret] = __result0 = (llvm.raw_ostream) llvm.raw_ostream.__CreateInstance(__ret);
                return __result0;
            }

            public override llvm.raw_ostream reverseColor()
            {
                var __ret = Internal.reverseColor_0(__Instance);
                llvm.raw_ostream __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (llvm.raw_ostream.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (llvm.raw_ostream) llvm.raw_ostream.NativeToManagedMap[__ret];
                else llvm.raw_ostream.NativeToManagedMap[__ret] = __result0 = (llvm.raw_ostream) llvm.raw_ostream.__CreateInstance(__ret);
                return __result0;
            }

            public override bool is_displayed()
            {
                var __ret = Internal.is_displayed_0(__Instance);
                return __ret;
            }

            public override bool has_colors()
            {
                var __ret = Internal.has_colors_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>has_error - Return the value of the flag in this raw_fd_ostream
            /// indicating whether an output error has been encountered. This doesn't
            /// implicitly flush any pending output. Also, it doesn't guarantee to detect
            /// all errors unless the stream has been closed.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// has_error - Return the value of the flag in this
            /// raw_fd_ostream indicating</para>
            /// <para>  /// whether an output error has been encountered.</para>
            /// <para>  /// This doesn't implicitly flush any pending output.  Also, it
            /// doesn't</para>
            /// <para>  /// guarantee to detect all errors unless the stream has been
            /// closed.</para>
            /// </remarks>
            public bool has_error()
            {
                var __ret = Internal.has_error_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>clear_error - Set the flag read by has_error() to false. If the
            /// error flag is set at the time when this raw_ostream's destructor is called,
            /// report_fatal_error is called to report the error. Use clear_error() after
            /// handling the error to avoid this behavior.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// clear_error - Set the flag read by has_error() to false. If
            /// the error</para>
            /// <para>  /// flag is set at the time when this raw_ostream's destructor
            /// is called,</para>
            /// <para>  /// report_fatal_error is called to report the error. Use
            /// clear_error()</para>
            /// <para>  /// after handling the error to avoid this behavior.</para>
            /// <para>  ///</para>
            /// <para>  ///   &quot;Errors should never pass silently.</para>
            /// <para>  ///    Unless explicitly silenced.&quot;</para>
            /// <para>  ///      - from The Zen of Python, by Tim Peters</para>
            /// <para>  ///</para>
            /// </remarks>
            public void clear_error()
            {
                Internal.clear_error_0(__Instance);
            }

            #region Virtual table interop

            // ~raw_fd_ostream()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
            private static _dtor_0Delegate _dtor_0DelegateInstance;

            private static void _dtor_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (raw_fd_ostream) _References[instance].Target;
                __target.DestroyNativeInstance();
            }

            // raw_ostream &changeColor(enum Colors colors, bool bold=false, bool bg=false) override
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _changeColor_0Delegate(global::System.IntPtr instance, llvm.raw_ostream.Colors colors, bool bold, bool bg);
            private static _changeColor_0Delegate _changeColor_0DelegateInstance;

            private static global::System.IntPtr _changeColor_0DelegateHook(global::System.IntPtr instance, llvm.raw_ostream.Colors colors, bool bold, bool bg)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (raw_fd_ostream) _References[instance].Target;
                var __ret = __target.changeColor(colors, bold, bg);
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // raw_ostream &resetColor() override
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _resetColor_0Delegate(global::System.IntPtr instance);
            private static _resetColor_0Delegate _resetColor_0DelegateInstance;

            private static global::System.IntPtr _resetColor_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (raw_fd_ostream) _References[instance].Target;
                var __ret = __target.resetColor();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // raw_ostream &reverseColor() override
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _reverseColor_0Delegate(global::System.IntPtr instance);
            private static _reverseColor_0Delegate _reverseColor_0DelegateInstance;

            private static global::System.IntPtr _reverseColor_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (raw_fd_ostream) _References[instance].Target;
                var __ret = __target.reverseColor();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // bool is_displayed() const override
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate bool _is_displayed_0Delegate(global::System.IntPtr instance);
            private static _is_displayed_0Delegate _is_displayed_0DelegateInstance;

            private static bool _is_displayed_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (raw_fd_ostream) _References[instance].Target;
                var __ret = __target.is_displayed();
                return __ret;
            }

            // bool has_colors() const override
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate bool _has_colors_0Delegate(global::System.IntPtr instance);
            private static _has_colors_0Delegate _has_colors_0DelegateInstance;

            private static bool _has_colors_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (raw_fd_ostream) _References[instance].Target;
                var __ret = __target.has_colors();
                return __ret;
            }

            // size_t preferred_buffer_size() const override
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate ulong _preferred_buffer_size_0Delegate(global::System.IntPtr instance);
            private static _preferred_buffer_size_0Delegate _preferred_buffer_size_0DelegateInstance;

            private static ulong _preferred_buffer_size_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (raw_fd_ostream) _References[instance].Target;
                var __ret = __target.preferred_buffer_size();
                return __ret;
            }

            private static void*[] _OldVTables;
            private static void*[] _NewVTables;
            private static void*[] _Thunks;
            private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

            void SetupVTables(global::System.IntPtr instance)
            {
                var native = (Internal*)instance.ToPointer();

                if (_References == null)
                    _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

                if (_References.ContainsKey(instance))
                    return;

                _References[instance] = new WeakReference(this);

                if (_OldVTables == null)
                {
                    _OldVTables = new void*[1];
                    _OldVTables[0] = native->vfptr0.ToPointer();
                }

                if (_Thunks == null)
                {
                    _Thunks = new void*[7];
                    _dtor_0DelegateInstance += _dtor_0DelegateHook;
                    _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                    _changeColor_0DelegateInstance += _changeColor_0DelegateHook;
                    _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_changeColor_0DelegateInstance).ToPointer();
                    _resetColor_0DelegateInstance += _resetColor_0DelegateHook;
                    _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_resetColor_0DelegateInstance).ToPointer();
                    _reverseColor_0DelegateInstance += _reverseColor_0DelegateHook;
                    _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_reverseColor_0DelegateInstance).ToPointer();
                    _is_displayed_0DelegateInstance += _is_displayed_0DelegateHook;
                    _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_is_displayed_0DelegateInstance).ToPointer();
                    _has_colors_0DelegateInstance += _has_colors_0DelegateHook;
                    _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_has_colors_0DelegateInstance).ToPointer();
                    _preferred_buffer_size_0DelegateInstance += _preferred_buffer_size_0DelegateHook;
                    _Thunks[6] = Marshal.GetFunctionPointerForDelegate(_preferred_buffer_size_0DelegateInstance).ToPointer();
                }

                if (_NewVTables == null)
                {
                    _NewVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(10 * 8);
                    _NewVTables[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + 8) = _Thunks[0];
                    *(void**)(vfptr0 + 16) = _Thunks[1];
                    *(void**)(vfptr0 + 24) = _Thunks[2];
                    *(void**)(vfptr0 + 32) = _Thunks[3];
                    *(void**)(vfptr0 + 40) = _Thunks[4];
                    *(void**)(vfptr0 + 48) = _Thunks[5];
                    *(void**)(vfptr0 + 56) = *(void**)(native->vfptr0 + 56);
                    *(void**)(vfptr0 + 64) = *(void**)(native->vfptr0 + 64);
                    *(void**)(vfptr0 + 72) = *(void**)(native->vfptr0 + 72);
                    *(void**)(vfptr0 + 80) = _Thunks[6];
                }

                native->vfptr0 = new IntPtr(_NewVTables[0]);
            }

            #endregion
        }

        /// <summary>
        /// <para>raw_string_ostream - A raw_ostream that writes to an std::string.
        /// This is a simple adaptor class. This class does not encounter output
        /// errors.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// raw_string_ostream - A raw_ostream that writes to an
        /// std::string.  This is a</para>
        /// <para>/// simple adaptor class. This class does not encounter output
        /// errors.</para>
        /// </remarks>
        public unsafe partial class raw_string_ostream : llvm.raw_ostream, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 48)]
            public new partial struct Internal
            {
                [FieldOffset(8)]
                public sbyte* OutBufStart;

                [FieldOffset(16)]
                public sbyte* OutBufEnd;

                [FieldOffset(24)]
                public sbyte* OutBufCur;

                [FieldOffset(32)]
                public llvm.raw_ostream.BufferKind BufferMode;

                [FieldOffset(40)]
                public global::System.IntPtr OS;

                [FieldOffset(0)]
                public global::System.IntPtr vfptr0;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm18raw_string_ostreamC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm18raw_string_ostreamD2Ev")]
                internal static extern void dtor_0(global::System.IntPtr instance);
            }

            private readonly bool __ownsNativeInstance;

            public static raw_string_ostream __CreateInstance(global::System.IntPtr native)
            {
                return new raw_string_ostream((raw_string_ostream.Internal*) native);
            }

            public static raw_string_ostream __CreateInstance(raw_string_ostream.Internal native)
            {
                return new raw_string_ostream(native);
            }

            private static raw_string_ostream.Internal* __CopyValue(raw_string_ostream.Internal native)
            {
                var ret = (raw_string_ostream.Internal*) Marshal.AllocHGlobal(48);
                *ret = native;
                return ret;
            }

            private raw_string_ostream(raw_string_ostream.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected raw_string_ostream(raw_string_ostream.Internal* native, bool isInternalImpl = false)
                : base((llvm.raw_ostream.Internal*) native)
            {
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                llvm.raw_ostream __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            #region Virtual table interop

            // ~raw_string_ostream()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
            private static _dtor_0Delegate _dtor_0DelegateInstance;

            private static void _dtor_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (raw_string_ostream) _References[instance].Target;
                __target.DestroyNativeInstance();
            }

            // raw_ostream &changeColor(enum Colors Color, bool Bold = false, bool BG = false)
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _changeColor_0Delegate(global::System.IntPtr instance, llvm.raw_ostream.Colors Color, bool Bold, bool BG);
            private static _changeColor_0Delegate _changeColor_0DelegateInstance;

            private static global::System.IntPtr _changeColor_0DelegateHook(global::System.IntPtr instance, llvm.raw_ostream.Colors Color, bool Bold, bool BG)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (raw_string_ostream) _References[instance].Target;
                var __ret = __target.changeColor(Color, Bold, BG);
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // raw_ostream &resetColor()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _resetColor_0Delegate(global::System.IntPtr instance);
            private static _resetColor_0Delegate _resetColor_0DelegateInstance;

            private static global::System.IntPtr _resetColor_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (raw_string_ostream) _References[instance].Target;
                var __ret = __target.resetColor();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // raw_ostream &reverseColor()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _reverseColor_0Delegate(global::System.IntPtr instance);
            private static _reverseColor_0Delegate _reverseColor_0DelegateInstance;

            private static global::System.IntPtr _reverseColor_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (raw_string_ostream) _References[instance].Target;
                var __ret = __target.reverseColor();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // bool is_displayed() const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate bool _is_displayed_0Delegate(global::System.IntPtr instance);
            private static _is_displayed_0Delegate _is_displayed_0DelegateInstance;

            private static bool _is_displayed_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (raw_string_ostream) _References[instance].Target;
                var __ret = __target.is_displayed();
                return __ret;
            }

            // bool has_colors() const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate bool _has_colors_0Delegate(global::System.IntPtr instance);
            private static _has_colors_0Delegate _has_colors_0DelegateInstance;

            private static bool _has_colors_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (raw_string_ostream) _References[instance].Target;
                var __ret = __target.has_colors();
                return __ret;
            }

            // size_t preferred_buffer_size() const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate ulong _preferred_buffer_size_0Delegate(global::System.IntPtr instance);
            private static _preferred_buffer_size_0Delegate _preferred_buffer_size_0DelegateInstance;

            private static ulong _preferred_buffer_size_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (raw_string_ostream) _References[instance].Target;
                var __ret = __target.preferred_buffer_size();
                return __ret;
            }

            private static void*[] _OldVTables;
            private static void*[] _NewVTables;
            private static void*[] _Thunks;
            private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

            void SetupVTables(global::System.IntPtr instance)
            {
                var native = (Internal*)instance.ToPointer();

                if (_References == null)
                    _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

                if (_References.ContainsKey(instance))
                    return;

                _References[instance] = new WeakReference(this);

                if (_OldVTables == null)
                {
                    _OldVTables = new void*[1];
                    _OldVTables[0] = native->vfptr0.ToPointer();
                }

                if (_Thunks == null)
                {
                    _Thunks = new void*[7];
                    _dtor_0DelegateInstance += _dtor_0DelegateHook;
                    _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                    _changeColor_0DelegateInstance += _changeColor_0DelegateHook;
                    _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_changeColor_0DelegateInstance).ToPointer();
                    _resetColor_0DelegateInstance += _resetColor_0DelegateHook;
                    _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_resetColor_0DelegateInstance).ToPointer();
                    _reverseColor_0DelegateInstance += _reverseColor_0DelegateHook;
                    _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_reverseColor_0DelegateInstance).ToPointer();
                    _is_displayed_0DelegateInstance += _is_displayed_0DelegateHook;
                    _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_is_displayed_0DelegateInstance).ToPointer();
                    _has_colors_0DelegateInstance += _has_colors_0DelegateHook;
                    _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_has_colors_0DelegateInstance).ToPointer();
                    _preferred_buffer_size_0DelegateInstance += _preferred_buffer_size_0DelegateHook;
                    _Thunks[6] = Marshal.GetFunctionPointerForDelegate(_preferred_buffer_size_0DelegateInstance).ToPointer();
                }

                if (_NewVTables == null)
                {
                    _NewVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(10 * 8);
                    _NewVTables[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + 8) = _Thunks[0];
                    *(void**)(vfptr0 + 16) = _Thunks[1];
                    *(void**)(vfptr0 + 24) = _Thunks[2];
                    *(void**)(vfptr0 + 32) = _Thunks[3];
                    *(void**)(vfptr0 + 40) = _Thunks[4];
                    *(void**)(vfptr0 + 48) = _Thunks[5];
                    *(void**)(vfptr0 + 56) = *(void**)(native->vfptr0 + 56);
                    *(void**)(vfptr0 + 64) = *(void**)(native->vfptr0 + 64);
                    *(void**)(vfptr0 + 72) = *(void**)(native->vfptr0 + 72);
                    *(void**)(vfptr0 + 80) = _Thunks[6];
                }

                native->vfptr0 = new IntPtr(_NewVTables[0]);
            }

            #endregion
        }

        /// <summary>
        /// <para>raw_svector_ostream - A raw_ostream that writes to an SmallVector
        /// or SmallString. This is a simple adaptor class. This class does not
        /// encounter output errors.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// raw_svector_ostream - A raw_ostream that writes to an
        /// SmallVector or</para>
        /// <para>/// SmallString.  This is a simple adaptor class. This class does
        /// not</para>
        /// <para>/// encounter output errors.</para>
        /// </remarks>
        public unsafe partial class raw_svector_ostream : llvm.raw_ostream, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 48)]
            public new partial struct Internal
            {
                [FieldOffset(8)]
                public sbyte* OutBufStart;

                [FieldOffset(16)]
                public sbyte* OutBufEnd;

                [FieldOffset(24)]
                public sbyte* OutBufCur;

                [FieldOffset(32)]
                public llvm.raw_ostream.BufferKind BufferMode;

                [FieldOffset(40)]
                public global::System.IntPtr OS;

                [FieldOffset(0)]
                public global::System.IntPtr vfptr0;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm19raw_svector_ostreamC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm19raw_svector_ostreamD2Ev")]
                internal static extern void dtor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm19raw_svector_ostream6resyncEv")]
                internal static extern void resync_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm19raw_svector_ostream3strEv")]
                internal static extern llvm.StringRef.Internal str_0(global::System.IntPtr instance);
            }

            private readonly bool __ownsNativeInstance;

            public static raw_svector_ostream __CreateInstance(global::System.IntPtr native)
            {
                return new raw_svector_ostream((raw_svector_ostream.Internal*) native);
            }

            public static raw_svector_ostream __CreateInstance(raw_svector_ostream.Internal native)
            {
                return new raw_svector_ostream(native);
            }

            private static raw_svector_ostream.Internal* __CopyValue(raw_svector_ostream.Internal native)
            {
                var ret = (raw_svector_ostream.Internal*) Marshal.AllocHGlobal(48);
                *ret = native;
                return ret;
            }

            private raw_svector_ostream(raw_svector_ostream.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected raw_svector_ostream(raw_svector_ostream.Internal* native, bool isInternalImpl = false)
                : base((llvm.raw_ostream.Internal*) native)
            {
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                llvm.raw_ostream __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            /// <summary>
            /// <para>resync - This is called when the SmallVector we're appending to
            /// is changed outside of the raw_svector_ostream's control. It is only safe to
            /// do this if the raw_svector_ostream has previously been flushed.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// resync - This is called when the SmallVector we're appending
            /// to is changed</para>
            /// <para>  /// outside of the raw_svector_ostream's control.  It is only
            /// safe to do this</para>
            /// <para>  /// if the raw_svector_ostream has previously been
            /// flushed.</para>
            /// </remarks>
            public void resync()
            {
                Internal.resync_0(__Instance);
            }

            /// <summary>
            /// <para>str - Flushes the stream contents to the target vector and return
            /// a StringRef for the vector contents.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// str - Flushes the stream contents to the target vector and
            /// return a</para>
            /// <para>  /// StringRef for the vector contents.</para>
            /// </remarks>
            public llvm.StringRef str()
            {
                var __ret = Internal.str_0(__Instance);
                return llvm.StringRef.__CreateInstance(__ret);
            }

            #region Virtual table interop

            // ~raw_svector_ostream()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
            private static _dtor_0Delegate _dtor_0DelegateInstance;

            private static void _dtor_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (raw_svector_ostream) _References[instance].Target;
                __target.DestroyNativeInstance();
            }

            // raw_ostream &changeColor(enum Colors Color, bool Bold = false, bool BG = false)
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _changeColor_0Delegate(global::System.IntPtr instance, llvm.raw_ostream.Colors Color, bool Bold, bool BG);
            private static _changeColor_0Delegate _changeColor_0DelegateInstance;

            private static global::System.IntPtr _changeColor_0DelegateHook(global::System.IntPtr instance, llvm.raw_ostream.Colors Color, bool Bold, bool BG)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (raw_svector_ostream) _References[instance].Target;
                var __ret = __target.changeColor(Color, Bold, BG);
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // raw_ostream &resetColor()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _resetColor_0Delegate(global::System.IntPtr instance);
            private static _resetColor_0Delegate _resetColor_0DelegateInstance;

            private static global::System.IntPtr _resetColor_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (raw_svector_ostream) _References[instance].Target;
                var __ret = __target.resetColor();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // raw_ostream &reverseColor()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _reverseColor_0Delegate(global::System.IntPtr instance);
            private static _reverseColor_0Delegate _reverseColor_0DelegateInstance;

            private static global::System.IntPtr _reverseColor_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (raw_svector_ostream) _References[instance].Target;
                var __ret = __target.reverseColor();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // bool is_displayed() const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate bool _is_displayed_0Delegate(global::System.IntPtr instance);
            private static _is_displayed_0Delegate _is_displayed_0DelegateInstance;

            private static bool _is_displayed_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (raw_svector_ostream) _References[instance].Target;
                var __ret = __target.is_displayed();
                return __ret;
            }

            // bool has_colors() const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate bool _has_colors_0Delegate(global::System.IntPtr instance);
            private static _has_colors_0Delegate _has_colors_0DelegateInstance;

            private static bool _has_colors_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (raw_svector_ostream) _References[instance].Target;
                var __ret = __target.has_colors();
                return __ret;
            }

            // size_t preferred_buffer_size() const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate ulong _preferred_buffer_size_0Delegate(global::System.IntPtr instance);
            private static _preferred_buffer_size_0Delegate _preferred_buffer_size_0DelegateInstance;

            private static ulong _preferred_buffer_size_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (raw_svector_ostream) _References[instance].Target;
                var __ret = __target.preferred_buffer_size();
                return __ret;
            }

            private static void*[] _OldVTables;
            private static void*[] _NewVTables;
            private static void*[] _Thunks;
            private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

            void SetupVTables(global::System.IntPtr instance)
            {
                var native = (Internal*)instance.ToPointer();

                if (_References == null)
                    _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

                if (_References.ContainsKey(instance))
                    return;

                _References[instance] = new WeakReference(this);

                if (_OldVTables == null)
                {
                    _OldVTables = new void*[1];
                    _OldVTables[0] = native->vfptr0.ToPointer();
                }

                if (_Thunks == null)
                {
                    _Thunks = new void*[7];
                    _dtor_0DelegateInstance += _dtor_0DelegateHook;
                    _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                    _changeColor_0DelegateInstance += _changeColor_0DelegateHook;
                    _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_changeColor_0DelegateInstance).ToPointer();
                    _resetColor_0DelegateInstance += _resetColor_0DelegateHook;
                    _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_resetColor_0DelegateInstance).ToPointer();
                    _reverseColor_0DelegateInstance += _reverseColor_0DelegateHook;
                    _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_reverseColor_0DelegateInstance).ToPointer();
                    _is_displayed_0DelegateInstance += _is_displayed_0DelegateHook;
                    _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_is_displayed_0DelegateInstance).ToPointer();
                    _has_colors_0DelegateInstance += _has_colors_0DelegateHook;
                    _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_has_colors_0DelegateInstance).ToPointer();
                    _preferred_buffer_size_0DelegateInstance += _preferred_buffer_size_0DelegateHook;
                    _Thunks[6] = Marshal.GetFunctionPointerForDelegate(_preferred_buffer_size_0DelegateInstance).ToPointer();
                }

                if (_NewVTables == null)
                {
                    _NewVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(10 * 8);
                    _NewVTables[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + 8) = _Thunks[0];
                    *(void**)(vfptr0 + 16) = _Thunks[1];
                    *(void**)(vfptr0 + 24) = _Thunks[2];
                    *(void**)(vfptr0 + 32) = _Thunks[3];
                    *(void**)(vfptr0 + 40) = _Thunks[4];
                    *(void**)(vfptr0 + 48) = _Thunks[5];
                    *(void**)(vfptr0 + 56) = *(void**)(native->vfptr0 + 56);
                    *(void**)(vfptr0 + 64) = *(void**)(native->vfptr0 + 64);
                    *(void**)(vfptr0 + 72) = *(void**)(native->vfptr0 + 72);
                    *(void**)(vfptr0 + 80) = _Thunks[6];
                }

                native->vfptr0 = new IntPtr(_NewVTables[0]);
            }

            #endregion
        }

        /// <summary>
        /// <para>raw_null_ostream - A raw_ostream that discards all output.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// raw_null_ostream - A raw_ostream that discards all
        /// output.</para>
        /// </remarks>
        public unsafe partial class raw_null_ostream : llvm.raw_ostream, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 40)]
            public new partial struct Internal
            {
                [FieldOffset(8)]
                public sbyte* OutBufStart;

                [FieldOffset(16)]
                public sbyte* OutBufEnd;

                [FieldOffset(24)]
                public sbyte* OutBufCur;

                [FieldOffset(32)]
                public llvm.raw_ostream.BufferKind BufferMode;

                [FieldOffset(0)]
                public global::System.IntPtr vfptr0;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm16raw_null_ostreamC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm16raw_null_ostreamC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm16raw_null_ostreamD2Ev")]
                internal static extern void dtor_0(global::System.IntPtr instance);
            }

            private readonly bool __ownsNativeInstance;

            public static raw_null_ostream __CreateInstance(global::System.IntPtr native)
            {
                return new raw_null_ostream((raw_null_ostream.Internal*) native);
            }

            public static raw_null_ostream __CreateInstance(raw_null_ostream.Internal native)
            {
                return new raw_null_ostream(native);
            }

            private static raw_null_ostream.Internal* __CopyValue(raw_null_ostream.Internal native)
            {
                var ret = (raw_null_ostream.Internal*) Marshal.AllocHGlobal(40);
                *ret = native;
                return ret;
            }

            private raw_null_ostream(raw_null_ostream.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected raw_null_ostream(raw_null_ostream.Internal* native, bool isInternalImpl = false)
                : base((llvm.raw_ostream.Internal*) native)
            {
            }

            public raw_null_ostream()
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(40);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
                SetupVTables(__Instance);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                llvm.raw_ostream __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            #region Virtual table interop

            // ~raw_null_ostream()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
            private static _dtor_0Delegate _dtor_0DelegateInstance;

            private static void _dtor_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (raw_null_ostream) _References[instance].Target;
                __target.DestroyNativeInstance();
            }

            // raw_ostream &changeColor(enum Colors Color, bool Bold = false, bool BG = false)
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _changeColor_0Delegate(global::System.IntPtr instance, llvm.raw_ostream.Colors Color, bool Bold, bool BG);
            private static _changeColor_0Delegate _changeColor_0DelegateInstance;

            private static global::System.IntPtr _changeColor_0DelegateHook(global::System.IntPtr instance, llvm.raw_ostream.Colors Color, bool Bold, bool BG)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (raw_null_ostream) _References[instance].Target;
                var __ret = __target.changeColor(Color, Bold, BG);
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // raw_ostream &resetColor()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _resetColor_0Delegate(global::System.IntPtr instance);
            private static _resetColor_0Delegate _resetColor_0DelegateInstance;

            private static global::System.IntPtr _resetColor_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (raw_null_ostream) _References[instance].Target;
                var __ret = __target.resetColor();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // raw_ostream &reverseColor()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _reverseColor_0Delegate(global::System.IntPtr instance);
            private static _reverseColor_0Delegate _reverseColor_0DelegateInstance;

            private static global::System.IntPtr _reverseColor_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (raw_null_ostream) _References[instance].Target;
                var __ret = __target.reverseColor();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // bool is_displayed() const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate bool _is_displayed_0Delegate(global::System.IntPtr instance);
            private static _is_displayed_0Delegate _is_displayed_0DelegateInstance;

            private static bool _is_displayed_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (raw_null_ostream) _References[instance].Target;
                var __ret = __target.is_displayed();
                return __ret;
            }

            // bool has_colors() const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate bool _has_colors_0Delegate(global::System.IntPtr instance);
            private static _has_colors_0Delegate _has_colors_0DelegateInstance;

            private static bool _has_colors_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (raw_null_ostream) _References[instance].Target;
                var __ret = __target.has_colors();
                return __ret;
            }

            // size_t preferred_buffer_size() const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate ulong _preferred_buffer_size_0Delegate(global::System.IntPtr instance);
            private static _preferred_buffer_size_0Delegate _preferred_buffer_size_0DelegateInstance;

            private static ulong _preferred_buffer_size_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (raw_null_ostream) _References[instance].Target;
                var __ret = __target.preferred_buffer_size();
                return __ret;
            }

            private static void*[] _OldVTables;
            private static void*[] _NewVTables;
            private static void*[] _Thunks;
            private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

            void SetupVTables(global::System.IntPtr instance)
            {
                var native = (Internal*)instance.ToPointer();

                if (_References == null)
                    _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

                if (_References.ContainsKey(instance))
                    return;

                _References[instance] = new WeakReference(this);

                if (_OldVTables == null)
                {
                    _OldVTables = new void*[1];
                    _OldVTables[0] = native->vfptr0.ToPointer();
                }

                if (_Thunks == null)
                {
                    _Thunks = new void*[7];
                    _dtor_0DelegateInstance += _dtor_0DelegateHook;
                    _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                    _changeColor_0DelegateInstance += _changeColor_0DelegateHook;
                    _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_changeColor_0DelegateInstance).ToPointer();
                    _resetColor_0DelegateInstance += _resetColor_0DelegateHook;
                    _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_resetColor_0DelegateInstance).ToPointer();
                    _reverseColor_0DelegateInstance += _reverseColor_0DelegateHook;
                    _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_reverseColor_0DelegateInstance).ToPointer();
                    _is_displayed_0DelegateInstance += _is_displayed_0DelegateHook;
                    _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_is_displayed_0DelegateInstance).ToPointer();
                    _has_colors_0DelegateInstance += _has_colors_0DelegateHook;
                    _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_has_colors_0DelegateInstance).ToPointer();
                    _preferred_buffer_size_0DelegateInstance += _preferred_buffer_size_0DelegateHook;
                    _Thunks[6] = Marshal.GetFunctionPointerForDelegate(_preferred_buffer_size_0DelegateInstance).ToPointer();
                }

                if (_NewVTables == null)
                {
                    _NewVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(10 * 8);
                    _NewVTables[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + 8) = _Thunks[0];
                    *(void**)(vfptr0 + 16) = _Thunks[1];
                    *(void**)(vfptr0 + 24) = _Thunks[2];
                    *(void**)(vfptr0 + 32) = _Thunks[3];
                    *(void**)(vfptr0 + 40) = _Thunks[4];
                    *(void**)(vfptr0 + 48) = _Thunks[5];
                    *(void**)(vfptr0 + 56) = *(void**)(native->vfptr0 + 56);
                    *(void**)(vfptr0 + 64) = *(void**)(native->vfptr0 + 64);
                    *(void**)(vfptr0 + 72) = *(void**)(native->vfptr0 + 72);
                    *(void**)(vfptr0 + 80) = _Thunks[6];
                }

                native->vfptr0 = new IntPtr(_NewVTables[0]);
            }

            #endregion
        }

        internal unsafe partial class raw_ostreamInternal : llvm.raw_ostream, IDisposable
        {
            private readonly bool __ownsNativeInstance;

            private static raw_ostream.Internal* __CopyValue(raw_ostream.Internal native)
            {
                var ret = (raw_ostream.Internal*) Marshal.AllocHGlobal(40);
                *ret = native;
                return ret;
            }

            internal raw_ostreamInternal(raw_ostream.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            internal raw_ostreamInternal(raw_ostream.Internal* native, bool isInternalImpl = false)
                : base((llvm.raw_ostream.Internal*) native, true)
            {
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                llvm.raw_ostream __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }
        }

        public unsafe partial class raw_ostream
        {
            public partial struct Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm4outsEv")]
                internal static extern global::System.IntPtr outs_0();

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm4errsEv")]
                internal static extern global::System.IntPtr errs_0();

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm5nullsEv")]
                internal static extern global::System.IntPtr nulls_0();
            }

            /// <summary>
            /// <para>outs() - This returns a reference to a raw_ostream for standard
            /// output. Use it like: outs() &lt;&lt; &quot;foo&quot; &lt;&lt;
            /// &quot;bar&quot;;</para>
            /// </summary>
            /// <remarks>
            /// <para>/// outs() - This returns a reference to a raw_ostream for
            /// standard output.</para>
            /// <para>/// Use it like: outs() &lt;&lt; &quot;foo&quot; &lt;&lt;
            /// &quot;bar&quot;;</para>
            /// </remarks>
            public static llvm.raw_ostream outs()
            {
                var __ret = Internal.outs_0();
                llvm.raw_ostream __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (llvm.raw_ostream.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (llvm.raw_ostream) llvm.raw_ostream.NativeToManagedMap[__ret];
                else llvm.raw_ostream.NativeToManagedMap[__ret] = __result0 = (llvm.raw_ostream) llvm.raw_ostream.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>errs() - This returns a reference to a raw_ostream for standard
            /// error. Use it like: errs() &lt;&lt; &quot;foo&quot; &lt;&lt;
            /// &quot;bar&quot;;</para>
            /// </summary>
            /// <remarks>
            /// <para>/// errs() - This returns a reference to a raw_ostream for
            /// standard error.</para>
            /// <para>/// Use it like: errs() &lt;&lt; &quot;foo&quot; &lt;&lt;
            /// &quot;bar&quot;;</para>
            /// </remarks>
            public static llvm.raw_ostream errs()
            {
                var __ret = Internal.errs_0();
                llvm.raw_ostream __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (llvm.raw_ostream.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (llvm.raw_ostream) llvm.raw_ostream.NativeToManagedMap[__ret];
                else llvm.raw_ostream.NativeToManagedMap[__ret] = __result0 = (llvm.raw_ostream) llvm.raw_ostream.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>nulls() - This returns a reference to a raw_ostream which simply
            /// discards output.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// nulls() - This returns a reference to a raw_ostream which
            /// simply discards</para>
            /// <para>/// output.</para>
            /// </remarks>
            public static llvm.raw_ostream nulls()
            {
                var __ret = Internal.nulls_0();
                llvm.raw_ostream __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (llvm.raw_ostream.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (llvm.raw_ostream) llvm.raw_ostream.NativeToManagedMap[__ret];
                else llvm.raw_ostream.NativeToManagedMap[__ret] = __result0 = (llvm.raw_ostream) llvm.raw_ostream.__CreateInstance(__ret);
                return __result0;
            }
        }

        namespace sys
        {
            namespace fs
            {
            }
        }
    }
}
