//----------------------------------------------------------------------------
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
//----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace CppSharp
{
    public unsafe partial class Diagnostic
    {
        public partial struct Internal
        {
        }
    }

    namespace clang
    {
        /// <summary>
        /// <para>Annotates a diagnostic with some code that should be inserted,
        /// removed, or replaced to fix the problem.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief Annotates a diagnostic with some code that should
        /// be</para>
        /// <para>/// inserted, removed, or replaced to fix the problem.</para>
        /// <para>///</para>
        /// <para>/// This kind of hint should be used when we are certain that
        /// the</para>
        /// <para>/// introduction, removal, or modification of a particular
        /// (small!)</para>
        /// <para>/// amount of code will correct a compilation error. The
        /// compiler</para>
        /// <para>/// should also provide full recovery from such errors, such
        /// that</para>
        /// <para>/// suppressing the diagnostic output can still result in
        /// successful</para>
        /// <para>/// compilation.</para>
        /// </remarks>
        public unsafe partial class FixItHint : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 56)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public clang.CharSourceRange.Internal RemoveRange;

                [FieldOffset(12)]
                public clang.CharSourceRange.Internal InsertFromRange;

                [FieldOffset(48)]
                public bool BeforePreviousInsertions;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9FixItHintC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9FixItHintC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9FixItHintD2Ev")]
                internal static extern void dtor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9FixItHint6isNullEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isNull_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9FixItHint15CreateInsertionENS_14SourceLocationEN4llvm9StringRefEb")]
                internal static extern void CreateInsertion_0(global::System.IntPtr @return, clang.SourceLocation.Internal InsertionLoc, llvm.StringRef.Internal Code, bool BeforePreviousInsertions);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9FixItHint24CreateInsertionFromRangeENS_14SourceLocationENS_15CharSourceRangeEb")]
                internal static extern void CreateInsertionFromRange_0(global::System.IntPtr @return, clang.SourceLocation.Internal InsertionLoc, clang.CharSourceRange.Internal FromRange, bool BeforePreviousInsertions);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9FixItHint13CreateRemovalENS_15CharSourceRangeE")]
                internal static extern void CreateRemoval_0(global::System.IntPtr @return, clang.CharSourceRange.Internal RemoveRange);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9FixItHint13CreateRemovalENS_11SourceRangeE")]
                internal static extern void CreateRemoval_1(global::System.IntPtr @return, clang.SourceRange.Internal RemoveRange);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9FixItHint17CreateReplacementENS_15CharSourceRangeEN4llvm9StringRefE")]
                internal static extern void CreateReplacement_0(global::System.IntPtr @return, clang.CharSourceRange.Internal RemoveRange, llvm.StringRef.Internal Code);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9FixItHint17CreateReplacementENS_11SourceRangeEN4llvm9StringRefE")]
                internal static extern void CreateReplacement_1(global::System.IntPtr @return, clang.SourceRange.Internal RemoveRange, llvm.StringRef.Internal Code);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, FixItHint> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, FixItHint>();

            private readonly bool __ownsNativeInstance;

            public static FixItHint __CreateInstance(global::System.IntPtr native)
            {
                return new FixItHint((FixItHint.Internal*) native);
            }

            public static FixItHint __CreateInstance(FixItHint.Internal native)
            {
                return new FixItHint(native);
            }

            private static FixItHint.Internal* __CopyValue(FixItHint.Internal native)
            {
                var ret = (FixItHint.Internal*) Marshal.AllocHGlobal(56);
                *ret = native;
                return ret;
            }

            private FixItHint(FixItHint.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected FixItHint(FixItHint.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            /// <summary>
            /// <para>Empty code modification hint, indicating that no code
            /// modification is known.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Empty code modification hint, indicating that no
            /// code</para>
            /// <para>  /// modification is known.</para>
            /// </remarks>
            public FixItHint()
            {
                __Instance = Marshal.AllocHGlobal(56);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.FixItHint __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance || force)
                    Internal.dtor_0(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public bool isNull()
            {
                var __ret = Internal.isNull_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Create a code modification hint that inserts the given code
            /// string at a specific location.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Create a code modification hint that inserts the
            /// given</para>
            /// <para>  /// code string at a specific location.</para>
            /// </remarks>
            public static clang.FixItHint CreateInsertion(clang.SourceLocation InsertionLoc, llvm.StringRef Code, bool BeforePreviousInsertions)
            {
                var arg0 = ReferenceEquals(InsertionLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (InsertionLoc.__Instance);
                var arg1 = ReferenceEquals(Code, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (Code.__Instance);
                var __ret = new clang.FixItHint.Internal();
                Internal.CreateInsertion_0(new IntPtr(&__ret), arg0, arg1, BeforePreviousInsertions);
                return clang.FixItHint.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Create a code modification hint that inserts the given code from
            /// FromRange at a specific location.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Create a code modification hint that inserts the
            /// given</para>
            /// <para>  /// code from \p FromRange at a specific location.</para>
            /// </remarks>
            public static clang.FixItHint CreateInsertionFromRange(clang.SourceLocation InsertionLoc, clang.CharSourceRange FromRange, bool BeforePreviousInsertions)
            {
                var arg0 = ReferenceEquals(InsertionLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (InsertionLoc.__Instance);
                var arg1 = ReferenceEquals(FromRange, null) ? new clang.CharSourceRange.Internal() : *(clang.CharSourceRange.Internal*) (FromRange.__Instance);
                var __ret = new clang.FixItHint.Internal();
                Internal.CreateInsertionFromRange_0(new IntPtr(&__ret), arg0, arg1, BeforePreviousInsertions);
                return clang.FixItHint.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Create a code modification hint that removes the given source
            /// range.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Create a code modification hint that removes the
            /// given</para>
            /// <para>  /// source range.</para>
            /// </remarks>
            public static clang.FixItHint CreateRemoval(clang.CharSourceRange RemoveRange)
            {
                var arg0 = ReferenceEquals(RemoveRange, null) ? new clang.CharSourceRange.Internal() : *(clang.CharSourceRange.Internal*) (RemoveRange.__Instance);
                var __ret = new clang.FixItHint.Internal();
                Internal.CreateRemoval_0(new IntPtr(&__ret), arg0);
                return clang.FixItHint.__CreateInstance(__ret);
            }

            public static clang.FixItHint CreateRemoval(clang.SourceRange RemoveRange)
            {
                var arg0 = ReferenceEquals(RemoveRange, null) ? new clang.SourceRange.Internal() : *(clang.SourceRange.Internal*) (RemoveRange.__Instance);
                var __ret = new clang.FixItHint.Internal();
                Internal.CreateRemoval_1(new IntPtr(&__ret), arg0);
                return clang.FixItHint.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Create a code modification hint that replaces the given source
            /// range with the given code string.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Create a code modification hint that replaces the
            /// given</para>
            /// <para>  /// source range with the given code string.</para>
            /// </remarks>
            public static clang.FixItHint CreateReplacement(clang.CharSourceRange RemoveRange, llvm.StringRef Code)
            {
                var arg0 = ReferenceEquals(RemoveRange, null) ? new clang.CharSourceRange.Internal() : *(clang.CharSourceRange.Internal*) (RemoveRange.__Instance);
                var arg1 = ReferenceEquals(Code, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (Code.__Instance);
                var __ret = new clang.FixItHint.Internal();
                Internal.CreateReplacement_0(new IntPtr(&__ret), arg0, arg1);
                return clang.FixItHint.__CreateInstance(__ret);
            }

            public static clang.FixItHint CreateReplacement(clang.SourceRange RemoveRange, llvm.StringRef Code)
            {
                var arg0 = ReferenceEquals(RemoveRange, null) ? new clang.SourceRange.Internal() : *(clang.SourceRange.Internal*) (RemoveRange.__Instance);
                var arg1 = ReferenceEquals(Code, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (Code.__Instance);
                var __ret = new clang.FixItHint.Internal();
                Internal.CreateReplacement_1(new IntPtr(&__ret), arg0, arg1);
                return clang.FixItHint.__CreateInstance(__ret);
            }

            public clang.CharSourceRange RemoveRange
            {
                get
                {
                    return clang.CharSourceRange.__CreateInstance(((Internal*) __Instance)->RemoveRange);
                }

                set
                {
                    ((Internal*) __Instance)->RemoveRange = ReferenceEquals(value, null) ? new clang.CharSourceRange.Internal() : *(clang.CharSourceRange.Internal*) (value.__Instance);
                }
            }

            public clang.CharSourceRange InsertFromRange
            {
                get
                {
                    return clang.CharSourceRange.__CreateInstance(((Internal*) __Instance)->InsertFromRange);
                }

                set
                {
                    ((Internal*) __Instance)->InsertFromRange = ReferenceEquals(value, null) ? new clang.CharSourceRange.Internal() : *(clang.CharSourceRange.Internal*) (value.__Instance);
                }
            }

            public bool BeforePreviousInsertions
            {
                get
                {
                    return ((Internal*) __Instance)->BeforePreviousInsertions;
                }

                set
                {
                    ((Internal*) __Instance)->BeforePreviousInsertions = value;
                }
            }
        }

        /// <summary>
        /// <para>Concrete class used by the front-end to report problems and
        /// issues.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief Concrete class used by the front-end to report
        /// problems and issues.</para>
        /// <para>///</para>
        /// <para>/// This massages the diagnostics (e.g. handling things like
        /// &quot;report warnings</para>
        /// <para>/// as errors&quot; and passes them off to the DiagnosticConsumer
        /// for reporting to</para>
        /// <para>/// the user. DiagnosticsEngine is tied to one translation unit
        /// and one</para>
        /// <para>/// SourceManager.</para>
        /// </remarks>
        public unsafe partial class DiagnosticsEngine : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 1208)]
            public partial struct Internal
            {
                [FieldOffset(4)]
                public byte AllExtensionsSilenced;

                [FieldOffset(5)]
                public bool IgnoreAllWarnings;

                [FieldOffset(6)]
                public bool WarningsAsErrors;

                [FieldOffset(7)]
                public bool EnableAllWarnings;

                [FieldOffset(8)]
                public bool ErrorsAsFatal;

                [FieldOffset(9)]
                public bool SuppressSystemWarnings;

                [FieldOffset(10)]
                public bool SuppressAllDiagnostics;

                [FieldOffset(11)]
                public bool ElideType;

                [FieldOffset(12)]
                public bool PrintTemplateTree;

                [FieldOffset(13)]
                public bool ShowColors;

                [FieldOffset(16)]
                public clang.OverloadsShown ShowOverloads;

                [FieldOffset(20)]
                public uint ErrorLimit;

                [FieldOffset(24)]
                public uint TemplateBacktraceLimit;

                [FieldOffset(28)]
                public uint ConstexprBacktraceLimit;

                [FieldOffset(32)]
                public clang.diag.Severity ExtBehavior;

                [FieldOffset(40)]
                internal llvm.IntrusiveRefCntPtr.Internal Diags;

                [FieldOffset(48)]
                internal llvm.IntrusiveRefCntPtr.Internal DiagOpts;

                [FieldOffset(56)]
                public global::System.IntPtr Client;

                [FieldOffset(72)]
                public global::System.IntPtr SourceMgr;

                [FieldOffset(152)]
                public bool ErrorOccurred;

                [FieldOffset(153)]
                public bool UncompilableErrorOccurred;

                [FieldOffset(154)]
                public bool FatalErrorOccurred;

                [FieldOffset(155)]
                public bool UnrecoverableErrorOccurred;

                [FieldOffset(156)]
                public uint TrapNumErrorsOccurred;

                [FieldOffset(160)]
                public uint TrapNumUnrecoverableErrorsOccurred;

                [FieldOffset(164)]
                public clang.DiagnosticIDs.Level LastDiagLevel;

                [FieldOffset(168)]
                public uint NumWarnings;

                [FieldOffset(172)]
                public uint NumErrors;

                [FieldOffset(176)]
                public global::System.IntPtr ArgToStringCookie;

                [FieldOffset(184)]
                public global::System.IntPtr ArgToStringFn;

                [FieldOffset(192)]
                public uint DelayedDiagID;

                [FieldOffset(272)]
                public clang.SourceLocation.Internal CurDiagLoc;

                [FieldOffset(276)]
                public uint CurDiagID;

                [FieldOffset(280)]
                public sbyte NumDiagArgs;

                [FieldOffset(281)]
                public fixed byte DiagArgumentsKind[10];

                [FieldOffset(296)]
                public fixed byte DiagArgumentsStr[0];

                [FieldOffset(536)]
                public fixed long DiagArgumentsVal[10];

                [FieldOffset(616)]
                internal llvm.SmallVector.Internal DiagRanges;

                [FieldOffset(736)]
                internal llvm.SmallVector.Internal DiagFixItHints;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17DiagnosticsEngineD2Ev")]
                internal static extern void dtor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17DiagnosticsEngine20getDiagnosticOptionsEv")]
                internal static extern global::System.IntPtr getDiagnosticOptions_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17DiagnosticsEngine9getClientEv")]
                internal static extern global::System.IntPtr getClient_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17DiagnosticsEngine10ownsClientEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool ownsClient_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17DiagnosticsEngine16hasSourceManagerEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasSourceManager_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17DiagnosticsEngine16getSourceManagerEv")]
                internal static extern global::System.IntPtr getSourceManager_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17DiagnosticsEngine16setSourceManagerEPNS_13SourceManagerE")]
                internal static extern void setSourceManager_0(global::System.IntPtr instance, global::System.IntPtr SrcMgr);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17DiagnosticsEngine12pushMappingsENS_14SourceLocationE")]
                internal static extern void pushMappings_0(global::System.IntPtr instance, clang.SourceLocation.Internal Loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17DiagnosticsEngine11popMappingsENS_14SourceLocationE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool popMappings_0(global::System.IntPtr instance, clang.SourceLocation.Internal Loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17DiagnosticsEngine9setClientEPNS_18DiagnosticConsumerEb")]
                internal static extern void setClient_0(global::System.IntPtr instance, global::System.IntPtr client, bool ShouldOwnClient);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17DiagnosticsEngine13setErrorLimitEj")]
                internal static extern void setErrorLimit_0(global::System.IntPtr instance, uint Limit);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17DiagnosticsEngine25setTemplateBacktraceLimitEj")]
                internal static extern void setTemplateBacktraceLimit_0(global::System.IntPtr instance, uint Limit);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17DiagnosticsEngine25getTemplateBacktraceLimitEv")]
                internal static extern uint getTemplateBacktraceLimit_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17DiagnosticsEngine26setConstexprBacktraceLimitEj")]
                internal static extern void setConstexprBacktraceLimit_0(global::System.IntPtr instance, uint Limit);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17DiagnosticsEngine26getConstexprBacktraceLimitEv")]
                internal static extern uint getConstexprBacktraceLimit_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17DiagnosticsEngine20setIgnoreAllWarningsEb")]
                internal static extern void setIgnoreAllWarnings_0(global::System.IntPtr instance, bool Val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17DiagnosticsEngine20getIgnoreAllWarningsEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool getIgnoreAllWarnings_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17DiagnosticsEngine20setEnableAllWarningsEb")]
                internal static extern void setEnableAllWarnings_0(global::System.IntPtr instance, bool Val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17DiagnosticsEngine20getEnableAllWarningsEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool getEnableAllWarnings_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17DiagnosticsEngine19setWarningsAsErrorsEb")]
                internal static extern void setWarningsAsErrors_0(global::System.IntPtr instance, bool Val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17DiagnosticsEngine19getWarningsAsErrorsEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool getWarningsAsErrors_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17DiagnosticsEngine16setErrorsAsFatalEb")]
                internal static extern void setErrorsAsFatal_0(global::System.IntPtr instance, bool Val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17DiagnosticsEngine16getErrorsAsFatalEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool getErrorsAsFatal_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17DiagnosticsEngine25setSuppressSystemWarningsEb")]
                internal static extern void setSuppressSystemWarnings_0(global::System.IntPtr instance, bool Val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17DiagnosticsEngine25getSuppressSystemWarningsEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool getSuppressSystemWarnings_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17DiagnosticsEngine25setSuppressAllDiagnosticsEb")]
                internal static extern void setSuppressAllDiagnostics_0(global::System.IntPtr instance, bool Val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17DiagnosticsEngine25getSuppressAllDiagnosticsEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool getSuppressAllDiagnostics_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17DiagnosticsEngine12setElideTypeEb")]
                internal static extern void setElideType_0(global::System.IntPtr instance, bool Val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17DiagnosticsEngine12getElideTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool getElideType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17DiagnosticsEngine20setPrintTemplateTreeEb")]
                internal static extern void setPrintTemplateTree_0(global::System.IntPtr instance, bool Val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17DiagnosticsEngine20getPrintTemplateTreeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool getPrintTemplateTree_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17DiagnosticsEngine13setShowColorsEb")]
                internal static extern void setShowColors_0(global::System.IntPtr instance, bool Val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17DiagnosticsEngine13getShowColorsEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool getShowColors_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17DiagnosticsEngine16setShowOverloadsENS_14OverloadsShownE")]
                internal static extern void setShowOverloads_0(global::System.IntPtr instance, clang.OverloadsShown Val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17DiagnosticsEngine16getShowOverloadsEv")]
                internal static extern clang.OverloadsShown getShowOverloads_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17DiagnosticsEngine24setLastDiagnosticIgnoredEv")]
                internal static extern void setLastDiagnosticIgnored_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17DiagnosticsEngine23isLastDiagnosticIgnoredEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isLastDiagnosticIgnored_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17DiagnosticsEngine28setExtensionHandlingBehaviorENS_4diag8SeverityE")]
                internal static extern void setExtensionHandlingBehavior_0(global::System.IntPtr instance, clang.diag.Severity H);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17DiagnosticsEngine28getExtensionHandlingBehaviorEv")]
                internal static extern clang.diag.Severity getExtensionHandlingBehavior_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17DiagnosticsEngine30IncrementAllExtensionsSilencedEv")]
                internal static extern void IncrementAllExtensionsSilenced_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17DiagnosticsEngine30DecrementAllExtensionsSilencedEv")]
                internal static extern void DecrementAllExtensionsSilenced_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17DiagnosticsEngine24hasAllExtensionsSilencedEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasAllExtensionsSilenced_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17DiagnosticsEngine11setSeverityEjNS_4diag8SeverityENS_14SourceLocationE")]
                internal static extern void setSeverity_0(global::System.IntPtr instance, uint Diag, clang.diag.Severity Map, clang.SourceLocation.Internal Loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17DiagnosticsEngine19setSeverityForGroupENS_4diag6FlavorEN4llvm9StringRefENS1_8SeverityENS_14SourceLocationE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool setSeverityForGroup_0(global::System.IntPtr instance, clang.diag.Flavor Flavor, llvm.StringRef.Internal Group, clang.diag.Severity Map, clang.SourceLocation.Internal Loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17DiagnosticsEngine32setDiagnosticGroupWarningAsErrorEN4llvm9StringRefEb")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool setDiagnosticGroupWarningAsError_0(global::System.IntPtr instance, llvm.StringRef.Internal Group, bool Enabled);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17DiagnosticsEngine30setDiagnosticGroupErrorAsFatalEN4llvm9StringRefEb")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool setDiagnosticGroupErrorAsFatal_0(global::System.IntPtr instance, llvm.StringRef.Internal Group, bool Enabled);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17DiagnosticsEngine17setSeverityForAllENS_4diag6FlavorENS1_8SeverityENS_14SourceLocationE")]
                internal static extern void setSeverityForAll_0(global::System.IntPtr instance, clang.diag.Flavor Flavor, clang.diag.Severity Map, clang.SourceLocation.Internal Loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17DiagnosticsEngine16hasErrorOccurredEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasErrorOccurred_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17DiagnosticsEngine28hasUncompilableErrorOccurredEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasUncompilableErrorOccurred_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17DiagnosticsEngine21hasFatalErrorOccurredEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasFatalErrorOccurred_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17DiagnosticsEngine29hasUnrecoverableErrorOccurredEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasUnrecoverableErrorOccurred_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17DiagnosticsEngine14getNumWarningsEv")]
                internal static extern uint getNumWarnings_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17DiagnosticsEngine14setNumWarningsEj")]
                internal static extern void setNumWarnings_0(global::System.IntPtr instance, uint NumWarnings);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17DiagnosticsEngine23notePriorDiagnosticFromERKS0_")]
                internal static extern void notePriorDiagnosticFrom_0(global::System.IntPtr instance, global::System.IntPtr Other);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17DiagnosticsEngine5ResetEv")]
                internal static extern void Reset_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17DiagnosticsEngine9isIgnoredEjNS_14SourceLocationE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isIgnored_0(global::System.IntPtr instance, uint DiagID, clang.SourceLocation.Internal Loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17DiagnosticsEngine18getDiagnosticLevelEjNS_14SourceLocationE")]
                internal static extern clang.DiagnosticsEngine.Level getDiagnosticLevel_0(global::System.IntPtr instance, uint DiagID, clang.SourceLocation.Internal Loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17DiagnosticsEngine6ReportENS_14SourceLocationEj")]
                internal static extern void Report_0(global::System.IntPtr @return, global::System.IntPtr instance, clang.SourceLocation.Internal Loc, uint DiagID);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17DiagnosticsEngine6ReportEj")]
                internal static extern void Report_1(global::System.IntPtr @return, global::System.IntPtr instance, uint DiagID);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17DiagnosticsEngine6ReportERKNS_16StoredDiagnosticE")]
                internal static extern void Report_2(global::System.IntPtr instance, global::System.IntPtr storedDiag);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17DiagnosticsEngine20isDiagnosticInFlightEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isDiagnosticInFlight_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17DiagnosticsEngine20SetDelayedDiagnosticEjN4llvm9StringRefES2_")]
                internal static extern void SetDelayedDiagnostic_0(global::System.IntPtr instance, uint DiagID, llvm.StringRef.Internal Arg1, llvm.StringRef.Internal Arg2);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17DiagnosticsEngine5ClearEv")]
                internal static extern void Clear_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17DiagnosticsEngine12getFlagValueEv")]
                internal static extern llvm.StringRef.Internal getFlagValue_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17DiagnosticsEngine21EmitCurrentDiagnosticEb")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool EmitCurrentDiagnostic_0(global::System.IntPtr instance, bool Force);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17DiagnosticsEngine16getCurrentDiagIDEv")]
                internal static extern uint getCurrentDiagID_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17DiagnosticsEngine17getCurrentDiagLocEv")]
                internal static extern clang.SourceLocation.Internal getCurrentDiagLoc_0(global::System.IntPtr instance);
            }

            /// <summary>
            /// <para>The level of the diagnostic, after it has been through
            /// mapping.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief The level of the diagnostic, after it has been through
            /// mapping.</para>
            /// </remarks>
            public enum Level : uint
            {
                Ignored = 0,
                Note = 1,
                Remark = 2,
                Warning = 3,
                Error = 4,
                Fatal = 5
            }

            public enum ArgumentKind : uint
            {
                /// <summary>std::string</summary>
                ak_std_string = 0,
                /// <summary>const char *</summary>
                ak_c_string = 1,
                /// <summary>int</summary>
                ak_sint = 2,
                /// <summary>unsigned</summary>
                ak_uint = 3,
                /// <summary>enum TokenKind : unsigned</summary>
                ak_tokenkind = 4,
                /// <summary>IdentifierInfo</summary>
                ak_identifierinfo = 5,
                /// <summary>QualType</summary>
                ak_qualtype = 6,
                /// <summary>DeclarationName</summary>
                ak_declarationname = 7,
                /// <summary>NamedDecl *</summary>
                ak_nameddecl = 8,
                /// <summary>NestedNameSpecifier *</summary>
                ak_nestednamespec = 9,
                /// <summary>DeclContext *</summary>
                ak_declcontext = 10,
                /// <summary>pair<QualType, QualType></summary>
                ak_qualtype_pair = 11,
                /// <summary>Attr *</summary>
                ak_attr = 12
            }

            /// <summary>
            /// <para>Mapping information for diagnostics.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Mapping information for diagnostics.</para>
            /// <para>  ///</para>
            /// <para>  /// Mapping info is packed into four bits per diagnostic.  The
            /// low three</para>
            /// <para>  /// bits are the mapping (an instance of diag::Severity), or
            /// zero if unset.</para>
            /// <para>  /// The high bit is set when the mapping was established as a
            /// user mapping.</para>
            /// <para>  /// If the high bit is clear, then the low bits are set to the
            /// default</para>
            /// <para>  /// value, and should be mapped with -pedantic, -Werror,
            /// etc.</para>
            /// <para>  ///</para>
            /// <para>  /// A new DiagState is created and kept around when diagnostic
            /// pragmas modify</para>
            /// <para>  /// the state so that we know what is the diagnostic state at
            /// any given</para>
            /// <para>  /// source location.</para>
            /// </remarks>
            internal unsafe partial class DiagState
            {
                [StructLayout(LayoutKind.Explicit, Size = 24)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    internal llvm.DenseMap.Internal DiagMap;
                }
            }

            /// <summary>
            /// <para>Represents a point in source where the diagnostic state was
            /// modified because of a pragma.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Represents a point in source where the diagnostic
            /// state was</para>
            /// <para>  /// modified because of a pragma.</para>
            /// <para>  ///</para>
            /// <para>  /// 'Loc' can be null if the point represents the diagnostic
            /// state</para>
            /// <para>  /// modifications done through the command-line.</para>
            /// </remarks>
            internal unsafe partial class DiagStatePoint
            {
                [StructLayout(LayoutKind.Explicit, Size = 24)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public global::System.IntPtr State;

                    [FieldOffset(8)]
                    public clang.FullSourceLoc.Internal Loc;
                }
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, DiagnosticsEngine> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, DiagnosticsEngine>();

            private readonly bool __ownsNativeInstance;

            public static DiagnosticsEngine __CreateInstance(global::System.IntPtr native)
            {
                return new DiagnosticsEngine((DiagnosticsEngine.Internal*) native);
            }

            public static DiagnosticsEngine __CreateInstance(DiagnosticsEngine.Internal native)
            {
                return new DiagnosticsEngine(native);
            }

            private static DiagnosticsEngine.Internal* __CopyValue(DiagnosticsEngine.Internal native)
            {
                var ret = (DiagnosticsEngine.Internal*) Marshal.AllocHGlobal(1208);
                *ret = native;
                return ret;
            }

            private DiagnosticsEngine(DiagnosticsEngine.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected DiagnosticsEngine(DiagnosticsEngine.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.DiagnosticsEngine __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance || force)
                    Internal.dtor_0(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            /// <summary>
            /// <para>Retrieve the diagnostic options.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the diagnostic options.</para>
            /// </remarks>
            public clang.DiagnosticOptions getDiagnosticOptions()
            {
                var __ret = Internal.getDiagnosticOptions_0(__Instance);
                clang.DiagnosticOptions __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.DiagnosticOptions.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.DiagnosticOptions) clang.DiagnosticOptions.NativeToManagedMap[__ret];
                else __result0 = clang.DiagnosticOptions.__CreateInstance(__ret);
                return __result0;
            }

            public clang.DiagnosticConsumer getClient()
            {
                var __ret = Internal.getClient_0(__Instance);
                clang.DiagnosticConsumer __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.DiagnosticConsumer.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.DiagnosticConsumer) clang.DiagnosticConsumer.NativeToManagedMap[__ret];
                else clang.DiagnosticConsumer.NativeToManagedMap[__ret] = __result0 = (clang.DiagnosticConsumer) clang.DiagnosticConsumer.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Determine whether this DiagnosticsEngine object own its
            /// client.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine whether this \c DiagnosticsEngine object own
            /// its client.</para>
            /// </remarks>
            public bool ownsClient()
            {
                var __ret = Internal.ownsClient_0(__Instance);
                return __ret;
            }

            public bool hasSourceManager()
            {
                var __ret = Internal.hasSourceManager_0(__Instance);
                return __ret;
            }

            public clang.SourceManager getSourceManager()
            {
                var __ret = Internal.getSourceManager_0(__Instance);
                clang.SourceManager __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.SourceManager.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.SourceManager) clang.SourceManager.NativeToManagedMap[__ret];
                else __result0 = clang.SourceManager.__CreateInstance(__ret);
                return __result0;
            }

            public void setSourceManager(clang.SourceManager SrcMgr)
            {
                var arg0 = ReferenceEquals(SrcMgr, null) ? global::System.IntPtr.Zero : SrcMgr.__Instance;
                Internal.setSourceManager_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>Copies the current DiagMappings and pushes the new copy onto the
            /// top of the stack.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Copies the current DiagMappings and pushes the new
            /// copy</para>
            /// <para>  /// onto the top of the stack.</para>
            /// </remarks>
            public void pushMappings(clang.SourceLocation Loc)
            {
                var arg0 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                Internal.pushMappings_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>Pops the current DiagMappings off the top of the stack, causing
            /// the new top of the stack to be the active mappings.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Pops the current DiagMappings off the top of the
            /// stack,</para>
            /// <para>  /// causing the new top of the stack to be the active
            /// mappings.</para>
            /// <para>  ///</para>
            /// <para>  /// \returns \c true if the pop happens, \c false if there is
            /// only one</para>
            /// <para>  /// DiagMapping on the stack.</para>
            /// </remarks>
            public bool popMappings(clang.SourceLocation Loc)
            {
                var arg0 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                var __ret = Internal.popMappings_0(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Set the diagnostic client associated with this diagnostic
            /// object.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Set the diagnostic client associated with this
            /// diagnostic object.</para>
            /// <para>  ///</para>
            /// <para>  /// \param ShouldOwnClient true if the diagnostic object should
            /// take</para>
            /// <para>  /// ownership of \c client.</para>
            /// </remarks>
            public void setClient(clang.DiagnosticConsumer client, bool ShouldOwnClient)
            {
                var arg0 = ReferenceEquals(client, null) ? global::System.IntPtr.Zero : client.__Instance;
                Internal.setClient_0(__Instance, arg0, ShouldOwnClient);
            }

            /// <summary>
            /// <para>Specify a limit for the number of errors we should emit before
            /// giving up.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Specify a limit for the number of errors we
            /// should</para>
            /// <para>  /// emit before giving up.</para>
            /// <para>  ///</para>
            /// <para>  /// Zero disables the limit.</para>
            /// </remarks>
            public void setErrorLimit(uint Limit)
            {
                Internal.setErrorLimit_0(__Instance, Limit);
            }

            /// <summary>
            /// <para>Specify the maximum number of template instantiation notes to
            /// emit along with a given diagnostic.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Specify the maximum number of template
            /// instantiation</para>
            /// <para>  /// notes to emit along with a given diagnostic.</para>
            /// </remarks>
            public void setTemplateBacktraceLimit(uint Limit)
            {
                Internal.setTemplateBacktraceLimit_0(__Instance, Limit);
            }

            /// <summary>
            /// <para>Retrieve the maximum number of template instantiation notes to
            /// emit along with a given diagnostic.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the maximum number of template
            /// instantiation</para>
            /// <para>  /// notes to emit along with a given diagnostic.</para>
            /// </remarks>
            public uint getTemplateBacktraceLimit()
            {
                var __ret = Internal.getTemplateBacktraceLimit_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Specify the maximum number of constexpr evaluation notes to emit
            /// along with a given diagnostic.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Specify the maximum number of constexpr
            /// evaluation</para>
            /// <para>  /// notes to emit along with a given diagnostic.</para>
            /// </remarks>
            public void setConstexprBacktraceLimit(uint Limit)
            {
                Internal.setConstexprBacktraceLimit_0(__Instance, Limit);
            }

            /// <summary>
            /// <para>Retrieve the maximum number of constexpr evaluation notes to emit
            /// along with a given diagnostic.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the maximum number of constexpr
            /// evaluation</para>
            /// <para>  /// notes to emit along with a given diagnostic.</para>
            /// </remarks>
            public uint getConstexprBacktraceLimit()
            {
                var __ret = Internal.getConstexprBacktraceLimit_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>When set to true, any unmapped warnings are ignored.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief When set to true, any unmapped warnings are
            /// ignored.</para>
            /// <para>  ///</para>
            /// <para>  /// If this and WarningsAsErrors are both set, then this one
            /// wins.</para>
            /// </remarks>
            public void setIgnoreAllWarnings(bool Val)
            {
                Internal.setIgnoreAllWarnings_0(__Instance, Val);
            }

            public bool getIgnoreAllWarnings()
            {
                var __ret = Internal.getIgnoreAllWarnings_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>When set to true, any unmapped ignored warnings are no longer
            /// ignored.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief When set to true, any unmapped ignored warnings are no
            /// longer</para>
            /// <para>  /// ignored.</para>
            /// <para>  ///</para>
            /// <para>  /// If this and IgnoreAllWarnings are both set, then that one
            /// wins.</para>
            /// </remarks>
            public void setEnableAllWarnings(bool Val)
            {
                Internal.setEnableAllWarnings_0(__Instance, Val);
            }

            public bool getEnableAllWarnings()
            {
                var __ret = Internal.getEnableAllWarnings_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>When set to true, any warnings reported are issued as
            /// errors.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief When set to true, any warnings reported are issued as
            /// errors.</para>
            /// </remarks>
            public void setWarningsAsErrors(bool Val)
            {
                Internal.setWarningsAsErrors_0(__Instance, Val);
            }

            public bool getWarningsAsErrors()
            {
                var __ret = Internal.getWarningsAsErrors_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>When set to true, any error reported is made a fatal
            /// error.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief When set to true, any error reported is made a fatal
            /// error.</para>
            /// </remarks>
            public void setErrorsAsFatal(bool Val)
            {
                Internal.setErrorsAsFatal_0(__Instance, Val);
            }

            public bool getErrorsAsFatal()
            {
                var __ret = Internal.getErrorsAsFatal_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>When set to true mask warnings that come from system
            /// headers.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief When set to true mask warnings that come from system
            /// headers.</para>
            /// </remarks>
            public void setSuppressSystemWarnings(bool Val)
            {
                Internal.setSuppressSystemWarnings_0(__Instance, Val);
            }

            public bool getSuppressSystemWarnings()
            {
                var __ret = Internal.getSuppressSystemWarnings_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Suppress all diagnostics, to silence the front end when we know
            /// that we don't want any more diagnostics to be passed along to the
            /// client</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Suppress all diagnostics, to silence the front end
            /// when we </para>
            /// <para>  /// know that we don't want any more diagnostics to be passed
            /// along to the</para>
            /// <para>  /// client</para>
            /// </remarks>
            public void setSuppressAllDiagnostics(bool Val)
            {
                Internal.setSuppressAllDiagnostics_0(__Instance, Val);
            }

            public bool getSuppressAllDiagnostics()
            {
                var __ret = Internal.getSuppressAllDiagnostics_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Set type eliding, to skip outputting same types occurring in
            /// template types.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Set type eliding, to skip outputting same types
            /// occurring in</para>
            /// <para>  /// template types.</para>
            /// </remarks>
            public void setElideType(bool Val)
            {
                Internal.setElideType_0(__Instance, Val);
            }

            public bool getElideType()
            {
                var __ret = Internal.getElideType_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Set tree printing, to outputting the template difference in a
            /// tree format.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Set tree printing, to outputting the template
            /// difference in a</para>
            /// <para>  /// tree format.</para>
            /// </remarks>
            public void setPrintTemplateTree(bool Val)
            {
                Internal.setPrintTemplateTree_0(__Instance, Val);
            }

            public bool getPrintTemplateTree()
            {
                var __ret = Internal.getPrintTemplateTree_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Set color printing, so the type diffing will inject color markers
            /// into the output.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Set color printing, so the type diffing will inject
            /// color markers</para>
            /// <para>  /// into the output.</para>
            /// </remarks>
            public void setShowColors(bool Val)
            {
                Internal.setShowColors_0(__Instance, Val);
            }

            public bool getShowColors()
            {
                var __ret = Internal.getShowColors_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Specify which overload candidates to show when overload
            /// resolution fails.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Specify which overload candidates to show when
            /// overload resolution</para>
            /// <para>  /// fails.</para>
            /// <para>  ///</para>
            /// <para>  /// By default, we show all candidates.</para>
            /// </remarks>
            public void setShowOverloads(clang.OverloadsShown Val)
            {
                var arg0 = Val;
                Internal.setShowOverloads_0(__Instance, arg0);
            }

            public clang.OverloadsShown getShowOverloads()
            {
                var __ret = Internal.getShowOverloads_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Pretend that the last diagnostic issued was ignored, so any
            /// subsequent notes will be suppressed.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Pretend that the last diagnostic issued was ignored,
            /// so any</para>
            /// <para>  /// subsequent notes will be suppressed.</para>
            /// <para>  ///</para>
            /// <para>  /// This can be used by clients who suppress diagnostics
            /// themselves.</para>
            /// </remarks>
            public void setLastDiagnosticIgnored()
            {
                Internal.setLastDiagnosticIgnored_0(__Instance);
            }

            /// <summary>
            /// <para>Determine whether the previous diagnostic was ignored. This can
            /// be used by clients that want to determine whether notes attached to a
            /// diagnostic will be suppressed.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine whether the previous diagnostic was ignored.
            /// This can</para>
            /// <para>  /// be used by clients that want to determine whether notes
            /// attached to a</para>
            /// <para>  /// diagnostic will be suppressed.</para>
            /// </remarks>
            public bool isLastDiagnosticIgnored()
            {
                var __ret = Internal.isLastDiagnosticIgnored_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Controls whether otherwise-unmapped extension diagnostics are
            /// mapped onto ignore/warning/error.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Controls whether otherwise-unmapped extension
            /// diagnostics are</para>
            /// <para>  /// mapped onto ignore/warning/error. </para>
            /// <para>  ///</para>
            /// <para>  /// This corresponds to the GCC -pedantic and -pedantic-errors
            /// option.</para>
            /// </remarks>
            public void setExtensionHandlingBehavior(clang.diag.Severity H)
            {
                var arg0 = H;
                Internal.setExtensionHandlingBehavior_0(__Instance, arg0);
            }

            public clang.diag.Severity getExtensionHandlingBehavior()
            {
                var __ret = Internal.getExtensionHandlingBehavior_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Counter bumped when an __extension__ block is/
            /// encountered.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Counter bumped when an __extension__  block is/
            /// encountered.</para>
            /// <para>  ///</para>
            /// <para>  /// When non-zero, all extension diagnostics are entirely
            /// silenced, no</para>
            /// <para>  /// matter how they are mapped.</para>
            /// </remarks>
            public void IncrementAllExtensionsSilenced()
            {
                Internal.IncrementAllExtensionsSilenced_0(__Instance);
            }

            public void DecrementAllExtensionsSilenced()
            {
                Internal.DecrementAllExtensionsSilenced_0(__Instance);
            }

            public bool hasAllExtensionsSilenced()
            {
                var __ret = Internal.hasAllExtensionsSilenced_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>This allows the client to specify that certain warnings are
            /// ignored.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief This allows the client to specify that certain
            /// warnings are</para>
            /// <para>  /// ignored.</para>
            /// <para>  ///</para>
            /// <para>  /// Notes can never be mapped, errors can only be mapped to
            /// fatal, and</para>
            /// <para>  /// WARNINGs and EXTENSIONs can be mapped arbitrarily.</para>
            /// <para>  ///</para>
            /// <para>  /// \param Loc The source location that this change of
            /// diagnostic state should</para>
            /// <para>  /// take affect. It can be null if we are setting the latest
            /// state.</para>
            /// </remarks>
            public void setSeverity(uint Diag, clang.diag.Severity Map, clang.SourceLocation Loc)
            {
                var arg0 = Diag;
                var arg1 = Map;
                var arg2 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                Internal.setSeverity_0(__Instance, arg0, arg1, arg2);
            }

            /// <summary>
            /// <para>Change an entire diagnostic group (e.g.
            /// &quot;unknown-pragmas&quot;) to have the specified mapping.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Change an entire diagnostic group (e.g.
            /// &quot;unknown-pragmas&quot;) to</para>
            /// <para>  /// have the specified mapping.</para>
            /// <para>  ///</para>
            /// <para>  /// \returns true (and ignores the request) if
            /// &quot;Group&quot; was unknown, false</para>
            /// <para>  /// otherwise.</para>
            /// <para>  ///</para>
            /// <para>  /// \param Flavor The flavor of group to affect. -Rfoo does not
            /// affect the</para>
            /// <para>  /// state of the -Wfoo group and vice versa.</para>
            /// <para>  ///</para>
            /// <para>  /// \param Loc The source location that this change of
            /// diagnostic state should</para>
            /// <para>  /// take affect. It can be null if we are setting the state
            /// from command-line.</para>
            /// </remarks>
            public bool setSeverityForGroup(clang.diag.Flavor Flavor, llvm.StringRef Group, clang.diag.Severity Map, clang.SourceLocation Loc)
            {
                var arg0 = Flavor;
                var arg1 = ReferenceEquals(Group, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (Group.__Instance);
                var arg2 = Map;
                var arg3 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                var __ret = Internal.setSeverityForGroup_0(__Instance, arg0, arg1, arg2, arg3);
                return __ret;
            }

            /// <summary>
            /// <para>Set the warning-as-error flag for the given diagnostic
            /// group.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Set the warning-as-error flag for the given diagnostic
            /// group.</para>
            /// <para>  ///</para>
            /// <para>  /// This function always only operates on the current
            /// diagnostic state.</para>
            /// <para>  ///</para>
            /// <para>  /// \returns True if the given group is unknown, false
            /// otherwise.</para>
            /// </remarks>
            public bool setDiagnosticGroupWarningAsError(llvm.StringRef Group, bool Enabled)
            {
                var arg0 = ReferenceEquals(Group, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (Group.__Instance);
                var __ret = Internal.setDiagnosticGroupWarningAsError_0(__Instance, arg0, Enabled);
                return __ret;
            }

            /// <summary>
            /// <para>Set the error-as-fatal flag for the given diagnostic
            /// group.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Set the error-as-fatal flag for the given diagnostic
            /// group.</para>
            /// <para>  ///</para>
            /// <para>  /// This function always only operates on the current
            /// diagnostic state.</para>
            /// <para>  ///</para>
            /// <para>  /// \returns True if the given group is unknown, false
            /// otherwise.</para>
            /// </remarks>
            public bool setDiagnosticGroupErrorAsFatal(llvm.StringRef Group, bool Enabled)
            {
                var arg0 = ReferenceEquals(Group, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (Group.__Instance);
                var __ret = Internal.setDiagnosticGroupErrorAsFatal_0(__Instance, arg0, Enabled);
                return __ret;
            }

            /// <summary>
            /// <para>Add the specified mapping to all diagnostics of the specified
            /// flavor.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Add the specified mapping to all diagnostics of the
            /// specified</para>
            /// <para>  /// flavor.</para>
            /// <para>  ///</para>
            /// <para>  /// Mainly to be used by -Wno-everything to disable all
            /// warnings but allow</para>
            /// <para>  /// subsequent -W options to enable specific warnings.</para>
            /// </remarks>
            public void setSeverityForAll(clang.diag.Flavor Flavor, clang.diag.Severity Map, clang.SourceLocation Loc)
            {
                var arg0 = Flavor;
                var arg1 = Map;
                var arg2 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                Internal.setSeverityForAll_0(__Instance, arg0, arg1, arg2);
            }

            public bool hasErrorOccurred()
            {
                var __ret = Internal.hasErrorOccurred_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Errors that actually prevent compilation, not those that are
            /// upgraded from a warning by -Werror.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Errors that actually prevent compilation, not those
            /// that are</para>
            /// <para>  /// upgraded from a warning by -Werror.</para>
            /// </remarks>
            public bool hasUncompilableErrorOccurred()
            {
                var __ret = Internal.hasUncompilableErrorOccurred_0(__Instance);
                return __ret;
            }

            public bool hasFatalErrorOccurred()
            {
                var __ret = Internal.hasFatalErrorOccurred_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determine whether any kind of unrecoverable error has
            /// occurred.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine whether any kind of unrecoverable error has
            /// occurred.</para>
            /// </remarks>
            public bool hasUnrecoverableErrorOccurred()
            {
                var __ret = Internal.hasUnrecoverableErrorOccurred_0(__Instance);
                return __ret;
            }

            public uint getNumWarnings()
            {
                var __ret = Internal.getNumWarnings_0(__Instance);
                return __ret;
            }

            public void setNumWarnings(uint NumWarnings)
            {
                Internal.setNumWarnings_0(__Instance, NumWarnings);
            }

            /// <summary>
            /// <para>Note that the prior diagnostic was emitted by some other
            /// DiagnosticsEngine, and we may be attaching a note to that
            /// diagnostic.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Note that the prior diagnostic was emitted by some
            /// other</para>
            /// <para>  /// \c DiagnosticsEngine, and we may be attaching a note to
            /// that diagnostic.</para>
            /// </remarks>
            public void notePriorDiagnosticFrom(clang.DiagnosticsEngine Other)
            {
                var arg0 = ReferenceEquals(Other, null) ? global::System.IntPtr.Zero : Other.__Instance;
                Internal.notePriorDiagnosticFrom_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>Reset the state of the diagnostic object to its initial
            /// configuration.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Reset the state of the diagnostic object to its
            /// initial </para>
            /// <para>  /// configuration.</para>
            /// </remarks>
            public void Reset()
            {
                Internal.Reset_0(__Instance);
            }

            /// <summary>
            /// <para>Determine whether the diagnostic is known to be ignored.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine whether the diagnostic is known to be
            /// ignored.</para>
            /// <para>  ///</para>
            /// <para>  /// This can be used to opportunistically avoid expensive
            /// checks when it's</para>
            /// <para>  /// known for certain that the diagnostic has been suppressed
            /// at the</para>
            /// <para>  /// specified location \p Loc.</para>
            /// <para>  ///</para>
            /// <para>  /// \param Loc The source location we are interested in finding
            /// out the</para>
            /// <para>  /// diagnostic state. Can be null in order to query the latest
            /// state.</para>
            /// </remarks>
            public bool isIgnored(uint DiagID, clang.SourceLocation Loc)
            {
                var arg1 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                var __ret = Internal.isIgnored_0(__Instance, DiagID, arg1);
                return __ret;
            }

            /// <summary>
            /// <para>Based on the way the client configured the DiagnosticsEngine
            /// object, classify the specified diagnostic ID into a Level, consumable by
            /// the DiagnosticConsumer.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Based on the way the client configured the
            /// DiagnosticsEngine</para>
            /// <para>  /// object, classify the specified diagnostic ID into a Level,
            /// consumable by</para>
            /// <para>  /// the DiagnosticConsumer.</para>
            /// <para>  ///</para>
            /// <para>  /// To preserve invariant assumptions, this function should not
            /// be used to</para>
            /// <para>  /// influence parse or semantic analysis actions. Instead
            /// consider using</para>
            /// <para>  /// \c isIgnored().</para>
            /// <para>  ///</para>
            /// <para>  /// \param Loc The source location we are interested in finding
            /// out the</para>
            /// <para>  /// diagnostic state. Can be null in order to query the latest
            /// state.</para>
            /// </remarks>
            public clang.DiagnosticsEngine.Level getDiagnosticLevel(uint DiagID, clang.SourceLocation Loc)
            {
                var arg1 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                var __ret = Internal.getDiagnosticLevel_0(__Instance, DiagID, arg1);
                return __ret;
            }

            /// <summary>
            /// <para>Issue the message to the client.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Issue the message to the client.</para>
            /// <para>  ///</para>
            /// <para>  /// This actually returns an instance of DiagnosticBuilder
            /// which emits the</para>
            /// <para>  /// diagnostics (through @c ProcessDiag) when it is
            /// destroyed.</para>
            /// <para>  ///</para>
            /// <para>  /// \param DiagID A member of the @c diag::kind enum.</para>
            /// <para>  /// \param Loc Represents the source location associated with
            /// the diagnostic,</para>
            /// <para>  /// which can be an invalid location if no position information
            /// is available.</para>
            /// </remarks>
            public clang.DiagnosticBuilder Report(clang.SourceLocation Loc, uint DiagID)
            {
                var arg0 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                var __ret = new clang.DiagnosticBuilder.Internal();
                Internal.Report_0(new IntPtr(&__ret), __Instance, arg0, DiagID);
                return clang.DiagnosticBuilder.__CreateInstance(__ret);
            }

            public clang.DiagnosticBuilder Report(uint DiagID)
            {
                var __ret = new clang.DiagnosticBuilder.Internal();
                Internal.Report_1(new IntPtr(&__ret), __Instance, DiagID);
                return clang.DiagnosticBuilder.__CreateInstance(__ret);
            }

            public void Report(clang.StoredDiagnostic storedDiag)
            {
                var arg0 = ReferenceEquals(storedDiag, null) ? global::System.IntPtr.Zero : storedDiag.__Instance;
                Internal.Report_2(__Instance, arg0);
            }

            /// <summary>
            /// <para>Determine whethere there is already a diagnostic in
            /// flight.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine whethere there is already a diagnostic in
            /// flight.</para>
            /// </remarks>
            public bool isDiagnosticInFlight()
            {
                var __ret = Internal.isDiagnosticInFlight_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Set the &quot;delayed&quot; diagnostic that will be emitted once
            /// the current diagnostic completes.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Set the &quot;delayed&quot; diagnostic that will be
            /// emitted once</para>
            /// <para>  /// the current diagnostic completes.</para>
            /// <para>  ///</para>
            /// <para>  ///  If a diagnostic is already in-flight but the front end
            /// must</para>
            /// <para>  ///  report a problem (e.g., with an inconsistent file
            /// system</para>
            /// <para>  ///  state), this routine sets a &quot;delayed&quot; diagnostic
            /// that will be</para>
            /// <para>  ///  emitted after the current diagnostic completes. This
            /// should</para>
            /// <para>  ///  only be used for fatal errors detected at
            /// inconvenient</para>
            /// <para>  ///  times. If emitting a delayed diagnostic causes a second
            /// delayed</para>
            /// <para>  ///  diagnostic to be introduced, that second delayed
            /// diagnostic</para>
            /// <para>  ///  will be ignored.</para>
            /// <para>  ///</para>
            /// <para>  /// \param DiagID The ID of the diagnostic being
            /// delayed.</para>
            /// <para>  ///</para>
            /// <para>  /// \param Arg1 A string argument that will be provided to
            /// the</para>
            /// <para>  /// diagnostic. A copy of this string will be stored in
            /// the</para>
            /// <para>  /// DiagnosticsEngine object itself.</para>
            /// <para>  ///</para>
            /// <para>  /// \param Arg2 A string argument that will be provided to
            /// the</para>
            /// <para>  /// diagnostic. A copy of this string will be stored in
            /// the</para>
            /// <para>  /// DiagnosticsEngine object itself.</para>
            /// </remarks>
            public void SetDelayedDiagnostic(uint DiagID, llvm.StringRef Arg1, llvm.StringRef Arg2)
            {
                var arg1 = ReferenceEquals(Arg1, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (Arg1.__Instance);
                var arg2 = ReferenceEquals(Arg2, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (Arg2.__Instance);
                Internal.SetDelayedDiagnostic_0(__Instance, DiagID, arg1, arg2);
            }

            /// <summary>
            /// <para>Clear out the current diagnostic.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Clear out the current diagnostic.</para>
            /// </remarks>
            public void Clear()
            {
                Internal.Clear_0(__Instance);
            }

            /// <summary>
            /// <para>Return the value associated with this diagnostic flag.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the value associated with this diagnostic
            /// flag.</para>
            /// </remarks>
            public llvm.StringRef getFlagValue()
            {
                var __ret = Internal.getFlagValue_0(__Instance);
                return llvm.StringRef.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Emit the current diagnostic and clear the diagnostic
            /// state.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Emit the current diagnostic and clear the diagnostic
            /// state.</para>
            /// <para>  ///</para>
            /// <para>  /// \param Force Emit the diagnostic regardless of suppression
            /// settings.</para>
            /// </remarks>
            protected bool EmitCurrentDiagnostic(bool Force)
            {
                var __ret = Internal.EmitCurrentDiagnostic_0(__Instance, Force);
                return __ret;
            }

            protected uint getCurrentDiagID()
            {
                var __ret = Internal.getCurrentDiagID_0(__Instance);
                return __ret;
            }

            protected clang.SourceLocation getCurrentDiagLoc()
            {
                var __ret = Internal.getCurrentDiagLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }
        }

        /// <summary>
        /// <para>RAII class that determines when any errors have occurred between
        /// the time the instance was created and the time it was queried.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief RAII class that determines when any errors have
        /// occurred</para>
        /// <para>/// between the time the instance was created and the time it
        /// was</para>
        /// <para>/// queried.</para>
        /// </remarks>
        public unsafe partial class DiagnosticErrorTrap : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr Diag;

                [FieldOffset(8)]
                public uint NumErrors;

                [FieldOffset(12)]
                public uint NumUnrecoverableErrors;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang19DiagnosticErrorTrapC2ERNS_17DiagnosticsEngineE")]
                internal static extern void ctor_0(global::System.IntPtr instance, global::System.IntPtr Diag);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang19DiagnosticErrorTrapC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang19DiagnosticErrorTrap16hasErrorOccurredEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasErrorOccurred_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang19DiagnosticErrorTrap29hasUnrecoverableErrorOccurredEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasUnrecoverableErrorOccurred_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang19DiagnosticErrorTrap5resetEv")]
                internal static extern void reset_0(global::System.IntPtr instance);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, DiagnosticErrorTrap> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, DiagnosticErrorTrap>();

            private readonly bool __ownsNativeInstance;

            public static DiagnosticErrorTrap __CreateInstance(global::System.IntPtr native)
            {
                return new DiagnosticErrorTrap((DiagnosticErrorTrap.Internal*) native);
            }

            public static DiagnosticErrorTrap __CreateInstance(DiagnosticErrorTrap.Internal native)
            {
                return new DiagnosticErrorTrap(native);
            }

            private static DiagnosticErrorTrap.Internal* __CopyValue(DiagnosticErrorTrap.Internal native)
            {
                var ret = (DiagnosticErrorTrap.Internal*) Marshal.AllocHGlobal(16);
                *ret = native;
                return ret;
            }

            private DiagnosticErrorTrap(DiagnosticErrorTrap.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected DiagnosticErrorTrap(DiagnosticErrorTrap.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public DiagnosticErrorTrap(clang.DiagnosticsEngine Diag)
            {
                __Instance = Marshal.AllocHGlobal(16);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(Diag, null) ? global::System.IntPtr.Zero : Diag.__Instance;
                Internal.ctor_0(__Instance, arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.DiagnosticErrorTrap __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            /// <summary>
            /// <para>Determine whether any errors have occurred since this object
            /// instance was created.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine whether any errors have occurred since
            /// this</para>
            /// <para>  /// object instance was created.</para>
            /// </remarks>
            public bool hasErrorOccurred()
            {
                var __ret = Internal.hasErrorOccurred_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determine whether any unrecoverable errors have occurred since
            /// this object instance was created.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine whether any unrecoverable errors have
            /// occurred since this</para>
            /// <para>  /// object instance was created.</para>
            /// </remarks>
            public bool hasUnrecoverableErrorOccurred()
            {
                var __ret = Internal.hasUnrecoverableErrorOccurred_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Set to initial state of &quot;no errors occurred&quot;.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Set to initial state of &quot;no errors
            /// occurred&quot;.</para>
            /// </remarks>
            public void reset()
            {
                Internal.reset_0(__Instance);
            }
        }

        /// <summary>
        /// <para>A little helper class used to produce diagnostics.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief A little helper class used to produce
        /// diagnostics.</para>
        /// <para>///</para>
        /// <para>/// This is constructed by the DiagnosticsEngine::Report method,
        /// and</para>
        /// <para>/// allows insertion of extra information (arguments and source
        /// ranges) into</para>
        /// <para>/// the currently &quot;in flight&quot; diagnostic.  When the
        /// temporary for the builder</para>
        /// <para>/// is destroyed, the diagnostic is issued.</para>
        /// <para>///</para>
        /// <para>/// Note that many of these will be created as temporary objects
        /// (many call</para>
        /// <para>/// sites), so we want them to be small and we never want their
        /// address taken.</para>
        /// <para>/// This ensures that compilers with somewhat reasonable
        /// optimizers will promote</para>
        /// <para>/// the common fields to registers, eliminating increments of the
        /// NumArgs field,</para>
        /// <para>/// for example.</para>
        /// </remarks>
        public unsafe partial class DiagnosticBuilder : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr DiagObj;

                [FieldOffset(8)]
                public uint NumArgs;

                [FieldOffset(12)]
                public bool IsActive;

                [FieldOffset(13)]
                public bool IsForceEmit;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17DiagnosticBuilderC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr D);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17DiagnosticBuilderD2Ev")]
                internal static extern void dtor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17DiagnosticBuilder11FlushCountsEv")]
                internal static extern void FlushCounts_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17DiagnosticBuilder5ClearEv")]
                internal static extern void Clear_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17DiagnosticBuilder8isActiveEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isActive_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17DiagnosticBuilder4EmitEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool Emit_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17DiagnosticBuilder8getEmptyEv")]
                internal static extern void getEmpty_0(global::System.IntPtr @return);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17DiagnosticBuilder12setForceEmitEv")]
                internal static extern global::System.IntPtr setForceEmit_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17DiagnosticBuildercvbEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorConversion_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17DiagnosticBuilder9AddStringEN4llvm9StringRefE")]
                internal static extern void AddString_0(global::System.IntPtr instance, llvm.StringRef.Internal S);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17DiagnosticBuilder12AddTaggedValElNS_17DiagnosticsEngine12ArgumentKindE")]
                internal static extern void AddTaggedVal_0(global::System.IntPtr instance, long V, clang.DiagnosticsEngine.ArgumentKind Kind);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17DiagnosticBuilder14AddSourceRangeERKNS_15CharSourceRangeE")]
                internal static extern void AddSourceRange_0(global::System.IntPtr instance, global::System.IntPtr R);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17DiagnosticBuilder12AddFixItHintERKNS_9FixItHintE")]
                internal static extern void AddFixItHint_0(global::System.IntPtr instance, global::System.IntPtr Hint);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17DiagnosticBuilder12addFlagValueEN4llvm9StringRefE")]
                internal static extern void addFlagValue_0(global::System.IntPtr instance, llvm.StringRef.Internal V);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clanglsERKNS_17DiagnosticBuilderEi")]
                internal static extern global::System.IntPtr OperatorLessLess_3(global::System.IntPtr DB, int I);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, DiagnosticBuilder> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, DiagnosticBuilder>();

            private readonly bool __ownsNativeInstance;

            public static DiagnosticBuilder __CreateInstance(global::System.IntPtr native)
            {
                return new DiagnosticBuilder((DiagnosticBuilder.Internal*) native);
            }

            public static DiagnosticBuilder __CreateInstance(DiagnosticBuilder.Internal native)
            {
                return new DiagnosticBuilder(native);
            }

            private static DiagnosticBuilder.Internal* __CopyValue(DiagnosticBuilder.Internal native)
            {
                var ret = (DiagnosticBuilder.Internal*) Marshal.AllocHGlobal(16);
                *ret = native;
                return ret;
            }

            private DiagnosticBuilder(DiagnosticBuilder.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected DiagnosticBuilder(DiagnosticBuilder.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.DiagnosticBuilder __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance || force)
                    Internal.dtor_0(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            protected void FlushCounts()
            {
                Internal.FlushCounts_0(__Instance);
            }

            /// <summary>
            /// <para>Clear out the current diagnostic.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Clear out the current diagnostic.</para>
            /// </remarks>
            protected void Clear()
            {
                Internal.Clear_0(__Instance);
            }

            /// <summary>
            /// <para>Determine whether this diagnostic is still active.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine whether this diagnostic is still
            /// active.</para>
            /// </remarks>
            protected bool isActive()
            {
                var __ret = Internal.isActive_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Force the diagnostic builder to emit the diagnostic now.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Force the diagnostic builder to emit the diagnostic
            /// now.</para>
            /// <para>  ///</para>
            /// <para>  /// Once this function has been called, the DiagnosticBuilder
            /// object</para>
            /// <para>  /// should not be used again before it is destroyed.</para>
            /// <para>  ///</para>
            /// <para>  /// \returns true if a diagnostic was emitted, false if
            /// the</para>
            /// <para>  /// diagnostic was suppressed.</para>
            /// </remarks>
            protected bool Emit()
            {
                var __ret = Internal.Emit_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Forces the diagnostic to be emitted.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Forces the diagnostic to be emitted.</para>
            /// </remarks>
            public clang.DiagnosticBuilder setForceEmit()
            {
                var __ret = Internal.setForceEmit_0(__Instance);
                clang.DiagnosticBuilder __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.DiagnosticBuilder.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.DiagnosticBuilder) clang.DiagnosticBuilder.NativeToManagedMap[__ret];
                else __result0 = clang.DiagnosticBuilder.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Conversion of DiagnosticBuilder to bool always returns
            /// true.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Conversion of DiagnosticBuilder to bool always returns
            /// \c true.</para>
            /// <para>  ///</para>
            /// <para>  /// This allows is to be used in boolean error contexts (where
            /// \c true is</para>
            /// <para>  /// used to indicate that an error has occurred), like:</para>
            /// <para>  /// \code</para>
            /// <para>  /// return Diag(...);</para>
            /// <para>  /// \endcode</para>
            /// </remarks>
            public static implicit operator bool(clang.DiagnosticBuilder __op)
            {
                var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
                var __ret = Internal.OperatorConversion_0(arg0);
                return __ret;
            }

            public void AddString(llvm.StringRef S)
            {
                var arg0 = ReferenceEquals(S, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (S.__Instance);
                Internal.AddString_0(__Instance, arg0);
            }

            public void AddTaggedVal(long V, clang.DiagnosticsEngine.ArgumentKind Kind)
            {
                var arg0 = V;
                var arg1 = Kind;
                Internal.AddTaggedVal_0(__Instance, arg0, arg1);
            }

            public void AddSourceRange(clang.CharSourceRange R)
            {
                var arg0 = ReferenceEquals(R, null) ? global::System.IntPtr.Zero : R.__Instance;
                Internal.AddSourceRange_0(__Instance, arg0);
            }

            public void AddFixItHint(clang.FixItHint Hint)
            {
                var arg0 = ReferenceEquals(Hint, null) ? global::System.IntPtr.Zero : Hint.__Instance;
                Internal.AddFixItHint_0(__Instance, arg0);
            }

            public void addFlagValue(llvm.StringRef V)
            {
                var arg0 = ReferenceEquals(V, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (V.__Instance);
                Internal.addFlagValue_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>Retrieve an empty diagnostic builder.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve an empty diagnostic builder.</para>
            /// </remarks>
            public static clang.DiagnosticBuilder getEmpty()
            {
                var __ret = new clang.DiagnosticBuilder.Internal();
                Internal.getEmpty_0(new IntPtr(&__ret));
                return clang.DiagnosticBuilder.__CreateInstance(__ret);
            }

            public static clang.DiagnosticBuilder operator <<(clang.DiagnosticBuilder DB, int I)
            {
                var arg0 = ReferenceEquals(DB, null) ? global::System.IntPtr.Zero : DB.__Instance;
                var __ret = Internal.OperatorLessLess_3(arg0, I);
                clang.DiagnosticBuilder __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.DiagnosticBuilder.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.DiagnosticBuilder) clang.DiagnosticBuilder.NativeToManagedMap[__ret];
                else __result0 = clang.DiagnosticBuilder.__CreateInstance(__ret);
                return __result0;
            }
        }

        public unsafe partial class AddFlagValue : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public llvm.StringRef.Internal Val;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12AddFlagValueC2EN4llvm9StringRefE")]
                internal static extern void ctor_0(global::System.IntPtr instance, llvm.StringRef.Internal V);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12AddFlagValueC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, AddFlagValue> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, AddFlagValue>();

            private readonly bool __ownsNativeInstance;

            public static AddFlagValue __CreateInstance(global::System.IntPtr native)
            {
                return new AddFlagValue((AddFlagValue.Internal*) native);
            }

            public static AddFlagValue __CreateInstance(AddFlagValue.Internal native)
            {
                return new AddFlagValue(native);
            }

            private static AddFlagValue.Internal* __CopyValue(AddFlagValue.Internal native)
            {
                var ret = (AddFlagValue.Internal*) Marshal.AllocHGlobal(16);
                *ret = native;
                return ret;
            }

            private AddFlagValue(AddFlagValue.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected AddFlagValue(AddFlagValue.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public AddFlagValue(llvm.StringRef V)
            {
                __Instance = Marshal.AllocHGlobal(16);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(V, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (V.__Instance);
                Internal.ctor_0(__Instance, arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.AddFlagValue __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public llvm.StringRef Val
            {
                get
                {
                    return llvm.StringRef.__CreateInstance(((Internal*) __Instance)->Val);
                }

                set
                {
                    ((Internal*) __Instance)->Val = ReferenceEquals(value, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (value.__Instance);
                }
            }
        }

        /// <summary>
        /// <para>A little helper class (which is basically a smart pointer that
        /// forwards info from DiagnosticsEngine) that allows clients to enquire about
        /// the currently in-flight diagnostic.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// A little helper class (which is basically a smart pointer
        /// that forwards</para>
        /// <para>/// info from DiagnosticsEngine) that allows clients to enquire
        /// about the</para>
        /// <para>/// currently in-flight diagnostic.</para>
        /// </remarks>
        public unsafe partial class Diagnostic : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 24)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr DiagObj;

                [FieldOffset(8)]
                public llvm.StringRef.Internal StoredDiagMessage;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10DiagnosticC2EPKNS_17DiagnosticsEngineE")]
                internal static extern void ctor_0(global::System.IntPtr instance, global::System.IntPtr DO);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10DiagnosticC2EPKNS_17DiagnosticsEngineEN4llvm9StringRefE")]
                internal static extern void ctor_1(global::System.IntPtr instance, global::System.IntPtr DO, llvm.StringRef.Internal storedDiagMessage);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10DiagnosticC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10Diagnostic8getDiagsEv")]
                internal static extern global::System.IntPtr getDiags_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10Diagnostic5getIDEv")]
                internal static extern uint getID_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10Diagnostic11getLocationEv")]
                internal static extern global::System.IntPtr getLocation_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10Diagnostic16hasSourceManagerEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasSourceManager_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10Diagnostic16getSourceManagerEv")]
                internal static extern global::System.IntPtr getSourceManager_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10Diagnostic10getNumArgsEv")]
                internal static extern uint getNumArgs_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10Diagnostic10getArgKindEj")]
                internal static extern clang.DiagnosticsEngine.ArgumentKind getArgKind_0(global::System.IntPtr instance, uint Idx);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10Diagnostic10getArgCStrEj")]
                internal static extern global::System.IntPtr getArgCStr_0(global::System.IntPtr instance, uint Idx);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10Diagnostic10getArgSIntEj")]
                internal static extern int getArgSInt_0(global::System.IntPtr instance, uint Idx);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10Diagnostic10getArgUIntEj")]
                internal static extern uint getArgUInt_0(global::System.IntPtr instance, uint Idx);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10Diagnostic16getArgIdentifierEj")]
                internal static extern global::System.IntPtr getArgIdentifier_0(global::System.IntPtr instance, uint Idx);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10Diagnostic9getRawArgEj")]
                internal static extern long getRawArg_0(global::System.IntPtr instance, uint Idx);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10Diagnostic12getNumRangesEv")]
                internal static extern uint getNumRanges_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10Diagnostic8getRangeEj")]
                internal static extern global::System.IntPtr getRange_0(global::System.IntPtr instance, uint Idx);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10Diagnostic16getNumFixItHintsEv")]
                internal static extern uint getNumFixItHints_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10Diagnostic12getFixItHintEj")]
                internal static extern global::System.IntPtr getFixItHint_0(global::System.IntPtr instance, uint Idx);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, Diagnostic> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, Diagnostic>();

            private readonly bool __ownsNativeInstance;

            public static Diagnostic __CreateInstance(global::System.IntPtr native)
            {
                return new Diagnostic((Diagnostic.Internal*) native);
            }

            public static Diagnostic __CreateInstance(Diagnostic.Internal native)
            {
                return new Diagnostic(native);
            }

            private static Diagnostic.Internal* __CopyValue(Diagnostic.Internal native)
            {
                var ret = (Diagnostic.Internal*) Marshal.AllocHGlobal(24);
                *ret = native;
                return ret;
            }

            private Diagnostic(Diagnostic.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected Diagnostic(Diagnostic.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public Diagnostic(clang.DiagnosticsEngine DO)
            {
                __Instance = Marshal.AllocHGlobal(24);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(DO, null) ? global::System.IntPtr.Zero : DO.__Instance;
                Internal.ctor_0(__Instance, arg0);
            }

            public Diagnostic(clang.DiagnosticsEngine DO, llvm.StringRef storedDiagMessage)
            {
                __Instance = Marshal.AllocHGlobal(24);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(DO, null) ? global::System.IntPtr.Zero : DO.__Instance;
                var arg1 = ReferenceEquals(storedDiagMessage, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (storedDiagMessage.__Instance);
                Internal.ctor_1(__Instance, arg0, arg1);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Diagnostic __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.DiagnosticsEngine getDiags()
            {
                var __ret = Internal.getDiags_0(__Instance);
                clang.DiagnosticsEngine __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.DiagnosticsEngine.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.DiagnosticsEngine) clang.DiagnosticsEngine.NativeToManagedMap[__ret];
                else __result0 = clang.DiagnosticsEngine.__CreateInstance(__ret);
                return __result0;
            }

            public uint getID()
            {
                var __ret = Internal.getID_0(__Instance);
                return __ret;
            }

            public clang.SourceLocation getLocation()
            {
                var __ret = Internal.getLocation_0(__Instance);
                clang.SourceLocation __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.SourceLocation.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.SourceLocation) clang.SourceLocation.NativeToManagedMap[__ret];
                else __result0 = clang.SourceLocation.__CreateInstance(__ret);
                return __result0;
            }

            public bool hasSourceManager()
            {
                var __ret = Internal.hasSourceManager_0(__Instance);
                return __ret;
            }

            public clang.SourceManager getSourceManager()
            {
                var __ret = Internal.getSourceManager_0(__Instance);
                clang.SourceManager __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.SourceManager.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.SourceManager) clang.SourceManager.NativeToManagedMap[__ret];
                else __result0 = clang.SourceManager.__CreateInstance(__ret);
                return __result0;
            }

            public uint getNumArgs()
            {
                var __ret = Internal.getNumArgs_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Return the kind of the specified index.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the kind of the specified index.</para>
            /// <para>  ///</para>
            /// <para>  /// Based on the kind of argument, the accessors below can be
            /// used to get</para>
            /// <para>  /// the value.</para>
            /// <para>  ///</para>
            /// <para>  /// \pre Idx &lt; getNumArgs()</para>
            /// </remarks>
            public clang.DiagnosticsEngine.ArgumentKind getArgKind(uint Idx)
            {
                var __ret = Internal.getArgKind_0(__Instance, Idx);
                return __ret;
            }

            /// <summary>
            /// <para>Return the specified C string argument.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the specified C string argument.</para>
            /// <para>  /// \pre getArgKind(Idx) ==
            /// DiagnosticsEngine::ak_c_string</para>
            /// </remarks>
            public string getArgCStr(uint Idx)
            {
                var __ret = Internal.getArgCStr_0(__Instance, Idx);
                return Marshal.PtrToStringAnsi(__ret);
            }

            /// <summary>
            /// <para>Return the specified signed integer argument.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the specified signed integer argument.</para>
            /// <para>  /// \pre getArgKind(Idx) == DiagnosticsEngine::ak_sint</para>
            /// </remarks>
            public int getArgSInt(uint Idx)
            {
                var __ret = Internal.getArgSInt_0(__Instance, Idx);
                return __ret;
            }

            /// <summary>
            /// <para>Return the specified unsigned integer argument.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the specified unsigned integer argument.</para>
            /// <para>  /// \pre getArgKind(Idx) == DiagnosticsEngine::ak_uint</para>
            /// </remarks>
            public uint getArgUInt(uint Idx)
            {
                var __ret = Internal.getArgUInt_0(__Instance, Idx);
                return __ret;
            }

            /// <summary>
            /// <para>Return the specified IdentifierInfo argument.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the specified IdentifierInfo argument.</para>
            /// <para>  /// \pre getArgKind(Idx) ==
            /// DiagnosticsEngine::ak_identifierinfo</para>
            /// </remarks>
            public clang.IdentifierInfo getArgIdentifier(uint Idx)
            {
                var __ret = Internal.getArgIdentifier_0(__Instance, Idx);
                clang.IdentifierInfo __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.IdentifierInfo.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.IdentifierInfo) clang.IdentifierInfo.NativeToManagedMap[__ret];
                else __result0 = clang.IdentifierInfo.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Return the specified non-string argument in an opaque
            /// form.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the specified non-string argument in an opaque
            /// form.</para>
            /// <para>  /// \pre getArgKind(Idx) !=
            /// DiagnosticsEngine::ak_std_string</para>
            /// </remarks>
            public long getRawArg(uint Idx)
            {
                var __ret = Internal.getRawArg_0(__Instance, Idx);
                return __ret;
            }

            /// <summary>
            /// <para>Return the number of source ranges associated with this
            /// diagnostic.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the number of source ranges associated with
            /// this diagnostic.</para>
            /// </remarks>
            public uint getNumRanges()
            {
                var __ret = Internal.getNumRanges_0(__Instance);
                return __ret;
            }

            public clang.CharSourceRange getRange(uint Idx)
            {
                var __ret = Internal.getRange_0(__Instance, Idx);
                clang.CharSourceRange __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.CharSourceRange.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.CharSourceRange) clang.CharSourceRange.NativeToManagedMap[__ret];
                else __result0 = clang.CharSourceRange.__CreateInstance(__ret);
                return __result0;
            }

            public uint getNumFixItHints()
            {
                var __ret = Internal.getNumFixItHints_0(__Instance);
                return __ret;
            }

            public clang.FixItHint getFixItHint(uint Idx)
            {
                var __ret = Internal.getFixItHint_0(__Instance, Idx);
                clang.FixItHint __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.FixItHint.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.FixItHint) clang.FixItHint.NativeToManagedMap[__ret];
                else __result0 = clang.FixItHint.__CreateInstance(__ret);
                return __result0;
            }
        }

        /// <summary>
        /// <para>Represents a diagnostic in a form that can be retained until its
        /// corresponding source manager is destroyed.</para>
        /// </summary>
        /// <remarks>
        /// <para>/**</para>
        /// <para> * \brief Represents a diagnostic in a form that can be retained
        /// until its </para>
        /// <para> * corresponding source manager is destroyed. </para>
        /// <para> */</para>
        /// </remarks>
        public unsafe partial class StoredDiagnostic : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 96)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public uint ID;

                [FieldOffset(4)]
                public clang.DiagnosticsEngine.Level Level;

                [FieldOffset(8)]
                public clang.FullSourceLoc.Internal Loc;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16StoredDiagnosticC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16StoredDiagnosticC2ENS_17DiagnosticsEngine5LevelERKNS_10DiagnosticE")]
                internal static extern void ctor_1(global::System.IntPtr instance, clang.DiagnosticsEngine.Level Level, global::System.IntPtr Info);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16StoredDiagnosticC2ENS_17DiagnosticsEngine5LevelEjN4llvm9StringRefE")]
                internal static extern void ctor_2(global::System.IntPtr instance, clang.DiagnosticsEngine.Level Level, uint ID, llvm.StringRef.Internal Message);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16StoredDiagnosticC2ERKS0_")]
                internal static extern void cctor_4(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16StoredDiagnosticD2Ev")]
                internal static extern void dtor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang16StoredDiagnosticcvbEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorConversion_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang16StoredDiagnostic5getIDEv")]
                internal static extern uint getID_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang16StoredDiagnostic8getLevelEv")]
                internal static extern clang.DiagnosticsEngine.Level getLevel_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang16StoredDiagnostic11getLocationEv")]
                internal static extern global::System.IntPtr getLocation_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang16StoredDiagnostic10getMessageEv")]
                internal static extern llvm.StringRef.Internal getMessage_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16StoredDiagnostic11setLocationENS_13FullSourceLocE")]
                internal static extern void setLocation_0(global::System.IntPtr instance, clang.FullSourceLoc.Internal Loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang16StoredDiagnostic10range_sizeEv")]
                internal static extern uint range_size_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang16StoredDiagnostic10fixit_sizeEv")]
                internal static extern uint fixit_size_0(global::System.IntPtr instance);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, StoredDiagnostic> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, StoredDiagnostic>();

            private readonly bool __ownsNativeInstance;

            public static StoredDiagnostic __CreateInstance(global::System.IntPtr native)
            {
                return new StoredDiagnostic((StoredDiagnostic.Internal*) native);
            }

            public static StoredDiagnostic __CreateInstance(StoredDiagnostic.Internal native)
            {
                return new StoredDiagnostic(native);
            }

            private static StoredDiagnostic.Internal* __CopyValue(StoredDiagnostic.Internal native)
            {
                var ret = (StoredDiagnostic.Internal*) Marshal.AllocHGlobal(96);
                *ret = native;
                return ret;
            }

            private StoredDiagnostic(StoredDiagnostic.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected StoredDiagnostic(StoredDiagnostic.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public StoredDiagnostic()
            {
                __Instance = Marshal.AllocHGlobal(96);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public StoredDiagnostic(clang.DiagnosticsEngine.Level Level, clang.Diagnostic Info)
            {
                __Instance = Marshal.AllocHGlobal(96);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = Level;
                var arg1 = ReferenceEquals(Info, null) ? global::System.IntPtr.Zero : Info.__Instance;
                Internal.ctor_1(__Instance, arg0, arg1);
            }

            public StoredDiagnostic(clang.DiagnosticsEngine.Level Level, uint ID, llvm.StringRef Message)
            {
                __Instance = Marshal.AllocHGlobal(96);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = Level;
                var arg2 = ReferenceEquals(Message, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (Message.__Instance);
                Internal.ctor_2(__Instance, arg0, ID, arg2);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.StoredDiagnostic __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance || force)
                    Internal.dtor_0(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            /// <summary>
            /// <para>Evaluates true when this object stores a diagnostic.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Evaluates true when this object stores a
            /// diagnostic.</para>
            /// </remarks>
            public static implicit operator bool(clang.StoredDiagnostic __op)
            {
                var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
                var __ret = Internal.OperatorConversion_0(arg0);
                return __ret;
            }

            public uint getID()
            {
                var __ret = Internal.getID_0(__Instance);
                return __ret;
            }

            public clang.DiagnosticsEngine.Level getLevel()
            {
                var __ret = Internal.getLevel_0(__Instance);
                return __ret;
            }

            public clang.FullSourceLoc getLocation()
            {
                var __ret = Internal.getLocation_0(__Instance);
                clang.FullSourceLoc __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.FullSourceLoc.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.FullSourceLoc) clang.FullSourceLoc.NativeToManagedMap[__ret];
                else __result0 = clang.FullSourceLoc.__CreateInstance(__ret);
                return __result0;
            }

            public llvm.StringRef getMessage()
            {
                var __ret = Internal.getMessage_0(__Instance);
                return llvm.StringRef.__CreateInstance(__ret);
            }

            public void setLocation(clang.FullSourceLoc Loc)
            {
                var arg0 = ReferenceEquals(Loc, null) ? new clang.FullSourceLoc.Internal() : *(clang.FullSourceLoc.Internal*) (Loc.__Instance);
                Internal.setLocation_0(__Instance, arg0);
            }

            public uint range_size()
            {
                var __ret = Internal.range_size_0(__Instance);
                return __ret;
            }

            public uint fixit_size()
            {
                var __ret = Internal.fixit_size_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Abstract interface, implemented by clients of the front-end,
        /// which formats and prints fully processed diagnostics.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief Abstract interface, implemented by clients of the
        /// front-end, which</para>
        /// <para>/// formats and prints fully processed diagnostics.</para>
        /// </remarks>
        public unsafe partial class DiagnosticConsumer : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public partial struct Internal
            {
                [FieldOffset(8)]
                public uint NumWarnings;

                [FieldOffset(12)]
                public uint NumErrors;

                [FieldOffset(0)]
                public global::System.IntPtr vfptr0;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang18DiagnosticConsumerC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang18DiagnosticConsumerC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang18DiagnosticConsumerD2Ev")]
                internal static extern void dtor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang18DiagnosticConsumer12getNumErrorsEv")]
                internal static extern uint getNumErrors_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang18DiagnosticConsumer14getNumWarningsEv")]
                internal static extern uint getNumWarnings_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang18DiagnosticConsumer5clearEv")]
                internal static extern void clear_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang18DiagnosticConsumer13EndSourceFileEv")]
                internal static extern void EndSourceFile_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang18DiagnosticConsumer6finishEv")]
                internal static extern void finish_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang18DiagnosticConsumer25IncludeInDiagnosticCountsEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool IncludeInDiagnosticCounts_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang18DiagnosticConsumer16HandleDiagnosticENS_17DiagnosticsEngine5LevelERKNS_10DiagnosticE")]
                internal static extern void HandleDiagnostic_0(global::System.IntPtr instance, clang.DiagnosticsEngine.Level DiagLevel, global::System.IntPtr Info);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, DiagnosticConsumer> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, DiagnosticConsumer>();

            private readonly bool __ownsNativeInstance;

            public static DiagnosticConsumer __CreateInstance(global::System.IntPtr native)
            {
                return new DiagnosticConsumer((DiagnosticConsumer.Internal*) native);
            }

            public static DiagnosticConsumer __CreateInstance(DiagnosticConsumer.Internal native)
            {
                return new DiagnosticConsumer(native);
            }

            private static DiagnosticConsumer.Internal* __CopyValue(DiagnosticConsumer.Internal native)
            {
                var ret = (DiagnosticConsumer.Internal*) Marshal.AllocHGlobal(16);
                *ret = native;
                return ret;
            }

            private DiagnosticConsumer(DiagnosticConsumer.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected DiagnosticConsumer(DiagnosticConsumer.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
                if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                    SetupVTables(__Instance);
            }

            public DiagnosticConsumer()
            {
                __Instance = Marshal.AllocHGlobal(16);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
                SetupVTables(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.DiagnosticConsumer __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance || force)
                    Internal.dtor_0(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public uint getNumErrors()
            {
                var __ret = Internal.getNumErrors_0(__Instance);
                return __ret;
            }

            public uint getNumWarnings()
            {
                var __ret = Internal.getNumWarnings_0(__Instance);
                return __ret;
            }

            public virtual void clear()
            {
                Internal.clear_0(__Instance);
            }

            /// <summary>
            /// <para>Callback to inform the diagnostic client that processing of a
            /// source file has ended.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Callback to inform the diagnostic client that
            /// processing</para>
            /// <para>  /// of a source file has ended.</para>
            /// <para>  ///</para>
            /// <para>  /// The diagnostic client should assume that any objects made
            /// available via</para>
            /// <para>  /// BeginSourceFile() are inaccessible.</para>
            /// </remarks>
            public virtual void EndSourceFile()
            {
                Internal.EndSourceFile_0(__Instance);
            }

            /// <summary>
            /// <para>Callback to inform the diagnostic client that processing of all
            /// source files has ended.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Callback to inform the diagnostic client that
            /// processing of all</para>
            /// <para>  /// source files has ended.</para>
            /// </remarks>
            public virtual void finish()
            {
                Internal.finish_0(__Instance);
            }

            /// <summary>
            /// <para>Indicates whether the diagnostics handled by this
            /// DiagnosticConsumer should be included in the number of diagnostics reported
            /// by DiagnosticsEngine.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Indicates whether the diagnostics handled by
            /// this</para>
            /// <para>  /// DiagnosticConsumer should be included in the number of
            /// diagnostics</para>
            /// <para>  /// reported by DiagnosticsEngine.</para>
            /// <para>  ///</para>
            /// <para>  /// The default implementation returns true.</para>
            /// </remarks>
            public virtual bool IncludeInDiagnosticCounts()
            {
                var __ret = Internal.IncludeInDiagnosticCounts_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Handle this diagnostic, reporting it to the user or capturing it
            /// to a log as needed.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Handle this diagnostic, reporting it to the user
            /// or</para>
            /// <para>  /// capturing it to a log as needed.</para>
            /// <para>  ///</para>
            /// <para>  /// The default implementation just keeps track of the total
            /// number of</para>
            /// <para>  /// warnings and errors.</para>
            /// </remarks>
            public virtual void HandleDiagnostic(clang.DiagnosticsEngine.Level DiagLevel, clang.Diagnostic Info)
            {
                var arg0 = DiagLevel;
                var arg1 = ReferenceEquals(Info, null) ? global::System.IntPtr.Zero : Info.__Instance;
                Internal.HandleDiagnostic_0(__Instance, arg0, arg1);
            }

            protected uint NumWarnings
            {
                get
                {
                    return ((Internal*) __Instance)->NumWarnings;
                }

                set
                {
                    ((Internal*) __Instance)->NumWarnings = value;
                }
            }

            protected uint NumErrors
            {
                get
                {
                    return ((Internal*) __Instance)->NumErrors;
                }

                set
                {
                    ((Internal*) __Instance)->NumErrors = value;
                }
            }

            #region Virtual table interop

            // void clear()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate void _clear_0Delegate(global::System.IntPtr instance);
            private static _clear_0Delegate _clear_0DelegateInstance;

            private static void _clear_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (DiagnosticConsumer) _References[instance].Target;
                __target.clear();
            }

            // virtual ~DiagnosticConsumer()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
            private static _dtor_0Delegate _dtor_0DelegateInstance;

            private static void _dtor_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (DiagnosticConsumer) _References[instance].Target;
                __target.DestroyNativeInstance();
            }

            // void EndSourceFile()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate void _EndSourceFile_0Delegate(global::System.IntPtr instance);
            private static _EndSourceFile_0Delegate _EndSourceFile_0DelegateInstance;

            private static void _EndSourceFile_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (DiagnosticConsumer) _References[instance].Target;
                __target.EndSourceFile();
            }

            // void finish()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate void _finish_0Delegate(global::System.IntPtr instance);
            private static _finish_0Delegate _finish_0DelegateInstance;

            private static void _finish_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (DiagnosticConsumer) _References[instance].Target;
                __target.finish();
            }

            // bool IncludeInDiagnosticCounts() const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate bool _IncludeInDiagnosticCounts_0Delegate(global::System.IntPtr instance);
            private static _IncludeInDiagnosticCounts_0Delegate _IncludeInDiagnosticCounts_0DelegateInstance;

            private static bool _IncludeInDiagnosticCounts_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (DiagnosticConsumer) _References[instance].Target;
                var __ret = __target.IncludeInDiagnosticCounts();
                return __ret;
            }

            // void HandleDiagnostic(DiagnosticsEngine::Level DiagLevel, const Diagnostic &Info)
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate void _HandleDiagnostic_0Delegate(global::System.IntPtr instance, clang.DiagnosticsEngine.Level DiagLevel, global::System.IntPtr Info);
            private static _HandleDiagnostic_0Delegate _HandleDiagnostic_0DelegateInstance;

            private static void _HandleDiagnostic_0DelegateHook(global::System.IntPtr instance, clang.DiagnosticsEngine.Level DiagLevel, global::System.IntPtr Info)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (DiagnosticConsumer) _References[instance].Target;
                clang.Diagnostic __result1;
                if (Info == IntPtr.Zero) __result1 = null;
                else if (clang.Diagnostic.NativeToManagedMap.ContainsKey(Info))
                    __result1 = (clang.Diagnostic) clang.Diagnostic.NativeToManagedMap[Info];
                else __result1 = clang.Diagnostic.__CreateInstance(Info);
                __target.HandleDiagnostic(DiagLevel, __result1);
            }

            private static void*[] _OldVTables;
            private static void*[] _NewVTables;
            private static void*[] _Thunks;
            private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

            void SetupVTables(global::System.IntPtr instance)
            {
                var native = (Internal*)instance.ToPointer();

                if (_References == null)
                    _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

                if (_References.ContainsKey(instance))
                    return;

                _References[instance] = new WeakReference(this);

                if (_OldVTables == null)
                {
                    _OldVTables = new void*[1];
                    _OldVTables[0] = native->vfptr0.ToPointer();
                }

                if (_Thunks == null)
                {
                    _Thunks = new void*[6];
                    _clear_0DelegateInstance += _clear_0DelegateHook;
                    _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_clear_0DelegateInstance).ToPointer();
                    _dtor_0DelegateInstance += _dtor_0DelegateHook;
                    _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                    _EndSourceFile_0DelegateInstance += _EndSourceFile_0DelegateHook;
                    _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_EndSourceFile_0DelegateInstance).ToPointer();
                    _finish_0DelegateInstance += _finish_0DelegateHook;
                    _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_finish_0DelegateInstance).ToPointer();
                    _IncludeInDiagnosticCounts_0DelegateInstance += _IncludeInDiagnosticCounts_0DelegateHook;
                    _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_IncludeInDiagnosticCounts_0DelegateInstance).ToPointer();
                    _HandleDiagnostic_0DelegateInstance += _HandleDiagnostic_0DelegateHook;
                    _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_HandleDiagnostic_0DelegateInstance).ToPointer();
                }

                if (_NewVTables == null)
                {
                    _NewVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(7 * 8);
                    _NewVTables[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + 0) = _Thunks[0];
                    *(void**)(vfptr0 + 16) = _Thunks[1];
                    *(void**)(vfptr0 + 24) = *(void**)(native->vfptr0 + 24);
                    *(void**)(vfptr0 + 32) = _Thunks[2];
                    *(void**)(vfptr0 + 40) = _Thunks[3];
                    *(void**)(vfptr0 + 48) = _Thunks[4];
                    *(void**)(vfptr0 + 56) = _Thunks[5];
                }

                native->vfptr0 = new IntPtr(_NewVTables[0]);
            }

            #endregion
        }

        /// <summary>
        /// <para>A diagnostic client that ignores all diagnostics.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief A diagnostic client that ignores all
        /// diagnostics.</para>
        /// </remarks>
        public unsafe partial class IgnoringDiagConsumer : clang.DiagnosticConsumer, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public new partial struct Internal
            {
                [FieldOffset(8)]
                public uint NumWarnings;

                [FieldOffset(12)]
                public uint NumErrors;

                [FieldOffset(0)]
                public global::System.IntPtr vfptr0;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang20IgnoringDiagConsumerC2Ev")]
                internal static extern void ctor_1(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang20IgnoringDiagConsumerC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang20IgnoringDiagConsumerD2Ev")]
                internal static extern void dtor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang20IgnoringDiagConsumer16HandleDiagnosticENS_17DiagnosticsEngine5LevelERKNS_10DiagnosticE")]
                internal static extern void HandleDiagnostic_0(global::System.IntPtr instance, clang.DiagnosticsEngine.Level DiagLevel, global::System.IntPtr Info);
            }

            private readonly bool __ownsNativeInstance;

            public static new IgnoringDiagConsumer __CreateInstance(global::System.IntPtr native)
            {
                return new IgnoringDiagConsumer((IgnoringDiagConsumer.Internal*) native);
            }

            public static IgnoringDiagConsumer __CreateInstance(IgnoringDiagConsumer.Internal native)
            {
                return new IgnoringDiagConsumer(native);
            }

            private static IgnoringDiagConsumer.Internal* __CopyValue(IgnoringDiagConsumer.Internal native)
            {
                var ret = (IgnoringDiagConsumer.Internal*) Marshal.AllocHGlobal(16);
                *ret = native;
                return ret;
            }

            private IgnoringDiagConsumer(IgnoringDiagConsumer.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected IgnoringDiagConsumer(IgnoringDiagConsumer.Internal* native, bool isInternalImpl = false)
                : base((clang.DiagnosticConsumer.Internal*) native)
            {
            }

            public IgnoringDiagConsumer()
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(16);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_1(__Instance);
                SetupVTables(__Instance);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.DiagnosticConsumer __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public sealed override void HandleDiagnostic(clang.DiagnosticsEngine.Level DiagLevel, clang.Diagnostic Info)
            {
                var arg0 = DiagLevel;
                var arg1 = ReferenceEquals(Info, null) ? global::System.IntPtr.Zero : Info.__Instance;
                Internal.HandleDiagnostic_0(__Instance, arg0, arg1);
            }

            #region Virtual table interop

            // void clear()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate void _clear_0Delegate(global::System.IntPtr instance);
            private static _clear_0Delegate _clear_0DelegateInstance;

            private static void _clear_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (IgnoringDiagConsumer) _References[instance].Target;
                __target.clear();
            }

            // IgnoringDiagConsumer
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
            private static _dtor_0Delegate _dtor_0DelegateInstance;

            private static void _dtor_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (IgnoringDiagConsumer) _References[instance].Target;
                __target.DestroyNativeInstance();
            }

            // void EndSourceFile()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate void _EndSourceFile_0Delegate(global::System.IntPtr instance);
            private static _EndSourceFile_0Delegate _EndSourceFile_0DelegateInstance;

            private static void _EndSourceFile_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (IgnoringDiagConsumer) _References[instance].Target;
                __target.EndSourceFile();
            }

            // void finish()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate void _finish_0Delegate(global::System.IntPtr instance);
            private static _finish_0Delegate _finish_0DelegateInstance;

            private static void _finish_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (IgnoringDiagConsumer) _References[instance].Target;
                __target.finish();
            }

            // bool IncludeInDiagnosticCounts() const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate bool _IncludeInDiagnosticCounts_0Delegate(global::System.IntPtr instance);
            private static _IncludeInDiagnosticCounts_0Delegate _IncludeInDiagnosticCounts_0DelegateInstance;

            private static bool _IncludeInDiagnosticCounts_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (IgnoringDiagConsumer) _References[instance].Target;
                var __ret = __target.IncludeInDiagnosticCounts();
                return __ret;
            }

            // void HandleDiagnostic(DiagnosticsEngine::Level DiagLevel, const Diagnostic &Info) override
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate void _HandleDiagnostic_0Delegate(global::System.IntPtr instance, clang.DiagnosticsEngine.Level DiagLevel, global::System.IntPtr Info);
            private static _HandleDiagnostic_0Delegate _HandleDiagnostic_0DelegateInstance;

            private static void _HandleDiagnostic_0DelegateHook(global::System.IntPtr instance, clang.DiagnosticsEngine.Level DiagLevel, global::System.IntPtr Info)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (IgnoringDiagConsumer) _References[instance].Target;
                clang.Diagnostic __result1;
                if (Info == IntPtr.Zero) __result1 = null;
                else if (clang.Diagnostic.NativeToManagedMap.ContainsKey(Info))
                    __result1 = (clang.Diagnostic) clang.Diagnostic.NativeToManagedMap[Info];
                else __result1 = clang.Diagnostic.__CreateInstance(Info);
                __target.HandleDiagnostic(DiagLevel, __result1);
            }

            private static void*[] _OldVTables;
            private static void*[] _NewVTables;
            private static void*[] _Thunks;
            private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

            void SetupVTables(global::System.IntPtr instance)
            {
                var native = (Internal*)instance.ToPointer();

                if (_References == null)
                    _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

                if (_References.ContainsKey(instance))
                    return;

                _References[instance] = new WeakReference(this);

                if (_OldVTables == null)
                {
                    _OldVTables = new void*[1];
                    _OldVTables[0] = native->vfptr0.ToPointer();
                }

                if (_Thunks == null)
                {
                    _Thunks = new void*[6];
                    _clear_0DelegateInstance += _clear_0DelegateHook;
                    _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_clear_0DelegateInstance).ToPointer();
                    _dtor_0DelegateInstance += _dtor_0DelegateHook;
                    _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                    _EndSourceFile_0DelegateInstance += _EndSourceFile_0DelegateHook;
                    _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_EndSourceFile_0DelegateInstance).ToPointer();
                    _finish_0DelegateInstance += _finish_0DelegateHook;
                    _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_finish_0DelegateInstance).ToPointer();
                    _IncludeInDiagnosticCounts_0DelegateInstance += _IncludeInDiagnosticCounts_0DelegateHook;
                    _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_IncludeInDiagnosticCounts_0DelegateInstance).ToPointer();
                    _HandleDiagnostic_0DelegateInstance += _HandleDiagnostic_0DelegateHook;
                    _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_HandleDiagnostic_0DelegateInstance).ToPointer();
                }

                if (_NewVTables == null)
                {
                    _NewVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(8 * 8);
                    _NewVTables[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + 0) = _Thunks[0];
                    *(void**)(vfptr0 + 16) = _Thunks[1];
                    *(void**)(vfptr0 + 24) = *(void**)(native->vfptr0 + 24);
                    *(void**)(vfptr0 + 32) = _Thunks[2];
                    *(void**)(vfptr0 + 40) = _Thunks[3];
                    *(void**)(vfptr0 + 48) = _Thunks[4];
                    *(void**)(vfptr0 + 56) = _Thunks[5];
                    *(void**)(vfptr0 + 64) = *(void**)(native->vfptr0 + 64);
                }

                native->vfptr0 = new IntPtr(_NewVTables[0]);
            }

            #endregion
        }

        /// <summary>
        /// <para>Diagnostic consumer that forwards diagnostics along to an
        /// existing, already-initialized diagnostic consumer.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief Diagnostic consumer that forwards diagnostics along to
        /// an</para>
        /// <para>/// existing, already-initialized diagnostic consumer.</para>
        /// <para>///</para>
        /// </remarks>
        public unsafe partial class ForwardingDiagnosticConsumer : clang.DiagnosticConsumer, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 24)]
            public new partial struct Internal
            {
                [FieldOffset(8)]
                public uint NumWarnings;

                [FieldOffset(12)]
                public uint NumErrors;

                [FieldOffset(16)]
                public global::System.IntPtr Target;

                [FieldOffset(0)]
                public global::System.IntPtr vfptr0;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang28ForwardingDiagnosticConsumerC2ERNS_18DiagnosticConsumerE")]
                internal static extern void ctor_0(global::System.IntPtr instance, global::System.IntPtr Target);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang28ForwardingDiagnosticConsumerC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang28ForwardingDiagnosticConsumerD2Ev")]
                internal static extern void dtor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang28ForwardingDiagnosticConsumer16HandleDiagnosticENS_17DiagnosticsEngine5LevelERKNS_10DiagnosticE")]
                internal static extern void HandleDiagnostic_0(global::System.IntPtr instance, clang.DiagnosticsEngine.Level DiagLevel, global::System.IntPtr Info);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang28ForwardingDiagnosticConsumer5clearEv")]
                internal static extern void clear_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang28ForwardingDiagnosticConsumer25IncludeInDiagnosticCountsEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool IncludeInDiagnosticCounts_0(global::System.IntPtr instance);
            }

            private readonly bool __ownsNativeInstance;

            public static new ForwardingDiagnosticConsumer __CreateInstance(global::System.IntPtr native)
            {
                return new ForwardingDiagnosticConsumer((ForwardingDiagnosticConsumer.Internal*) native);
            }

            public static ForwardingDiagnosticConsumer __CreateInstance(ForwardingDiagnosticConsumer.Internal native)
            {
                return new ForwardingDiagnosticConsumer(native);
            }

            private static ForwardingDiagnosticConsumer.Internal* __CopyValue(ForwardingDiagnosticConsumer.Internal native)
            {
                var ret = (ForwardingDiagnosticConsumer.Internal*) Marshal.AllocHGlobal(24);
                *ret = native;
                return ret;
            }

            private ForwardingDiagnosticConsumer(ForwardingDiagnosticConsumer.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected ForwardingDiagnosticConsumer(ForwardingDiagnosticConsumer.Internal* native, bool isInternalImpl = false)
                : base((clang.DiagnosticConsumer.Internal*) native)
            {
            }

            public ForwardingDiagnosticConsumer(clang.DiagnosticConsumer Target)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(24);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(Target, null) ? global::System.IntPtr.Zero : Target.__Instance;
                Internal.ctor_0(__Instance, arg0);
                SetupVTables(__Instance);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.DiagnosticConsumer __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public override void HandleDiagnostic(clang.DiagnosticsEngine.Level DiagLevel, clang.Diagnostic Info)
            {
                var arg0 = DiagLevel;
                var arg1 = ReferenceEquals(Info, null) ? global::System.IntPtr.Zero : Info.__Instance;
                Internal.HandleDiagnostic_0(__Instance, arg0, arg1);
            }

            public override void clear()
            {
                Internal.clear_0(__Instance);
            }

            public override bool IncludeInDiagnosticCounts()
            {
                var __ret = Internal.IncludeInDiagnosticCounts_0(__Instance);
                return __ret;
            }

            #region Virtual table interop

            // void clear() override
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate void _clear_0Delegate(global::System.IntPtr instance);
            private static _clear_0Delegate _clear_0DelegateInstance;

            private static void _clear_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (ForwardingDiagnosticConsumer) _References[instance].Target;
                __target.clear();
            }

            // virtual ~ForwardingDiagnosticConsumer()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
            private static _dtor_0Delegate _dtor_0DelegateInstance;

            private static void _dtor_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (ForwardingDiagnosticConsumer) _References[instance].Target;
                __target.DestroyNativeInstance();
            }

            // void EndSourceFile()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate void _EndSourceFile_0Delegate(global::System.IntPtr instance);
            private static _EndSourceFile_0Delegate _EndSourceFile_0DelegateInstance;

            private static void _EndSourceFile_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (ForwardingDiagnosticConsumer) _References[instance].Target;
                __target.EndSourceFile();
            }

            // void finish()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate void _finish_0Delegate(global::System.IntPtr instance);
            private static _finish_0Delegate _finish_0DelegateInstance;

            private static void _finish_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (ForwardingDiagnosticConsumer) _References[instance].Target;
                __target.finish();
            }

            // bool IncludeInDiagnosticCounts() const override
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate bool _IncludeInDiagnosticCounts_0Delegate(global::System.IntPtr instance);
            private static _IncludeInDiagnosticCounts_0Delegate _IncludeInDiagnosticCounts_0DelegateInstance;

            private static bool _IncludeInDiagnosticCounts_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (ForwardingDiagnosticConsumer) _References[instance].Target;
                var __ret = __target.IncludeInDiagnosticCounts();
                return __ret;
            }

            // void HandleDiagnostic(DiagnosticsEngine::Level DiagLevel, const Diagnostic &Info) override
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate void _HandleDiagnostic_0Delegate(global::System.IntPtr instance, clang.DiagnosticsEngine.Level DiagLevel, global::System.IntPtr Info);
            private static _HandleDiagnostic_0Delegate _HandleDiagnostic_0DelegateInstance;

            private static void _HandleDiagnostic_0DelegateHook(global::System.IntPtr instance, clang.DiagnosticsEngine.Level DiagLevel, global::System.IntPtr Info)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (ForwardingDiagnosticConsumer) _References[instance].Target;
                clang.Diagnostic __result1;
                if (Info == IntPtr.Zero) __result1 = null;
                else if (clang.Diagnostic.NativeToManagedMap.ContainsKey(Info))
                    __result1 = (clang.Diagnostic) clang.Diagnostic.NativeToManagedMap[Info];
                else __result1 = clang.Diagnostic.__CreateInstance(Info);
                __target.HandleDiagnostic(DiagLevel, __result1);
            }

            private static void*[] _OldVTables;
            private static void*[] _NewVTables;
            private static void*[] _Thunks;
            private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

            void SetupVTables(global::System.IntPtr instance)
            {
                var native = (Internal*)instance.ToPointer();

                if (_References == null)
                    _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

                if (_References.ContainsKey(instance))
                    return;

                _References[instance] = new WeakReference(this);

                if (_OldVTables == null)
                {
                    _OldVTables = new void*[1];
                    _OldVTables[0] = native->vfptr0.ToPointer();
                }

                if (_Thunks == null)
                {
                    _Thunks = new void*[6];
                    _clear_0DelegateInstance += _clear_0DelegateHook;
                    _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_clear_0DelegateInstance).ToPointer();
                    _dtor_0DelegateInstance += _dtor_0DelegateHook;
                    _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                    _EndSourceFile_0DelegateInstance += _EndSourceFile_0DelegateHook;
                    _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_EndSourceFile_0DelegateInstance).ToPointer();
                    _finish_0DelegateInstance += _finish_0DelegateHook;
                    _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_finish_0DelegateInstance).ToPointer();
                    _IncludeInDiagnosticCounts_0DelegateInstance += _IncludeInDiagnosticCounts_0DelegateHook;
                    _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_IncludeInDiagnosticCounts_0DelegateInstance).ToPointer();
                    _HandleDiagnostic_0DelegateInstance += _HandleDiagnostic_0DelegateHook;
                    _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_HandleDiagnostic_0DelegateInstance).ToPointer();
                }

                if (_NewVTables == null)
                {
                    _NewVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(7 * 8);
                    _NewVTables[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + 0) = _Thunks[0];
                    *(void**)(vfptr0 + 16) = _Thunks[1];
                    *(void**)(vfptr0 + 24) = *(void**)(native->vfptr0 + 24);
                    *(void**)(vfptr0 + 32) = _Thunks[2];
                    *(void**)(vfptr0 + 40) = _Thunks[3];
                    *(void**)(vfptr0 + 48) = _Thunks[4];
                    *(void**)(vfptr0 + 56) = _Thunks[5];
                }

                native->vfptr0 = new IntPtr(_NewVTables[0]);
            }

            #endregion
        }

        public unsafe partial class TemplateDiffTypes : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 24)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public long FromType;

                [FieldOffset(8)]
                public long ToType;

                [FieldOffset(16)]
                public uint PrintTree;

                [FieldOffset(16)]
                public uint PrintFromType;

                [FieldOffset(16)]
                public uint ElideType;

                [FieldOffset(16)]
                public uint ShowColors;

                [FieldOffset(16)]
                public uint TemplateDiffUsed;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17TemplateDiffTypesC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, TemplateDiffTypes> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, TemplateDiffTypes>();

            private readonly bool __ownsNativeInstance;

            public static TemplateDiffTypes __CreateInstance(global::System.IntPtr native)
            {
                return new TemplateDiffTypes((TemplateDiffTypes.Internal*) native);
            }

            public static TemplateDiffTypes __CreateInstance(TemplateDiffTypes.Internal native)
            {
                return new TemplateDiffTypes(native);
            }

            private static TemplateDiffTypes.Internal* __CopyValue(TemplateDiffTypes.Internal native)
            {
                var ret = (TemplateDiffTypes.Internal*) Marshal.AllocHGlobal(24);
                *ret = native;
                return ret;
            }

            private TemplateDiffTypes(TemplateDiffTypes.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected TemplateDiffTypes(TemplateDiffTypes.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public TemplateDiffTypes()
            {
                __Instance = Marshal.AllocHGlobal(24);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.TemplateDiffTypes __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public long FromType
            {
                get
                {
                    return ((Internal*) __Instance)->FromType;
                }

                set
                {
                    ((Internal*) __Instance)->FromType = value;
                }
            }

            public long ToType
            {
                get
                {
                    return ((Internal*) __Instance)->ToType;
                }

                set
                {
                    ((Internal*) __Instance)->ToType = value;
                }
            }

            public uint PrintTree
            {
                get
                {
                    return ((Internal*) __Instance)->PrintTree;
                }

                set
                {
                    ((Internal*) __Instance)->PrintTree = value;
                }
            }

            public uint PrintFromType
            {
                get
                {
                    return ((Internal*) __Instance)->PrintFromType;
                }

                set
                {
                    ((Internal*) __Instance)->PrintFromType = value;
                }
            }

            public uint ElideType
            {
                get
                {
                    return ((Internal*) __Instance)->ElideType;
                }

                set
                {
                    ((Internal*) __Instance)->ElideType = value;
                }
            }

            public uint ShowColors
            {
                get
                {
                    return ((Internal*) __Instance)->ShowColors;
                }

                set
                {
                    ((Internal*) __Instance)->ShowColors = value;
                }
            }

            public uint TemplateDiffUsed
            {
                get
                {
                    return ((Internal*) __Instance)->TemplateDiffUsed;
                }

                set
                {
                    ((Internal*) __Instance)->TemplateDiffUsed = value;
                }
            }
        }

        public unsafe partial class Diagnostic
        {
            public partial struct Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang21ProcessWarningOptionsERNS_17DiagnosticsEngineERKNS_17DiagnosticOptionsEb")]
                internal static extern void ProcessWarningOptions_0(global::System.IntPtr Diags, global::System.IntPtr Opts, bool ReportDiags);
            }

            /// <summary>
            /// <para>ProcessWarningOptions - Initialize the diagnostic client and
            /// process the warning options specified on the command line.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// ProcessWarningOptions - Initialize the diagnostic client and
            /// process the</para>
            /// <para>/// warning options specified on the command line.</para>
            /// </remarks>
            public static void ProcessWarningOptions(clang.DiagnosticsEngine Diags, clang.DiagnosticOptions Opts, bool ReportDiags)
            {
                var arg0 = ReferenceEquals(Diags, null) ? global::System.IntPtr.Zero : Diags.__Instance;
                var arg1 = ReferenceEquals(Opts, null) ? global::System.IntPtr.Zero : Opts.__Instance;
                Internal.ProcessWarningOptions_0(arg0, arg1, ReportDiags);
            }
        }

        namespace tok
        {
        }
    }
}
