//----------------------------------------------------------------------------
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
//----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace CppSharp
{
    namespace llvm
    {
        /// <summary>
        /// <para>FoldingSet - This template class is used to instantiate a
        /// specialized implementation of the folding set to the node class T. T must
        /// be a subclass of FoldingSetNode and implement a Profile function.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// FoldingSet - This template class is used to instantiate a
        /// specialized</para>
        /// <para>/// implementation of the folding set to the node class T.  T
        /// must be a</para>
        /// <para>/// subclass of FoldingSetNode and implement a Profile
        /// function.</para>
        /// <para>///</para>
        /// </remarks>
        public unsafe partial class FoldingSet
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public new partial struct Internal
            {
                [FieldOffset(8)]
                public void** Buckets;

                [FieldOffset(16)]
                public uint NumBuckets;

                [FieldOffset(20)]
                public uint NumNodes;
            }
        }

        /// <summary>
        /// <para>ContextualFoldingSet - This template class is a further
        /// refinement of FoldingSet which provides a context argument when calling
        /// Profile on its nodes. Currently, that argument is fixed at initialization
        /// time.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// ContextualFoldingSet - This template class is a further
        /// refinement</para>
        /// <para>/// of FoldingSet which provides a context argument when
        /// calling</para>
        /// <para>/// Profile on its nodes.  Currently, that argument is fixed
        /// at</para>
        /// <para>/// initialization time.</para>
        /// <para>///</para>
        /// <para>/// T must be a subclass of FoldingSetNode and implement a
        /// Profile</para>
        /// <para>/// function with signature</para>
        /// <para>///   void Profile(llvm::FoldingSetNodeID &amp;, Ctx);</para>
        /// </remarks>
        public unsafe partial class ContextualFoldingSet
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public new partial struct Internal
            {
                [FieldOffset(8)]
                public void** Buckets;

                [FieldOffset(16)]
                public uint NumBuckets;

                [FieldOffset(20)]
                public uint NumNodes;
            }
        }

        /// <summary>
        /// <para>DefaultFoldingSetTrait - This class provides default
        /// implementations for FoldingSetTrait implementations.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// DefaultFoldingSetTrait - This class provides default
        /// implementations</para>
        /// <para>/// for FoldingSetTrait implementations.</para>
        /// <para>///</para>
        /// </remarks>
        public unsafe static partial class DefaultFoldingSetTrait
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct Internal
            {
            }
        }

        /// <summary>
        /// <para>DefaultContextualFoldingSetTrait - Like DefaultFoldingSetTrait,
        /// but for ContextualFoldingSets.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// DefaultContextualFoldingSetTrait - Like
        /// DefaultFoldingSetTrait, but</para>
        /// <para>/// for ContextualFoldingSets.</para>
        /// </remarks>
        public unsafe static partial class DefaultContextualFoldingSetTrait
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct Internal
            {
            }
        }

        /// <summary>
        /// <para>FoldingSetVector - This template class combines a FoldingSet and
        /// a vector to provide the interface of FoldingSet but with deterministic
        /// iteration order based on the insertion order. T must be a subclass of
        /// FoldingSetNode and implement a Profile function.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// FoldingSetVector - This template class combines a FoldingSet
        /// and a vector</para>
        /// <para>/// to provide the interface of FoldingSet but with deterministic
        /// iteration</para>
        /// <para>/// order based on the insertion order. T must be a subclass of
        /// FoldingSetNode</para>
        /// <para>/// and implement a Profile function.</para>
        /// </remarks>
        public unsafe partial class FoldingSetVector
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct Internal
            {
            }
        }

        /// <summary>
        /// <para>FoldingSetNodeWrapper - This template class is used to
        /// &quot;wrap&quot; arbitrary types in an enclosing object so that they can be
        /// inserted into FoldingSets.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// FoldingSetNodeWrapper - This template class is used to
        /// &quot;wrap&quot; arbitrary</para>
        /// <para>/// types in an enclosing object so that they can be inserted
        /// into FoldingSets.</para>
        /// </remarks>
        public unsafe partial class FoldingSetNodeWrapper
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr NextInFoldingSetBucket;
            }
        }

        /// <summary>
        /// <para>FoldingSetImpl - Implements the folding set functionality. The
        /// main structure is an array of buckets. Each bucket is indexed by the hash
        /// of the nodes it contains. The bucket itself points to the nodes contained
        /// in the bucket via a singly linked list. The last node in the list points
        /// back to the bucket to facilitate node removal.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// FoldingSetImpl - Implements the folding set functionality.
        /// The main</para>
        /// <para>/// structure is an array of buckets.  Each bucket is indexed by
        /// the hash of</para>
        /// <para>/// the nodes it contains.  The bucket itself points to the nodes
        /// contained</para>
        /// <para>/// in the bucket via a singly linked list.  The last node in the
        /// list points</para>
        /// <para>/// back to the bucket to facilitate node removal.</para>
        /// <para>///</para>
        /// </remarks>
        public unsafe abstract partial class FoldingSetImpl : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 24)]
            public partial struct Internal
            {
                [FieldOffset(8)]
                public void** Buckets;

                [FieldOffset(16)]
                public uint NumBuckets;

                [FieldOffset(20)]
                public uint NumNodes;

                [FieldOffset(0)]
                public global::System.IntPtr vfptr0;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm14FoldingSetImplC2Ej")]
                internal static extern void ctor_0(global::System.IntPtr instance, uint Log2InitSize);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm14FoldingSetImplC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm14FoldingSetImplD2Ev")]
                internal static extern void dtor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm14FoldingSetImpl5clearEv")]
                internal static extern void clear_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm14FoldingSetImpl10RemoveNodeEPNS0_4NodeE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool RemoveNode_0(global::System.IntPtr instance, global::System.IntPtr N);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm14FoldingSetImpl15GetOrInsertNodeEPNS0_4NodeE")]
                internal static extern global::System.IntPtr GetOrInsertNode_0(global::System.IntPtr instance, global::System.IntPtr N);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm14FoldingSetImpl19FindNodeOrInsertPosERKNS_16FoldingSetNodeIDERPv")]
                internal static extern global::System.IntPtr FindNodeOrInsertPos_0(global::System.IntPtr instance, global::System.IntPtr ID, void** InsertPos);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm14FoldingSetImpl10InsertNodeEPNS0_4NodeEPv")]
                internal static extern void InsertNode_0(global::System.IntPtr instance, global::System.IntPtr N, global::System.IntPtr InsertPos);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm14FoldingSetImpl10InsertNodeEPNS0_4NodeE")]
                internal static extern void InsertNode_1(global::System.IntPtr instance, global::System.IntPtr N);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm14FoldingSetImpl4sizeEv")]
                internal static extern uint size_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm14FoldingSetImpl5emptyEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool empty_0(global::System.IntPtr instance);
            }

            /// <summary>
            /// <para>Node - This class is used to maintain the singly linked bucket
            /// list in a folding set.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Node - This class is used to maintain the singly linked
            /// bucket list in</para>
            /// <para>  /// a folding set.</para>
            /// <para>  ///</para>
            /// </remarks>
            public unsafe partial class Node : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 8)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public global::System.IntPtr NextInFoldingSetBucket;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN4llvm14FoldingSetImpl4NodeC2Ev")]
                    internal static extern void ctor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN4llvm14FoldingSetImpl4NodeC2ERKS1_")]
                    internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK4llvm14FoldingSetImpl4Node15getNextInBucketEv")]
                    internal static extern global::System.IntPtr getNextInBucket_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN4llvm14FoldingSetImpl4Node15SetNextInBucketEPv")]
                    internal static extern void SetNextInBucket_0(global::System.IntPtr instance, global::System.IntPtr N);
                }

                public global::System.IntPtr __Instance { get; protected set; }
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, Node> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, Node>();

                private readonly bool __ownsNativeInstance;

                public static Node __CreateInstance(global::System.IntPtr native)
                {
                    return new Node((Node.Internal*) native);
                }

                public static Node __CreateInstance(Node.Internal native)
                {
                    return new Node(native);
                }

                private static Node.Internal* __CopyValue(Node.Internal native)
                {
                    var ret = (Node.Internal*) Marshal.AllocHGlobal(8);
                    *ret = native;
                    return ret;
                }

                private Node(Node.Internal native)
                    : this(__CopyValue(native))
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected Node(Node.Internal* native, bool isInternalImpl = false)
                {
                    __Instance = new global::System.IntPtr(native);
                }

                public Node()
                {
                    __Instance = Marshal.AllocHGlobal(8);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_0(__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    DestroyNativeInstance(false);
                }

                public virtual void DestroyNativeInstance()
                {
                    DestroyNativeInstance(true);
                }

                private void DestroyNativeInstance(bool force)
                {
                    llvm.FoldingSetImpl.Node __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public global::System.IntPtr getNextInBucket()
                {
                    var __ret = Internal.getNextInBucket_0(__Instance);
                    return __ret;
                }

                public void SetNextInBucket(global::System.IntPtr N)
                {
                    var arg0 = N;
                    Internal.SetNextInBucket_0(__Instance, arg0);
                }
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, FoldingSetImpl> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, FoldingSetImpl>();

            private readonly bool __ownsNativeInstance;

            public static FoldingSetImpl __CreateInstance(global::System.IntPtr native)
            {
                return new FoldingSetImplInternal((FoldingSetImpl.Internal*) native);
            }

            public static FoldingSetImpl __CreateInstance(FoldingSetImpl.Internal native)
            {
                return new FoldingSetImplInternal(native);
            }

            protected FoldingSetImpl(FoldingSetImpl.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
                if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                    SetupVTables(__Instance);
            }

            protected FoldingSetImpl(uint Log2InitSize)
            {
                __Instance = Marshal.AllocHGlobal(24);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance, Log2InitSize);
                SetupVTables(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                llvm.FoldingSetImpl __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance || force)
                    Internal.dtor_0(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            /// <summary>
            /// <para>clear - Remove all nodes from the folding set.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// clear - Remove all nodes from the folding set.</para>
            /// </remarks>
            public void clear()
            {
                Internal.clear_0(__Instance);
            }

            /// <summary>
            /// <para>RemoveNode - Remove a node from the folding set, returning true
            /// if one was removed or false if the node was not in the folding set.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// RemoveNode - Remove a node from the folding set, returning
            /// true if one</para>
            /// <para>  /// was removed or false if the node was not in the folding
            /// set.</para>
            /// </remarks>
            public bool RemoveNode(llvm.FoldingSetImpl.Node N)
            {
                var arg0 = ReferenceEquals(N, null) ? global::System.IntPtr.Zero : N.__Instance;
                var __ret = Internal.RemoveNode_0(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>GetOrInsertNode - If there is an existing simple Node exactly
            /// equal to the specified node, return it. Otherwise, insert 'N' and return it
            /// instead.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// GetOrInsertNode - If there is an existing simple Node
            /// exactly</para>
            /// <para>  /// equal to the specified node, return it.  Otherwise, insert
            /// 'N' and return</para>
            /// <para>  /// it instead.</para>
            /// </remarks>
            public llvm.FoldingSetImpl.Node GetOrInsertNode(llvm.FoldingSetImpl.Node N)
            {
                var arg0 = ReferenceEquals(N, null) ? global::System.IntPtr.Zero : N.__Instance;
                var __ret = Internal.GetOrInsertNode_0(__Instance, arg0);
                llvm.FoldingSetImpl.Node __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (llvm.FoldingSetImpl.Node.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (llvm.FoldingSetImpl.Node) llvm.FoldingSetImpl.Node.NativeToManagedMap[__ret];
                else __result0 = llvm.FoldingSetImpl.Node.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>FindNodeOrInsertPos - Look up the node specified by ID. If it
            /// exists, return it. If not, return the insertion token that will make
            /// insertion faster.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// FindNodeOrInsertPos - Look up the node specified by ID.  If
            /// it exists,</para>
            /// <para>  /// return it.  If not, return the insertion token that will
            /// make insertion</para>
            /// <para>  /// faster.</para>
            /// </remarks>
            public llvm.FoldingSetImpl.Node FindNodeOrInsertPos(llvm.FoldingSetNodeID ID, void** InsertPos)
            {
                var arg0 = ReferenceEquals(ID, null) ? global::System.IntPtr.Zero : ID.__Instance;
                var arg1 = InsertPos;
                var __ret = Internal.FindNodeOrInsertPos_0(__Instance, arg0, arg1);
                llvm.FoldingSetImpl.Node __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (llvm.FoldingSetImpl.Node.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (llvm.FoldingSetImpl.Node) llvm.FoldingSetImpl.Node.NativeToManagedMap[__ret];
                else __result0 = llvm.FoldingSetImpl.Node.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>InsertNode - Insert the specified node into the folding set,
            /// knowing that it is not already in the folding set. InsertPos must be
            /// obtained from FindNodeOrInsertPos.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// InsertNode - Insert the specified node into the folding set,
            /// knowing that</para>
            /// <para>  /// it is not already in the folding set.  InsertPos must be
            /// obtained from</para>
            /// <para>  /// FindNodeOrInsertPos.</para>
            /// </remarks>
            public void InsertNode(llvm.FoldingSetImpl.Node N, global::System.IntPtr InsertPos)
            {
                var arg0 = ReferenceEquals(N, null) ? global::System.IntPtr.Zero : N.__Instance;
                var arg1 = InsertPos;
                Internal.InsertNode_0(__Instance, arg0, arg1);
            }

            /// <summary>
            /// <para>InsertNode - Insert the specified node into the folding set,
            /// knowing that it is not already in the folding set.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// InsertNode - Insert the specified node into the folding set,
            /// knowing that</para>
            /// <para>  /// it is not already in the folding set.</para>
            /// </remarks>
            public void InsertNode(llvm.FoldingSetImpl.Node N)
            {
                var arg0 = ReferenceEquals(N, null) ? global::System.IntPtr.Zero : N.__Instance;
                Internal.InsertNode_1(__Instance, arg0);
            }

            /// <summary>
            /// <para>size - Returns the number of nodes in the folding set.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// size - Returns the number of nodes in the folding set.</para>
            /// </remarks>
            public uint size()
            {
                var __ret = Internal.size_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>empty - Returns true if there are no nodes in the folding
            /// set.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// empty - Returns true if there are no nodes in the folding
            /// set.</para>
            /// </remarks>
            public bool empty()
            {
                var __ret = Internal.empty_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>GetNodeProfile - Instantiations of the FoldingSet template
            /// implement this function to gather data bits for the given node.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// GetNodeProfile - Instantiations of the FoldingSet template
            /// implement</para>
            /// <para>  /// this function to gather data bits for the given
            /// node.</para>
            /// </remarks>
            protected abstract void GetNodeProfile(llvm.FoldingSetImpl.Node N, llvm.FoldingSetNodeID ID);

            /// <summary>
            /// <para>NodeEquals - Instantiations of the FoldingSet template implement
            /// this function to compare the given node with the given ID.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// NodeEquals - Instantiations of the FoldingSet template
            /// implement</para>
            /// <para>  /// this function to compare the given node with the given
            /// ID.</para>
            /// </remarks>
            protected abstract bool NodeEquals(llvm.FoldingSetImpl.Node N, llvm.FoldingSetNodeID ID, uint IDHash, llvm.FoldingSetNodeID TempID);

            /// <summary>
            /// <para>ComputeNodeHash - Instantiations of the FoldingSet template
            /// implement this function to compute a hash value for the given node.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// ComputeNodeHash - Instantiations of the FoldingSet template
            /// implement</para>
            /// <para>  /// this function to compute a hash value for the given
            /// node.</para>
            /// </remarks>
            protected abstract uint ComputeNodeHash(llvm.FoldingSetImpl.Node N, llvm.FoldingSetNodeID TempID);

            protected void** Buckets
            {
                get
                {
                    return ((Internal*) __Instance)->Buckets;
                }

                set
                {
                    ((Internal*) __Instance)->Buckets = value;
                }
            }

            protected uint NumBuckets
            {
                get
                {
                    return ((Internal*) __Instance)->NumBuckets;
                }

                set
                {
                    ((Internal*) __Instance)->NumBuckets = value;
                }
            }

            protected uint NumNodes
            {
                get
                {
                    return ((Internal*) __Instance)->NumNodes;
                }

                set
                {
                    ((Internal*) __Instance)->NumNodes = value;
                }
            }

            #region Virtual table interop

            // virtual ~FoldingSetImpl()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
            private static _dtor_0Delegate _dtor_0DelegateInstance;

            private static void _dtor_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (FoldingSetImpl) _References[instance].Target;
                __target.DestroyNativeInstance();
            }

            // void GetNodeProfile(Node *N, FoldingSetNodeID &ID) const = 0
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate void _GetNodeProfile_0Delegate(global::System.IntPtr instance, global::System.IntPtr N, global::System.IntPtr ID);
            private static _GetNodeProfile_0Delegate _GetNodeProfile_0DelegateInstance;

            private static void _GetNodeProfile_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr N, global::System.IntPtr ID)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (FoldingSetImpl) _References[instance].Target;
                llvm.FoldingSetImpl.Node __result0;
                if (N == IntPtr.Zero) __result0 = null;
                else if (llvm.FoldingSetImpl.Node.NativeToManagedMap.ContainsKey(N))
                    __result0 = (llvm.FoldingSetImpl.Node) llvm.FoldingSetImpl.Node.NativeToManagedMap[N];
                else __result0 = llvm.FoldingSetImpl.Node.__CreateInstance(N);
                llvm.FoldingSetNodeID __result1;
                if (ID == IntPtr.Zero) __result1 = null;
                else if (llvm.FoldingSetNodeID.NativeToManagedMap.ContainsKey(ID))
                    __result1 = (llvm.FoldingSetNodeID) llvm.FoldingSetNodeID.NativeToManagedMap[ID];
                else __result1 = llvm.FoldingSetNodeID.__CreateInstance(ID);
                __target.GetNodeProfile(__result0, __result1);
            }

            // bool NodeEquals(Node *N, const FoldingSetNodeID &ID, unsigned IDHash, FoldingSetNodeID &TempID) const=0
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate bool _NodeEquals_0Delegate(global::System.IntPtr instance, global::System.IntPtr N, global::System.IntPtr ID, uint IDHash, global::System.IntPtr TempID);
            private static _NodeEquals_0Delegate _NodeEquals_0DelegateInstance;

            private static bool _NodeEquals_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr N, global::System.IntPtr ID, uint IDHash, global::System.IntPtr TempID)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (FoldingSetImpl) _References[instance].Target;
                llvm.FoldingSetImpl.Node __result0;
                if (N == IntPtr.Zero) __result0 = null;
                else if (llvm.FoldingSetImpl.Node.NativeToManagedMap.ContainsKey(N))
                    __result0 = (llvm.FoldingSetImpl.Node) llvm.FoldingSetImpl.Node.NativeToManagedMap[N];
                else __result0 = llvm.FoldingSetImpl.Node.__CreateInstance(N);
                llvm.FoldingSetNodeID __result1;
                if (ID == IntPtr.Zero) __result1 = null;
                else if (llvm.FoldingSetNodeID.NativeToManagedMap.ContainsKey(ID))
                    __result1 = (llvm.FoldingSetNodeID) llvm.FoldingSetNodeID.NativeToManagedMap[ID];
                else __result1 = llvm.FoldingSetNodeID.__CreateInstance(ID);
                llvm.FoldingSetNodeID __result3;
                if (TempID == IntPtr.Zero) __result3 = null;
                else if (llvm.FoldingSetNodeID.NativeToManagedMap.ContainsKey(TempID))
                    __result3 = (llvm.FoldingSetNodeID) llvm.FoldingSetNodeID.NativeToManagedMap[TempID];
                else __result3 = llvm.FoldingSetNodeID.__CreateInstance(TempID);
                var __ret = __target.NodeEquals(__result0, __result1, IDHash, __result3);
                return __ret;
            }

            // unsigned ComputeNodeHash(Node *N, FoldingSetNodeID &TempID) const = 0
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate uint _ComputeNodeHash_0Delegate(global::System.IntPtr instance, global::System.IntPtr N, global::System.IntPtr TempID);
            private static _ComputeNodeHash_0Delegate _ComputeNodeHash_0DelegateInstance;

            private static uint _ComputeNodeHash_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr N, global::System.IntPtr TempID)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (FoldingSetImpl) _References[instance].Target;
                llvm.FoldingSetImpl.Node __result0;
                if (N == IntPtr.Zero) __result0 = null;
                else if (llvm.FoldingSetImpl.Node.NativeToManagedMap.ContainsKey(N))
                    __result0 = (llvm.FoldingSetImpl.Node) llvm.FoldingSetImpl.Node.NativeToManagedMap[N];
                else __result0 = llvm.FoldingSetImpl.Node.__CreateInstance(N);
                llvm.FoldingSetNodeID __result1;
                if (TempID == IntPtr.Zero) __result1 = null;
                else if (llvm.FoldingSetNodeID.NativeToManagedMap.ContainsKey(TempID))
                    __result1 = (llvm.FoldingSetNodeID) llvm.FoldingSetNodeID.NativeToManagedMap[TempID];
                else __result1 = llvm.FoldingSetNodeID.__CreateInstance(TempID);
                var __ret = __target.ComputeNodeHash(__result0, __result1);
                return __ret;
            }

            private static void*[] _OldVTables;
            private static void*[] _NewVTables;
            private static void*[] _Thunks;
            private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

            void SetupVTables(global::System.IntPtr instance)
            {
                var native = (Internal*)instance.ToPointer();

                if (_References == null)
                    _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

                if (_References.ContainsKey(instance))
                    return;

                _References[instance] = new WeakReference(this);

                if (_OldVTables == null)
                {
                    _OldVTables = new void*[1];
                    _OldVTables[0] = native->vfptr0.ToPointer();
                }

                if (_Thunks == null)
                {
                    _Thunks = new void*[4];
                    _dtor_0DelegateInstance += _dtor_0DelegateHook;
                    _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                    _GetNodeProfile_0DelegateInstance += _GetNodeProfile_0DelegateHook;
                    _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_GetNodeProfile_0DelegateInstance).ToPointer();
                    _NodeEquals_0DelegateInstance += _NodeEquals_0DelegateHook;
                    _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_NodeEquals_0DelegateInstance).ToPointer();
                    _ComputeNodeHash_0DelegateInstance += _ComputeNodeHash_0DelegateHook;
                    _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_ComputeNodeHash_0DelegateInstance).ToPointer();
                }

                if (_NewVTables == null)
                {
                    _NewVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(4 * 8);
                    _NewVTables[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + 8) = _Thunks[0];
                    *(void**)(vfptr0 + 16) = _Thunks[1];
                    *(void**)(vfptr0 + 24) = _Thunks[2];
                    *(void**)(vfptr0 + 32) = _Thunks[3];
                }

                native->vfptr0 = new IntPtr(_NewVTables[0]);
            }

            #endregion
        }

        /// <summary>
        /// <para>FoldingSetNodeIDRef - This class describes a reference to an
        /// interned FoldingSetNodeID, which can be a useful to store node id data
        /// rather than using plain FoldingSetNodeIDs, since the 32-element SmallVector
        /// is often much larger than necessary, and the possibility of heap allocation
        /// means it requires a non-trivial destructor call.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// FoldingSetNodeIDRef - This class describes a reference to an
        /// interned</para>
        /// <para>/// FoldingSetNodeID, which can be a useful to store node id data
        /// rather</para>
        /// <para>/// than using plain FoldingSetNodeIDs, since the 32-element
        /// SmallVector</para>
        /// <para>/// is often much larger than necessary, and the possibility of
        /// heap</para>
        /// <para>/// allocation means it requires a non-trivial destructor
        /// call.</para>
        /// </remarks>
        public unsafe partial class FoldingSetNodeIDRef : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public uint* Data;

                [FieldOffset(8)]
                public ulong Size;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm19FoldingSetNodeIDRefC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm19FoldingSetNodeIDRefC2EPKjm")]
                internal static extern void ctor_1(global::System.IntPtr instance, uint* D, ulong S);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm19FoldingSetNodeIDRefC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm19FoldingSetNodeIDRef11ComputeHashEv")]
                internal static extern uint ComputeHash_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm19FoldingSetNodeIDRefeqES0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorEqualEqual_0(global::System.IntPtr instance, llvm.FoldingSetNodeIDRef.Internal _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm19FoldingSetNodeIDRefneES0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorExclaimEqual_0(global::System.IntPtr instance, llvm.FoldingSetNodeIDRef.Internal RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm19FoldingSetNodeIDRefltES0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorLess_0(global::System.IntPtr instance, llvm.FoldingSetNodeIDRef.Internal _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm19FoldingSetNodeIDRef7getDataEv")]
                internal static extern uint* getData_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm19FoldingSetNodeIDRef7getSizeEv")]
                internal static extern ulong getSize_0(global::System.IntPtr instance);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, FoldingSetNodeIDRef> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, FoldingSetNodeIDRef>();

            private readonly bool __ownsNativeInstance;

            public static FoldingSetNodeIDRef __CreateInstance(global::System.IntPtr native)
            {
                return new FoldingSetNodeIDRef((FoldingSetNodeIDRef.Internal*) native);
            }

            public static FoldingSetNodeIDRef __CreateInstance(FoldingSetNodeIDRef.Internal native)
            {
                return new FoldingSetNodeIDRef(native);
            }

            private static FoldingSetNodeIDRef.Internal* __CopyValue(FoldingSetNodeIDRef.Internal native)
            {
                var ret = (FoldingSetNodeIDRef.Internal*) Marshal.AllocHGlobal(16);
                *ret = native;
                return ret;
            }

            private FoldingSetNodeIDRef(FoldingSetNodeIDRef.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected FoldingSetNodeIDRef(FoldingSetNodeIDRef.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public FoldingSetNodeIDRef()
            {
                __Instance = Marshal.AllocHGlobal(16);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public FoldingSetNodeIDRef(ref uint D, ulong S)
            {
                __Instance = Marshal.AllocHGlobal(16);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                fixed (uint* arg0 = &D)
                {
                    var arg1 = S;
                    Internal.ctor_1(__Instance, arg0, arg1);
                }
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                llvm.FoldingSetNodeIDRef __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            /// <summary>
            /// <para>ComputeHash - Compute a strong hash value for this
            /// FoldingSetNodeIDRef, used to lookup the node in the FoldingSetImpl.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// ComputeHash - Compute a strong hash value for this
            /// FoldingSetNodeIDRef,</para>
            /// <para>  /// used to lookup the node in the FoldingSetImpl.</para>
            /// </remarks>
            public uint ComputeHash()
            {
                var __ret = Internal.ComputeHash_0(__Instance);
                return __ret;
            }

            public static bool operator ==(llvm.FoldingSetNodeIDRef __op, llvm.FoldingSetNodeIDRef _0)
            {
                bool __opNull = ReferenceEquals(__op, null);
                bool _0Null = ReferenceEquals(_0, null);
                if (__opNull || _0Null)
                    return __opNull && _0Null;
                var arg0 = __op.__Instance;
                var arg1 = ReferenceEquals(_0, null) ? new llvm.FoldingSetNodeIDRef.Internal() : *(llvm.FoldingSetNodeIDRef.Internal*) (_0.__Instance);
                var __ret = Internal.OperatorEqualEqual_0(arg0, arg1);
                return __ret;
            }

            public override bool Equals(object obj)
            {
                return this == obj as FoldingSetNodeIDRef;
            }

            public static bool operator !=(llvm.FoldingSetNodeIDRef __op, llvm.FoldingSetNodeIDRef RHS)
            {
                var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
                var arg1 = ReferenceEquals(RHS, null) ? new llvm.FoldingSetNodeIDRef.Internal() : *(llvm.FoldingSetNodeIDRef.Internal*) (RHS.__Instance);
                var __ret = Internal.OperatorExclaimEqual_0(arg0, arg1);
                return __ret;
            }

            public static bool operator >(llvm.FoldingSetNodeIDRef __op, llvm.FoldingSetNodeIDRef _0)
            {
                return !(__op < _0);
            }

            /// <summary>
            /// <para>Used to compare the &quot;ordering&quot; of two nodes as defined
            /// by the profiled bits and their ordering defined by memcmp().</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Used to compare the &quot;ordering&quot; of two nodes as
            /// defined by the</para>
            /// <para>  /// profiled bits and their ordering defined by
            /// memcmp().</para>
            /// </remarks>
            public static bool operator <(llvm.FoldingSetNodeIDRef __op, llvm.FoldingSetNodeIDRef _0)
            {
                var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
                var arg1 = ReferenceEquals(_0, null) ? new llvm.FoldingSetNodeIDRef.Internal() : *(llvm.FoldingSetNodeIDRef.Internal*) (_0.__Instance);
                var __ret = Internal.OperatorLess_0(arg0, arg1);
                return __ret;
            }

            public uint* getData()
            {
                var __ret = Internal.getData_0(__Instance);
                return __ret;
            }

            public ulong getSize()
            {
                var __ret = Internal.getSize_0(__Instance);
                return __ret;
            }
        }

        /// <summary>
        /// <para>FoldingSetNodeID - This class is used to gather all the unique
        /// data bits of a node. When all the bits are gathered this class is used to
        /// produce a hash value for the node.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// FoldingSetNodeID - This class is used to gather all the
        /// unique data bits of</para>
        /// <para>/// a node.  When all the bits are gathered this class is used to
        /// produce a</para>
        /// <para>/// hash value for the node.</para>
        /// <para>///</para>
        /// </remarks>
        public unsafe partial class FoldingSetNodeID : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 152)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                internal llvm.SmallVector.Internal Bits;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm16FoldingSetNodeIDC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm16FoldingSetNodeIDC2ENS_19FoldingSetNodeIDRefE")]
                internal static extern void ctor_1(global::System.IntPtr instance, llvm.FoldingSetNodeIDRef.Internal Ref);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm16FoldingSetNodeIDC2ERKS0_")]
                internal static extern void cctor_3(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm16FoldingSetNodeIDD2Ev")]
                internal static extern void dtor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm16FoldingSetNodeID10AddPointerEPKv")]
                internal static extern void AddPointer_0(global::System.IntPtr instance, global::System.IntPtr Ptr);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm16FoldingSetNodeID10AddIntegerEi")]
                internal static extern void AddInteger_0(global::System.IntPtr instance, int I);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm16FoldingSetNodeID10AddIntegerEj")]
                internal static extern void AddInteger_1(global::System.IntPtr instance, uint I);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm16FoldingSetNodeID10AddIntegerEl")]
                internal static extern void AddInteger_2(global::System.IntPtr instance, long I);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm16FoldingSetNodeID10AddIntegerEm")]
                internal static extern void AddInteger_3(global::System.IntPtr instance, ulong I);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm16FoldingSetNodeID10AddIntegerEx")]
                internal static extern void AddInteger_4(global::System.IntPtr instance, long I);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm16FoldingSetNodeID10AddIntegerEy")]
                internal static extern void AddInteger_5(global::System.IntPtr instance, ulong I);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm16FoldingSetNodeID10AddBooleanEb")]
                internal static extern void AddBoolean_0(global::System.IntPtr instance, bool B);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm16FoldingSetNodeID9AddStringENS_9StringRefE")]
                internal static extern void AddString_0(global::System.IntPtr instance, llvm.StringRef.Internal String);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm16FoldingSetNodeID9AddNodeIDERKS0_")]
                internal static extern void AddNodeID_0(global::System.IntPtr instance, global::System.IntPtr ID);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm16FoldingSetNodeID5clearEv")]
                internal static extern void clear_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm16FoldingSetNodeID11ComputeHashEv")]
                internal static extern uint ComputeHash_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm16FoldingSetNodeIDeqERKS0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorEqualEqual_0(global::System.IntPtr instance, global::System.IntPtr RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm16FoldingSetNodeIDeqENS_19FoldingSetNodeIDRefE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorEqualEqual_1(global::System.IntPtr instance, llvm.FoldingSetNodeIDRef.Internal RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm16FoldingSetNodeIDneERKS0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorExclaimEqual_0(global::System.IntPtr instance, global::System.IntPtr RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm16FoldingSetNodeIDneENS_19FoldingSetNodeIDRefE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorExclaimEqual_1(global::System.IntPtr instance, llvm.FoldingSetNodeIDRef.Internal RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm16FoldingSetNodeIDltERKS0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorLess_0(global::System.IntPtr instance, global::System.IntPtr RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm16FoldingSetNodeIDltENS_19FoldingSetNodeIDRefE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorLess_1(global::System.IntPtr instance, llvm.FoldingSetNodeIDRef.Internal RHS);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, FoldingSetNodeID> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, FoldingSetNodeID>();

            private readonly bool __ownsNativeInstance;

            public static FoldingSetNodeID __CreateInstance(global::System.IntPtr native)
            {
                return new FoldingSetNodeID((FoldingSetNodeID.Internal*) native);
            }

            public static FoldingSetNodeID __CreateInstance(FoldingSetNodeID.Internal native)
            {
                return new FoldingSetNodeID(native);
            }

            private static FoldingSetNodeID.Internal* __CopyValue(FoldingSetNodeID.Internal native)
            {
                var ret = (FoldingSetNodeID.Internal*) Marshal.AllocHGlobal(152);
                *ret = native;
                return ret;
            }

            private FoldingSetNodeID(FoldingSetNodeID.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected FoldingSetNodeID(FoldingSetNodeID.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public FoldingSetNodeID()
            {
                __Instance = Marshal.AllocHGlobal(152);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public FoldingSetNodeID(llvm.FoldingSetNodeIDRef Ref)
            {
                __Instance = Marshal.AllocHGlobal(152);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(Ref, null) ? new llvm.FoldingSetNodeIDRef.Internal() : *(llvm.FoldingSetNodeIDRef.Internal*) (Ref.__Instance);
                Internal.ctor_1(__Instance, arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                llvm.FoldingSetNodeID __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance || force)
                    Internal.dtor_0(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            /// <summary>
            /// <para>Add* - Add various data types to Bit data.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Add* - Add various data types to Bit data.</para>
            /// <para>  ///</para>
            /// </remarks>
            public void AddPointer(global::System.IntPtr Ptr)
            {
                var arg0 = Ptr;
                Internal.AddPointer_0(__Instance, arg0);
            }

            public void AddInteger(int I)
            {
                Internal.AddInteger_0(__Instance, I);
            }

            public void AddInteger(uint I)
            {
                Internal.AddInteger_1(__Instance, I);
            }

            public void AddInteger(long I)
            {
                Internal.AddInteger_2(__Instance, I);
            }

            public void AddInteger(ulong I)
            {
                Internal.AddInteger_3(__Instance, I);
            }

            public void AddInteger(long I)
            {
                Internal.AddInteger_4(__Instance, I);
            }

            public void AddInteger(ulong I)
            {
                Internal.AddInteger_5(__Instance, I);
            }

            public void AddBoolean(bool B)
            {
                Internal.AddBoolean_0(__Instance, B);
            }

            public void AddString(llvm.StringRef String)
            {
                var arg0 = ReferenceEquals(String, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (String.__Instance);
                Internal.AddString_0(__Instance, arg0);
            }

            public void AddNodeID(llvm.FoldingSetNodeID ID)
            {
                var arg0 = ReferenceEquals(ID, null) ? global::System.IntPtr.Zero : ID.__Instance;
                Internal.AddNodeID_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>clear - Clear the accumulated profile, allowing this
            /// FoldingSetNodeID object to be used to compute a new profile.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// clear - Clear the accumulated profile, allowing this
            /// FoldingSetNodeID</para>
            /// <para>  /// object to be used to compute a new profile.</para>
            /// </remarks>
            public void clear()
            {
                Internal.clear_0(__Instance);
            }

            /// <summary>
            /// <para>ComputeHash - Compute a strong hash value for this
            /// FoldingSetNodeID, used to lookup the node in the FoldingSetImpl.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// ComputeHash - Compute a strong hash value for this
            /// FoldingSetNodeID, used</para>
            /// <para>  /// to lookup the node in the FoldingSetImpl.</para>
            /// </remarks>
            public uint ComputeHash()
            {
                var __ret = Internal.ComputeHash_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>operator== - Used to compare two nodes to each other.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// operator== - Used to compare two nodes to each other.</para>
            /// <para>  ///</para>
            /// </remarks>
            public static bool operator ==(llvm.FoldingSetNodeID __op, llvm.FoldingSetNodeID RHS)
            {
                bool __opNull = ReferenceEquals(__op, null);
                bool RHSNull = ReferenceEquals(RHS, null);
                if (__opNull || RHSNull)
                    return __opNull && RHSNull;
                var arg0 = __op.__Instance;
                var arg1 = RHS.__Instance;
                var __ret = Internal.OperatorEqualEqual_0(arg0, arg1);
                return __ret;
            }

            public override bool Equals(object obj)
            {
                return this == obj as FoldingSetNodeID;
            }

            public static bool operator ==(llvm.FoldingSetNodeID __op, llvm.FoldingSetNodeIDRef RHS)
            {
                bool __opNull = ReferenceEquals(__op, null);
                bool RHSNull = ReferenceEquals(RHS, null);
                if (__opNull || RHSNull)
                    return __opNull && RHSNull;
                var arg0 = __op.__Instance;
                var arg1 = ReferenceEquals(RHS, null) ? new llvm.FoldingSetNodeIDRef.Internal() : *(llvm.FoldingSetNodeIDRef.Internal*) (RHS.__Instance);
                var __ret = Internal.OperatorEqualEqual_1(arg0, arg1);
                return __ret;
            }

            public static bool operator !=(llvm.FoldingSetNodeID __op, llvm.FoldingSetNodeID RHS)
            {
                var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
                var arg1 = ReferenceEquals(RHS, null) ? global::System.IntPtr.Zero : RHS.__Instance;
                var __ret = Internal.OperatorExclaimEqual_0(arg0, arg1);
                return __ret;
            }

            public static bool operator !=(llvm.FoldingSetNodeID __op, llvm.FoldingSetNodeIDRef RHS)
            {
                var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
                var arg1 = ReferenceEquals(RHS, null) ? new llvm.FoldingSetNodeIDRef.Internal() : *(llvm.FoldingSetNodeIDRef.Internal*) (RHS.__Instance);
                var __ret = Internal.OperatorExclaimEqual_1(arg0, arg1);
                return __ret;
            }

            public static bool operator >(llvm.FoldingSetNodeID __op, llvm.FoldingSetNodeID RHS)
            {
                return !(__op < RHS);
            }

            /// <summary>
            /// <para>Used to compare the &quot;ordering&quot; of two nodes as defined
            /// by the profiled bits and their ordering defined by memcmp().</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Used to compare the &quot;ordering&quot; of two nodes as
            /// defined by the</para>
            /// <para>  /// profiled bits and their ordering defined by
            /// memcmp().</para>
            /// </remarks>
            public static bool operator <(llvm.FoldingSetNodeID __op, llvm.FoldingSetNodeID RHS)
            {
                var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
                var arg1 = ReferenceEquals(RHS, null) ? global::System.IntPtr.Zero : RHS.__Instance;
                var __ret = Internal.OperatorLess_0(arg0, arg1);
                return __ret;
            }

            public static bool operator >(llvm.FoldingSetNodeID __op, llvm.FoldingSetNodeIDRef RHS)
            {
                return !(__op < RHS);
            }

            public static bool operator <(llvm.FoldingSetNodeID __op, llvm.FoldingSetNodeIDRef RHS)
            {
                var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
                var arg1 = ReferenceEquals(RHS, null) ? new llvm.FoldingSetNodeIDRef.Internal() : *(llvm.FoldingSetNodeIDRef.Internal*) (RHS.__Instance);
                var __ret = Internal.OperatorLess_1(arg0, arg1);
                return __ret;
            }
        }

        /// <summary>
        /// <para>FoldingSetIteratorImpl - This is the common iterator support
        /// shared by all folding sets, which knows how to walk the folding set hash
        /// table.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// FoldingSetIteratorImpl - This is the common iterator support
        /// shared by all</para>
        /// <para>/// folding sets, which knows how to walk the folding set hash
        /// table.</para>
        /// </remarks>
        public unsafe partial class FoldingSetIteratorImpl : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 8)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr NodePtr;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm22FoldingSetIteratorImplC2EPPv")]
                internal static extern void ctor_0(global::System.IntPtr instance, void** Bucket);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm22FoldingSetIteratorImplC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm22FoldingSetIteratorImpl7advanceEv")]
                internal static extern void advance_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm22FoldingSetIteratorImpleqERKS0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorEqualEqual_0(global::System.IntPtr instance, global::System.IntPtr RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm22FoldingSetIteratorImplneERKS0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorExclaimEqual_0(global::System.IntPtr instance, global::System.IntPtr RHS);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, FoldingSetIteratorImpl> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, FoldingSetIteratorImpl>();

            private readonly bool __ownsNativeInstance;

            public static FoldingSetIteratorImpl __CreateInstance(global::System.IntPtr native)
            {
                return new FoldingSetIteratorImpl((FoldingSetIteratorImpl.Internal*) native);
            }

            public static FoldingSetIteratorImpl __CreateInstance(FoldingSetIteratorImpl.Internal native)
            {
                return new FoldingSetIteratorImpl(native);
            }

            private static FoldingSetIteratorImpl.Internal* __CopyValue(FoldingSetIteratorImpl.Internal native)
            {
                var ret = (FoldingSetIteratorImpl.Internal*) Marshal.AllocHGlobal(8);
                *ret = native;
                return ret;
            }

            private FoldingSetIteratorImpl(FoldingSetIteratorImpl.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected FoldingSetIteratorImpl(FoldingSetIteratorImpl.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            protected FoldingSetIteratorImpl(void** Bucket)
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = Bucket;
                Internal.ctor_0(__Instance, arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                llvm.FoldingSetIteratorImpl __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            protected void advance()
            {
                Internal.advance_0(__Instance);
            }

            public static bool operator ==(llvm.FoldingSetIteratorImpl __op, llvm.FoldingSetIteratorImpl RHS)
            {
                bool __opNull = ReferenceEquals(__op, null);
                bool RHSNull = ReferenceEquals(RHS, null);
                if (__opNull || RHSNull)
                    return __opNull && RHSNull;
                var arg0 = __op.__Instance;
                var arg1 = RHS.__Instance;
                var __ret = Internal.OperatorEqualEqual_0(arg0, arg1);
                return __ret;
            }

            public override bool Equals(object obj)
            {
                return this == obj as FoldingSetIteratorImpl;
            }

            public static bool operator !=(llvm.FoldingSetIteratorImpl __op, llvm.FoldingSetIteratorImpl RHS)
            {
                var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
                var arg1 = ReferenceEquals(RHS, null) ? global::System.IntPtr.Zero : RHS.__Instance;
                var __ret = Internal.OperatorExclaimEqual_0(arg0, arg1);
                return __ret;
            }

            protected llvm.FoldingSetImpl.Node NodePtr
            {
                get
                {
                    llvm.FoldingSetImpl.Node __result0;
                    if (((Internal*) __Instance)->NodePtr == IntPtr.Zero) __result0 = null;
                    else if (llvm.FoldingSetImpl.Node.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->NodePtr))
                        __result0 = (llvm.FoldingSetImpl.Node) llvm.FoldingSetImpl.Node.NativeToManagedMap[((Internal*) __Instance)->NodePtr];
                    else __result0 = llvm.FoldingSetImpl.Node.__CreateInstance(((Internal*) __Instance)->NodePtr);
                    return __result0;
                }

                set
                {
                    ((Internal*) __Instance)->NodePtr = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                }
            }
        }

        /// <summary>
        /// <para>FoldingSetBucketIteratorImpl - This is the common bucket iterator
        /// support shared by all folding sets, which knows how to walk a particular
        /// bucket of a folding set hash table.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// FoldingSetBucketIteratorImpl - This is the common bucket
        /// iterator support</para>
        /// <para>/// shared by all folding sets, which knows how to walk a
        /// particular bucket</para>
        /// <para>/// of a folding set hash table.</para>
        /// </remarks>
        public unsafe partial class FoldingSetBucketIteratorImpl : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 8)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr Ptr;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm28FoldingSetBucketIteratorImplC2EPPv")]
                internal static extern void ctor_0(global::System.IntPtr instance, void** Bucket);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm28FoldingSetBucketIteratorImplC2EPPvb")]
                internal static extern void ctor_1(global::System.IntPtr instance, void** Bucket, bool _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm28FoldingSetBucketIteratorImplC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm28FoldingSetBucketIteratorImpl7advanceEv")]
                internal static extern void advance_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm28FoldingSetBucketIteratorImpleqERKS0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorEqualEqual_0(global::System.IntPtr instance, global::System.IntPtr RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm28FoldingSetBucketIteratorImplneERKS0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorExclaimEqual_0(global::System.IntPtr instance, global::System.IntPtr RHS);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, FoldingSetBucketIteratorImpl> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, FoldingSetBucketIteratorImpl>();

            private readonly bool __ownsNativeInstance;

            public static FoldingSetBucketIteratorImpl __CreateInstance(global::System.IntPtr native)
            {
                return new FoldingSetBucketIteratorImpl((FoldingSetBucketIteratorImpl.Internal*) native);
            }

            public static FoldingSetBucketIteratorImpl __CreateInstance(FoldingSetBucketIteratorImpl.Internal native)
            {
                return new FoldingSetBucketIteratorImpl(native);
            }

            private static FoldingSetBucketIteratorImpl.Internal* __CopyValue(FoldingSetBucketIteratorImpl.Internal native)
            {
                var ret = (FoldingSetBucketIteratorImpl.Internal*) Marshal.AllocHGlobal(8);
                *ret = native;
                return ret;
            }

            private FoldingSetBucketIteratorImpl(FoldingSetBucketIteratorImpl.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected FoldingSetBucketIteratorImpl(FoldingSetBucketIteratorImpl.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            protected FoldingSetBucketIteratorImpl(void** Bucket)
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = Bucket;
                Internal.ctor_0(__Instance, arg0);
            }

            protected FoldingSetBucketIteratorImpl(void** Bucket, bool _0)
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = Bucket;
                Internal.ctor_1(__Instance, arg0, _0);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                llvm.FoldingSetBucketIteratorImpl __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            protected void advance()
            {
                Internal.advance_0(__Instance);
            }

            public static bool operator ==(llvm.FoldingSetBucketIteratorImpl __op, llvm.FoldingSetBucketIteratorImpl RHS)
            {
                bool __opNull = ReferenceEquals(__op, null);
                bool RHSNull = ReferenceEquals(RHS, null);
                if (__opNull || RHSNull)
                    return __opNull && RHSNull;
                var arg0 = __op.__Instance;
                var arg1 = RHS.__Instance;
                var __ret = Internal.OperatorEqualEqual_0(arg0, arg1);
                return __ret;
            }

            public override bool Equals(object obj)
            {
                return this == obj as FoldingSetBucketIteratorImpl;
            }

            public static bool operator !=(llvm.FoldingSetBucketIteratorImpl __op, llvm.FoldingSetBucketIteratorImpl RHS)
            {
                var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
                var arg1 = ReferenceEquals(RHS, null) ? global::System.IntPtr.Zero : RHS.__Instance;
                var __ret = Internal.OperatorExclaimEqual_0(arg0, arg1);
                return __ret;
            }

            protected global::System.IntPtr Ptr
            {
                get
                {
                    return ((Internal*) __Instance)->Ptr;
                }

                set
                {
                    ((Internal*) __Instance)->Ptr = value;
                }
            }
        }

        /// <summary>
        /// <para>FastFoldingSetNode - This is a subclass of FoldingSetNode which
        /// stores a FoldingSetNodeID value rather than requiring the node to recompute
        /// it each time it is needed. This trades space for speed (which can be
        /// significant if the ID is long), and it also permits nodes to drop
        /// information that would otherwise only be required for recomputing an
        /// ID.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// FastFoldingSetNode - This is a subclass of FoldingSetNode
        /// which stores</para>
        /// <para>/// a FoldingSetNodeID value rather than requiring the node to
        /// recompute it</para>
        /// <para>/// each time it is needed. This trades space for speed (which
        /// can be</para>
        /// <para>/// significant if the ID is long), and it also permits nodes to
        /// drop</para>
        /// <para>/// information that would otherwise only be required for
        /// recomputing an ID.</para>
        /// </remarks>
        public unsafe partial class FastFoldingSetNode : llvm.FoldingSetImpl.Node, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 160)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr NextInFoldingSetBucket;

                [FieldOffset(8)]
                public llvm.FoldingSetNodeID.Internal FastID;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm18FastFoldingSetNodeC2ERKNS_16FoldingSetNodeIDE")]
                internal static extern void ctor_0(global::System.IntPtr instance, global::System.IntPtr ID);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm18FastFoldingSetNodeC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm18FastFoldingSetNodeD2Ev")]
                internal static extern void dtor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm18FastFoldingSetNode7ProfileERNS_16FoldingSetNodeIDE")]
                internal static extern void Profile_0(global::System.IntPtr instance, global::System.IntPtr ID);
            }

            private readonly bool __ownsNativeInstance;

            public static new FastFoldingSetNode __CreateInstance(global::System.IntPtr native)
            {
                return new FastFoldingSetNode((FastFoldingSetNode.Internal*) native);
            }

            public static FastFoldingSetNode __CreateInstance(FastFoldingSetNode.Internal native)
            {
                return new FastFoldingSetNode(native);
            }

            private static FastFoldingSetNode.Internal* __CopyValue(FastFoldingSetNode.Internal native)
            {
                var ret = (FastFoldingSetNode.Internal*) Marshal.AllocHGlobal(160);
                *ret = native;
                return ret;
            }

            private FastFoldingSetNode(FastFoldingSetNode.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected FastFoldingSetNode(FastFoldingSetNode.Internal* native, bool isInternalImpl = false)
                : base((llvm.FoldingSetImpl.Node.Internal*) native)
            {
            }

            protected FastFoldingSetNode(llvm.FoldingSetNodeID ID)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(160);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(ID, null) ? global::System.IntPtr.Zero : ID.__Instance;
                Internal.ctor_0(__Instance, arg0);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                llvm.FoldingSetImpl.Node __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public void Profile(llvm.FoldingSetNodeID ID)
            {
                var arg0 = ReferenceEquals(ID, null) ? global::System.IntPtr.Zero : ID.__Instance;
                Internal.Profile_0(__Instance, arg0);
            }
        }

        internal unsafe partial class FoldingSetImplInternal : llvm.FoldingSetImpl, IDisposable
        {
            private readonly bool __ownsNativeInstance;

            private static FoldingSetImpl.Internal* __CopyValue(FoldingSetImpl.Internal native)
            {
                var ret = (FoldingSetImpl.Internal*) Marshal.AllocHGlobal(24);
                *ret = native;
                return ret;
            }

            internal FoldingSetImplInternal(FoldingSetImpl.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            internal FoldingSetImplInternal(FoldingSetImpl.Internal* native, bool isInternalImpl = false)
                : base((llvm.FoldingSetImpl.Internal*) native, true)
            {
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                llvm.FoldingSetImpl __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            /// <summary>
            /// <para>GetNodeProfile - Instantiations of the FoldingSet template
            /// implement this function to gather data bits for the given node.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// GetNodeProfile - Instantiations of the FoldingSet template
            /// implement</para>
            /// <para>  /// this function to gather data bits for the given
            /// node.</para>
            /// </remarks>
            protected override void GetNodeProfile(llvm.FoldingSetImpl.Node N, llvm.FoldingSetNodeID ID)
            {
                void* slot = *(void**) (((FoldingSetImpl.Internal*) __Instance)->vfptr0 + 2 * 8);
                var ___GetNodeProfile_0Delegate = (_GetNodeProfile_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_GetNodeProfile_0Delegate));
                var arg0 = ReferenceEquals(N, null) ? global::System.IntPtr.Zero : N.__Instance;
                var arg1 = ReferenceEquals(ID, null) ? global::System.IntPtr.Zero : ID.__Instance;
                ___GetNodeProfile_0Delegate(__Instance, arg0, arg1);
            }

            /// <summary>
            /// <para>NodeEquals - Instantiations of the FoldingSet template implement
            /// this function to compare the given node with the given ID.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// NodeEquals - Instantiations of the FoldingSet template
            /// implement</para>
            /// <para>  /// this function to compare the given node with the given
            /// ID.</para>
            /// </remarks>
            protected override bool NodeEquals(llvm.FoldingSetImpl.Node N, llvm.FoldingSetNodeID ID, uint IDHash, llvm.FoldingSetNodeID TempID)
            {
                void* slot = *(void**) (((FoldingSetImpl.Internal*) __Instance)->vfptr0 + 3 * 8);
                var ___NodeEquals_0Delegate = (_NodeEquals_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_NodeEquals_0Delegate));
                var arg0 = ReferenceEquals(N, null) ? global::System.IntPtr.Zero : N.__Instance;
                var arg1 = ReferenceEquals(ID, null) ? global::System.IntPtr.Zero : ID.__Instance;
                var arg3 = ReferenceEquals(TempID, null) ? global::System.IntPtr.Zero : TempID.__Instance;
                var __ret = ___NodeEquals_0Delegate(__Instance, arg0, arg1, IDHash, arg3);
                return __ret;
            }

            /// <summary>
            /// <para>ComputeNodeHash - Instantiations of the FoldingSet template
            /// implement this function to compute a hash value for the given node.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// ComputeNodeHash - Instantiations of the FoldingSet template
            /// implement</para>
            /// <para>  /// this function to compute a hash value for the given
            /// node.</para>
            /// </remarks>
            protected override uint ComputeNodeHash(llvm.FoldingSetImpl.Node N, llvm.FoldingSetNodeID TempID)
            {
                void* slot = *(void**) (((FoldingSetImpl.Internal*) __Instance)->vfptr0 + 4 * 8);
                var ___ComputeNodeHash_0Delegate = (_ComputeNodeHash_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_ComputeNodeHash_0Delegate));
                var arg0 = ReferenceEquals(N, null) ? global::System.IntPtr.Zero : N.__Instance;
                var arg1 = ReferenceEquals(TempID, null) ? global::System.IntPtr.Zero : TempID.__Instance;
                var __ret = ___ComputeNodeHash_0Delegate(__Instance, arg0, arg1);
                return __ret;
            }
        }
    }
}
