//----------------------------------------------------------------------------
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
//----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace CppSharp
{
    namespace llvm
    {
        public unsafe partial class AlignmentCalcImpl
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public sbyte x;
            }
        }

        /// <summary>
        /// <para>AlignOf - A templated class that contains an enum value
        /// representing the alignment of the template argument. For example,
        /// AlignOf&lt;int&gt;::Alignment represents the alignment of type
        /// &quot;int&quot;. The alignment calculated is the minimum alignment, and not
        /// necessarily the &quot;desired&quot; alignment returned by GCC's __alignof__
        /// (for example). Note that because the alignment is an enum value, it can be
        /// used as a compile-time constant (e.g., for template instantiation).</para>
        /// </summary>
        /// <remarks>
        /// <para>/// AlignOf - A templated class that contains an enum value
        /// representing</para>
        /// <para>///  the alignment of the template argument.  For example,</para>
        /// <para>///  AlignOf&lt;int&gt;::Alignment represents the alignment of
        /// type &quot;int&quot;.  The</para>
        /// <para>///  alignment calculated is the minimum alignment, and not
        /// necessarily</para>
        /// <para>///  the &quot;desired&quot; alignment returned by GCC's
        /// __alignof__ (for example).  Note</para>
        /// <para>///  that because the alignment is an enum value, it can be used
        /// as a</para>
        /// <para>///  compile-time constant (e.g., for template
        /// instantiation).</para>
        /// </remarks>
        public unsafe static partial class AlignOf
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct Internal
            {
            }
        }

        public unsafe partial class AlignedCharArray
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct Internal
            {
            }
        }

        /// <summary>
        /// <para>This union template exposes a suitably aligned and sized
        /// character array member which can hold elements of any of up to four
        /// types.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief This union template exposes a suitably aligned and
        /// sized character</para>
        /// <para>/// array member which can hold elements of any of up to four
        /// types.</para>
        /// <para>///</para>
        /// <para>/// These types may be arrays, structs, or any other types. The
        /// goal is to</para>
        /// <para>/// expose a char array buffer member which can be used as
        /// suitable storage for</para>
        /// <para>/// a placement new of any of these types. Support for more than
        /// seven types can</para>
        /// <para>/// be added at the cost of more boiler plate.</para>
        /// </remarks>
        public unsafe static partial class AlignedCharArrayUnion
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct Internal
            {
            }
        }

        namespace detail
        {
            public unsafe partial class AlignerImpl
            {
                [StructLayout(LayoutKind.Explicit, Size = 0)]
                public partial struct Internal
                {
                }
            }

            public unsafe partial struct SizerImpl
            {
                [StructLayout(LayoutKind.Explicit, Size = 0)]
                public partial struct Internal
                {
                }
            }
        }
    }
}
