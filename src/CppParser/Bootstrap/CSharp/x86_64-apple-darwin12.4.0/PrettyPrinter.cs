//----------------------------------------------------------------------------
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
//----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace CppSharp
{
    namespace clang
    {
        public unsafe abstract partial class PrinterHelper : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 8)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr vfptr0;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13PrinterHelperC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13PrinterHelperC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13PrinterHelperD2Ev")]
                internal static extern void dtor_0(global::System.IntPtr instance);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, PrinterHelper> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, PrinterHelper>();

            private readonly bool __ownsNativeInstance;

            public static PrinterHelper __CreateInstance(global::System.IntPtr native)
            {
                return new PrinterHelperInternal((PrinterHelper.Internal*) native);
            }

            public static PrinterHelper __CreateInstance(PrinterHelper.Internal native)
            {
                return new PrinterHelperInternal(native);
            }

            protected PrinterHelper(PrinterHelper.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
                if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                    SetupVTables(__Instance);
            }

            protected PrinterHelper()
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
                SetupVTables(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.PrinterHelper __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance || force)
                    Internal.dtor_0(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public abstract bool handledStmt(clang.Stmt E, llvm.raw_ostream OS);

            #region Virtual table interop

            // virtual ~PrinterHelper()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
            private static _dtor_0Delegate _dtor_0DelegateInstance;

            private static void _dtor_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (PrinterHelper) _References[instance].Target;
                __target.DestroyNativeInstance();
            }

            // bool handledStmt(Stmt* E, raw_ostream& OS) = 0
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate bool _handledStmt_0Delegate(global::System.IntPtr instance, global::System.IntPtr E, global::System.IntPtr OS);
            private static _handledStmt_0Delegate _handledStmt_0DelegateInstance;

            private static bool _handledStmt_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr E, global::System.IntPtr OS)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (PrinterHelper) _References[instance].Target;
                clang.Stmt __result0;
                if (E == IntPtr.Zero) __result0 = null;
                else if (clang.Stmt.NativeToManagedMap.ContainsKey(E))
                    __result0 = (clang.Stmt) clang.Stmt.NativeToManagedMap[E];
                else __result0 = clang.Stmt.__CreateInstance(E);
                llvm.raw_ostream __result1;
                if (OS == IntPtr.Zero) __result1 = null;
                else if (llvm.raw_ostream.NativeToManagedMap.ContainsKey(OS))
                    __result1 = (llvm.raw_ostream) llvm.raw_ostream.NativeToManagedMap[OS];
                else llvm.raw_ostream.NativeToManagedMap[OS] = __result1 = (llvm.raw_ostream) llvm.raw_ostream.__CreateInstance(OS);
                var __ret = __target.handledStmt(__result0, __result1);
                return __ret;
            }

            private static void*[] _OldVTables;
            private static void*[] _NewVTables;
            private static void*[] _Thunks;
            private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

            void SetupVTables(global::System.IntPtr instance)
            {
                var native = (Internal*)instance.ToPointer();

                if (_References == null)
                    _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

                if (_References.ContainsKey(instance))
                    return;

                _References[instance] = new WeakReference(this);

                if (_OldVTables == null)
                {
                    _OldVTables = new void*[1];
                    _OldVTables[0] = native->vfptr0.ToPointer();
                }

                if (_Thunks == null)
                {
                    _Thunks = new void*[2];
                    _dtor_0DelegateInstance += _dtor_0DelegateHook;
                    _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                    _handledStmt_0DelegateInstance += _handledStmt_0DelegateHook;
                    _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_handledStmt_0DelegateInstance).ToPointer();
                }

                if (_NewVTables == null)
                {
                    _NewVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                    _NewVTables[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + 8) = _Thunks[0];
                    *(void**)(vfptr0 + 16) = _Thunks[1];
                }

                native->vfptr0 = new IntPtr(_NewVTables[0]);
            }

            #endregion
        }

        /// <summary>
        /// <para>Describes how types, statements, expressions, and declarations
        /// should be printed.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief Describes how types, statements, expressions,
        /// and</para>
        /// <para>/// declarations should be printed.</para>
        /// </remarks>
        public unsafe partial class PrintingPolicy : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 272)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public clang.LangOptions.Internal LangOpts;

                [FieldOffset(264)]
                public uint Indentation;

                [FieldOffset(265)]
                public bool SuppressSpecifiers;

                [FieldOffset(265)]
                public bool SuppressTagKeyword;

                [FieldOffset(265)]
                public bool SuppressTag;

                [FieldOffset(265)]
                public bool SuppressScope;

                [FieldOffset(265)]
                public bool SuppressUnwrittenScope;

                [FieldOffset(265)]
                public bool SuppressInitializers;

                [FieldOffset(265)]
                public bool ConstantArraySizeAsWritten;

                [FieldOffset(265)]
                public bool AnonymousTagLocations;

                [FieldOffset(266)]
                public uint SuppressStrongLifetime;

                [FieldOffset(266)]
                public uint SuppressLifetimeQualifiers;

                [FieldOffset(266)]
                public uint Bool;

                [FieldOffset(266)]
                public uint TerseOutput;

                [FieldOffset(266)]
                public uint PolishForDeclaration;

                [FieldOffset(266)]
                public uint Half;

                [FieldOffset(266)]
                public uint MSWChar;

                [FieldOffset(266)]
                public uint IncludeNewlines;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14PrintingPolicyC2ERKNS_11LangOptionsE")]
                internal static extern void ctor_0(global::System.IntPtr instance, global::System.IntPtr LO);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14PrintingPolicyC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14PrintingPolicyD2Ev")]
                internal static extern void dtor_0(global::System.IntPtr instance);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, PrintingPolicy> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, PrintingPolicy>();

            private readonly bool __ownsNativeInstance;

            public static PrintingPolicy __CreateInstance(global::System.IntPtr native)
            {
                return new PrintingPolicy((PrintingPolicy.Internal*) native);
            }

            public static PrintingPolicy __CreateInstance(PrintingPolicy.Internal native)
            {
                return new PrintingPolicy(native);
            }

            private static PrintingPolicy.Internal* __CopyValue(PrintingPolicy.Internal native)
            {
                var ret = (PrintingPolicy.Internal*) Marshal.AllocHGlobal(272);
                *ret = native;
                return ret;
            }

            private PrintingPolicy(PrintingPolicy.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected PrintingPolicy(PrintingPolicy.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            /// <summary>
            /// <para>Create a default printing policy for C.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Create a default printing policy for C.</para>
            /// </remarks>
            public PrintingPolicy(clang.LangOptions LO)
            {
                __Instance = Marshal.AllocHGlobal(272);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(LO, null) ? global::System.IntPtr.Zero : LO.__Instance;
                Internal.ctor_0(__Instance, arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.PrintingPolicy __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance || force)
                    Internal.dtor_0(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.LangOptions LangOpts
            {
                get
                {
                    return clang.LangOptions.__CreateInstance(((Internal*) __Instance)->LangOpts);
                }

                set
                {
                    ((Internal*) __Instance)->LangOpts = ReferenceEquals(value, null) ? new clang.LangOptions.Internal() : *(clang.LangOptions.Internal*) (value.__Instance);
                }
            }

            public uint Indentation
            {
                get
                {
                    return ((Internal*) __Instance)->Indentation;
                }

                set
                {
                    ((Internal*) __Instance)->Indentation = value;
                }
            }

            public bool SuppressSpecifiers
            {
                get
                {
                    return ((Internal*) __Instance)->SuppressSpecifiers;
                }

                set
                {
                    ((Internal*) __Instance)->SuppressSpecifiers = value;
                }
            }

            public bool SuppressTagKeyword
            {
                get
                {
                    return ((Internal*) __Instance)->SuppressTagKeyword;
                }

                set
                {
                    ((Internal*) __Instance)->SuppressTagKeyword = value;
                }
            }

            public bool SuppressTag
            {
                get
                {
                    return ((Internal*) __Instance)->SuppressTag;
                }

                set
                {
                    ((Internal*) __Instance)->SuppressTag = value;
                }
            }

            public bool SuppressScope
            {
                get
                {
                    return ((Internal*) __Instance)->SuppressScope;
                }

                set
                {
                    ((Internal*) __Instance)->SuppressScope = value;
                }
            }

            public bool SuppressUnwrittenScope
            {
                get
                {
                    return ((Internal*) __Instance)->SuppressUnwrittenScope;
                }

                set
                {
                    ((Internal*) __Instance)->SuppressUnwrittenScope = value;
                }
            }

            public bool SuppressInitializers
            {
                get
                {
                    return ((Internal*) __Instance)->SuppressInitializers;
                }

                set
                {
                    ((Internal*) __Instance)->SuppressInitializers = value;
                }
            }

            public bool ConstantArraySizeAsWritten
            {
                get
                {
                    return ((Internal*) __Instance)->ConstantArraySizeAsWritten;
                }

                set
                {
                    ((Internal*) __Instance)->ConstantArraySizeAsWritten = value;
                }
            }

            public bool AnonymousTagLocations
            {
                get
                {
                    return ((Internal*) __Instance)->AnonymousTagLocations;
                }

                set
                {
                    ((Internal*) __Instance)->AnonymousTagLocations = value;
                }
            }

            public uint SuppressStrongLifetime
            {
                get
                {
                    return ((Internal*) __Instance)->SuppressStrongLifetime;
                }

                set
                {
                    ((Internal*) __Instance)->SuppressStrongLifetime = value;
                }
            }

            public uint SuppressLifetimeQualifiers
            {
                get
                {
                    return ((Internal*) __Instance)->SuppressLifetimeQualifiers;
                }

                set
                {
                    ((Internal*) __Instance)->SuppressLifetimeQualifiers = value;
                }
            }

            public uint Bool
            {
                get
                {
                    return ((Internal*) __Instance)->Bool;
                }

                set
                {
                    ((Internal*) __Instance)->Bool = value;
                }
            }

            public uint TerseOutput
            {
                get
                {
                    return ((Internal*) __Instance)->TerseOutput;
                }

                set
                {
                    ((Internal*) __Instance)->TerseOutput = value;
                }
            }

            public uint PolishForDeclaration
            {
                get
                {
                    return ((Internal*) __Instance)->PolishForDeclaration;
                }

                set
                {
                    ((Internal*) __Instance)->PolishForDeclaration = value;
                }
            }

            public uint Half
            {
                get
                {
                    return ((Internal*) __Instance)->Half;
                }

                set
                {
                    ((Internal*) __Instance)->Half = value;
                }
            }

            public uint MSWChar
            {
                get
                {
                    return ((Internal*) __Instance)->MSWChar;
                }

                set
                {
                    ((Internal*) __Instance)->MSWChar = value;
                }
            }

            public uint IncludeNewlines
            {
                get
                {
                    return ((Internal*) __Instance)->IncludeNewlines;
                }

                set
                {
                    ((Internal*) __Instance)->IncludeNewlines = value;
                }
            }
        }

        internal unsafe partial class PrinterHelperInternal : clang.PrinterHelper, IDisposable
        {
            private readonly bool __ownsNativeInstance;

            private static PrinterHelper.Internal* __CopyValue(PrinterHelper.Internal native)
            {
                var ret = (PrinterHelper.Internal*) Marshal.AllocHGlobal(8);
                *ret = native;
                return ret;
            }

            internal PrinterHelperInternal(PrinterHelper.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            internal PrinterHelperInternal(PrinterHelper.Internal* native, bool isInternalImpl = false)
                : base((clang.PrinterHelper.Internal*) native, true)
            {
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.PrinterHelper __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public override bool handledStmt(clang.Stmt E, llvm.raw_ostream OS)
            {
                void* slot = *(void**) (((PrinterHelper.Internal*) __Instance)->vfptr0 + 2 * 8);
                var ___handledStmt_0Delegate = (_handledStmt_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_handledStmt_0Delegate));
                var arg0 = ReferenceEquals(E, null) ? global::System.IntPtr.Zero : E.__Instance;
                var arg1 = ReferenceEquals(OS, null) ? global::System.IntPtr.Zero : OS.__Instance;
                var __ret = ___handledStmt_0Delegate(__Instance, arg0, arg1);
                return __ret;
            }
        }
    }
}
