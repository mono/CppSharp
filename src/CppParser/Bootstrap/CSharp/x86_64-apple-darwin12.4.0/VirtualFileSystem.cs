//----------------------------------------------------------------------------
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
//----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace CppSharp
{
    public unsafe partial class VirtualFileSystem
    {
        public partial struct Internal
        {
        }
    }

    namespace clang
    {
        public unsafe partial class VirtualFileSystem
        {
            public partial struct Internal
            {
            }
        }

        namespace vfs
        {
            /// <summary>
            /// <para>The result of a status operation.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief The result of a \p status operation.</para>
            /// </remarks>
            public unsafe partial class Status : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 88)]
                public partial struct Internal
                {
                    [FieldOffset(24)]
                    public llvm.sys.fs.UniqueID.Internal UID;

                    [FieldOffset(40)]
                    public llvm.sys.TimeValue.Internal MTime;

                    [FieldOffset(56)]
                    public uint User;

                    [FieldOffset(60)]
                    public uint Group;

                    [FieldOffset(64)]
                    public ulong Size;

                    [FieldOffset(72)]
                    public llvm.sys.fs.file_type Type;

                    [FieldOffset(76)]
                    public llvm.sys.fs.perms Perms;

                    [FieldOffset(80)]
                    public bool IsVFSMapped;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang3vfs6StatusC2Ev")]
                    internal static extern void ctor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang3vfs6StatusC2ERKN4llvm3sys2fs11file_statusE")]
                    internal static extern void ctor_1(global::System.IntPtr instance, global::System.IntPtr Status);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang3vfs6StatusC2EN4llvm9StringRefES3_NS2_3sys2fs8UniqueIDENS4_9TimeValueEjjyNS5_9file_typeENS5_5permsE")]
                    internal static extern void ctor_2(global::System.IntPtr instance, llvm.StringRef.Internal Name, llvm.StringRef.Internal RealName, llvm.sys.fs.UniqueID.Internal UID, llvm.sys.TimeValue.Internal MTime, uint User, uint Group, ulong Size, llvm.sys.fs.file_type Type, llvm.sys.fs.perms Perms);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang3vfs6StatusC2ERKS1_")]
                    internal static extern void cctor_4(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang3vfs6StatusD2Ev")]
                    internal static extern void dtor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang3vfs6Status7getNameEv")]
                    internal static extern llvm.StringRef.Internal getName_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang3vfs6Status7setNameEN4llvm9StringRefE")]
                    internal static extern void setName_0(global::System.IntPtr instance, llvm.StringRef.Internal N);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang3vfs6Status7getTypeEv")]
                    internal static extern llvm.sys.fs.file_type getType_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang3vfs6Status14getPermissionsEv")]
                    internal static extern llvm.sys.fs.perms getPermissions_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang3vfs6Status23getLastModificationTimeEv")]
                    internal static extern llvm.sys.TimeValue.Internal getLastModificationTime_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang3vfs6Status11getUniqueIDEv")]
                    internal static extern llvm.sys.fs.UniqueID.Internal getUniqueID_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang3vfs6Status7getUserEv")]
                    internal static extern uint getUser_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang3vfs6Status8getGroupEv")]
                    internal static extern uint getGroup_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang3vfs6Status7getSizeEv")]
                    internal static extern ulong getSize_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang3vfs6Status7setTypeEN4llvm3sys2fs9file_typeE")]
                    internal static extern void setType_0(global::System.IntPtr instance, llvm.sys.fs.file_type v);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang3vfs6Status14setPermissionsEN4llvm3sys2fs5permsE")]
                    internal static extern void setPermissions_0(global::System.IntPtr instance, llvm.sys.fs.perms p);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang3vfs6Status10equivalentERKS1_")]
                    [return: MarshalAsAttribute(UnmanagedType.I1)]
                    internal static extern bool equivalent_0(global::System.IntPtr instance, global::System.IntPtr Other);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang3vfs6Status11isDirectoryEv")]
                    [return: MarshalAsAttribute(UnmanagedType.I1)]
                    internal static extern bool isDirectory_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang3vfs6Status13isRegularFileEv")]
                    [return: MarshalAsAttribute(UnmanagedType.I1)]
                    internal static extern bool isRegularFile_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang3vfs6Status7isOtherEv")]
                    [return: MarshalAsAttribute(UnmanagedType.I1)]
                    internal static extern bool isOther_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang3vfs6Status9isSymlinkEv")]
                    [return: MarshalAsAttribute(UnmanagedType.I1)]
                    internal static extern bool isSymlink_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang3vfs6Status13isStatusKnownEv")]
                    [return: MarshalAsAttribute(UnmanagedType.I1)]
                    internal static extern bool isStatusKnown_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang3vfs6Status6existsEv")]
                    [return: MarshalAsAttribute(UnmanagedType.I1)]
                    internal static extern bool exists_0(global::System.IntPtr instance);
                }

                public global::System.IntPtr __Instance { get; protected set; }
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, Status> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, Status>();

                private readonly bool __ownsNativeInstance;

                public static Status __CreateInstance(global::System.IntPtr native)
                {
                    return new Status((Status.Internal*) native);
                }

                public static Status __CreateInstance(Status.Internal native)
                {
                    return new Status(native);
                }

                private static Status.Internal* __CopyValue(Status.Internal native)
                {
                    var ret = (Status.Internal*) Marshal.AllocHGlobal(88);
                    *ret = native;
                    return ret;
                }

                private Status(Status.Internal native)
                    : this(__CopyValue(native))
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected Status(Status.Internal* native, bool isInternalImpl = false)
                {
                    __Instance = new global::System.IntPtr(native);
                }

                public Status()
                {
                    __Instance = Marshal.AllocHGlobal(88);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_0(__Instance);
                }

                public Status(llvm.sys.fs.file_status Status)
                {
                    __Instance = Marshal.AllocHGlobal(88);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    var arg0 = ReferenceEquals(Status, null) ? global::System.IntPtr.Zero : Status.__Instance;
                    Internal.ctor_1(__Instance, arg0);
                }

                public Status(llvm.StringRef Name, llvm.StringRef RealName, llvm.sys.fs.UniqueID UID, llvm.sys.TimeValue MTime, uint User, uint Group, ulong Size, llvm.sys.fs.file_type Type, llvm.sys.fs.perms Perms)
                {
                    __Instance = Marshal.AllocHGlobal(88);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    var arg0 = ReferenceEquals(Name, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (Name.__Instance);
                    var arg1 = ReferenceEquals(RealName, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (RealName.__Instance);
                    var arg2 = ReferenceEquals(UID, null) ? new llvm.sys.fs.UniqueID.Internal() : *(llvm.sys.fs.UniqueID.Internal*) (UID.__Instance);
                    var arg3 = ReferenceEquals(MTime, null) ? new llvm.sys.TimeValue.Internal() : *(llvm.sys.TimeValue.Internal*) (MTime.__Instance);
                    var arg4 = User;
                    var arg5 = Group;
                    var arg6 = Size;
                    var arg7 = Type;
                    var arg8 = Perms;
                    Internal.ctor_2(__Instance, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    DestroyNativeInstance(false);
                }

                public virtual void DestroyNativeInstance()
                {
                    DestroyNativeInstance(true);
                }

                private void DestroyNativeInstance(bool force)
                {
                    clang.vfs.Status __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance || force)
                        Internal.dtor_0(__Instance);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                /// <summary>
                /// <para>Returns the name that should be used for this file or
                /// directory.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Returns the name that should be used for this file or
                /// directory.</para>
                /// </remarks>
                public llvm.StringRef getName()
                {
                    var __ret = Internal.getName_0(__Instance);
                    return llvm.StringRef.__CreateInstance(__ret);
                }

                public void setName(llvm.StringRef N)
                {
                    var arg0 = ReferenceEquals(N, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (N.__Instance);
                    Internal.setName_0(__Instance, arg0);
                }

                /// <summary>
                /// <para>@{</para>
                /// </summary>
                /// <remarks>
                /// <para>/// @name Status interface from llvm::sys::fs</para>
                /// <para>  /// @{</para>
                /// </remarks>
                public llvm.sys.fs.file_type getType()
                {
                    var __ret = Internal.getType_0(__Instance);
                    return __ret;
                }

                public llvm.sys.fs.perms getPermissions()
                {
                    var __ret = Internal.getPermissions_0(__Instance);
                    return __ret;
                }

                public llvm.sys.TimeValue getLastModificationTime()
                {
                    var __ret = Internal.getLastModificationTime_0(__Instance);
                    return llvm.sys.TimeValue.__CreateInstance(__ret);
                }

                public llvm.sys.fs.UniqueID getUniqueID()
                {
                    var __ret = Internal.getUniqueID_0(__Instance);
                    return llvm.sys.fs.UniqueID.__CreateInstance(__ret);
                }

                public uint getUser()
                {
                    var __ret = Internal.getUser_0(__Instance);
                    return __ret;
                }

                public uint getGroup()
                {
                    var __ret = Internal.getGroup_0(__Instance);
                    return __ret;
                }

                public ulong getSize()
                {
                    var __ret = Internal.getSize_0(__Instance);
                    return __ret;
                }

                public void setType(llvm.sys.fs.file_type v)
                {
                    var arg0 = v;
                    Internal.setType_0(__Instance, arg0);
                }

                public void setPermissions(llvm.sys.fs.perms p)
                {
                    var arg0 = p;
                    Internal.setPermissions_0(__Instance, arg0);
                }

                /// <summary>
                /// <para>@} These are static queries in llvm::sys::fs. @{</para>
                /// </summary>
                /// <remarks>
                /// <para>/// @}</para>
                /// <para>  /// @name Status queries</para>
                /// <para>  /// These are static queries in llvm::sys::fs.</para>
                /// <para>  /// @{</para>
                /// </remarks>
                public bool equivalent(clang.vfs.Status Other)
                {
                    var arg0 = ReferenceEquals(Other, null) ? global::System.IntPtr.Zero : Other.__Instance;
                    var __ret = Internal.equivalent_0(__Instance, arg0);
                    return __ret;
                }

                public bool isDirectory()
                {
                    var __ret = Internal.isDirectory_0(__Instance);
                    return __ret;
                }

                public bool isRegularFile()
                {
                    var __ret = Internal.isRegularFile_0(__Instance);
                    return __ret;
                }

                public bool isOther()
                {
                    var __ret = Internal.isOther_0(__Instance);
                    return __ret;
                }

                public bool isSymlink()
                {
                    var __ret = Internal.isSymlink_0(__Instance);
                    return __ret;
                }

                public bool isStatusKnown()
                {
                    var __ret = Internal.isStatusKnown_0(__Instance);
                    return __ret;
                }

                public bool exists()
                {
                    var __ret = Internal.exists_0(__Instance);
                    return __ret;
                }

                public bool IsVFSMapped
                {
                    get
                    {
                        return ((Internal*) __Instance)->IsVFSMapped;
                    }

                    set
                    {
                        ((Internal*) __Instance)->IsVFSMapped = value;
                    }
                }
            }

            /// <summary>
            /// <para>Represents an open file.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Represents an open file.</para>
            /// </remarks>
            public unsafe abstract partial class File : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 8)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public global::System.IntPtr vfptr0;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang3vfs4FileC2Ev")]
                    internal static extern void ctor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang3vfs4FileC2ERKS1_")]
                    internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang3vfs4FileD2Ev")]
                    internal static extern void dtor_0(global::System.IntPtr instance);
                }

                public global::System.IntPtr __Instance { get; protected set; }
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, File> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, File>();

                private readonly bool __ownsNativeInstance;

                public static File __CreateInstance(global::System.IntPtr native)
                {
                    return new FileInternal((File.Internal*) native);
                }

                public static File __CreateInstance(File.Internal native)
                {
                    return new FileInternal(native);
                }

                protected File(File.Internal* native, bool isInternalImpl = false)
                {
                    __Instance = new global::System.IntPtr(native);
                    if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                        SetupVTables(__Instance);
                }

                protected File()
                {
                    __Instance = Marshal.AllocHGlobal(8);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_0(__Instance);
                    SetupVTables(__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    DestroyNativeInstance(false);
                }

                public virtual void DestroyNativeInstance()
                {
                    DestroyNativeInstance(true);
                }

                private void DestroyNativeInstance(bool force)
                {
                    clang.vfs.File __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance || force)
                        Internal.dtor_0(__Instance);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                /// <summary>
                /// <para>Closes the file.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Closes the file.</para>
                /// </remarks>
                public abstract std.__1.error_code close();

                /// <summary>
                /// <para>Sets the name to use for this file.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Sets the name to use for this file.</para>
                /// </remarks>
                public abstract void setName(llvm.StringRef Name);

                #region Virtual table interop

                // virtual ~File()
                [SuppressUnmanagedCodeSecurity]
                [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
                internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
                private static _dtor_0Delegate _dtor_0DelegateInstance;

                private static void _dtor_0DelegateHook(global::System.IntPtr instance)
                {
                    if (!_References.ContainsKey(instance))
                        throw new global::System.Exception("No managed instance was found");

                    var __target = (File) _References[instance].Target;
                    __target.DestroyNativeInstance();
                }

                // std::error_code close() = 0
                [SuppressUnmanagedCodeSecurity]
                [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
                internal delegate std.__1.error_code.Internal _close_0Delegate(global::System.IntPtr instance);
                private static _close_0Delegate _close_0DelegateInstance;

                private static std.__1.error_code.Internal _close_0DelegateHook(global::System.IntPtr instance)
                {
                    if (!_References.ContainsKey(instance))
                        throw new global::System.Exception("No managed instance was found");

                    var __target = (File) _References[instance].Target;
                    var __ret = __target.close();
                    return ReferenceEquals(__ret, null) ? new std.__1.error_code.Internal() : *(std.__1.error_code.Internal*) (__ret.__Instance);
                }

                // void setName(StringRef Name) = 0
                [SuppressUnmanagedCodeSecurity]
                [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
                internal delegate void _setName_0Delegate(global::System.IntPtr instance, llvm.StringRef.Internal Name);
                private static _setName_0Delegate _setName_0DelegateInstance;

                private static void _setName_0DelegateHook(global::System.IntPtr instance, llvm.StringRef.Internal Name)
                {
                    if (!_References.ContainsKey(instance))
                        throw new global::System.Exception("No managed instance was found");

                    var __target = (File) _References[instance].Target;
                    __target.setName(llvm.StringRef.__CreateInstance(Name));
                }

                private static void*[] _OldVTables;
                private static void*[] _NewVTables;
                private static void*[] _Thunks;
                private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

                void SetupVTables(global::System.IntPtr instance)
                {
                    var native = (Internal*)instance.ToPointer();

                    if (_References == null)
                        _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

                    if (_References.ContainsKey(instance))
                        return;

                    _References[instance] = new WeakReference(this);

                    if (_OldVTables == null)
                    {
                        _OldVTables = new void*[1];
                        _OldVTables[0] = native->vfptr0.ToPointer();
                    }

                    if (_Thunks == null)
                    {
                        _Thunks = new void*[3];
                        _dtor_0DelegateInstance += _dtor_0DelegateHook;
                        _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                        _close_0DelegateInstance += _close_0DelegateHook;
                        _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_close_0DelegateInstance).ToPointer();
                        _setName_0DelegateInstance += _setName_0DelegateHook;
                        _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_setName_0DelegateInstance).ToPointer();
                    }

                    if (_NewVTables == null)
                    {
                        _NewVTables = new void*[1];
                        var vfptr0 = Marshal.AllocHGlobal(5 * 8);
                        _NewVTables[0] = vfptr0.ToPointer();
                        *(void**)(vfptr0 + 8) = _Thunks[0];
                        *(void**)(vfptr0 + 16) = *(void**)(native->vfptr0 + 16);
                        *(void**)(vfptr0 + 24) = *(void**)(native->vfptr0 + 24);
                        *(void**)(vfptr0 + 32) = _Thunks[1];
                        *(void**)(vfptr0 + 40) = _Thunks[2];
                    }

                    native->vfptr0 = new IntPtr(_NewVTables[0]);
                }

                #endregion
            }

            /// <summary>
            /// <para>An input iterator over the entries in a virtual path, similar to
            /// llvm::sys::fs::directory_iterator.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief An input iterator over the entries in a virtual path,
            /// similar to</para>
            /// <para>/// llvm::sys::fs::directory_iterator.</para>
            /// </remarks>
            public unsafe partial class directory_iterator : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 16)]
                public partial struct Internal
                {
                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang3vfs18directory_iteratorC2Ev")]
                    internal static extern void ctor_1(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang3vfs18directory_iteratorC2ERKS1_")]
                    internal static extern void cctor_3(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang3vfs18directory_iteratorD2Ev")]
                    internal static extern void dtor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang3vfs18directory_iterator9incrementERNSt3__110error_codeE")]
                    internal static extern global::System.IntPtr increment_0(global::System.IntPtr instance, global::System.IntPtr EC);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang3vfs18directory_iteratoreqERKS1_")]
                    [return: MarshalAsAttribute(UnmanagedType.I1)]
                    internal static extern bool OperatorEqualEqual_0(global::System.IntPtr instance, global::System.IntPtr RHS);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang3vfs18directory_iteratorneERKS1_")]
                    [return: MarshalAsAttribute(UnmanagedType.I1)]
                    internal static extern bool OperatorExclaimEqual_0(global::System.IntPtr instance, global::System.IntPtr RHS);
                }

                public global::System.IntPtr __Instance { get; protected set; }
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, directory_iterator> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, directory_iterator>();

                private readonly bool __ownsNativeInstance;

                public static directory_iterator __CreateInstance(global::System.IntPtr native)
                {
                    return new directory_iterator((directory_iterator.Internal*) native);
                }

                public static directory_iterator __CreateInstance(directory_iterator.Internal native)
                {
                    return new directory_iterator(native);
                }

                private static directory_iterator.Internal* __CopyValue(directory_iterator.Internal native)
                {
                    var ret = (directory_iterator.Internal*) Marshal.AllocHGlobal(16);
                    *ret = native;
                    return ret;
                }

                private directory_iterator(directory_iterator.Internal native)
                    : this(__CopyValue(native))
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected directory_iterator(directory_iterator.Internal* native, bool isInternalImpl = false)
                {
                    __Instance = new global::System.IntPtr(native);
                }

                /// <summary>
                /// <para>Construct an 'end' iterator.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Construct an 'end' iterator.</para>
                /// </remarks>
                public directory_iterator()
                {
                    __Instance = Marshal.AllocHGlobal(16);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_1(__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    DestroyNativeInstance(false);
                }

                public virtual void DestroyNativeInstance()
                {
                    DestroyNativeInstance(true);
                }

                private void DestroyNativeInstance(bool force)
                {
                    clang.vfs.directory_iterator __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance || force)
                        Internal.dtor_0(__Instance);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                /// <summary>
                /// <para>Equivalent to operator++, with an error code.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Equivalent to operator++, with an error code.</para>
                /// </remarks>
                public clang.vfs.directory_iterator increment(std.__1.error_code EC)
                {
                    var arg0 = ReferenceEquals(EC, null) ? global::System.IntPtr.Zero : EC.__Instance;
                    var __ret = Internal.increment_0(__Instance, arg0);
                    clang.vfs.directory_iterator __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (clang.vfs.directory_iterator.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (clang.vfs.directory_iterator) clang.vfs.directory_iterator.NativeToManagedMap[__ret];
                    else __result0 = clang.vfs.directory_iterator.__CreateInstance(__ret);
                    return __result0;
                }

                public static bool operator ==(clang.vfs.directory_iterator __op, clang.vfs.directory_iterator RHS)
                {
                    bool __opNull = ReferenceEquals(__op, null);
                    bool RHSNull = ReferenceEquals(RHS, null);
                    if (__opNull || RHSNull)
                        return __opNull && RHSNull;
                    var arg0 = __op.__Instance;
                    var arg1 = RHS.__Instance;
                    var __ret = Internal.OperatorEqualEqual_0(arg0, arg1);
                    return __ret;
                }

                public override bool Equals(object obj)
                {
                    return this == obj as directory_iterator;
                }

                public static bool operator !=(clang.vfs.directory_iterator __op, clang.vfs.directory_iterator RHS)
                {
                    var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
                    var arg1 = ReferenceEquals(RHS, null) ? global::System.IntPtr.Zero : RHS.__Instance;
                    var __ret = Internal.OperatorExclaimEqual_0(arg0, arg1);
                    return __ret;
                }
            }

            /// <summary>
            /// <para>An input iterator over the recursive contents of a virtual path,
            /// similar to llvm::sys::fs::recursive_directory_iterator.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief An input iterator over the recursive contents of a
            /// virtual path,</para>
            /// <para>/// similar to
            /// llvm::sys::fs::recursive_directory_iterator.</para>
            /// </remarks>
            public unsafe partial class recursive_directory_iterator : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 24)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public global::System.IntPtr FS;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang3vfs28recursive_directory_iteratorC2ERNS0_10FileSystemERKN4llvm5TwineERNSt3__110error_codeE")]
                    internal static extern void ctor_0(global::System.IntPtr instance, global::System.IntPtr FS, global::System.IntPtr Path, global::System.IntPtr EC);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang3vfs28recursive_directory_iteratorC2Ev")]
                    internal static extern void ctor_1(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang3vfs28recursive_directory_iteratorC2ERKS1_")]
                    internal static extern void cctor_3(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang3vfs28recursive_directory_iteratorD2Ev")]
                    internal static extern void dtor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang3vfs28recursive_directory_iterator9incrementERNSt3__110error_codeE")]
                    internal static extern global::System.IntPtr increment_0(global::System.IntPtr instance, global::System.IntPtr EC);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang3vfs28recursive_directory_iteratoreqERKS1_")]
                    [return: MarshalAsAttribute(UnmanagedType.I1)]
                    internal static extern bool OperatorEqualEqual_0(global::System.IntPtr instance, global::System.IntPtr Other);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang3vfs28recursive_directory_iteratorneERKS1_")]
                    [return: MarshalAsAttribute(UnmanagedType.I1)]
                    internal static extern bool OperatorExclaimEqual_0(global::System.IntPtr instance, global::System.IntPtr RHS);
                }

                public global::System.IntPtr __Instance { get; protected set; }
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, recursive_directory_iterator> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, recursive_directory_iterator>();

                private readonly bool __ownsNativeInstance;

                public static recursive_directory_iterator __CreateInstance(global::System.IntPtr native)
                {
                    return new recursive_directory_iterator((recursive_directory_iterator.Internal*) native);
                }

                public static recursive_directory_iterator __CreateInstance(recursive_directory_iterator.Internal native)
                {
                    return new recursive_directory_iterator(native);
                }

                private static recursive_directory_iterator.Internal* __CopyValue(recursive_directory_iterator.Internal native)
                {
                    var ret = (recursive_directory_iterator.Internal*) Marshal.AllocHGlobal(24);
                    *ret = native;
                    return ret;
                }

                private recursive_directory_iterator(recursive_directory_iterator.Internal native)
                    : this(__CopyValue(native))
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected recursive_directory_iterator(recursive_directory_iterator.Internal* native, bool isInternalImpl = false)
                {
                    __Instance = new global::System.IntPtr(native);
                }

                public recursive_directory_iterator(clang.vfs.FileSystem FS, llvm.Twine Path, std.__1.error_code EC)
                {
                    __Instance = Marshal.AllocHGlobal(24);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    var arg0 = ReferenceEquals(FS, null) ? global::System.IntPtr.Zero : FS.__Instance;
                    var arg1 = ReferenceEquals(Path, null) ? global::System.IntPtr.Zero : Path.__Instance;
                    var arg2 = ReferenceEquals(EC, null) ? global::System.IntPtr.Zero : EC.__Instance;
                    Internal.ctor_0(__Instance, arg0, arg1, arg2);
                }

                /// <summary>
                /// <para>Construct an 'end' iterator.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Construct an 'end' iterator.</para>
                /// </remarks>
                public recursive_directory_iterator()
                {
                    __Instance = Marshal.AllocHGlobal(24);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_1(__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    DestroyNativeInstance(false);
                }

                public virtual void DestroyNativeInstance()
                {
                    DestroyNativeInstance(true);
                }

                private void DestroyNativeInstance(bool force)
                {
                    clang.vfs.recursive_directory_iterator __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance || force)
                        Internal.dtor_0(__Instance);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                /// <summary>
                /// <para>Equivalent to operator++, with an error code.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Equivalent to operator++, with an error code.</para>
                /// </remarks>
                public clang.vfs.recursive_directory_iterator increment(std.__1.error_code EC)
                {
                    var arg0 = ReferenceEquals(EC, null) ? global::System.IntPtr.Zero : EC.__Instance;
                    var __ret = Internal.increment_0(__Instance, arg0);
                    clang.vfs.recursive_directory_iterator __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (clang.vfs.recursive_directory_iterator.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (clang.vfs.recursive_directory_iterator) clang.vfs.recursive_directory_iterator.NativeToManagedMap[__ret];
                    else __result0 = clang.vfs.recursive_directory_iterator.__CreateInstance(__ret);
                    return __result0;
                }

                public static bool operator ==(clang.vfs.recursive_directory_iterator __op, clang.vfs.recursive_directory_iterator Other)
                {
                    bool __opNull = ReferenceEquals(__op, null);
                    bool OtherNull = ReferenceEquals(Other, null);
                    if (__opNull || OtherNull)
                        return __opNull && OtherNull;
                    var arg0 = __op.__Instance;
                    var arg1 = Other.__Instance;
                    var __ret = Internal.OperatorEqualEqual_0(arg0, arg1);
                    return __ret;
                }

                public override bool Equals(object obj)
                {
                    return this == obj as recursive_directory_iterator;
                }

                public static bool operator !=(clang.vfs.recursive_directory_iterator __op, clang.vfs.recursive_directory_iterator RHS)
                {
                    var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
                    var arg1 = ReferenceEquals(RHS, null) ? global::System.IntPtr.Zero : RHS.__Instance;
                    var __ret = Internal.OperatorExclaimEqual_0(arg0, arg1);
                    return __ret;
                }
            }

            /// <summary>
            /// <para>The virtual file system interface.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief The virtual file system interface.</para>
            /// </remarks>
            public unsafe abstract partial class FileSystem : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 16)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public global::System.IntPtr vfptr0;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang3vfs10FileSystemC2ERKS1_")]
                    internal static extern void cctor_0(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang3vfs10FileSystemC2Ev")]
                    internal static extern void ctor_1(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang3vfs10FileSystemD2Ev")]
                    internal static extern void dtor_0(global::System.IntPtr instance);
                }

                public global::System.IntPtr __Instance { get; protected set; }
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, FileSystem> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, FileSystem>();

                private readonly bool __ownsNativeInstance;

                public static FileSystem __CreateInstance(global::System.IntPtr native)
                {
                    return new FileSystemInternal((FileSystem.Internal*) native);
                }

                public static FileSystem __CreateInstance(FileSystem.Internal native)
                {
                    return new FileSystemInternal(native);
                }

                protected FileSystem(FileSystem.Internal* native, bool isInternalImpl = false)
                {
                    __Instance = new global::System.IntPtr(native);
                    if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                        SetupVTables(__Instance);
                }

                protected FileSystem()
                {
                    __Instance = Marshal.AllocHGlobal(16);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_1(__Instance);
                    SetupVTables(__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    DestroyNativeInstance(false);
                }

                public virtual void DestroyNativeInstance()
                {
                    DestroyNativeInstance(true);
                }

                private void DestroyNativeInstance(bool force)
                {
                    clang.vfs.FileSystem __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance || force)
                        Internal.dtor_0(__Instance);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                /// <summary>
                /// <para>Get a directory_iterator for Dir.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Get a directory_iterator for \p Dir.</para>
                /// <para>  /// \note The 'end' iterator is directory_iterator().</para>
                /// </remarks>
                public abstract clang.vfs.directory_iterator dir_begin(llvm.Twine Dir, std.__1.error_code EC);

                #region Virtual table interop

                // virtual ~FileSystem()
                [SuppressUnmanagedCodeSecurity]
                [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
                internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
                private static _dtor_0Delegate _dtor_0DelegateInstance;

                private static void _dtor_0DelegateHook(global::System.IntPtr instance)
                {
                    if (!_References.ContainsKey(instance))
                        throw new global::System.Exception("No managed instance was found");

                    var __target = (FileSystem) _References[instance].Target;
                    __target.DestroyNativeInstance();
                }

                // directory_iterator dir_begin(const Twine &Dir, std::error_code &EC) = 0
                [SuppressUnmanagedCodeSecurity]
                [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
                internal delegate clang.vfs.directory_iterator.Internal _dir_begin_0Delegate(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr Dir, global::System.IntPtr EC);
                private static _dir_begin_0Delegate _dir_begin_0DelegateInstance;

                private static clang.vfs.directory_iterator.Internal _dir_begin_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr Dir, global::System.IntPtr EC)
                {
                    if (!_References.ContainsKey(instance))
                        throw new global::System.Exception("No managed instance was found");

                    var __target = (FileSystem) _References[instance].Target;
                    llvm.Twine __result1;
                    if (Dir == IntPtr.Zero) __result1 = null;
                    else if (llvm.Twine.NativeToManagedMap.ContainsKey(Dir))
                        __result1 = (llvm.Twine) llvm.Twine.NativeToManagedMap[Dir];
                    else __result1 = llvm.Twine.__CreateInstance(Dir);
                    std.__1.error_code __result2;
                    if (EC == IntPtr.Zero) __result2 = null;
                    else if (std.__1.error_code.NativeToManagedMap.ContainsKey(EC))
                        __result2 = (std.__1.error_code) std.__1.error_code.NativeToManagedMap[EC];
                    else __result2 = std.__1.error_code.__CreateInstance(EC);
                    var __ret = __target.dir_begin(__result1, __result2);
                    return ReferenceEquals(__ret, null) ? new clang.vfs.directory_iterator.Internal() : *(clang.vfs.directory_iterator.Internal*) (__ret.__Instance);
                }

                private static void*[] _OldVTables;
                private static void*[] _NewVTables;
                private static void*[] _Thunks;
                private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

                void SetupVTables(global::System.IntPtr instance)
                {
                    var native = (Internal*)instance.ToPointer();

                    if (_References == null)
                        _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

                    if (_References.ContainsKey(instance))
                        return;

                    _References[instance] = new WeakReference(this);

                    if (_OldVTables == null)
                    {
                        _OldVTables = new void*[1];
                        _OldVTables[0] = native->vfptr0.ToPointer();
                    }

                    if (_Thunks == null)
                    {
                        _Thunks = new void*[2];
                        _dtor_0DelegateInstance += _dtor_0DelegateHook;
                        _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                        _dir_begin_0DelegateInstance += _dir_begin_0DelegateHook;
                        _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_dir_begin_0DelegateInstance).ToPointer();
                    }

                    if (_NewVTables == null)
                    {
                        _NewVTables = new void*[1];
                        var vfptr0 = Marshal.AllocHGlobal(4 * 8);
                        _NewVTables[0] = vfptr0.ToPointer();
                        *(void**)(vfptr0 + 8) = _Thunks[0];
                        *(void**)(vfptr0 + 16) = *(void**)(native->vfptr0 + 16);
                        *(void**)(vfptr0 + 24) = *(void**)(native->vfptr0 + 24);
                        *(void**)(vfptr0 + 32) = _Thunks[1];
                    }

                    native->vfptr0 = new IntPtr(_NewVTables[0]);
                }

                #endregion
            }

            /// <summary>
            /// <para>A file system that allows overlaying one AbstractFileSystem on
            /// top of another.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief A file system that allows overlaying one \p
            /// AbstractFileSystem on top</para>
            /// <para>/// of another.</para>
            /// <para>///</para>
            /// <para>/// Consists of a stack of &gt;=1 \p FileSystem objects, which
            /// are treated as being</para>
            /// <para>/// one merged file system. When there is a directory that exists
            /// in more than</para>
            /// <para>/// one file system, the \p OverlayFileSystem contains a
            /// directory containing</para>
            /// <para>/// the union of their contents.  The attributes (permissions,
            /// etc.) of the</para>
            /// <para>/// top-most (most recently added) directory are used.  When
            /// there is a file</para>
            /// <para>/// that exists in more than one file system, the file in the
            /// top-most file</para>
            /// <para>/// system overrides the other(s).</para>
            /// </remarks>
            public unsafe partial class OverlayFileSystem : clang.vfs.FileSystem, IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 56)]
                public new partial struct Internal
                {
                    [FieldOffset(16)]
                    internal llvm.SmallVector.Internal FSList;

                    [FieldOffset(0)]
                    public global::System.IntPtr vfptr0;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang3vfs17OverlayFileSystemC2ERKS1_")]
                    internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang3vfs17OverlayFileSystemD2Ev")]
                    internal static extern void dtor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang3vfs17OverlayFileSystem9dir_beginERKN4llvm5TwineERNSt3__110error_codeE")]
                    internal static extern void dir_begin_0(global::System.IntPtr @return, global::System.IntPtr instance, global::System.IntPtr Dir, global::System.IntPtr EC);
                }

                private readonly bool __ownsNativeInstance;

                public static OverlayFileSystem __CreateInstance(global::System.IntPtr native)
                {
                    return new OverlayFileSystem((OverlayFileSystem.Internal*) native);
                }

                public static OverlayFileSystem __CreateInstance(OverlayFileSystem.Internal native)
                {
                    return new OverlayFileSystem(native);
                }

                private static OverlayFileSystem.Internal* __CopyValue(OverlayFileSystem.Internal native)
                {
                    var ret = (OverlayFileSystem.Internal*) Marshal.AllocHGlobal(56);
                    *ret = native;
                    return ret;
                }

                private OverlayFileSystem(OverlayFileSystem.Internal native)
                    : this(__CopyValue(native))
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected OverlayFileSystem(OverlayFileSystem.Internal* native, bool isInternalImpl = false)
                    : base((clang.vfs.FileSystem.Internal*) native)
                {
                }

                protected override void Dispose(bool disposing)
                {
                    DestroyNativeInstance(false);
                    base.Dispose(disposing);
                }

                public override void DestroyNativeInstance()
                {
                    DestroyNativeInstance(true);
                }

                private void DestroyNativeInstance(bool force)
                {
                    clang.vfs.FileSystem __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public virtual clang.vfs.directory_iterator dir_begin(llvm.Twine Dir, std.__1.error_code EC)
                {
                    var arg0 = ReferenceEquals(Dir, null) ? global::System.IntPtr.Zero : Dir.__Instance;
                    var arg1 = ReferenceEquals(EC, null) ? global::System.IntPtr.Zero : EC.__Instance;
                    var __ret = new clang.vfs.directory_iterator.Internal();
                    Internal.dir_begin_0(new IntPtr(&__ret), __Instance, arg0, arg1);
                    return clang.vfs.directory_iterator.__CreateInstance(__ret);
                }

                #region Virtual table interop

                // OverlayFileSystem
                [SuppressUnmanagedCodeSecurity]
                [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
                internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
                private static _dtor_0Delegate _dtor_0DelegateInstance;

                private static void _dtor_0DelegateHook(global::System.IntPtr instance)
                {
                    if (!_References.ContainsKey(instance))
                        throw new global::System.Exception("No managed instance was found");

                    var __target = (OverlayFileSystem) _References[instance].Target;
                    __target.DestroyNativeInstance();
                }

                // directory_iterator dir_begin(const Twine &Dir, std::error_code &EC) override
                [SuppressUnmanagedCodeSecurity]
                [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
                internal delegate clang.vfs.directory_iterator.Internal _dir_begin_0Delegate(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr Dir, global::System.IntPtr EC);
                private static _dir_begin_0Delegate _dir_begin_0DelegateInstance;

                private static clang.vfs.directory_iterator.Internal _dir_begin_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr @return, global::System.IntPtr Dir, global::System.IntPtr EC)
                {
                    if (!_References.ContainsKey(instance))
                        throw new global::System.Exception("No managed instance was found");

                    var __target = (OverlayFileSystem) _References[instance].Target;
                    llvm.Twine __result1;
                    if (Dir == IntPtr.Zero) __result1 = null;
                    else if (llvm.Twine.NativeToManagedMap.ContainsKey(Dir))
                        __result1 = (llvm.Twine) llvm.Twine.NativeToManagedMap[Dir];
                    else __result1 = llvm.Twine.__CreateInstance(Dir);
                    std.__1.error_code __result2;
                    if (EC == IntPtr.Zero) __result2 = null;
                    else if (std.__1.error_code.NativeToManagedMap.ContainsKey(EC))
                        __result2 = (std.__1.error_code) std.__1.error_code.NativeToManagedMap[EC];
                    else __result2 = std.__1.error_code.__CreateInstance(EC);
                    var __ret = __target.dir_begin(__result1, __result2);
                    return ReferenceEquals(__ret, null) ? new clang.vfs.directory_iterator.Internal() : *(clang.vfs.directory_iterator.Internal*) (__ret.__Instance);
                }

                private static void*[] _OldVTables;
                private static void*[] _NewVTables;
                private static void*[] _Thunks;
                private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

                void SetupVTables(global::System.IntPtr instance)
                {
                    var native = (Internal*)instance.ToPointer();

                    if (_References == null)
                        _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

                    if (_References.ContainsKey(instance))
                        return;

                    _References[instance] = new WeakReference(this);

                    if (_OldVTables == null)
                    {
                        _OldVTables = new void*[1];
                        _OldVTables[0] = native->vfptr0.ToPointer();
                    }

                    if (_Thunks == null)
                    {
                        _Thunks = new void*[2];
                        _dtor_0DelegateInstance += _dtor_0DelegateHook;
                        _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                        _dir_begin_0DelegateInstance += _dir_begin_0DelegateHook;
                        _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_dir_begin_0DelegateInstance).ToPointer();
                    }

                    if (_NewVTables == null)
                    {
                        _NewVTables = new void*[1];
                        var vfptr0 = Marshal.AllocHGlobal(4 * 8);
                        _NewVTables[0] = vfptr0.ToPointer();
                        *(void**)(vfptr0 + 8) = _Thunks[0];
                        *(void**)(vfptr0 + 16) = *(void**)(native->vfptr0 + 16);
                        *(void**)(vfptr0 + 24) = *(void**)(native->vfptr0 + 24);
                        *(void**)(vfptr0 + 32) = _Thunks[1];
                    }

                    native->vfptr0 = new IntPtr(_NewVTables[0]);
                }

                #endregion
            }

            public unsafe partial class YAMLVFSEntry : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 48)]
                public partial struct Internal
                {
                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang3vfs12YAMLVFSEntryC2ERKS1_")]
                    internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang3vfs12YAMLVFSEntryD2Ev")]
                    internal static extern void dtor_0(global::System.IntPtr instance);
                }

                public global::System.IntPtr __Instance { get; protected set; }
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, YAMLVFSEntry> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, YAMLVFSEntry>();

                private readonly bool __ownsNativeInstance;

                public static YAMLVFSEntry __CreateInstance(global::System.IntPtr native)
                {
                    return new YAMLVFSEntry((YAMLVFSEntry.Internal*) native);
                }

                public static YAMLVFSEntry __CreateInstance(YAMLVFSEntry.Internal native)
                {
                    return new YAMLVFSEntry(native);
                }

                private static YAMLVFSEntry.Internal* __CopyValue(YAMLVFSEntry.Internal native)
                {
                    var ret = (YAMLVFSEntry.Internal*) Marshal.AllocHGlobal(48);
                    *ret = native;
                    return ret;
                }

                private YAMLVFSEntry(YAMLVFSEntry.Internal native)
                    : this(__CopyValue(native))
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected YAMLVFSEntry(YAMLVFSEntry.Internal* native, bool isInternalImpl = false)
                {
                    __Instance = new global::System.IntPtr(native);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    DestroyNativeInstance(false);
                }

                public virtual void DestroyNativeInstance()
                {
                    DestroyNativeInstance(true);
                }

                private void DestroyNativeInstance(bool force)
                {
                    clang.vfs.YAMLVFSEntry __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance || force)
                        Internal.dtor_0(__Instance);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }
            }

            public unsafe partial class YAMLVFSWriter : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 32)]
                public partial struct Internal
                {
                    [FieldOffset(24)]
                    internal llvm.Optional.Internal IsCaseSensitive;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang3vfs13YAMLVFSWriterC2Ev")]
                    internal static extern void ctor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang3vfs13YAMLVFSWriterC2ERKS1_")]
                    internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang3vfs13YAMLVFSWriterD2Ev")]
                    internal static extern void dtor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang3vfs13YAMLVFSWriter14addFileMappingEN4llvm9StringRefES3_")]
                    internal static extern void addFileMapping_0(global::System.IntPtr instance, llvm.StringRef.Internal VirtualPath, llvm.StringRef.Internal RealPath);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang3vfs13YAMLVFSWriter18setCaseSensitivityEb")]
                    internal static extern void setCaseSensitivity_0(global::System.IntPtr instance, bool CaseSensitive);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang3vfs13YAMLVFSWriter5writeERN4llvm11raw_ostreamE")]
                    internal static extern void write_0(global::System.IntPtr instance, global::System.IntPtr OS);
                }

                public global::System.IntPtr __Instance { get; protected set; }
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, YAMLVFSWriter> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, YAMLVFSWriter>();

                private readonly bool __ownsNativeInstance;

                public static YAMLVFSWriter __CreateInstance(global::System.IntPtr native)
                {
                    return new YAMLVFSWriter((YAMLVFSWriter.Internal*) native);
                }

                public static YAMLVFSWriter __CreateInstance(YAMLVFSWriter.Internal native)
                {
                    return new YAMLVFSWriter(native);
                }

                private static YAMLVFSWriter.Internal* __CopyValue(YAMLVFSWriter.Internal native)
                {
                    var ret = (YAMLVFSWriter.Internal*) Marshal.AllocHGlobal(32);
                    *ret = native;
                    return ret;
                }

                private YAMLVFSWriter(YAMLVFSWriter.Internal native)
                    : this(__CopyValue(native))
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected YAMLVFSWriter(YAMLVFSWriter.Internal* native, bool isInternalImpl = false)
                {
                    __Instance = new global::System.IntPtr(native);
                }

                public YAMLVFSWriter()
                {
                    __Instance = Marshal.AllocHGlobal(32);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    Internal.ctor_0(__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    DestroyNativeInstance(false);
                }

                public virtual void DestroyNativeInstance()
                {
                    DestroyNativeInstance(true);
                }

                private void DestroyNativeInstance(bool force)
                {
                    clang.vfs.YAMLVFSWriter __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance || force)
                        Internal.dtor_0(__Instance);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public void addFileMapping(llvm.StringRef VirtualPath, llvm.StringRef RealPath)
                {
                    var arg0 = ReferenceEquals(VirtualPath, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (VirtualPath.__Instance);
                    var arg1 = ReferenceEquals(RealPath, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (RealPath.__Instance);
                    Internal.addFileMapping_0(__Instance, arg0, arg1);
                }

                public void setCaseSensitivity(bool CaseSensitive)
                {
                    Internal.setCaseSensitivity_0(__Instance, CaseSensitive);
                }

                public void write(llvm.raw_ostream OS)
                {
                    var arg0 = ReferenceEquals(OS, null) ? global::System.IntPtr.Zero : OS.__Instance;
                    Internal.write_0(__Instance, arg0);
                }
            }

            internal unsafe partial class FileInternal : clang.vfs.File, IDisposable
            {
                private readonly bool __ownsNativeInstance;

                private static File.Internal* __CopyValue(File.Internal native)
                {
                    var ret = (File.Internal*) Marshal.AllocHGlobal(8);
                    *ret = native;
                    return ret;
                }

                internal FileInternal(File.Internal native)
                    : this(__CopyValue(native))
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                internal FileInternal(File.Internal* native, bool isInternalImpl = false)
                    : base((clang.vfs.File.Internal*) native, true)
                {
                }

                protected override void Dispose(bool disposing)
                {
                    DestroyNativeInstance(false);
                    base.Dispose(disposing);
                }

                public override void DestroyNativeInstance()
                {
                    DestroyNativeInstance(true);
                }

                private void DestroyNativeInstance(bool force)
                {
                    clang.vfs.File __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                /// <summary>
                /// <para>Closes the file.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Closes the file.</para>
                /// </remarks>
                public override std.__1.error_code close()
                {
                    void* slot = *(void**) (((File.Internal*) __Instance)->vfptr0 + 4 * 8);
                    var ___close_0Delegate = (_close_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_close_0Delegate));
                    var __ret = ___close_0Delegate(__Instance);
                    return std.__1.error_code.__CreateInstance(__ret);
                }

                /// <summary>
                /// <para>Sets the name to use for this file.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Sets the name to use for this file.</para>
                /// </remarks>
                public override void setName(llvm.StringRef Name)
                {
                    void* slot = *(void**) (((File.Internal*) __Instance)->vfptr0 + 5 * 8);
                    var ___setName_0Delegate = (_setName_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_setName_0Delegate));
                    var arg0 = ReferenceEquals(Name, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (Name.__Instance);
                    ___setName_0Delegate(__Instance, arg0);
                }
            }

            internal unsafe partial class FileSystemInternal : clang.vfs.FileSystem, IDisposable
            {
                private readonly bool __ownsNativeInstance;

                private static FileSystem.Internal* __CopyValue(FileSystem.Internal native)
                {
                    var ret = (FileSystem.Internal*) Marshal.AllocHGlobal(16);
                    *ret = native;
                    return ret;
                }

                internal FileSystemInternal(FileSystem.Internal native)
                    : this(__CopyValue(native))
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                internal FileSystemInternal(FileSystem.Internal* native, bool isInternalImpl = false)
                    : base((clang.vfs.FileSystem.Internal*) native, true)
                {
                }

                protected override void Dispose(bool disposing)
                {
                    DestroyNativeInstance(false);
                    base.Dispose(disposing);
                }

                public override void DestroyNativeInstance()
                {
                    DestroyNativeInstance(true);
                }

                private void DestroyNativeInstance(bool force)
                {
                    clang.vfs.FileSystem __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                /// <summary>
                /// <para>Get a directory_iterator for Dir.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Get a directory_iterator for \p Dir.</para>
                /// <para>  /// \note The 'end' iterator is directory_iterator().</para>
                /// </remarks>
                public virtual clang.vfs.directory_iterator dir_begin(llvm.Twine Dir, std.__1.error_code EC)
                {
                    void* slot = *(void**) (((FileSystem.Internal*) __Instance)->vfptr0 + 4 * 8);
                    var ___dir_begin_0Delegate = (_dir_begin_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_dir_begin_0Delegate));
                    var arg0 = ReferenceEquals(Dir, null) ? global::System.IntPtr.Zero : Dir.__Instance;
                    var arg1 = ReferenceEquals(EC, null) ? global::System.IntPtr.Zero : EC.__Instance;
                    var __ret = new clang.vfs.directory_iterator.Internal();
                    ___dir_begin_0Delegate(new IntPtr(&__ret), __Instance, arg0, arg1);
                    return clang.vfs.directory_iterator.__CreateInstance(__ret);
                }
            }

            public unsafe partial class VirtualFileSystem
            {
                public partial struct Internal
                {
                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang3vfs22getNextVirtualUniqueIDEv")]
                    internal static extern llvm.sys.fs.UniqueID.Internal getNextVirtualUniqueID_0();
                }

                /// <summary>
                /// <para>Get a globally unique ID for a virtual file or directory.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Get a globally unique ID for a virtual file or
                /// directory.</para>
                /// </remarks>
                public static llvm.sys.fs.UniqueID getNextVirtualUniqueID()
                {
                    var __ret = Internal.getNextVirtualUniqueID_0();
                    return llvm.sys.fs.UniqueID.__CreateInstance(__ret);
                }
            }

            namespace detail
            {
                /// <summary>
                /// <para>An interface for virtual file systems to provide an iterator over
                /// the (non-recursive) contents of a directory.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief An interface for virtual file systems to provide an
                /// iterator over the</para>
                /// <para>/// (non-recursive) contents of a directory.</para>
                /// </remarks>
                public unsafe abstract partial class DirIterImpl : IDisposable
                {
                    [StructLayout(LayoutKind.Explicit, Size = 96)]
                    public partial struct Internal
                    {
                        [FieldOffset(8)]
                        public clang.vfs.Status.Internal CurrentEntry;

                        [FieldOffset(0)]
                        public global::System.IntPtr vfptr0;

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZN5clang3vfs6detail11DirIterImplC2Ev")]
                        internal static extern void ctor_0(global::System.IntPtr instance);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZN5clang3vfs6detail11DirIterImplC2ERKS2_")]
                        internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                        [SuppressUnmanagedCodeSecurity]
                        [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                            EntryPoint="_ZN5clang3vfs6detail11DirIterImplD2Ev")]
                        internal static extern void dtor_0(global::System.IntPtr instance);
                    }

                    public global::System.IntPtr __Instance { get; protected set; }
                    public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, DirIterImpl> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, DirIterImpl>();

                    private readonly bool __ownsNativeInstance;

                    public static DirIterImpl __CreateInstance(global::System.IntPtr native)
                    {
                        return new DirIterImplInternal((DirIterImpl.Internal*) native);
                    }

                    public static DirIterImpl __CreateInstance(DirIterImpl.Internal native)
                    {
                        return new DirIterImplInternal(native);
                    }

                    protected DirIterImpl(DirIterImpl.Internal* native, bool isInternalImpl = false)
                    {
                        __Instance = new global::System.IntPtr(native);
                        if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                            SetupVTables(__Instance);
                    }

                    protected DirIterImpl()
                    {
                        __Instance = Marshal.AllocHGlobal(96);
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                        Internal.ctor_0(__Instance);
                        SetupVTables(__Instance);
                    }

                    public void Dispose()
                    {
                        Dispose(disposing: true);
                    }

                    protected virtual void Dispose(bool disposing)
                    {
                        DestroyNativeInstance(false);
                    }

                    public virtual void DestroyNativeInstance()
                    {
                        DestroyNativeInstance(true);
                    }

                    private void DestroyNativeInstance(bool force)
                    {
                        clang.vfs.detail.DirIterImpl __dummy;
                        NativeToManagedMap.TryRemove(__Instance, out __dummy);
                        if (__ownsNativeInstance || force)
                            Internal.dtor_0(__Instance);
                        if (__ownsNativeInstance)
                            Marshal.FreeHGlobal(__Instance);
                    }

                    /// <summary>
                    /// <para>Sets CurrentEntry to the next entry in the directory on success,
                    /// or returns a system-defined error_code.</para>
                    /// </summary>
                    /// <remarks>
                    /// <para>/// \brief Sets \c CurrentEntry to the next entry in the
                    /// directory on success,</para>
                    /// <para>  /// or returns a system-defined \c error_code.</para>
                    /// </remarks>
                    public abstract std.__1.error_code increment();

                    public clang.vfs.Status CurrentEntry
                    {
                        get
                        {
                            return clang.vfs.Status.__CreateInstance(((Internal*) __Instance)->CurrentEntry);
                        }

                        set
                        {
                            ((Internal*) __Instance)->CurrentEntry = ReferenceEquals(value, null) ? new clang.vfs.Status.Internal() : *(clang.vfs.Status.Internal*) (value.__Instance);
                        }
                    }

                    #region Virtual table interop

                    // virtual ~DirIterImpl()
                    [SuppressUnmanagedCodeSecurity]
                    [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
                    internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
                    private static _dtor_0Delegate _dtor_0DelegateInstance;

                    private static void _dtor_0DelegateHook(global::System.IntPtr instance)
                    {
                        if (!_References.ContainsKey(instance))
                            throw new global::System.Exception("No managed instance was found");

                        var __target = (DirIterImpl) _References[instance].Target;
                        __target.DestroyNativeInstance();
                    }

                    // std::error_code increment() = 0
                    [SuppressUnmanagedCodeSecurity]
                    [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
                    internal delegate std.__1.error_code.Internal _increment_0Delegate(global::System.IntPtr instance);
                    private static _increment_0Delegate _increment_0DelegateInstance;

                    private static std.__1.error_code.Internal _increment_0DelegateHook(global::System.IntPtr instance)
                    {
                        if (!_References.ContainsKey(instance))
                            throw new global::System.Exception("No managed instance was found");

                        var __target = (DirIterImpl) _References[instance].Target;
                        var __ret = __target.increment();
                        return ReferenceEquals(__ret, null) ? new std.__1.error_code.Internal() : *(std.__1.error_code.Internal*) (__ret.__Instance);
                    }

                    private static void*[] _OldVTables;
                    private static void*[] _NewVTables;
                    private static void*[] _Thunks;
                    private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

                    void SetupVTables(global::System.IntPtr instance)
                    {
                        var native = (Internal*)instance.ToPointer();

                        if (_References == null)
                            _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

                        if (_References.ContainsKey(instance))
                            return;

                        _References[instance] = new WeakReference(this);

                        if (_OldVTables == null)
                        {
                            _OldVTables = new void*[1];
                            _OldVTables[0] = native->vfptr0.ToPointer();
                        }

                        if (_Thunks == null)
                        {
                            _Thunks = new void*[2];
                            _dtor_0DelegateInstance += _dtor_0DelegateHook;
                            _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                            _increment_0DelegateInstance += _increment_0DelegateHook;
                            _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_increment_0DelegateInstance).ToPointer();
                        }

                        if (_NewVTables == null)
                        {
                            _NewVTables = new void*[1];
                            var vfptr0 = Marshal.AllocHGlobal(2 * 8);
                            _NewVTables[0] = vfptr0.ToPointer();
                            *(void**)(vfptr0 + 8) = _Thunks[0];
                            *(void**)(vfptr0 + 16) = _Thunks[1];
                        }

                        native->vfptr0 = new IntPtr(_NewVTables[0]);
                    }

                    #endregion
                }

                internal unsafe partial class DirIterImplInternal : clang.vfs.detail.DirIterImpl, IDisposable
                {
                    private readonly bool __ownsNativeInstance;

                    private static DirIterImpl.Internal* __CopyValue(DirIterImpl.Internal native)
                    {
                        var ret = (DirIterImpl.Internal*) Marshal.AllocHGlobal(96);
                        *ret = native;
                        return ret;
                    }

                    internal DirIterImplInternal(DirIterImpl.Internal native)
                        : this(__CopyValue(native))
                    {
                        __ownsNativeInstance = true;
                        NativeToManagedMap[__Instance] = this;
                    }

                    internal DirIterImplInternal(DirIterImpl.Internal* native, bool isInternalImpl = false)
                        : base((clang.vfs.detail.DirIterImpl.Internal*) native, true)
                    {
                    }

                    protected override void Dispose(bool disposing)
                    {
                        DestroyNativeInstance(false);
                        base.Dispose(disposing);
                    }

                    public override void DestroyNativeInstance()
                    {
                        DestroyNativeInstance(true);
                    }

                    private void DestroyNativeInstance(bool force)
                    {
                        clang.vfs.detail.DirIterImpl __dummy;
                        NativeToManagedMap.TryRemove(__Instance, out __dummy);
                        if (__ownsNativeInstance)
                            Marshal.FreeHGlobal(__Instance);
                    }

                    /// <summary>
                    /// <para>Sets CurrentEntry to the next entry in the directory on success,
                    /// or returns a system-defined error_code.</para>
                    /// </summary>
                    /// <remarks>
                    /// <para>/// \brief Sets \c CurrentEntry to the next entry in the
                    /// directory on success,</para>
                    /// <para>  /// or returns a system-defined \c error_code.</para>
                    /// </remarks>
                    public override std.__1.error_code increment()
                    {
                        void* slot = *(void**) (((DirIterImpl.Internal*) __Instance)->vfptr0 + 2 * 8);
                        var ___increment_0Delegate = (_increment_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_increment_0Delegate));
                        var __ret = ___increment_0Delegate(__Instance);
                        return std.__1.error_code.__CreateInstance(__ret);
                    }
                }
            }
        }
    }

    namespace llvm
    {
    }
}
