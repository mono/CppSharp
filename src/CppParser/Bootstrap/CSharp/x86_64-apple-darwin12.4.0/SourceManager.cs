//----------------------------------------------------------------------------
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
//----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace CppSharp
{
    namespace clang
    {
        /// <summary>
        /// <para>External source of source location entries.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief External source of source location entries.</para>
        /// </remarks>
        public unsafe abstract partial class ExternalSLocEntrySource : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 8)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr vfptr0;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang23ExternalSLocEntrySourceC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang23ExternalSLocEntrySourceC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang23ExternalSLocEntrySourceD2Ev")]
                internal static extern void dtor_0(global::System.IntPtr instance);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ExternalSLocEntrySource> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ExternalSLocEntrySource>();

            private readonly bool __ownsNativeInstance;

            public static ExternalSLocEntrySource __CreateInstance(global::System.IntPtr native)
            {
                return new ExternalSLocEntrySourceInternal((ExternalSLocEntrySource.Internal*) native);
            }

            public static ExternalSLocEntrySource __CreateInstance(ExternalSLocEntrySource.Internal native)
            {
                return new ExternalSLocEntrySourceInternal(native);
            }

            protected ExternalSLocEntrySource(ExternalSLocEntrySource.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
                if (__Instance != global::System.IntPtr.Zero && !isInternalImpl)
                    SetupVTables(__Instance);
            }

            protected ExternalSLocEntrySource()
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
                SetupVTables(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.ExternalSLocEntrySource __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance || force)
                    Internal.dtor_0(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            /// <summary>
            /// <para>Read the source location entry with index ID, which will always
            /// be less than -1.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Read the source location entry with index ID, which
            /// will always be</para>
            /// <para>  /// less than -1.</para>
            /// <para>  ///</para>
            /// <para>  /// \returns true if an error occurred that prevented the
            /// source-location</para>
            /// <para>  /// entry from being loaded.</para>
            /// </remarks>
            public abstract bool ReadSLocEntry(int ID);

            #region Virtual table interop

            // virtual ~ExternalSLocEntrySource()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
            private static _dtor_0Delegate _dtor_0DelegateInstance;

            private static void _dtor_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (ExternalSLocEntrySource) _References[instance].Target;
                __target.DestroyNativeInstance();
            }

            // bool ReadSLocEntry(int ID) = 0
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate bool _ReadSLocEntry_0Delegate(global::System.IntPtr instance, int ID);
            private static _ReadSLocEntry_0Delegate _ReadSLocEntry_0DelegateInstance;

            private static bool _ReadSLocEntry_0DelegateHook(global::System.IntPtr instance, int ID)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (ExternalSLocEntrySource) _References[instance].Target;
                var __ret = __target.ReadSLocEntry(ID);
                return __ret;
            }

            private static void*[] _OldVTables;
            private static void*[] _NewVTables;
            private static void*[] _Thunks;
            private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

            void SetupVTables(global::System.IntPtr instance)
            {
                var native = (Internal*)instance.ToPointer();

                if (_References == null)
                    _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

                if (_References.ContainsKey(instance))
                    return;

                _References[instance] = new WeakReference(this);

                if (_OldVTables == null)
                {
                    _OldVTables = new void*[1];
                    _OldVTables[0] = native->vfptr0.ToPointer();
                }

                if (_Thunks == null)
                {
                    _Thunks = new void*[2];
                    _dtor_0DelegateInstance += _dtor_0DelegateHook;
                    _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                    _ReadSLocEntry_0DelegateInstance += _ReadSLocEntry_0DelegateHook;
                    _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_ReadSLocEntry_0DelegateInstance).ToPointer();
                }

                if (_NewVTables == null)
                {
                    _NewVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(3 * 8);
                    _NewVTables[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + 8) = _Thunks[0];
                    *(void**)(vfptr0 + 16) = _Thunks[1];
                    *(void**)(vfptr0 + 24) = *(void**)(native->vfptr0 + 24);
                }

                native->vfptr0 = new IntPtr(_NewVTables[0]);
            }

            #endregion
        }

        /// <summary>
        /// <para>Holds the cache used by isBeforeInTranslationUnit.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief Holds the cache used by
        /// isBeforeInTranslationUnit.</para>
        /// <para>///</para>
        /// <para>/// The cache structure is complex enough to be worth breaking
        /// out of</para>
        /// <para>/// SourceManager.</para>
        /// </remarks>
        public unsafe partial class InBeforeInTUCacheEntry : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 24)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public clang.FileID.Internal LQueryFID;

                [FieldOffset(4)]
                public clang.FileID.Internal RQueryFID;

                [FieldOffset(8)]
                public bool IsLQFIDBeforeRQFID;

                [FieldOffset(12)]
                public clang.FileID.Internal CommonFID;

                [FieldOffset(16)]
                public uint LCommonOffset;

                [FieldOffset(20)]
                public uint RCommonOffset;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang22InBeforeInTUCacheEntryC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang22InBeforeInTUCacheEntryC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang22InBeforeInTUCacheEntry12isCacheValidENS_6FileIDES1_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isCacheValid_0(global::System.IntPtr instance, clang.FileID.Internal LHS, clang.FileID.Internal RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang22InBeforeInTUCacheEntry15getCachedResultEjj")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool getCachedResult_0(global::System.IntPtr instance, uint LOffset, uint ROffset);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang22InBeforeInTUCacheEntry12setQueryFIDsENS_6FileIDES1_b")]
                internal static extern void setQueryFIDs_0(global::System.IntPtr instance, clang.FileID.Internal LHS, clang.FileID.Internal RHS, bool isLFIDBeforeRFID);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang22InBeforeInTUCacheEntry5clearEv")]
                internal static extern void clear_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang22InBeforeInTUCacheEntry12setCommonLocENS_6FileIDEjj")]
                internal static extern void setCommonLoc_0(global::System.IntPtr instance, clang.FileID.Internal commonFID, uint lCommonOffset, uint rCommonOffset);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, InBeforeInTUCacheEntry> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, InBeforeInTUCacheEntry>();

            private readonly bool __ownsNativeInstance;

            public static InBeforeInTUCacheEntry __CreateInstance(global::System.IntPtr native)
            {
                return new InBeforeInTUCacheEntry((InBeforeInTUCacheEntry.Internal*) native);
            }

            public static InBeforeInTUCacheEntry __CreateInstance(InBeforeInTUCacheEntry.Internal native)
            {
                return new InBeforeInTUCacheEntry(native);
            }

            private static InBeforeInTUCacheEntry.Internal* __CopyValue(InBeforeInTUCacheEntry.Internal native)
            {
                var ret = (InBeforeInTUCacheEntry.Internal*) Marshal.AllocHGlobal(24);
                *ret = native;
                return ret;
            }

            private InBeforeInTUCacheEntry(InBeforeInTUCacheEntry.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected InBeforeInTUCacheEntry(InBeforeInTUCacheEntry.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public InBeforeInTUCacheEntry()
            {
                __Instance = Marshal.AllocHGlobal(24);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.InBeforeInTUCacheEntry __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            /// <summary>
            /// <para>Return true if the currently cached values match up with the
            /// specified LHS/RHS query.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return true if the currently cached values match up
            /// with</para>
            /// <para>  /// the specified LHS/RHS query.</para>
            /// <para>  ///</para>
            /// <para>  /// If not, we can't use the cache.</para>
            /// </remarks>
            public bool isCacheValid(clang.FileID LHS, clang.FileID RHS)
            {
                var arg0 = ReferenceEquals(LHS, null) ? new clang.FileID.Internal() : *(clang.FileID.Internal*) (LHS.__Instance);
                var arg1 = ReferenceEquals(RHS, null) ? new clang.FileID.Internal() : *(clang.FileID.Internal*) (RHS.__Instance);
                var __ret = Internal.isCacheValid_0(__Instance, arg0, arg1);
                return __ret;
            }

            /// <summary>
            /// <para>If the cache is valid, compute the result given the specified
            /// offsets in the LHS/RHS FileID's.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief If the cache is valid, compute the result given
            /// the</para>
            /// <para>  /// specified offsets in the LHS/RHS FileID's.</para>
            /// </remarks>
            public bool getCachedResult(uint LOffset, uint ROffset)
            {
                var __ret = Internal.getCachedResult_0(__Instance, LOffset, ROffset);
                return __ret;
            }

            /// <summary>
            /// <para>Set up a new query.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Set up a new query.</para>
            /// </remarks>
            public void setQueryFIDs(clang.FileID LHS, clang.FileID RHS, bool isLFIDBeforeRFID)
            {
                var arg0 = ReferenceEquals(LHS, null) ? new clang.FileID.Internal() : *(clang.FileID.Internal*) (LHS.__Instance);
                var arg1 = ReferenceEquals(RHS, null) ? new clang.FileID.Internal() : *(clang.FileID.Internal*) (RHS.__Instance);
                Internal.setQueryFIDs_0(__Instance, arg0, arg1, isLFIDBeforeRFID);
            }

            public void clear()
            {
                Internal.clear_0(__Instance);
            }

            public void setCommonLoc(clang.FileID commonFID, uint lCommonOffset, uint rCommonOffset)
            {
                var arg0 = ReferenceEquals(commonFID, null) ? new clang.FileID.Internal() : *(clang.FileID.Internal*) (commonFID.__Instance);
                Internal.setCommonLoc_0(__Instance, arg0, lCommonOffset, rCommonOffset);
            }
        }

        /// <summary>
        /// <para>This class handles loading and caching of source files into
        /// memory.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief This class handles loading and caching of source files
        /// into memory.</para>
        /// <para>///</para>
        /// <para>/// This object owns the MemoryBuffer objects for all of the
        /// loaded</para>
        /// <para>/// files and assigns unique FileID's for each unique \#include
        /// chain.</para>
        /// <para>///</para>
        /// <para>/// The SourceManager can be queried for information about
        /// SourceLocation</para>
        /// <para>/// objects, turning them into either spelling or expansion
        /// locations. Spelling</para>
        /// <para>/// locations represent where the bytes corresponding to a token
        /// came from and</para>
        /// <para>/// expansion locations represent where the location is in the
        /// user's view. In</para>
        /// <para>/// the case of a macro expansion, for example, the spelling
        /// location indicates</para>
        /// <para>/// where the expanded token came from and the expansion location
        /// specifies</para>
        /// <para>/// where it was expanded.</para>
        /// </remarks>
        public unsafe partial class SourceManager : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 648)]
            public partial struct Internal
            {
                [FieldOffset(8)]
                public global::System.IntPtr Diag;

                [FieldOffset(16)]
                public global::System.IntPtr FileMgr;

                [FieldOffset(24)]
                internal llvm.BumpPtrAllocatorImpl.Internal ContentCacheAlloc;

                [FieldOffset(160)]
                internal llvm.DenseMap.Internal FileInfos;

                [FieldOffset(184)]
                public bool OverridenFilesKeepOriginalName;

                [FieldOffset(185)]
                public bool UserFilesAreVolatile;

                [FieldOffset(224)]
                internal llvm.SmallVector.Internal LocalSLocEntryTable;

                [FieldOffset(280)]
                internal llvm.SmallVector.Internal LoadedSLocEntryTable;

                [FieldOffset(336)]
                public uint NextLocalOffset;

                [FieldOffset(340)]
                public uint CurrentLoadedOffset;

                [FieldOffset(368)]
                public global::System.IntPtr ExternalSLocEntries;

                [FieldOffset(376)]
                public clang.FileID.Internal LastFileIDLookup;

                [FieldOffset(384)]
                public global::System.IntPtr LineTable;

                [FieldOffset(392)]
                public clang.FileID.Internal LastLineNoFileIDQuery;

                [FieldOffset(400)]
                public global::System.IntPtr LastLineNoContentCache;

                [FieldOffset(408)]
                public uint LastLineNoFilePos;

                [FieldOffset(412)]
                public uint LastLineNoResult;

                [FieldOffset(416)]
                public clang.FileID.Internal MainFileID;

                [FieldOffset(420)]
                public clang.FileID.Internal PreambleFileID;

                [FieldOffset(424)]
                public uint NumLinearScans;

                [FieldOffset(428)]
                public uint NumBinaryProbes;

                [FieldOffset(432)]
                internal llvm.DenseMap.Internal IncludedLocMap;

                [FieldOffset(456)]
                internal llvm.DenseMap.Internal IBTUCache;

                [FieldOffset(480)]
                public clang.InBeforeInTUCacheEntry.Internal IBTUCacheOverflow;

                [FieldOffset(520)]
                internal llvm.DenseMap.Internal MacroArgsCacheMap;

                [FieldOffset(544)]
                internal llvm.SmallVector.Internal StoredModuleBuildStack;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13SourceManagerC2ERNS_17DiagnosticsEngineERNS_11FileManagerEb")]
                internal static extern void ctor_1(global::System.IntPtr instance, global::System.IntPtr Diag, global::System.IntPtr FileMgr, bool UserFilesAreVolatile);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13SourceManagerD2Ev")]
                internal static extern void dtor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13SourceManager13clearIDTablesEv")]
                internal static extern void clearIDTables_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13SourceManager14getDiagnosticsEv")]
                internal static extern global::System.IntPtr getDiagnostics_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13SourceManager14getFileManagerEv")]
                internal static extern global::System.IntPtr getFileManager_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13SourceManager33setOverridenFilesKeepOriginalNameEb")]
                internal static extern void setOverridenFilesKeepOriginalName_0(global::System.IntPtr instance, bool value);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13SourceManager20userFilesAreVolatileEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool userFilesAreVolatile_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13SourceManager20pushModuleBuildStackEN4llvm9StringRefENS_13FullSourceLocE")]
                internal static extern void pushModuleBuildStack_0(global::System.IntPtr instance, llvm.StringRef.Internal moduleName, clang.FullSourceLoc.Internal importLoc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13SourceManager13getMainFileIDEv")]
                internal static extern clang.FileID.Internal getMainFileID_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13SourceManager13setMainFileIDENS_6FileIDE")]
                internal static extern void setMainFileID_0(global::System.IntPtr instance, clang.FileID.Internal FID);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13SourceManager17setPreambleFileIDENS_6FileIDE")]
                internal static extern void setPreambleFileID_0(global::System.IntPtr instance, clang.FileID.Internal Preamble);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13SourceManager17getPreambleFileIDEv")]
                internal static extern clang.FileID.Internal getPreambleFileID_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13SourceManager12createFileIDEPKNS_9FileEntryENS_14SourceLocationENS_6SrcMgr18CharacteristicKindEij")]
                internal static extern clang.FileID.Internal createFileID_0(global::System.IntPtr instance, global::System.IntPtr SourceFile, clang.SourceLocation.Internal IncludePos, clang.SrcMgr.CharacteristicKind FileCharacter, int LoadedID, uint LoadedOffset);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13SourceManager26createMacroArgExpansionLocENS_14SourceLocationES1_j")]
                internal static extern clang.SourceLocation.Internal createMacroArgExpansionLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal Loc, clang.SourceLocation.Internal ExpansionLoc, uint TokLength);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13SourceManager18createExpansionLocENS_14SourceLocationES1_S1_jij")]
                internal static extern clang.SourceLocation.Internal createExpansionLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal Loc, clang.SourceLocation.Internal ExpansionLocStart, clang.SourceLocation.Internal ExpansionLocEnd, uint TokLength, int LoadedID, uint LoadedOffset);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13SourceManager22getMemoryBufferForFileEPKNS_9FileEntryEPb")]
                internal static extern global::System.IntPtr getMemoryBufferForFile_0(global::System.IntPtr instance, global::System.IntPtr File, bool* Invalid);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13SourceManager20overrideFileContentsEPKNS_9FileEntryEPN4llvm12MemoryBufferEb")]
                internal static extern void overrideFileContents_0(global::System.IntPtr instance, global::System.IntPtr SourceFile, global::System.IntPtr Buffer, bool DoNotFree);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13SourceManager20overrideFileContentsEPKNS_9FileEntryES3_")]
                internal static extern void overrideFileContents_2(global::System.IntPtr instance, global::System.IntPtr SourceFile, global::System.IntPtr NewFile);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13SourceManager16isFileOverriddenEPKNS_9FileEntryE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isFileOverridden_0(global::System.IntPtr instance, global::System.IntPtr File);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13SourceManager27disableFileContentsOverrideEPKNS_9FileEntryE")]
                internal static extern void disableFileContentsOverride_0(global::System.IntPtr instance, global::System.IntPtr File);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13SourceManager9getBufferENS_6FileIDENS_14SourceLocationEPb")]
                internal static extern global::System.IntPtr getBuffer_0(global::System.IntPtr instance, clang.FileID.Internal FID, clang.SourceLocation.Internal Loc, bool* Invalid);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13SourceManager9getBufferENS_6FileIDEPb")]
                internal static extern global::System.IntPtr getBuffer_1(global::System.IntPtr instance, clang.FileID.Internal FID, bool* Invalid);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13SourceManager17getFileEntryForIDENS_6FileIDE")]
                internal static extern global::System.IntPtr getFileEntryForID_0(global::System.IntPtr instance, clang.FileID.Internal FID);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13SourceManager24getFileEntryForSLocEntryERKNS_6SrcMgr9SLocEntryE")]
                internal static extern global::System.IntPtr getFileEntryForSLocEntry_0(global::System.IntPtr instance, global::System.IntPtr sloc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13SourceManager13getBufferDataENS_6FileIDEPb")]
                internal static extern llvm.StringRef.Internal getBufferData_0(global::System.IntPtr instance, clang.FileID.Internal FID, bool* Invalid);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13SourceManager26getNumCreatedFIDsForFileIDENS_6FileIDE")]
                internal static extern uint getNumCreatedFIDsForFileID_0(global::System.IntPtr instance, clang.FileID.Internal FID);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13SourceManager26setNumCreatedFIDsForFileIDENS_6FileIDEj")]
                internal static extern void setNumCreatedFIDsForFileID_0(global::System.IntPtr instance, clang.FileID.Internal FID, uint NumFIDs);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13SourceManager9getFileIDENS_14SourceLocationE")]
                internal static extern clang.FileID.Internal getFileID_0(global::System.IntPtr instance, clang.SourceLocation.Internal SpellingLoc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13SourceManager11getFilenameENS_14SourceLocationE")]
                internal static extern llvm.StringRef.Internal getFilename_0(global::System.IntPtr instance, clang.SourceLocation.Internal SpellingLoc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13SourceManager20getLocForStartOfFileENS_6FileIDE")]
                internal static extern clang.SourceLocation.Internal getLocForStartOfFile_0(global::System.IntPtr instance, clang.FileID.Internal FID);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13SourceManager18getLocForEndOfFileENS_6FileIDE")]
                internal static extern clang.SourceLocation.Internal getLocForEndOfFile_0(global::System.IntPtr instance, clang.FileID.Internal FID);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13SourceManager13getIncludeLocENS_6FileIDE")]
                internal static extern clang.SourceLocation.Internal getIncludeLoc_0(global::System.IntPtr instance, clang.FileID.Internal FID);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13SourceManager15getExpansionLocENS_14SourceLocationE")]
                internal static extern clang.SourceLocation.Internal getExpansionLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal Loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13SourceManager10getFileLocENS_14SourceLocationE")]
                internal static extern clang.SourceLocation.Internal getFileLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal Loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13SourceManager17getExpansionRangeENS_11SourceRangeE")]
                internal static extern clang.SourceRange.Internal getExpansionRange_1(global::System.IntPtr instance, clang.SourceRange.Internal Range);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13SourceManager14getSpellingLocENS_14SourceLocationE")]
                internal static extern clang.SourceLocation.Internal getSpellingLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal Loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13SourceManager23getImmediateSpellingLocENS_14SourceLocationE")]
                internal static extern clang.SourceLocation.Internal getImmediateSpellingLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal Loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13SourceManager13getFileOffsetENS_14SourceLocationE")]
                internal static extern uint getFileOffset_0(global::System.IntPtr instance, clang.SourceLocation.Internal SpellingLoc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13SourceManager19isMacroArgExpansionENS_14SourceLocationE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isMacroArgExpansion_0(global::System.IntPtr instance, clang.SourceLocation.Internal Loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13SourceManager20isMacroBodyExpansionENS_14SourceLocationE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isMacroBodyExpansion_0(global::System.IntPtr instance, clang.SourceLocation.Internal Loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13SourceManager34isAtStartOfImmediateMacroExpansionENS_14SourceLocationEPS1_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isAtStartOfImmediateMacroExpansion_0(global::System.IntPtr instance, clang.SourceLocation.Internal Loc, global::System.IntPtr MacroBegin);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13SourceManager32isAtEndOfImmediateMacroExpansionENS_14SourceLocationEPS1_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isAtEndOfImmediateMacroExpansion_0(global::System.IntPtr instance, clang.SourceLocation.Internal Loc, global::System.IntPtr MacroEnd);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13SourceManager17isInSLocAddrSpaceENS_14SourceLocationES1_jPj")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isInSLocAddrSpace_0(global::System.IntPtr instance, clang.SourceLocation.Internal Loc, clang.SourceLocation.Internal Start, uint Length, uint* RelativeOffset);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13SourceManager21isInSameSLocAddrSpaceENS_14SourceLocationES1_Pi")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isInSameSLocAddrSpace_0(global::System.IntPtr instance, clang.SourceLocation.Internal LHS, clang.SourceLocation.Internal RHS, int* RelativeOffset);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13SourceManager16getCharacterDataENS_14SourceLocationEPb")]
                internal static extern global::System.IntPtr getCharacterData_0(global::System.IntPtr instance, clang.SourceLocation.Internal SL, bool* Invalid);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13SourceManager15getColumnNumberENS_6FileIDEjPb")]
                internal static extern uint getColumnNumber_0(global::System.IntPtr instance, clang.FileID.Internal FID, uint FilePos, bool* Invalid);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13SourceManager23getSpellingColumnNumberENS_14SourceLocationEPb")]
                internal static extern uint getSpellingColumnNumber_0(global::System.IntPtr instance, clang.SourceLocation.Internal Loc, bool* Invalid);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13SourceManager24getExpansionColumnNumberENS_14SourceLocationEPb")]
                internal static extern uint getExpansionColumnNumber_0(global::System.IntPtr instance, clang.SourceLocation.Internal Loc, bool* Invalid);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13SourceManager23getPresumedColumnNumberENS_14SourceLocationEPb")]
                internal static extern uint getPresumedColumnNumber_0(global::System.IntPtr instance, clang.SourceLocation.Internal Loc, bool* Invalid);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13SourceManager13getLineNumberENS_6FileIDEjPb")]
                internal static extern uint getLineNumber_0(global::System.IntPtr instance, clang.FileID.Internal FID, uint FilePos, bool* Invalid);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13SourceManager21getSpellingLineNumberENS_14SourceLocationEPb")]
                internal static extern uint getSpellingLineNumber_0(global::System.IntPtr instance, clang.SourceLocation.Internal Loc, bool* Invalid);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13SourceManager22getExpansionLineNumberENS_14SourceLocationEPb")]
                internal static extern uint getExpansionLineNumber_0(global::System.IntPtr instance, clang.SourceLocation.Internal Loc, bool* Invalid);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13SourceManager21getPresumedLineNumberENS_14SourceLocationEPb")]
                internal static extern uint getPresumedLineNumber_0(global::System.IntPtr instance, clang.SourceLocation.Internal Loc, bool* Invalid);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13SourceManager13getBufferNameENS_14SourceLocationEPb")]
                internal static extern global::System.IntPtr getBufferName_0(global::System.IntPtr instance, clang.SourceLocation.Internal Loc, bool* Invalid);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13SourceManager21getFileCharacteristicENS_14SourceLocationE")]
                internal static extern clang.SrcMgr.CharacteristicKind getFileCharacteristic_0(global::System.IntPtr instance, clang.SourceLocation.Internal Loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13SourceManager14getPresumedLocENS_14SourceLocationEb")]
                internal static extern void getPresumedLoc_0(global::System.IntPtr @return, global::System.IntPtr instance, clang.SourceLocation.Internal Loc, bool UseLineDirectives);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13SourceManager12isInMainFileENS_14SourceLocationE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isInMainFile_0(global::System.IntPtr instance, clang.SourceLocation.Internal Loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13SourceManager19isWrittenInSameFileENS_14SourceLocationES1_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isWrittenInSameFile_0(global::System.IntPtr instance, clang.SourceLocation.Internal Loc1, clang.SourceLocation.Internal Loc2);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13SourceManager19isWrittenInMainFileENS_14SourceLocationE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isWrittenInMainFile_0(global::System.IntPtr instance, clang.SourceLocation.Internal Loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13SourceManager16isInSystemHeaderENS_14SourceLocationE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isInSystemHeader_0(global::System.IntPtr instance, clang.SourceLocation.Internal Loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13SourceManager23isInExternCSystemHeaderENS_14SourceLocationE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isInExternCSystemHeader_0(global::System.IntPtr instance, clang.SourceLocation.Internal Loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13SourceManager15isInSystemMacroENS_14SourceLocationE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isInSystemMacro_0(global::System.IntPtr instance, clang.SourceLocation.Internal loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13SourceManager13getFileIDSizeENS_6FileIDE")]
                internal static extern uint getFileIDSize_0(global::System.IntPtr instance, clang.FileID.Internal FID);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13SourceManager10isInFileIDENS_14SourceLocationENS_6FileIDEPj")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isInFileID_0(global::System.IntPtr instance, clang.SourceLocation.Internal Loc, clang.FileID.Internal FID, uint* RelativeOffset);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13SourceManager22getLineTableFilenameIDEN4llvm9StringRefE")]
                internal static extern uint getLineTableFilenameID_0(global::System.IntPtr instance, llvm.StringRef.Internal Str);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13SourceManager11AddLineNoteENS_14SourceLocationEji")]
                internal static extern void AddLineNote_0(global::System.IntPtr instance, clang.SourceLocation.Internal Loc, uint LineNo, int FilenameID);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13SourceManager11AddLineNoteENS_14SourceLocationEjibbbb")]
                internal static extern void AddLineNote_1(global::System.IntPtr instance, clang.SourceLocation.Internal Loc, uint LineNo, int FilenameID, bool IsFileEntry, bool IsFileExit, bool IsSystemHeader, bool IsExternCHeader);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13SourceManager12hasLineTableEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasLineTable_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13SourceManager19getContentCacheSizeEv")]
                internal static extern ulong getContentCacheSize_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13SourceManager20getMemoryBufferSizesEv")]
                internal static extern clang.SourceManager.MemoryBufferSizes.Internal getMemoryBufferSizes_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13SourceManager21getDataStructureSizesEv")]
                internal static extern ulong getDataStructureSizes_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13SourceManager20translateFileLineColEPKNS_9FileEntryEjj")]
                internal static extern clang.SourceLocation.Internal translateFileLineCol_0(global::System.IntPtr instance, global::System.IntPtr SourceFile, uint Line, uint Col);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13SourceManager13translateFileEPKNS_9FileEntryE")]
                internal static extern clang.FileID.Internal translateFile_0(global::System.IntPtr instance, global::System.IntPtr SourceFile);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13SourceManager16translateLineColENS_6FileIDEjj")]
                internal static extern clang.SourceLocation.Internal translateLineCol_0(global::System.IntPtr instance, clang.FileID.Internal FID, uint Line, uint Col);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13SourceManager27getMacroArgExpandedLocationENS_14SourceLocationE")]
                internal static extern clang.SourceLocation.Internal getMacroArgExpandedLocation_0(global::System.IntPtr instance, clang.SourceLocation.Internal Loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13SourceManager25isBeforeInTranslationUnitENS_14SourceLocationES1_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isBeforeInTranslationUnit_0(global::System.IntPtr instance, clang.SourceLocation.Internal LHS, clang.SourceLocation.Internal RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13SourceManager23isBeforeInSLocAddrSpaceENS_14SourceLocationES1_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isBeforeInSLocAddrSpace_0(global::System.IntPtr instance, clang.SourceLocation.Internal LHS, clang.SourceLocation.Internal RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13SourceManager23isBeforeInSLocAddrSpaceENS_14SourceLocationEj")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isBeforeInSLocAddrSpace_1(global::System.IntPtr instance, clang.SourceLocation.Internal LHS, uint RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13SourceManager11hasFileInfoEPKNS_9FileEntryE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasFileInfo_0(global::System.IntPtr instance, global::System.IntPtr File);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13SourceManager10PrintStatsEv")]
                internal static extern void PrintStats_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13SourceManager21local_sloc_entry_sizeEv")]
                internal static extern uint local_sloc_entry_size_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13SourceManager17getLocalSLocEntryEjPb")]
                internal static extern global::System.IntPtr getLocalSLocEntry_0(global::System.IntPtr instance, uint Index, bool* Invalid);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13SourceManager22loaded_sloc_entry_sizeEv")]
                internal static extern uint loaded_sloc_entry_size_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13SourceManager18getLoadedSLocEntryEjPb")]
                internal static extern global::System.IntPtr getLoadedSLocEntry_0(global::System.IntPtr instance, uint Index, bool* Invalid);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13SourceManager12getSLocEntryENS_6FileIDEPb")]
                internal static extern global::System.IntPtr getSLocEntry_0(global::System.IntPtr instance, clang.FileID.Internal FID, bool* Invalid);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13SourceManager18getNextLocalOffsetEv")]
                internal static extern uint getNextLocalOffset_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13SourceManager26setExternalSLocEntrySourceEPNS_23ExternalSLocEntrySourceE")]
                internal static extern void setExternalSLocEntrySource_0(global::System.IntPtr instance, global::System.IntPtr Source);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13SourceManager22isLoadedSourceLocationENS_14SourceLocationE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isLoadedSourceLocation_0(global::System.IntPtr instance, clang.SourceLocation.Internal Loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13SourceManager21isLocalSourceLocationENS_14SourceLocationE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isLocalSourceLocation_0(global::System.IntPtr instance, clang.SourceLocation.Internal Loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13SourceManager14isLoadedFileIDENS_6FileIDE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isLoadedFileID_0(global::System.IntPtr instance, clang.FileID.Internal FID);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13SourceManager13isLocalFileIDENS_6FileIDE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isLocalFileID_0(global::System.IntPtr instance, clang.FileID.Internal FID);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13SourceManager26getImmediateMacroCallerLocENS_14SourceLocationE")]
                internal static extern clang.SourceLocation.Internal getImmediateMacroCallerLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal Loc);
            }

            internal unsafe partial class OverriddenFilesInfoTy
            {
                [StructLayout(LayoutKind.Explicit, Size = 48)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    internal llvm.DenseMap.Internal OverriddenFiles;

                    [FieldOffset(24)]
                    internal llvm.DenseSet.Internal OverriddenFilesWithBuffer;
                }
            }

            public unsafe partial class MemoryBufferSizes : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 16)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public ulong malloc_bytes;

                    [FieldOffset(8)]
                    public ulong mmap_bytes;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang13SourceManager17MemoryBufferSizesC2Emm")]
                    internal static extern void ctor_0(global::System.IntPtr instance, ulong malloc_bytes, ulong mmap_bytes);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang13SourceManager17MemoryBufferSizesC2ERKS1_")]
                    internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, MemoryBufferSizes> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, MemoryBufferSizes>();

                private readonly bool __ownsNativeInstance;

                public static MemoryBufferSizes __CreateInstance(global::System.IntPtr native)
                {
                    return new MemoryBufferSizes((MemoryBufferSizes.Internal*) native);
                }

                public static MemoryBufferSizes __CreateInstance(MemoryBufferSizes.Internal native)
                {
                    return new MemoryBufferSizes(native);
                }

                private static MemoryBufferSizes.Internal* __CopyValue(MemoryBufferSizes.Internal native)
                {
                    var ret = (MemoryBufferSizes.Internal*) Marshal.AllocHGlobal(16);
                    *ret = native;
                    return ret;
                }

                private MemoryBufferSizes(MemoryBufferSizes.Internal native)
                    : this(__CopyValue(native))
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected MemoryBufferSizes(MemoryBufferSizes.Internal* native, bool isInternalImpl = false)
                {
                    __Instance = new global::System.IntPtr(native);
                }

                public MemoryBufferSizes(ulong malloc_bytes, ulong mmap_bytes)
                {
                    __Instance = Marshal.AllocHGlobal(16);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    var arg0 = malloc_bytes;
                    var arg1 = mmap_bytes;
                    Internal.ctor_0(__Instance, arg0, arg1);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    DestroyNativeInstance(false);
                }

                public virtual void DestroyNativeInstance()
                {
                    DestroyNativeInstance(true);
                }

                private void DestroyNativeInstance(bool force)
                {
                    clang.SourceManager.MemoryBufferSizes __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public ulong malloc_bytes
                {
                    get
                    {
                        return ((Internal*) __Instance)->malloc_bytes;
                    }
                }

                public ulong mmap_bytes
                {
                    get
                    {
                        return ((Internal*) __Instance)->mmap_bytes;
                    }
                }
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, SourceManager> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, SourceManager>();

            private readonly bool __ownsNativeInstance;

            public static SourceManager __CreateInstance(global::System.IntPtr native)
            {
                return new SourceManager((SourceManager.Internal*) native);
            }

            public static SourceManager __CreateInstance(SourceManager.Internal native)
            {
                return new SourceManager(native);
            }

            private static SourceManager.Internal* __CopyValue(SourceManager.Internal native)
            {
                var ret = (SourceManager.Internal*) Marshal.AllocHGlobal(648);
                *ret = native;
                return ret;
            }

            private SourceManager(SourceManager.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected SourceManager(SourceManager.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public SourceManager(clang.DiagnosticsEngine Diag, clang.FileManager FileMgr, bool UserFilesAreVolatile)
            {
                __Instance = Marshal.AllocHGlobal(648);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(Diag, null) ? global::System.IntPtr.Zero : Diag.__Instance;
                var arg1 = ReferenceEquals(FileMgr, null) ? global::System.IntPtr.Zero : FileMgr.__Instance;
                Internal.ctor_1(__Instance, arg0, arg1, UserFilesAreVolatile);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.SourceManager __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance || force)
                    Internal.dtor_0(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public void clearIDTables()
            {
                Internal.clearIDTables_0(__Instance);
            }

            public clang.DiagnosticsEngine getDiagnostics()
            {
                var __ret = Internal.getDiagnostics_0(__Instance);
                clang.DiagnosticsEngine __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.DiagnosticsEngine.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.DiagnosticsEngine) clang.DiagnosticsEngine.NativeToManagedMap[__ret];
                else __result0 = clang.DiagnosticsEngine.__CreateInstance(__ret);
                return __result0;
            }

            public clang.FileManager getFileManager()
            {
                var __ret = Internal.getFileManager_0(__Instance);
                clang.FileManager __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.FileManager.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.FileManager) clang.FileManager.NativeToManagedMap[__ret];
                else __result0 = clang.FileManager.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Set true if the SourceManager should report the original file
            /// name for contents of files that were overridden by other files. Defaults to
            /// true.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Set true if the SourceManager should report the
            /// original file name</para>
            /// <para>  /// for contents of files that were overridden by other files.
            /// Defaults to</para>
            /// <para>  /// true.</para>
            /// </remarks>
            public void setOverridenFilesKeepOriginalName(bool value)
            {
                Internal.setOverridenFilesKeepOriginalName_0(__Instance, value);
            }

            /// <summary>
            /// <para>True if non-system source files should be treated as volatile
            /// (likely to change while trying to use them).</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief True if non-system source files should be treated as
            /// volatile</para>
            /// <para>  /// (likely to change while trying to use them).</para>
            /// </remarks>
            public bool userFilesAreVolatile()
            {
                var __ret = Internal.userFilesAreVolatile_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Push an entry to the module build stack.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Push an entry to the module build stack.</para>
            /// </remarks>
            public void pushModuleBuildStack(llvm.StringRef moduleName, clang.FullSourceLoc importLoc)
            {
                var arg0 = ReferenceEquals(moduleName, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (moduleName.__Instance);
                var arg1 = ReferenceEquals(importLoc, null) ? new clang.FullSourceLoc.Internal() : *(clang.FullSourceLoc.Internal*) (importLoc.__Instance);
                Internal.pushModuleBuildStack_0(__Instance, arg0, arg1);
            }

            /// <summary>
            /// <para>Returns the FileID of the main source file.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Returns the FileID of the main source file.</para>
            /// </remarks>
            public clang.FileID getMainFileID()
            {
                var __ret = Internal.getMainFileID_0(__Instance);
                return clang.FileID.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Set the file ID for the main source file.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Set the file ID for the main source file.</para>
            /// </remarks>
            public void setMainFileID(clang.FileID FID)
            {
                var arg0 = ReferenceEquals(FID, null) ? new clang.FileID.Internal() : *(clang.FileID.Internal*) (FID.__Instance);
                Internal.setMainFileID_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>Set the file ID for the precompiled preamble.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Set the file ID for the precompiled preamble.</para>
            /// </remarks>
            public void setPreambleFileID(clang.FileID Preamble)
            {
                var arg0 = ReferenceEquals(Preamble, null) ? new clang.FileID.Internal() : *(clang.FileID.Internal*) (Preamble.__Instance);
                Internal.setPreambleFileID_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>Get the file ID for the precompiled preamble if there is
            /// one.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Get the file ID for the precompiled preamble if there
            /// is one.</para>
            /// </remarks>
            public clang.FileID getPreambleFileID()
            {
                var __ret = Internal.getPreambleFileID_0(__Instance);
                return clang.FileID.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Create a new FileID that represents the specified file being
            /// #included from the specified IncludePosition.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Create a new FileID that represents the specified
            /// file</para>
            /// <para>  /// being \#included from the specified IncludePosition.</para>
            /// <para>  ///</para>
            /// <para>  /// This translates NULL into standard input.</para>
            /// </remarks>
            public clang.FileID createFileID(clang.FileEntry SourceFile, clang.SourceLocation IncludePos, clang.SrcMgr.CharacteristicKind FileCharacter, int LoadedID, uint LoadedOffset)
            {
                var arg0 = ReferenceEquals(SourceFile, null) ? global::System.IntPtr.Zero : SourceFile.__Instance;
                var arg1 = ReferenceEquals(IncludePos, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (IncludePos.__Instance);
                var arg2 = FileCharacter;
                var __ret = Internal.createFileID_0(__Instance, arg0, arg1, arg2, LoadedID, LoadedOffset);
                return clang.FileID.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Return a new SourceLocation that encodes the fact that a token
            /// from SpellingLoc should actually be referenced from ExpansionLoc, and that
            /// it represents the expansion of a macro argument into the function-like
            /// macro body.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return a new SourceLocation that encodes the</para>
            /// <para>  /// fact that a token from SpellingLoc should actually be
            /// referenced from</para>
            /// <para>  /// ExpansionLoc, and that it represents the expansion of a
            /// macro argument</para>
            /// <para>  /// into the function-like macro body.</para>
            /// </remarks>
            public clang.SourceLocation createMacroArgExpansionLoc(clang.SourceLocation Loc, clang.SourceLocation ExpansionLoc, uint TokLength)
            {
                var arg0 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                var arg1 = ReferenceEquals(ExpansionLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (ExpansionLoc.__Instance);
                var __ret = Internal.createMacroArgExpansionLoc_0(__Instance, arg0, arg1, TokLength);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Return a new SourceLocation that encodes the fact that a token
            /// from SpellingLoc should actually be referenced from ExpansionLoc.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return a new SourceLocation that encodes the
            /// fact</para>
            /// <para>  /// that a token from SpellingLoc should actually be referenced
            /// from</para>
            /// <para>  /// ExpansionLoc.</para>
            /// </remarks>
            public clang.SourceLocation createExpansionLoc(clang.SourceLocation Loc, clang.SourceLocation ExpansionLocStart, clang.SourceLocation ExpansionLocEnd, uint TokLength, int LoadedID, uint LoadedOffset)
            {
                var arg0 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                var arg1 = ReferenceEquals(ExpansionLocStart, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (ExpansionLocStart.__Instance);
                var arg2 = ReferenceEquals(ExpansionLocEnd, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (ExpansionLocEnd.__Instance);
                var __ret = Internal.createExpansionLoc_0(__Instance, arg0, arg1, arg2, TokLength, LoadedID, LoadedOffset);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Retrieve the memory buffer associated with the given file.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the memory buffer associated with the given
            /// file.</para>
            /// <para>  ///</para>
            /// <para>  /// \param Invalid If non-NULL, will be set \c true if an
            /// error</para>
            /// <para>  /// occurs while retrieving the memory buffer.</para>
            /// </remarks>
            public llvm.MemoryBuffer getMemoryBufferForFile(clang.FileEntry File, ref bool Invalid)
            {
                var arg0 = ReferenceEquals(File, null) ? global::System.IntPtr.Zero : File.__Instance;
                fixed (bool* arg1 = &Invalid)
                {
                    var __ret = Internal.getMemoryBufferForFile_0(__Instance, arg0, arg1);
                    llvm.MemoryBuffer __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (llvm.MemoryBuffer.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (llvm.MemoryBuffer) llvm.MemoryBuffer.NativeToManagedMap[__ret];
                    else llvm.MemoryBuffer.NativeToManagedMap[__ret] = __result0 = (llvm.MemoryBuffer) llvm.MemoryBuffer.__CreateInstance(__ret);
                    return __result0;
                }
            }

            /// <summary>
            /// <para>Override the contents of the given source file by providing an
            /// already-allocated buffer.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Override the contents of the given source file by
            /// providing an</para>
            /// <para>  /// already-allocated buffer.</para>
            /// <para>  ///</para>
            /// <para>  /// \param SourceFile the source file whose contents will be
            /// overridden.</para>
            /// <para>  ///</para>
            /// <para>  /// \param Buffer the memory buffer whose contents will be used
            /// as the</para>
            /// <para>  /// data in the given source file.</para>
            /// <para>  ///</para>
            /// <para>  /// \param DoNotFree If true, then the buffer will not be freed
            /// when the</para>
            /// <para>  /// source manager is destroyed.</para>
            /// </remarks>
            public void overrideFileContents(clang.FileEntry SourceFile, llvm.MemoryBuffer Buffer, bool DoNotFree)
            {
                var arg0 = ReferenceEquals(SourceFile, null) ? global::System.IntPtr.Zero : SourceFile.__Instance;
                var arg1 = ReferenceEquals(Buffer, null) ? global::System.IntPtr.Zero : Buffer.__Instance;
                Internal.overrideFileContents_0(__Instance, arg0, arg1, DoNotFree);
            }

            /// <summary>
            /// <para>Override the given source file with another one.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Override the given source file with another
            /// one.</para>
            /// <para>  ///</para>
            /// <para>  /// \param SourceFile the source file which will be
            /// overridden.</para>
            /// <para>  ///</para>
            /// <para>  /// \param NewFile the file whose contents will be used as
            /// the</para>
            /// <para>  /// data instead of the contents of the given source
            /// file.</para>
            /// </remarks>
            public void overrideFileContents(clang.FileEntry SourceFile, clang.FileEntry NewFile)
            {
                var arg0 = ReferenceEquals(SourceFile, null) ? global::System.IntPtr.Zero : SourceFile.__Instance;
                var arg1 = ReferenceEquals(NewFile, null) ? global::System.IntPtr.Zero : NewFile.__Instance;
                Internal.overrideFileContents_2(__Instance, arg0, arg1);
            }

            /// <summary>
            /// <para>Returns true if the file contents have been overridden.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Returns true if the file contents have been
            /// overridden.</para>
            /// </remarks>
            public bool isFileOverridden(clang.FileEntry File)
            {
                var arg0 = ReferenceEquals(File, null) ? global::System.IntPtr.Zero : File.__Instance;
                var __ret = Internal.isFileOverridden_0(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Disable overridding the contents of a file, previously enabled
            /// with #overrideFileContents.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Disable overridding the contents of a file, previously
            /// enabled</para>
            /// <para>  /// with #overrideFileContents.</para>
            /// <para>  ///</para>
            /// <para>  /// This should be called before parsing has begun.</para>
            /// </remarks>
            public void disableFileContentsOverride(clang.FileEntry File)
            {
                var arg0 = ReferenceEquals(File, null) ? global::System.IntPtr.Zero : File.__Instance;
                Internal.disableFileContentsOverride_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>Return the buffer for the specified FileID.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the buffer for the specified FileID.</para>
            /// <para>  ///</para>
            /// <para>  /// If there is an error opening this buffer the first time,
            /// this</para>
            /// <para>  /// manufactures a temporary buffer and returns a non-empty
            /// error string.</para>
            /// </remarks>
            public llvm.MemoryBuffer getBuffer(clang.FileID FID, clang.SourceLocation Loc, ref bool Invalid)
            {
                var arg0 = ReferenceEquals(FID, null) ? new clang.FileID.Internal() : *(clang.FileID.Internal*) (FID.__Instance);
                var arg1 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                fixed (bool* arg2 = &Invalid)
                {
                    var __ret = Internal.getBuffer_0(__Instance, arg0, arg1, arg2);
                    llvm.MemoryBuffer __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (llvm.MemoryBuffer.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (llvm.MemoryBuffer) llvm.MemoryBuffer.NativeToManagedMap[__ret];
                    else llvm.MemoryBuffer.NativeToManagedMap[__ret] = __result0 = (llvm.MemoryBuffer) llvm.MemoryBuffer.__CreateInstance(__ret);
                    return __result0;
                }
            }

            public llvm.MemoryBuffer getBuffer(clang.FileID FID, ref bool Invalid)
            {
                var arg0 = ReferenceEquals(FID, null) ? new clang.FileID.Internal() : *(clang.FileID.Internal*) (FID.__Instance);
                fixed (bool* arg1 = &Invalid)
                {
                    var __ret = Internal.getBuffer_1(__Instance, arg0, arg1);
                    llvm.MemoryBuffer __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (llvm.MemoryBuffer.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (llvm.MemoryBuffer) llvm.MemoryBuffer.NativeToManagedMap[__ret];
                    else llvm.MemoryBuffer.NativeToManagedMap[__ret] = __result0 = (llvm.MemoryBuffer) llvm.MemoryBuffer.__CreateInstance(__ret);
                    return __result0;
                }
            }

            /// <summary>
            /// <para>Returns the FileEntry record for the provided FileID.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Returns the FileEntry record for the provided
            /// FileID.</para>
            /// </remarks>
            public clang.FileEntry getFileEntryForID(clang.FileID FID)
            {
                var arg0 = ReferenceEquals(FID, null) ? new clang.FileID.Internal() : *(clang.FileID.Internal*) (FID.__Instance);
                var __ret = Internal.getFileEntryForID_0(__Instance, arg0);
                clang.FileEntry __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.FileEntry.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.FileEntry) clang.FileEntry.NativeToManagedMap[__ret];
                else __result0 = clang.FileEntry.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Returns the FileEntry record for the provided SLocEntry.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Returns the FileEntry record for the provided
            /// SLocEntry.</para>
            /// </remarks>
            public clang.FileEntry getFileEntryForSLocEntry(clang.SrcMgr.SLocEntry sloc)
            {
                var arg0 = ReferenceEquals(sloc, null) ? global::System.IntPtr.Zero : sloc.__Instance;
                var __ret = Internal.getFileEntryForSLocEntry_0(__Instance, arg0);
                clang.FileEntry __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.FileEntry.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.FileEntry) clang.FileEntry.NativeToManagedMap[__ret];
                else __result0 = clang.FileEntry.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Return a StringRef to the source buffer data for the specified
            /// FileID.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return a StringRef to the source buffer data for
            /// the</para>
            /// <para>  /// specified FileID.</para>
            /// <para>  ///</para>
            /// <para>  /// \param FID The file ID whose contents will be
            /// returned.</para>
            /// <para>  /// \param Invalid If non-NULL, will be set true if an error
            /// occurred.</para>
            /// </remarks>
            public llvm.StringRef getBufferData(clang.FileID FID, ref bool Invalid)
            {
                var arg0 = ReferenceEquals(FID, null) ? new clang.FileID.Internal() : *(clang.FileID.Internal*) (FID.__Instance);
                fixed (bool* arg1 = &Invalid)
                {
                    var __ret = Internal.getBufferData_0(__Instance, arg0, arg1);
                    return llvm.StringRef.__CreateInstance(__ret);
                }
            }

            /// <summary>
            /// <para>Get the number of FileIDs (files and macros) that were created
            /// during preprocessing of FID, including it.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Get the number of FileIDs (files and macros) that were
            /// created</para>
            /// <para>  /// during preprocessing of \p FID, including it.</para>
            /// </remarks>
            public uint getNumCreatedFIDsForFileID(clang.FileID FID)
            {
                var arg0 = ReferenceEquals(FID, null) ? new clang.FileID.Internal() : *(clang.FileID.Internal*) (FID.__Instance);
                var __ret = Internal.getNumCreatedFIDsForFileID_0(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Set the number of FileIDs (files and macros) that were created
            /// during preprocessing of FID, including it.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Set the number of FileIDs (files and macros) that were
            /// created</para>
            /// <para>  /// during preprocessing of \p FID, including it.</para>
            /// </remarks>
            public void setNumCreatedFIDsForFileID(clang.FileID FID, uint NumFIDs)
            {
                var arg0 = ReferenceEquals(FID, null) ? new clang.FileID.Internal() : *(clang.FileID.Internal*) (FID.__Instance);
                Internal.setNumCreatedFIDsForFileID_0(__Instance, arg0, NumFIDs);
            }

            /// <summary>
            /// <para>Return the FileID for a SourceLocation.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the FileID for a SourceLocation.</para>
            /// <para>  ///</para>
            /// <para>  /// This is a very hot method that is used for all
            /// SourceManager queries</para>
            /// <para>  /// that start with a SourceLocation object.  It is responsible
            /// for finding</para>
            /// <para>  /// the entry in SLocEntryTable which contains the specified
            /// location.</para>
            /// <para>  ///</para>
            /// </remarks>
            public clang.FileID getFileID(clang.SourceLocation SpellingLoc)
            {
                var arg0 = ReferenceEquals(SpellingLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (SpellingLoc.__Instance);
                var __ret = Internal.getFileID_0(__Instance, arg0);
                return clang.FileID.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Return the filename of the file containing a
            /// SourceLocation.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the filename of the file containing a
            /// SourceLocation.</para>
            /// </remarks>
            public llvm.StringRef getFilename(clang.SourceLocation SpellingLoc)
            {
                var arg0 = ReferenceEquals(SpellingLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (SpellingLoc.__Instance);
                var __ret = Internal.getFilename_0(__Instance, arg0);
                return llvm.StringRef.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Return the source location corresponding to the first byte of the
            /// specified file.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the source location corresponding to the first
            /// byte of</para>
            /// <para>  /// the specified file.</para>
            /// </remarks>
            public clang.SourceLocation getLocForStartOfFile(clang.FileID FID)
            {
                var arg0 = ReferenceEquals(FID, null) ? new clang.FileID.Internal() : *(clang.FileID.Internal*) (FID.__Instance);
                var __ret = Internal.getLocForStartOfFile_0(__Instance, arg0);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Return the source location corresponding to the last byte of the
            /// specified file.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the source location corresponding to the last
            /// byte of the</para>
            /// <para>  /// specified file.</para>
            /// </remarks>
            public clang.SourceLocation getLocForEndOfFile(clang.FileID FID)
            {
                var arg0 = ReferenceEquals(FID, null) ? new clang.FileID.Internal() : *(clang.FileID.Internal*) (FID.__Instance);
                var __ret = Internal.getLocForEndOfFile_0(__Instance, arg0);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Returns the include location if FID is a #include'd file
            /// otherwise it returns an invalid location.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Returns the include location if \p FID is a
            /// \#include'd file</para>
            /// <para>  /// otherwise it returns an invalid location.</para>
            /// </remarks>
            public clang.SourceLocation getIncludeLoc(clang.FileID FID)
            {
                var arg0 = ReferenceEquals(FID, null) ? new clang.FileID.Internal() : *(clang.FileID.Internal*) (FID.__Instance);
                var __ret = Internal.getIncludeLoc_0(__Instance, arg0);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Given a SourceLocation object Loc, return the expansion location
            /// referenced by the ID.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Given a SourceLocation object \p Loc, return the
            /// expansion</para>
            /// <para>  /// location referenced by the ID.</para>
            /// </remarks>
            public clang.SourceLocation getExpansionLoc(clang.SourceLocation Loc)
            {
                var arg0 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                var __ret = Internal.getExpansionLoc_0(__Instance, arg0);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Given Loc, if it is a macro location return the expansion
            /// location or the spelling location, depending on if it comes from a macro
            /// argument or not.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Given \p Loc, if it is a macro location return the
            /// expansion</para>
            /// <para>  /// location or the spelling location, depending on if it comes
            /// from a</para>
            /// <para>  /// macro argument or not.</para>
            /// </remarks>
            public clang.SourceLocation getFileLoc(clang.SourceLocation Loc)
            {
                var arg0 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                var __ret = Internal.getFileLoc_0(__Instance, arg0);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Given a SourceRange object, return the range of tokens covered by
            /// the expansion in the ultimate file.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Given a SourceRange object, return the range of</para>
            /// <para>  /// tokens covered by the expansion in the ultimate
            /// file.</para>
            /// </remarks>
            public clang.SourceRange getExpansionRange(clang.SourceRange Range)
            {
                var arg0 = ReferenceEquals(Range, null) ? new clang.SourceRange.Internal() : *(clang.SourceRange.Internal*) (Range.__Instance);
                var __ret = Internal.getExpansionRange_1(__Instance, arg0);
                return clang.SourceRange.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Given a SourceLocation object, return the spelling location
            /// referenced by the ID.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Given a SourceLocation object, return the
            /// spelling</para>
            /// <para>  /// location referenced by the ID.</para>
            /// <para>  ///</para>
            /// <para>  /// This is the place where the characters that make up the
            /// lexed token</para>
            /// <para>  /// can be found.</para>
            /// </remarks>
            public clang.SourceLocation getSpellingLoc(clang.SourceLocation Loc)
            {
                var arg0 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                var __ret = Internal.getSpellingLoc_0(__Instance, arg0);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Given a SourceLocation object, return the spelling location
            /// referenced by the ID.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Given a SourceLocation object, return the spelling
            /// location</para>
            /// <para>  /// referenced by the ID.</para>
            /// <para>  ///</para>
            /// <para>  /// This is the first level down towards the place where the
            /// characters</para>
            /// <para>  /// that make up the lexed token can be found.  This should not
            /// generally</para>
            /// <para>  /// be used by clients.</para>
            /// </remarks>
            public clang.SourceLocation getImmediateSpellingLoc(clang.SourceLocation Loc)
            {
                var arg0 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                var __ret = Internal.getImmediateSpellingLoc_0(__Instance, arg0);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Returns the offset from the start of the file that the specified
            /// SourceLocation represents.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Returns the offset from the start of the file that
            /// the</para>
            /// <para>  /// specified SourceLocation represents.</para>
            /// <para>  ///</para>
            /// <para>  /// This is not very meaningful for a macro ID.</para>
            /// </remarks>
            public uint getFileOffset(clang.SourceLocation SpellingLoc)
            {
                var arg0 = ReferenceEquals(SpellingLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (SpellingLoc.__Instance);
                var __ret = Internal.getFileOffset_0(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Tests whether the given source location represents a macro
            /// argument's expansion into the function-like macro definition.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Tests whether the given source location represents a
            /// macro</para>
            /// <para>  /// argument's expansion into the function-like macro
            /// definition.</para>
            /// <para>  ///</para>
            /// <para>  /// Such source locations only appear inside of the
            /// expansion</para>
            /// <para>  /// locations representing where a particular function-like
            /// macro was</para>
            /// <para>  /// expanded.</para>
            /// </remarks>
            public bool isMacroArgExpansion(clang.SourceLocation Loc)
            {
                var arg0 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                var __ret = Internal.isMacroArgExpansion_0(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Tests whether the given source location represents the expansion
            /// of a macro body.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Tests whether the given source location represents the
            /// expansion of</para>
            /// <para>  /// a macro body.</para>
            /// <para>  ///</para>
            /// <para>  /// This is equivalent to testing whether the location is part
            /// of a macro</para>
            /// <para>  /// expansion but not the expansion of an argument to a
            /// function-like macro.</para>
            /// </remarks>
            public bool isMacroBodyExpansion(clang.SourceLocation Loc)
            {
                var arg0 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                var __ret = Internal.isMacroBodyExpansion_0(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Returns true if the given MacroID location points at the
            /// beginning of the immediate macro expansion.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Returns true if the given MacroID location points at
            /// the beginning</para>
            /// <para>  /// of the immediate macro expansion.</para>
            /// <para>  ///</para>
            /// <para>  /// \param MacroBegin If non-null and function returns true, it
            /// is set to the</para>
            /// <para>  /// begin location of the immediate macro expansion.</para>
            /// </remarks>
            public bool isAtStartOfImmediateMacroExpansion(clang.SourceLocation Loc, clang.SourceLocation MacroBegin)
            {
                var arg0 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                var arg1 = ReferenceEquals(MacroBegin, null) ? global::System.IntPtr.Zero : MacroBegin.__Instance;
                var __ret = Internal.isAtStartOfImmediateMacroExpansion_0(__Instance, arg0, arg1);
                return __ret;
            }

            /// <summary>
            /// <para>Returns true if the given MacroID location points at the
            /// character end of the immediate macro expansion.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Returns true if the given MacroID location points at
            /// the character</para>
            /// <para>  /// end of the immediate macro expansion.</para>
            /// <para>  ///</para>
            /// <para>  /// \param MacroEnd If non-null and function returns true, it
            /// is set to the</para>
            /// <para>  /// character end location of the immediate macro
            /// expansion.</para>
            /// </remarks>
            public bool isAtEndOfImmediateMacroExpansion(clang.SourceLocation Loc, clang.SourceLocation MacroEnd)
            {
                var arg0 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                var arg1 = ReferenceEquals(MacroEnd, null) ? global::System.IntPtr.Zero : MacroEnd.__Instance;
                var __ret = Internal.isAtEndOfImmediateMacroExpansion_0(__Instance, arg0, arg1);
                return __ret;
            }

            /// <summary>
            /// <para>Returns true if Loc is inside the [ Start, + Length) chunk of the
            /// source location address space.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Returns true if \p Loc is inside the [\p Start, +\p
            /// Length)</para>
            /// <para>  /// chunk of the source location address space.</para>
            /// <para>  ///</para>
            /// <para>  /// If it's true and \p RelativeOffset is non-null, it will be
            /// set to the</para>
            /// <para>  /// relative offset of \p Loc inside the chunk.</para>
            /// </remarks>
            public bool isInSLocAddrSpace(clang.SourceLocation Loc, clang.SourceLocation Start, uint Length, ref uint RelativeOffset)
            {
                var arg0 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                var arg1 = ReferenceEquals(Start, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Start.__Instance);
                fixed (uint* arg3 = &RelativeOffset)
                {
                    var __ret = Internal.isInSLocAddrSpace_0(__Instance, arg0, arg1, Length, arg3);
                    return __ret;
                }
            }

            /// <summary>
            /// <para>Return true if both LHS and RHS are in the local source location
            /// address space or the loaded one.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return true if both \p LHS and \p RHS are in the local
            /// source</para>
            /// <para>  /// location address space or the loaded one.</para>
            /// <para>  ///</para>
            /// <para>  /// If it's true and \p RelativeOffset is non-null, it will be
            /// set to the</para>
            /// <para>  /// offset of \p RHS relative to \p LHS.</para>
            /// </remarks>
            public bool isInSameSLocAddrSpace(clang.SourceLocation LHS, clang.SourceLocation RHS, ref int RelativeOffset)
            {
                var arg0 = ReferenceEquals(LHS, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (LHS.__Instance);
                var arg1 = ReferenceEquals(RHS, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (RHS.__Instance);
                fixed (int* arg2 = &RelativeOffset)
                {
                    var __ret = Internal.isInSameSLocAddrSpace_0(__Instance, arg0, arg1, arg2);
                    return __ret;
                }
            }

            /// <summary>
            /// <para>Return a pointer to the start of the specified location in the
            /// appropriate spelling MemoryBuffer.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return a pointer to the start of the specified
            /// location</para>
            /// <para>  /// in the appropriate spelling MemoryBuffer.</para>
            /// <para>  ///</para>
            /// <para>  /// \param Invalid If non-NULL, will be set \c true if an error
            /// occurs.</para>
            /// </remarks>
            public string getCharacterData(clang.SourceLocation SL, ref bool Invalid)
            {
                var arg0 = ReferenceEquals(SL, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (SL.__Instance);
                fixed (bool* arg1 = &Invalid)
                {
                    var __ret = Internal.getCharacterData_0(__Instance, arg0, arg1);
                    return Marshal.PtrToStringAnsi(__ret);
                }
            }

            /// <summary>
            /// <para>Return the column # for the specified file position.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the column # for the specified file
            /// position.</para>
            /// <para>  ///</para>
            /// <para>  /// This is significantly cheaper to compute than the line
            /// number.  This</para>
            /// <para>  /// returns zero if the column number isn't known.  This may
            /// only be called</para>
            /// <para>  /// on a file sloc, so you must choose a spelling or expansion
            /// location</para>
            /// <para>  /// before calling this method.</para>
            /// </remarks>
            public uint getColumnNumber(clang.FileID FID, uint FilePos, ref bool Invalid)
            {
                var arg0 = ReferenceEquals(FID, null) ? new clang.FileID.Internal() : *(clang.FileID.Internal*) (FID.__Instance);
                fixed (bool* arg2 = &Invalid)
                {
                    var __ret = Internal.getColumnNumber_0(__Instance, arg0, FilePos, arg2);
                    return __ret;
                }
            }

            public uint getSpellingColumnNumber(clang.SourceLocation Loc, ref bool Invalid)
            {
                var arg0 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                fixed (bool* arg1 = &Invalid)
                {
                    var __ret = Internal.getSpellingColumnNumber_0(__Instance, arg0, arg1);
                    return __ret;
                }
            }

            public uint getExpansionColumnNumber(clang.SourceLocation Loc, ref bool Invalid)
            {
                var arg0 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                fixed (bool* arg1 = &Invalid)
                {
                    var __ret = Internal.getExpansionColumnNumber_0(__Instance, arg0, arg1);
                    return __ret;
                }
            }

            public uint getPresumedColumnNumber(clang.SourceLocation Loc, ref bool Invalid)
            {
                var arg0 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                fixed (bool* arg1 = &Invalid)
                {
                    var __ret = Internal.getPresumedColumnNumber_0(__Instance, arg0, arg1);
                    return __ret;
                }
            }

            /// <summary>
            /// <para>Given a SourceLocation, return the spelling line number for the
            /// position indicated.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Given a SourceLocation, return the spelling line
            /// number</para>
            /// <para>  /// for the position indicated.</para>
            /// <para>  ///</para>
            /// <para>  /// This requires building and caching a table of line offsets
            /// for the</para>
            /// <para>  /// MemoryBuffer, so this is not cheap: use only when about to
            /// emit a</para>
            /// <para>  /// diagnostic.</para>
            /// </remarks>
            public uint getLineNumber(clang.FileID FID, uint FilePos, ref bool Invalid)
            {
                var arg0 = ReferenceEquals(FID, null) ? new clang.FileID.Internal() : *(clang.FileID.Internal*) (FID.__Instance);
                fixed (bool* arg2 = &Invalid)
                {
                    var __ret = Internal.getLineNumber_0(__Instance, arg0, FilePos, arg2);
                    return __ret;
                }
            }

            public uint getSpellingLineNumber(clang.SourceLocation Loc, ref bool Invalid)
            {
                var arg0 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                fixed (bool* arg1 = &Invalid)
                {
                    var __ret = Internal.getSpellingLineNumber_0(__Instance, arg0, arg1);
                    return __ret;
                }
            }

            public uint getExpansionLineNumber(clang.SourceLocation Loc, ref bool Invalid)
            {
                var arg0 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                fixed (bool* arg1 = &Invalid)
                {
                    var __ret = Internal.getExpansionLineNumber_0(__Instance, arg0, arg1);
                    return __ret;
                }
            }

            public uint getPresumedLineNumber(clang.SourceLocation Loc, ref bool Invalid)
            {
                var arg0 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                fixed (bool* arg1 = &Invalid)
                {
                    var __ret = Internal.getPresumedLineNumber_0(__Instance, arg0, arg1);
                    return __ret;
                }
            }

            /// <summary>
            /// <para>Return the filename or buffer identifier of the buffer the
            /// location is in.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the filename or buffer identifier of the buffer
            /// the</para>
            /// <para>  /// location is in.</para>
            /// <para>  ///</para>
            /// <para>  /// Note that this name does not respect \#line directives.
            /// Use</para>
            /// <para>  /// getPresumedLoc for normal clients.</para>
            /// </remarks>
            public string getBufferName(clang.SourceLocation Loc, ref bool Invalid)
            {
                var arg0 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                fixed (bool* arg1 = &Invalid)
                {
                    var __ret = Internal.getBufferName_0(__Instance, arg0, arg1);
                    return Marshal.PtrToStringAnsi(__ret);
                }
            }

            /// <summary>
            /// <para>Return the file characteristic of the specified source location,
            /// indicating whether this is a normal file, a system header, or an
            /// &quot;implicit extern C&quot; system header.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the file characteristic of the specified
            /// source</para>
            /// <para>  /// location, indicating whether this is a normal file, a
            /// system</para>
            /// <para>  /// header, or an &quot;implicit extern C&quot; system
            /// header.</para>
            /// <para>  ///</para>
            /// <para>  /// This state can be modified with flags on GNU linemarker
            /// directives like:</para>
            /// <para>  /// \code</para>
            /// <para>  ///   # 4 &quot;foo.h&quot; 3</para>
            /// <para>  /// \endcode</para>
            /// <para>  /// which changes all source locations in the current file
            /// after that to be</para>
            /// <para>  /// considered to be from a system header.</para>
            /// </remarks>
            public clang.SrcMgr.CharacteristicKind getFileCharacteristic(clang.SourceLocation Loc)
            {
                var arg0 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                var __ret = Internal.getFileCharacteristic_0(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Returns the &quot;presumed&quot; location of a SourceLocation
            /// specifies.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Returns the &quot;presumed&quot; location of a
            /// SourceLocation specifies.</para>
            /// <para>  ///</para>
            /// <para>  /// A &quot;presumed location&quot; can be modified by \#line
            /// or GNU line marker</para>
            /// <para>  /// directives.  This provides a view on the data that a user
            /// should see</para>
            /// <para>  /// in diagnostics, for example.</para>
            /// <para>  ///</para>
            /// <para>  /// Note that a presumed location is always given as the
            /// expansion point of</para>
            /// <para>  /// an expansion location, not at the spelling location.</para>
            /// <para>  ///</para>
            /// <para>  /// \returns The presumed location of the specified
            /// SourceLocation. If the</para>
            /// <para>  /// presumed location cannot be calculated (e.g., because \p
            /// Loc is invalid</para>
            /// <para>  /// or the file containing \p Loc has changed on disk), returns
            /// an invalid</para>
            /// <para>  /// presumed location.</para>
            /// </remarks>
            public clang.PresumedLoc getPresumedLoc(clang.SourceLocation Loc, bool UseLineDirectives)
            {
                var arg0 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                var __ret = new clang.PresumedLoc.Internal();
                Internal.getPresumedLoc_0(new IntPtr(&__ret), __Instance, arg0, UseLineDirectives);
                return clang.PresumedLoc.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Returns whether the PresumedLoc for a given SourceLocation is in
            /// the main file.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Returns whether the PresumedLoc for a given
            /// SourceLocation is </para>
            /// <para>  /// in the main file.</para>
            /// <para>  ///</para>
            /// <para>  /// This computes the &quot;presumed&quot; location for a
            /// SourceLocation, then checks</para>
            /// <para>  /// whether it came from a file other than the main file. This
            /// is different</para>
            /// <para>  /// from isWrittenInMainFile() because it takes line marker
            /// directives into</para>
            /// <para>  /// account.</para>
            /// </remarks>
            public bool isInMainFile(clang.SourceLocation Loc)
            {
                var arg0 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                var __ret = Internal.isInMainFile_0(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Returns true if the spelling locations for both SourceLocations
            /// are part of the same file buffer.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Returns true if the spelling locations for both
            /// SourceLocations</para>
            /// <para>  /// are part of the same file buffer.</para>
            /// <para>  ///</para>
            /// <para>  /// This check ignores line marker directives.</para>
            /// </remarks>
            public bool isWrittenInSameFile(clang.SourceLocation Loc1, clang.SourceLocation Loc2)
            {
                var arg0 = ReferenceEquals(Loc1, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc1.__Instance);
                var arg1 = ReferenceEquals(Loc2, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc2.__Instance);
                var __ret = Internal.isWrittenInSameFile_0(__Instance, arg0, arg1);
                return __ret;
            }

            /// <summary>
            /// <para>Returns true if the spelling location for the given location is
            /// in the main file buffer.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Returns true if the spelling location for the given
            /// location</para>
            /// <para>  /// is in the main file buffer.</para>
            /// <para>  ///</para>
            /// <para>  /// This check ignores line marker directives.</para>
            /// </remarks>
            public bool isWrittenInMainFile(clang.SourceLocation Loc)
            {
                var arg0 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                var __ret = Internal.isWrittenInMainFile_0(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Returns if a SourceLocation is in a system header.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Returns if a SourceLocation is in a system
            /// header.</para>
            /// </remarks>
            public bool isInSystemHeader(clang.SourceLocation Loc)
            {
                var arg0 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                var __ret = Internal.isInSystemHeader_0(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Returns if a SourceLocation is in an &quot;extern C&quot; system
            /// header.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Returns if a SourceLocation is in an &quot;extern
            /// C&quot; system header.</para>
            /// </remarks>
            public bool isInExternCSystemHeader(clang.SourceLocation Loc)
            {
                var arg0 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                var __ret = Internal.isInExternCSystemHeader_0(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Returns whether Loc is expanded from a macro in a system
            /// header.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Returns whether \p Loc is expanded from a macro in a
            /// system header.</para>
            /// </remarks>
            public bool isInSystemMacro(clang.SourceLocation loc)
            {
                var arg0 = ReferenceEquals(loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (loc.__Instance);
                var __ret = Internal.isInSystemMacro_0(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>The size of the SLocEntry that FID represents.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief The size of the SLocEntry that \p FID
            /// represents.</para>
            /// </remarks>
            public uint getFileIDSize(clang.FileID FID)
            {
                var arg0 = ReferenceEquals(FID, null) ? new clang.FileID.Internal() : *(clang.FileID.Internal*) (FID.__Instance);
                var __ret = Internal.getFileIDSize_0(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Given a specific FileID, returns true if Loc is inside that
            /// FileID chunk and sets relative offset (offset of Loc from beginning of
            /// FileID) to relativeOffset.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Given a specific FileID, returns true if \p Loc is
            /// inside that</para>
            /// <para>  /// FileID chunk and sets relative offset (offset of \p Loc
            /// from beginning</para>
            /// <para>  /// of FileID) to \p relativeOffset.</para>
            /// </remarks>
            public bool isInFileID(clang.SourceLocation Loc, clang.FileID FID, ref uint RelativeOffset)
            {
                var arg0 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                var arg1 = ReferenceEquals(FID, null) ? new clang.FileID.Internal() : *(clang.FileID.Internal*) (FID.__Instance);
                fixed (uint* arg2 = &RelativeOffset)
                {
                    var __ret = Internal.isInFileID_0(__Instance, arg0, arg1, arg2);
                    return __ret;
                }
            }

            /// <summary>
            /// <para>Return the uniqued ID for the specified filename.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the uniqued ID for the specified
            /// filename.</para>
            /// <para>  ///</para>
            /// </remarks>
            public uint getLineTableFilenameID(llvm.StringRef Str)
            {
                var arg0 = ReferenceEquals(Str, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (Str.__Instance);
                var __ret = Internal.getLineTableFilenameID_0(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Add a line note to the line table for the FileID and offset
            /// specified by Loc.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Add a line note to the line table for the FileID and
            /// offset</para>
            /// <para>  /// specified by Loc.</para>
            /// <para>  ///</para>
            /// <para>  /// If FilenameID is -1, it is considered to be
            /// unspecified.</para>
            /// </remarks>
            public void AddLineNote(clang.SourceLocation Loc, uint LineNo, int FilenameID)
            {
                var arg0 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                Internal.AddLineNote_0(__Instance, arg0, LineNo, FilenameID);
            }

            public void AddLineNote(clang.SourceLocation Loc, uint LineNo, int FilenameID, bool IsFileEntry, bool IsFileExit, bool IsSystemHeader, bool IsExternCHeader)
            {
                var arg0 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                Internal.AddLineNote_1(__Instance, arg0, LineNo, FilenameID, IsFileEntry, IsFileExit, IsSystemHeader, IsExternCHeader);
            }

            /// <summary>
            /// <para>Determine if the source manager has a line table.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine if the source manager has a line
            /// table.</para>
            /// </remarks>
            public bool hasLineTable()
            {
                var __ret = Internal.hasLineTable_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Return the total amount of physical memory allocated by the
            /// ContentCache allocator.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the total amount of physical memory allocated
            /// by the</para>
            /// <para>  /// ContentCache allocator.</para>
            /// </remarks>
            public ulong getContentCacheSize()
            {
                var __ret = Internal.getContentCacheSize_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Return the amount of memory used by memory buffers, breaking down
            /// by heap-backed versus mmap'ed memory.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the amount of memory used by memory buffers,
            /// breaking down</para>
            /// <para>  /// by heap-backed versus mmap'ed memory.</para>
            /// </remarks>
            public clang.SourceManager.MemoryBufferSizes getMemoryBufferSizes()
            {
                var __ret = Internal.getMemoryBufferSizes_0(__Instance);
                return clang.SourceManager.MemoryBufferSizes.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Return the amount of memory used for various side tables and data
            /// structures in the SourceManager.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the amount of memory used for various side
            /// tables and</para>
            /// <para>  /// data structures in the SourceManager.</para>
            /// </remarks>
            public ulong getDataStructureSizes()
            {
                var __ret = Internal.getDataStructureSizes_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Get the source location for the given file:line:col
            /// triplet.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Get the source location for the given file:line:col
            /// triplet.</para>
            /// <para>  ///</para>
            /// <para>  /// If the source file is included multiple times, the source
            /// location will</para>
            /// <para>  /// be based upon the first inclusion.</para>
            /// </remarks>
            public clang.SourceLocation translateFileLineCol(clang.FileEntry SourceFile, uint Line, uint Col)
            {
                var arg0 = ReferenceEquals(SourceFile, null) ? global::System.IntPtr.Zero : SourceFile.__Instance;
                var __ret = Internal.translateFileLineCol_0(__Instance, arg0, Line, Col);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Get the FileID for the given file.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Get the FileID for the given file.</para>
            /// <para>  ///</para>
            /// <para>  /// If the source file is included multiple times, the FileID
            /// will be the</para>
            /// <para>  /// first inclusion.</para>
            /// </remarks>
            public clang.FileID translateFile(clang.FileEntry SourceFile)
            {
                var arg0 = ReferenceEquals(SourceFile, null) ? global::System.IntPtr.Zero : SourceFile.__Instance;
                var __ret = Internal.translateFile_0(__Instance, arg0);
                return clang.FileID.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Get the source location in FID for the given line:col. Returns
            /// null location if FID is not a file SLocEntry.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Get the source location in \p FID for the given
            /// line:col.</para>
            /// <para>  /// Returns null location if \p FID is not a file
            /// SLocEntry.</para>
            /// </remarks>
            public clang.SourceLocation translateLineCol(clang.FileID FID, uint Line, uint Col)
            {
                var arg0 = ReferenceEquals(FID, null) ? new clang.FileID.Internal() : *(clang.FileID.Internal*) (FID.__Instance);
                var __ret = Internal.translateLineCol_0(__Instance, arg0, Line, Col);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>If Loc points inside a function macro argument, the returned
            /// location will be the macro location in which the argument was expanded. If
            /// a macro argument is used multiple times, the expanded location will be at
            /// the first expansion of the argument. e.g. MY_MACRO(foo); ^ Passing a file
            /// location pointing at 'foo', will yield a macro location where 'foo' was
            /// expanded into.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief If \p Loc points inside a function macro argument, the
            /// returned</para>
            /// <para>  /// location will be the macro location in which the argument
            /// was expanded.</para>
            /// <para>  /// If a macro argument is used multiple times, the expanded
            /// location will</para>
            /// <para>  /// be at the first expansion of the argument.</para>
            /// <para>  /// e.g.</para>
            /// <para>  ///   MY_MACRO(foo);</para>
            /// <para>  ///             ^</para>
            /// <para>  /// Passing a file location pointing at 'foo', will yield a
            /// macro location</para>
            /// <para>  /// where 'foo' was expanded into.</para>
            /// </remarks>
            public clang.SourceLocation getMacroArgExpandedLocation(clang.SourceLocation Loc)
            {
                var arg0 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                var __ret = Internal.getMacroArgExpandedLocation_0(__Instance, arg0);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Determines the order of 2 source locations in the translation
            /// unit.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determines the order of 2 source locations in the
            /// translation unit.</para>
            /// <para>  ///</para>
            /// <para>  /// \returns true if LHS source location comes before RHS,
            /// false otherwise.</para>
            /// </remarks>
            public bool isBeforeInTranslationUnit(clang.SourceLocation LHS, clang.SourceLocation RHS)
            {
                var arg0 = ReferenceEquals(LHS, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (LHS.__Instance);
                var arg1 = ReferenceEquals(RHS, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (RHS.__Instance);
                var __ret = Internal.isBeforeInTranslationUnit_0(__Instance, arg0, arg1);
                return __ret;
            }

            /// <summary>
            /// <para>Determines the order of 2 source locations in the &quot;source
            /// location address space&quot;.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determines the order of 2 source locations in the
            /// &quot;source location</para>
            /// <para>  /// address space&quot;.</para>
            /// </remarks>
            public bool isBeforeInSLocAddrSpace(clang.SourceLocation LHS, clang.SourceLocation RHS)
            {
                var arg0 = ReferenceEquals(LHS, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (LHS.__Instance);
                var arg1 = ReferenceEquals(RHS, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (RHS.__Instance);
                var __ret = Internal.isBeforeInSLocAddrSpace_0(__Instance, arg0, arg1);
                return __ret;
            }

            /// <summary>
            /// <para>Determines the order of a source location and a source location
            /// offset in the &quot;source location address space&quot;.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determines the order of a source location and a source
            /// location</para>
            /// <para>  /// offset in the &quot;source location address
            /// space&quot;.</para>
            /// <para>  ///</para>
            /// <para>  /// Note that we always consider source locations loaded
            /// from</para>
            /// </remarks>
            public bool isBeforeInSLocAddrSpace(clang.SourceLocation LHS, uint RHS)
            {
                var arg0 = ReferenceEquals(LHS, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (LHS.__Instance);
                var __ret = Internal.isBeforeInSLocAddrSpace_1(__Instance, arg0, RHS);
                return __ret;
            }

            public bool hasFileInfo(clang.FileEntry File)
            {
                var arg0 = ReferenceEquals(File, null) ? global::System.IntPtr.Zero : File.__Instance;
                var __ret = Internal.hasFileInfo_0(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Print statistics to stderr.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Print statistics to stderr.</para>
            /// <para>  ///</para>
            /// </remarks>
            public void PrintStats()
            {
                Internal.PrintStats_0(__Instance);
            }

            /// <summary>
            /// <para>Get the number of local SLocEntries we have.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Get the number of local SLocEntries we have.</para>
            /// </remarks>
            public uint local_sloc_entry_size()
            {
                var __ret = Internal.local_sloc_entry_size_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Get a local SLocEntry. This is exposed for indexing.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Get a local SLocEntry. This is exposed for
            /// indexing.</para>
            /// </remarks>
            public clang.SrcMgr.SLocEntry getLocalSLocEntry(uint Index, ref bool Invalid)
            {
                fixed (bool* arg1 = &Invalid)
                {
                    var __ret = Internal.getLocalSLocEntry_0(__Instance, Index, arg1);
                    clang.SrcMgr.SLocEntry __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (clang.SrcMgr.SLocEntry.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (clang.SrcMgr.SLocEntry) clang.SrcMgr.SLocEntry.NativeToManagedMap[__ret];
                    else __result0 = clang.SrcMgr.SLocEntry.__CreateInstance(__ret);
                    return __result0;
                }
            }

            /// <summary>
            /// <para>Get the number of loaded SLocEntries we have.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Get the number of loaded SLocEntries we have.</para>
            /// </remarks>
            public uint loaded_sloc_entry_size()
            {
                var __ret = Internal.loaded_sloc_entry_size_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Get a loaded SLocEntry. This is exposed for indexing.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Get a loaded SLocEntry. This is exposed for
            /// indexing.</para>
            /// </remarks>
            public clang.SrcMgr.SLocEntry getLoadedSLocEntry(uint Index, ref bool Invalid)
            {
                fixed (bool* arg1 = &Invalid)
                {
                    var __ret = Internal.getLoadedSLocEntry_0(__Instance, Index, arg1);
                    clang.SrcMgr.SLocEntry __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (clang.SrcMgr.SLocEntry.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (clang.SrcMgr.SLocEntry) clang.SrcMgr.SLocEntry.NativeToManagedMap[__ret];
                    else __result0 = clang.SrcMgr.SLocEntry.__CreateInstance(__ret);
                    return __result0;
                }
            }

            public clang.SrcMgr.SLocEntry getSLocEntry(clang.FileID FID, ref bool Invalid)
            {
                var arg0 = ReferenceEquals(FID, null) ? new clang.FileID.Internal() : *(clang.FileID.Internal*) (FID.__Instance);
                fixed (bool* arg1 = &Invalid)
                {
                    var __ret = Internal.getSLocEntry_0(__Instance, arg0, arg1);
                    clang.SrcMgr.SLocEntry __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (clang.SrcMgr.SLocEntry.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (clang.SrcMgr.SLocEntry) clang.SrcMgr.SLocEntry.NativeToManagedMap[__ret];
                    else __result0 = clang.SrcMgr.SLocEntry.__CreateInstance(__ret);
                    return __result0;
                }
            }

            public uint getNextLocalOffset()
            {
                var __ret = Internal.getNextLocalOffset_0(__Instance);
                return __ret;
            }

            public void setExternalSLocEntrySource(clang.ExternalSLocEntrySource Source)
            {
                var arg0 = ReferenceEquals(Source, null) ? global::System.IntPtr.Zero : Source.__Instance;
                Internal.setExternalSLocEntrySource_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>Returns true if Loc came from a PCH/Module.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Returns true if \p Loc came from a PCH/Module.</para>
            /// </remarks>
            public bool isLoadedSourceLocation(clang.SourceLocation Loc)
            {
                var arg0 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                var __ret = Internal.isLoadedSourceLocation_0(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Returns true if Loc did not come from a PCH/Module.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Returns true if \p Loc did not come from a
            /// PCH/Module.</para>
            /// </remarks>
            public bool isLocalSourceLocation(clang.SourceLocation Loc)
            {
                var arg0 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                var __ret = Internal.isLocalSourceLocation_0(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Returns true if FID came from a PCH/Module.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Returns true if \p FID came from a PCH/Module.</para>
            /// </remarks>
            public bool isLoadedFileID(clang.FileID FID)
            {
                var arg0 = ReferenceEquals(FID, null) ? new clang.FileID.Internal() : *(clang.FileID.Internal*) (FID.__Instance);
                var __ret = Internal.isLoadedFileID_0(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Returns true if FID did not come from a PCH/Module.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Returns true if \p FID did not come from a
            /// PCH/Module.</para>
            /// </remarks>
            public bool isLocalFileID(clang.FileID FID)
            {
                var arg0 = ReferenceEquals(FID, null) ? new clang.FileID.Internal() : *(clang.FileID.Internal*) (FID.__Instance);
                var __ret = Internal.isLocalFileID_0(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Gets the location of the immediate macro caller, one level up the
            /// stack toward the initial macro typed into the source.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Gets the location of the immediate macro caller, one level up
            /// the stack</para>
            /// <para>  /// toward the initial macro typed into the source.</para>
            /// </remarks>
            public clang.SourceLocation getImmediateMacroCallerLoc(clang.SourceLocation Loc)
            {
                var arg0 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                var __ret = Internal.getImmediateMacroCallerLoc_0(__Instance, arg0);
                return clang.SourceLocation.__CreateInstance(__ret);
            }
        }

        internal unsafe partial class ExternalSLocEntrySourceInternal : clang.ExternalSLocEntrySource, IDisposable
        {
            private readonly bool __ownsNativeInstance;

            private static ExternalSLocEntrySource.Internal* __CopyValue(ExternalSLocEntrySource.Internal native)
            {
                var ret = (ExternalSLocEntrySource.Internal*) Marshal.AllocHGlobal(8);
                *ret = native;
                return ret;
            }

            internal ExternalSLocEntrySourceInternal(ExternalSLocEntrySource.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            internal ExternalSLocEntrySourceInternal(ExternalSLocEntrySource.Internal* native, bool isInternalImpl = false)
                : base((clang.ExternalSLocEntrySource.Internal*) native, true)
            {
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.ExternalSLocEntrySource __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            /// <summary>
            /// <para>Read the source location entry with index ID, which will always
            /// be less than -1.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Read the source location entry with index ID, which
            /// will always be</para>
            /// <para>  /// less than -1.</para>
            /// <para>  ///</para>
            /// <para>  /// \returns true if an error occurred that prevented the
            /// source-location</para>
            /// <para>  /// entry from being loaded.</para>
            /// </remarks>
            public override bool ReadSLocEntry(int ID)
            {
                void* slot = *(void**) (((ExternalSLocEntrySource.Internal*) __Instance)->vfptr0 + 2 * 8);
                var ___ReadSLocEntry_0Delegate = (_ReadSLocEntry_0Delegate) Marshal.GetDelegateForFunctionPointer(new IntPtr(slot), typeof(_ReadSLocEntry_0Delegate));
                var __ret = ___ReadSLocEntry_0Delegate(__Instance, ID);
                return __ret;
            }
        }

        namespace SrcMgr
        {
            /// <summary>
            /// <para>Indicates whether a file or directory holds normal user code,
            /// system code, or system code which is implicitly 'extern &quot;C&quot;' in
            /// C++ mode.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Indicates whether a file or directory holds normal
            /// user code,</para>
            /// <para>  /// system code, or system code which is implicitly 'extern
            /// &quot;C&quot;' in C++ mode.</para>
            /// <para>  ///</para>
            /// <para>  /// Entire directories can be tagged with this (this is
            /// maintained by</para>
            /// <para>  /// DirectoryLookup and friends) as can specific FileInfos when
            /// a \#pragma</para>
            /// <para>  /// system_header is seen or in various other cases.</para>
            /// <para>  ///</para>
            /// </remarks>
            public enum CharacteristicKind : uint
            {
                C_User = 0,
                C_System = 1,
                C_ExternCSystem = 2
            }

            /// <summary>
            /// <para>One instance of this struct is kept for every file loaded or
            /// used.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief One instance of this struct is kept for every file
            /// loaded or used.</para>
            /// <para>  ///</para>
            /// <para>  /// This object owns the MemoryBuffer object.</para>
            /// </remarks>
            public unsafe partial class ContentCache : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 48)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    internal llvm.AlignedCharArray.Internal NonceAligner;

                    [FieldOffset(8)]
                    internal llvm.PointerIntPair.Internal Buffer;

                    [FieldOffset(16)]
                    public global::System.IntPtr OrigEntry;

                    [FieldOffset(24)]
                    public global::System.IntPtr ContentsEntry;

                    [FieldOffset(32)]
                    public uint* SourceLineCache;

                    [FieldOffset(40)]
                    public uint NumLines;

                    [FieldOffset(43)]
                    public uint BufferOverridden;

                    [FieldOffset(44)]
                    public uint IsSystemFile;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang6SrcMgr12ContentCacheC2EPKNS_9FileEntryE")]
                    internal static extern void ctor_0(global::System.IntPtr instance, global::System.IntPtr Ent);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang6SrcMgr12ContentCacheC2EPKNS_9FileEntryES4_")]
                    internal static extern void ctor_1(global::System.IntPtr instance, global::System.IntPtr Ent, global::System.IntPtr contentEnt);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang6SrcMgr12ContentCacheC2ERKS1_")]
                    internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr RHS);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang6SrcMgr12ContentCacheD2Ev")]
                    internal static extern void dtor_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang6SrcMgr12ContentCache9getBufferERNS_17DiagnosticsEngineERKNS_13SourceManagerENS_14SourceLocationEPb")]
                    internal static extern global::System.IntPtr getBuffer_0(global::System.IntPtr instance, global::System.IntPtr Diag, global::System.IntPtr SM, clang.SourceLocation.Internal Loc, bool* Invalid);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang6SrcMgr12ContentCache7getSizeEv")]
                    internal static extern uint getSize_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang6SrcMgr12ContentCache18getSizeBytesMappedEv")]
                    internal static extern uint getSizeBytesMapped_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang6SrcMgr12ContentCache19getMemoryBufferKindEv")]
                    internal static extern llvm.MemoryBuffer.BufferKind getMemoryBufferKind_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang6SrcMgr12ContentCache12getRawBufferEv")]
                    internal static extern global::System.IntPtr getRawBuffer_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang6SrcMgr12ContentCache13replaceBufferEPN4llvm12MemoryBufferEb")]
                    internal static extern void replaceBuffer_0(global::System.IntPtr instance, global::System.IntPtr B, bool DoNotFree);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang6SrcMgr12ContentCache15isBufferInvalidEv")]
                    [return: MarshalAsAttribute(UnmanagedType.I1)]
                    internal static extern bool isBufferInvalid_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang6SrcMgr12ContentCache16shouldFreeBufferEv")]
                    [return: MarshalAsAttribute(UnmanagedType.I1)]
                    internal static extern bool shouldFreeBuffer_0(global::System.IntPtr instance);
                }

                public global::System.IntPtr __Instance { get; protected set; }
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ContentCache> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ContentCache>();

                private readonly bool __ownsNativeInstance;

                public static ContentCache __CreateInstance(global::System.IntPtr native)
                {
                    return new ContentCache((ContentCache.Internal*) native);
                }

                public static ContentCache __CreateInstance(ContentCache.Internal native)
                {
                    return new ContentCache(native);
                }

                private static ContentCache.Internal* __CopyValue(ContentCache.Internal native)
                {
                    var ret = (ContentCache.Internal*) Marshal.AllocHGlobal(48);
                    *ret = native;
                    return ret;
                }

                private ContentCache(ContentCache.Internal native)
                    : this(__CopyValue(native))
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected ContentCache(ContentCache.Internal* native, bool isInternalImpl = false)
                {
                    __Instance = new global::System.IntPtr(native);
                }

                public ContentCache(clang.FileEntry Ent)
                {
                    __Instance = Marshal.AllocHGlobal(48);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    var arg0 = ReferenceEquals(Ent, null) ? global::System.IntPtr.Zero : Ent.__Instance;
                    Internal.ctor_0(__Instance, arg0);
                }

                public ContentCache(clang.FileEntry Ent, clang.FileEntry contentEnt)
                {
                    __Instance = Marshal.AllocHGlobal(48);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    var arg0 = ReferenceEquals(Ent, null) ? global::System.IntPtr.Zero : Ent.__Instance;
                    var arg1 = ReferenceEquals(contentEnt, null) ? global::System.IntPtr.Zero : contentEnt.__Instance;
                    Internal.ctor_1(__Instance, arg0, arg1);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    DestroyNativeInstance(false);
                }

                public virtual void DestroyNativeInstance()
                {
                    DestroyNativeInstance(true);
                }

                private void DestroyNativeInstance(bool force)
                {
                    clang.SrcMgr.ContentCache __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance || force)
                        Internal.dtor_0(__Instance);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                /// <summary>
                /// <para>Returns the memory buffer for the associated content.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Returns the memory buffer for the associated
                /// content.</para>
                /// <para>    ///</para>
                /// <para>    /// \param Diag Object through which diagnostics will be
                /// emitted if the</para>
                /// <para>    ///   buffer cannot be retrieved.</para>
                /// <para>    ///</para>
                /// <para>    /// \param Loc If specified, is the location that invalid
                /// file diagnostics</para>
                /// <para>    ///   will be emitted at.</para>
                /// <para>    ///</para>
                /// <para>    /// \param Invalid If non-NULL, will be set \c true if an
                /// error occurred.</para>
                /// </remarks>
                public llvm.MemoryBuffer getBuffer(clang.DiagnosticsEngine Diag, clang.SourceManager SM, clang.SourceLocation Loc, ref bool Invalid)
                {
                    var arg0 = ReferenceEquals(Diag, null) ? global::System.IntPtr.Zero : Diag.__Instance;
                    var arg1 = ReferenceEquals(SM, null) ? global::System.IntPtr.Zero : SM.__Instance;
                    var arg2 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                    fixed (bool* arg3 = &Invalid)
                    {
                        var __ret = Internal.getBuffer_0(__Instance, arg0, arg1, arg2, arg3);
                        llvm.MemoryBuffer __result0;
                        if (__ret == IntPtr.Zero) __result0 = null;
                        else if (llvm.MemoryBuffer.NativeToManagedMap.ContainsKey(__ret))
                            __result0 = (llvm.MemoryBuffer) llvm.MemoryBuffer.NativeToManagedMap[__ret];
                        else llvm.MemoryBuffer.NativeToManagedMap[__ret] = __result0 = (llvm.MemoryBuffer) llvm.MemoryBuffer.__CreateInstance(__ret);
                        return __result0;
                    }
                }

                /// <summary>
                /// <para>Returns the size of the content encapsulated by this
                /// ContentCache.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Returns the size of the content encapsulated by
                /// this</para>
                /// <para>    /// ContentCache.</para>
                /// <para>    ///</para>
                /// <para>    /// This can be the size of the source file or the size of
                /// an</para>
                /// <para>    /// arbitrary scratch buffer.  If the ContentCache
                /// encapsulates a source</para>
                /// <para>    /// file this size is retrieved from the file's
                /// FileEntry.</para>
                /// </remarks>
                public uint getSize()
                {
                    var __ret = Internal.getSize_0(__Instance);
                    return __ret;
                }

                /// <summary>
                /// <para>Returns the number of bytes actually mapped for this
                /// ContentCache.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Returns the number of bytes actually mapped for
                /// this</para>
                /// <para>    /// ContentCache.</para>
                /// <para>    ///</para>
                /// <para>    /// This can be 0 if the MemBuffer was not actually
                /// expanded.</para>
                /// </remarks>
                public uint getSizeBytesMapped()
                {
                    var __ret = Internal.getSizeBytesMapped_0(__Instance);
                    return __ret;
                }

                /// <summary>
                /// <para>Returns the kind of memory used to back the memory buffer for
                /// this content cache. This is used for performance analysis.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// Returns the kind of memory used to back the memory buffer
                /// for</para>
                /// <para>    /// this content cache.  This is used for performance
                /// analysis.</para>
                /// </remarks>
                public llvm.MemoryBuffer.BufferKind getMemoryBufferKind()
                {
                    var __ret = Internal.getMemoryBufferKind_0(__Instance);
                    return __ret;
                }

                /// <summary>
                /// <para>Get the underlying buffer, returning NULL if the buffer is not
                /// yet available.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Get the underlying buffer, returning NULL if the
                /// buffer is not</para>
                /// <para>    /// yet available.</para>
                /// </remarks>
                public llvm.MemoryBuffer getRawBuffer()
                {
                    var __ret = Internal.getRawBuffer_0(__Instance);
                    llvm.MemoryBuffer __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (llvm.MemoryBuffer.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (llvm.MemoryBuffer) llvm.MemoryBuffer.NativeToManagedMap[__ret];
                    else llvm.MemoryBuffer.NativeToManagedMap[__ret] = __result0 = (llvm.MemoryBuffer) llvm.MemoryBuffer.__CreateInstance(__ret);
                    return __result0;
                }

                /// <summary>
                /// <para>Replace the existing buffer (which will be deleted) with the
                /// given buffer.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Replace the existing buffer (which will be
                /// deleted)</para>
                /// <para>    /// with the given buffer.</para>
                /// </remarks>
                public void replaceBuffer(llvm.MemoryBuffer B, bool DoNotFree)
                {
                    var arg0 = ReferenceEquals(B, null) ? global::System.IntPtr.Zero : B.__Instance;
                    Internal.replaceBuffer_0(__Instance, arg0, DoNotFree);
                }

                /// <summary>
                /// <para>Determine whether the buffer itself is invalid.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Determine whether the buffer itself is invalid.</para>
                /// </remarks>
                public bool isBufferInvalid()
                {
                    var __ret = Internal.isBufferInvalid_0(__Instance);
                    return __ret;
                }

                /// <summary>
                /// <para>Determine whether the buffer should be freed.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Determine whether the buffer should be freed.</para>
                /// </remarks>
                public bool shouldFreeBuffer()
                {
                    var __ret = Internal.shouldFreeBuffer_0(__Instance);
                    return __ret;
                }

                public clang.FileEntry OrigEntry
                {
                    get
                    {
                        clang.FileEntry __result0;
                        if (((Internal*) __Instance)->OrigEntry == IntPtr.Zero) __result0 = null;
                        else if (clang.FileEntry.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->OrigEntry))
                            __result0 = (clang.FileEntry) clang.FileEntry.NativeToManagedMap[((Internal*) __Instance)->OrigEntry];
                        else __result0 = clang.FileEntry.__CreateInstance(((Internal*) __Instance)->OrigEntry);
                        return __result0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->OrigEntry = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public clang.FileEntry ContentsEntry
                {
                    get
                    {
                        clang.FileEntry __result0;
                        if (((Internal*) __Instance)->ContentsEntry == IntPtr.Zero) __result0 = null;
                        else if (clang.FileEntry.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->ContentsEntry))
                            __result0 = (clang.FileEntry) clang.FileEntry.NativeToManagedMap[((Internal*) __Instance)->ContentsEntry];
                        else __result0 = clang.FileEntry.__CreateInstance(((Internal*) __Instance)->ContentsEntry);
                        return __result0;
                    }

                    set
                    {
                        ((Internal*) __Instance)->ContentsEntry = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                    }
                }

                public uint* SourceLineCache
                {
                    get
                    {
                        return ((Internal*) __Instance)->SourceLineCache;
                    }

                    set
                    {
                        ((Internal*) __Instance)->SourceLineCache = value;
                    }
                }

                public uint NumLines
                {
                    get
                    {
                        return ((Internal*) __Instance)->NumLines;
                    }

                    set
                    {
                        ((Internal*) __Instance)->NumLines = value;
                    }
                }

                public uint BufferOverridden
                {
                    get
                    {
                        return ((Internal*) __Instance)->BufferOverridden;
                    }

                    set
                    {
                        ((Internal*) __Instance)->BufferOverridden = value;
                    }
                }

                public uint IsSystemFile
                {
                    get
                    {
                        return ((Internal*) __Instance)->IsSystemFile;
                    }

                    set
                    {
                        ((Internal*) __Instance)->IsSystemFile = value;
                    }
                }
            }

            /// <summary>
            /// <para>Information about a FileID, basically just the logical file that
            /// it represents and include stack information.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Information about a FileID, basically just the logical
            /// file</para>
            /// <para>  /// that it represents and include stack information.</para>
            /// <para>  ///</para>
            /// <para>  /// Each FileInfo has include stack information, indicating
            /// where it came</para>
            /// <para>  /// from. This information encodes the \#include chain that a
            /// token was</para>
            /// <para>  /// expanded from. The main include file has an invalid
            /// IncludeLoc.</para>
            /// <para>  ///</para>
            /// <para>  /// FileInfos contain a &quot;ContentCache *&quot;, with the
            /// contents of the file.</para>
            /// <para>  ///</para>
            /// </remarks>
            public unsafe partial class FileInfo : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 16)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public uint IncludeLoc;

                    [FieldOffset(4)]
                    public uint NumCreatedFIDs;

                    [FieldOffset(8)]
                    public ulong Data;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang6SrcMgr8FileInfoC2ERKS1_")]
                    internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang6SrcMgr8FileInfo3getENS_14SourceLocationEPKNS0_12ContentCacheENS0_18CharacteristicKindE")]
                    internal static extern clang.SrcMgr.FileInfo.Internal get_0(clang.SourceLocation.Internal IL, global::System.IntPtr Con, clang.SrcMgr.CharacteristicKind FileCharacter);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang6SrcMgr8FileInfo13getIncludeLocEv")]
                    internal static extern clang.SourceLocation.Internal getIncludeLoc_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang6SrcMgr8FileInfo15getContentCacheEv")]
                    internal static extern global::System.IntPtr getContentCache_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang6SrcMgr8FileInfo21getFileCharacteristicEv")]
                    internal static extern clang.SrcMgr.CharacteristicKind getFileCharacteristic_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang6SrcMgr8FileInfo17hasLineDirectivesEv")]
                    [return: MarshalAsAttribute(UnmanagedType.I1)]
                    internal static extern bool hasLineDirectives_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang6SrcMgr8FileInfo20setHasLineDirectivesEv")]
                    internal static extern void setHasLineDirectives_0(global::System.IntPtr instance);
                }

                public global::System.IntPtr __Instance { get; protected set; }
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, FileInfo> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, FileInfo>();

                private readonly bool __ownsNativeInstance;

                public static FileInfo __CreateInstance(global::System.IntPtr native)
                {
                    return new FileInfo((FileInfo.Internal*) native);
                }

                public static FileInfo __CreateInstance(FileInfo.Internal native)
                {
                    return new FileInfo(native);
                }

                private static FileInfo.Internal* __CopyValue(FileInfo.Internal native)
                {
                    var ret = (FileInfo.Internal*) Marshal.AllocHGlobal(16);
                    *ret = native;
                    return ret;
                }

                private FileInfo(FileInfo.Internal native)
                    : this(__CopyValue(native))
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected FileInfo(FileInfo.Internal* native, bool isInternalImpl = false)
                {
                    __Instance = new global::System.IntPtr(native);
                }

                public FileInfo()
                {
                    __Instance = Marshal.AllocHGlobal(16);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    DestroyNativeInstance(false);
                }

                public virtual void DestroyNativeInstance()
                {
                    DestroyNativeInstance(true);
                }

                private void DestroyNativeInstance(bool force)
                {
                    clang.SrcMgr.FileInfo __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public clang.SourceLocation getIncludeLoc()
                {
                    var __ret = Internal.getIncludeLoc_0(__Instance);
                    return clang.SourceLocation.__CreateInstance(__ret);
                }

                public clang.SrcMgr.ContentCache getContentCache()
                {
                    var __ret = Internal.getContentCache_0(__Instance);
                    clang.SrcMgr.ContentCache __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (clang.SrcMgr.ContentCache.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (clang.SrcMgr.ContentCache) clang.SrcMgr.ContentCache.NativeToManagedMap[__ret];
                    else __result0 = clang.SrcMgr.ContentCache.__CreateInstance(__ret);
                    return __result0;
                }

                /// <summary>
                /// <para>Return whether this is a system header or not.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Return whether this is a system header or not.</para>
                /// </remarks>
                public clang.SrcMgr.CharacteristicKind getFileCharacteristic()
                {
                    var __ret = Internal.getFileCharacteristic_0(__Instance);
                    return __ret;
                }

                /// <summary>
                /// <para>Return true if this FileID has #line directives in it.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Return true if this FileID has \#line directives in
                /// it.</para>
                /// </remarks>
                public bool hasLineDirectives()
                {
                    var __ret = Internal.hasLineDirectives_0(__Instance);
                    return __ret;
                }

                /// <summary>
                /// <para>Set the flag that indicates that this FileID has line table
                /// entries associated with it.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Set the flag that indicates that this FileID
                /// has</para>
                /// <para>    /// line table entries associated with it.</para>
                /// </remarks>
                public void setHasLineDirectives()
                {
                    Internal.setHasLineDirectives_0(__Instance);
                }

                /// <summary>
                /// <para>Return a FileInfo object.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Return a FileInfo object.</para>
                /// </remarks>
                public static clang.SrcMgr.FileInfo get(clang.SourceLocation IL, clang.SrcMgr.ContentCache Con, clang.SrcMgr.CharacteristicKind FileCharacter)
                {
                    var arg0 = ReferenceEquals(IL, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (IL.__Instance);
                    var arg1 = ReferenceEquals(Con, null) ? global::System.IntPtr.Zero : Con.__Instance;
                    var arg2 = FileCharacter;
                    var __ret = Internal.get_0(arg0, arg1, arg2);
                    return clang.SrcMgr.FileInfo.__CreateInstance(__ret);
                }
            }

            /// <summary>
            /// <para>Each ExpansionInfo encodes the expansion location - where the
            /// token was ultimately expanded, and the SpellingLoc - where the actual
            /// character data for the token came from.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Each ExpansionInfo encodes the expansion location -
            /// where</para>
            /// <para>  /// the token was ultimately expanded, and the SpellingLoc -
            /// where the actual</para>
            /// <para>  /// character data for the token came from.</para>
            /// </remarks>
            public unsafe partial class ExpansionInfo : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 12)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public uint SpellingLoc;

                    [FieldOffset(4)]
                    public uint ExpansionLocStart;

                    [FieldOffset(8)]
                    public uint ExpansionLocEnd;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang6SrcMgr13ExpansionInfoC2ERKS1_")]
                    internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang6SrcMgr13ExpansionInfo14getSpellingLocEv")]
                    internal static extern clang.SourceLocation.Internal getSpellingLoc_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang6SrcMgr13ExpansionInfo20getExpansionLocStartEv")]
                    internal static extern clang.SourceLocation.Internal getExpansionLocStart_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang6SrcMgr13ExpansionInfo18getExpansionLocEndEv")]
                    internal static extern clang.SourceLocation.Internal getExpansionLocEnd_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang6SrcMgr13ExpansionInfo19isMacroArgExpansionEv")]
                    [return: MarshalAsAttribute(UnmanagedType.I1)]
                    internal static extern bool isMacroArgExpansion_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang6SrcMgr13ExpansionInfo20isMacroBodyExpansionEv")]
                    [return: MarshalAsAttribute(UnmanagedType.I1)]
                    internal static extern bool isMacroBodyExpansion_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang6SrcMgr13ExpansionInfo24isFunctionMacroExpansionEv")]
                    [return: MarshalAsAttribute(UnmanagedType.I1)]
                    internal static extern bool isFunctionMacroExpansion_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang6SrcMgr13ExpansionInfo6createENS_14SourceLocationES2_S2_")]
                    internal static extern clang.SrcMgr.ExpansionInfo.Internal create_0(clang.SourceLocation.Internal SpellingLoc, clang.SourceLocation.Internal Start, clang.SourceLocation.Internal End);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang6SrcMgr13ExpansionInfo17createForMacroArgENS_14SourceLocationES2_")]
                    internal static extern clang.SrcMgr.ExpansionInfo.Internal createForMacroArg_0(clang.SourceLocation.Internal SpellingLoc, clang.SourceLocation.Internal ExpansionLoc);
                }

                public global::System.IntPtr __Instance { get; protected set; }
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ExpansionInfo> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ExpansionInfo>();

                private readonly bool __ownsNativeInstance;

                public static ExpansionInfo __CreateInstance(global::System.IntPtr native)
                {
                    return new ExpansionInfo((ExpansionInfo.Internal*) native);
                }

                public static ExpansionInfo __CreateInstance(ExpansionInfo.Internal native)
                {
                    return new ExpansionInfo(native);
                }

                private static ExpansionInfo.Internal* __CopyValue(ExpansionInfo.Internal native)
                {
                    var ret = (ExpansionInfo.Internal*) Marshal.AllocHGlobal(12);
                    *ret = native;
                    return ret;
                }

                private ExpansionInfo(ExpansionInfo.Internal native)
                    : this(__CopyValue(native))
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected ExpansionInfo(ExpansionInfo.Internal* native, bool isInternalImpl = false)
                {
                    __Instance = new global::System.IntPtr(native);
                }

                public ExpansionInfo()
                {
                    __Instance = Marshal.AllocHGlobal(12);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    DestroyNativeInstance(false);
                }

                public virtual void DestroyNativeInstance()
                {
                    DestroyNativeInstance(true);
                }

                private void DestroyNativeInstance(bool force)
                {
                    clang.SrcMgr.ExpansionInfo __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public clang.SourceLocation getSpellingLoc()
                {
                    var __ret = Internal.getSpellingLoc_0(__Instance);
                    return clang.SourceLocation.__CreateInstance(__ret);
                }

                public clang.SourceLocation getExpansionLocStart()
                {
                    var __ret = Internal.getExpansionLocStart_0(__Instance);
                    return clang.SourceLocation.__CreateInstance(__ret);
                }

                public clang.SourceLocation getExpansionLocEnd()
                {
                    var __ret = Internal.getExpansionLocEnd_0(__Instance);
                    return clang.SourceLocation.__CreateInstance(__ret);
                }

                public bool isMacroArgExpansion()
                {
                    var __ret = Internal.isMacroArgExpansion_0(__Instance);
                    return __ret;
                }

                public bool isMacroBodyExpansion()
                {
                    var __ret = Internal.isMacroBodyExpansion_0(__Instance);
                    return __ret;
                }

                public bool isFunctionMacroExpansion()
                {
                    var __ret = Internal.isFunctionMacroExpansion_0(__Instance);
                    return __ret;
                }

                /// <summary>
                /// <para>Return a ExpansionInfo for an expansion.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Return a ExpansionInfo for an expansion.</para>
                /// <para>    ///</para>
                /// <para>    /// Start and End specify the expansion range (where the
                /// macro is</para>
                /// <para>    /// expanded), and SpellingLoc specifies the spelling
                /// location (where</para>
                /// <para>    /// the characters from the token come from). All three can
                /// refer to</para>
                /// <para>    /// normal File SLocs or expansion locations.</para>
                /// </remarks>
                public static clang.SrcMgr.ExpansionInfo create(clang.SourceLocation SpellingLoc, clang.SourceLocation Start, clang.SourceLocation End)
                {
                    var arg0 = ReferenceEquals(SpellingLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (SpellingLoc.__Instance);
                    var arg1 = ReferenceEquals(Start, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Start.__Instance);
                    var arg2 = ReferenceEquals(End, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (End.__Instance);
                    var __ret = Internal.create_0(arg0, arg1, arg2);
                    return clang.SrcMgr.ExpansionInfo.__CreateInstance(__ret);
                }

                /// <summary>
                /// <para>Return a special ExpansionInfo for the expansion of a macro
                /// argument into a function-like macro's body.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// \brief Return a special ExpansionInfo for the expansion
                /// of</para>
                /// <para>    /// a macro argument into a function-like macro's
                /// body.</para>
                /// <para>    ///</para>
                /// <para>    /// ExpansionLoc specifies the expansion location (where the
                /// macro is</para>
                /// <para>    /// expanded). This doesn't need to be a range because a
                /// macro is always</para>
                /// <para>    /// expanded at a macro parameter reference, and macro
                /// parameters are</para>
                /// <para>    /// always exactly one token. SpellingLoc specifies the
                /// spelling location</para>
                /// <para>    /// (where the characters from the token come from).
                /// ExpansionLoc and</para>
                /// <para>    /// SpellingLoc can both refer to normal File SLocs or
                /// expansion locations.</para>
                /// <para>    ///</para>
                /// <para>    /// Given the code:</para>
                /// <para>    /// \code</para>
                /// <para>    ///   #define F(x) f(x)</para>
                /// <para>    ///   F(42);</para>
                /// <para>    /// \endcode</para>
                /// <para>    ///</para>
                /// <para>    /// When expanding '\c F(42)', the '\c x' would call this
                /// with an</para>
                /// <para>    /// SpellingLoc pointing at '\c 42' and an ExpansionLoc
                /// pointing at its</para>
                /// <para>    /// location in the definition of '\c F'.</para>
                /// </remarks>
                public static clang.SrcMgr.ExpansionInfo createForMacroArg(clang.SourceLocation SpellingLoc, clang.SourceLocation ExpansionLoc)
                {
                    var arg0 = ReferenceEquals(SpellingLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (SpellingLoc.__Instance);
                    var arg1 = ReferenceEquals(ExpansionLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (ExpansionLoc.__Instance);
                    var __ret = Internal.createForMacroArg_0(arg0, arg1);
                    return clang.SrcMgr.ExpansionInfo.__CreateInstance(__ret);
                }
            }

            /// <summary>
            /// <para>This is a discriminated union of FileInfo and
            /// ExpansionInfo.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief This is a discriminated union of FileInfo and
            /// ExpansionInfo.</para>
            /// <para>  ///</para>
            /// <para>  /// SourceManager keeps an array of these objects, and they are
            /// uniquely</para>
            /// <para>  /// identified by the FileID datatype.</para>
            /// </remarks>
            public unsafe partial class SLocEntry : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 24)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public uint Offset;

                    [FieldOffset(8)]
                    internal clang.SrcMgr.SLocEntry._.Internal _0;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang6SrcMgr9SLocEntryC2ERKS1_")]
                    internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang6SrcMgr9SLocEntry9getOffsetEv")]
                    internal static extern uint getOffset_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang6SrcMgr9SLocEntry11isExpansionEv")]
                    [return: MarshalAsAttribute(UnmanagedType.I1)]
                    internal static extern bool isExpansion_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang6SrcMgr9SLocEntry6isFileEv")]
                    [return: MarshalAsAttribute(UnmanagedType.I1)]
                    internal static extern bool isFile_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang6SrcMgr9SLocEntry7getFileEv")]
                    internal static extern global::System.IntPtr getFile_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang6SrcMgr9SLocEntry12getExpansionEv")]
                    internal static extern global::System.IntPtr getExpansion_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang6SrcMgr9SLocEntry3getEjRKNS0_8FileInfoE")]
                    internal static extern void get_0(global::System.IntPtr @return, uint Offset, global::System.IntPtr FI);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang6SrcMgr9SLocEntry3getEjRKNS0_13ExpansionInfoE")]
                    internal static extern void get_1(global::System.IntPtr @return, uint Offset, global::System.IntPtr Expansion);
                }

                internal unsafe partial struct _
                {
                    [StructLayout(LayoutKind.Explicit, Size = 16)]
                    public partial struct Internal
                    {
                        [FieldOffset(0)]
                        public clang.SrcMgr.FileInfo.Internal File;

                        [FieldOffset(0)]
                        public clang.SrcMgr.ExpansionInfo.Internal Expansion;
                    }
                }

                public global::System.IntPtr __Instance { get; protected set; }
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, SLocEntry> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, SLocEntry>();

                private readonly bool __ownsNativeInstance;

                public static SLocEntry __CreateInstance(global::System.IntPtr native)
                {
                    return new SLocEntry((SLocEntry.Internal*) native);
                }

                public static SLocEntry __CreateInstance(SLocEntry.Internal native)
                {
                    return new SLocEntry(native);
                }

                private static SLocEntry.Internal* __CopyValue(SLocEntry.Internal native)
                {
                    var ret = (SLocEntry.Internal*) Marshal.AllocHGlobal(24);
                    *ret = native;
                    return ret;
                }

                private SLocEntry(SLocEntry.Internal native)
                    : this(__CopyValue(native))
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected SLocEntry(SLocEntry.Internal* native, bool isInternalImpl = false)
                {
                    __Instance = new global::System.IntPtr(native);
                }

                public SLocEntry()
                {
                    __Instance = Marshal.AllocHGlobal(24);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    DestroyNativeInstance(false);
                }

                public virtual void DestroyNativeInstance()
                {
                    DestroyNativeInstance(true);
                }

                private void DestroyNativeInstance(bool force)
                {
                    clang.SrcMgr.SLocEntry __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                public uint getOffset()
                {
                    var __ret = Internal.getOffset_0(__Instance);
                    return __ret;
                }

                public bool isExpansion()
                {
                    var __ret = Internal.isExpansion_0(__Instance);
                    return __ret;
                }

                public bool isFile()
                {
                    var __ret = Internal.isFile_0(__Instance);
                    return __ret;
                }

                public clang.SrcMgr.FileInfo getFile()
                {
                    var __ret = Internal.getFile_0(__Instance);
                    clang.SrcMgr.FileInfo __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (clang.SrcMgr.FileInfo.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (clang.SrcMgr.FileInfo) clang.SrcMgr.FileInfo.NativeToManagedMap[__ret];
                    else __result0 = clang.SrcMgr.FileInfo.__CreateInstance(__ret);
                    return __result0;
                }

                public clang.SrcMgr.ExpansionInfo getExpansion()
                {
                    var __ret = Internal.getExpansion_0(__Instance);
                    clang.SrcMgr.ExpansionInfo __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (clang.SrcMgr.ExpansionInfo.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (clang.SrcMgr.ExpansionInfo) clang.SrcMgr.ExpansionInfo.NativeToManagedMap[__ret];
                    else __result0 = clang.SrcMgr.ExpansionInfo.__CreateInstance(__ret);
                    return __result0;
                }

                public static clang.SrcMgr.SLocEntry get(uint Offset, clang.SrcMgr.FileInfo FI)
                {
                    var arg1 = ReferenceEquals(FI, null) ? global::System.IntPtr.Zero : FI.__Instance;
                    var __ret = new clang.SrcMgr.SLocEntry.Internal();
                    Internal.get_0(new IntPtr(&__ret), Offset, arg1);
                    return clang.SrcMgr.SLocEntry.__CreateInstance(__ret);
                }

                public static clang.SrcMgr.SLocEntry get(uint Offset, clang.SrcMgr.ExpansionInfo Expansion)
                {
                    var arg1 = ReferenceEquals(Expansion, null) ? global::System.IntPtr.Zero : Expansion.__Instance;
                    var __ret = new clang.SrcMgr.SLocEntry.Internal();
                    Internal.get_1(new IntPtr(&__ret), Offset, arg1);
                    return clang.SrcMgr.SLocEntry.__CreateInstance(__ret);
                }
            }
        }
    }
}
