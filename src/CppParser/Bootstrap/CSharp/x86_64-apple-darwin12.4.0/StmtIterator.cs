//----------------------------------------------------------------------------
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
//----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace CppSharp
{
    public unsafe partial class StmtIterator
    {
        public partial struct Internal
        {
        }
    }

    namespace clang
    {
        public unsafe partial class StmtIteratorImpl
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr stmt;

                [FieldOffset(8)]
                public global::System.IntPtr DGI;

                [FieldOffset(16)]
                public ulong RawVAPtr;

                [FieldOffset(24)]
                public global::System.IntPtr DGE;
            }
        }

        public unsafe partial class StmtIteratorBase : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 32)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr stmt;

                [FieldOffset(8)]
                public global::System.IntPtr DGI;

                [FieldOffset(16)]
                public ulong RawVAPtr;

                [FieldOffset(24)]
                public global::System.IntPtr DGE;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16StmtIteratorBaseC2EPPNS_4StmtE")]
                internal static extern void ctor_0(global::System.IntPtr instance, global::System.IntPtr s);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16StmtIteratorBaseC2EPKNS_17VariableArrayTypeE")]
                internal static extern void ctor_1(global::System.IntPtr instance, global::System.IntPtr t);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16StmtIteratorBaseC2EPPNS_4DeclES3_")]
                internal static extern void ctor_2(global::System.IntPtr instance, global::System.IntPtr dgi, global::System.IntPtr dge);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16StmtIteratorBaseC2Ev")]
                internal static extern void ctor_3(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16StmtIteratorBaseC2ERKS0_")]
                internal static extern void cctor_4(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang16StmtIteratorBase11inDeclGroupEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool inDeclGroup_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang16StmtIteratorBase14inSizeOfTypeVAEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool inSizeOfTypeVA_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang16StmtIteratorBase6inStmtEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool inStmt_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang16StmtIteratorBase8getVAPtrEv")]
                internal static extern global::System.IntPtr getVAPtr_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16StmtIteratorBase8setVAPtrEPKNS_17VariableArrayTypeE")]
                internal static extern void setVAPtr_0(global::System.IntPtr instance, global::System.IntPtr P);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16StmtIteratorBase8NextDeclEb")]
                internal static extern void NextDecl_0(global::System.IntPtr instance, bool ImmediateAdvance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16StmtIteratorBase10HandleDeclEPNS_4DeclE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool HandleDecl_0(global::System.IntPtr instance, global::System.IntPtr D);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16StmtIteratorBase6NextVAEv")]
                internal static extern void NextVA_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang16StmtIteratorBase11GetDeclExprEv")]
                internal static extern global::System.IntPtr GetDeclExpr_0(global::System.IntPtr instance);
            }

            public enum _0 : uint
            {
                StmtMode = 0x0,
                SizeOfTypeVAMode = 0x1,
                DeclGroupMode = 0x2,
                Flags = 0x3
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, StmtIteratorBase> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, StmtIteratorBase>();

            private readonly bool __ownsNativeInstance;

            public static StmtIteratorBase __CreateInstance(global::System.IntPtr native)
            {
                return new StmtIteratorBase((StmtIteratorBase.Internal*) native);
            }

            public static StmtIteratorBase __CreateInstance(StmtIteratorBase.Internal native)
            {
                return new StmtIteratorBase(native);
            }

            private static StmtIteratorBase.Internal* __CopyValue(StmtIteratorBase.Internal native)
            {
                var ret = (StmtIteratorBase.Internal*) Marshal.AllocHGlobal(32);
                *ret = native;
                return ret;
            }

            private StmtIteratorBase(StmtIteratorBase.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected StmtIteratorBase(StmtIteratorBase.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            protected StmtIteratorBase(clang.Stmt s)
            {
                __Instance = Marshal.AllocHGlobal(32);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(s, null) ? global::System.IntPtr.Zero : s.__Instance;
                Internal.ctor_0(__Instance, arg0);
            }

            protected StmtIteratorBase(clang.VariableArrayType t)
            {
                __Instance = Marshal.AllocHGlobal(32);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(t, null) ? global::System.IntPtr.Zero : t.__Instance;
                Internal.ctor_1(__Instance, arg0);
            }

            protected StmtIteratorBase(clang.Decl dgi, clang.Decl dge)
            {
                __Instance = Marshal.AllocHGlobal(32);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(dgi, null) ? global::System.IntPtr.Zero : dgi.__Instance;
                var arg1 = ReferenceEquals(dge, null) ? global::System.IntPtr.Zero : dge.__Instance;
                Internal.ctor_2(__Instance, arg0, arg1);
            }

            protected StmtIteratorBase()
            {
                __Instance = Marshal.AllocHGlobal(32);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_3(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.StmtIteratorBase __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            protected bool inDeclGroup()
            {
                var __ret = Internal.inDeclGroup_0(__Instance);
                return __ret;
            }

            protected bool inSizeOfTypeVA()
            {
                var __ret = Internal.inSizeOfTypeVA_0(__Instance);
                return __ret;
            }

            protected bool inStmt()
            {
                var __ret = Internal.inStmt_0(__Instance);
                return __ret;
            }

            protected clang.VariableArrayType getVAPtr()
            {
                var __ret = Internal.getVAPtr_0(__Instance);
                clang.VariableArrayType __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.VariableArrayType.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.VariableArrayType) clang.VariableArrayType.NativeToManagedMap[__ret];
                else __result0 = clang.VariableArrayType.__CreateInstance(__ret);
                return __result0;
            }

            protected void setVAPtr(clang.VariableArrayType P)
            {
                var arg0 = ReferenceEquals(P, null) ? global::System.IntPtr.Zero : P.__Instance;
                Internal.setVAPtr_0(__Instance, arg0);
            }

            protected void NextDecl(bool ImmediateAdvance)
            {
                Internal.NextDecl_0(__Instance, ImmediateAdvance);
            }

            protected bool HandleDecl(clang.Decl D)
            {
                var arg0 = ReferenceEquals(D, null) ? global::System.IntPtr.Zero : D.__Instance;
                var __ret = Internal.HandleDecl_0(__Instance, arg0);
                return __ret;
            }

            protected void NextVA()
            {
                Internal.NextVA_0(__Instance);
            }

            protected clang.Stmt GetDeclExpr()
            {
                var __ret = Internal.GetDeclExpr_0(__Instance);
                clang.Stmt __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Stmt.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Stmt) clang.Stmt.NativeToManagedMap[__ret];
                else __result0 = clang.Stmt.__CreateInstance(__ret);
                return __result0;
            }

            protected clang.Stmt stmt
            {
                get
                {
                    clang.Stmt __result0;
                    if (((Internal*) __Instance)->stmt == IntPtr.Zero) __result0 = null;
                    else if (clang.Stmt.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->stmt))
                        __result0 = (clang.Stmt) clang.Stmt.NativeToManagedMap[((Internal*) __Instance)->stmt];
                    else __result0 = clang.Stmt.__CreateInstance(((Internal*) __Instance)->stmt);
                    return __result0;
                }

                set
                {
                    ((Internal*) __Instance)->stmt = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                }
            }

            protected clang.Decl DGI
            {
                get
                {
                    clang.Decl __result0;
                    if (((Internal*) __Instance)->DGI == IntPtr.Zero) __result0 = null;
                    else if (clang.Decl.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->DGI))
                        __result0 = (clang.Decl) clang.Decl.NativeToManagedMap[((Internal*) __Instance)->DGI];
                    else clang.Decl.NativeToManagedMap[((Internal*) __Instance)->DGI] = __result0 = (clang.Decl) clang.Decl.__CreateInstance(((Internal*) __Instance)->DGI);
                    return __result0;
                }

                set
                {
                    ((Internal*) __Instance)->DGI = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                }
            }

            protected ulong RawVAPtr
            {
                get
                {
                    return ((Internal*) __Instance)->RawVAPtr;
                }

                set
                {
                    ((Internal*) __Instance)->RawVAPtr = value;
                }
            }

            protected clang.Decl DGE
            {
                get
                {
                    clang.Decl __result0;
                    if (((Internal*) __Instance)->DGE == IntPtr.Zero) __result0 = null;
                    else if (clang.Decl.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->DGE))
                        __result0 = (clang.Decl) clang.Decl.NativeToManagedMap[((Internal*) __Instance)->DGE];
                    else clang.Decl.NativeToManagedMap[((Internal*) __Instance)->DGE] = __result0 = (clang.Decl) clang.Decl.__CreateInstance(((Internal*) __Instance)->DGE);
                    return __result0;
                }

                set
                {
                    ((Internal*) __Instance)->DGE = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                }
            }
        }

        public unsafe partial class StmtIterator : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12StmtIteratorC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12StmtIteratorC2EPPNS_4StmtE")]
                internal static extern void ctor_1(global::System.IntPtr instance, global::System.IntPtr S);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12StmtIteratorC2EPPNS_4DeclES3_")]
                internal static extern void ctor_2(global::System.IntPtr instance, global::System.IntPtr dgi, global::System.IntPtr dge);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12StmtIteratorC2EPKNS_17VariableArrayTypeE")]
                internal static extern void ctor_3(global::System.IntPtr instance, global::System.IntPtr t);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12StmtIteratorC2ERKS0_")]
                internal static extern void cctor_4(global::System.IntPtr instance, global::System.IntPtr _0);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, StmtIterator> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, StmtIterator>();

            private readonly bool __ownsNativeInstance;

            public static StmtIterator __CreateInstance(global::System.IntPtr native)
            {
                return new StmtIterator((StmtIterator.Internal*) native);
            }

            public static StmtIterator __CreateInstance(StmtIterator.Internal native)
            {
                return new StmtIterator(native);
            }

            private static StmtIterator.Internal* __CopyValue(StmtIterator.Internal native)
            {
                var ret = (StmtIterator.Internal*) Marshal.AllocHGlobal(0);
                *ret = native;
                return ret;
            }

            private StmtIterator(StmtIterator.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected StmtIterator(StmtIterator.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public StmtIterator()
            {
                __Instance = Marshal.AllocHGlobal(0);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public StmtIterator(clang.Stmt S)
            {
                __Instance = Marshal.AllocHGlobal(0);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(S, null) ? global::System.IntPtr.Zero : S.__Instance;
                Internal.ctor_1(__Instance, arg0);
            }

            public StmtIterator(clang.Decl dgi, clang.Decl dge)
            {
                __Instance = Marshal.AllocHGlobal(0);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(dgi, null) ? global::System.IntPtr.Zero : dgi.__Instance;
                var arg1 = ReferenceEquals(dge, null) ? global::System.IntPtr.Zero : dge.__Instance;
                Internal.ctor_2(__Instance, arg0, arg1);
            }

            public StmtIterator(clang.VariableArrayType t)
            {
                __Instance = Marshal.AllocHGlobal(0);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(t, null) ? global::System.IntPtr.Zero : t.__Instance;
                Internal.ctor_3(__Instance, arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.StmtIterator __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }
        }

        public unsafe partial class ConstStmtIterator : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17ConstStmtIteratorC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17ConstStmtIteratorC2ERKNS_12StmtIteratorE")]
                internal static extern void ctor_1(global::System.IntPtr instance, global::System.IntPtr RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17ConstStmtIteratorC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ConstStmtIterator> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ConstStmtIterator>();

            private readonly bool __ownsNativeInstance;

            public static ConstStmtIterator __CreateInstance(global::System.IntPtr native)
            {
                return new ConstStmtIterator((ConstStmtIterator.Internal*) native);
            }

            public static ConstStmtIterator __CreateInstance(ConstStmtIterator.Internal native)
            {
                return new ConstStmtIterator(native);
            }

            private static ConstStmtIterator.Internal* __CopyValue(ConstStmtIterator.Internal native)
            {
                var ret = (ConstStmtIterator.Internal*) Marshal.AllocHGlobal(0);
                *ret = native;
                return ret;
            }

            private ConstStmtIterator(ConstStmtIterator.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected ConstStmtIterator(ConstStmtIterator.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public ConstStmtIterator()
            {
                __Instance = Marshal.AllocHGlobal(0);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public ConstStmtIterator(clang.StmtIterator RHS)
            {
                __Instance = Marshal.AllocHGlobal(0);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(RHS, null) ? global::System.IntPtr.Zero : RHS.__Instance;
                Internal.ctor_1(__Instance, arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.ConstStmtIterator __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }
        }

        /// <summary>
        /// <para>A range of statement iterators.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// A range of statement iterators.</para>
        /// <para>///</para>
        /// <para>/// This class provides some extra functionality beyond
        /// std::pair</para>
        /// <para>/// in order to allow the following idiom:</para>
        /// <para>///   for (StmtRange range = stmt-&gt;children(); range;
        /// ++range)</para>
        /// </remarks>
        public unsafe partial class StmtRange : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9StmtRangeC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9StmtRangeC2ERKNS_12StmtIteratorES3_")]
                internal static extern void ctor_1(global::System.IntPtr instance, global::System.IntPtr begin, global::System.IntPtr end);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9StmtRangeC2ERKS0_")]
                internal static extern void cctor_3(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9StmtRange5emptyEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool empty_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9StmtRangecvbEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorConversion_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9StmtRangeppEv")]
                internal static extern global::System.IntPtr OperatorPlusPlus_0(global::System.IntPtr instance);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, StmtRange> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, StmtRange>();

            private readonly bool __ownsNativeInstance;

            public static StmtRange __CreateInstance(global::System.IntPtr native)
            {
                return new StmtRange((StmtRange.Internal*) native);
            }

            public static StmtRange __CreateInstance(StmtRange.Internal native)
            {
                return new StmtRange(native);
            }

            private static StmtRange.Internal* __CopyValue(StmtRange.Internal native)
            {
                var ret = (StmtRange.Internal*) Marshal.AllocHGlobal(0);
                *ret = native;
                return ret;
            }

            private StmtRange(StmtRange.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected StmtRange(StmtRange.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public StmtRange()
            {
                __Instance = Marshal.AllocHGlobal(0);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public StmtRange(clang.StmtIterator begin, clang.StmtIterator end)
            {
                __Instance = Marshal.AllocHGlobal(0);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(begin, null) ? global::System.IntPtr.Zero : begin.__Instance;
                var arg1 = ReferenceEquals(end, null) ? global::System.IntPtr.Zero : end.__Instance;
                Internal.ctor_1(__Instance, arg0, arg1);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.StmtRange __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public bool empty()
            {
                var __ret = Internal.empty_0(__Instance);
                return __ret;
            }

            public static implicit operator bool(clang.StmtRange __op)
            {
                var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
                var __ret = Internal.OperatorConversion_0(arg0);
                return __ret;
            }

            public static clang.StmtRange operator ++(clang.StmtRange __op)
            {
                var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
                var __ret = Internal.OperatorPlusPlus_0(arg0);
                clang.StmtRange __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.StmtRange.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.StmtRange) clang.StmtRange.NativeToManagedMap[__ret];
                else __result0 = clang.StmtRange.__CreateInstance(__ret);
                return __result0;
            }
        }

        /// <summary>
        /// <para>A range of const statement iterators.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// A range of const statement iterators.</para>
        /// <para>///</para>
        /// <para>/// This class provides some extra functionality beyond
        /// std::pair</para>
        /// <para>/// in order to allow the following idiom:</para>
        /// <para>///   for (ConstStmtRange range = stmt-&gt;children(); range;
        /// ++range)</para>
        /// </remarks>
        public unsafe partial class ConstStmtRange : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 0)]
            public partial struct Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14ConstStmtRangeC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14ConstStmtRangeC2ERKNS_17ConstStmtIteratorES3_")]
                internal static extern void ctor_1(global::System.IntPtr instance, global::System.IntPtr begin, global::System.IntPtr end);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14ConstStmtRangeC2ERKNS_9StmtRangeE")]
                internal static extern void ctor_2(global::System.IntPtr instance, global::System.IntPtr range);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14ConstStmtRangeC2ERKNS_12StmtIteratorES3_")]
                internal static extern void ctor_3(global::System.IntPtr instance, global::System.IntPtr begin, global::System.IntPtr end);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14ConstStmtRangeC2ERKS0_")]
                internal static extern void cctor_5(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14ConstStmtRange5emptyEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool empty_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14ConstStmtRangecvbEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorConversion_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14ConstStmtRangeppEv")]
                internal static extern global::System.IntPtr OperatorPlusPlus_0(global::System.IntPtr instance);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ConstStmtRange> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ConstStmtRange>();

            private readonly bool __ownsNativeInstance;

            public static ConstStmtRange __CreateInstance(global::System.IntPtr native)
            {
                return new ConstStmtRange((ConstStmtRange.Internal*) native);
            }

            public static ConstStmtRange __CreateInstance(ConstStmtRange.Internal native)
            {
                return new ConstStmtRange(native);
            }

            private static ConstStmtRange.Internal* __CopyValue(ConstStmtRange.Internal native)
            {
                var ret = (ConstStmtRange.Internal*) Marshal.AllocHGlobal(0);
                *ret = native;
                return ret;
            }

            private ConstStmtRange(ConstStmtRange.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected ConstStmtRange(ConstStmtRange.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public ConstStmtRange()
            {
                __Instance = Marshal.AllocHGlobal(0);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public ConstStmtRange(clang.ConstStmtIterator begin, clang.ConstStmtIterator end)
            {
                __Instance = Marshal.AllocHGlobal(0);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(begin, null) ? global::System.IntPtr.Zero : begin.__Instance;
                var arg1 = ReferenceEquals(end, null) ? global::System.IntPtr.Zero : end.__Instance;
                Internal.ctor_1(__Instance, arg0, arg1);
            }

            public ConstStmtRange(clang.StmtRange range)
            {
                __Instance = Marshal.AllocHGlobal(0);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(range, null) ? global::System.IntPtr.Zero : range.__Instance;
                Internal.ctor_2(__Instance, arg0);
            }

            public ConstStmtRange(clang.StmtIterator begin, clang.StmtIterator end)
            {
                __Instance = Marshal.AllocHGlobal(0);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(begin, null) ? global::System.IntPtr.Zero : begin.__Instance;
                var arg1 = ReferenceEquals(end, null) ? global::System.IntPtr.Zero : end.__Instance;
                Internal.ctor_3(__Instance, arg0, arg1);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.ConstStmtRange __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public bool empty()
            {
                var __ret = Internal.empty_0(__Instance);
                return __ret;
            }

            public static implicit operator bool(clang.ConstStmtRange __op)
            {
                var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
                var __ret = Internal.OperatorConversion_0(arg0);
                return __ret;
            }

            public static clang.ConstStmtRange operator ++(clang.ConstStmtRange __op)
            {
                var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
                var __ret = Internal.OperatorPlusPlus_0(arg0);
                clang.ConstStmtRange __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.ConstStmtRange.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.ConstStmtRange) clang.ConstStmtRange.NativeToManagedMap[__ret];
                else __result0 = clang.ConstStmtRange.__CreateInstance(__ret);
                return __result0;
            }
        }

        public unsafe partial class StmtIterator
        {
            public partial struct Internal
            {
                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang5beginERKNS_9StmtRangeE")]
                internal static extern global::System.IntPtr begin_0(global::System.IntPtr range);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang3endERKNS_9StmtRangeE")]
                internal static extern global::System.IntPtr end_0(global::System.IntPtr range);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang5beginERKNS_14ConstStmtRangeE")]
                internal static extern global::System.IntPtr begin_1(global::System.IntPtr range);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang3endERKNS_14ConstStmtRangeE")]
                internal static extern global::System.IntPtr end_1(global::System.IntPtr range);
            }

            public static clang.StmtIterator begin(clang.StmtRange range)
            {
                var arg0 = ReferenceEquals(range, null) ? global::System.IntPtr.Zero : range.__Instance;
                var __ret = Internal.begin_0(arg0);
                clang.StmtIterator __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.StmtIterator.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.StmtIterator) clang.StmtIterator.NativeToManagedMap[__ret];
                else __result0 = clang.StmtIterator.__CreateInstance(__ret);
                return __result0;
            }

            public static clang.StmtIterator end(clang.StmtRange range)
            {
                var arg0 = ReferenceEquals(range, null) ? global::System.IntPtr.Zero : range.__Instance;
                var __ret = Internal.end_0(arg0);
                clang.StmtIterator __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.StmtIterator.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.StmtIterator) clang.StmtIterator.NativeToManagedMap[__ret];
                else __result0 = clang.StmtIterator.__CreateInstance(__ret);
                return __result0;
            }

            public static clang.ConstStmtIterator begin(clang.ConstStmtRange range)
            {
                var arg0 = ReferenceEquals(range, null) ? global::System.IntPtr.Zero : range.__Instance;
                var __ret = Internal.begin_1(arg0);
                clang.ConstStmtIterator __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.ConstStmtIterator.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.ConstStmtIterator) clang.ConstStmtIterator.NativeToManagedMap[__ret];
                else __result0 = clang.ConstStmtIterator.__CreateInstance(__ret);
                return __result0;
            }

            public static clang.ConstStmtIterator end(clang.ConstStmtRange range)
            {
                var arg0 = ReferenceEquals(range, null) ? global::System.IntPtr.Zero : range.__Instance;
                var __ret = Internal.end_1(arg0);
                clang.ConstStmtIterator __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.ConstStmtIterator.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.ConstStmtIterator) clang.ConstStmtIterator.NativeToManagedMap[__ret];
                else __result0 = clang.ConstStmtIterator.__CreateInstance(__ret);
                return __result0;
            }
        }
    }
}
