//----------------------------------------------------------------------------
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
//----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace CppSharp
{
    namespace llvm
    {
        /// <summary>
        /// <para>Triple - Helper class for working with autoconf configuration
        /// names. For historical reasons, we also call these 'triples' (they used to
        /// contain exactly three fields).</para>
        /// </summary>
        /// <remarks>
        /// <para>/// Triple - Helper class for working with autoconf configuration
        /// names. For</para>
        /// <para>/// historical reasons, we also call these 'triples' (they used
        /// to contain</para>
        /// <para>/// exactly three fields).</para>
        /// <para>///</para>
        /// <para>/// Configuration names are strings in the canonical form:</para>
        /// <para>///   ARCHITECTURE-VENDOR-OPERATING_SYSTEM</para>
        /// <para>/// or</para>
        /// <para>///   ARCHITECTURE-VENDOR-OPERATING_SYSTEM-ENVIRONMENT</para>
        /// <para>///</para>
        /// <para>/// This class is used for clients which want to support
        /// arbitrary</para>
        /// <para>/// configuration names, but also want to implement certain
        /// special</para>
        /// <para>/// behavior for particular configurations. This class isolates
        /// the mapping</para>
        /// <para>/// from the components of the configuration name to well known
        /// IDs.</para>
        /// <para>///</para>
        /// <para>/// At its core the Triple class is designed to be a wrapper for
        /// a triple</para>
        /// <para>/// string; the constructor does not change or normalize the
        /// triple string.</para>
        /// <para>/// Clients that need to handle the non-canonical triples that
        /// users often</para>
        /// <para>/// specify should use the normalize method.</para>
        /// <para>///</para>
        /// <para>/// See autoconf/config.guess for a glimpse into what
        /// configuration names</para>
        /// <para>/// look like in practice.</para>
        /// </remarks>
        public unsafe partial class Triple : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 48)]
            public partial struct Internal
            {
                [FieldOffset(24)]
                public llvm.Triple.ArchType Arch;

                [FieldOffset(28)]
                public llvm.Triple.SubArchType SubArch;

                [FieldOffset(32)]
                public llvm.Triple.VendorType Vendor;

                [FieldOffset(36)]
                public llvm.Triple.OSType OS;

                [FieldOffset(40)]
                public llvm.Triple.EnvironmentType Environment;

                [FieldOffset(44)]
                public llvm.Triple.ObjectFormatType ObjectFormat;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm6TripleC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm6TripleC2ERKNS_5TwineE")]
                internal static extern void ctor_1(global::System.IntPtr instance, global::System.IntPtr Str);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm6TripleC2ERKNS_5TwineES3_S3_")]
                internal static extern void ctor_2(global::System.IntPtr instance, global::System.IntPtr ArchStr, global::System.IntPtr VendorStr, global::System.IntPtr OSStr);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm6TripleC2ERKNS_5TwineES3_S3_S3_")]
                internal static extern void ctor_3(global::System.IntPtr instance, global::System.IntPtr ArchStr, global::System.IntPtr VendorStr, global::System.IntPtr OSStr, global::System.IntPtr EnvironmentStr);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm6TripleC2ERKS0_")]
                internal static extern void cctor_5(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm6TripleD2Ev")]
                internal static extern void dtor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm6TripleeqERKS0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorEqualEqual_0(global::System.IntPtr instance, global::System.IntPtr Other);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm6Triple7getArchEv")]
                internal static extern llvm.Triple.ArchType getArch_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm6Triple10getSubArchEv")]
                internal static extern llvm.Triple.SubArchType getSubArch_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm6Triple9getVendorEv")]
                internal static extern llvm.Triple.VendorType getVendor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm6Triple5getOSEv")]
                internal static extern llvm.Triple.OSType getOS_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm6Triple14hasEnvironmentEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasEnvironment_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm6Triple14getEnvironmentEv")]
                internal static extern llvm.Triple.EnvironmentType getEnvironment_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm6Triple15getObjectFormatEv")]
                internal static extern llvm.Triple.ObjectFormatType getObjectFormat_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm6Triple12getOSVersionERjS1_S1_")]
                internal static extern void getOSVersion_0(global::System.IntPtr instance, uint* Major, uint* Minor, uint* Micro);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm6Triple17getOSMajorVersionEv")]
                internal static extern uint getOSMajorVersion_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm6Triple16getMacOSXVersionERjS1_S1_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool getMacOSXVersion_0(global::System.IntPtr instance, uint* Major, uint* Minor, uint* Micro);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm6Triple13getiOSVersionERjS1_S1_")]
                internal static extern void getiOSVersion_0(global::System.IntPtr instance, uint* Major, uint* Minor, uint* Micro);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm6Triple11getArchNameEv")]
                internal static extern llvm.StringRef.Internal getArchName_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm6Triple13getVendorNameEv")]
                internal static extern llvm.StringRef.Internal getVendorName_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm6Triple9getOSNameEv")]
                internal static extern llvm.StringRef.Internal getOSName_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm6Triple18getEnvironmentNameEv")]
                internal static extern llvm.StringRef.Internal getEnvironmentName_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm6Triple23getOSAndEnvironmentNameEv")]
                internal static extern llvm.StringRef.Internal getOSAndEnvironmentName_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm6Triple11isArch64BitEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isArch64Bit_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm6Triple11isArch32BitEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isArch32Bit_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm6Triple11isArch16BitEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isArch16Bit_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm6Triple13isOSVersionLTEjjj")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isOSVersionLT_0(global::System.IntPtr instance, uint Major, uint Minor, uint Micro);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm6Triple13isOSVersionLTERKS0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isOSVersionLT_1(global::System.IntPtr instance, global::System.IntPtr Other);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm6Triple17isMacOSXVersionLTEjjj")]
                internal static extern uint isMacOSXVersionLT_0(global::System.IntPtr instance, uint Major, uint Minor, uint Micro);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm6Triple8isMacOSXEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isMacOSX_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm6Triple5isiOSEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isiOS_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm6Triple10isOSDarwinEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isOSDarwin_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm6Triple10isOSNetBSDEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isOSNetBSD_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm6Triple11isOSOpenBSDEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isOSOpenBSD_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm6Triple11isOSFreeBSDEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isOSFreeBSD_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm6Triple13isOSDragonFlyEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isOSDragonFly_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm6Triple11isOSSolarisEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isOSSolaris_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm6Triple10isOSBitrigEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isOSBitrig_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm6Triple24isWindowsMSVCEnvironmentEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isWindowsMSVCEnvironment_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm6Triple29isKnownWindowsMSVCEnvironmentEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isKnownWindowsMSVCEnvironment_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm6Triple27isWindowsItaniumEnvironmentEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isWindowsItaniumEnvironment_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm6Triple26isWindowsCygwinEnvironmentEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isWindowsCygwinEnvironment_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm6Triple23isWindowsGNUEnvironmentEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isWindowsGNUEnvironment_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm6Triple11isOSCygMingEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isOSCygMing_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm6Triple10isOSMSVCRTEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isOSMSVCRT_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm6Triple11isOSWindowsEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isOSWindows_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm6Triple8isOSNaClEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isOSNaCl_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm6Triple9isOSLinuxEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isOSLinux_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm6Triple16isOSBinFormatELFEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isOSBinFormatELF_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm6Triple17isOSBinFormatCOFFEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isOSBinFormatCOFF_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm6Triple18isOSBinFormatMachOEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isOSBinFormatMachO_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm6Triple8isPS4CPUEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isPS4CPU_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm6Triple5isPS4Ev")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isPS4_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm6Triple7setArchENS0_8ArchTypeE")]
                internal static extern void setArch_0(global::System.IntPtr instance, llvm.Triple.ArchType Kind);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm6Triple9setVendorENS0_10VendorTypeE")]
                internal static extern void setVendor_0(global::System.IntPtr instance, llvm.Triple.VendorType Kind);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm6Triple5setOSENS0_6OSTypeE")]
                internal static extern void setOS_0(global::System.IntPtr instance, llvm.Triple.OSType Kind);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm6Triple14setEnvironmentENS0_15EnvironmentTypeE")]
                internal static extern void setEnvironment_0(global::System.IntPtr instance, llvm.Triple.EnvironmentType Kind);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm6Triple15setObjectFormatENS0_16ObjectFormatTypeE")]
                internal static extern void setObjectFormat_0(global::System.IntPtr instance, llvm.Triple.ObjectFormatType Kind);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm6Triple9setTripleERKNS_5TwineE")]
                internal static extern void setTriple_0(global::System.IntPtr instance, global::System.IntPtr Str);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm6Triple11setArchNameENS_9StringRefE")]
                internal static extern void setArchName_0(global::System.IntPtr instance, llvm.StringRef.Internal Str);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm6Triple13setVendorNameENS_9StringRefE")]
                internal static extern void setVendorName_0(global::System.IntPtr instance, llvm.StringRef.Internal Str);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm6Triple9setOSNameENS_9StringRefE")]
                internal static extern void setOSName_0(global::System.IntPtr instance, llvm.StringRef.Internal Str);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm6Triple18setEnvironmentNameENS_9StringRefE")]
                internal static extern void setEnvironmentName_0(global::System.IntPtr instance, llvm.StringRef.Internal Str);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm6Triple23setOSAndEnvironmentNameENS_9StringRefE")]
                internal static extern void setOSAndEnvironmentName_0(global::System.IntPtr instance, llvm.StringRef.Internal Str);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm6Triple19get32BitArchVariantEv")]
                internal static extern void get32BitArchVariant_0(global::System.IntPtr @return, global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm6Triple19get64BitArchVariantEv")]
                internal static extern void get64BitArchVariant_0(global::System.IntPtr @return, global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK4llvm6Triple16getARMCPUForArchENS_9StringRefE")]
                internal static extern global::System.IntPtr getARMCPUForArch_0(global::System.IntPtr instance, llvm.StringRef.Internal Arch);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm6Triple15getArchTypeNameENS0_8ArchTypeE")]
                internal static extern global::System.IntPtr getArchTypeName_0(llvm.Triple.ArchType Kind);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm6Triple17getArchTypePrefixENS0_8ArchTypeE")]
                internal static extern global::System.IntPtr getArchTypePrefix_0(llvm.Triple.ArchType Kind);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm6Triple17getVendorTypeNameENS0_10VendorTypeE")]
                internal static extern global::System.IntPtr getVendorTypeName_0(llvm.Triple.VendorType Kind);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm6Triple13getOSTypeNameENS0_6OSTypeE")]
                internal static extern global::System.IntPtr getOSTypeName_0(llvm.Triple.OSType Kind);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm6Triple22getEnvironmentTypeNameENS0_15EnvironmentTypeE")]
                internal static extern global::System.IntPtr getEnvironmentTypeName_0(llvm.Triple.EnvironmentType Kind);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN4llvm6Triple22getArchTypeForLLVMNameENS_9StringRefE")]
                internal static extern llvm.Triple.ArchType getArchTypeForLLVMName_0(llvm.StringRef.Internal Str);
            }

            public enum ArchType : uint
            {
                UnknownArch = 0,
                arm = 1,
                armeb = 2,
                aarch64 = 3,
                aarch64_be = 4,
                bpf = 5,
                hexagon = 6,
                mips = 7,
                mipsel = 8,
                mips64 = 9,
                mips64el = 10,
                msp430 = 11,
                ppc = 12,
                ppc64 = 13,
                ppc64le = 14,
                r600 = 15,
                amdgcn = 16,
                sparc = 17,
                sparcv9 = 18,
                systemz = 19,
                tce = 20,
                thumb = 21,
                thumbeb = 22,
                x86 = 23,
                x86_64 = 24,
                xcore = 25,
                nvptx = 26,
                nvptx64 = 27,
                le32 = 28,
                le64 = 29,
                amdil = 30,
                amdil64 = 31,
                hsail = 32,
                hsail64 = 33,
                spir = 34,
                spir64 = 35,
                kalimba = 36
            }

            public enum SubArchType : uint
            {
                NoSubArch = 0,
                ARMSubArch_v8 = 1,
                ARMSubArch_v7 = 2,
                ARMSubArch_v7em = 3,
                ARMSubArch_v7m = 4,
                ARMSubArch_v7s = 5,
                ARMSubArch_v6 = 6,
                ARMSubArch_v6m = 7,
                ARMSubArch_v6t2 = 8,
                ARMSubArch_v5 = 9,
                ARMSubArch_v5te = 10,
                ARMSubArch_v4t = 11,
                KalimbaSubArch_v3 = 12,
                KalimbaSubArch_v4 = 13,
                KalimbaSubArch_v5 = 14
            }

            public enum VendorType : uint
            {
                UnknownVendor = 0,
                Apple = 1,
                PC = 2,
                SCEI = 3,
                BGP = 4,
                BGQ = 5,
                Freescale = 6,
                IBM = 7,
                ImaginationTechnologies = 8,
                MipsTechnologies = 9,
                NVIDIA = 10,
                CSR = 11
            }

            public enum OSType : uint
            {
                UnknownOS = 0,
                Darwin = 1,
                DragonFly = 2,
                FreeBSD = 3,
                IOS = 4,
                KFreeBSD = 5,
                Linux = 6,
                Lv2 = 7,
                MacOSX = 8,
                NetBSD = 9,
                OpenBSD = 10,
                Solaris = 11,
                Win32 = 12,
                Haiku = 13,
                Minix = 14,
                RTEMS = 15,
                NaCl = 16,
                CNK = 17,
                Bitrig = 18,
                AIX = 19,
                CUDA = 20,
                NVCL = 21,
                AMDHSA = 22,
                PS4 = 23
            }

            public enum EnvironmentType : uint
            {
                UnknownEnvironment = 0,
                GNU = 1,
                GNUEABI = 2,
                GNUEABIHF = 3,
                GNUX32 = 4,
                CODE16 = 5,
                EABI = 6,
                EABIHF = 7,
                Android = 8,
                MSVC = 9,
                Itanium = 10,
                Cygnus = 11
            }

            public enum ObjectFormatType : uint
            {
                UnknownObjectFormat = 0,
                COFF = 1,
                ELF = 2,
                MachO = 3
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, Triple> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, Triple>();

            private readonly bool __ownsNativeInstance;

            public static Triple __CreateInstance(global::System.IntPtr native)
            {
                return new Triple((Triple.Internal*) native);
            }

            public static Triple __CreateInstance(Triple.Internal native)
            {
                return new Triple(native);
            }

            private static Triple.Internal* __CopyValue(Triple.Internal native)
            {
                var ret = (Triple.Internal*) Marshal.AllocHGlobal(48);
                *ret = native;
                return ret;
            }

            private Triple(Triple.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected Triple(Triple.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            /// <summary>
            /// <para>Default constructor is the same as an empty string and leaves all
            /// triple fields unknown.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Default constructor is the same as an empty string and
            /// leaves all</para>
            /// <para>  /// triple fields unknown.</para>
            /// </remarks>
            public Triple()
            {
                __Instance = Marshal.AllocHGlobal(48);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public Triple(llvm.Twine Str)
            {
                __Instance = Marshal.AllocHGlobal(48);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(Str, null) ? global::System.IntPtr.Zero : Str.__Instance;
                Internal.ctor_1(__Instance, arg0);
            }

            public Triple(llvm.Twine ArchStr, llvm.Twine VendorStr, llvm.Twine OSStr)
            {
                __Instance = Marshal.AllocHGlobal(48);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(ArchStr, null) ? global::System.IntPtr.Zero : ArchStr.__Instance;
                var arg1 = ReferenceEquals(VendorStr, null) ? global::System.IntPtr.Zero : VendorStr.__Instance;
                var arg2 = ReferenceEquals(OSStr, null) ? global::System.IntPtr.Zero : OSStr.__Instance;
                Internal.ctor_2(__Instance, arg0, arg1, arg2);
            }

            public Triple(llvm.Twine ArchStr, llvm.Twine VendorStr, llvm.Twine OSStr, llvm.Twine EnvironmentStr)
            {
                __Instance = Marshal.AllocHGlobal(48);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(ArchStr, null) ? global::System.IntPtr.Zero : ArchStr.__Instance;
                var arg1 = ReferenceEquals(VendorStr, null) ? global::System.IntPtr.Zero : VendorStr.__Instance;
                var arg2 = ReferenceEquals(OSStr, null) ? global::System.IntPtr.Zero : OSStr.__Instance;
                var arg3 = ReferenceEquals(EnvironmentStr, null) ? global::System.IntPtr.Zero : EnvironmentStr.__Instance;
                Internal.ctor_3(__Instance, arg0, arg1, arg2, arg3);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                llvm.Triple __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance || force)
                    Internal.dtor_0(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public static bool operator !=(llvm.Triple __op, llvm.Triple Other)
            {
                return !(__op == Other);
            }

            public static bool operator ==(llvm.Triple __op, llvm.Triple Other)
            {
                bool __opNull = ReferenceEquals(__op, null);
                bool OtherNull = ReferenceEquals(Other, null);
                if (__opNull || OtherNull)
                    return __opNull && OtherNull;
                var arg0 = __op.__Instance;
                var arg1 = Other.__Instance;
                var __ret = Internal.OperatorEqualEqual_0(arg0, arg1);
                return __ret;
            }

            public override bool Equals(object obj)
            {
                return this == obj as Triple;
            }

            /// <summary>
            /// <para>getArch - Get the parsed architecture type of this triple.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getArch - Get the parsed architecture type of this
            /// triple.</para>
            /// </remarks>
            public llvm.Triple.ArchType getArch()
            {
                var __ret = Internal.getArch_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>getSubArch - get the parsed subarchitecture type for this
            /// triple.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getSubArch - get the parsed subarchitecture type for this
            /// triple.</para>
            /// </remarks>
            public llvm.Triple.SubArchType getSubArch()
            {
                var __ret = Internal.getSubArch_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>getVendor - Get the parsed vendor type of this triple.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getVendor - Get the parsed vendor type of this triple.</para>
            /// </remarks>
            public llvm.Triple.VendorType getVendor()
            {
                var __ret = Internal.getVendor_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>getOS - Get the parsed operating system type of this
            /// triple.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getOS - Get the parsed operating system type of this
            /// triple.</para>
            /// </remarks>
            public llvm.Triple.OSType getOS()
            {
                var __ret = Internal.getOS_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>hasEnvironment - Does this triple have the optional environment
            /// (fourth) component?</para>
            /// </summary>
            /// <remarks>
            /// <para>/// hasEnvironment - Does this triple have the optional
            /// environment</para>
            /// <para>  /// (fourth) component?</para>
            /// </remarks>
            public bool hasEnvironment()
            {
                var __ret = Internal.hasEnvironment_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>getEnvironment - Get the parsed environment type of this
            /// triple.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getEnvironment - Get the parsed environment type of this
            /// triple.</para>
            /// </remarks>
            public llvm.Triple.EnvironmentType getEnvironment()
            {
                var __ret = Internal.getEnvironment_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>getFormat - Get the object format for this triple.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getFormat - Get the object format for this triple.</para>
            /// </remarks>
            public llvm.Triple.ObjectFormatType getObjectFormat()
            {
                var __ret = Internal.getObjectFormat_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>getOSVersion - Parse the version number from the OS name
            /// component of the triple, if present.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getOSVersion - Parse the version number from the OS name
            /// component of the</para>
            /// <para>  /// triple, if present.</para>
            /// <para>  ///</para>
            /// <para>  /// For example, &quot;fooos1.2.3&quot; would return (1, 2,
            /// 3).</para>
            /// <para>  ///</para>
            /// <para>  /// If an entry is not defined, it will be returned as
            /// 0.</para>
            /// </remarks>
            public void getOSVersion(ref uint Major, ref uint Minor, ref uint Micro)
            {
                fixed (uint* arg0 = &Major)
                {
                    fixed (uint* arg1 = &Minor)
                    {
                        fixed (uint* arg2 = &Micro)
                        {
                            Internal.getOSVersion_0(__Instance, arg0, arg1, arg2);
                        }
                    }
                }
            }

            /// <summary>
            /// <para>getOSMajorVersion - Return just the major version number, this is
            /// specialized because it is a common query.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getOSMajorVersion - Return just the major version number,
            /// this is</para>
            /// <para>  /// specialized because it is a common query.</para>
            /// </remarks>
            public uint getOSMajorVersion()
            {
                var __ret = Internal.getOSMajorVersion_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>getMacOSXVersion - Parse the version number as with getOSVersion
            /// and then translate generic &quot;darwin&quot; versions to the corresponding
            /// OS X versions. This may also be called with IOS triples but the OS X
            /// version number is just set to a constant 10.4.0 in that case. Returns true
            /// if successful.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getMacOSXVersion - Parse the version number as with
            /// getOSVersion and then</para>
            /// <para>  /// translate generic &quot;darwin&quot; versions to the
            /// corresponding OS X versions.</para>
            /// <para>  /// This may also be called with IOS triples but the OS X
            /// version number is</para>
            /// <para>  /// just set to a constant 10.4.0 in that case.  Returns true
            /// if successful.</para>
            /// </remarks>
            public bool getMacOSXVersion(ref uint Major, ref uint Minor, ref uint Micro)
            {
                fixed (uint* arg0 = &Major)
                {
                    fixed (uint* arg1 = &Minor)
                    {
                        fixed (uint* arg2 = &Micro)
                        {
                            var __ret = Internal.getMacOSXVersion_0(__Instance, arg0, arg1, arg2);
                            return __ret;
                        }
                    }
                }
            }

            /// <summary>
            /// <para>getiOSVersion - Parse the version number as with getOSVersion.
            /// This should only be called with IOS triples.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getiOSVersion - Parse the version number as with
            /// getOSVersion.  This should</para>
            /// <para>  /// only be called with IOS triples.</para>
            /// </remarks>
            public void getiOSVersion(ref uint Major, ref uint Minor, ref uint Micro)
            {
                fixed (uint* arg0 = &Major)
                {
                    fixed (uint* arg1 = &Minor)
                    {
                        fixed (uint* arg2 = &Micro)
                        {
                            Internal.getiOSVersion_0(__Instance, arg0, arg1, arg2);
                        }
                    }
                }
            }

            /// <summary>
            /// <para>getArchName - Get the architecture (first) component of the
            /// triple.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getArchName - Get the architecture (first) component of
            /// the</para>
            /// <para>  /// triple.</para>
            /// </remarks>
            public llvm.StringRef getArchName()
            {
                var __ret = Internal.getArchName_0(__Instance);
                return llvm.StringRef.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>getVendorName - Get the vendor (second) component of the
            /// triple.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getVendorName - Get the vendor (second) component of the
            /// triple.</para>
            /// </remarks>
            public llvm.StringRef getVendorName()
            {
                var __ret = Internal.getVendorName_0(__Instance);
                return llvm.StringRef.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>getOSName - Get the operating system (third) component of the
            /// triple.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getOSName - Get the operating system (third) component of
            /// the</para>
            /// <para>  /// triple.</para>
            /// </remarks>
            public llvm.StringRef getOSName()
            {
                var __ret = Internal.getOSName_0(__Instance);
                return llvm.StringRef.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>getEnvironmentName - Get the optional environment (fourth)
            /// component of the triple, or &quot;&quot; if empty.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getEnvironmentName - Get the optional environment
            /// (fourth)</para>
            /// <para>  /// component of the triple, or &quot;&quot; if empty.</para>
            /// </remarks>
            public llvm.StringRef getEnvironmentName()
            {
                var __ret = Internal.getEnvironmentName_0(__Instance);
                return llvm.StringRef.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>getOSAndEnvironmentName - Get the operating system and optional
            /// environment components as a single string (separated by a '-' if the
            /// environment component is present).</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getOSAndEnvironmentName - Get the operating system and
            /// optional</para>
            /// <para>  /// environment components as a single string (separated by a
            /// '-'</para>
            /// <para>  /// if the environment component is present).</para>
            /// </remarks>
            public llvm.StringRef getOSAndEnvironmentName()
            {
                var __ret = Internal.getOSAndEnvironmentName_0(__Instance);
                return llvm.StringRef.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Test whether the architecture is 64-bit</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Test whether the architecture is 64-bit</para>
            /// <para>  ///</para>
            /// <para>  /// Note that this tests for 64-bit pointer width, and nothing
            /// else. Note</para>
            /// <para>  /// that we intentionally expose only three predicates, 64-bit,
            /// 32-bit, and</para>
            /// <para>  /// 16-bit. The inner details of pointer width for particular
            /// architectures</para>
            /// <para>  /// is not summed up in the triple, and so only a coarse
            /// grained predicate</para>
            /// <para>  /// system is provided.</para>
            /// </remarks>
            public bool isArch64Bit()
            {
                var __ret = Internal.isArch64Bit_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Test whether the architecture is 32-bit</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Test whether the architecture is 32-bit</para>
            /// <para>  ///</para>
            /// <para>  /// Note that this tests for 32-bit pointer width, and nothing
            /// else.</para>
            /// </remarks>
            public bool isArch32Bit()
            {
                var __ret = Internal.isArch32Bit_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Test whether the architecture is 16-bit</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Test whether the architecture is 16-bit</para>
            /// <para>  ///</para>
            /// <para>  /// Note that this tests for 16-bit pointer width, and nothing
            /// else.</para>
            /// </remarks>
            public bool isArch16Bit()
            {
                var __ret = Internal.isArch16Bit_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>isOSVersionLT - Helper function for doing comparisons against
            /// version numbers included in the target triple.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// isOSVersionLT - Helper function for doing comparisons against
            /// version</para>
            /// <para>  /// numbers included in the target triple.</para>
            /// </remarks>
            public bool isOSVersionLT(uint Major, uint Minor, uint Micro)
            {
                var __ret = Internal.isOSVersionLT_0(__Instance, Major, Minor, Micro);
                return __ret;
            }

            public bool isOSVersionLT(llvm.Triple Other)
            {
                var arg0 = ReferenceEquals(Other, null) ? global::System.IntPtr.Zero : Other.__Instance;
                var __ret = Internal.isOSVersionLT_1(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>isMacOSXVersionLT - Comparison function for checking OS X version
            /// compatibility, which handles supporting skewed version numbering schemes
            /// used by the &quot;darwin&quot; triples.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// isMacOSXVersionLT - Comparison function for checking OS X
            /// version</para>
            /// <para>  /// compatibility, which handles supporting skewed version
            /// numbering schemes</para>
            /// <para>  /// used by the &quot;darwin&quot; triples.</para>
            /// </remarks>
            public uint isMacOSXVersionLT(uint Major, uint Minor, uint Micro)
            {
                var __ret = Internal.isMacOSXVersionLT_0(__Instance, Major, Minor, Micro);
                return __ret;
            }

            /// <summary>
            /// <para>isMacOSX - Is this a Mac OS X triple. For legacy reasons, we
            /// support both &quot;darwin&quot; and &quot;osx&quot; as OS X triples.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// isMacOSX - Is this a Mac OS X triple. For legacy reasons, we
            /// support both</para>
            /// <para>  /// &quot;darwin&quot; and &quot;osx&quot; as OS X
            /// triples.</para>
            /// </remarks>
            public bool isMacOSX()
            {
                var __ret = Internal.isMacOSX_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Is this an iOS triple.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Is this an iOS triple.</para>
            /// </remarks>
            public bool isiOS()
            {
                var __ret = Internal.isiOS_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>isOSDarwin - Is this a &quot;Darwin&quot; OS (OS X or
            /// iOS).</para>
            /// </summary>
            /// <remarks>
            /// <para>/// isOSDarwin - Is this a &quot;Darwin&quot; OS (OS X or
            /// iOS).</para>
            /// </remarks>
            public bool isOSDarwin()
            {
                var __ret = Internal.isOSDarwin_0(__Instance);
                return __ret;
            }

            public bool isOSNetBSD()
            {
                var __ret = Internal.isOSNetBSD_0(__Instance);
                return __ret;
            }

            public bool isOSOpenBSD()
            {
                var __ret = Internal.isOSOpenBSD_0(__Instance);
                return __ret;
            }

            public bool isOSFreeBSD()
            {
                var __ret = Internal.isOSFreeBSD_0(__Instance);
                return __ret;
            }

            public bool isOSDragonFly()
            {
                var __ret = Internal.isOSDragonFly_0(__Instance);
                return __ret;
            }

            public bool isOSSolaris()
            {
                var __ret = Internal.isOSSolaris_0(__Instance);
                return __ret;
            }

            public bool isOSBitrig()
            {
                var __ret = Internal.isOSBitrig_0(__Instance);
                return __ret;
            }

            public bool isWindowsMSVCEnvironment()
            {
                var __ret = Internal.isWindowsMSVCEnvironment_0(__Instance);
                return __ret;
            }

            public bool isKnownWindowsMSVCEnvironment()
            {
                var __ret = Internal.isKnownWindowsMSVCEnvironment_0(__Instance);
                return __ret;
            }

            public bool isWindowsItaniumEnvironment()
            {
                var __ret = Internal.isWindowsItaniumEnvironment_0(__Instance);
                return __ret;
            }

            public bool isWindowsCygwinEnvironment()
            {
                var __ret = Internal.isWindowsCygwinEnvironment_0(__Instance);
                return __ret;
            }

            public bool isWindowsGNUEnvironment()
            {
                var __ret = Internal.isWindowsGNUEnvironment_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Tests for either Cygwin or MinGW OS</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Tests for either Cygwin or MinGW OS</para>
            /// </remarks>
            public bool isOSCygMing()
            {
                var __ret = Internal.isOSCygMing_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Is this a &quot;Windows&quot; OS targeting a
            /// &quot;MSVCRT.dll&quot; environment.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Is this a &quot;Windows&quot; OS targeting a
            /// &quot;MSVCRT.dll&quot; environment.</para>
            /// </remarks>
            public bool isOSMSVCRT()
            {
                var __ret = Internal.isOSMSVCRT_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Tests whether the OS is Windows.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Tests whether the OS is Windows.</para>
            /// </remarks>
            public bool isOSWindows()
            {
                var __ret = Internal.isOSWindows_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Tests whether the OS is NaCl (Native Client)</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Tests whether the OS is NaCl (Native Client)</para>
            /// </remarks>
            public bool isOSNaCl()
            {
                var __ret = Internal.isOSNaCl_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Tests whether the OS is Linux.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Tests whether the OS is Linux.</para>
            /// </remarks>
            public bool isOSLinux()
            {
                var __ret = Internal.isOSLinux_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Tests whether the OS uses the ELF binary format.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Tests whether the OS uses the ELF binary
            /// format.</para>
            /// </remarks>
            public bool isOSBinFormatELF()
            {
                var __ret = Internal.isOSBinFormatELF_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Tests whether the OS uses the COFF binary format.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Tests whether the OS uses the COFF binary
            /// format.</para>
            /// </remarks>
            public bool isOSBinFormatCOFF()
            {
                var __ret = Internal.isOSBinFormatCOFF_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Tests whether the environment is MachO.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Tests whether the environment is MachO.</para>
            /// </remarks>
            public bool isOSBinFormatMachO()
            {
                var __ret = Internal.isOSBinFormatMachO_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Tests whether the target is the PS4 CPU</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Tests whether the target is the PS4 CPU</para>
            /// </remarks>
            public bool isPS4CPU()
            {
                var __ret = Internal.isPS4CPU_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Tests whether the target is the PS4 platform</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Tests whether the target is the PS4 platform</para>
            /// </remarks>
            public bool isPS4()
            {
                var __ret = Internal.isPS4_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>setArch - Set the architecture (first) component of the triple to
            /// a known type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// setArch - Set the architecture (first) component of the
            /// triple</para>
            /// <para>  /// to a known type.</para>
            /// </remarks>
            public void setArch(llvm.Triple.ArchType Kind)
            {
                var arg0 = Kind;
                Internal.setArch_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>setVendor - Set the vendor (second) component of the triple to a
            /// known type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// setVendor - Set the vendor (second) component of the triple
            /// to a</para>
            /// <para>  /// known type.</para>
            /// </remarks>
            public void setVendor(llvm.Triple.VendorType Kind)
            {
                var arg0 = Kind;
                Internal.setVendor_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>setOS - Set the operating system (third) component of the triple
            /// to a known type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// setOS - Set the operating system (third) component of the
            /// triple</para>
            /// <para>  /// to a known type.</para>
            /// </remarks>
            public void setOS(llvm.Triple.OSType Kind)
            {
                var arg0 = Kind;
                Internal.setOS_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>setEnvironment - Set the environment (fourth) component of the
            /// triple to a known type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// setEnvironment - Set the environment (fourth) component of
            /// the triple</para>
            /// <para>  /// to a known type.</para>
            /// </remarks>
            public void setEnvironment(llvm.Triple.EnvironmentType Kind)
            {
                var arg0 = Kind;
                Internal.setEnvironment_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>setObjectFormat - Set the object file format</para>
            /// </summary>
            /// <remarks>
            /// <para>/// setObjectFormat - Set the object file format</para>
            /// </remarks>
            public void setObjectFormat(llvm.Triple.ObjectFormatType Kind)
            {
                var arg0 = Kind;
                Internal.setObjectFormat_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>setTriple - Set all components to the new triple Str.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// setTriple - Set all components to the new triple \p
            /// Str.</para>
            /// </remarks>
            public void setTriple(llvm.Twine Str)
            {
                var arg0 = ReferenceEquals(Str, null) ? global::System.IntPtr.Zero : Str.__Instance;
                Internal.setTriple_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>setArchName - Set the architecture (first) component of the
            /// triple by name.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// setArchName - Set the architecture (first) component of
            /// the</para>
            /// <para>  /// triple by name.</para>
            /// </remarks>
            public void setArchName(llvm.StringRef Str)
            {
                var arg0 = ReferenceEquals(Str, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (Str.__Instance);
                Internal.setArchName_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>setVendorName - Set the vendor (second) component of the triple
            /// by name.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// setVendorName - Set the vendor (second) component of the
            /// triple</para>
            /// <para>  /// by name.</para>
            /// </remarks>
            public void setVendorName(llvm.StringRef Str)
            {
                var arg0 = ReferenceEquals(Str, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (Str.__Instance);
                Internal.setVendorName_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>setOSName - Set the operating system (third) component of the
            /// triple by name.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// setOSName - Set the operating system (third) component of
            /// the</para>
            /// <para>  /// triple by name.</para>
            /// </remarks>
            public void setOSName(llvm.StringRef Str)
            {
                var arg0 = ReferenceEquals(Str, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (Str.__Instance);
                Internal.setOSName_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>setEnvironmentName - Set the optional environment (fourth)
            /// component of the triple by name.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// setEnvironmentName - Set the optional environment
            /// (fourth)</para>
            /// <para>  /// component of the triple by name.</para>
            /// </remarks>
            public void setEnvironmentName(llvm.StringRef Str)
            {
                var arg0 = ReferenceEquals(Str, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (Str.__Instance);
                Internal.setEnvironmentName_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>setOSAndEnvironmentName - Set the operating system and optional
            /// environment components with a single string.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// setOSAndEnvironmentName - Set the operating system and
            /// optional</para>
            /// <para>  /// environment components with a single string.</para>
            /// </remarks>
            public void setOSAndEnvironmentName(llvm.StringRef Str)
            {
                var arg0 = ReferenceEquals(Str, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (Str.__Instance);
                Internal.setOSAndEnvironmentName_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>Form a triple with a 32-bit variant of the current
            /// architecture.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Form a triple with a 32-bit variant of the current
            /// architecture.</para>
            /// <para>  ///</para>
            /// <para>  /// This can be used to move across &quot;families&quot; of
            /// architectures where useful.</para>
            /// <para>  ///</para>
            /// <para>  /// \returns A new triple with a 32-bit architecture or an
            /// unknown</para>
            /// <para>  ///          architecture if no such variant can be
            /// found.</para>
            /// </remarks>
            public llvm.Triple get32BitArchVariant()
            {
                var __ret = new llvm.Triple.Internal();
                Internal.get32BitArchVariant_0(new IntPtr(&__ret), __Instance);
                return llvm.Triple.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Form a triple with a 64-bit variant of the current
            /// architecture.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Form a triple with a 64-bit variant of the current
            /// architecture.</para>
            /// <para>  ///</para>
            /// <para>  /// This can be used to move across &quot;families&quot; of
            /// architectures where useful.</para>
            /// <para>  ///</para>
            /// <para>  /// \returns A new triple with a 64-bit architecture or an
            /// unknown</para>
            /// <para>  ///          architecture if no such variant can be
            /// found.</para>
            /// </remarks>
            public llvm.Triple get64BitArchVariant()
            {
                var __ret = new llvm.Triple.Internal();
                Internal.get64BitArchVariant_0(new IntPtr(&__ret), __Instance);
                return llvm.Triple.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Get the (LLVM) name of the minimum ARM CPU for the arch we are
            /// targeting.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Get the (LLVM) name of the minimum ARM CPU for the arch we
            /// are targeting.</para>
            /// <para>  ///</para>
            /// <para>  /// \param Arch the architecture name (e.g.,
            /// &quot;armv7s&quot;). If it is an empty</para>
            /// <para>  /// string then the triple's arch name is used.</para>
            /// </remarks>
            public string getARMCPUForArch(llvm.StringRef Arch)
            {
                var arg0 = ReferenceEquals(Arch, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (Arch.__Instance);
                var __ret = Internal.getARMCPUForArch_0(__Instance, arg0);
                return Marshal.PtrToStringAnsi(__ret);
            }

            /// <summary>
            /// <para>getArchTypeName - Get the canonical name for the Kind
            /// architecture.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getArchTypeName - Get the canonical name for the \p Kind
            /// architecture.</para>
            /// </remarks>
            public static string getArchTypeName(llvm.Triple.ArchType Kind)
            {
                var arg0 = Kind;
                var __ret = Internal.getArchTypeName_0(arg0);
                return Marshal.PtrToStringAnsi(__ret);
            }

            /// <summary>
            /// <para>getArchTypePrefix - Get the &quot;prefix&quot; canonical name for
            /// the Kind architecture. This is the prefix used by the architecture specific
            /// builtins, and is suitable for passing to</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getArchTypePrefix - Get the &quot;prefix&quot; canonical name
            /// for the \p Kind</para>
            /// <para>  /// architecture. This is the prefix used by the architecture
            /// specific</para>
            /// <para>  /// builtins, and is suitable for passing to \see</para>
            /// <para>  /// Intrinsic::getIntrinsicForGCCBuiltin().</para>
            /// <para>  ///</para>
            /// <para>  /// \return - The architecture prefix, or 0 if none is
            /// defined.</para>
            /// </remarks>
            public static string getArchTypePrefix(llvm.Triple.ArchType Kind)
            {
                var arg0 = Kind;
                var __ret = Internal.getArchTypePrefix_0(arg0);
                return Marshal.PtrToStringAnsi(__ret);
            }

            /// <summary>
            /// <para>getVendorTypeName - Get the canonical name for the Kind
            /// vendor.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getVendorTypeName - Get the canonical name for the \p Kind
            /// vendor.</para>
            /// </remarks>
            public static string getVendorTypeName(llvm.Triple.VendorType Kind)
            {
                var arg0 = Kind;
                var __ret = Internal.getVendorTypeName_0(arg0);
                return Marshal.PtrToStringAnsi(__ret);
            }

            /// <summary>
            /// <para>getOSTypeName - Get the canonical name for the Kind operating
            /// system.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getOSTypeName - Get the canonical name for the \p Kind
            /// operating system.</para>
            /// </remarks>
            public static string getOSTypeName(llvm.Triple.OSType Kind)
            {
                var arg0 = Kind;
                var __ret = Internal.getOSTypeName_0(arg0);
                return Marshal.PtrToStringAnsi(__ret);
            }

            /// <summary>
            /// <para>getEnvironmentTypeName - Get the canonical name for the Kind
            /// environment.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getEnvironmentTypeName - Get the canonical name for the \p
            /// Kind</para>
            /// <para>  /// environment.</para>
            /// </remarks>
            public static string getEnvironmentTypeName(llvm.Triple.EnvironmentType Kind)
            {
                var arg0 = Kind;
                var __ret = Internal.getEnvironmentTypeName_0(arg0);
                return Marshal.PtrToStringAnsi(__ret);
            }

            /// <summary>
            /// <para>getArchTypeForLLVMName - The canonical type for the given LLVM
            /// architecture name (e.g., &quot;x86&quot;).</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getArchTypeForLLVMName - The canonical type for the given
            /// LLVM</para>
            /// <para>  /// architecture name (e.g., &quot;x86&quot;).</para>
            /// </remarks>
            public static llvm.Triple.ArchType getArchTypeForLLVMName(llvm.StringRef Str)
            {
                var arg0 = ReferenceEquals(Str, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (Str.__Instance);
                var __ret = Internal.getArchTypeForLLVMName_0(arg0);
                return __ret;
            }
        }
    }
}
