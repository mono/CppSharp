//----------------------------------------------------------------------------
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
//----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace CppSharp
{
    namespace clang
    {
        /// <summary>
        /// <para>A container of type source information.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief A container of type source information.</para>
        /// <para>///</para>
        /// <para>/// A client can read the relevant info using TypeLoc wrappers,
        /// e.g:</para>
        /// <para>/// @code</para>
        /// <para>/// TypeLoc TL = TypeSourceInfo-&gt;getTypeLoc();</para>
        /// <para>/// TL.getStartLoc().print(OS, SrcMgr);</para>
        /// <para>/// @endcode</para>
        /// <para>///</para>
        /// </remarks>
        public unsafe partial class TypeSourceInfo : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 8)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public clang.QualType.Internal Ty;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14TypeSourceInfoC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14TypeSourceInfo7getTypeEv")]
                internal static extern clang.QualType.Internal getType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14TypeSourceInfo10getTypeLocEv")]
                internal static extern clang.TypeLoc.Internal getTypeLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14TypeSourceInfo12overrideTypeENS_8QualTypeE")]
                internal static extern void overrideType_0(global::System.IntPtr instance, clang.QualType.Internal T);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, TypeSourceInfo> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, TypeSourceInfo>();

            private readonly bool __ownsNativeInstance;

            public static TypeSourceInfo __CreateInstance(global::System.IntPtr native)
            {
                return new TypeSourceInfo((TypeSourceInfo.Internal*) native);
            }

            public static TypeSourceInfo __CreateInstance(TypeSourceInfo.Internal native)
            {
                return new TypeSourceInfo(native);
            }

            private static TypeSourceInfo.Internal* __CopyValue(TypeSourceInfo.Internal native)
            {
                var ret = (TypeSourceInfo.Internal*) Marshal.AllocHGlobal(8);
                *ret = native;
                return ret;
            }

            private TypeSourceInfo(TypeSourceInfo.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected TypeSourceInfo(TypeSourceInfo.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.TypeSourceInfo __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            /// <summary>
            /// <para>Return the type wrapped by this type source info.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the type wrapped by this type source
            /// info.</para>
            /// </remarks>
            public clang.QualType getType()
            {
                var __ret = Internal.getType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Return the TypeLoc wrapper for the type source info.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the TypeLoc wrapper for the type source
            /// info.</para>
            /// </remarks>
            public clang.TypeLoc getTypeLoc()
            {
                var __ret = Internal.getTypeLoc_0(__Instance);
                return clang.TypeLoc.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Override the type stored in this TypeSourceInfo. Use with
            /// caution!</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Override the type stored in this TypeSourceInfo. Use
            /// with caution!</para>
            /// </remarks>
            public void overrideType(clang.QualType T)
            {
                var arg0 = ReferenceEquals(T, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (T.__Instance);
                Internal.overrideType_0(__Instance, arg0);
            }
        }

        /// <summary>
        /// <para>TranslationUnitDecl - The top declaration context.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// TranslationUnitDecl - The top declaration context.</para>
        /// </remarks>
        public unsafe partial class TranslationUnitDecl : clang.Decl, clang.DeclContext, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 80)]
            public new partial struct Internal
            {
                [FieldOffset(8)]
                internal llvm.PointerIntPair.Internal NextInContextAndBits;

                [FieldOffset(16)]
                internal llvm.PointerUnion.Internal DeclCtx;

                [FieldOffset(24)]
                public clang.SourceLocation.Internal Loc;

                [FieldOffset(28)]
                public uint DeclKind;

                [FieldOffset(29)]
                public uint InvalidDecl;

                [FieldOffset(29)]
                public uint HasAttrs;

                [FieldOffset(29)]
                public uint Implicit;

                [FieldOffset(29)]
                public uint Used;

                [FieldOffset(29)]
                public uint Referenced;

                [FieldOffset(29)]
                public uint Access;

                [FieldOffset(29)]
                public uint FromASTFile;

                [FieldOffset(30)]
                public uint Hidden;

                [FieldOffset(30)]
                public uint IdentifierNamespace;

                [FieldOffset(31)]
                public uint CacheValidAndLinkage;

                [FieldOffset(0)]
                public uint DeclKind;

                [FieldOffset(1)]
                public bool ExternalLexicalStorage;

                [FieldOffset(1)]
                public bool ExternalVisibleStorage;

                [FieldOffset(1)]
                public bool NeedToReconcileExternalVisibleStorage;

                [FieldOffset(8)]
                internal llvm.PointerIntPair.Internal LookupPtr;

                [FieldOffset(16)]
                public global::System.IntPtr FirstDecl;

                [FieldOffset(24)]
                public global::System.IntPtr LastDecl;

                [FieldOffset(64)]
                public global::System.IntPtr Ctx;

                [FieldOffset(72)]
                public global::System.IntPtr AnonymousNamespace;

                [FieldOffset(0)]
                public global::System.IntPtr vfptr0;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang19TranslationUnitDeclC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang19TranslationUnitDeclD2Ev")]
                internal static extern void dtor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang19TranslationUnitDecl13getASTContextEv")]
                internal static extern global::System.IntPtr getASTContext_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang19TranslationUnitDecl21getAnonymousNamespaceEv")]
                internal static extern global::System.IntPtr getAnonymousNamespace_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang19TranslationUnitDecl21setAnonymousNamespaceEPNS_13NamespaceDeclE")]
                internal static extern void setAnonymousNamespace_0(global::System.IntPtr instance, global::System.IntPtr D);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang19TranslationUnitDecl6CreateERNS_10ASTContextE")]
                internal static extern global::System.IntPtr Create_0(global::System.IntPtr C);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang19TranslationUnitDecl7classofEPKNS_4DeclE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr D);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang19TranslationUnitDecl11classofKindENS_4Decl4KindE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classofKind_0(clang.Decl.Kind K);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang19TranslationUnitDecl17castToDeclContextEPKS0_")]
                internal static extern global::System.IntPtr castToDeclContext_0(global::System.IntPtr D);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang19TranslationUnitDecl19castFromDeclContextEPKNS_11DeclContextE")]
                internal static extern global::System.IntPtr castFromDeclContext_0(global::System.IntPtr DC);
            }

            private readonly bool __ownsNativeInstance;

            public static new TranslationUnitDecl __CreateInstance(global::System.IntPtr native)
            {
                return new TranslationUnitDecl((TranslationUnitDecl.Internal*) native);
            }

            public static TranslationUnitDecl __CreateInstance(TranslationUnitDecl.Internal native)
            {
                return new TranslationUnitDecl(native);
            }

            private static TranslationUnitDecl.Internal* __CopyValue(TranslationUnitDecl.Internal native)
            {
                var ret = (TranslationUnitDecl.Internal*) Marshal.AllocHGlobal(80);
                *ret = native;
                return ret;
            }

            private TranslationUnitDecl(TranslationUnitDecl.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected TranslationUnitDecl(TranslationUnitDecl.Internal* native, bool isInternalImpl = false)
                : base((clang.Decl.Internal*) native)
            {
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Decl __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.ASTContext getASTContext()
            {
                var __ret = Internal.getASTContext_0(__Instance);
                clang.ASTContext __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.ASTContext.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.ASTContext) clang.ASTContext.NativeToManagedMap[__ret];
                else __result0 = clang.ASTContext.__CreateInstance(__ret);
                return __result0;
            }

            public clang.NamespaceDecl getAnonymousNamespace()
            {
                var __ret = Internal.getAnonymousNamespace_0(__Instance);
                clang.NamespaceDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.NamespaceDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.NamespaceDecl) clang.NamespaceDecl.NativeToManagedMap[__ret];
                else clang.NamespaceDecl.NativeToManagedMap[__ret] = __result0 = (clang.NamespaceDecl) clang.NamespaceDecl.__CreateInstance(__ret);
                return __result0;
            }

            public void setAnonymousNamespace(clang.NamespaceDecl D)
            {
                var arg0 = ReferenceEquals(D, null) ? global::System.IntPtr.Zero : D.__Instance;
                Internal.setAnonymousNamespace_0(__Instance, arg0);
            }

            public static clang.TranslationUnitDecl Create(clang.ASTContext C)
            {
                var arg0 = ReferenceEquals(C, null) ? global::System.IntPtr.Zero : C.__Instance;
                var __ret = Internal.Create_0(arg0);
                clang.TranslationUnitDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.TranslationUnitDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.TranslationUnitDecl) clang.TranslationUnitDecl.NativeToManagedMap[__ret];
                else clang.TranslationUnitDecl.NativeToManagedMap[__ret] = __result0 = (clang.TranslationUnitDecl) clang.TranslationUnitDecl.__CreateInstance(__ret);
                return __result0;
            }

            public static bool classof(clang.Decl D)
            {
                var arg0 = ReferenceEquals(D, null) ? global::System.IntPtr.Zero : D.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }

            public static bool classofKind(clang.Decl.Kind K)
            {
                var arg0 = K;
                var __ret = Internal.classofKind_0(arg0);
                return __ret;
            }

            public static clang.DeclContext castToDeclContext(clang.TranslationUnitDecl D)
            {
                var arg0 = ReferenceEquals(D, null) ? global::System.IntPtr.Zero : D.__Instance;
                var __ret = Internal.castToDeclContext_0(arg0);
                clang.DeclContext __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.DeclContext.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.DeclContext) clang.DeclContext.NativeToManagedMap[__ret];
                else __result0 = clang.DeclContext.__CreateInstance(__ret);
                return __result0;
            }

            public static clang.TranslationUnitDecl castFromDeclContext(clang.DeclContext DC)
            {
                var arg0 = ReferenceEquals(DC, null) ? global::System.IntPtr.Zero : DC.__Instance;
                var __ret = Internal.castFromDeclContext_0(arg0);
                clang.TranslationUnitDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.TranslationUnitDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.TranslationUnitDecl) clang.TranslationUnitDecl.NativeToManagedMap[__ret];
                else clang.TranslationUnitDecl.NativeToManagedMap[__ret] = __result0 = (clang.TranslationUnitDecl) clang.TranslationUnitDecl.__CreateInstance(__ret);
                return __result0;
            }

            #region Virtual table interop

            // TranslationUnitDecl
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
            private static _dtor_0Delegate _dtor_0DelegateInstance;

            private static void _dtor_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (TranslationUnitDecl) _References[instance].Target;
                __target.DestroyNativeInstance();
            }

            // SourceRange getSourceRange() const LLVM_READONLY
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate clang.SourceRange.Internal _getSourceRange_0Delegate(global::System.IntPtr instance);
            private static _getSourceRange_0Delegate _getSourceRange_0DelegateInstance;

            private static clang.SourceRange.Internal _getSourceRange_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (TranslationUnitDecl) _References[instance].Target;
                var __ret = __target.getSourceRange();
                return ReferenceEquals(__ret, null) ? new clang.SourceRange.Internal() : *(clang.SourceRange.Internal*) (__ret.__Instance);
            }

            // bool isOutOfLine() const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate bool _isOutOfLine_0Delegate(global::System.IntPtr instance);
            private static _isOutOfLine_0Delegate _isOutOfLine_0DelegateInstance;

            private static bool _isOutOfLine_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (TranslationUnitDecl) _References[instance].Target;
                var __ret = __target.isOutOfLine();
                return __ret;
            }

            // Decl *getCanonicalDecl()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getCanonicalDecl_0Delegate(global::System.IntPtr instance);
            private static _getCanonicalDecl_0Delegate _getCanonicalDecl_0DelegateInstance;

            private static global::System.IntPtr _getCanonicalDecl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (TranslationUnitDecl) _References[instance].Target;
                var __ret = __target.getCanonicalDecl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // Decl *getNextRedeclarationImpl()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getNextRedeclarationImpl_0Delegate(global::System.IntPtr instance);
            private static _getNextRedeclarationImpl_0Delegate _getNextRedeclarationImpl_0DelegateInstance;

            private static global::System.IntPtr _getNextRedeclarationImpl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (TranslationUnitDecl) _References[instance].Target;
                var __ret = __target.getNextRedeclarationImpl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // Decl *getPreviousDeclImpl()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getPreviousDeclImpl_0Delegate(global::System.IntPtr instance);
            private static _getPreviousDeclImpl_0Delegate _getPreviousDeclImpl_0DelegateInstance;

            private static global::System.IntPtr _getPreviousDeclImpl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (TranslationUnitDecl) _References[instance].Target;
                var __ret = __target.getPreviousDeclImpl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // Decl *getMostRecentDeclImpl()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getMostRecentDeclImpl_0Delegate(global::System.IntPtr instance);
            private static _getMostRecentDeclImpl_0Delegate _getMostRecentDeclImpl_0DelegateInstance;

            private static global::System.IntPtr _getMostRecentDeclImpl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (TranslationUnitDecl) _References[instance].Target;
                var __ret = __target.getMostRecentDeclImpl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // Stmt* getBody() const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getBody_0Delegate(global::System.IntPtr instance);
            private static _getBody_0Delegate _getBody_0DelegateInstance;

            private static global::System.IntPtr _getBody_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (TranslationUnitDecl) _References[instance].Target;
                var __ret = __target.getBody();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // bool hasBody() const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate bool _hasBody_0Delegate(global::System.IntPtr instance);
            private static _hasBody_0Delegate _hasBody_0DelegateInstance;

            private static bool _hasBody_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (TranslationUnitDecl) _References[instance].Target;
                var __ret = __target.hasBody();
                return __ret;
            }

            private static void*[] _OldVTables;
            private static void*[] _NewVTables;
            private static void*[] _Thunks;
            private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

            void SetupVTables(global::System.IntPtr instance)
            {
                var native = (Internal*)instance.ToPointer();

                if (_References == null)
                    _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

                if (_References.ContainsKey(instance))
                    return;

                _References[instance] = new WeakReference(this);

                if (_OldVTables == null)
                {
                    _OldVTables = new void*[1];
                    _OldVTables[0] = native->vfptr0.ToPointer();
                }

                if (_Thunks == null)
                {
                    _Thunks = new void*[9];
                    _dtor_0DelegateInstance += _dtor_0DelegateHook;
                    _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                    _getSourceRange_0DelegateInstance += _getSourceRange_0DelegateHook;
                    _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_getSourceRange_0DelegateInstance).ToPointer();
                    _isOutOfLine_0DelegateInstance += _isOutOfLine_0DelegateHook;
                    _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_isOutOfLine_0DelegateInstance).ToPointer();
                    _getCanonicalDecl_0DelegateInstance += _getCanonicalDecl_0DelegateHook;
                    _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_getCanonicalDecl_0DelegateInstance).ToPointer();
                    _getNextRedeclarationImpl_0DelegateInstance += _getNextRedeclarationImpl_0DelegateHook;
                    _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_getNextRedeclarationImpl_0DelegateInstance).ToPointer();
                    _getPreviousDeclImpl_0DelegateInstance += _getPreviousDeclImpl_0DelegateHook;
                    _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_getPreviousDeclImpl_0DelegateInstance).ToPointer();
                    _getMostRecentDeclImpl_0DelegateInstance += _getMostRecentDeclImpl_0DelegateHook;
                    _Thunks[6] = Marshal.GetFunctionPointerForDelegate(_getMostRecentDeclImpl_0DelegateInstance).ToPointer();
                    _getBody_0DelegateInstance += _getBody_0DelegateHook;
                    _Thunks[7] = Marshal.GetFunctionPointerForDelegate(_getBody_0DelegateInstance).ToPointer();
                    _hasBody_0DelegateInstance += _hasBody_0DelegateHook;
                    _Thunks[8] = Marshal.GetFunctionPointerForDelegate(_hasBody_0DelegateInstance).ToPointer();
                }

                if (_NewVTables == null)
                {
                    _NewVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(10 * 8);
                    _NewVTables[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + 8) = _Thunks[0];
                    *(void**)(vfptr0 + 16) = _Thunks[1];
                    *(void**)(vfptr0 + 24) = _Thunks[2];
                    *(void**)(vfptr0 + 32) = _Thunks[3];
                    *(void**)(vfptr0 + 40) = _Thunks[4];
                    *(void**)(vfptr0 + 48) = _Thunks[5];
                    *(void**)(vfptr0 + 56) = _Thunks[6];
                    *(void**)(vfptr0 + 64) = _Thunks[7];
                    *(void**)(vfptr0 + 72) = _Thunks[8];
                    *(void**)(vfptr0 + 80) = *(void**)(native->vfptr0 + 80);
                }

                native->vfptr0 = new IntPtr(_NewVTables[0]);
            }

            #endregion
        }

        /// <summary>
        /// <para>NamedDecl - This represents a decl with a name. Many decls have
        /// names such as ObjCMethodDecl, but not @class, etc.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// NamedDecl - This represents a decl with a name.  Many decls
        /// have names such</para>
        /// <para>/// as ObjCMethodDecl, but not \@class, etc.</para>
        /// </remarks>
        public unsafe partial class NamedDecl : clang.Decl, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 40)]
            public new partial struct Internal
            {
                [FieldOffset(8)]
                internal llvm.PointerIntPair.Internal NextInContextAndBits;

                [FieldOffset(16)]
                internal llvm.PointerUnion.Internal DeclCtx;

                [FieldOffset(24)]
                public clang.SourceLocation.Internal Loc;

                [FieldOffset(28)]
                public uint DeclKind;

                [FieldOffset(29)]
                public uint InvalidDecl;

                [FieldOffset(29)]
                public uint HasAttrs;

                [FieldOffset(29)]
                public uint Implicit;

                [FieldOffset(29)]
                public uint Used;

                [FieldOffset(29)]
                public uint Referenced;

                [FieldOffset(29)]
                public uint Access;

                [FieldOffset(29)]
                public uint FromASTFile;

                [FieldOffset(30)]
                public uint Hidden;

                [FieldOffset(30)]
                public uint IdentifierNamespace;

                [FieldOffset(31)]
                public uint CacheValidAndLinkage;

                [FieldOffset(32)]
                public clang.DeclarationName.Internal Name;

                [FieldOffset(0)]
                public global::System.IntPtr vfptr0;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9NamedDeclC2ENS_4Decl4KindEPNS_11DeclContextENS_14SourceLocationENS_15DeclarationNameE")]
                internal static extern void ctor_0(global::System.IntPtr instance, clang.Decl.Kind DK, global::System.IntPtr DC, clang.SourceLocation.Internal L, clang.DeclarationName.Internal N);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9NamedDeclC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9NamedDeclD2Ev")]
                internal static extern void dtor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9NamedDecl13getIdentifierEv")]
                internal static extern global::System.IntPtr getIdentifier_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9NamedDecl7getNameEv")]
                internal static extern llvm.StringRef.Internal getName_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9NamedDecl9printNameERN4llvm11raw_ostreamE")]
                internal static extern void printName_0(global::System.IntPtr instance, global::System.IntPtr os);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9NamedDecl11getDeclNameEv")]
                internal static extern clang.DeclarationName.Internal getDeclName_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9NamedDecl11setDeclNameENS_15DeclarationNameE")]
                internal static extern void setDeclName_0(global::System.IntPtr instance, clang.DeclarationName.Internal N);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9NamedDecl18printQualifiedNameERN4llvm11raw_ostreamE")]
                internal static extern void printQualifiedName_0(global::System.IntPtr instance, global::System.IntPtr OS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9NamedDecl18printQualifiedNameERN4llvm11raw_ostreamERKNS_14PrintingPolicyE")]
                internal static extern void printQualifiedName_1(global::System.IntPtr instance, global::System.IntPtr OS, global::System.IntPtr Policy);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9NamedDecl20getNameForDiagnosticERN4llvm11raw_ostreamERKNS_14PrintingPolicyEb")]
                internal static extern void getNameForDiagnostic_0(global::System.IntPtr instance, global::System.IntPtr OS, global::System.IntPtr Policy, bool Qualified);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9NamedDecl19declarationReplacesEPS0_b")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool declarationReplaces_0(global::System.IntPtr instance, global::System.IntPtr OldD, bool IsKnownNewer);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9NamedDecl10hasLinkageEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasLinkage_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9NamedDecl8isHiddenEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isHidden_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9NamedDecl9setHiddenEb")]
                internal static extern void setHidden_0(global::System.IntPtr instance, bool Hide);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9NamedDecl16isCXXClassMemberEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isCXXClassMember_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9NamedDecl19isCXXInstanceMemberEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isCXXInstanceMember_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9NamedDecl18getLinkageInternalEv")]
                internal static extern clang.Linkage getLinkageInternal_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9NamedDecl16getFormalLinkageEv")]
                internal static extern clang.Linkage getFormalLinkage_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9NamedDecl24hasExternalFormalLinkageEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasExternalFormalLinkage_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9NamedDecl19isExternallyVisibleEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isExternallyVisible_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9NamedDecl13getVisibilityEv")]
                internal static extern clang.Visibility getVisibility_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9NamedDecl23getLinkageAndVisibilityEv")]
                internal static extern clang.LinkageInfo.Internal getLinkageAndVisibility_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9NamedDecl14isLinkageValidEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isLinkageValid_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9NamedDecl22hasLinkageBeenComputedEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasLinkageBeenComputed_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9NamedDecl17getUnderlyingDeclEv")]
                internal static extern global::System.IntPtr getUnderlyingDecl_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9NamedDecl17getMostRecentDeclEv")]
                internal static extern global::System.IntPtr getMostRecentDecl_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9NamedDecl30getObjCFStringFormattingFamilyEv")]
                internal static extern clang.ObjCStringFormatFamily getObjCFStringFormattingFamily_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9NamedDecl7classofEPKNS_4DeclE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr D);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9NamedDecl11classofKindENS_4Decl4KindE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classofKind_0(clang.Decl.Kind K);
            }

            /// <summary>
            /// <para>Kinds of explicit visibility.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Kinds of explicit visibility.</para>
            /// </remarks>
            public enum ExplicitVisibilityKind : uint
            {
                VisibilityForType = 0,
                VisibilityForValue = 1
            }

            private readonly bool __ownsNativeInstance;

            public static new NamedDecl __CreateInstance(global::System.IntPtr native)
            {
                return new NamedDecl((NamedDecl.Internal*) native);
            }

            public static NamedDecl __CreateInstance(NamedDecl.Internal native)
            {
                return new NamedDecl(native);
            }

            private static NamedDecl.Internal* __CopyValue(NamedDecl.Internal native)
            {
                var ret = (NamedDecl.Internal*) Marshal.AllocHGlobal(40);
                *ret = native;
                return ret;
            }

            private NamedDecl(NamedDecl.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected NamedDecl(NamedDecl.Internal* native, bool isInternalImpl = false)
                : base((clang.Decl.Internal*) native)
            {
            }

            protected NamedDecl(clang.Decl.Kind DK, clang.DeclContext DC, clang.SourceLocation L, clang.DeclarationName N)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(40);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = DK;
                var arg1 = ReferenceEquals(DC, null) ? global::System.IntPtr.Zero : DC.__Instance;
                var arg2 = ReferenceEquals(L, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (L.__Instance);
                var arg3 = ReferenceEquals(N, null) ? new clang.DeclarationName.Internal() : *(clang.DeclarationName.Internal*) (N.__Instance);
                Internal.ctor_0(__Instance, arg0, arg1, arg2, arg3);
                SetupVTables(__Instance);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Decl __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            /// <summary>
            /// <para>getIdentifier - Get the identifier that names this declaration,
            /// if there is one. This will return NULL if this declaration has no name
            /// (e.g., for an unnamed class) or if the name is a special name (C++
            /// constructor, Objective-C selector, etc.).</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getIdentifier - Get the identifier that names this
            /// declaration,</para>
            /// <para>  /// if there is one. This will return NULL if this declaration
            /// has</para>
            /// <para>  /// no name (e.g., for an unnamed class) or if the name is a
            /// special</para>
            /// <para>  /// name (C++ constructor, Objective-C selector, etc.).</para>
            /// </remarks>
            public clang.IdentifierInfo getIdentifier()
            {
                var __ret = Internal.getIdentifier_0(__Instance);
                clang.IdentifierInfo __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.IdentifierInfo.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.IdentifierInfo) clang.IdentifierInfo.NativeToManagedMap[__ret];
                else __result0 = clang.IdentifierInfo.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>getName - Get the name of identifier for this declaration as a
            /// StringRef. This requires that the declaration have a name and that it be a
            /// simple identifier.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getName - Get the name of identifier for this declaration as
            /// a StringRef.</para>
            /// <para>  /// This requires that the declaration have a name and that it
            /// be a simple</para>
            /// <para>  /// identifier.</para>
            /// </remarks>
            public llvm.StringRef getName()
            {
                var __ret = Internal.getName_0(__Instance);
                return llvm.StringRef.__CreateInstance(__ret);
            }

            public void printName(llvm.raw_ostream os)
            {
                var arg0 = ReferenceEquals(os, null) ? global::System.IntPtr.Zero : os.__Instance;
                Internal.printName_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>getDeclName - Get the actual, stored name of the declaration,
            /// which may be a special name.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getDeclName - Get the actual, stored name of the
            /// declaration,</para>
            /// <para>  /// which may be a special name.</para>
            /// </remarks>
            public clang.DeclarationName getDeclName()
            {
                var __ret = Internal.getDeclName_0(__Instance);
                return clang.DeclarationName.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Set the name of this declaration.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Set the name of this declaration.</para>
            /// </remarks>
            public void setDeclName(clang.DeclarationName N)
            {
                var arg0 = ReferenceEquals(N, null) ? new clang.DeclarationName.Internal() : *(clang.DeclarationName.Internal*) (N.__Instance);
                Internal.setDeclName_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>printQualifiedName - Returns human-readable qualified name for
            /// declaration, like A::B::i, for i being member of namespace A::B. If
            /// declaration is not member of context which can be named (record,
            /// namespace), it will return same result as printName(). Creating this name
            /// is expensive, so it should be called only when performance doesn't
            /// matter.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// printQualifiedName - Returns human-readable qualified name
            /// for</para>
            /// <para>  /// declaration, like A::B::i, for i being member of namespace
            /// A::B.</para>
            /// <para>  /// If declaration is not member of context which can be named
            /// (record,</para>
            /// <para>  /// namespace), it will return same result as
            /// printName().</para>
            /// <para>  /// Creating this name is expensive, so it should be called
            /// only when</para>
            /// <para>  /// performance doesn't matter.</para>
            /// </remarks>
            public void printQualifiedName(llvm.raw_ostream OS)
            {
                var arg0 = ReferenceEquals(OS, null) ? global::System.IntPtr.Zero : OS.__Instance;
                Internal.printQualifiedName_0(__Instance, arg0);
            }

            public void printQualifiedName(llvm.raw_ostream OS, clang.PrintingPolicy Policy)
            {
                var arg0 = ReferenceEquals(OS, null) ? global::System.IntPtr.Zero : OS.__Instance;
                var arg1 = ReferenceEquals(Policy, null) ? global::System.IntPtr.Zero : Policy.__Instance;
                Internal.printQualifiedName_1(__Instance, arg0, arg1);
            }

            /// <summary>
            /// <para>getNameForDiagnostic - Appends a human-readable name for this
            /// declaration into the given stream.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getNameForDiagnostic - Appends a human-readable name for
            /// this</para>
            /// <para>  /// declaration into the given stream.</para>
            /// <para>  ///</para>
            /// <para>  /// This is the method invoked by Sema when displaying a
            /// NamedDecl</para>
            /// <para>  /// in a diagnostic.  It does not necessarily produce the
            /// same</para>
            /// <para>  /// result as printName(); for example, class template</para>
            /// <para>  /// specializations are printed with their template
            /// arguments.</para>
            /// </remarks>
            public virtual void getNameForDiagnostic(llvm.raw_ostream OS, clang.PrintingPolicy Policy, bool Qualified)
            {
                var arg0 = ReferenceEquals(OS, null) ? global::System.IntPtr.Zero : OS.__Instance;
                var arg1 = ReferenceEquals(Policy, null) ? global::System.IntPtr.Zero : Policy.__Instance;
                Internal.getNameForDiagnostic_0(__Instance, arg0, arg1, Qualified);
            }

            /// <summary>
            /// <para>Determine whether this declaration, if known to be well-formed
            /// within its context, will replace the declaration OldD if introduced into
            /// scope. A declaration will replace another declaration if, for example, it
            /// is a redeclaration of the same variable or function, but not if it is a
            /// declaration of a different kind (function vs. class) or an overloaded
            /// function.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine whether this declaration, if</para>
            /// <para>  /// known to be well-formed within its context, will replace
            /// the</para>
            /// <para>  /// declaration OldD if introduced into scope. A declaration
            /// will</para>
            /// <para>  /// replace another declaration if, for example, it is a</para>
            /// <para>  /// redeclaration of the same variable or function, but not if
            /// it is</para>
            /// <para>  /// a declaration of a different kind (function vs. class) or
            /// an</para>
            /// <para>  /// overloaded function.</para>
            /// <para>  ///</para>
            /// <para>  /// \param IsKnownNewer \c true if this declaration is known to
            /// be newer</para>
            /// <para>  /// than \p OldD (for instance, if this declaration is
            /// newly-created).</para>
            /// </remarks>
            public bool declarationReplaces(clang.NamedDecl OldD, bool IsKnownNewer)
            {
                var arg0 = ReferenceEquals(OldD, null) ? global::System.IntPtr.Zero : OldD.__Instance;
                var __ret = Internal.declarationReplaces_0(__Instance, arg0, IsKnownNewer);
                return __ret;
            }

            /// <summary>
            /// <para>Determine whether this declaration has linkage.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine whether this declaration has linkage.</para>
            /// </remarks>
            public bool hasLinkage()
            {
                var __ret = Internal.hasLinkage_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determine whether this declaration is hidden from name
            /// lookup.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine whether this declaration is hidden from name
            /// lookup.</para>
            /// </remarks>
            public bool isHidden()
            {
                var __ret = Internal.isHidden_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Set whether this declaration is hidden from name lookup.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Set whether this declaration is hidden from name
            /// lookup.</para>
            /// </remarks>
            public void setHidden(bool Hide)
            {
                Internal.setHidden_0(__Instance, Hide);
            }

            /// <summary>
            /// <para>Determine whether this declaration is a C++ class member.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine whether this declaration is a C++ class
            /// member.</para>
            /// </remarks>
            public bool isCXXClassMember()
            {
                var __ret = Internal.isCXXClassMember_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determine whether the given declaration is an instance member of
            /// a C++ class.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine whether the given declaration is an instance
            /// member of</para>
            /// <para>  /// a C++ class.</para>
            /// </remarks>
            public bool isCXXInstanceMember()
            {
                var __ret = Internal.isCXXInstanceMember_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determine what kind of linkage this entity has. This is not the
            /// linkage as defined by the standard or the codegen notion of linkage. It is
            /// just an implementation detail that is used to compute those.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine what kind of linkage this entity has.</para>
            /// <para>  /// This is not the linkage as defined by the standard or the
            /// codegen notion</para>
            /// <para>  /// of linkage. It is just an implementation detail that is
            /// used to compute</para>
            /// <para>  /// those.</para>
            /// </remarks>
            public clang.Linkage getLinkageInternal()
            {
                var __ret = Internal.getLinkageInternal_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Get the linkage from a semantic point of view. Entities in
            /// anonymous namespaces are external (in c++98).</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Get the linkage from a semantic point of view.
            /// Entities in</para>
            /// <para>  /// anonymous namespaces are external (in c++98).</para>
            /// </remarks>
            public clang.Linkage getFormalLinkage()
            {
                var __ret = Internal.getFormalLinkage_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>True if this decl has external linkage.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief True if this decl has external linkage.</para>
            /// </remarks>
            public bool hasExternalFormalLinkage()
            {
                var __ret = Internal.hasExternalFormalLinkage_0(__Instance);
                return __ret;
            }

            public bool isExternallyVisible()
            {
                var __ret = Internal.isExternallyVisible_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determines the visibility of this entity.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determines the visibility of this entity.</para>
            /// </remarks>
            public clang.Visibility getVisibility()
            {
                var __ret = Internal.getVisibility_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determines the linkage and visibility of this entity.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determines the linkage and visibility of this
            /// entity.</para>
            /// </remarks>
            public clang.LinkageInfo getLinkageAndVisibility()
            {
                var __ret = Internal.getLinkageAndVisibility_0(__Instance);
                return clang.LinkageInfo.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>True if the computed linkage is valid. Used for consistency
            /// checking. Should always return true.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief True if the computed linkage is valid. Used for
            /// consistency</para>
            /// <para>  /// checking. Should always return true.</para>
            /// </remarks>
            public bool isLinkageValid()
            {
                var __ret = Internal.isLinkageValid_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>True if something has required us to compute the linkage of this
            /// declaration.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief True if something has required us to compute the
            /// linkage</para>
            /// <para>  /// of this declaration.</para>
            /// <para>  ///</para>
            /// <para>  /// Language features which can retroactively change linkage
            /// (like a</para>
            /// <para>  /// typedef name for linkage purposes) may need to consider
            /// this,</para>
            /// <para>  /// but hopefully only in transitory ways during
            /// parsing.</para>
            /// </remarks>
            public bool hasLinkageBeenComputed()
            {
                var __ret = Internal.hasLinkageBeenComputed_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Looks through UsingDecls and ObjCCompatibleAliasDecls for the
            /// underlying named decl.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Looks through UsingDecls and ObjCCompatibleAliasDecls
            /// for</para>
            /// <para>  /// the underlying named decl.</para>
            /// </remarks>
            public clang.NamedDecl getUnderlyingDecl()
            {
                var __ret = Internal.getUnderlyingDecl_0(__Instance);
                clang.NamedDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.NamedDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.NamedDecl) clang.NamedDecl.NativeToManagedMap[__ret];
                else clang.NamedDecl.NativeToManagedMap[__ret] = __result0 = (clang.NamedDecl) clang.NamedDecl.__CreateInstance(__ret);
                return __result0;
            }

            public clang.NamedDecl getMostRecentDecl()
            {
                var __ret = Internal.getMostRecentDecl_0(__Instance);
                clang.NamedDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.NamedDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.NamedDecl) clang.NamedDecl.NativeToManagedMap[__ret];
                else clang.NamedDecl.NativeToManagedMap[__ret] = __result0 = (clang.NamedDecl) clang.NamedDecl.__CreateInstance(__ret);
                return __result0;
            }

            public clang.ObjCStringFormatFamily getObjCFStringFormattingFamily()
            {
                var __ret = Internal.getObjCFStringFormattingFamily_0(__Instance);
                return __ret;
            }

            public static bool classof(clang.Decl D)
            {
                var arg0 = ReferenceEquals(D, null) ? global::System.IntPtr.Zero : D.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }

            public static bool classofKind(clang.Decl.Kind K)
            {
                var arg0 = K;
                var __ret = Internal.classofKind_0(arg0);
                return __ret;
            }

            #region Virtual table interop

            // NamedDecl
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
            private static _dtor_0Delegate _dtor_0DelegateInstance;

            private static void _dtor_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (NamedDecl) _References[instance].Target;
                __target.DestroyNativeInstance();
            }

            // SourceRange getSourceRange() const LLVM_READONLY
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate clang.SourceRange.Internal _getSourceRange_0Delegate(global::System.IntPtr instance);
            private static _getSourceRange_0Delegate _getSourceRange_0DelegateInstance;

            private static clang.SourceRange.Internal _getSourceRange_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (NamedDecl) _References[instance].Target;
                var __ret = __target.getSourceRange();
                return ReferenceEquals(__ret, null) ? new clang.SourceRange.Internal() : *(clang.SourceRange.Internal*) (__ret.__Instance);
            }

            // bool isOutOfLine() const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate bool _isOutOfLine_0Delegate(global::System.IntPtr instance);
            private static _isOutOfLine_0Delegate _isOutOfLine_0DelegateInstance;

            private static bool _isOutOfLine_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (NamedDecl) _References[instance].Target;
                var __ret = __target.isOutOfLine();
                return __ret;
            }

            // Decl *getCanonicalDecl()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getCanonicalDecl_0Delegate(global::System.IntPtr instance);
            private static _getCanonicalDecl_0Delegate _getCanonicalDecl_0DelegateInstance;

            private static global::System.IntPtr _getCanonicalDecl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (NamedDecl) _References[instance].Target;
                var __ret = __target.getCanonicalDecl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // Decl *getNextRedeclarationImpl()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getNextRedeclarationImpl_0Delegate(global::System.IntPtr instance);
            private static _getNextRedeclarationImpl_0Delegate _getNextRedeclarationImpl_0DelegateInstance;

            private static global::System.IntPtr _getNextRedeclarationImpl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (NamedDecl) _References[instance].Target;
                var __ret = __target.getNextRedeclarationImpl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // Decl *getPreviousDeclImpl()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getPreviousDeclImpl_0Delegate(global::System.IntPtr instance);
            private static _getPreviousDeclImpl_0Delegate _getPreviousDeclImpl_0DelegateInstance;

            private static global::System.IntPtr _getPreviousDeclImpl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (NamedDecl) _References[instance].Target;
                var __ret = __target.getPreviousDeclImpl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // Decl *getMostRecentDeclImpl()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getMostRecentDeclImpl_0Delegate(global::System.IntPtr instance);
            private static _getMostRecentDeclImpl_0Delegate _getMostRecentDeclImpl_0DelegateInstance;

            private static global::System.IntPtr _getMostRecentDeclImpl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (NamedDecl) _References[instance].Target;
                var __ret = __target.getMostRecentDeclImpl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // Stmt* getBody() const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getBody_0Delegate(global::System.IntPtr instance);
            private static _getBody_0Delegate _getBody_0DelegateInstance;

            private static global::System.IntPtr _getBody_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (NamedDecl) _References[instance].Target;
                var __ret = __target.getBody();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // bool hasBody() const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate bool _hasBody_0Delegate(global::System.IntPtr instance);
            private static _hasBody_0Delegate _hasBody_0DelegateInstance;

            private static bool _hasBody_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (NamedDecl) _References[instance].Target;
                var __ret = __target.hasBody();
                return __ret;
            }

            // void getNameForDiagnostic(raw_ostream &OS, const PrintingPolicy &Policy, bool Qualified) const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate void _getNameForDiagnostic_0Delegate(global::System.IntPtr instance, global::System.IntPtr OS, global::System.IntPtr Policy, bool Qualified);
            private static _getNameForDiagnostic_0Delegate _getNameForDiagnostic_0DelegateInstance;

            private static void _getNameForDiagnostic_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr OS, global::System.IntPtr Policy, bool Qualified)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (NamedDecl) _References[instance].Target;
                llvm.raw_ostream __result0;
                if (OS == IntPtr.Zero) __result0 = null;
                else if (llvm.raw_ostream.NativeToManagedMap.ContainsKey(OS))
                    __result0 = (llvm.raw_ostream) llvm.raw_ostream.NativeToManagedMap[OS];
                else llvm.raw_ostream.NativeToManagedMap[OS] = __result0 = (llvm.raw_ostream) llvm.raw_ostream.__CreateInstance(OS);
                clang.PrintingPolicy __result1;
                if (Policy == IntPtr.Zero) __result1 = null;
                else if (clang.PrintingPolicy.NativeToManagedMap.ContainsKey(Policy))
                    __result1 = (clang.PrintingPolicy) clang.PrintingPolicy.NativeToManagedMap[Policy];
                else __result1 = clang.PrintingPolicy.__CreateInstance(Policy);
                __target.getNameForDiagnostic(__result0, __result1, Qualified);
            }

            private static void*[] _OldVTables;
            private static void*[] _NewVTables;
            private static void*[] _Thunks;
            private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

            void SetupVTables(global::System.IntPtr instance)
            {
                var native = (Internal*)instance.ToPointer();

                if (_References == null)
                    _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

                if (_References.ContainsKey(instance))
                    return;

                _References[instance] = new WeakReference(this);

                if (_OldVTables == null)
                {
                    _OldVTables = new void*[1];
                    _OldVTables[0] = native->vfptr0.ToPointer();
                }

                if (_Thunks == null)
                {
                    _Thunks = new void*[10];
                    _dtor_0DelegateInstance += _dtor_0DelegateHook;
                    _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                    _getSourceRange_0DelegateInstance += _getSourceRange_0DelegateHook;
                    _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_getSourceRange_0DelegateInstance).ToPointer();
                    _isOutOfLine_0DelegateInstance += _isOutOfLine_0DelegateHook;
                    _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_isOutOfLine_0DelegateInstance).ToPointer();
                    _getCanonicalDecl_0DelegateInstance += _getCanonicalDecl_0DelegateHook;
                    _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_getCanonicalDecl_0DelegateInstance).ToPointer();
                    _getNextRedeclarationImpl_0DelegateInstance += _getNextRedeclarationImpl_0DelegateHook;
                    _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_getNextRedeclarationImpl_0DelegateInstance).ToPointer();
                    _getPreviousDeclImpl_0DelegateInstance += _getPreviousDeclImpl_0DelegateHook;
                    _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_getPreviousDeclImpl_0DelegateInstance).ToPointer();
                    _getMostRecentDeclImpl_0DelegateInstance += _getMostRecentDeclImpl_0DelegateHook;
                    _Thunks[6] = Marshal.GetFunctionPointerForDelegate(_getMostRecentDeclImpl_0DelegateInstance).ToPointer();
                    _getBody_0DelegateInstance += _getBody_0DelegateHook;
                    _Thunks[7] = Marshal.GetFunctionPointerForDelegate(_getBody_0DelegateInstance).ToPointer();
                    _hasBody_0DelegateInstance += _hasBody_0DelegateHook;
                    _Thunks[8] = Marshal.GetFunctionPointerForDelegate(_hasBody_0DelegateInstance).ToPointer();
                    _getNameForDiagnostic_0DelegateInstance += _getNameForDiagnostic_0DelegateHook;
                    _Thunks[9] = Marshal.GetFunctionPointerForDelegate(_getNameForDiagnostic_0DelegateInstance).ToPointer();
                }

                if (_NewVTables == null)
                {
                    _NewVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(11 * 8);
                    _NewVTables[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + 8) = _Thunks[0];
                    *(void**)(vfptr0 + 16) = _Thunks[1];
                    *(void**)(vfptr0 + 24) = _Thunks[2];
                    *(void**)(vfptr0 + 32) = _Thunks[3];
                    *(void**)(vfptr0 + 40) = _Thunks[4];
                    *(void**)(vfptr0 + 48) = _Thunks[5];
                    *(void**)(vfptr0 + 56) = _Thunks[6];
                    *(void**)(vfptr0 + 64) = _Thunks[7];
                    *(void**)(vfptr0 + 72) = _Thunks[8];
                    *(void**)(vfptr0 + 80) = *(void**)(native->vfptr0 + 80);
                    *(void**)(vfptr0 + 88) = _Thunks[9];
                }

                native->vfptr0 = new IntPtr(_NewVTables[0]);
            }

            #endregion
        }

        /// <summary>
        /// <para>LabelDecl - Represents the declaration of a label. Labels also
        /// have a corresponding LabelStmt, which indicates the position that the label
        /// was defined at. For normal labels, the location of the decl is the same as
        /// the location of the statement. For GNU local labels (__label__), the decl
        /// location is where the __label__ is.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// LabelDecl - Represents the declaration of a label.  Labels
        /// also have a</para>
        /// <para>/// corresponding LabelStmt, which indicates the position that
        /// the label was</para>
        /// <para>/// defined at.  For normal labels, the location of the decl is
        /// the same as the</para>
        /// <para>/// location of the statement.  For GNU local labels (__label__),
        /// the decl</para>
        /// <para>/// location is where the __label__ is.</para>
        /// </remarks>
        public unsafe partial class LabelDecl : clang.NamedDecl, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 72)]
            public new partial struct Internal
            {
                [FieldOffset(8)]
                internal llvm.PointerIntPair.Internal NextInContextAndBits;

                [FieldOffset(16)]
                internal llvm.PointerUnion.Internal DeclCtx;

                [FieldOffset(24)]
                public clang.SourceLocation.Internal Loc;

                [FieldOffset(28)]
                public uint DeclKind;

                [FieldOffset(29)]
                public uint InvalidDecl;

                [FieldOffset(29)]
                public uint HasAttrs;

                [FieldOffset(29)]
                public uint Implicit;

                [FieldOffset(29)]
                public uint Used;

                [FieldOffset(29)]
                public uint Referenced;

                [FieldOffset(29)]
                public uint Access;

                [FieldOffset(29)]
                public uint FromASTFile;

                [FieldOffset(30)]
                public uint Hidden;

                [FieldOffset(30)]
                public uint IdentifierNamespace;

                [FieldOffset(31)]
                public uint CacheValidAndLinkage;

                [FieldOffset(32)]
                public clang.DeclarationName.Internal Name;

                [FieldOffset(40)]
                public global::System.IntPtr TheStmt;

                [FieldOffset(48)]
                public llvm.StringRef.Internal MSAsmName;

                [FieldOffset(64)]
                public bool MSAsmNameResolved;

                [FieldOffset(68)]
                public clang.SourceLocation.Internal LocStart;

                [FieldOffset(0)]
                public global::System.IntPtr vfptr0;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9LabelDeclC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9LabelDeclD2Ev")]
                internal static extern void dtor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9LabelDecl6CreateERNS_10ASTContextEPNS_11DeclContextENS_14SourceLocationEPNS_14IdentifierInfoE")]
                internal static extern global::System.IntPtr Create_0(global::System.IntPtr C, global::System.IntPtr DC, clang.SourceLocation.Internal IdentL, global::System.IntPtr II);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9LabelDecl6CreateERNS_10ASTContextEPNS_11DeclContextENS_14SourceLocationEPNS_14IdentifierInfoES5_")]
                internal static extern global::System.IntPtr Create_1(global::System.IntPtr C, global::System.IntPtr DC, clang.SourceLocation.Internal IdentL, global::System.IntPtr II, clang.SourceLocation.Internal GnuLabelL);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9LabelDecl18CreateDeserializedERNS_10ASTContextEj")]
                internal static extern global::System.IntPtr CreateDeserialized_0(global::System.IntPtr C, uint ID);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9LabelDecl7getStmtEv")]
                internal static extern global::System.IntPtr getStmt_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9LabelDecl7setStmtEPNS_9LabelStmtE")]
                internal static extern void setStmt_0(global::System.IntPtr instance, global::System.IntPtr T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9LabelDecl10isGnuLocalEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isGnuLocal_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9LabelDecl11setLocStartENS_14SourceLocationE")]
                internal static extern void setLocStart_0(global::System.IntPtr instance, clang.SourceLocation.Internal L);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9LabelDecl14getSourceRangeEv")]
                internal static extern clang.SourceRange.Internal getSourceRange_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9LabelDecl12isMSAsmLabelEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isMSAsmLabel_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9LabelDecl20isResolvedMSAsmLabelEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isResolvedMSAsmLabel_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9LabelDecl13setMSAsmLabelEN4llvm9StringRefE")]
                internal static extern void setMSAsmLabel_0(global::System.IntPtr instance, llvm.StringRef.Internal Name);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9LabelDecl13getMSAsmLabelEv")]
                internal static extern llvm.StringRef.Internal getMSAsmLabel_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9LabelDecl21setMSAsmLabelResolvedEv")]
                internal static extern void setMSAsmLabelResolved_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9LabelDecl7classofEPKNS_4DeclE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr D);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9LabelDecl11classofKindENS_4Decl4KindE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classofKind_0(clang.Decl.Kind K);
            }

            private readonly bool __ownsNativeInstance;

            public static new LabelDecl __CreateInstance(global::System.IntPtr native)
            {
                return new LabelDecl((LabelDecl.Internal*) native);
            }

            public static LabelDecl __CreateInstance(LabelDecl.Internal native)
            {
                return new LabelDecl(native);
            }

            private static LabelDecl.Internal* __CopyValue(LabelDecl.Internal native)
            {
                var ret = (LabelDecl.Internal*) Marshal.AllocHGlobal(72);
                *ret = native;
                return ret;
            }

            private LabelDecl(LabelDecl.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected LabelDecl(LabelDecl.Internal* native, bool isInternalImpl = false)
                : base((clang.NamedDecl.Internal*) native)
            {
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Decl __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.LabelStmt getStmt()
            {
                var __ret = Internal.getStmt_0(__Instance);
                clang.LabelStmt __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.LabelStmt.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.LabelStmt) clang.LabelStmt.NativeToManagedMap[__ret];
                else __result0 = clang.LabelStmt.__CreateInstance(__ret);
                return __result0;
            }

            public void setStmt(clang.LabelStmt T)
            {
                var arg0 = ReferenceEquals(T, null) ? global::System.IntPtr.Zero : T.__Instance;
                Internal.setStmt_0(__Instance, arg0);
            }

            public bool isGnuLocal()
            {
                var __ret = Internal.isGnuLocal_0(__Instance);
                return __ret;
            }

            public void setLocStart(clang.SourceLocation L)
            {
                var arg0 = ReferenceEquals(L, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (L.__Instance);
                Internal.setLocStart_0(__Instance, arg0);
            }

            public override clang.SourceRange getSourceRange()
            {
                var __ret = Internal.getSourceRange_0(__Instance);
                return clang.SourceRange.__CreateInstance(__ret);
            }

            public bool isMSAsmLabel()
            {
                var __ret = Internal.isMSAsmLabel_0(__Instance);
                return __ret;
            }

            public bool isResolvedMSAsmLabel()
            {
                var __ret = Internal.isResolvedMSAsmLabel_0(__Instance);
                return __ret;
            }

            public void setMSAsmLabel(llvm.StringRef Name)
            {
                var arg0 = ReferenceEquals(Name, null) ? new llvm.StringRef.Internal() : *(llvm.StringRef.Internal*) (Name.__Instance);
                Internal.setMSAsmLabel_0(__Instance, arg0);
            }

            public llvm.StringRef getMSAsmLabel()
            {
                var __ret = Internal.getMSAsmLabel_0(__Instance);
                return llvm.StringRef.__CreateInstance(__ret);
            }

            public void setMSAsmLabelResolved()
            {
                Internal.setMSAsmLabelResolved_0(__Instance);
            }

            public static clang.LabelDecl Create(clang.ASTContext C, clang.DeclContext DC, clang.SourceLocation IdentL, clang.IdentifierInfo II)
            {
                var arg0 = ReferenceEquals(C, null) ? global::System.IntPtr.Zero : C.__Instance;
                var arg1 = ReferenceEquals(DC, null) ? global::System.IntPtr.Zero : DC.__Instance;
                var arg2 = ReferenceEquals(IdentL, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (IdentL.__Instance);
                var arg3 = ReferenceEquals(II, null) ? global::System.IntPtr.Zero : II.__Instance;
                var __ret = Internal.Create_0(arg0, arg1, arg2, arg3);
                clang.LabelDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.LabelDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.LabelDecl) clang.LabelDecl.NativeToManagedMap[__ret];
                else clang.LabelDecl.NativeToManagedMap[__ret] = __result0 = (clang.LabelDecl) clang.LabelDecl.__CreateInstance(__ret);
                return __result0;
            }

            public static clang.LabelDecl Create(clang.ASTContext C, clang.DeclContext DC, clang.SourceLocation IdentL, clang.IdentifierInfo II, clang.SourceLocation GnuLabelL)
            {
                var arg0 = ReferenceEquals(C, null) ? global::System.IntPtr.Zero : C.__Instance;
                var arg1 = ReferenceEquals(DC, null) ? global::System.IntPtr.Zero : DC.__Instance;
                var arg2 = ReferenceEquals(IdentL, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (IdentL.__Instance);
                var arg3 = ReferenceEquals(II, null) ? global::System.IntPtr.Zero : II.__Instance;
                var arg4 = ReferenceEquals(GnuLabelL, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (GnuLabelL.__Instance);
                var __ret = Internal.Create_1(arg0, arg1, arg2, arg3, arg4);
                clang.LabelDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.LabelDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.LabelDecl) clang.LabelDecl.NativeToManagedMap[__ret];
                else clang.LabelDecl.NativeToManagedMap[__ret] = __result0 = (clang.LabelDecl) clang.LabelDecl.__CreateInstance(__ret);
                return __result0;
            }

            public static clang.LabelDecl CreateDeserialized(clang.ASTContext C, uint ID)
            {
                var arg0 = ReferenceEquals(C, null) ? global::System.IntPtr.Zero : C.__Instance;
                var __ret = Internal.CreateDeserialized_0(arg0, ID);
                clang.LabelDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.LabelDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.LabelDecl) clang.LabelDecl.NativeToManagedMap[__ret];
                else clang.LabelDecl.NativeToManagedMap[__ret] = __result0 = (clang.LabelDecl) clang.LabelDecl.__CreateInstance(__ret);
                return __result0;
            }

            public static bool classof(clang.Decl D)
            {
                var arg0 = ReferenceEquals(D, null) ? global::System.IntPtr.Zero : D.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }

            public static bool classofKind(clang.Decl.Kind K)
            {
                var arg0 = K;
                var __ret = Internal.classofKind_0(arg0);
                return __ret;
            }

            #region Virtual table interop

            // LabelDecl
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
            private static _dtor_0Delegate _dtor_0DelegateInstance;

            private static void _dtor_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (LabelDecl) _References[instance].Target;
                __target.DestroyNativeInstance();
            }

            // SourceRange getSourceRange() const override
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate clang.SourceRange.Internal _getSourceRange_0Delegate(global::System.IntPtr instance);
            private static _getSourceRange_0Delegate _getSourceRange_0DelegateInstance;

            private static clang.SourceRange.Internal _getSourceRange_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (LabelDecl) _References[instance].Target;
                var __ret = __target.getSourceRange();
                return ReferenceEquals(__ret, null) ? new clang.SourceRange.Internal() : *(clang.SourceRange.Internal*) (__ret.__Instance);
            }

            // bool isOutOfLine() const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate bool _isOutOfLine_0Delegate(global::System.IntPtr instance);
            private static _isOutOfLine_0Delegate _isOutOfLine_0DelegateInstance;

            private static bool _isOutOfLine_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (LabelDecl) _References[instance].Target;
                var __ret = __target.isOutOfLine();
                return __ret;
            }

            // Decl *getCanonicalDecl()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getCanonicalDecl_0Delegate(global::System.IntPtr instance);
            private static _getCanonicalDecl_0Delegate _getCanonicalDecl_0DelegateInstance;

            private static global::System.IntPtr _getCanonicalDecl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (LabelDecl) _References[instance].Target;
                var __ret = __target.getCanonicalDecl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // Decl *getNextRedeclarationImpl()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getNextRedeclarationImpl_0Delegate(global::System.IntPtr instance);
            private static _getNextRedeclarationImpl_0Delegate _getNextRedeclarationImpl_0DelegateInstance;

            private static global::System.IntPtr _getNextRedeclarationImpl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (LabelDecl) _References[instance].Target;
                var __ret = __target.getNextRedeclarationImpl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // Decl *getPreviousDeclImpl()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getPreviousDeclImpl_0Delegate(global::System.IntPtr instance);
            private static _getPreviousDeclImpl_0Delegate _getPreviousDeclImpl_0DelegateInstance;

            private static global::System.IntPtr _getPreviousDeclImpl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (LabelDecl) _References[instance].Target;
                var __ret = __target.getPreviousDeclImpl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // Decl *getMostRecentDeclImpl()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getMostRecentDeclImpl_0Delegate(global::System.IntPtr instance);
            private static _getMostRecentDeclImpl_0Delegate _getMostRecentDeclImpl_0DelegateInstance;

            private static global::System.IntPtr _getMostRecentDeclImpl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (LabelDecl) _References[instance].Target;
                var __ret = __target.getMostRecentDeclImpl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // Stmt* getBody() const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getBody_0Delegate(global::System.IntPtr instance);
            private static _getBody_0Delegate _getBody_0DelegateInstance;

            private static global::System.IntPtr _getBody_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (LabelDecl) _References[instance].Target;
                var __ret = __target.getBody();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // bool hasBody() const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate bool _hasBody_0Delegate(global::System.IntPtr instance);
            private static _hasBody_0Delegate _hasBody_0DelegateInstance;

            private static bool _hasBody_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (LabelDecl) _References[instance].Target;
                var __ret = __target.hasBody();
                return __ret;
            }

            // void getNameForDiagnostic(raw_ostream &OS, const PrintingPolicy &Policy, bool Qualified) const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate void _getNameForDiagnostic_0Delegate(global::System.IntPtr instance, global::System.IntPtr OS, global::System.IntPtr Policy, bool Qualified);
            private static _getNameForDiagnostic_0Delegate _getNameForDiagnostic_0DelegateInstance;

            private static void _getNameForDiagnostic_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr OS, global::System.IntPtr Policy, bool Qualified)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (LabelDecl) _References[instance].Target;
                llvm.raw_ostream __result0;
                if (OS == IntPtr.Zero) __result0 = null;
                else if (llvm.raw_ostream.NativeToManagedMap.ContainsKey(OS))
                    __result0 = (llvm.raw_ostream) llvm.raw_ostream.NativeToManagedMap[OS];
                else llvm.raw_ostream.NativeToManagedMap[OS] = __result0 = (llvm.raw_ostream) llvm.raw_ostream.__CreateInstance(OS);
                clang.PrintingPolicy __result1;
                if (Policy == IntPtr.Zero) __result1 = null;
                else if (clang.PrintingPolicy.NativeToManagedMap.ContainsKey(Policy))
                    __result1 = (clang.PrintingPolicy) clang.PrintingPolicy.NativeToManagedMap[Policy];
                else __result1 = clang.PrintingPolicy.__CreateInstance(Policy);
                __target.getNameForDiagnostic(__result0, __result1, Qualified);
            }

            private static void*[] _OldVTables;
            private static void*[] _NewVTables;
            private static void*[] _Thunks;
            private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

            void SetupVTables(global::System.IntPtr instance)
            {
                var native = (Internal*)instance.ToPointer();

                if (_References == null)
                    _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

                if (_References.ContainsKey(instance))
                    return;

                _References[instance] = new WeakReference(this);

                if (_OldVTables == null)
                {
                    _OldVTables = new void*[1];
                    _OldVTables[0] = native->vfptr0.ToPointer();
                }

                if (_Thunks == null)
                {
                    _Thunks = new void*[10];
                    _dtor_0DelegateInstance += _dtor_0DelegateHook;
                    _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                    _getSourceRange_0DelegateInstance += _getSourceRange_0DelegateHook;
                    _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_getSourceRange_0DelegateInstance).ToPointer();
                    _isOutOfLine_0DelegateInstance += _isOutOfLine_0DelegateHook;
                    _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_isOutOfLine_0DelegateInstance).ToPointer();
                    _getCanonicalDecl_0DelegateInstance += _getCanonicalDecl_0DelegateHook;
                    _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_getCanonicalDecl_0DelegateInstance).ToPointer();
                    _getNextRedeclarationImpl_0DelegateInstance += _getNextRedeclarationImpl_0DelegateHook;
                    _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_getNextRedeclarationImpl_0DelegateInstance).ToPointer();
                    _getPreviousDeclImpl_0DelegateInstance += _getPreviousDeclImpl_0DelegateHook;
                    _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_getPreviousDeclImpl_0DelegateInstance).ToPointer();
                    _getMostRecentDeclImpl_0DelegateInstance += _getMostRecentDeclImpl_0DelegateHook;
                    _Thunks[6] = Marshal.GetFunctionPointerForDelegate(_getMostRecentDeclImpl_0DelegateInstance).ToPointer();
                    _getBody_0DelegateInstance += _getBody_0DelegateHook;
                    _Thunks[7] = Marshal.GetFunctionPointerForDelegate(_getBody_0DelegateInstance).ToPointer();
                    _hasBody_0DelegateInstance += _hasBody_0DelegateHook;
                    _Thunks[8] = Marshal.GetFunctionPointerForDelegate(_hasBody_0DelegateInstance).ToPointer();
                    _getNameForDiagnostic_0DelegateInstance += _getNameForDiagnostic_0DelegateHook;
                    _Thunks[9] = Marshal.GetFunctionPointerForDelegate(_getNameForDiagnostic_0DelegateInstance).ToPointer();
                }

                if (_NewVTables == null)
                {
                    _NewVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(11 * 8);
                    _NewVTables[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + 8) = _Thunks[0];
                    *(void**)(vfptr0 + 16) = _Thunks[1];
                    *(void**)(vfptr0 + 24) = _Thunks[2];
                    *(void**)(vfptr0 + 32) = _Thunks[3];
                    *(void**)(vfptr0 + 40) = _Thunks[4];
                    *(void**)(vfptr0 + 48) = _Thunks[5];
                    *(void**)(vfptr0 + 56) = _Thunks[6];
                    *(void**)(vfptr0 + 64) = _Thunks[7];
                    *(void**)(vfptr0 + 72) = _Thunks[8];
                    *(void**)(vfptr0 + 80) = *(void**)(native->vfptr0 + 80);
                    *(void**)(vfptr0 + 88) = _Thunks[9];
                }

                native->vfptr0 = new IntPtr(_NewVTables[0]);
            }

            #endregion
        }

        /// <summary>
        /// <para>NamespaceDecl - Represent a C++ namespace.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// NamespaceDecl - Represent a C++ namespace.</para>
        /// </remarks>
        public unsafe partial class NamespaceDecl : clang.NamedDecl, clang.DeclContext, clang.Redeclarable, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 96)]
            public new partial struct Internal
            {
                [FieldOffset(8)]
                internal llvm.PointerIntPair.Internal NextInContextAndBits;

                [FieldOffset(16)]
                internal llvm.PointerUnion.Internal DeclCtx;

                [FieldOffset(24)]
                public clang.SourceLocation.Internal Loc;

                [FieldOffset(28)]
                public uint DeclKind;

                [FieldOffset(29)]
                public uint InvalidDecl;

                [FieldOffset(29)]
                public uint HasAttrs;

                [FieldOffset(29)]
                public uint Implicit;

                [FieldOffset(29)]
                public uint Used;

                [FieldOffset(29)]
                public uint Referenced;

                [FieldOffset(29)]
                public uint Access;

                [FieldOffset(29)]
                public uint FromASTFile;

                [FieldOffset(30)]
                public uint Hidden;

                [FieldOffset(30)]
                public uint IdentifierNamespace;

                [FieldOffset(31)]
                public uint CacheValidAndLinkage;

                [FieldOffset(32)]
                public clang.DeclarationName.Internal Name;

                [FieldOffset(0)]
                public uint DeclKind;

                [FieldOffset(1)]
                public bool ExternalLexicalStorage;

                [FieldOffset(1)]
                public bool ExternalVisibleStorage;

                [FieldOffset(1)]
                public bool NeedToReconcileExternalVisibleStorage;

                [FieldOffset(8)]
                internal llvm.PointerIntPair.Internal LookupPtr;

                [FieldOffset(16)]
                public global::System.IntPtr FirstDecl;

                [FieldOffset(24)]
                public global::System.IntPtr LastDecl;

                [FieldOffset(80)]
                public clang.SourceLocation.Internal LocStart;

                [FieldOffset(84)]
                public clang.SourceLocation.Internal RBraceLoc;

                [FieldOffset(88)]
                internal llvm.PointerIntPair.Internal AnonOrFirstNamespaceAndInline;

                [FieldOffset(0)]
                public global::System.IntPtr vfptr0;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13NamespaceDeclC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13NamespaceDeclD2Ev")]
                internal static extern void dtor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13NamespaceDecl24getNextRedeclarationImplEv")]
                internal static extern global::System.IntPtr getNextRedeclarationImpl_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13NamespaceDecl19getPreviousDeclImplEv")]
                internal static extern global::System.IntPtr getPreviousDeclImpl_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13NamespaceDecl21getMostRecentDeclImplEv")]
                internal static extern global::System.IntPtr getMostRecentDeclImpl_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13NamespaceDecl6CreateERNS_10ASTContextEPNS_11DeclContextEbNS_14SourceLocationES5_PNS_14IdentifierInfoEPS0_")]
                internal static extern global::System.IntPtr Create_0(global::System.IntPtr C, global::System.IntPtr DC, bool Inline, clang.SourceLocation.Internal StartLoc, clang.SourceLocation.Internal IdLoc, global::System.IntPtr Id, global::System.IntPtr PrevDecl);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13NamespaceDecl18CreateDeserializedERNS_10ASTContextEj")]
                internal static extern global::System.IntPtr CreateDeserialized_0(global::System.IntPtr C, uint ID);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13NamespaceDecl20isAnonymousNamespaceEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isAnonymousNamespace_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13NamespaceDecl8isInlineEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isInline_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13NamespaceDecl9setInlineEb")]
                internal static extern void setInline_0(global::System.IntPtr instance, bool Inline);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13NamespaceDecl20getOriginalNamespaceEv")]
                internal static extern global::System.IntPtr getOriginalNamespace_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13NamespaceDecl19isOriginalNamespaceEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isOriginalNamespace_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13NamespaceDecl21getAnonymousNamespaceEv")]
                internal static extern global::System.IntPtr getAnonymousNamespace_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13NamespaceDecl21setAnonymousNamespaceEPS0_")]
                internal static extern void setAnonymousNamespace_0(global::System.IntPtr instance, global::System.IntPtr D);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13NamespaceDecl16getCanonicalDeclEv")]
                internal static extern global::System.IntPtr getCanonicalDecl_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13NamespaceDecl14getSourceRangeEv")]
                internal static extern clang.SourceRange.Internal getSourceRange_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13NamespaceDecl11getLocStartEv")]
                internal static extern clang.SourceLocation.Internal getLocStart_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13NamespaceDecl12getRBraceLocEv")]
                internal static extern clang.SourceLocation.Internal getRBraceLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13NamespaceDecl11setLocStartENS_14SourceLocationE")]
                internal static extern void setLocStart_0(global::System.IntPtr instance, clang.SourceLocation.Internal L);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13NamespaceDecl12setRBraceLocENS_14SourceLocationE")]
                internal static extern void setRBraceLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal L);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13NamespaceDecl7classofEPKNS_4DeclE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr D);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13NamespaceDecl11classofKindENS_4Decl4KindE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classofKind_0(clang.Decl.Kind K);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13NamespaceDecl17castToDeclContextEPKS0_")]
                internal static extern global::System.IntPtr castToDeclContext_0(global::System.IntPtr D);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13NamespaceDecl19castFromDeclContextEPKNS_11DeclContextE")]
                internal static extern global::System.IntPtr castFromDeclContext_0(global::System.IntPtr DC);
            }

            private readonly bool __ownsNativeInstance;

            public static new NamespaceDecl __CreateInstance(global::System.IntPtr native)
            {
                return new NamespaceDecl((NamespaceDecl.Internal*) native);
            }

            public static NamespaceDecl __CreateInstance(NamespaceDecl.Internal native)
            {
                return new NamespaceDecl(native);
            }

            private static NamespaceDecl.Internal* __CopyValue(NamespaceDecl.Internal native)
            {
                var ret = (NamespaceDecl.Internal*) Marshal.AllocHGlobal(96);
                *ret = native;
                return ret;
            }

            private NamespaceDecl(NamespaceDecl.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected NamespaceDecl(NamespaceDecl.Internal* native, bool isInternalImpl = false)
                : base((clang.NamedDecl.Internal*) native)
            {
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Decl __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            internal virtual clang.NamespaceDecl getNextRedeclarationImpl()
            {
                var __ret = Internal.getNextRedeclarationImpl_0(__Instance);
                clang.NamespaceDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.NamespaceDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.NamespaceDecl) clang.NamespaceDecl.NativeToManagedMap[__ret];
                else clang.NamespaceDecl.NativeToManagedMap[__ret] = __result0 = (clang.NamespaceDecl) clang.NamespaceDecl.__CreateInstance(__ret);
                return __result0;
            }

            internal virtual clang.NamespaceDecl getPreviousDeclImpl()
            {
                var __ret = Internal.getPreviousDeclImpl_0(__Instance);
                clang.NamespaceDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.NamespaceDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.NamespaceDecl) clang.NamespaceDecl.NativeToManagedMap[__ret];
                else clang.NamespaceDecl.NativeToManagedMap[__ret] = __result0 = (clang.NamespaceDecl) clang.NamespaceDecl.__CreateInstance(__ret);
                return __result0;
            }

            internal virtual clang.NamespaceDecl getMostRecentDeclImpl()
            {
                var __ret = Internal.getMostRecentDeclImpl_0(__Instance);
                clang.NamespaceDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.NamespaceDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.NamespaceDecl) clang.NamespaceDecl.NativeToManagedMap[__ret];
                else clang.NamespaceDecl.NativeToManagedMap[__ret] = __result0 = (clang.NamespaceDecl) clang.NamespaceDecl.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Returns true if this is an anonymous namespace
            /// declaration.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Returns true if this is an anonymous namespace
            /// declaration.</para>
            /// <para>  ///</para>
            /// <para>  /// For example:</para>
            /// <para>  /// \code</para>
            /// <para>  ///   namespace {</para>
            /// <para>  ///     ...</para>
            /// <para>  ///   };</para>
            /// <para>  /// \endcode</para>
            /// <para>  /// q.v. C++ [namespace.unnamed]</para>
            /// </remarks>
            public bool isAnonymousNamespace()
            {
                var __ret = Internal.isAnonymousNamespace_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Returns true if this is an inline namespace declaration.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Returns true if this is an inline namespace
            /// declaration.</para>
            /// </remarks>
            public bool isInline()
            {
                var __ret = Internal.isInline_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Set whether this is an inline namespace declaration.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Set whether this is an inline namespace
            /// declaration.</para>
            /// </remarks>
            public void setInline(bool Inline)
            {
                Internal.setInline_0(__Instance, Inline);
            }

            /// <summary>
            /// <para>Get the original (first) namespace declaration.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Get the original (first) namespace declaration.</para>
            /// </remarks>
            public clang.NamespaceDecl getOriginalNamespace()
            {
                var __ret = Internal.getOriginalNamespace_0(__Instance);
                clang.NamespaceDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.NamespaceDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.NamespaceDecl) clang.NamespaceDecl.NativeToManagedMap[__ret];
                else clang.NamespaceDecl.NativeToManagedMap[__ret] = __result0 = (clang.NamespaceDecl) clang.NamespaceDecl.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Return true if this declaration is an original (first)
            /// declaration of the namespace. This is false for non-original (subsequent)
            /// namespace declarations and anonymous namespaces.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return true if this declaration is an original (first)
            /// declaration</para>
            /// <para>  /// of the namespace. This is false for non-original
            /// (subsequent) namespace</para>
            /// <para>  /// declarations and anonymous namespaces.</para>
            /// </remarks>
            public bool isOriginalNamespace()
            {
                var __ret = Internal.isOriginalNamespace_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Retrieve the anonymous namespace nested inside this namespace, if
            /// any.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the anonymous namespace nested inside this
            /// namespace,</para>
            /// <para>  /// if any.</para>
            /// </remarks>
            public clang.NamespaceDecl getAnonymousNamespace()
            {
                var __ret = Internal.getAnonymousNamespace_0(__Instance);
                clang.NamespaceDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.NamespaceDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.NamespaceDecl) clang.NamespaceDecl.NativeToManagedMap[__ret];
                else clang.NamespaceDecl.NativeToManagedMap[__ret] = __result0 = (clang.NamespaceDecl) clang.NamespaceDecl.__CreateInstance(__ret);
                return __result0;
            }

            public void setAnonymousNamespace(clang.NamespaceDecl D)
            {
                var arg0 = ReferenceEquals(D, null) ? global::System.IntPtr.Zero : D.__Instance;
                Internal.setAnonymousNamespace_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>Retrieves the canonical declaration of this namespace.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Retrieves the canonical declaration of this namespace.</para>
            /// </remarks>
            public virtual clang.NamespaceDecl getCanonicalDecl()
            {
                var __ret = Internal.getCanonicalDecl_0(__Instance);
                clang.NamespaceDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.NamespaceDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.NamespaceDecl) clang.NamespaceDecl.NativeToManagedMap[__ret];
                else clang.NamespaceDecl.NativeToManagedMap[__ret] = __result0 = (clang.NamespaceDecl) clang.NamespaceDecl.__CreateInstance(__ret);
                return __result0;
            }

            public override clang.SourceRange getSourceRange()
            {
                var __ret = Internal.getSourceRange_0(__Instance);
                return clang.SourceRange.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLocStart()
            {
                var __ret = Internal.getLocStart_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getRBraceLoc()
            {
                var __ret = Internal.getRBraceLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setLocStart(clang.SourceLocation L)
            {
                var arg0 = ReferenceEquals(L, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (L.__Instance);
                Internal.setLocStart_0(__Instance, arg0);
            }

            public void setRBraceLoc(clang.SourceLocation L)
            {
                var arg0 = ReferenceEquals(L, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (L.__Instance);
                Internal.setRBraceLoc_0(__Instance, arg0);
            }

            public static clang.NamespaceDecl Create(clang.ASTContext C, clang.DeclContext DC, bool Inline, clang.SourceLocation StartLoc, clang.SourceLocation IdLoc, clang.IdentifierInfo Id, clang.NamespaceDecl PrevDecl)
            {
                var arg0 = ReferenceEquals(C, null) ? global::System.IntPtr.Zero : C.__Instance;
                var arg1 = ReferenceEquals(DC, null) ? global::System.IntPtr.Zero : DC.__Instance;
                var arg3 = ReferenceEquals(StartLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (StartLoc.__Instance);
                var arg4 = ReferenceEquals(IdLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (IdLoc.__Instance);
                var arg5 = ReferenceEquals(Id, null) ? global::System.IntPtr.Zero : Id.__Instance;
                var arg6 = ReferenceEquals(PrevDecl, null) ? global::System.IntPtr.Zero : PrevDecl.__Instance;
                var __ret = Internal.Create_0(arg0, arg1, Inline, arg3, arg4, arg5, arg6);
                clang.NamespaceDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.NamespaceDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.NamespaceDecl) clang.NamespaceDecl.NativeToManagedMap[__ret];
                else clang.NamespaceDecl.NativeToManagedMap[__ret] = __result0 = (clang.NamespaceDecl) clang.NamespaceDecl.__CreateInstance(__ret);
                return __result0;
            }

            public static clang.NamespaceDecl CreateDeserialized(clang.ASTContext C, uint ID)
            {
                var arg0 = ReferenceEquals(C, null) ? global::System.IntPtr.Zero : C.__Instance;
                var __ret = Internal.CreateDeserialized_0(arg0, ID);
                clang.NamespaceDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.NamespaceDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.NamespaceDecl) clang.NamespaceDecl.NativeToManagedMap[__ret];
                else clang.NamespaceDecl.NativeToManagedMap[__ret] = __result0 = (clang.NamespaceDecl) clang.NamespaceDecl.__CreateInstance(__ret);
                return __result0;
            }

            public static bool classof(clang.Decl D)
            {
                var arg0 = ReferenceEquals(D, null) ? global::System.IntPtr.Zero : D.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }

            public static bool classofKind(clang.Decl.Kind K)
            {
                var arg0 = K;
                var __ret = Internal.classofKind_0(arg0);
                return __ret;
            }

            public static clang.DeclContext castToDeclContext(clang.NamespaceDecl D)
            {
                var arg0 = ReferenceEquals(D, null) ? global::System.IntPtr.Zero : D.__Instance;
                var __ret = Internal.castToDeclContext_0(arg0);
                clang.DeclContext __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.DeclContext.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.DeclContext) clang.DeclContext.NativeToManagedMap[__ret];
                else __result0 = clang.DeclContext.__CreateInstance(__ret);
                return __result0;
            }

            public static clang.NamespaceDecl castFromDeclContext(clang.DeclContext DC)
            {
                var arg0 = ReferenceEquals(DC, null) ? global::System.IntPtr.Zero : DC.__Instance;
                var __ret = Internal.castFromDeclContext_0(arg0);
                clang.NamespaceDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.NamespaceDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.NamespaceDecl) clang.NamespaceDecl.NativeToManagedMap[__ret];
                else clang.NamespaceDecl.NativeToManagedMap[__ret] = __result0 = (clang.NamespaceDecl) clang.NamespaceDecl.__CreateInstance(__ret);
                return __result0;
            }

            #region Virtual table interop

            // NamespaceDecl
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
            private static _dtor_0Delegate _dtor_0DelegateInstance;

            private static void _dtor_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (NamespaceDecl) _References[instance].Target;
                __target.DestroyNativeInstance();
            }

            // SourceRange getSourceRange() const override
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate clang.SourceRange.Internal _getSourceRange_0Delegate(global::System.IntPtr instance);
            private static _getSourceRange_0Delegate _getSourceRange_0DelegateInstance;

            private static clang.SourceRange.Internal _getSourceRange_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (NamespaceDecl) _References[instance].Target;
                var __ret = __target.getSourceRange();
                return ReferenceEquals(__ret, null) ? new clang.SourceRange.Internal() : *(clang.SourceRange.Internal*) (__ret.__Instance);
            }

            // bool isOutOfLine() const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate bool _isOutOfLine_0Delegate(global::System.IntPtr instance);
            private static _isOutOfLine_0Delegate _isOutOfLine_0DelegateInstance;

            private static bool _isOutOfLine_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (NamespaceDecl) _References[instance].Target;
                var __ret = __target.isOutOfLine();
                return __ret;
            }

            // NamespaceDecl *getCanonicalDecl() override
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getCanonicalDecl_0Delegate(global::System.IntPtr instance);
            private static _getCanonicalDecl_0Delegate _getCanonicalDecl_0DelegateInstance;

            private static global::System.IntPtr _getCanonicalDecl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (NamespaceDecl) _References[instance].Target;
                var __ret = __target.getCanonicalDecl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // NamespaceDecl *getNextRedeclarationImpl() override
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getNextRedeclarationImpl_0Delegate(global::System.IntPtr instance);
            private static _getNextRedeclarationImpl_0Delegate _getNextRedeclarationImpl_0DelegateInstance;

            private static global::System.IntPtr _getNextRedeclarationImpl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (NamespaceDecl) _References[instance].Target;
                var __ret = __target.getNextRedeclarationImpl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // NamespaceDecl *getPreviousDeclImpl() override
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getPreviousDeclImpl_0Delegate(global::System.IntPtr instance);
            private static _getPreviousDeclImpl_0Delegate _getPreviousDeclImpl_0DelegateInstance;

            private static global::System.IntPtr _getPreviousDeclImpl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (NamespaceDecl) _References[instance].Target;
                var __ret = __target.getPreviousDeclImpl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // NamespaceDecl *getMostRecentDeclImpl() override
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getMostRecentDeclImpl_0Delegate(global::System.IntPtr instance);
            private static _getMostRecentDeclImpl_0Delegate _getMostRecentDeclImpl_0DelegateInstance;

            private static global::System.IntPtr _getMostRecentDeclImpl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (NamespaceDecl) _References[instance].Target;
                var __ret = __target.getMostRecentDeclImpl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // Stmt* getBody() const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getBody_0Delegate(global::System.IntPtr instance);
            private static _getBody_0Delegate _getBody_0DelegateInstance;

            private static global::System.IntPtr _getBody_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (NamespaceDecl) _References[instance].Target;
                var __ret = __target.getBody();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // bool hasBody() const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate bool _hasBody_0Delegate(global::System.IntPtr instance);
            private static _hasBody_0Delegate _hasBody_0DelegateInstance;

            private static bool _hasBody_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (NamespaceDecl) _References[instance].Target;
                var __ret = __target.hasBody();
                return __ret;
            }

            // void getNameForDiagnostic(raw_ostream &OS, const PrintingPolicy &Policy, bool Qualified) const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate void _getNameForDiagnostic_0Delegate(global::System.IntPtr instance, global::System.IntPtr OS, global::System.IntPtr Policy, bool Qualified);
            private static _getNameForDiagnostic_0Delegate _getNameForDiagnostic_0DelegateInstance;

            private static void _getNameForDiagnostic_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr OS, global::System.IntPtr Policy, bool Qualified)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (NamespaceDecl) _References[instance].Target;
                llvm.raw_ostream __result0;
                if (OS == IntPtr.Zero) __result0 = null;
                else if (llvm.raw_ostream.NativeToManagedMap.ContainsKey(OS))
                    __result0 = (llvm.raw_ostream) llvm.raw_ostream.NativeToManagedMap[OS];
                else llvm.raw_ostream.NativeToManagedMap[OS] = __result0 = (llvm.raw_ostream) llvm.raw_ostream.__CreateInstance(OS);
                clang.PrintingPolicy __result1;
                if (Policy == IntPtr.Zero) __result1 = null;
                else if (clang.PrintingPolicy.NativeToManagedMap.ContainsKey(Policy))
                    __result1 = (clang.PrintingPolicy) clang.PrintingPolicy.NativeToManagedMap[Policy];
                else __result1 = clang.PrintingPolicy.__CreateInstance(Policy);
                __target.getNameForDiagnostic(__result0, __result1, Qualified);
            }

            private static void*[] _OldVTables;
            private static void*[] _NewVTables;
            private static void*[] _Thunks;
            private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

            void SetupVTables(global::System.IntPtr instance)
            {
                var native = (Internal*)instance.ToPointer();

                if (_References == null)
                    _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

                if (_References.ContainsKey(instance))
                    return;

                _References[instance] = new WeakReference(this);

                if (_OldVTables == null)
                {
                    _OldVTables = new void*[1];
                    _OldVTables[0] = native->vfptr0.ToPointer();
                }

                if (_Thunks == null)
                {
                    _Thunks = new void*[10];
                    _dtor_0DelegateInstance += _dtor_0DelegateHook;
                    _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                    _getSourceRange_0DelegateInstance += _getSourceRange_0DelegateHook;
                    _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_getSourceRange_0DelegateInstance).ToPointer();
                    _isOutOfLine_0DelegateInstance += _isOutOfLine_0DelegateHook;
                    _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_isOutOfLine_0DelegateInstance).ToPointer();
                    _getCanonicalDecl_0DelegateInstance += _getCanonicalDecl_0DelegateHook;
                    _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_getCanonicalDecl_0DelegateInstance).ToPointer();
                    _getNextRedeclarationImpl_0DelegateInstance += _getNextRedeclarationImpl_0DelegateHook;
                    _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_getNextRedeclarationImpl_0DelegateInstance).ToPointer();
                    _getPreviousDeclImpl_0DelegateInstance += _getPreviousDeclImpl_0DelegateHook;
                    _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_getPreviousDeclImpl_0DelegateInstance).ToPointer();
                    _getMostRecentDeclImpl_0DelegateInstance += _getMostRecentDeclImpl_0DelegateHook;
                    _Thunks[6] = Marshal.GetFunctionPointerForDelegate(_getMostRecentDeclImpl_0DelegateInstance).ToPointer();
                    _getBody_0DelegateInstance += _getBody_0DelegateHook;
                    _Thunks[7] = Marshal.GetFunctionPointerForDelegate(_getBody_0DelegateInstance).ToPointer();
                    _hasBody_0DelegateInstance += _hasBody_0DelegateHook;
                    _Thunks[8] = Marshal.GetFunctionPointerForDelegate(_hasBody_0DelegateInstance).ToPointer();
                    _getNameForDiagnostic_0DelegateInstance += _getNameForDiagnostic_0DelegateHook;
                    _Thunks[9] = Marshal.GetFunctionPointerForDelegate(_getNameForDiagnostic_0DelegateInstance).ToPointer();
                }

                if (_NewVTables == null)
                {
                    _NewVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(11 * 8);
                    _NewVTables[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + 8) = _Thunks[0];
                    *(void**)(vfptr0 + 16) = _Thunks[1];
                    *(void**)(vfptr0 + 24) = _Thunks[2];
                    *(void**)(vfptr0 + 32) = _Thunks[3];
                    *(void**)(vfptr0 + 40) = _Thunks[4];
                    *(void**)(vfptr0 + 48) = _Thunks[5];
                    *(void**)(vfptr0 + 56) = _Thunks[6];
                    *(void**)(vfptr0 + 64) = _Thunks[7];
                    *(void**)(vfptr0 + 72) = _Thunks[8];
                    *(void**)(vfptr0 + 80) = *(void**)(native->vfptr0 + 80);
                    *(void**)(vfptr0 + 88) = _Thunks[9];
                }

                native->vfptr0 = new IntPtr(_NewVTables[0]);
            }

            #endregion
        }

        /// <summary>
        /// <para>ValueDecl - Represent the declaration of a variable (in which
        /// case it is an lvalue) a function (in which case it is a function
        /// designator) or an enum constant.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// ValueDecl - Represent the declaration of a variable (in which
        /// case it is</para>
        /// <para>/// an lvalue) a function (in which case it is a function
        /// designator) or</para>
        /// <para>/// an enum constant.</para>
        /// </remarks>
        public unsafe partial class ValueDecl : clang.NamedDecl, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 48)]
            public new partial struct Internal
            {
                [FieldOffset(8)]
                internal llvm.PointerIntPair.Internal NextInContextAndBits;

                [FieldOffset(16)]
                internal llvm.PointerUnion.Internal DeclCtx;

                [FieldOffset(24)]
                public clang.SourceLocation.Internal Loc;

                [FieldOffset(28)]
                public uint DeclKind;

                [FieldOffset(29)]
                public uint InvalidDecl;

                [FieldOffset(29)]
                public uint HasAttrs;

                [FieldOffset(29)]
                public uint Implicit;

                [FieldOffset(29)]
                public uint Used;

                [FieldOffset(29)]
                public uint Referenced;

                [FieldOffset(29)]
                public uint Access;

                [FieldOffset(29)]
                public uint FromASTFile;

                [FieldOffset(30)]
                public uint Hidden;

                [FieldOffset(30)]
                public uint IdentifierNamespace;

                [FieldOffset(31)]
                public uint CacheValidAndLinkage;

                [FieldOffset(32)]
                public clang.DeclarationName.Internal Name;

                [FieldOffset(40)]
                public clang.QualType.Internal DeclType;

                [FieldOffset(0)]
                public global::System.IntPtr vfptr0;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9ValueDeclC2ENS_4Decl4KindEPNS_11DeclContextENS_14SourceLocationENS_15DeclarationNameENS_8QualTypeE")]
                internal static extern void ctor_0(global::System.IntPtr instance, clang.Decl.Kind DK, global::System.IntPtr DC, clang.SourceLocation.Internal L, clang.DeclarationName.Internal N, clang.QualType.Internal T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9ValueDeclC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9ValueDeclD2Ev")]
                internal static extern void dtor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9ValueDecl7getTypeEv")]
                internal static extern clang.QualType.Internal getType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9ValueDecl7setTypeENS_8QualTypeE")]
                internal static extern void setType_0(global::System.IntPtr instance, clang.QualType.Internal newType);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9ValueDecl6isWeakEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isWeak_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9ValueDecl7classofEPKNS_4DeclE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr D);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9ValueDecl11classofKindENS_4Decl4KindE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classofKind_0(clang.Decl.Kind K);
            }

            private readonly bool __ownsNativeInstance;

            public static new ValueDecl __CreateInstance(global::System.IntPtr native)
            {
                return new ValueDecl((ValueDecl.Internal*) native);
            }

            public static ValueDecl __CreateInstance(ValueDecl.Internal native)
            {
                return new ValueDecl(native);
            }

            private static ValueDecl.Internal* __CopyValue(ValueDecl.Internal native)
            {
                var ret = (ValueDecl.Internal*) Marshal.AllocHGlobal(48);
                *ret = native;
                return ret;
            }

            private ValueDecl(ValueDecl.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected ValueDecl(ValueDecl.Internal* native, bool isInternalImpl = false)
                : base((clang.NamedDecl.Internal*) native)
            {
            }

            protected ValueDecl(clang.Decl.Kind DK, clang.DeclContext DC, clang.SourceLocation L, clang.DeclarationName N, clang.QualType T)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(48);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = DK;
                var arg1 = ReferenceEquals(DC, null) ? global::System.IntPtr.Zero : DC.__Instance;
                var arg2 = ReferenceEquals(L, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (L.__Instance);
                var arg3 = ReferenceEquals(N, null) ? new clang.DeclarationName.Internal() : *(clang.DeclarationName.Internal*) (N.__Instance);
                var arg4 = ReferenceEquals(T, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (T.__Instance);
                Internal.ctor_0(__Instance, arg0, arg1, arg2, arg3, arg4);
                SetupVTables(__Instance);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Decl __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.QualType getType()
            {
                var __ret = Internal.getType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            public void setType(clang.QualType newType)
            {
                var arg0 = ReferenceEquals(newType, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (newType.__Instance);
                Internal.setType_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>Determine whether this symbol is weakly-imported, or declared
            /// with the weak or weak-ref attr.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine whether this symbol is
            /// weakly-imported,</para>
            /// <para>  ///        or declared with the weak or weak-ref attr.</para>
            /// </remarks>
            public bool isWeak()
            {
                var __ret = Internal.isWeak_0(__Instance);
                return __ret;
            }

            public static bool classof(clang.Decl D)
            {
                var arg0 = ReferenceEquals(D, null) ? global::System.IntPtr.Zero : D.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }

            public static bool classofKind(clang.Decl.Kind K)
            {
                var arg0 = K;
                var __ret = Internal.classofKind_0(arg0);
                return __ret;
            }

            #region Virtual table interop

            // ValueDecl
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
            private static _dtor_0Delegate _dtor_0DelegateInstance;

            private static void _dtor_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (ValueDecl) _References[instance].Target;
                __target.DestroyNativeInstance();
            }

            // SourceRange getSourceRange() const LLVM_READONLY
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate clang.SourceRange.Internal _getSourceRange_0Delegate(global::System.IntPtr instance);
            private static _getSourceRange_0Delegate _getSourceRange_0DelegateInstance;

            private static clang.SourceRange.Internal _getSourceRange_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (ValueDecl) _References[instance].Target;
                var __ret = __target.getSourceRange();
                return ReferenceEquals(__ret, null) ? new clang.SourceRange.Internal() : *(clang.SourceRange.Internal*) (__ret.__Instance);
            }

            // bool isOutOfLine() const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate bool _isOutOfLine_0Delegate(global::System.IntPtr instance);
            private static _isOutOfLine_0Delegate _isOutOfLine_0DelegateInstance;

            private static bool _isOutOfLine_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (ValueDecl) _References[instance].Target;
                var __ret = __target.isOutOfLine();
                return __ret;
            }

            // Decl *getCanonicalDecl()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getCanonicalDecl_0Delegate(global::System.IntPtr instance);
            private static _getCanonicalDecl_0Delegate _getCanonicalDecl_0DelegateInstance;

            private static global::System.IntPtr _getCanonicalDecl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (ValueDecl) _References[instance].Target;
                var __ret = __target.getCanonicalDecl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // Decl *getNextRedeclarationImpl()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getNextRedeclarationImpl_0Delegate(global::System.IntPtr instance);
            private static _getNextRedeclarationImpl_0Delegate _getNextRedeclarationImpl_0DelegateInstance;

            private static global::System.IntPtr _getNextRedeclarationImpl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (ValueDecl) _References[instance].Target;
                var __ret = __target.getNextRedeclarationImpl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // Decl *getPreviousDeclImpl()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getPreviousDeclImpl_0Delegate(global::System.IntPtr instance);
            private static _getPreviousDeclImpl_0Delegate _getPreviousDeclImpl_0DelegateInstance;

            private static global::System.IntPtr _getPreviousDeclImpl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (ValueDecl) _References[instance].Target;
                var __ret = __target.getPreviousDeclImpl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // Decl *getMostRecentDeclImpl()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getMostRecentDeclImpl_0Delegate(global::System.IntPtr instance);
            private static _getMostRecentDeclImpl_0Delegate _getMostRecentDeclImpl_0DelegateInstance;

            private static global::System.IntPtr _getMostRecentDeclImpl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (ValueDecl) _References[instance].Target;
                var __ret = __target.getMostRecentDeclImpl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // Stmt* getBody() const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getBody_0Delegate(global::System.IntPtr instance);
            private static _getBody_0Delegate _getBody_0DelegateInstance;

            private static global::System.IntPtr _getBody_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (ValueDecl) _References[instance].Target;
                var __ret = __target.getBody();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // bool hasBody() const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate bool _hasBody_0Delegate(global::System.IntPtr instance);
            private static _hasBody_0Delegate _hasBody_0DelegateInstance;

            private static bool _hasBody_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (ValueDecl) _References[instance].Target;
                var __ret = __target.hasBody();
                return __ret;
            }

            // void getNameForDiagnostic(raw_ostream &OS, const PrintingPolicy &Policy, bool Qualified) const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate void _getNameForDiagnostic_0Delegate(global::System.IntPtr instance, global::System.IntPtr OS, global::System.IntPtr Policy, bool Qualified);
            private static _getNameForDiagnostic_0Delegate _getNameForDiagnostic_0DelegateInstance;

            private static void _getNameForDiagnostic_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr OS, global::System.IntPtr Policy, bool Qualified)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (ValueDecl) _References[instance].Target;
                llvm.raw_ostream __result0;
                if (OS == IntPtr.Zero) __result0 = null;
                else if (llvm.raw_ostream.NativeToManagedMap.ContainsKey(OS))
                    __result0 = (llvm.raw_ostream) llvm.raw_ostream.NativeToManagedMap[OS];
                else llvm.raw_ostream.NativeToManagedMap[OS] = __result0 = (llvm.raw_ostream) llvm.raw_ostream.__CreateInstance(OS);
                clang.PrintingPolicy __result1;
                if (Policy == IntPtr.Zero) __result1 = null;
                else if (clang.PrintingPolicy.NativeToManagedMap.ContainsKey(Policy))
                    __result1 = (clang.PrintingPolicy) clang.PrintingPolicy.NativeToManagedMap[Policy];
                else __result1 = clang.PrintingPolicy.__CreateInstance(Policy);
                __target.getNameForDiagnostic(__result0, __result1, Qualified);
            }

            private static void*[] _OldVTables;
            private static void*[] _NewVTables;
            private static void*[] _Thunks;
            private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

            void SetupVTables(global::System.IntPtr instance)
            {
                var native = (Internal*)instance.ToPointer();

                if (_References == null)
                    _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

                if (_References.ContainsKey(instance))
                    return;

                _References[instance] = new WeakReference(this);

                if (_OldVTables == null)
                {
                    _OldVTables = new void*[1];
                    _OldVTables[0] = native->vfptr0.ToPointer();
                }

                if (_Thunks == null)
                {
                    _Thunks = new void*[10];
                    _dtor_0DelegateInstance += _dtor_0DelegateHook;
                    _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                    _getSourceRange_0DelegateInstance += _getSourceRange_0DelegateHook;
                    _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_getSourceRange_0DelegateInstance).ToPointer();
                    _isOutOfLine_0DelegateInstance += _isOutOfLine_0DelegateHook;
                    _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_isOutOfLine_0DelegateInstance).ToPointer();
                    _getCanonicalDecl_0DelegateInstance += _getCanonicalDecl_0DelegateHook;
                    _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_getCanonicalDecl_0DelegateInstance).ToPointer();
                    _getNextRedeclarationImpl_0DelegateInstance += _getNextRedeclarationImpl_0DelegateHook;
                    _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_getNextRedeclarationImpl_0DelegateInstance).ToPointer();
                    _getPreviousDeclImpl_0DelegateInstance += _getPreviousDeclImpl_0DelegateHook;
                    _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_getPreviousDeclImpl_0DelegateInstance).ToPointer();
                    _getMostRecentDeclImpl_0DelegateInstance += _getMostRecentDeclImpl_0DelegateHook;
                    _Thunks[6] = Marshal.GetFunctionPointerForDelegate(_getMostRecentDeclImpl_0DelegateInstance).ToPointer();
                    _getBody_0DelegateInstance += _getBody_0DelegateHook;
                    _Thunks[7] = Marshal.GetFunctionPointerForDelegate(_getBody_0DelegateInstance).ToPointer();
                    _hasBody_0DelegateInstance += _hasBody_0DelegateHook;
                    _Thunks[8] = Marshal.GetFunctionPointerForDelegate(_hasBody_0DelegateInstance).ToPointer();
                    _getNameForDiagnostic_0DelegateInstance += _getNameForDiagnostic_0DelegateHook;
                    _Thunks[9] = Marshal.GetFunctionPointerForDelegate(_getNameForDiagnostic_0DelegateInstance).ToPointer();
                }

                if (_NewVTables == null)
                {
                    _NewVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(11 * 8);
                    _NewVTables[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + 8) = _Thunks[0];
                    *(void**)(vfptr0 + 16) = _Thunks[1];
                    *(void**)(vfptr0 + 24) = _Thunks[2];
                    *(void**)(vfptr0 + 32) = _Thunks[3];
                    *(void**)(vfptr0 + 40) = _Thunks[4];
                    *(void**)(vfptr0 + 48) = _Thunks[5];
                    *(void**)(vfptr0 + 56) = _Thunks[6];
                    *(void**)(vfptr0 + 64) = _Thunks[7];
                    *(void**)(vfptr0 + 72) = _Thunks[8];
                    *(void**)(vfptr0 + 80) = *(void**)(native->vfptr0 + 80);
                    *(void**)(vfptr0 + 88) = _Thunks[9];
                }

                native->vfptr0 = new IntPtr(_NewVTables[0]);
            }

            #endregion
        }

        /// <summary>
        /// <para>QualifierInfo - A struct with extended info about a syntactic
        /// name qualifier, to be used for the case of out-of-line declarations.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// QualifierInfo - A struct with extended info about a
        /// syntactic</para>
        /// <para>/// name qualifier, to be used for the case of out-of-line
        /// declarations.</para>
        /// </remarks>
        public unsafe partial class QualifierInfo : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 32)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public clang.NestedNameSpecifierLoc.Internal QualifierLoc;

                [FieldOffset(16)]
                public uint NumTemplParamLists;

                [FieldOffset(24)]
                public global::System.IntPtr TemplParamLists;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13QualifierInfoC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, QualifierInfo> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, QualifierInfo>();

            private readonly bool __ownsNativeInstance;

            public static QualifierInfo __CreateInstance(global::System.IntPtr native)
            {
                return new QualifierInfo((QualifierInfo.Internal*) native);
            }

            public static QualifierInfo __CreateInstance(QualifierInfo.Internal native)
            {
                return new QualifierInfo(native);
            }

            private static QualifierInfo.Internal* __CopyValue(QualifierInfo.Internal native)
            {
                var ret = (QualifierInfo.Internal*) Marshal.AllocHGlobal(32);
                *ret = native;
                return ret;
            }

            private QualifierInfo(QualifierInfo.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected QualifierInfo(QualifierInfo.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            /// <summary>
            /// <para>Default constructor.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Default constructor.</para>
            /// </remarks>
            public QualifierInfo()
            {
                __Instance = Marshal.AllocHGlobal(32);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.QualifierInfo __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.NestedNameSpecifierLoc QualifierLoc
            {
                get
                {
                    return clang.NestedNameSpecifierLoc.__CreateInstance(((Internal*) __Instance)->QualifierLoc);
                }

                set
                {
                    ((Internal*) __Instance)->QualifierLoc = ReferenceEquals(value, null) ? new clang.NestedNameSpecifierLoc.Internal() : *(clang.NestedNameSpecifierLoc.Internal*) (value.__Instance);
                }
            }

            public uint NumTemplParamLists
            {
                get
                {
                    return ((Internal*) __Instance)->NumTemplParamLists;
                }

                set
                {
                    ((Internal*) __Instance)->NumTemplParamLists = value;
                }
            }
        }

        /// <summary>
        /// <para>Represents a ValueDecl that came out of a declarator. Contains
        /// type source information through TypeSourceInfo.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief Represents a ValueDecl that came out of a
        /// declarator.</para>
        /// <para>/// Contains type source information through
        /// TypeSourceInfo.</para>
        /// </remarks>
        public unsafe partial class DeclaratorDecl : clang.ValueDecl, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 64)]
            public new partial struct Internal
            {
                [FieldOffset(8)]
                internal llvm.PointerIntPair.Internal NextInContextAndBits;

                [FieldOffset(16)]
                internal llvm.PointerUnion.Internal DeclCtx;

                [FieldOffset(24)]
                public clang.SourceLocation.Internal Loc;

                [FieldOffset(28)]
                public uint DeclKind;

                [FieldOffset(29)]
                public uint InvalidDecl;

                [FieldOffset(29)]
                public uint HasAttrs;

                [FieldOffset(29)]
                public uint Implicit;

                [FieldOffset(29)]
                public uint Used;

                [FieldOffset(29)]
                public uint Referenced;

                [FieldOffset(29)]
                public uint Access;

                [FieldOffset(29)]
                public uint FromASTFile;

                [FieldOffset(30)]
                public uint Hidden;

                [FieldOffset(30)]
                public uint IdentifierNamespace;

                [FieldOffset(31)]
                public uint CacheValidAndLinkage;

                [FieldOffset(32)]
                public clang.DeclarationName.Internal Name;

                [FieldOffset(40)]
                public clang.QualType.Internal DeclType;

                [FieldOffset(48)]
                internal llvm.PointerUnion.Internal DeclInfo;

                [FieldOffset(56)]
                public clang.SourceLocation.Internal InnerLocStart;

                [FieldOffset(0)]
                public global::System.IntPtr vfptr0;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14DeclaratorDeclC2ENS_4Decl4KindEPNS_11DeclContextENS_14SourceLocationENS_15DeclarationNameENS_8QualTypeEPNS_14TypeSourceInfoES5_")]
                internal static extern void ctor_0(global::System.IntPtr instance, clang.Decl.Kind DK, global::System.IntPtr DC, clang.SourceLocation.Internal L, clang.DeclarationName.Internal N, clang.QualType.Internal T, global::System.IntPtr TInfo, clang.SourceLocation.Internal StartL);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14DeclaratorDeclC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14DeclaratorDeclD2Ev")]
                internal static extern void dtor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14DeclaratorDecl17getTypeSourceInfoEv")]
                internal static extern global::System.IntPtr getTypeSourceInfo_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14DeclaratorDecl17setTypeSourceInfoEPNS_14TypeSourceInfoE")]
                internal static extern void setTypeSourceInfo_0(global::System.IntPtr instance, global::System.IntPtr TI);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14DeclaratorDecl16getInnerLocStartEv")]
                internal static extern clang.SourceLocation.Internal getInnerLocStart_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14DeclaratorDecl16setInnerLocStartENS_14SourceLocationE")]
                internal static extern void setInnerLocStart_0(global::System.IntPtr instance, clang.SourceLocation.Internal L);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14DeclaratorDecl16getOuterLocStartEv")]
                internal static extern clang.SourceLocation.Internal getOuterLocStart_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14DeclaratorDecl14getSourceRangeEv")]
                internal static extern clang.SourceRange.Internal getSourceRange_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14DeclaratorDecl11getLocStartEv")]
                internal static extern clang.SourceLocation.Internal getLocStart_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14DeclaratorDecl12getQualifierEv")]
                internal static extern global::System.IntPtr getQualifier_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14DeclaratorDecl15getQualifierLocEv")]
                internal static extern clang.NestedNameSpecifierLoc.Internal getQualifierLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14DeclaratorDecl16setQualifierInfoENS_22NestedNameSpecifierLocE")]
                internal static extern void setQualifierInfo_0(global::System.IntPtr instance, clang.NestedNameSpecifierLoc.Internal QualifierLoc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14DeclaratorDecl28getNumTemplateParameterListsEv")]
                internal static extern uint getNumTemplateParameterLists_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14DeclaratorDecl19getTypeSpecStartLocEv")]
                internal static extern clang.SourceLocation.Internal getTypeSpecStartLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14DeclaratorDecl7classofEPKNS_4DeclE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr D);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14DeclaratorDecl11classofKindENS_4Decl4KindE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classofKind_0(clang.Decl.Kind K);
            }

            internal unsafe partial class ExtInfo
            {
                [StructLayout(LayoutKind.Explicit, Size = 40)]
                public new partial struct Internal
                {
                    [FieldOffset(0)]
                    public clang.NestedNameSpecifierLoc.Internal QualifierLoc;

                    [FieldOffset(16)]
                    public uint NumTemplParamLists;

                    [FieldOffset(24)]
                    public global::System.IntPtr TemplParamLists;

                    [FieldOffset(32)]
                    public global::System.IntPtr TInfo;
                }
            }

            private readonly bool __ownsNativeInstance;

            public static new DeclaratorDecl __CreateInstance(global::System.IntPtr native)
            {
                return new DeclaratorDecl((DeclaratorDecl.Internal*) native);
            }

            public static DeclaratorDecl __CreateInstance(DeclaratorDecl.Internal native)
            {
                return new DeclaratorDecl(native);
            }

            private static DeclaratorDecl.Internal* __CopyValue(DeclaratorDecl.Internal native)
            {
                var ret = (DeclaratorDecl.Internal*) Marshal.AllocHGlobal(64);
                *ret = native;
                return ret;
            }

            private DeclaratorDecl(DeclaratorDecl.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected DeclaratorDecl(DeclaratorDecl.Internal* native, bool isInternalImpl = false)
                : base((clang.ValueDecl.Internal*) native)
            {
            }

            protected DeclaratorDecl(clang.Decl.Kind DK, clang.DeclContext DC, clang.SourceLocation L, clang.DeclarationName N, clang.QualType T, clang.TypeSourceInfo TInfo, clang.SourceLocation StartL)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(64);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = DK;
                var arg1 = ReferenceEquals(DC, null) ? global::System.IntPtr.Zero : DC.__Instance;
                var arg2 = ReferenceEquals(L, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (L.__Instance);
                var arg3 = ReferenceEquals(N, null) ? new clang.DeclarationName.Internal() : *(clang.DeclarationName.Internal*) (N.__Instance);
                var arg4 = ReferenceEquals(T, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (T.__Instance);
                var arg5 = ReferenceEquals(TInfo, null) ? global::System.IntPtr.Zero : TInfo.__Instance;
                var arg6 = ReferenceEquals(StartL, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (StartL.__Instance);
                Internal.ctor_0(__Instance, arg0, arg1, arg2, arg3, arg4, arg5, arg6);
                SetupVTables(__Instance);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Decl __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.TypeSourceInfo getTypeSourceInfo()
            {
                var __ret = Internal.getTypeSourceInfo_0(__Instance);
                clang.TypeSourceInfo __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.TypeSourceInfo.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.TypeSourceInfo) clang.TypeSourceInfo.NativeToManagedMap[__ret];
                else __result0 = clang.TypeSourceInfo.__CreateInstance(__ret);
                return __result0;
            }

            public void setTypeSourceInfo(clang.TypeSourceInfo TI)
            {
                var arg0 = ReferenceEquals(TI, null) ? global::System.IntPtr.Zero : TI.__Instance;
                Internal.setTypeSourceInfo_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>getInnerLocStart - Return SourceLocation representing start of
            /// source range ignoring outer template declarations.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getInnerLocStart - Return SourceLocation representing start
            /// of source</para>
            /// <para>  /// range ignoring outer template declarations.</para>
            /// </remarks>
            public clang.SourceLocation getInnerLocStart()
            {
                var __ret = Internal.getInnerLocStart_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setInnerLocStart(clang.SourceLocation L)
            {
                var arg0 = ReferenceEquals(L, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (L.__Instance);
                Internal.setInnerLocStart_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>getOuterLocStart - Return SourceLocation representing start of
            /// source range taking into account any outer template declarations.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getOuterLocStart - Return SourceLocation representing start
            /// of source</para>
            /// <para>  /// range taking into account any outer template
            /// declarations.</para>
            /// </remarks>
            public clang.SourceLocation getOuterLocStart()
            {
                var __ret = Internal.getOuterLocStart_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public override clang.SourceRange getSourceRange()
            {
                var __ret = Internal.getSourceRange_0(__Instance);
                return clang.SourceRange.__CreateInstance(__ret);
            }

            public clang.SourceLocation getLocStart()
            {
                var __ret = Internal.getLocStart_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Retrieve the nested-name-specifier that qualifies the name of
            /// this declaration, if it was present in the source.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the nested-name-specifier that qualifies the
            /// name of this</para>
            /// <para>  /// declaration, if it was present in the source.</para>
            /// </remarks>
            public clang.NestedNameSpecifier getQualifier()
            {
                var __ret = Internal.getQualifier_0(__Instance);
                clang.NestedNameSpecifier __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.NestedNameSpecifier.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.NestedNameSpecifier) clang.NestedNameSpecifier.NativeToManagedMap[__ret];
                else __result0 = clang.NestedNameSpecifier.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Retrieve the nested-name-specifier (with source-location
            /// information) that qualifies the name of this declaration, if it was present
            /// in the source.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the nested-name-specifier (with
            /// source-location</para>
            /// <para>  /// information) that qualifies the name of this declaration,
            /// if it was</para>
            /// <para>  /// present in the source.</para>
            /// </remarks>
            public clang.NestedNameSpecifierLoc getQualifierLoc()
            {
                var __ret = Internal.getQualifierLoc_0(__Instance);
                return clang.NestedNameSpecifierLoc.__CreateInstance(__ret);
            }

            public void setQualifierInfo(clang.NestedNameSpecifierLoc QualifierLoc)
            {
                var arg0 = ReferenceEquals(QualifierLoc, null) ? new clang.NestedNameSpecifierLoc.Internal() : *(clang.NestedNameSpecifierLoc.Internal*) (QualifierLoc.__Instance);
                Internal.setQualifierInfo_0(__Instance, arg0);
            }

            public uint getNumTemplateParameterLists()
            {
                var __ret = Internal.getNumTemplateParameterLists_0(__Instance);
                return __ret;
            }

            public clang.SourceLocation getTypeSpecStartLoc()
            {
                var __ret = Internal.getTypeSpecStartLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public static bool classof(clang.Decl D)
            {
                var arg0 = ReferenceEquals(D, null) ? global::System.IntPtr.Zero : D.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }

            public static bool classofKind(clang.Decl.Kind K)
            {
                var arg0 = K;
                var __ret = Internal.classofKind_0(arg0);
                return __ret;
            }

            #region Virtual table interop

            // DeclaratorDecl
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
            private static _dtor_0Delegate _dtor_0DelegateInstance;

            private static void _dtor_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (DeclaratorDecl) _References[instance].Target;
                __target.DestroyNativeInstance();
            }

            // SourceRange getSourceRange() const override
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate clang.SourceRange.Internal _getSourceRange_0Delegate(global::System.IntPtr instance);
            private static _getSourceRange_0Delegate _getSourceRange_0DelegateInstance;

            private static clang.SourceRange.Internal _getSourceRange_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (DeclaratorDecl) _References[instance].Target;
                var __ret = __target.getSourceRange();
                return ReferenceEquals(__ret, null) ? new clang.SourceRange.Internal() : *(clang.SourceRange.Internal*) (__ret.__Instance);
            }

            // bool isOutOfLine() const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate bool _isOutOfLine_0Delegate(global::System.IntPtr instance);
            private static _isOutOfLine_0Delegate _isOutOfLine_0DelegateInstance;

            private static bool _isOutOfLine_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (DeclaratorDecl) _References[instance].Target;
                var __ret = __target.isOutOfLine();
                return __ret;
            }

            // Decl *getCanonicalDecl()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getCanonicalDecl_0Delegate(global::System.IntPtr instance);
            private static _getCanonicalDecl_0Delegate _getCanonicalDecl_0DelegateInstance;

            private static global::System.IntPtr _getCanonicalDecl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (DeclaratorDecl) _References[instance].Target;
                var __ret = __target.getCanonicalDecl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // Decl *getNextRedeclarationImpl()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getNextRedeclarationImpl_0Delegate(global::System.IntPtr instance);
            private static _getNextRedeclarationImpl_0Delegate _getNextRedeclarationImpl_0DelegateInstance;

            private static global::System.IntPtr _getNextRedeclarationImpl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (DeclaratorDecl) _References[instance].Target;
                var __ret = __target.getNextRedeclarationImpl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // Decl *getPreviousDeclImpl()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getPreviousDeclImpl_0Delegate(global::System.IntPtr instance);
            private static _getPreviousDeclImpl_0Delegate _getPreviousDeclImpl_0DelegateInstance;

            private static global::System.IntPtr _getPreviousDeclImpl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (DeclaratorDecl) _References[instance].Target;
                var __ret = __target.getPreviousDeclImpl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // Decl *getMostRecentDeclImpl()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getMostRecentDeclImpl_0Delegate(global::System.IntPtr instance);
            private static _getMostRecentDeclImpl_0Delegate _getMostRecentDeclImpl_0DelegateInstance;

            private static global::System.IntPtr _getMostRecentDeclImpl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (DeclaratorDecl) _References[instance].Target;
                var __ret = __target.getMostRecentDeclImpl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // Stmt* getBody() const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getBody_0Delegate(global::System.IntPtr instance);
            private static _getBody_0Delegate _getBody_0DelegateInstance;

            private static global::System.IntPtr _getBody_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (DeclaratorDecl) _References[instance].Target;
                var __ret = __target.getBody();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // bool hasBody() const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate bool _hasBody_0Delegate(global::System.IntPtr instance);
            private static _hasBody_0Delegate _hasBody_0DelegateInstance;

            private static bool _hasBody_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (DeclaratorDecl) _References[instance].Target;
                var __ret = __target.hasBody();
                return __ret;
            }

            // void getNameForDiagnostic(raw_ostream &OS, const PrintingPolicy &Policy, bool Qualified) const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate void _getNameForDiagnostic_0Delegate(global::System.IntPtr instance, global::System.IntPtr OS, global::System.IntPtr Policy, bool Qualified);
            private static _getNameForDiagnostic_0Delegate _getNameForDiagnostic_0DelegateInstance;

            private static void _getNameForDiagnostic_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr OS, global::System.IntPtr Policy, bool Qualified)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (DeclaratorDecl) _References[instance].Target;
                llvm.raw_ostream __result0;
                if (OS == IntPtr.Zero) __result0 = null;
                else if (llvm.raw_ostream.NativeToManagedMap.ContainsKey(OS))
                    __result0 = (llvm.raw_ostream) llvm.raw_ostream.NativeToManagedMap[OS];
                else llvm.raw_ostream.NativeToManagedMap[OS] = __result0 = (llvm.raw_ostream) llvm.raw_ostream.__CreateInstance(OS);
                clang.PrintingPolicy __result1;
                if (Policy == IntPtr.Zero) __result1 = null;
                else if (clang.PrintingPolicy.NativeToManagedMap.ContainsKey(Policy))
                    __result1 = (clang.PrintingPolicy) clang.PrintingPolicy.NativeToManagedMap[Policy];
                else __result1 = clang.PrintingPolicy.__CreateInstance(Policy);
                __target.getNameForDiagnostic(__result0, __result1, Qualified);
            }

            private static void*[] _OldVTables;
            private static void*[] _NewVTables;
            private static void*[] _Thunks;
            private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

            void SetupVTables(global::System.IntPtr instance)
            {
                var native = (Internal*)instance.ToPointer();

                if (_References == null)
                    _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

                if (_References.ContainsKey(instance))
                    return;

                _References[instance] = new WeakReference(this);

                if (_OldVTables == null)
                {
                    _OldVTables = new void*[1];
                    _OldVTables[0] = native->vfptr0.ToPointer();
                }

                if (_Thunks == null)
                {
                    _Thunks = new void*[10];
                    _dtor_0DelegateInstance += _dtor_0DelegateHook;
                    _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                    _getSourceRange_0DelegateInstance += _getSourceRange_0DelegateHook;
                    _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_getSourceRange_0DelegateInstance).ToPointer();
                    _isOutOfLine_0DelegateInstance += _isOutOfLine_0DelegateHook;
                    _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_isOutOfLine_0DelegateInstance).ToPointer();
                    _getCanonicalDecl_0DelegateInstance += _getCanonicalDecl_0DelegateHook;
                    _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_getCanonicalDecl_0DelegateInstance).ToPointer();
                    _getNextRedeclarationImpl_0DelegateInstance += _getNextRedeclarationImpl_0DelegateHook;
                    _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_getNextRedeclarationImpl_0DelegateInstance).ToPointer();
                    _getPreviousDeclImpl_0DelegateInstance += _getPreviousDeclImpl_0DelegateHook;
                    _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_getPreviousDeclImpl_0DelegateInstance).ToPointer();
                    _getMostRecentDeclImpl_0DelegateInstance += _getMostRecentDeclImpl_0DelegateHook;
                    _Thunks[6] = Marshal.GetFunctionPointerForDelegate(_getMostRecentDeclImpl_0DelegateInstance).ToPointer();
                    _getBody_0DelegateInstance += _getBody_0DelegateHook;
                    _Thunks[7] = Marshal.GetFunctionPointerForDelegate(_getBody_0DelegateInstance).ToPointer();
                    _hasBody_0DelegateInstance += _hasBody_0DelegateHook;
                    _Thunks[8] = Marshal.GetFunctionPointerForDelegate(_hasBody_0DelegateInstance).ToPointer();
                    _getNameForDiagnostic_0DelegateInstance += _getNameForDiagnostic_0DelegateHook;
                    _Thunks[9] = Marshal.GetFunctionPointerForDelegate(_getNameForDiagnostic_0DelegateInstance).ToPointer();
                }

                if (_NewVTables == null)
                {
                    _NewVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(11 * 8);
                    _NewVTables[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + 8) = _Thunks[0];
                    *(void**)(vfptr0 + 16) = _Thunks[1];
                    *(void**)(vfptr0 + 24) = _Thunks[2];
                    *(void**)(vfptr0 + 32) = _Thunks[3];
                    *(void**)(vfptr0 + 40) = _Thunks[4];
                    *(void**)(vfptr0 + 48) = _Thunks[5];
                    *(void**)(vfptr0 + 56) = _Thunks[6];
                    *(void**)(vfptr0 + 64) = _Thunks[7];
                    *(void**)(vfptr0 + 72) = _Thunks[8];
                    *(void**)(vfptr0 + 80) = *(void**)(native->vfptr0 + 80);
                    *(void**)(vfptr0 + 88) = _Thunks[9];
                }

                native->vfptr0 = new IntPtr(_NewVTables[0]);
            }

            #endregion
        }

        /// <summary>
        /// <para>Structure used to store a statement, the constant value to which
        /// it was evaluated (if any), and whether or not the statement is an integral
        /// constant expression (if known).</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief Structure used to store a statement, the constant
        /// value to</para>
        /// <para>/// which it was evaluated (if any), and whether or not the
        /// statement</para>
        /// <para>/// is an integral constant expression (if known).</para>
        /// </remarks>
        public unsafe partial class EvaluatedStmt : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 72)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public bool WasEvaluated;

                [FieldOffset(0)]
                public bool IsEvaluating;

                [FieldOffset(0)]
                public bool CheckedICE;

                [FieldOffset(0)]
                public bool CheckingICE;

                [FieldOffset(0)]
                public bool IsICE;

                [FieldOffset(8)]
                public global::System.IntPtr Value;

                [FieldOffset(16)]
                public clang.APValue.Internal Evaluated;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13EvaluatedStmtC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13EvaluatedStmtC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13EvaluatedStmtD2Ev")]
                internal static extern void dtor_0(global::System.IntPtr instance);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, EvaluatedStmt> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, EvaluatedStmt>();

            private readonly bool __ownsNativeInstance;

            public static EvaluatedStmt __CreateInstance(global::System.IntPtr native)
            {
                return new EvaluatedStmt((EvaluatedStmt.Internal*) native);
            }

            public static EvaluatedStmt __CreateInstance(EvaluatedStmt.Internal native)
            {
                return new EvaluatedStmt(native);
            }

            private static EvaluatedStmt.Internal* __CopyValue(EvaluatedStmt.Internal native)
            {
                var ret = (EvaluatedStmt.Internal*) Marshal.AllocHGlobal(72);
                *ret = native;
                return ret;
            }

            private EvaluatedStmt(EvaluatedStmt.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected EvaluatedStmt(EvaluatedStmt.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public EvaluatedStmt()
            {
                __Instance = Marshal.AllocHGlobal(72);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.EvaluatedStmt __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance || force)
                    Internal.dtor_0(__Instance);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public bool WasEvaluated
            {
                get
                {
                    return ((Internal*) __Instance)->WasEvaluated;
                }

                set
                {
                    ((Internal*) __Instance)->WasEvaluated = value;
                }
            }

            public bool IsEvaluating
            {
                get
                {
                    return ((Internal*) __Instance)->IsEvaluating;
                }

                set
                {
                    ((Internal*) __Instance)->IsEvaluating = value;
                }
            }

            public bool CheckedICE
            {
                get
                {
                    return ((Internal*) __Instance)->CheckedICE;
                }

                set
                {
                    ((Internal*) __Instance)->CheckedICE = value;
                }
            }

            public bool CheckingICE
            {
                get
                {
                    return ((Internal*) __Instance)->CheckingICE;
                }

                set
                {
                    ((Internal*) __Instance)->CheckingICE = value;
                }
            }

            public bool IsICE
            {
                get
                {
                    return ((Internal*) __Instance)->IsICE;
                }

                set
                {
                    ((Internal*) __Instance)->IsICE = value;
                }
            }

            public clang.Stmt Value
            {
                get
                {
                    clang.Stmt __result0;
                    if (((Internal*) __Instance)->Value == IntPtr.Zero) __result0 = null;
                    else if (clang.Stmt.NativeToManagedMap.ContainsKey(((Internal*) __Instance)->Value))
                        __result0 = (clang.Stmt) clang.Stmt.NativeToManagedMap[((Internal*) __Instance)->Value];
                    else __result0 = clang.Stmt.__CreateInstance(((Internal*) __Instance)->Value);
                    return __result0;
                }

                set
                {
                    ((Internal*) __Instance)->Value = ReferenceEquals(value, null) ? global::System.IntPtr.Zero : value.__Instance;
                }
            }

            public clang.APValue Evaluated
            {
                get
                {
                    return clang.APValue.__CreateInstance(((Internal*) __Instance)->Evaluated);
                }

                set
                {
                    ((Internal*) __Instance)->Evaluated = ReferenceEquals(value, null) ? new clang.APValue.Internal() : *(clang.APValue.Internal*) (value.__Instance);
                }
            }
        }

        /// <summary>
        /// <para>VarDecl - An instance of this class is created to represent a
        /// variable declaration or definition.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// VarDecl - An instance of this class is created to represent a
        /// variable</para>
        /// <para>/// declaration or definition.</para>
        /// </remarks>
        public unsafe partial class VarDecl : clang.DeclaratorDecl, clang.Redeclarable, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 88)]
            public new partial struct Internal
            {
                [FieldOffset(8)]
                internal llvm.PointerIntPair.Internal NextInContextAndBits;

                [FieldOffset(16)]
                internal llvm.PointerUnion.Internal DeclCtx;

                [FieldOffset(24)]
                public clang.SourceLocation.Internal Loc;

                [FieldOffset(28)]
                public uint DeclKind;

                [FieldOffset(29)]
                public uint InvalidDecl;

                [FieldOffset(29)]
                public uint HasAttrs;

                [FieldOffset(29)]
                public uint Implicit;

                [FieldOffset(29)]
                public uint Used;

                [FieldOffset(29)]
                public uint Referenced;

                [FieldOffset(29)]
                public uint Access;

                [FieldOffset(29)]
                public uint FromASTFile;

                [FieldOffset(30)]
                public uint Hidden;

                [FieldOffset(30)]
                public uint IdentifierNamespace;

                [FieldOffset(31)]
                public uint CacheValidAndLinkage;

                [FieldOffset(32)]
                public clang.DeclarationName.Internal Name;

                [FieldOffset(40)]
                public clang.QualType.Internal DeclType;

                [FieldOffset(48)]
                internal llvm.PointerUnion.Internal DeclInfo;

                [FieldOffset(56)]
                public clang.SourceLocation.Internal InnerLocStart;

                [FieldOffset(72)]
                internal llvm.PointerUnion4.Internal Init;

                [FieldOffset(80)]
                internal clang.VarDecl._.Internal __;

                [FieldOffset(0)]
                public global::System.IntPtr vfptr0;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang7VarDeclC2ENS_4Decl4KindERNS_10ASTContextEPNS_11DeclContextENS_14SourceLocationES7_PNS_14IdentifierInfoENS_8QualTypeEPNS_14TypeSourceInfoENS_12StorageClassE")]
                internal static extern void ctor_0(global::System.IntPtr instance, clang.Decl.Kind DK, global::System.IntPtr C, global::System.IntPtr DC, clang.SourceLocation.Internal StartLoc, clang.SourceLocation.Internal IdLoc, global::System.IntPtr Id, clang.QualType.Internal T, global::System.IntPtr TInfo, clang.StorageClass SC);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang7VarDeclC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang7VarDeclD2Ev")]
                internal static extern void dtor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang7VarDecl30getStorageClassSpecifierStringENS_12StorageClassE")]
                internal static extern global::System.IntPtr getStorageClassSpecifierString_0(clang.StorageClass SC);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang7VarDecl24getNextRedeclarationImplEv")]
                internal static extern global::System.IntPtr getNextRedeclarationImpl_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang7VarDecl19getPreviousDeclImplEv")]
                internal static extern global::System.IntPtr getPreviousDeclImpl_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang7VarDecl21getMostRecentDeclImplEv")]
                internal static extern global::System.IntPtr getMostRecentDeclImpl_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang7VarDecl6CreateERNS_10ASTContextEPNS_11DeclContextENS_14SourceLocationES5_PNS_14IdentifierInfoENS_8QualTypeEPNS_14TypeSourceInfoENS_12StorageClassE")]
                internal static extern global::System.IntPtr Create_0(global::System.IntPtr C, global::System.IntPtr DC, clang.SourceLocation.Internal StartLoc, clang.SourceLocation.Internal IdLoc, global::System.IntPtr Id, clang.QualType.Internal T, global::System.IntPtr TInfo, clang.StorageClass S);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang7VarDecl18CreateDeserializedERNS_10ASTContextEj")]
                internal static extern global::System.IntPtr CreateDeserialized_0(global::System.IntPtr C, uint ID);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7VarDecl14getSourceRangeEv")]
                internal static extern clang.SourceRange.Internal getSourceRange_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7VarDecl15getStorageClassEv")]
                internal static extern clang.StorageClass getStorageClass_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang7VarDecl15setStorageClassENS_12StorageClassE")]
                internal static extern void setStorageClass_0(global::System.IntPtr instance, clang.StorageClass SC);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang7VarDecl10setTSCSpecENS_27ThreadStorageClassSpecifierE")]
                internal static extern void setTSCSpec_0(global::System.IntPtr instance, clang.ThreadStorageClassSpecifier TSC);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7VarDecl10getTSCSpecEv")]
                internal static extern clang.ThreadStorageClassSpecifier getTSCSpec_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7VarDecl10getTLSKindEv")]
                internal static extern clang.VarDecl.TLSKind getTLSKind_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7VarDecl15hasLocalStorageEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasLocalStorage_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7VarDecl13isStaticLocalEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isStaticLocal_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7VarDecl18hasExternalStorageEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasExternalStorage_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7VarDecl16hasGlobalStorageEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasGlobalStorage_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7VarDecl18getStorageDurationEv")]
                internal static extern clang.StorageDuration getStorageDuration_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7VarDecl18getLanguageLinkageEv")]
                internal static extern clang.LanguageLinkage getLanguageLinkage_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7VarDecl9isExternCEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isExternC_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7VarDecl18isInExternCContextEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isInExternCContext_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7VarDecl20isInExternCXXContextEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isInExternCXXContext_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7VarDecl14isLocalVarDeclEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isLocalVarDecl_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7VarDecl20isLocalVarDeclOrParmEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isLocalVarDeclOrParm_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7VarDecl25isFunctionOrMethodVarDeclEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isFunctionOrMethodVarDecl_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7VarDecl18isStaticDataMemberEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isStaticDataMember_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang7VarDecl16getCanonicalDeclEv")]
                internal static extern global::System.IntPtr getCanonicalDecl_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7VarDecl28isThisDeclarationADefinitionERNS_10ASTContextE")]
                internal static extern clang.VarDecl.DefinitionKind isThisDeclarationADefinition_0(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7VarDecl28isThisDeclarationADefinitionEv")]
                internal static extern clang.VarDecl.DefinitionKind isThisDeclarationADefinition_1(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7VarDecl13hasDefinitionERNS_10ASTContextE")]
                internal static extern clang.VarDecl.DefinitionKind hasDefinition_0(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7VarDecl13hasDefinitionEv")]
                internal static extern clang.VarDecl.DefinitionKind hasDefinition_1(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang7VarDecl19getActingDefinitionEv")]
                internal static extern global::System.IntPtr getActingDefinition_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang7VarDecl13getDefinitionERNS_10ASTContextE")]
                internal static extern global::System.IntPtr getDefinition_0(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang7VarDecl13getDefinitionEv")]
                internal static extern global::System.IntPtr getDefinition_2(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7VarDecl11isOutOfLineEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isOutOfLine_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang7VarDecl22getOutOfLineDefinitionEv")]
                internal static extern global::System.IntPtr getOutOfLineDefinition_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7VarDecl13isFileVarDeclEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isFileVarDecl_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7VarDecl7hasInitEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasInit_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang7VarDecl14getInitAddressEv")]
                internal static extern global::System.IntPtr getInitAddress_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7VarDecl29isUsableInConstantExpressionsERNS_10ASTContextE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isUsableInConstantExpressions_0(global::System.IntPtr instance, global::System.IntPtr C);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7VarDecl19ensureEvaluatedStmtEv")]
                internal static extern global::System.IntPtr ensureEvaluatedStmt_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7VarDecl13evaluateValueEv")]
                internal static extern global::System.IntPtr evaluateValue_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7VarDecl17getEvaluatedValueEv")]
                internal static extern global::System.IntPtr getEvaluatedValue_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7VarDecl14isInitKnownICEEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isInitKnownICE_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7VarDecl9isInitICEEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isInitICE_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7VarDecl14checkInitIsICEEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool checkInitIsICE_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang7VarDecl12setInitStyleENS0_19InitializationStyleE")]
                internal static extern void setInitStyle_0(global::System.IntPtr instance, clang.VarDecl.InitializationStyle Style);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7VarDecl12getInitStyleEv")]
                internal static extern clang.VarDecl.InitializationStyle getInitStyle_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7VarDecl12isDirectInitEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isDirectInit_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7VarDecl19isExceptionVariableEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isExceptionVariable_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang7VarDecl20setExceptionVariableEb")]
                internal static extern void setExceptionVariable_0(global::System.IntPtr instance, bool EV);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7VarDecl14isNRVOVariableEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isNRVOVariable_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang7VarDecl15setNRVOVariableEb")]
                internal static extern void setNRVOVariable_0(global::System.IntPtr instance, bool NRVO);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7VarDecl17isCXXForRangeDeclEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isCXXForRangeDecl_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang7VarDecl18setCXXForRangeDeclEb")]
                internal static extern void setCXXForRangeDecl_0(global::System.IntPtr instance, bool FRD);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7VarDecl17isARCPseudoStrongEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isARCPseudoStrong_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang7VarDecl18setARCPseudoStrongEb")]
                internal static extern void setARCPseudoStrong_0(global::System.IntPtr instance, bool ps);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7VarDecl11isConstexprEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isConstexpr_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang7VarDecl12setConstexprEb")]
                internal static extern void setConstexpr_0(global::System.IntPtr instance, bool IC);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7VarDecl13isInitCaptureEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isInitCapture_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang7VarDecl14setInitCaptureEb")]
                internal static extern void setInitCapture_0(global::System.IntPtr instance, bool IC);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7VarDecl30isPreviousDeclInSameBlockScopeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isPreviousDeclInSameBlockScope_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang7VarDecl31setPreviousDeclInSameBlockScopeEb")]
                internal static extern void setPreviousDeclInSameBlockScope_0(global::System.IntPtr instance, bool Same);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7VarDecl35getInstantiatedFromStaticDataMemberEv")]
                internal static extern global::System.IntPtr getInstantiatedFromStaticDataMember_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7VarDecl29getTemplateSpecializationKindEv")]
                internal static extern clang.TemplateSpecializationKind getTemplateSpecializationKind_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7VarDecl23getPointOfInstantiationEv")]
                internal static extern clang.SourceLocation.Internal getPointOfInstantiation_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang7VarDecl29setTemplateSpecializationKindENS_26TemplateSpecializationKindENS_14SourceLocationE")]
                internal static extern void setTemplateSpecializationKind_0(global::System.IntPtr instance, clang.TemplateSpecializationKind TSK, clang.SourceLocation.Internal PointOfInstantiation);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang7VarDecl34setInstantiationOfStaticDataMemberEPS0_NS_26TemplateSpecializationKindE")]
                internal static extern void setInstantiationOfStaticDataMember_0(global::System.IntPtr instance, global::System.IntPtr VD, clang.TemplateSpecializationKind TSK);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang7VarDecl7classofEPKNS_4DeclE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr D);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang7VarDecl11classofKindENS_4Decl4KindE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classofKind_0(clang.Decl.Kind K);
            }

            /// <summary>
            /// <para>Initialization styles.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Initialization styles.</para>
            /// </remarks>
            public enum InitializationStyle : uint
            {
                /// <summary>C-style initialization with assignment</summary>
                CInit = 0,
                /// <summary>Call-style initialization (C++98)</summary>
                CallInit = 1,
                /// <summary>Direct list-initialization (C++11)</summary>
                ListInit = 2
            }

            /// <summary>
            /// <para>Kinds of thread-local storage.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Kinds of thread-local storage.</para>
            /// </remarks>
            public enum TLSKind : uint
            {
                /// <summary>Not a TLS variable.</summary>
                TLS_None = 0,
                /// <summary>TLS with a known-constant initializer.</summary>
                TLS_Static = 1,
                /// <summary>TLS with a dynamic initializer.</summary>
                TLS_Dynamic = 2
            }

            [Flags]
            public enum NumParameterIndexBits : uint
            {
                NumParameterIndexBits = 8
            }

            public enum DefinitionKind : uint
            {
                /// <summary>This declaration is only a declaration.</summary>
                DeclarationOnly = 0,
                /// <summary>This declaration is a tentative definition.</summary>
                TentativeDefinition = 1,
                /// <summary>This declaration is definitely a definition.</summary>
                Definition = 2
            }

            internal unsafe partial class VarDeclBitfields
            {
                [StructLayout(LayoutKind.Explicit, Size = 4)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public uint SClass;

                    [FieldOffset(0)]
                    public uint TSCSpec;

                    [FieldOffset(0)]
                    public uint InitStyle;

                    [FieldOffset(0)]
                    public uint ExceptionVar;

                    [FieldOffset(1)]
                    public uint NRVOVariable;

                    [FieldOffset(1)]
                    public uint CXXForRangeDecl;

                    [FieldOffset(1)]
                    public uint ARCPseudoStrong;

                    [FieldOffset(1)]
                    public uint IsConstexpr;

                    [FieldOffset(1)]
                    public uint IsInitCapture;

                    [FieldOffset(1)]
                    public uint PreviousDeclInSameBlockScope;
                }
            }

            protected internal unsafe partial class ParmVarDeclBitfields : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 4)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public uint _0;

                    [FieldOffset(1)]
                    public uint HasInheritedDefaultArg;

                    [FieldOffset(1)]
                    public uint IsKNRPromoted;

                    [FieldOffset(2)]
                    public uint IsObjCMethodParam;

                    [FieldOffset(2)]
                    public uint ScopeDepthOrObjCQuals;

                    [FieldOffset(3)]
                    public uint ParameterIndex;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang7VarDecl20ParmVarDeclBitfieldsC2ERKS1_")]
                    internal static extern void cctor_0(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ParmVarDeclBitfields> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, ParmVarDeclBitfields>();

                private readonly bool __ownsNativeInstance;

                public static ParmVarDeclBitfields __CreateInstance(global::System.IntPtr native)
                {
                    return new ParmVarDeclBitfields((ParmVarDeclBitfields.Internal*) native);
                }

                public static ParmVarDeclBitfields __CreateInstance(ParmVarDeclBitfields.Internal native)
                {
                    return new ParmVarDeclBitfields(native);
                }

                private static ParmVarDeclBitfields.Internal* __CopyValue(ParmVarDeclBitfields.Internal native)
                {
                    var ret = (ParmVarDeclBitfields.Internal*) Marshal.AllocHGlobal(4);
                    *ret = native;
                    return ret;
                }

                private ParmVarDeclBitfields(ParmVarDeclBitfields.Internal native)
                    : this(__CopyValue(native))
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected ParmVarDeclBitfields(ParmVarDeclBitfields.Internal* native, bool isInternalImpl = false)
                {
                    __Instance = new global::System.IntPtr(native);
                }

                public ParmVarDeclBitfields()
                {
                    __Instance = Marshal.AllocHGlobal(4);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    DestroyNativeInstance(false);
                }

                public virtual void DestroyNativeInstance()
                {
                    DestroyNativeInstance(true);
                }

                private void DestroyNativeInstance(bool force)
                {
                    clang.VarDecl.ParmVarDeclBitfields __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }
            }

            protected internal unsafe partial struct _
            {
                [StructLayout(LayoutKind.Explicit, Size = 4)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    public uint AllBits;

                    [FieldOffset(0)]
                    internal clang.VarDecl.VarDeclBitfields.Internal VarDeclBits;

                    [FieldOffset(0)]
                    public clang.VarDecl.ParmVarDeclBitfields.Internal ParmVarDeclBits;
                }
            }

            private readonly bool __ownsNativeInstance;

            public static new VarDecl __CreateInstance(global::System.IntPtr native)
            {
                return new VarDecl((VarDecl.Internal*) native);
            }

            public static VarDecl __CreateInstance(VarDecl.Internal native)
            {
                return new VarDecl(native);
            }

            private static VarDecl.Internal* __CopyValue(VarDecl.Internal native)
            {
                var ret = (VarDecl.Internal*) Marshal.AllocHGlobal(88);
                *ret = native;
                return ret;
            }

            private VarDecl(VarDecl.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected VarDecl(VarDecl.Internal* native, bool isInternalImpl = false)
                : base((clang.DeclaratorDecl.Internal*) native)
            {
            }

            protected VarDecl(clang.Decl.Kind DK, clang.ASTContext C, clang.DeclContext DC, clang.SourceLocation StartLoc, clang.SourceLocation IdLoc, clang.IdentifierInfo Id, clang.QualType T, clang.TypeSourceInfo TInfo, clang.StorageClass SC)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(88);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = DK;
                var arg1 = ReferenceEquals(C, null) ? global::System.IntPtr.Zero : C.__Instance;
                var arg2 = ReferenceEquals(DC, null) ? global::System.IntPtr.Zero : DC.__Instance;
                var arg3 = ReferenceEquals(StartLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (StartLoc.__Instance);
                var arg4 = ReferenceEquals(IdLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (IdLoc.__Instance);
                var arg5 = ReferenceEquals(Id, null) ? global::System.IntPtr.Zero : Id.__Instance;
                var arg6 = ReferenceEquals(T, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (T.__Instance);
                var arg7 = ReferenceEquals(TInfo, null) ? global::System.IntPtr.Zero : TInfo.__Instance;
                var arg8 = SC;
                Internal.ctor_0(__Instance, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
                SetupVTables(__Instance);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Decl __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            protected virtual clang.VarDecl getNextRedeclarationImpl()
            {
                var __ret = Internal.getNextRedeclarationImpl_0(__Instance);
                clang.VarDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.VarDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.VarDecl) clang.VarDecl.NativeToManagedMap[__ret];
                else clang.VarDecl.NativeToManagedMap[__ret] = __result0 = (clang.VarDecl) clang.VarDecl.__CreateInstance(__ret);
                return __result0;
            }

            protected virtual clang.VarDecl getPreviousDeclImpl()
            {
                var __ret = Internal.getPreviousDeclImpl_0(__Instance);
                clang.VarDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.VarDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.VarDecl) clang.VarDecl.NativeToManagedMap[__ret];
                else clang.VarDecl.NativeToManagedMap[__ret] = __result0 = (clang.VarDecl) clang.VarDecl.__CreateInstance(__ret);
                return __result0;
            }

            protected virtual clang.VarDecl getMostRecentDeclImpl()
            {
                var __ret = Internal.getMostRecentDeclImpl_0(__Instance);
                clang.VarDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.VarDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.VarDecl) clang.VarDecl.NativeToManagedMap[__ret];
                else clang.VarDecl.NativeToManagedMap[__ret] = __result0 = (clang.VarDecl) clang.VarDecl.__CreateInstance(__ret);
                return __result0;
            }

            public override clang.SourceRange getSourceRange()
            {
                var __ret = Internal.getSourceRange_0(__Instance);
                return clang.SourceRange.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Returns the storage class as written in the source. For the
            /// computed linkage of symbol, see getLinkage.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Returns the storage class as written in the source.
            /// For the</para>
            /// <para>  /// computed linkage of symbol, see getLinkage.</para>
            /// </remarks>
            public clang.StorageClass getStorageClass()
            {
                var __ret = Internal.getStorageClass_0(__Instance);
                return __ret;
            }

            public void setStorageClass(clang.StorageClass SC)
            {
                var arg0 = SC;
                Internal.setStorageClass_0(__Instance, arg0);
            }

            public void setTSCSpec(clang.ThreadStorageClassSpecifier TSC)
            {
                var arg0 = TSC;
                Internal.setTSCSpec_0(__Instance, arg0);
            }

            public clang.ThreadStorageClassSpecifier getTSCSpec()
            {
                var __ret = Internal.getTSCSpec_0(__Instance);
                return __ret;
            }

            public clang.VarDecl.TLSKind getTLSKind()
            {
                var __ret = Internal.getTLSKind_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>hasLocalStorage - Returns true if a variable with function scope
            /// is a non-static local variable.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// hasLocalStorage - Returns true if a variable with function
            /// scope</para>
            /// <para>  ///  is a non-static local variable.</para>
            /// </remarks>
            public bool hasLocalStorage()
            {
                var __ret = Internal.hasLocalStorage_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>isStaticLocal - Returns true if a variable with function scope is
            /// a static local variable.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// isStaticLocal - Returns true if a variable with function
            /// scope is a</para>
            /// <para>  /// static local variable.</para>
            /// </remarks>
            public bool isStaticLocal()
            {
                var __ret = Internal.isStaticLocal_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Returns true if a variable has extern or __private_extern__
            /// storage.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Returns true if a variable has extern or
            /// __private_extern__</para>
            /// <para>  /// storage.</para>
            /// </remarks>
            public bool hasExternalStorage()
            {
                var __ret = Internal.hasExternalStorage_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Returns true for all variables that do not have local
            /// storage.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Returns true for all variables that do not have local
            /// storage.</para>
            /// <para>  ///</para>
            /// <para>  /// This includes all global variables as well as static
            /// variables declared</para>
            /// <para>  /// within a function.</para>
            /// </remarks>
            public bool hasGlobalStorage()
            {
                var __ret = Internal.hasGlobalStorage_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Get the storage duration of this variable, per C++
            /// [basic.stc].</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Get the storage duration of this variable, per C++
            /// [basic.stc].</para>
            /// </remarks>
            public clang.StorageDuration getStorageDuration()
            {
                var __ret = Internal.getStorageDuration_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Compute the language linkage.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Compute the language linkage.</para>
            /// </remarks>
            public clang.LanguageLinkage getLanguageLinkage()
            {
                var __ret = Internal.getLanguageLinkage_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determines whether this variable is a variable with external, C
            /// linkage.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determines whether this variable is a variable
            /// with</para>
            /// <para>  /// external, C linkage.</para>
            /// </remarks>
            public bool isExternC()
            {
                var __ret = Internal.isExternC_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determines whether this variable's context is, or is nested
            /// within, a C++ extern &quot;C&quot; linkage spec.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determines whether this variable's context is, or is
            /// nested within,</para>
            /// <para>  /// a C++ extern &quot;C&quot; linkage spec.</para>
            /// </remarks>
            public bool isInExternCContext()
            {
                var __ret = Internal.isInExternCContext_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determines whether this variable's context is, or is nested
            /// within, a C++ extern &quot;C++&quot; linkage spec.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determines whether this variable's context is, or is
            /// nested within,</para>
            /// <para>  /// a C++ extern &quot;C++&quot; linkage spec.</para>
            /// </remarks>
            public bool isInExternCXXContext()
            {
                var __ret = Internal.isInExternCXXContext_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>isLocalVarDecl - Returns true for local variable declarations
            /// other than parameters. Note that this includes static variables inside of
            /// functions. It also includes variables inside blocks.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// isLocalVarDecl - Returns true for local variable
            /// declarations</para>
            /// <para>  /// other than parameters.  Note that this includes static
            /// variables</para>
            /// <para>  /// inside of functions. It also includes variables inside
            /// blocks.</para>
            /// <para>  ///</para>
            /// <para>  ///   void foo() { int x; static int y; extern int z; }</para>
            /// <para>  ///</para>
            /// </remarks>
            public bool isLocalVarDecl()
            {
                var __ret = Internal.isLocalVarDecl_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Similar to isLocalVarDecl but also includes parameters.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Similar to isLocalVarDecl but also includes
            /// parameters.</para>
            /// </remarks>
            public bool isLocalVarDeclOrParm()
            {
                var __ret = Internal.isLocalVarDeclOrParm_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>isFunctionOrMethodVarDecl - Similar to isLocalVarDecl, but
            /// excludes variables declared in blocks.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// isFunctionOrMethodVarDecl - Similar to isLocalVarDecl,
            /// but</para>
            /// <para>  /// excludes variables declared in blocks.</para>
            /// </remarks>
            public bool isFunctionOrMethodVarDecl()
            {
                var __ret = Internal.isFunctionOrMethodVarDecl_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determines whether this is a static data member.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determines whether this is a static data
            /// member.</para>
            /// <para>  ///</para>
            /// <para>  /// This will only be true in C++, and applies to, e.g.,
            /// the</para>
            /// <para>  /// variable 'x' in:</para>
            /// <para>  /// \code</para>
            /// <para>  /// struct S {</para>
            /// <para>  ///   static int x;</para>
            /// <para>  /// };</para>
            /// <para>  /// \endcode</para>
            /// </remarks>
            public bool isStaticDataMember()
            {
                var __ret = Internal.isStaticDataMember_0(__Instance);
                return __ret;
            }

            public virtual clang.VarDecl getCanonicalDecl()
            {
                var __ret = Internal.getCanonicalDecl_0(__Instance);
                clang.VarDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.VarDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.VarDecl) clang.VarDecl.NativeToManagedMap[__ret];
                else clang.VarDecl.NativeToManagedMap[__ret] = __result0 = (clang.VarDecl) clang.VarDecl.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Check whether this declaration is a definition. If this could be
            /// a tentative definition (in C), don't check whether there's an overriding
            /// definition.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Check whether this declaration is a definition. If
            /// this could be</para>
            /// <para>  /// a tentative definition (in C), don't check whether there's
            /// an overriding</para>
            /// <para>  /// definition.</para>
            /// </remarks>
            public clang.VarDecl.DefinitionKind isThisDeclarationADefinition(clang.ASTContext _0)
            {
                var arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
                var __ret = Internal.isThisDeclarationADefinition_0(__Instance, arg0);
                return __ret;
            }

            public clang.VarDecl.DefinitionKind isThisDeclarationADefinition()
            {
                var __ret = Internal.isThisDeclarationADefinition_1(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Check whether this variable is defined in this translation
            /// unit.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Check whether this variable is defined in this</para>
            /// <para>  /// translation unit.</para>
            /// </remarks>
            public clang.VarDecl.DefinitionKind hasDefinition(clang.ASTContext _0)
            {
                var arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
                var __ret = Internal.hasDefinition_0(__Instance, arg0);
                return __ret;
            }

            public clang.VarDecl.DefinitionKind hasDefinition()
            {
                var __ret = Internal.hasDefinition_1(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Get the tentative definition that acts as the real definition in
            /// a TU. Returns null if there is a proper definition available.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Get the tentative definition that acts as the real
            /// definition in</para>
            /// <para>  /// a TU. Returns null if there is a proper definition
            /// available.</para>
            /// </remarks>
            public clang.VarDecl getActingDefinition()
            {
                var __ret = Internal.getActingDefinition_0(__Instance);
                clang.VarDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.VarDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.VarDecl) clang.VarDecl.NativeToManagedMap[__ret];
                else clang.VarDecl.NativeToManagedMap[__ret] = __result0 = (clang.VarDecl) clang.VarDecl.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Get the real (not just tentative) definition for this
            /// declaration.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Get the real (not just tentative) definition for this
            /// declaration.</para>
            /// </remarks>
            public clang.VarDecl getDefinition(clang.ASTContext _0)
            {
                var arg0 = ReferenceEquals(_0, null) ? global::System.IntPtr.Zero : _0.__Instance;
                var __ret = Internal.getDefinition_0(__Instance, arg0);
                clang.VarDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.VarDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.VarDecl) clang.VarDecl.NativeToManagedMap[__ret];
                else clang.VarDecl.NativeToManagedMap[__ret] = __result0 = (clang.VarDecl) clang.VarDecl.__CreateInstance(__ret);
                return __result0;
            }

            public clang.VarDecl getDefinition()
            {
                var __ret = Internal.getDefinition_2(__Instance);
                clang.VarDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.VarDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.VarDecl) clang.VarDecl.NativeToManagedMap[__ret];
                else clang.VarDecl.NativeToManagedMap[__ret] = __result0 = (clang.VarDecl) clang.VarDecl.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Determine whether this is or was instantiated from an out-of-line
            /// definition of a static data member.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine whether this is or was instantiated from an
            /// out-of-line</para>
            /// <para>  /// definition of a static data member.</para>
            /// </remarks>
            public override bool isOutOfLine()
            {
                var __ret = Internal.isOutOfLine_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>If this is a static data member, find its out-of-line
            /// definition.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief If this is a static data member, find its out-of-line
            /// definition.</para>
            /// </remarks>
            public clang.VarDecl getOutOfLineDefinition()
            {
                var __ret = Internal.getOutOfLineDefinition_0(__Instance);
                clang.VarDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.VarDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.VarDecl) clang.VarDecl.NativeToManagedMap[__ret];
                else clang.VarDecl.NativeToManagedMap[__ret] = __result0 = (clang.VarDecl) clang.VarDecl.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>isFileVarDecl - Returns true for file scoped variable
            /// declaration.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// isFileVarDecl - Returns true for file scoped variable
            /// declaration.</para>
            /// </remarks>
            public bool isFileVarDecl()
            {
                var __ret = Internal.isFileVarDecl_0(__Instance);
                return __ret;
            }

            public bool hasInit()
            {
                var __ret = Internal.hasInit_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Retrieve the address of the initializer expression.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the address of the initializer
            /// expression.</para>
            /// </remarks>
            public clang.Stmt getInitAddress()
            {
                var __ret = Internal.getInitAddress_0(__Instance);
                clang.Stmt __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Stmt.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Stmt) clang.Stmt.NativeToManagedMap[__ret];
                else __result0 = clang.Stmt.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Determine whether this variable's value can be used in a constant
            /// expression, according to the relevant language standard. This only checks
            /// properties of the declaration, and does not check whether the initializer
            /// is in fact a constant expression.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine whether this variable's value can be used in
            /// a</para>
            /// <para>  /// constant expression, according to the relevant language
            /// standard.</para>
            /// <para>  /// This only checks properties of the declaration, and does
            /// not check</para>
            /// <para>  /// whether the initializer is in fact a constant
            /// expression.</para>
            /// </remarks>
            public bool isUsableInConstantExpressions(clang.ASTContext C)
            {
                var arg0 = ReferenceEquals(C, null) ? global::System.IntPtr.Zero : C.__Instance;
                var __ret = Internal.isUsableInConstantExpressions_0(__Instance, arg0);
                return __ret;
            }

            public clang.EvaluatedStmt ensureEvaluatedStmt()
            {
                var __ret = Internal.ensureEvaluatedStmt_0(__Instance);
                clang.EvaluatedStmt __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.EvaluatedStmt.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.EvaluatedStmt) clang.EvaluatedStmt.NativeToManagedMap[__ret];
                else __result0 = clang.EvaluatedStmt.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Attempt to evaluate the value of the initializer attached to this
            /// declaration, and produce notes explaining why it cannot be evaluated or is
            /// not a constant expression. Returns a pointer to the value if evaluation
            /// succeeded, 0 otherwise.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Attempt to evaluate the value of the initializer
            /// attached to this</para>
            /// <para>  /// declaration, and produce notes explaining why it cannot be
            /// evaluated or is</para>
            /// <para>  /// not a constant expression. Returns a pointer to the value
            /// if evaluation</para>
            /// <para>  /// succeeded, 0 otherwise.</para>
            /// </remarks>
            public clang.APValue evaluateValue()
            {
                var __ret = Internal.evaluateValue_0(__Instance);
                clang.APValue __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.APValue.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.APValue) clang.APValue.NativeToManagedMap[__ret];
                else __result0 = clang.APValue.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Return the already-evaluated value of this variable's
            /// initializer, or NULL if the value is not yet known. Returns pointer to
            /// untyped APValue if the value could not be evaluated.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the already-evaluated value of this
            /// variable's</para>
            /// <para>  /// initializer, or NULL if the value is not yet known. Returns
            /// pointer</para>
            /// <para>  /// to untyped APValue if the value could not be
            /// evaluated.</para>
            /// </remarks>
            public clang.APValue getEvaluatedValue()
            {
                var __ret = Internal.getEvaluatedValue_0(__Instance);
                clang.APValue __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.APValue.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.APValue) clang.APValue.NativeToManagedMap[__ret];
                else __result0 = clang.APValue.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Determines whether it is already known whether the initializer is
            /// an integral constant expression or not.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determines whether it is already known whether
            /// the</para>
            /// <para>  /// initializer is an integral constant expression or
            /// not.</para>
            /// </remarks>
            public bool isInitKnownICE()
            {
                var __ret = Internal.isInitKnownICE_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determines whether the initializer is an integral constant
            /// expression, or in C++11, whether the initializer is a constant
            /// expression.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determines whether the initializer is an integral
            /// constant</para>
            /// <para>  /// expression, or in C++11, whether the initializer is a
            /// constant</para>
            /// <para>  /// expression.</para>
            /// <para>  ///</para>
            /// <para>  /// \pre isInitKnownICE()</para>
            /// </remarks>
            public bool isInitICE()
            {
                var __ret = Internal.isInitICE_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determine whether the value of the initializer attached to this
            /// declaration is an integral constant expression.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine whether the value of the initializer
            /// attached to this</para>
            /// <para>  /// declaration is an integral constant expression.</para>
            /// </remarks>
            public bool checkInitIsICE()
            {
                var __ret = Internal.checkInitIsICE_0(__Instance);
                return __ret;
            }

            public void setInitStyle(clang.VarDecl.InitializationStyle Style)
            {
                var arg0 = Style;
                Internal.setInitStyle_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>The style of initialization for this declaration.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief The style of initialization for this
            /// declaration.</para>
            /// <para>  ///</para>
            /// <para>  /// C-style initialization is &quot;int x = 1;&quot;.
            /// Call-style initialization is</para>
            /// <para>  /// a C++98 direct-initializer, e.g. &quot;int x(1);&quot;. The
            /// Init expression will be</para>
            /// <para>  /// the expression inside the parens or a
            /// &quot;ClassType(a,b,c)&quot; class constructor</para>
            /// <para>  /// expression for class types. List-style initialization is
            /// C++11 syntax,</para>
            /// <para>  /// e.g. &quot;int x{1};&quot;. Clients can distinguish between
            /// different forms of</para>
            /// <para>  /// initialization by checking this value. In particular,
            /// &quot;int x = {1};&quot; is</para>
            /// <para>  /// C-style, &quot;int x({1})&quot; is call-style, and
            /// &quot;int x{1};&quot; is list-style; the</para>
            /// <para>  /// Init expression in all three cases is an
            /// InitListExpr.</para>
            /// </remarks>
            public clang.VarDecl.InitializationStyle getInitStyle()
            {
                var __ret = Internal.getInitStyle_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Whether the initializer is a direct-initializer (list or
            /// call).</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Whether the initializer is a direct-initializer (list
            /// or call).</para>
            /// </remarks>
            public bool isDirectInit()
            {
                var __ret = Internal.isDirectInit_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determine whether this variable is the exception variable in a
            /// C++ catch statememt or an Objective-C @catch statement.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine whether this variable is the exception
            /// variable in a</para>
            /// <para>  /// C++ catch statememt or an Objective-C \@catch
            /// statement.</para>
            /// </remarks>
            public bool isExceptionVariable()
            {
                var __ret = Internal.isExceptionVariable_0(__Instance);
                return __ret;
            }

            public void setExceptionVariable(bool EV)
            {
                Internal.setExceptionVariable_0(__Instance, EV);
            }

            /// <summary>
            /// <para>Determine whether this local variable can be used with the named
            /// return value optimization (NRVO).</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine whether this local variable can be used with
            /// the named</para>
            /// <para>  /// return value optimization (NRVO).</para>
            /// <para>  ///</para>
            /// <para>  /// The named return value optimization (NRVO) works by marking
            /// certain</para>
            /// <para>  /// non-volatile local variables of class type as NRVO objects.
            /// These</para>
            /// <para>  /// locals can be allocated within the return slot of their
            /// containing</para>
            /// <para>  /// function, in which case there is no need to copy the object
            /// to the</para>
            /// <para>  /// return slot when returning from the function. Within the
            /// function body,</para>
            /// <para>  /// each return that returns the NRVO object will have this
            /// variable as its</para>
            /// <para>  /// NRVO candidate.</para>
            /// </remarks>
            public bool isNRVOVariable()
            {
                var __ret = Internal.isNRVOVariable_0(__Instance);
                return __ret;
            }

            public void setNRVOVariable(bool NRVO)
            {
                Internal.setNRVOVariable_0(__Instance, NRVO);
            }

            /// <summary>
            /// <para>Determine whether this variable is the for-range-declaration in a
            /// C++0x for-range statement.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine whether this variable is the
            /// for-range-declaration in</para>
            /// <para>  /// a C++0x for-range statement.</para>
            /// </remarks>
            public bool isCXXForRangeDecl()
            {
                var __ret = Internal.isCXXForRangeDecl_0(__Instance);
                return __ret;
            }

            public void setCXXForRangeDecl(bool FRD)
            {
                Internal.setCXXForRangeDecl_0(__Instance, FRD);
            }

            /// <summary>
            /// <para>Determine whether this variable is an ARC pseudo-__strong
            /// variable. A pseudo-__strong variable has a __strong-qualified type but does
            /// not actually retain the object written into it. Generally such variables
            /// are also 'const' for safety.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine whether this variable is an ARC
            /// pseudo-__strong</para>
            /// <para>  /// variable.  A pseudo-__strong variable has a
            /// __strong-qualified</para>
            /// <para>  /// type but does not actually retain the object written into
            /// it.</para>
            /// <para>  /// Generally such variables are also 'const' for
            /// safety.</para>
            /// </remarks>
            public bool isARCPseudoStrong()
            {
                var __ret = Internal.isARCPseudoStrong_0(__Instance);
                return __ret;
            }

            public void setARCPseudoStrong(bool ps)
            {
                Internal.setARCPseudoStrong_0(__Instance, ps);
            }

            /// <summary>
            /// <para>Whether this variable is (C++11) constexpr.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Whether this variable is (C++11) constexpr.</para>
            /// </remarks>
            public bool isConstexpr()
            {
                var __ret = Internal.isConstexpr_0(__Instance);
                return __ret;
            }

            public void setConstexpr(bool IC)
            {
                Internal.setConstexpr_0(__Instance, IC);
            }

            /// <summary>
            /// <para>Whether this variable is the implicit variable for a lambda
            /// init-capture.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Whether this variable is the implicit variable for a lambda
            /// init-capture.</para>
            /// </remarks>
            public bool isInitCapture()
            {
                var __ret = Internal.isInitCapture_0(__Instance);
                return __ret;
            }

            public void setInitCapture(bool IC)
            {
                Internal.setInitCapture_0(__Instance, IC);
            }

            /// <summary>
            /// <para>Whether this local extern variable declaration's previous
            /// declaration was declared in the same block scope. Only correct in
            /// C++.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Whether this local extern variable declaration's previous
            /// declaration</para>
            /// <para>  /// was declared in the same block scope. Only correct in
            /// C++.</para>
            /// </remarks>
            public bool isPreviousDeclInSameBlockScope()
            {
                var __ret = Internal.isPreviousDeclInSameBlockScope_0(__Instance);
                return __ret;
            }

            public void setPreviousDeclInSameBlockScope(bool Same)
            {
                Internal.setPreviousDeclInSameBlockScope_0(__Instance, Same);
            }

            /// <summary>
            /// <para>If this variable is an instantiated static data member of a class
            /// template specialization, returns the templated static data member from
            /// which it was instantiated.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief If this variable is an instantiated static data member
            /// of a</para>
            /// <para>  /// class template specialization, returns the templated static
            /// data member</para>
            /// <para>  /// from which it was instantiated.</para>
            /// </remarks>
            public clang.VarDecl getInstantiatedFromStaticDataMember()
            {
                var __ret = Internal.getInstantiatedFromStaticDataMember_0(__Instance);
                clang.VarDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.VarDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.VarDecl) clang.VarDecl.NativeToManagedMap[__ret];
                else clang.VarDecl.NativeToManagedMap[__ret] = __result0 = (clang.VarDecl) clang.VarDecl.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>If this variable is an instantiation of a variable template or a
            /// static data member of a class template, determine what kind of template
            /// specialization or instantiation this is.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief If this variable is an instantiation of a variable
            /// template or a</para>
            /// <para>  /// static data member of a class template, determine what kind
            /// of</para>
            /// <para>  /// template specialization or instantiation this is.</para>
            /// </remarks>
            public clang.TemplateSpecializationKind getTemplateSpecializationKind()
            {
                var __ret = Internal.getTemplateSpecializationKind_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>If this variable is an instantiation of a variable template or a
            /// static data member of a class template, determine its point of
            /// instantiation.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief If this variable is an instantiation of a variable
            /// template or a</para>
            /// <para>  /// static data member of a class template, determine its point
            /// of</para>
            /// <para>  /// instantiation.</para>
            /// </remarks>
            public clang.SourceLocation getPointOfInstantiation()
            {
                var __ret = Internal.getPointOfInstantiation_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>For a static data member that was instantiated from a static data
            /// member of a class template, set the template specialiation kind.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief For a static data member that was instantiated from a
            /// static</para>
            /// <para>  /// data member of a class template, set the template
            /// specialiation kind.</para>
            /// </remarks>
            public void setTemplateSpecializationKind(clang.TemplateSpecializationKind TSK, clang.SourceLocation PointOfInstantiation)
            {
                var arg0 = TSK;
                var arg1 = ReferenceEquals(PointOfInstantiation, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (PointOfInstantiation.__Instance);
                Internal.setTemplateSpecializationKind_0(__Instance, arg0, arg1);
            }

            /// <summary>
            /// <para>Specify that this variable is an instantiation of the static data
            /// member VD.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Specify that this variable is an instantiation of
            /// the</para>
            /// <para>  /// static data member VD.</para>
            /// </remarks>
            public void setInstantiationOfStaticDataMember(clang.VarDecl VD, clang.TemplateSpecializationKind TSK)
            {
                var arg0 = ReferenceEquals(VD, null) ? global::System.IntPtr.Zero : VD.__Instance;
                var arg1 = TSK;
                Internal.setInstantiationOfStaticDataMember_0(__Instance, arg0, arg1);
            }

            /// <summary>
            /// <para>getStorageClassSpecifierString - Return the string used to
            /// specify the storage class SC.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getStorageClassSpecifierString - Return the string used
            /// to</para>
            /// <para>  /// specify the storage class \p SC.</para>
            /// <para>  ///</para>
            /// <para>  /// It is illegal to call this function with SC == None.</para>
            /// </remarks>
            public static string getStorageClassSpecifierString(clang.StorageClass SC)
            {
                var arg0 = SC;
                var __ret = Internal.getStorageClassSpecifierString_0(arg0);
                return Marshal.PtrToStringAnsi(__ret);
            }

            public static clang.VarDecl Create(clang.ASTContext C, clang.DeclContext DC, clang.SourceLocation StartLoc, clang.SourceLocation IdLoc, clang.IdentifierInfo Id, clang.QualType T, clang.TypeSourceInfo TInfo, clang.StorageClass S)
            {
                var arg0 = ReferenceEquals(C, null) ? global::System.IntPtr.Zero : C.__Instance;
                var arg1 = ReferenceEquals(DC, null) ? global::System.IntPtr.Zero : DC.__Instance;
                var arg2 = ReferenceEquals(StartLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (StartLoc.__Instance);
                var arg3 = ReferenceEquals(IdLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (IdLoc.__Instance);
                var arg4 = ReferenceEquals(Id, null) ? global::System.IntPtr.Zero : Id.__Instance;
                var arg5 = ReferenceEquals(T, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (T.__Instance);
                var arg6 = ReferenceEquals(TInfo, null) ? global::System.IntPtr.Zero : TInfo.__Instance;
                var arg7 = S;
                var __ret = Internal.Create_0(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
                clang.VarDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.VarDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.VarDecl) clang.VarDecl.NativeToManagedMap[__ret];
                else clang.VarDecl.NativeToManagedMap[__ret] = __result0 = (clang.VarDecl) clang.VarDecl.__CreateInstance(__ret);
                return __result0;
            }

            public static clang.VarDecl CreateDeserialized(clang.ASTContext C, uint ID)
            {
                var arg0 = ReferenceEquals(C, null) ? global::System.IntPtr.Zero : C.__Instance;
                var __ret = Internal.CreateDeserialized_0(arg0, ID);
                clang.VarDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.VarDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.VarDecl) clang.VarDecl.NativeToManagedMap[__ret];
                else clang.VarDecl.NativeToManagedMap[__ret] = __result0 = (clang.VarDecl) clang.VarDecl.__CreateInstance(__ret);
                return __result0;
            }

            public static bool classof(clang.Decl D)
            {
                var arg0 = ReferenceEquals(D, null) ? global::System.IntPtr.Zero : D.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }

            public static bool classofKind(clang.Decl.Kind K)
            {
                var arg0 = K;
                var __ret = Internal.classofKind_0(arg0);
                return __ret;
            }

            #region Virtual table interop

            // VarDecl
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
            private static _dtor_0Delegate _dtor_0DelegateInstance;

            private static void _dtor_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (VarDecl) _References[instance].Target;
                __target.DestroyNativeInstance();
            }

            // SourceRange getSourceRange() const override
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate clang.SourceRange.Internal _getSourceRange_0Delegate(global::System.IntPtr instance);
            private static _getSourceRange_0Delegate _getSourceRange_0DelegateInstance;

            private static clang.SourceRange.Internal _getSourceRange_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (VarDecl) _References[instance].Target;
                var __ret = __target.getSourceRange();
                return ReferenceEquals(__ret, null) ? new clang.SourceRange.Internal() : *(clang.SourceRange.Internal*) (__ret.__Instance);
            }

            // bool isOutOfLine() const override
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate bool _isOutOfLine_0Delegate(global::System.IntPtr instance);
            private static _isOutOfLine_0Delegate _isOutOfLine_0DelegateInstance;

            private static bool _isOutOfLine_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (VarDecl) _References[instance].Target;
                var __ret = __target.isOutOfLine();
                return __ret;
            }

            // VarDecl *getCanonicalDecl() override
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getCanonicalDecl_0Delegate(global::System.IntPtr instance);
            private static _getCanonicalDecl_0Delegate _getCanonicalDecl_0DelegateInstance;

            private static global::System.IntPtr _getCanonicalDecl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (VarDecl) _References[instance].Target;
                var __ret = __target.getCanonicalDecl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // VarDecl *getNextRedeclarationImpl() override
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getNextRedeclarationImpl_0Delegate(global::System.IntPtr instance);
            private static _getNextRedeclarationImpl_0Delegate _getNextRedeclarationImpl_0DelegateInstance;

            private static global::System.IntPtr _getNextRedeclarationImpl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (VarDecl) _References[instance].Target;
                var __ret = __target.getNextRedeclarationImpl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // VarDecl *getPreviousDeclImpl() override
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getPreviousDeclImpl_0Delegate(global::System.IntPtr instance);
            private static _getPreviousDeclImpl_0Delegate _getPreviousDeclImpl_0DelegateInstance;

            private static global::System.IntPtr _getPreviousDeclImpl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (VarDecl) _References[instance].Target;
                var __ret = __target.getPreviousDeclImpl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // VarDecl *getMostRecentDeclImpl() override
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getMostRecentDeclImpl_0Delegate(global::System.IntPtr instance);
            private static _getMostRecentDeclImpl_0Delegate _getMostRecentDeclImpl_0DelegateInstance;

            private static global::System.IntPtr _getMostRecentDeclImpl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (VarDecl) _References[instance].Target;
                var __ret = __target.getMostRecentDeclImpl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // Stmt* getBody() const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getBody_0Delegate(global::System.IntPtr instance);
            private static _getBody_0Delegate _getBody_0DelegateInstance;

            private static global::System.IntPtr _getBody_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (VarDecl) _References[instance].Target;
                var __ret = __target.getBody();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // bool hasBody() const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate bool _hasBody_0Delegate(global::System.IntPtr instance);
            private static _hasBody_0Delegate _hasBody_0DelegateInstance;

            private static bool _hasBody_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (VarDecl) _References[instance].Target;
                var __ret = __target.hasBody();
                return __ret;
            }

            // void getNameForDiagnostic(raw_ostream &OS, const PrintingPolicy &Policy, bool Qualified) const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate void _getNameForDiagnostic_0Delegate(global::System.IntPtr instance, global::System.IntPtr OS, global::System.IntPtr Policy, bool Qualified);
            private static _getNameForDiagnostic_0Delegate _getNameForDiagnostic_0DelegateInstance;

            private static void _getNameForDiagnostic_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr OS, global::System.IntPtr Policy, bool Qualified)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (VarDecl) _References[instance].Target;
                llvm.raw_ostream __result0;
                if (OS == IntPtr.Zero) __result0 = null;
                else if (llvm.raw_ostream.NativeToManagedMap.ContainsKey(OS))
                    __result0 = (llvm.raw_ostream) llvm.raw_ostream.NativeToManagedMap[OS];
                else llvm.raw_ostream.NativeToManagedMap[OS] = __result0 = (llvm.raw_ostream) llvm.raw_ostream.__CreateInstance(OS);
                clang.PrintingPolicy __result1;
                if (Policy == IntPtr.Zero) __result1 = null;
                else if (clang.PrintingPolicy.NativeToManagedMap.ContainsKey(Policy))
                    __result1 = (clang.PrintingPolicy) clang.PrintingPolicy.NativeToManagedMap[Policy];
                else __result1 = clang.PrintingPolicy.__CreateInstance(Policy);
                __target.getNameForDiagnostic(__result0, __result1, Qualified);
            }

            private static void*[] _OldVTables;
            private static void*[] _NewVTables;
            private static void*[] _Thunks;
            private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

            void SetupVTables(global::System.IntPtr instance)
            {
                var native = (Internal*)instance.ToPointer();

                if (_References == null)
                    _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

                if (_References.ContainsKey(instance))
                    return;

                _References[instance] = new WeakReference(this);

                if (_OldVTables == null)
                {
                    _OldVTables = new void*[1];
                    _OldVTables[0] = native->vfptr0.ToPointer();
                }

                if (_Thunks == null)
                {
                    _Thunks = new void*[10];
                    _dtor_0DelegateInstance += _dtor_0DelegateHook;
                    _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                    _getSourceRange_0DelegateInstance += _getSourceRange_0DelegateHook;
                    _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_getSourceRange_0DelegateInstance).ToPointer();
                    _isOutOfLine_0DelegateInstance += _isOutOfLine_0DelegateHook;
                    _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_isOutOfLine_0DelegateInstance).ToPointer();
                    _getCanonicalDecl_0DelegateInstance += _getCanonicalDecl_0DelegateHook;
                    _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_getCanonicalDecl_0DelegateInstance).ToPointer();
                    _getNextRedeclarationImpl_0DelegateInstance += _getNextRedeclarationImpl_0DelegateHook;
                    _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_getNextRedeclarationImpl_0DelegateInstance).ToPointer();
                    _getPreviousDeclImpl_0DelegateInstance += _getPreviousDeclImpl_0DelegateHook;
                    _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_getPreviousDeclImpl_0DelegateInstance).ToPointer();
                    _getMostRecentDeclImpl_0DelegateInstance += _getMostRecentDeclImpl_0DelegateHook;
                    _Thunks[6] = Marshal.GetFunctionPointerForDelegate(_getMostRecentDeclImpl_0DelegateInstance).ToPointer();
                    _getBody_0DelegateInstance += _getBody_0DelegateHook;
                    _Thunks[7] = Marshal.GetFunctionPointerForDelegate(_getBody_0DelegateInstance).ToPointer();
                    _hasBody_0DelegateInstance += _hasBody_0DelegateHook;
                    _Thunks[8] = Marshal.GetFunctionPointerForDelegate(_hasBody_0DelegateInstance).ToPointer();
                    _getNameForDiagnostic_0DelegateInstance += _getNameForDiagnostic_0DelegateHook;
                    _Thunks[9] = Marshal.GetFunctionPointerForDelegate(_getNameForDiagnostic_0DelegateInstance).ToPointer();
                }

                if (_NewVTables == null)
                {
                    _NewVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(11 * 8);
                    _NewVTables[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + 8) = _Thunks[0];
                    *(void**)(vfptr0 + 16) = _Thunks[1];
                    *(void**)(vfptr0 + 24) = _Thunks[2];
                    *(void**)(vfptr0 + 32) = _Thunks[3];
                    *(void**)(vfptr0 + 40) = _Thunks[4];
                    *(void**)(vfptr0 + 48) = _Thunks[5];
                    *(void**)(vfptr0 + 56) = _Thunks[6];
                    *(void**)(vfptr0 + 64) = _Thunks[7];
                    *(void**)(vfptr0 + 72) = _Thunks[8];
                    *(void**)(vfptr0 + 80) = *(void**)(native->vfptr0 + 80);
                    *(void**)(vfptr0 + 88) = _Thunks[9];
                }

                native->vfptr0 = new IntPtr(_NewVTables[0]);
            }

            #endregion
        }

        public unsafe partial class ImplicitParamDecl : clang.VarDecl, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 88)]
            public new partial struct Internal
            {
                [FieldOffset(8)]
                internal llvm.PointerIntPair.Internal NextInContextAndBits;

                [FieldOffset(16)]
                internal llvm.PointerUnion.Internal DeclCtx;

                [FieldOffset(24)]
                public clang.SourceLocation.Internal Loc;

                [FieldOffset(28)]
                public uint DeclKind;

                [FieldOffset(29)]
                public uint InvalidDecl;

                [FieldOffset(29)]
                public uint HasAttrs;

                [FieldOffset(29)]
                public uint Implicit;

                [FieldOffset(29)]
                public uint Used;

                [FieldOffset(29)]
                public uint Referenced;

                [FieldOffset(29)]
                public uint Access;

                [FieldOffset(29)]
                public uint FromASTFile;

                [FieldOffset(30)]
                public uint Hidden;

                [FieldOffset(30)]
                public uint IdentifierNamespace;

                [FieldOffset(31)]
                public uint CacheValidAndLinkage;

                [FieldOffset(32)]
                public clang.DeclarationName.Internal Name;

                [FieldOffset(40)]
                public clang.QualType.Internal DeclType;

                [FieldOffset(48)]
                internal llvm.PointerUnion.Internal DeclInfo;

                [FieldOffset(56)]
                public clang.SourceLocation.Internal InnerLocStart;

                [FieldOffset(72)]
                internal llvm.PointerUnion4.Internal Init;

                [FieldOffset(80)]
                internal clang.VarDecl._.Internal __;

                [FieldOffset(0)]
                public global::System.IntPtr vfptr0;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17ImplicitParamDeclC2ERNS_10ASTContextEPNS_11DeclContextENS_14SourceLocationEPNS_14IdentifierInfoENS_8QualTypeE")]
                internal static extern void ctor_0(global::System.IntPtr instance, global::System.IntPtr C, global::System.IntPtr DC, clang.SourceLocation.Internal IdLoc, global::System.IntPtr Id, clang.QualType.Internal Type);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17ImplicitParamDeclC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17ImplicitParamDeclD2Ev")]
                internal static extern void dtor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17ImplicitParamDecl6CreateERNS_10ASTContextEPNS_11DeclContextENS_14SourceLocationEPNS_14IdentifierInfoENS_8QualTypeE")]
                internal static extern global::System.IntPtr Create_0(global::System.IntPtr C, global::System.IntPtr DC, clang.SourceLocation.Internal IdLoc, global::System.IntPtr Id, clang.QualType.Internal T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17ImplicitParamDecl18CreateDeserializedERNS_10ASTContextEj")]
                internal static extern global::System.IntPtr CreateDeserialized_0(global::System.IntPtr C, uint ID);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17ImplicitParamDecl7classofEPKNS_4DeclE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr D);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17ImplicitParamDecl11classofKindENS_4Decl4KindE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classofKind_0(clang.Decl.Kind K);
            }

            private readonly bool __ownsNativeInstance;

            public static new ImplicitParamDecl __CreateInstance(global::System.IntPtr native)
            {
                return new ImplicitParamDecl((ImplicitParamDecl.Internal*) native);
            }

            public static ImplicitParamDecl __CreateInstance(ImplicitParamDecl.Internal native)
            {
                return new ImplicitParamDecl(native);
            }

            private static ImplicitParamDecl.Internal* __CopyValue(ImplicitParamDecl.Internal native)
            {
                var ret = (ImplicitParamDecl.Internal*) Marshal.AllocHGlobal(88);
                *ret = native;
                return ret;
            }

            private ImplicitParamDecl(ImplicitParamDecl.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected ImplicitParamDecl(ImplicitParamDecl.Internal* native, bool isInternalImpl = false)
                : base((clang.VarDecl.Internal*) native)
            {
            }

            public ImplicitParamDecl(clang.ASTContext C, clang.DeclContext DC, clang.SourceLocation IdLoc, clang.IdentifierInfo Id, clang.QualType Type)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(88);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(C, null) ? global::System.IntPtr.Zero : C.__Instance;
                var arg1 = ReferenceEquals(DC, null) ? global::System.IntPtr.Zero : DC.__Instance;
                var arg2 = ReferenceEquals(IdLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (IdLoc.__Instance);
                var arg3 = ReferenceEquals(Id, null) ? global::System.IntPtr.Zero : Id.__Instance;
                var arg4 = ReferenceEquals(Type, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (Type.__Instance);
                Internal.ctor_0(__Instance, arg0, arg1, arg2, arg3, arg4);
                SetupVTables(__Instance);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Decl __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public static clang.ImplicitParamDecl Create(clang.ASTContext C, clang.DeclContext DC, clang.SourceLocation IdLoc, clang.IdentifierInfo Id, clang.QualType T)
            {
                var arg0 = ReferenceEquals(C, null) ? global::System.IntPtr.Zero : C.__Instance;
                var arg1 = ReferenceEquals(DC, null) ? global::System.IntPtr.Zero : DC.__Instance;
                var arg2 = ReferenceEquals(IdLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (IdLoc.__Instance);
                var arg3 = ReferenceEquals(Id, null) ? global::System.IntPtr.Zero : Id.__Instance;
                var arg4 = ReferenceEquals(T, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (T.__Instance);
                var __ret = Internal.Create_0(arg0, arg1, arg2, arg3, arg4);
                clang.ImplicitParamDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.ImplicitParamDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.ImplicitParamDecl) clang.ImplicitParamDecl.NativeToManagedMap[__ret];
                else clang.ImplicitParamDecl.NativeToManagedMap[__ret] = __result0 = (clang.ImplicitParamDecl) clang.ImplicitParamDecl.__CreateInstance(__ret);
                return __result0;
            }

            public static clang.ImplicitParamDecl CreateDeserialized(clang.ASTContext C, uint ID)
            {
                var arg0 = ReferenceEquals(C, null) ? global::System.IntPtr.Zero : C.__Instance;
                var __ret = Internal.CreateDeserialized_0(arg0, ID);
                clang.ImplicitParamDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.ImplicitParamDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.ImplicitParamDecl) clang.ImplicitParamDecl.NativeToManagedMap[__ret];
                else clang.ImplicitParamDecl.NativeToManagedMap[__ret] = __result0 = (clang.ImplicitParamDecl) clang.ImplicitParamDecl.__CreateInstance(__ret);
                return __result0;
            }

            public static bool classof(clang.Decl D)
            {
                var arg0 = ReferenceEquals(D, null) ? global::System.IntPtr.Zero : D.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }

            public static bool classofKind(clang.Decl.Kind K)
            {
                var arg0 = K;
                var __ret = Internal.classofKind_0(arg0);
                return __ret;
            }

            #region Virtual table interop

            // ImplicitParamDecl
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
            private static _dtor_0Delegate _dtor_0DelegateInstance;

            private static void _dtor_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (ImplicitParamDecl) _References[instance].Target;
                __target.DestroyNativeInstance();
            }

            // SourceRange getSourceRange() const override
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate clang.SourceRange.Internal _getSourceRange_0Delegate(global::System.IntPtr instance);
            private static _getSourceRange_0Delegate _getSourceRange_0DelegateInstance;

            private static clang.SourceRange.Internal _getSourceRange_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (ImplicitParamDecl) _References[instance].Target;
                var __ret = __target.getSourceRange();
                return ReferenceEquals(__ret, null) ? new clang.SourceRange.Internal() : *(clang.SourceRange.Internal*) (__ret.__Instance);
            }

            // bool isOutOfLine() const override
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate bool _isOutOfLine_0Delegate(global::System.IntPtr instance);
            private static _isOutOfLine_0Delegate _isOutOfLine_0DelegateInstance;

            private static bool _isOutOfLine_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (ImplicitParamDecl) _References[instance].Target;
                var __ret = __target.isOutOfLine();
                return __ret;
            }

            // VarDecl *getCanonicalDecl() override
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getCanonicalDecl_0Delegate(global::System.IntPtr instance);
            private static _getCanonicalDecl_0Delegate _getCanonicalDecl_0DelegateInstance;

            private static global::System.IntPtr _getCanonicalDecl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (ImplicitParamDecl) _References[instance].Target;
                var __ret = __target.getCanonicalDecl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // VarDecl *getNextRedeclarationImpl() override
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getNextRedeclarationImpl_0Delegate(global::System.IntPtr instance);
            private static _getNextRedeclarationImpl_0Delegate _getNextRedeclarationImpl_0DelegateInstance;

            private static global::System.IntPtr _getNextRedeclarationImpl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (ImplicitParamDecl) _References[instance].Target;
                var __ret = __target.getNextRedeclarationImpl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // VarDecl *getPreviousDeclImpl() override
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getPreviousDeclImpl_0Delegate(global::System.IntPtr instance);
            private static _getPreviousDeclImpl_0Delegate _getPreviousDeclImpl_0DelegateInstance;

            private static global::System.IntPtr _getPreviousDeclImpl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (ImplicitParamDecl) _References[instance].Target;
                var __ret = __target.getPreviousDeclImpl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // VarDecl *getMostRecentDeclImpl() override
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getMostRecentDeclImpl_0Delegate(global::System.IntPtr instance);
            private static _getMostRecentDeclImpl_0Delegate _getMostRecentDeclImpl_0DelegateInstance;

            private static global::System.IntPtr _getMostRecentDeclImpl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (ImplicitParamDecl) _References[instance].Target;
                var __ret = __target.getMostRecentDeclImpl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // Stmt* getBody() const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getBody_0Delegate(global::System.IntPtr instance);
            private static _getBody_0Delegate _getBody_0DelegateInstance;

            private static global::System.IntPtr _getBody_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (ImplicitParamDecl) _References[instance].Target;
                var __ret = __target.getBody();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // bool hasBody() const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate bool _hasBody_0Delegate(global::System.IntPtr instance);
            private static _hasBody_0Delegate _hasBody_0DelegateInstance;

            private static bool _hasBody_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (ImplicitParamDecl) _References[instance].Target;
                var __ret = __target.hasBody();
                return __ret;
            }

            // void getNameForDiagnostic(raw_ostream &OS, const PrintingPolicy &Policy, bool Qualified) const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate void _getNameForDiagnostic_0Delegate(global::System.IntPtr instance, global::System.IntPtr OS, global::System.IntPtr Policy, bool Qualified);
            private static _getNameForDiagnostic_0Delegate _getNameForDiagnostic_0DelegateInstance;

            private static void _getNameForDiagnostic_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr OS, global::System.IntPtr Policy, bool Qualified)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (ImplicitParamDecl) _References[instance].Target;
                llvm.raw_ostream __result0;
                if (OS == IntPtr.Zero) __result0 = null;
                else if (llvm.raw_ostream.NativeToManagedMap.ContainsKey(OS))
                    __result0 = (llvm.raw_ostream) llvm.raw_ostream.NativeToManagedMap[OS];
                else llvm.raw_ostream.NativeToManagedMap[OS] = __result0 = (llvm.raw_ostream) llvm.raw_ostream.__CreateInstance(OS);
                clang.PrintingPolicy __result1;
                if (Policy == IntPtr.Zero) __result1 = null;
                else if (clang.PrintingPolicy.NativeToManagedMap.ContainsKey(Policy))
                    __result1 = (clang.PrintingPolicy) clang.PrintingPolicy.NativeToManagedMap[Policy];
                else __result1 = clang.PrintingPolicy.__CreateInstance(Policy);
                __target.getNameForDiagnostic(__result0, __result1, Qualified);
            }

            private static void*[] _OldVTables;
            private static void*[] _NewVTables;
            private static void*[] _Thunks;
            private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

            void SetupVTables(global::System.IntPtr instance)
            {
                var native = (Internal*)instance.ToPointer();

                if (_References == null)
                    _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

                if (_References.ContainsKey(instance))
                    return;

                _References[instance] = new WeakReference(this);

                if (_OldVTables == null)
                {
                    _OldVTables = new void*[1];
                    _OldVTables[0] = native->vfptr0.ToPointer();
                }

                if (_Thunks == null)
                {
                    _Thunks = new void*[10];
                    _dtor_0DelegateInstance += _dtor_0DelegateHook;
                    _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                    _getSourceRange_0DelegateInstance += _getSourceRange_0DelegateHook;
                    _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_getSourceRange_0DelegateInstance).ToPointer();
                    _isOutOfLine_0DelegateInstance += _isOutOfLine_0DelegateHook;
                    _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_isOutOfLine_0DelegateInstance).ToPointer();
                    _getCanonicalDecl_0DelegateInstance += _getCanonicalDecl_0DelegateHook;
                    _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_getCanonicalDecl_0DelegateInstance).ToPointer();
                    _getNextRedeclarationImpl_0DelegateInstance += _getNextRedeclarationImpl_0DelegateHook;
                    _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_getNextRedeclarationImpl_0DelegateInstance).ToPointer();
                    _getPreviousDeclImpl_0DelegateInstance += _getPreviousDeclImpl_0DelegateHook;
                    _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_getPreviousDeclImpl_0DelegateInstance).ToPointer();
                    _getMostRecentDeclImpl_0DelegateInstance += _getMostRecentDeclImpl_0DelegateHook;
                    _Thunks[6] = Marshal.GetFunctionPointerForDelegate(_getMostRecentDeclImpl_0DelegateInstance).ToPointer();
                    _getBody_0DelegateInstance += _getBody_0DelegateHook;
                    _Thunks[7] = Marshal.GetFunctionPointerForDelegate(_getBody_0DelegateInstance).ToPointer();
                    _hasBody_0DelegateInstance += _hasBody_0DelegateHook;
                    _Thunks[8] = Marshal.GetFunctionPointerForDelegate(_hasBody_0DelegateInstance).ToPointer();
                    _getNameForDiagnostic_0DelegateInstance += _getNameForDiagnostic_0DelegateHook;
                    _Thunks[9] = Marshal.GetFunctionPointerForDelegate(_getNameForDiagnostic_0DelegateInstance).ToPointer();
                }

                if (_NewVTables == null)
                {
                    _NewVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(11 * 8);
                    _NewVTables[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + 8) = _Thunks[0];
                    *(void**)(vfptr0 + 16) = _Thunks[1];
                    *(void**)(vfptr0 + 24) = _Thunks[2];
                    *(void**)(vfptr0 + 32) = _Thunks[3];
                    *(void**)(vfptr0 + 40) = _Thunks[4];
                    *(void**)(vfptr0 + 48) = _Thunks[5];
                    *(void**)(vfptr0 + 56) = _Thunks[6];
                    *(void**)(vfptr0 + 64) = _Thunks[7];
                    *(void**)(vfptr0 + 72) = _Thunks[8];
                    *(void**)(vfptr0 + 80) = *(void**)(native->vfptr0 + 80);
                    *(void**)(vfptr0 + 88) = _Thunks[9];
                }

                native->vfptr0 = new IntPtr(_NewVTables[0]);
            }

            #endregion
        }

        /// <summary>
        /// <para>ParmVarDecl - Represents a parameter to a function.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// ParmVarDecl - Represents a parameter to a function.</para>
        /// </remarks>
        public unsafe partial class ParmVarDecl : clang.VarDecl, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 88)]
            public new partial struct Internal
            {
                [FieldOffset(8)]
                internal llvm.PointerIntPair.Internal NextInContextAndBits;

                [FieldOffset(16)]
                internal llvm.PointerUnion.Internal DeclCtx;

                [FieldOffset(24)]
                public clang.SourceLocation.Internal Loc;

                [FieldOffset(28)]
                public uint DeclKind;

                [FieldOffset(29)]
                public uint InvalidDecl;

                [FieldOffset(29)]
                public uint HasAttrs;

                [FieldOffset(29)]
                public uint Implicit;

                [FieldOffset(29)]
                public uint Used;

                [FieldOffset(29)]
                public uint Referenced;

                [FieldOffset(29)]
                public uint Access;

                [FieldOffset(29)]
                public uint FromASTFile;

                [FieldOffset(30)]
                public uint Hidden;

                [FieldOffset(30)]
                public uint IdentifierNamespace;

                [FieldOffset(31)]
                public uint CacheValidAndLinkage;

                [FieldOffset(32)]
                public clang.DeclarationName.Internal Name;

                [FieldOffset(40)]
                public clang.QualType.Internal DeclType;

                [FieldOffset(48)]
                internal llvm.PointerUnion.Internal DeclInfo;

                [FieldOffset(56)]
                public clang.SourceLocation.Internal InnerLocStart;

                [FieldOffset(72)]
                internal llvm.PointerUnion4.Internal Init;

                [FieldOffset(80)]
                internal clang.VarDecl._.Internal __;

                [FieldOffset(0)]
                public global::System.IntPtr vfptr0;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11ParmVarDeclC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11ParmVarDeclD2Ev")]
                internal static extern void dtor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11ParmVarDecl18CreateDeserializedERNS_10ASTContextEj")]
                internal static extern global::System.IntPtr CreateDeserialized_0(global::System.IntPtr C, uint ID);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11ParmVarDecl14getSourceRangeEv")]
                internal static extern clang.SourceRange.Internal getSourceRange_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11ParmVarDecl22setObjCMethodScopeInfoEj")]
                internal static extern void setObjCMethodScopeInfo_0(global::System.IntPtr instance, uint parameterIndex);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11ParmVarDecl12setScopeInfoEjj")]
                internal static extern void setScopeInfo_0(global::System.IntPtr instance, uint scopeDepth, uint parameterIndex);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11ParmVarDecl21isObjCMethodParameterEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isObjCMethodParameter_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11ParmVarDecl21getFunctionScopeDepthEv")]
                internal static extern uint getFunctionScopeDepth_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11ParmVarDecl21getFunctionScopeIndexEv")]
                internal static extern uint getFunctionScopeIndex_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11ParmVarDecl20getObjCDeclQualifierEv")]
                internal static extern clang.Decl.ObjCDeclQualifier getObjCDeclQualifier_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11ParmVarDecl20setObjCDeclQualifierENS_4Decl17ObjCDeclQualifierE")]
                internal static extern void setObjCDeclQualifier_0(global::System.IntPtr instance, clang.Decl.ObjCDeclQualifier QTVal);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11ParmVarDecl13isKNRPromotedEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isKNRPromoted_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11ParmVarDecl14setKNRPromotedEb")]
                internal static extern void setKNRPromoted_0(global::System.IntPtr instance, bool promoted);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11ParmVarDecl18getDefaultArgRangeEv")]
                internal static extern clang.SourceRange.Internal getDefaultArgRange_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11ParmVarDecl13hasDefaultArgEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasDefaultArg_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11ParmVarDecl21hasUnparsedDefaultArgEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasUnparsedDefaultArg_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11ParmVarDecl27hasUninstantiatedDefaultArgEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasUninstantiatedDefaultArg_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11ParmVarDecl21setUnparsedDefaultArgEv")]
                internal static extern void setUnparsedDefaultArg_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11ParmVarDecl22hasInheritedDefaultArgEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasInheritedDefaultArg_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11ParmVarDecl25setHasInheritedDefaultArgEb")]
                internal static extern void setHasInheritedDefaultArg_0(global::System.IntPtr instance, bool I);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11ParmVarDecl15getOriginalTypeEv")]
                internal static extern clang.QualType.Internal getOriginalType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11ParmVarDecl15isParameterPackEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isParameterPack_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11ParmVarDecl17setOwningFunctionEPNS_11DeclContextE")]
                internal static extern void setOwningFunction_0(global::System.IntPtr instance, global::System.IntPtr FD);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11ParmVarDecl7classofEPKNS_4DeclE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr D);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11ParmVarDecl11classofKindENS_4Decl4KindE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classofKind_0(clang.Decl.Kind K);
            }

            public enum MaxFunctionScopeDepth : uint
            {
                MaxFunctionScopeDepth = 255
            }

            public enum MaxFunctionScopeIndex : uint
            {
                MaxFunctionScopeIndex = 255
            }

            private readonly bool __ownsNativeInstance;

            public static new ParmVarDecl __CreateInstance(global::System.IntPtr native)
            {
                return new ParmVarDecl((ParmVarDecl.Internal*) native);
            }

            public static ParmVarDecl __CreateInstance(ParmVarDecl.Internal native)
            {
                return new ParmVarDecl(native);
            }

            private static ParmVarDecl.Internal* __CopyValue(ParmVarDecl.Internal native)
            {
                var ret = (ParmVarDecl.Internal*) Marshal.AllocHGlobal(88);
                *ret = native;
                return ret;
            }

            private ParmVarDecl(ParmVarDecl.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected ParmVarDecl(ParmVarDecl.Internal* native, bool isInternalImpl = false)
                : base((clang.VarDecl.Internal*) native)
            {
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Decl __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public override clang.SourceRange getSourceRange()
            {
                var __ret = Internal.getSourceRange_0(__Instance);
                return clang.SourceRange.__CreateInstance(__ret);
            }

            public void setObjCMethodScopeInfo(uint parameterIndex)
            {
                Internal.setObjCMethodScopeInfo_0(__Instance, parameterIndex);
            }

            public void setScopeInfo(uint scopeDepth, uint parameterIndex)
            {
                Internal.setScopeInfo_0(__Instance, scopeDepth, parameterIndex);
            }

            public bool isObjCMethodParameter()
            {
                var __ret = Internal.isObjCMethodParameter_0(__Instance);
                return __ret;
            }

            public uint getFunctionScopeDepth()
            {
                var __ret = Internal.getFunctionScopeDepth_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Returns the index of this parameter in its prototype or method
            /// scope.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Returns the index of this parameter in its prototype or
            /// method scope.</para>
            /// </remarks>
            public uint getFunctionScopeIndex()
            {
                var __ret = Internal.getFunctionScopeIndex_0(__Instance);
                return __ret;
            }

            public clang.Decl.ObjCDeclQualifier getObjCDeclQualifier()
            {
                var __ret = Internal.getObjCDeclQualifier_0(__Instance);
                return __ret;
            }

            public void setObjCDeclQualifier(clang.Decl.ObjCDeclQualifier QTVal)
            {
                var arg0 = QTVal;
                Internal.setObjCDeclQualifier_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>True if the value passed to this parameter must undergo
            /// K&amp;R-style default argument promotion:</para>
            /// </summary>
            /// <remarks>
            /// <para>/// True if the value passed to this parameter must
            /// undergo</para>
            /// <para>  /// K&amp;R-style default argument promotion:</para>
            /// <para>  ///</para>
            /// <para>  /// C99 6.5.2.2.</para>
            /// <para>  ///   If the expression that denotes the called function has a
            /// type</para>
            /// <para>  ///   that does not include a prototype, the integer promotions
            /// are</para>
            /// <para>  ///   performed on each argument, and arguments that have type
            /// float</para>
            /// <para>  ///   are promoted to double.</para>
            /// </remarks>
            public bool isKNRPromoted()
            {
                var __ret = Internal.isKNRPromoted_0(__Instance);
                return __ret;
            }

            public void setKNRPromoted(bool promoted)
            {
                Internal.setKNRPromoted_0(__Instance, promoted);
            }

            /// <summary>
            /// <para>Retrieve the source range that covers the entire default
            /// argument.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the source range that covers the entire
            /// default</para>
            /// <para>  /// argument.</para>
            /// </remarks>
            public clang.SourceRange getDefaultArgRange()
            {
                var __ret = Internal.getDefaultArgRange_0(__Instance);
                return clang.SourceRange.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>hasDefaultArg - Determines whether this parameter has a default
            /// argument, either parsed or not.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// hasDefaultArg - Determines whether this parameter has a
            /// default argument,</para>
            /// <para>  /// either parsed or not.</para>
            /// </remarks>
            public bool hasDefaultArg()
            {
                var __ret = Internal.hasDefaultArg_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>hasUnparsedDefaultArg - Determines whether this parameter has a
            /// default argument that has not yet been parsed. This will occur during the
            /// processing of a C++ class whose member functions have default arguments,
            /// e.g.,</para>
            /// </summary>
            /// <remarks>
            /// <para>/// hasUnparsedDefaultArg - Determines whether this parameter has
            /// a</para>
            /// <para>  /// default argument that has not yet been parsed. This will
            /// occur</para>
            /// <para>  /// during the processing of a C++ class whose member functions
            /// have</para>
            /// <para>  /// default arguments, e.g.,</para>
            /// <para>  /// @code</para>
            /// <para>  ///   class X {</para>
            /// <para>  ///   public:</para>
            /// <para>  ///     void f(int x = 17); // x has an unparsed default
            /// argument now</para>
            /// <para>  ///   }; // x has a regular default argument now</para>
            /// <para>  /// @endcode</para>
            /// </remarks>
            public bool hasUnparsedDefaultArg()
            {
                var __ret = Internal.hasUnparsedDefaultArg_0(__Instance);
                return __ret;
            }

            public bool hasUninstantiatedDefaultArg()
            {
                var __ret = Internal.hasUninstantiatedDefaultArg_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>setUnparsedDefaultArg - Specify that this parameter has an
            /// unparsed default argument. The argument will be replaced with a real
            /// default argument via setDefaultArg when the class definition enclosing the
            /// function declaration that owns this default argument is completed.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// setUnparsedDefaultArg - Specify that this parameter has
            /// an</para>
            /// <para>  /// unparsed default argument. The argument will be replaced
            /// with a</para>
            /// <para>  /// real default argument via setDefaultArg when the
            /// class</para>
            /// <para>  /// definition enclosing the function declaration that owns
            /// this</para>
            /// <para>  /// default argument is completed.</para>
            /// </remarks>
            public void setUnparsedDefaultArg()
            {
                Internal.setUnparsedDefaultArg_0(__Instance);
            }

            public bool hasInheritedDefaultArg()
            {
                var __ret = Internal.hasInheritedDefaultArg_0(__Instance);
                return __ret;
            }

            public void setHasInheritedDefaultArg(bool I)
            {
                Internal.setHasInheritedDefaultArg_0(__Instance, I);
            }

            public clang.QualType getOriginalType()
            {
                var __ret = Internal.getOriginalType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Determine whether this parameter is actually a function parameter
            /// pack.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine whether this parameter is actually a
            /// function</para>
            /// <para>  /// parameter pack.</para>
            /// </remarks>
            public bool isParameterPack()
            {
                var __ret = Internal.isParameterPack_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>setOwningFunction - Sets the function declaration that owns this
            /// ParmVarDecl. Since ParmVarDecls are often created before the FunctionDecls
            /// that own them, this routine is required to update the DeclContext
            /// appropriately.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// setOwningFunction - Sets the function declaration that owns
            /// this</para>
            /// <para>  /// ParmVarDecl. Since ParmVarDecls are often created before
            /// the</para>
            /// <para>  /// FunctionDecls that own them, this routine is required to
            /// update</para>
            /// <para>  /// the DeclContext appropriately.</para>
            /// </remarks>
            public void setOwningFunction(clang.DeclContext FD)
            {
                var arg0 = ReferenceEquals(FD, null) ? global::System.IntPtr.Zero : FD.__Instance;
                Internal.setOwningFunction_0(__Instance, arg0);
            }

            public static clang.ParmVarDecl CreateDeserialized(clang.ASTContext C, uint ID)
            {
                var arg0 = ReferenceEquals(C, null) ? global::System.IntPtr.Zero : C.__Instance;
                var __ret = Internal.CreateDeserialized_0(arg0, ID);
                clang.ParmVarDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.ParmVarDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.ParmVarDecl) clang.ParmVarDecl.NativeToManagedMap[__ret];
                else clang.ParmVarDecl.NativeToManagedMap[__ret] = __result0 = (clang.ParmVarDecl) clang.ParmVarDecl.__CreateInstance(__ret);
                return __result0;
            }

            public static bool classof(clang.Decl D)
            {
                var arg0 = ReferenceEquals(D, null) ? global::System.IntPtr.Zero : D.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }

            public static bool classofKind(clang.Decl.Kind K)
            {
                var arg0 = K;
                var __ret = Internal.classofKind_0(arg0);
                return __ret;
            }

            #region Virtual table interop

            // ParmVarDecl
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
            private static _dtor_0Delegate _dtor_0DelegateInstance;

            private static void _dtor_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (ParmVarDecl) _References[instance].Target;
                __target.DestroyNativeInstance();
            }

            // SourceRange getSourceRange() const override
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate clang.SourceRange.Internal _getSourceRange_0Delegate(global::System.IntPtr instance);
            private static _getSourceRange_0Delegate _getSourceRange_0DelegateInstance;

            private static clang.SourceRange.Internal _getSourceRange_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (ParmVarDecl) _References[instance].Target;
                var __ret = __target.getSourceRange();
                return ReferenceEquals(__ret, null) ? new clang.SourceRange.Internal() : *(clang.SourceRange.Internal*) (__ret.__Instance);
            }

            // bool isOutOfLine() const override
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate bool _isOutOfLine_0Delegate(global::System.IntPtr instance);
            private static _isOutOfLine_0Delegate _isOutOfLine_0DelegateInstance;

            private static bool _isOutOfLine_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (ParmVarDecl) _References[instance].Target;
                var __ret = __target.isOutOfLine();
                return __ret;
            }

            // VarDecl *getCanonicalDecl() override
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getCanonicalDecl_0Delegate(global::System.IntPtr instance);
            private static _getCanonicalDecl_0Delegate _getCanonicalDecl_0DelegateInstance;

            private static global::System.IntPtr _getCanonicalDecl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (ParmVarDecl) _References[instance].Target;
                var __ret = __target.getCanonicalDecl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // VarDecl *getNextRedeclarationImpl() override
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getNextRedeclarationImpl_0Delegate(global::System.IntPtr instance);
            private static _getNextRedeclarationImpl_0Delegate _getNextRedeclarationImpl_0DelegateInstance;

            private static global::System.IntPtr _getNextRedeclarationImpl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (ParmVarDecl) _References[instance].Target;
                var __ret = __target.getNextRedeclarationImpl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // VarDecl *getPreviousDeclImpl() override
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getPreviousDeclImpl_0Delegate(global::System.IntPtr instance);
            private static _getPreviousDeclImpl_0Delegate _getPreviousDeclImpl_0DelegateInstance;

            private static global::System.IntPtr _getPreviousDeclImpl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (ParmVarDecl) _References[instance].Target;
                var __ret = __target.getPreviousDeclImpl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // VarDecl *getMostRecentDeclImpl() override
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getMostRecentDeclImpl_0Delegate(global::System.IntPtr instance);
            private static _getMostRecentDeclImpl_0Delegate _getMostRecentDeclImpl_0DelegateInstance;

            private static global::System.IntPtr _getMostRecentDeclImpl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (ParmVarDecl) _References[instance].Target;
                var __ret = __target.getMostRecentDeclImpl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // Stmt* getBody() const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getBody_0Delegate(global::System.IntPtr instance);
            private static _getBody_0Delegate _getBody_0DelegateInstance;

            private static global::System.IntPtr _getBody_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (ParmVarDecl) _References[instance].Target;
                var __ret = __target.getBody();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // bool hasBody() const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate bool _hasBody_0Delegate(global::System.IntPtr instance);
            private static _hasBody_0Delegate _hasBody_0DelegateInstance;

            private static bool _hasBody_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (ParmVarDecl) _References[instance].Target;
                var __ret = __target.hasBody();
                return __ret;
            }

            // void getNameForDiagnostic(raw_ostream &OS, const PrintingPolicy &Policy, bool Qualified) const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate void _getNameForDiagnostic_0Delegate(global::System.IntPtr instance, global::System.IntPtr OS, global::System.IntPtr Policy, bool Qualified);
            private static _getNameForDiagnostic_0Delegate _getNameForDiagnostic_0DelegateInstance;

            private static void _getNameForDiagnostic_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr OS, global::System.IntPtr Policy, bool Qualified)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (ParmVarDecl) _References[instance].Target;
                llvm.raw_ostream __result0;
                if (OS == IntPtr.Zero) __result0 = null;
                else if (llvm.raw_ostream.NativeToManagedMap.ContainsKey(OS))
                    __result0 = (llvm.raw_ostream) llvm.raw_ostream.NativeToManagedMap[OS];
                else llvm.raw_ostream.NativeToManagedMap[OS] = __result0 = (llvm.raw_ostream) llvm.raw_ostream.__CreateInstance(OS);
                clang.PrintingPolicy __result1;
                if (Policy == IntPtr.Zero) __result1 = null;
                else if (clang.PrintingPolicy.NativeToManagedMap.ContainsKey(Policy))
                    __result1 = (clang.PrintingPolicy) clang.PrintingPolicy.NativeToManagedMap[Policy];
                else __result1 = clang.PrintingPolicy.__CreateInstance(Policy);
                __target.getNameForDiagnostic(__result0, __result1, Qualified);
            }

            private static void*[] _OldVTables;
            private static void*[] _NewVTables;
            private static void*[] _Thunks;
            private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

            void SetupVTables(global::System.IntPtr instance)
            {
                var native = (Internal*)instance.ToPointer();

                if (_References == null)
                    _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

                if (_References.ContainsKey(instance))
                    return;

                _References[instance] = new WeakReference(this);

                if (_OldVTables == null)
                {
                    _OldVTables = new void*[1];
                    _OldVTables[0] = native->vfptr0.ToPointer();
                }

                if (_Thunks == null)
                {
                    _Thunks = new void*[10];
                    _dtor_0DelegateInstance += _dtor_0DelegateHook;
                    _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                    _getSourceRange_0DelegateInstance += _getSourceRange_0DelegateHook;
                    _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_getSourceRange_0DelegateInstance).ToPointer();
                    _isOutOfLine_0DelegateInstance += _isOutOfLine_0DelegateHook;
                    _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_isOutOfLine_0DelegateInstance).ToPointer();
                    _getCanonicalDecl_0DelegateInstance += _getCanonicalDecl_0DelegateHook;
                    _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_getCanonicalDecl_0DelegateInstance).ToPointer();
                    _getNextRedeclarationImpl_0DelegateInstance += _getNextRedeclarationImpl_0DelegateHook;
                    _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_getNextRedeclarationImpl_0DelegateInstance).ToPointer();
                    _getPreviousDeclImpl_0DelegateInstance += _getPreviousDeclImpl_0DelegateHook;
                    _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_getPreviousDeclImpl_0DelegateInstance).ToPointer();
                    _getMostRecentDeclImpl_0DelegateInstance += _getMostRecentDeclImpl_0DelegateHook;
                    _Thunks[6] = Marshal.GetFunctionPointerForDelegate(_getMostRecentDeclImpl_0DelegateInstance).ToPointer();
                    _getBody_0DelegateInstance += _getBody_0DelegateHook;
                    _Thunks[7] = Marshal.GetFunctionPointerForDelegate(_getBody_0DelegateInstance).ToPointer();
                    _hasBody_0DelegateInstance += _hasBody_0DelegateHook;
                    _Thunks[8] = Marshal.GetFunctionPointerForDelegate(_hasBody_0DelegateInstance).ToPointer();
                    _getNameForDiagnostic_0DelegateInstance += _getNameForDiagnostic_0DelegateHook;
                    _Thunks[9] = Marshal.GetFunctionPointerForDelegate(_getNameForDiagnostic_0DelegateInstance).ToPointer();
                }

                if (_NewVTables == null)
                {
                    _NewVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(11 * 8);
                    _NewVTables[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + 8) = _Thunks[0];
                    *(void**)(vfptr0 + 16) = _Thunks[1];
                    *(void**)(vfptr0 + 24) = _Thunks[2];
                    *(void**)(vfptr0 + 32) = _Thunks[3];
                    *(void**)(vfptr0 + 40) = _Thunks[4];
                    *(void**)(vfptr0 + 48) = _Thunks[5];
                    *(void**)(vfptr0 + 56) = _Thunks[6];
                    *(void**)(vfptr0 + 64) = _Thunks[7];
                    *(void**)(vfptr0 + 72) = _Thunks[8];
                    *(void**)(vfptr0 + 80) = *(void**)(native->vfptr0 + 80);
                    *(void**)(vfptr0 + 88) = _Thunks[9];
                }

                native->vfptr0 = new IntPtr(_NewVTables[0]);
            }

            #endregion
        }

        /// <summary>
        /// <para>FunctionDecl - An instance of this class is created to represent
        /// a function declaration or definition.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// FunctionDecl - An instance of this class is created to
        /// represent a</para>
        /// <para>/// function declaration or definition.</para>
        /// <para>///</para>
        /// <para>/// Since a given function can be declared several times in a
        /// program,</para>
        /// <para>/// there may be several FunctionDecls that correspond to
        /// that</para>
        /// <para>/// function. Only one of those FunctionDecls will be found
        /// when</para>
        /// <para>/// traversing the list of declarations in the context of
        /// the</para>
        /// <para>/// FunctionDecl (e.g., the translation unit); this
        /// FunctionDecl</para>
        /// <para>/// contains all of the information known about the function.
        /// Other,</para>
        /// <para>/// previous declarations of the function are available via
        /// the</para>
        /// <para>/// getPreviousDecl() chain.</para>
        /// </remarks>
        public unsafe partial class FunctionDecl : clang.DeclaratorDecl, clang.DeclContext, clang.Redeclarable, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 160)]
            public new partial struct Internal
            {
                [FieldOffset(8)]
                internal llvm.PointerIntPair.Internal NextInContextAndBits;

                [FieldOffset(16)]
                internal llvm.PointerUnion.Internal DeclCtx;

                [FieldOffset(24)]
                public clang.SourceLocation.Internal Loc;

                [FieldOffset(28)]
                public uint DeclKind;

                [FieldOffset(29)]
                public uint InvalidDecl;

                [FieldOffset(29)]
                public uint HasAttrs;

                [FieldOffset(29)]
                public uint Implicit;

                [FieldOffset(29)]
                public uint Used;

                [FieldOffset(29)]
                public uint Referenced;

                [FieldOffset(29)]
                public uint Access;

                [FieldOffset(29)]
                public uint FromASTFile;

                [FieldOffset(30)]
                public uint Hidden;

                [FieldOffset(30)]
                public uint IdentifierNamespace;

                [FieldOffset(31)]
                public uint CacheValidAndLinkage;

                [FieldOffset(32)]
                public clang.DeclarationName.Internal Name;

                [FieldOffset(40)]
                public clang.QualType.Internal DeclType;

                [FieldOffset(48)]
                internal llvm.PointerUnion.Internal DeclInfo;

                [FieldOffset(56)]
                public clang.SourceLocation.Internal InnerLocStart;

                [FieldOffset(0)]
                public uint DeclKind;

                [FieldOffset(1)]
                public bool ExternalLexicalStorage;

                [FieldOffset(1)]
                public bool ExternalVisibleStorage;

                [FieldOffset(1)]
                public bool NeedToReconcileExternalVisibleStorage;

                [FieldOffset(8)]
                internal llvm.PointerIntPair.Internal LookupPtr;

                [FieldOffset(16)]
                public global::System.IntPtr FirstDecl;

                [FieldOffset(24)]
                public global::System.IntPtr LastDecl;

                [FieldOffset(104)]
                public global::System.IntPtr ParamInfo;

                [FieldOffset(112)]
                internal llvm.ArrayRef.Internal DeclsInPrototypeScope;

                [FieldOffset(128)]
                internal clang.LazyOffsetPtr.Internal Body;

                [FieldOffset(136)]
                public uint SClass;

                [FieldOffset(136)]
                public bool IsInline;

                [FieldOffset(136)]
                public bool IsInlineSpecified;

                [FieldOffset(136)]
                public bool IsVirtualAsWritten;

                [FieldOffset(136)]
                public bool IsPure;

                [FieldOffset(136)]
                public bool HasInheritedPrototype;

                [FieldOffset(136)]
                public bool HasWrittenPrototype;

                [FieldOffset(137)]
                public bool IsDeleted;

                [FieldOffset(137)]
                public bool IsTrivial;

                [FieldOffset(137)]
                public bool IsDefaulted;

                [FieldOffset(137)]
                public bool IsExplicitlyDefaulted;

                [FieldOffset(137)]
                public bool HasImplicitReturnZero;

                [FieldOffset(137)]
                public bool IsLateTemplateParsed;

                [FieldOffset(137)]
                public bool IsConstexpr;

                [FieldOffset(137)]
                public bool UsesSEHTry;

                [FieldOffset(138)]
                public uint HasSkippedBody;

                [FieldOffset(140)]
                public clang.SourceLocation.Internal EndRangeLoc;

                [FieldOffset(144)]
                internal llvm.PointerUnion4.Internal TemplateOrSpecialization;

                [FieldOffset(152)]
                public clang.DeclarationNameLoc.Internal DNLoc;

                [FieldOffset(0)]
                public global::System.IntPtr vfptr0;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12FunctionDeclC2ENS_4Decl4KindERNS_10ASTContextEPNS_11DeclContextENS_14SourceLocationERKNS_19DeclarationNameInfoENS_8QualTypeEPNS_14TypeSourceInfoENS_12StorageClassEbb")]
                internal static extern void ctor_0(global::System.IntPtr instance, clang.Decl.Kind DK, global::System.IntPtr C, global::System.IntPtr DC, clang.SourceLocation.Internal StartLoc, global::System.IntPtr NameInfo, clang.QualType.Internal T, global::System.IntPtr TInfo, clang.StorageClass S, bool isInlineSpecified, bool isConstexprSpecified);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12FunctionDeclC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12FunctionDeclD2Ev")]
                internal static extern void dtor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12FunctionDecl24getNextRedeclarationImplEv")]
                internal static extern global::System.IntPtr getNextRedeclarationImpl_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12FunctionDecl19getPreviousDeclImplEv")]
                internal static extern global::System.IntPtr getPreviousDeclImpl_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12FunctionDecl21getMostRecentDeclImplEv")]
                internal static extern global::System.IntPtr getMostRecentDeclImpl_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12FunctionDecl6CreateERNS_10ASTContextEPNS_11DeclContextENS_14SourceLocationES5_NS_15DeclarationNameENS_8QualTypeEPNS_14TypeSourceInfoENS_12StorageClassEbbb")]
                internal static extern global::System.IntPtr Create_0(global::System.IntPtr C, global::System.IntPtr DC, clang.SourceLocation.Internal StartLoc, clang.SourceLocation.Internal NLoc, clang.DeclarationName.Internal N, clang.QualType.Internal T, global::System.IntPtr TInfo, clang.StorageClass SC, bool isInlineSpecified, bool hasWrittenPrototype, bool isConstexprSpecified);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12FunctionDecl6CreateERNS_10ASTContextEPNS_11DeclContextENS_14SourceLocationERKNS_19DeclarationNameInfoENS_8QualTypeEPNS_14TypeSourceInfoENS_12StorageClassEbbb")]
                internal static extern global::System.IntPtr Create_1(global::System.IntPtr C, global::System.IntPtr DC, clang.SourceLocation.Internal StartLoc, global::System.IntPtr NameInfo, clang.QualType.Internal T, global::System.IntPtr TInfo, clang.StorageClass SC, bool isInlineSpecified, bool hasWrittenPrototype, bool isConstexprSpecified);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12FunctionDecl18CreateDeserializedERNS_10ASTContextEj")]
                internal static extern global::System.IntPtr CreateDeserialized_0(global::System.IntPtr C, uint ID);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12FunctionDecl11getNameInfoEv")]
                internal static extern void getNameInfo_0(global::System.IntPtr @return, global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12FunctionDecl20getNameForDiagnosticERN4llvm11raw_ostreamERKNS_14PrintingPolicyEb")]
                internal static extern void getNameForDiagnostic_0(global::System.IntPtr instance, global::System.IntPtr OS, global::System.IntPtr Policy, bool Qualified);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12FunctionDecl11setRangeEndENS_14SourceLocationE")]
                internal static extern void setRangeEnd_0(global::System.IntPtr instance, clang.SourceLocation.Internal E);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12FunctionDecl14getSourceRangeEv")]
                internal static extern clang.SourceRange.Internal getSourceRange_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12FunctionDecl7hasBodyERPKS0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasBody_0(global::System.IntPtr instance, global::System.IntPtr Definition);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12FunctionDecl7hasBodyEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasBody_1(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12FunctionDecl14hasTrivialBodyEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasTrivialBody_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12FunctionDecl9isDefinedERPKS0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isDefined_0(global::System.IntPtr instance, global::System.IntPtr Definition);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12FunctionDecl9isDefinedEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isDefined_1(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12FunctionDecl7getBodyERPKS0_")]
                internal static extern global::System.IntPtr getBody_0(global::System.IntPtr instance, global::System.IntPtr Definition);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12FunctionDecl7getBodyEv")]
                internal static extern global::System.IntPtr getBody_1(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12FunctionDecl28isThisDeclarationADefinitionEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isThisDeclarationADefinition_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12FunctionDecl28doesThisDeclarationHaveABodyEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool doesThisDeclarationHaveABody_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12FunctionDecl7setBodyEPNS_4StmtE")]
                internal static extern void setBody_0(global::System.IntPtr instance, global::System.IntPtr B);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12FunctionDecl11setLazyBodyEy")]
                internal static extern void setLazyBody_0(global::System.IntPtr instance, ulong Offset);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12FunctionDecl10isVariadicEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isVariadic_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12FunctionDecl18isVirtualAsWrittenEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isVirtualAsWritten_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12FunctionDecl19setVirtualAsWrittenEb")]
                internal static extern void setVirtualAsWritten_0(global::System.IntPtr instance, bool V);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12FunctionDecl6isPureEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isPure_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12FunctionDecl7setPureEb")]
                internal static extern void setPure_0(global::System.IntPtr instance, bool P);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12FunctionDecl20isLateTemplateParsedEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isLateTemplateParsed_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12FunctionDecl21setLateTemplateParsedEb")]
                internal static extern void setLateTemplateParsed_0(global::System.IntPtr instance, bool ILT);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12FunctionDecl9isTrivialEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isTrivial_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12FunctionDecl10setTrivialEb")]
                internal static extern void setTrivial_0(global::System.IntPtr instance, bool IT);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12FunctionDecl11isDefaultedEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isDefaulted_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12FunctionDecl12setDefaultedEb")]
                internal static extern void setDefaulted_0(global::System.IntPtr instance, bool D);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12FunctionDecl21isExplicitlyDefaultedEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isExplicitlyDefaulted_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12FunctionDecl22setExplicitlyDefaultedEb")]
                internal static extern void setExplicitlyDefaulted_0(global::System.IntPtr instance, bool ED);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12FunctionDecl21hasImplicitReturnZeroEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasImplicitReturnZero_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12FunctionDecl24setHasImplicitReturnZeroEb")]
                internal static extern void setHasImplicitReturnZero_0(global::System.IntPtr instance, bool IRZ);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12FunctionDecl12hasPrototypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasPrototype_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12FunctionDecl19hasWrittenPrototypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasWrittenPrototype_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12FunctionDecl21hasInheritedPrototypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasInheritedPrototype_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12FunctionDecl24setHasInheritedPrototypeEb")]
                internal static extern void setHasInheritedPrototype_0(global::System.IntPtr instance, bool P);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12FunctionDecl11isConstexprEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isConstexpr_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12FunctionDecl12setConstexprEb")]
                internal static extern void setConstexpr_0(global::System.IntPtr instance, bool IC);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12FunctionDecl10usesSEHTryEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool usesSEHTry_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12FunctionDecl13setUsesSEHTryEb")]
                internal static extern void setUsesSEHTry_0(global::System.IntPtr instance, bool UST);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12FunctionDecl9isDeletedEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isDeleted_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12FunctionDecl18isDeletedAsWrittenEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isDeletedAsWritten_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12FunctionDecl19setDeletedAsWrittenEb")]
                internal static extern void setDeletedAsWritten_0(global::System.IntPtr instance, bool D);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12FunctionDecl6isMainEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isMain_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12FunctionDecl18isMSVCRTEntryPointEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isMSVCRTEntryPoint_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12FunctionDecl33isReservedGlobalPlacementOperatorEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isReservedGlobalPlacementOperator_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12FunctionDecl37isReplaceableGlobalAllocationFunctionEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isReplaceableGlobalAllocationFunction_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12FunctionDecl49getCorrespondingUnsizedGlobalDeallocationFunctionEv")]
                internal static extern global::System.IntPtr getCorrespondingUnsizedGlobalDeallocationFunction_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12FunctionDecl18getLanguageLinkageEv")]
                internal static extern clang.LanguageLinkage getLanguageLinkage_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12FunctionDecl9isExternCEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isExternC_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12FunctionDecl18isInExternCContextEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isInExternCContext_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12FunctionDecl20isInExternCXXContextEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isInExternCXXContext_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12FunctionDecl8isGlobalEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isGlobal_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12FunctionDecl10isNoReturnEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isNoReturn_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12FunctionDecl14hasSkippedBodyEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasSkippedBody_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12FunctionDecl17setHasSkippedBodyEb")]
                internal static extern void setHasSkippedBody_0(global::System.IntPtr instance, bool Skipped);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12FunctionDecl22setPreviousDeclarationEPS0_")]
                internal static extern void setPreviousDeclaration_0(global::System.IntPtr instance, global::System.IntPtr PrevDecl);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12FunctionDecl16getCanonicalDeclEv")]
                internal static extern global::System.IntPtr getCanonicalDecl_1(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12FunctionDecl12getBuiltinIDEv")]
                internal static extern uint getBuiltinID_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12FunctionDecl10param_sizeEv")]
                internal static extern uint param_size_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12FunctionDecl11param_beginEv")]
                internal static extern global::System.IntPtr param_begin_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12FunctionDecl9param_endEv")]
                internal static extern global::System.IntPtr param_end_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12FunctionDecl12getNumParamsEv")]
                internal static extern uint getNumParams_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12FunctionDecl12getParamDeclEj")]
                internal static extern global::System.IntPtr getParamDecl_1(global::System.IntPtr instance, uint i);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12FunctionDecl23getMinRequiredArgumentsEv")]
                internal static extern uint getMinRequiredArguments_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12FunctionDecl13getReturnTypeEv")]
                internal static extern clang.QualType.Internal getReturnType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12FunctionDecl24getReturnTypeSourceRangeEv")]
                internal static extern clang.SourceRange.Internal getReturnTypeSourceRange_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12FunctionDecl17getCallResultTypeEv")]
                internal static extern clang.QualType.Internal getCallResultType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12FunctionDecl15getStorageClassEv")]
                internal static extern clang.StorageClass getStorageClass_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12FunctionDecl17isInlineSpecifiedEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isInlineSpecified_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12FunctionDecl18setInlineSpecifiedEb")]
                internal static extern void setInlineSpecified_0(global::System.IntPtr instance, bool I);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12FunctionDecl19setImplicitlyInlineEv")]
                internal static extern void setImplicitlyInline_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12FunctionDecl9isInlinedEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isInlined_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12FunctionDecl35isInlineDefinitionExternallyVisibleEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isInlineDefinitionExternallyVisible_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12FunctionDecl16isMSExternInlineEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isMSExternInline_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12FunctionDecl47doesDeclarationForceExternallyVisibleDefinitionEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool doesDeclarationForceExternallyVisibleDefinition_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12FunctionDecl20isOverloadedOperatorEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isOverloadedOperator_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12FunctionDecl21getOverloadedOperatorEv")]
                internal static extern clang.OverloadedOperatorKind getOverloadedOperator_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12FunctionDecl20getLiteralIdentifierEv")]
                internal static extern global::System.IntPtr getLiteralIdentifier_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12FunctionDecl33getInstantiatedFromMemberFunctionEv")]
                internal static extern global::System.IntPtr getInstantiatedFromMemberFunction_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12FunctionDecl16getTemplatedKindEv")]
                internal static extern clang.FunctionDecl.TemplatedKind getTemplatedKind_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12FunctionDecl32setInstantiationOfMemberFunctionEPS0_NS_26TemplateSpecializationKindE")]
                internal static extern void setInstantiationOfMemberFunction_1(global::System.IntPtr instance, global::System.IntPtr FD, clang.TemplateSpecializationKind TSK);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12FunctionDecl32isFunctionTemplateSpecializationEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isFunctionTemplateSpecialization_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12FunctionDecl34getClassScopeSpecializationPatternEv")]
                internal static extern global::System.IntPtr getClassScopeSpecializationPattern_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12FunctionDecl24isImplicitlyInstantiableEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isImplicitlyInstantiable_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12FunctionDecl23isTemplateInstantiationEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isTemplateInstantiation_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12FunctionDecl31getTemplateInstantiationPatternEv")]
                internal static extern global::System.IntPtr getTemplateInstantiationPattern_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12FunctionDecl38getTemplateSpecializationArgsAsWrittenEv")]
                internal static extern global::System.IntPtr getTemplateSpecializationArgsAsWritten_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12FunctionDecl29getTemplateSpecializationKindEv")]
                internal static extern clang.TemplateSpecializationKind getTemplateSpecializationKind_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12FunctionDecl29setTemplateSpecializationKindENS_26TemplateSpecializationKindENS_14SourceLocationE")]
                internal static extern void setTemplateSpecializationKind_0(global::System.IntPtr instance, clang.TemplateSpecializationKind TSK, clang.SourceLocation.Internal PointOfInstantiation);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12FunctionDecl23getPointOfInstantiationEv")]
                internal static extern clang.SourceLocation.Internal getPointOfInstantiation_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12FunctionDecl11isOutOfLineEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isOutOfLine_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12FunctionDecl21getMemoryFunctionKindEv")]
                internal static extern uint getMemoryFunctionKind_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12FunctionDecl7classofEPKNS_4DeclE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr D);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12FunctionDecl11classofKindENS_4Decl4KindE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classofKind_0(clang.Decl.Kind K);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12FunctionDecl17castToDeclContextEPKS0_")]
                internal static extern global::System.IntPtr castToDeclContext_0(global::System.IntPtr D);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12FunctionDecl19castFromDeclContextEPKNS_11DeclContextE")]
                internal static extern global::System.IntPtr castFromDeclContext_0(global::System.IntPtr DC);
            }

            /// <summary>
            /// <para>The kind of templated function a FunctionDecl can be.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief The kind of templated function a FunctionDecl can
            /// be.</para>
            /// </remarks>
            public enum TemplatedKind : uint
            {
                TK_NonTemplate = 0,
                TK_FunctionTemplate = 1,
                TK_MemberSpecialization = 2,
                TK_FunctionTemplateSpecialization = 3,
                TK_DependentFunctionTemplateSpecialization = 4
            }

            private readonly bool __ownsNativeInstance;

            public static new FunctionDecl __CreateInstance(global::System.IntPtr native)
            {
                return new FunctionDecl((FunctionDecl.Internal*) native);
            }

            public static FunctionDecl __CreateInstance(FunctionDecl.Internal native)
            {
                return new FunctionDecl(native);
            }

            private static FunctionDecl.Internal* __CopyValue(FunctionDecl.Internal native)
            {
                var ret = (FunctionDecl.Internal*) Marshal.AllocHGlobal(160);
                *ret = native;
                return ret;
            }

            private FunctionDecl(FunctionDecl.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected FunctionDecl(FunctionDecl.Internal* native, bool isInternalImpl = false)
                : base((clang.DeclaratorDecl.Internal*) native)
            {
            }

            protected FunctionDecl(clang.Decl.Kind DK, clang.ASTContext C, clang.DeclContext DC, clang.SourceLocation StartLoc, clang.DeclarationNameInfo NameInfo, clang.QualType T, clang.TypeSourceInfo TInfo, clang.StorageClass S, bool isInlineSpecified, bool isConstexprSpecified)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(160);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = DK;
                var arg1 = ReferenceEquals(C, null) ? global::System.IntPtr.Zero : C.__Instance;
                var arg2 = ReferenceEquals(DC, null) ? global::System.IntPtr.Zero : DC.__Instance;
                var arg3 = ReferenceEquals(StartLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (StartLoc.__Instance);
                var arg4 = ReferenceEquals(NameInfo, null) ? global::System.IntPtr.Zero : NameInfo.__Instance;
                var arg5 = ReferenceEquals(T, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (T.__Instance);
                var arg6 = ReferenceEquals(TInfo, null) ? global::System.IntPtr.Zero : TInfo.__Instance;
                var arg7 = S;
                Internal.ctor_0(__Instance, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, isInlineSpecified, isConstexprSpecified);
                SetupVTables(__Instance);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Decl __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            protected virtual clang.FunctionDecl getNextRedeclarationImpl()
            {
                var __ret = Internal.getNextRedeclarationImpl_0(__Instance);
                clang.FunctionDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.FunctionDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.FunctionDecl) clang.FunctionDecl.NativeToManagedMap[__ret];
                else clang.FunctionDecl.NativeToManagedMap[__ret] = __result0 = (clang.FunctionDecl) clang.FunctionDecl.__CreateInstance(__ret);
                return __result0;
            }

            protected virtual clang.FunctionDecl getPreviousDeclImpl()
            {
                var __ret = Internal.getPreviousDeclImpl_0(__Instance);
                clang.FunctionDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.FunctionDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.FunctionDecl) clang.FunctionDecl.NativeToManagedMap[__ret];
                else clang.FunctionDecl.NativeToManagedMap[__ret] = __result0 = (clang.FunctionDecl) clang.FunctionDecl.__CreateInstance(__ret);
                return __result0;
            }

            protected virtual clang.FunctionDecl getMostRecentDeclImpl()
            {
                var __ret = Internal.getMostRecentDeclImpl_0(__Instance);
                clang.FunctionDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.FunctionDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.FunctionDecl) clang.FunctionDecl.NativeToManagedMap[__ret];
                else clang.FunctionDecl.NativeToManagedMap[__ret] = __result0 = (clang.FunctionDecl) clang.FunctionDecl.__CreateInstance(__ret);
                return __result0;
            }

            public clang.DeclarationNameInfo getNameInfo()
            {
                var __ret = new clang.DeclarationNameInfo.Internal();
                Internal.getNameInfo_0(new IntPtr(&__ret), __Instance);
                return clang.DeclarationNameInfo.__CreateInstance(__ret);
            }

            public virtual void getNameForDiagnostic(llvm.raw_ostream OS, clang.PrintingPolicy Policy, bool Qualified)
            {
                var arg0 = ReferenceEquals(OS, null) ? global::System.IntPtr.Zero : OS.__Instance;
                var arg1 = ReferenceEquals(Policy, null) ? global::System.IntPtr.Zero : Policy.__Instance;
                Internal.getNameForDiagnostic_0(__Instance, arg0, arg1, Qualified);
            }

            public void setRangeEnd(clang.SourceLocation E)
            {
                var arg0 = ReferenceEquals(E, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (E.__Instance);
                Internal.setRangeEnd_0(__Instance, arg0);
            }

            public override clang.SourceRange getSourceRange()
            {
                var __ret = Internal.getSourceRange_0(__Instance);
                return clang.SourceRange.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Returns true if the function has a body (definition). The
            /// function body might be in any of the (re-)declarations of this function.
            /// The variant that accepts a FunctionDecl pointer will set that function
            /// declaration to the actual declaration containing the body (if there is
            /// one).</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Returns true if the function has a body (definition).
            /// The</para>
            /// <para>  /// function body might be in any of the (re-)declarations of
            /// this</para>
            /// <para>  /// function. The variant that accepts a FunctionDecl pointer
            /// will</para>
            /// <para>  /// set that function declaration to the actual
            /// declaration</para>
            /// <para>  /// containing the body (if there is one).</para>
            /// </remarks>
            public bool hasBody(clang.FunctionDecl Definition)
            {
                var arg0 = ReferenceEquals(Definition, null) ? global::System.IntPtr.Zero : Definition.__Instance;
                var __ret = Internal.hasBody_0(__Instance, arg0);
                return __ret;
            }

            public override bool hasBody()
            {
                var __ret = Internal.hasBody_1(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>hasTrivialBody - Returns whether the function has a trivial body
            /// that does not require any specific codegen.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// hasTrivialBody - Returns whether the function has a trivial
            /// body that does</para>
            /// <para>  /// not require any specific codegen.</para>
            /// </remarks>
            public bool hasTrivialBody()
            {
                var __ret = Internal.hasTrivialBody_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>isDefined - Returns true if the function is defined at all,
            /// including a deleted definition. Except for the behavior when the function
            /// is deleted, behaves like hasBody.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// isDefined - Returns true if the function is defined at all,
            /// including</para>
            /// <para>  /// a deleted definition. Except for the behavior when the
            /// function is</para>
            /// <para>  /// deleted, behaves like hasBody.</para>
            /// </remarks>
            public bool isDefined(clang.FunctionDecl Definition)
            {
                var arg0 = ReferenceEquals(Definition, null) ? global::System.IntPtr.Zero : Definition.__Instance;
                var __ret = Internal.isDefined_0(__Instance, arg0);
                return __ret;
            }

            public virtual bool isDefined()
            {
                var __ret = Internal.isDefined_1(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>getBody - Retrieve the body (definition) of the function. The
            /// function body might be in any of the (re-)declarations of this function.
            /// The variant that accepts a FunctionDecl pointer will set that function
            /// declaration to the actual declaration containing the body (if there is
            /// one). NOTE: For checking if there is a body, use hasBody() instead, to
            /// avoid unnecessary AST de-serialization of the body.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getBody - Retrieve the body (definition) of the function.
            /// The</para>
            /// <para>  /// function body might be in any of the (re-)declarations of
            /// this</para>
            /// <para>  /// function. The variant that accepts a FunctionDecl pointer
            /// will</para>
            /// <para>  /// set that function declaration to the actual
            /// declaration</para>
            /// <para>  /// containing the body (if there is one).</para>
            /// <para>  /// NOTE: For checking if there is a body, use hasBody()
            /// instead, to avoid</para>
            /// <para>  /// unnecessary AST de-serialization of the body.</para>
            /// </remarks>
            public clang.Stmt getBody(clang.FunctionDecl Definition)
            {
                var arg0 = ReferenceEquals(Definition, null) ? global::System.IntPtr.Zero : Definition.__Instance;
                var __ret = Internal.getBody_0(__Instance, arg0);
                clang.Stmt __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Stmt.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Stmt) clang.Stmt.NativeToManagedMap[__ret];
                else __result0 = clang.Stmt.__CreateInstance(__ret);
                return __result0;
            }

            public override clang.Stmt getBody()
            {
                var __ret = Internal.getBody_1(__Instance);
                clang.Stmt __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Stmt.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Stmt) clang.Stmt.NativeToManagedMap[__ret];
                else __result0 = clang.Stmt.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>isThisDeclarationADefinition - Returns whether this specific
            /// declaration of the function is also a definition. This does not determine
            /// whether the function has been defined (e.g., in a previous definition); for
            /// that information, use isDefined. Note that this returns false for a
            /// defaulted function unless that function has been implicitly defined
            /// (possibly as deleted).</para>
            /// </summary>
            /// <remarks>
            /// <para>/// isThisDeclarationADefinition - Returns whether this
            /// specific</para>
            /// <para>  /// declaration of the function is also a definition. This does
            /// not</para>
            /// <para>  /// determine whether the function has been defined (e.g., in
            /// a</para>
            /// <para>  /// previous definition); for that information, use isDefined.
            /// Note</para>
            /// <para>  /// that this returns false for a defaulted function unless
            /// that function</para>
            /// <para>  /// has been implicitly defined (possibly as deleted).</para>
            /// </remarks>
            public bool isThisDeclarationADefinition()
            {
                var __ret = Internal.isThisDeclarationADefinition_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>doesThisDeclarationHaveABody - Returns whether this specific
            /// declaration of the function has a body - that is, if it is a non- deleted
            /// definition.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// doesThisDeclarationHaveABody - Returns whether this
            /// specific</para>
            /// <para>  /// declaration of the function has a body - that is, if it is
            /// a non-</para>
            /// <para>  /// deleted definition.</para>
            /// </remarks>
            public bool doesThisDeclarationHaveABody()
            {
                var __ret = Internal.doesThisDeclarationHaveABody_0(__Instance);
                return __ret;
            }

            public void setBody(clang.Stmt B)
            {
                var arg0 = ReferenceEquals(B, null) ? global::System.IntPtr.Zero : B.__Instance;
                Internal.setBody_0(__Instance, arg0);
            }

            public void setLazyBody(ulong Offset)
            {
                var arg0 = Offset;
                Internal.setLazyBody_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>Whether this function is variadic.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Whether this function is variadic.</para>
            /// </remarks>
            public bool isVariadic()
            {
                var __ret = Internal.isVariadic_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Whether this function is marked as virtual explicitly.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Whether this function is marked as virtual explicitly.</para>
            /// </remarks>
            public bool isVirtualAsWritten()
            {
                var __ret = Internal.isVirtualAsWritten_0(__Instance);
                return __ret;
            }

            public void setVirtualAsWritten(bool V)
            {
                Internal.setVirtualAsWritten_0(__Instance, V);
            }

            /// <summary>
            /// <para>Whether this virtual function is pure, i.e. makes the containing
            /// class abstract.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Whether this virtual function is pure, i.e. makes the
            /// containing class</para>
            /// <para>  /// abstract.</para>
            /// </remarks>
            public bool isPure()
            {
                var __ret = Internal.isPure_0(__Instance);
                return __ret;
            }

            public void setPure(bool P)
            {
                Internal.setPure_0(__Instance, P);
            }

            /// <summary>
            /// <para>Whether this templated function will be late parsed.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Whether this templated function will be late parsed.</para>
            /// </remarks>
            public bool isLateTemplateParsed()
            {
                var __ret = Internal.isLateTemplateParsed_0(__Instance);
                return __ret;
            }

            public void setLateTemplateParsed(bool ILT)
            {
                Internal.setLateTemplateParsed_0(__Instance, ILT);
            }

            /// <summary>
            /// <para>Whether this function is &quot;trivial&quot; in some specialized
            /// C++ senses. Can only be true for default constructors, copy constructors,
            /// copy assignment operators, and destructors. Not meaningful until the class
            /// has been fully built by Sema.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Whether this function is &quot;trivial&quot; in some
            /// specialized C++ senses.</para>
            /// <para>  /// Can only be true for default constructors, copy
            /// constructors,</para>
            /// <para>  /// copy assignment operators, and destructors.  Not meaningful
            /// until</para>
            /// <para>  /// the class has been fully built by Sema.</para>
            /// </remarks>
            public bool isTrivial()
            {
                var __ret = Internal.isTrivial_0(__Instance);
                return __ret;
            }

            public void setTrivial(bool IT)
            {
                Internal.setTrivial_0(__Instance, IT);
            }

            /// <summary>
            /// <para>Whether this function is defaulted per C++0x. Only valid for
            /// special member functions.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Whether this function is defaulted per C++0x. Only valid
            /// for</para>
            /// <para>  /// special member functions.</para>
            /// </remarks>
            public bool isDefaulted()
            {
                var __ret = Internal.isDefaulted_0(__Instance);
                return __ret;
            }

            public void setDefaulted(bool D)
            {
                Internal.setDefaulted_0(__Instance, D);
            }

            /// <summary>
            /// <para>Whether this function is explicitly defaulted per C++0x. Only
            /// valid for special member functions.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Whether this function is explicitly defaulted per C++0x. Only
            /// valid</para>
            /// <para>  /// for special member functions.</para>
            /// </remarks>
            public bool isExplicitlyDefaulted()
            {
                var __ret = Internal.isExplicitlyDefaulted_0(__Instance);
                return __ret;
            }

            public void setExplicitlyDefaulted(bool ED)
            {
                Internal.setExplicitlyDefaulted_0(__Instance, ED);
            }

            /// <summary>
            /// <para>Whether falling off this function implicitly returns null/zero.
            /// If a more specific implicit return value is required, front-ends should
            /// synthesize the appropriate return statements.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Whether falling off this function implicitly returns
            /// null/zero.</para>
            /// <para>  /// If a more specific implicit return value is required,
            /// front-ends</para>
            /// <para>  /// should synthesize the appropriate return statements.</para>
            /// </remarks>
            public bool hasImplicitReturnZero()
            {
                var __ret = Internal.hasImplicitReturnZero_0(__Instance);
                return __ret;
            }

            public void setHasImplicitReturnZero(bool IRZ)
            {
                Internal.setHasImplicitReturnZero_0(__Instance, IRZ);
            }

            /// <summary>
            /// <para>Whether this function has a prototype, either because one was
            /// explicitly written or because it was &quot;inherited&quot; by merging a
            /// declaration without a prototype with a declaration that has a
            /// prototype.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Whether this function has a prototype, either because
            /// one</para>
            /// <para>  /// was explicitly written or because it was
            /// &quot;inherited&quot; by merging</para>
            /// <para>  /// a declaration without a prototype with a declaration that
            /// has a</para>
            /// <para>  /// prototype.</para>
            /// </remarks>
            public bool hasPrototype()
            {
                var __ret = Internal.hasPrototype_0(__Instance);
                return __ret;
            }

            public bool hasWrittenPrototype()
            {
                var __ret = Internal.hasWrittenPrototype_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Whether this function inherited its prototype from a previous
            /// declaration.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Whether this function inherited its prototype from
            /// a</para>
            /// <para>  /// previous declaration.</para>
            /// </remarks>
            public bool hasInheritedPrototype()
            {
                var __ret = Internal.hasInheritedPrototype_0(__Instance);
                return __ret;
            }

            public void setHasInheritedPrototype(bool P)
            {
                Internal.setHasInheritedPrototype_0(__Instance, P);
            }

            /// <summary>
            /// <para>Whether this is a (C++11) constexpr function or constexpr
            /// constructor.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Whether this is a (C++11) constexpr function or constexpr
            /// constructor.</para>
            /// </remarks>
            public bool isConstexpr()
            {
                var __ret = Internal.isConstexpr_0(__Instance);
                return __ret;
            }

            public void setConstexpr(bool IC)
            {
                Internal.setConstexpr_0(__Instance, IC);
            }

            /// <summary>
            /// <para>Whether this is a (C++11) constexpr function or constexpr
            /// constructor.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Whether this is a (C++11) constexpr function or constexpr
            /// constructor.</para>
            /// </remarks>
            public bool usesSEHTry()
            {
                var __ret = Internal.usesSEHTry_0(__Instance);
                return __ret;
            }

            public void setUsesSEHTry(bool UST)
            {
                Internal.setUsesSEHTry_0(__Instance, UST);
            }

            /// <summary>
            /// <para>Whether this function has been deleted.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Whether this function has been deleted.</para>
            /// <para>  ///</para>
            /// <para>  /// A function that is &quot;deleted&quot; (via the C++0x
            /// &quot;= delete&quot; syntax)</para>
            /// <para>  /// acts like a normal function, except that it cannot actually
            /// be</para>
            /// <para>  /// called or have its address taken. Deleted functions
            /// are</para>
            /// <para>  /// typically used in C++ overload resolution to attract
            /// arguments</para>
            /// <para>  /// whose type or lvalue/rvalue-ness would permit the use of
            /// a</para>
            /// <para>  /// different overload that would behave incorrectly. For
            /// example,</para>
            /// <para>  /// one might use deleted functions to ban implicit conversion
            /// from</para>
            /// <para>  /// a floating-point number to an Integer type:</para>
            /// <para>  ///</para>
            /// <para>  /// @code</para>
            /// <para>  /// struct Integer {</para>
            /// <para>  ///   Integer(long); // construct from a long</para>
            /// <para>  ///   Integer(double) = delete; // no construction from float
            /// or double</para>
            /// <para>  ///   Integer(long double) = delete; // no construction from
            /// long double</para>
            /// <para>  /// };</para>
            /// <para>  /// @endcode</para>
            /// </remarks>
            public bool isDeleted()
            {
                var __ret = Internal.isDeleted_0(__Instance);
                return __ret;
            }

            public bool isDeletedAsWritten()
            {
                var __ret = Internal.isDeletedAsWritten_0(__Instance);
                return __ret;
            }

            public void setDeletedAsWritten(bool D)
            {
                Internal.setDeletedAsWritten_0(__Instance, D);
            }

            /// <summary>
            /// <para>Determines whether this function is &quot;main&quot;, which is
            /// the entry point into an executable program.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determines whether this function is &quot;main&quot;,
            /// which is the</para>
            /// <para>  /// entry point into an executable program.</para>
            /// </remarks>
            public bool isMain()
            {
                var __ret = Internal.isMain_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determines whether this function is a MSVCRT user defined entry
            /// point.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determines whether this function is a MSVCRT user
            /// defined entry</para>
            /// <para>  /// point.</para>
            /// </remarks>
            public bool isMSVCRTEntryPoint()
            {
                var __ret = Internal.isMSVCRTEntryPoint_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determines whether this operator new or delete is one of the
            /// reserved global placement operators: void *operator new(size_t, void *);
            /// void *operator new[](size_t, void *); void operator delete(void *, void *);
            /// void operator delete[](void *, void *); These functions have special
            /// behavior under [new.delete.placement]: These functions are reserved, a C++
            /// program may not define functions that displace the versions in the Standard
            /// C++ library. The provisions of [basic.stc.dynamic] do not apply to these
            /// reserved placement forms of operator new and operator delete.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determines whether this operator new or delete is
            /// one</para>
            /// <para>  /// of the reserved global placement operators:</para>
            /// <para>  ///    void *operator new(size_t, void *);</para>
            /// <para>  ///    void *operator new[](size_t, void *);</para>
            /// <para>  ///    void operator delete(void *, void *);</para>
            /// <para>  ///    void operator delete[](void *, void *);</para>
            /// <para>  /// These functions have special behavior under
            /// [new.delete.placement]:</para>
            /// <para>  ///    These functions are reserved, a C++ program may not
            /// define</para>
            /// <para>  ///    functions that displace the versions in the Standard C++
            /// library.</para>
            /// <para>  ///    The provisions of [basic.stc.dynamic] do not apply to
            /// these</para>
            /// <para>  ///    reserved placement forms of operator new and operator
            /// delete.</para>
            /// <para>  ///</para>
            /// <para>  /// This function must be an allocation or deallocation
            /// function.</para>
            /// </remarks>
            public bool isReservedGlobalPlacementOperator()
            {
                var __ret = Internal.isReservedGlobalPlacementOperator_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determines whether this function is one of the replaceable global
            /// allocation functions: void *operator new(size_t); void *operator
            /// new(size_t, const std::nothrow_t &amp;) noexcept; void *operator
            /// new[](size_t); void *operator new[](size_t, const std::nothrow_t &amp;)
            /// noexcept; void operator delete(void *) noexcept; void operator delete(void
            /// *, std::size_t) noexcept; [C++1y] void operator delete(void *, const
            /// std::nothrow_t &amp;) noexcept; void operator delete[](void *) noexcept;
            /// void operator delete[](void *, std::size_t) noexcept; [C++1y] void operator
            /// delete[](void *, const std::nothrow_t &amp;) noexcept; These functions have
            /// special behavior under C++1y [expr.new]: An implementation is allowed to
            /// omit a call to a replaceable global allocation function. [...]</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determines whether this function is one of the
            /// replaceable</para>
            /// <para>  /// global allocation functions:</para>
            /// <para>  ///    void *operator new(size_t);</para>
            /// <para>  ///    void *operator new(size_t, const std::nothrow_t &amp;)
            /// noexcept;</para>
            /// <para>  ///    void *operator new[](size_t);</para>
            /// <para>  ///    void *operator new[](size_t, const std::nothrow_t &amp;)
            /// noexcept;</para>
            /// <para>  ///    void operator delete(void *) noexcept;</para>
            /// <para>  ///    void operator delete(void *, std::size_t) noexcept;
            /// [C++1y]</para>
            /// <para>  ///    void operator delete(void *, const std::nothrow_t &amp;)
            /// noexcept;</para>
            /// <para>  ///    void operator delete[](void *) noexcept;</para>
            /// <para>  ///    void operator delete[](void *, std::size_t) noexcept;
            /// [C++1y]</para>
            /// <para>  ///    void operator delete[](void *, const std::nothrow_t
            /// &amp;) noexcept;</para>
            /// <para>  /// These functions have special behavior under C++1y
            /// [expr.new]:</para>
            /// <para>  ///    An implementation is allowed to omit a call to a
            /// replaceable global</para>
            /// <para>  ///    allocation function. [...]</para>
            /// </remarks>
            public bool isReplaceableGlobalAllocationFunction()
            {
                var __ret = Internal.isReplaceableGlobalAllocationFunction_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determine whether this function is a sized global deallocation
            /// function in C++1y. If so, find and return the corresponding unsized
            /// deallocation function.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine whether this function is a sized global
            /// deallocation</para>
            /// <para>  /// function in C++1y. If so, find and return the corresponding
            /// unsized</para>
            /// <para>  /// deallocation function.</para>
            /// </remarks>
            public clang.FunctionDecl getCorrespondingUnsizedGlobalDeallocationFunction()
            {
                var __ret = Internal.getCorrespondingUnsizedGlobalDeallocationFunction_0(__Instance);
                clang.FunctionDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.FunctionDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.FunctionDecl) clang.FunctionDecl.NativeToManagedMap[__ret];
                else clang.FunctionDecl.NativeToManagedMap[__ret] = __result0 = (clang.FunctionDecl) clang.FunctionDecl.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Compute the language linkage.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Compute the language linkage.</para>
            /// </remarks>
            public clang.LanguageLinkage getLanguageLinkage()
            {
                var __ret = Internal.getLanguageLinkage_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determines whether this function is a function with external, C
            /// linkage.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determines whether this function is a function
            /// with</para>
            /// <para>  /// external, C linkage.</para>
            /// </remarks>
            public bool isExternC()
            {
                var __ret = Internal.isExternC_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determines whether this function's context is, or is nested
            /// within, a C++ extern &quot;C&quot; linkage spec.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determines whether this function's context is, or is
            /// nested within,</para>
            /// <para>  /// a C++ extern &quot;C&quot; linkage spec.</para>
            /// </remarks>
            public bool isInExternCContext()
            {
                var __ret = Internal.isInExternCContext_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determines whether this function's context is, or is nested
            /// within, a C++ extern &quot;C++&quot; linkage spec.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determines whether this function's context is, or is
            /// nested within,</para>
            /// <para>  /// a C++ extern &quot;C++&quot; linkage spec.</para>
            /// </remarks>
            public bool isInExternCXXContext()
            {
                var __ret = Internal.isInExternCXXContext_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determines whether this is a global function.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determines whether this is a global function.</para>
            /// </remarks>
            public bool isGlobal()
            {
                var __ret = Internal.isGlobal_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determines whether this function is known to be 'noreturn',
            /// through an attribute on its declaration or its type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determines whether this function is known to be
            /// 'noreturn', through</para>
            /// <para>  /// an attribute on its declaration or its type.</para>
            /// </remarks>
            public bool isNoReturn()
            {
                var __ret = Internal.isNoReturn_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>True if the function was a definition but its body was
            /// skipped.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief True if the function was a definition but its body was
            /// skipped.</para>
            /// </remarks>
            public bool hasSkippedBody()
            {
                var __ret = Internal.hasSkippedBody_0(__Instance);
                return __ret;
            }

            public void setHasSkippedBody(bool Skipped)
            {
                Internal.setHasSkippedBody_0(__Instance, Skipped);
            }

            public void setPreviousDeclaration(clang.FunctionDecl PrevDecl)
            {
                var arg0 = ReferenceEquals(PrevDecl, null) ? global::System.IntPtr.Zero : PrevDecl.__Instance;
                Internal.setPreviousDeclaration_0(__Instance, arg0);
            }

            public virtual clang.FunctionDecl getCanonicalDecl()
            {
                var __ret = Internal.getCanonicalDecl_1(__Instance);
                clang.FunctionDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.FunctionDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.FunctionDecl) clang.FunctionDecl.NativeToManagedMap[__ret];
                else clang.FunctionDecl.NativeToManagedMap[__ret] = __result0 = (clang.FunctionDecl) clang.FunctionDecl.__CreateInstance(__ret);
                return __result0;
            }

            public uint getBuiltinID()
            {
                var __ret = Internal.getBuiltinID_0(__Instance);
                return __ret;
            }

            public uint param_size()
            {
                var __ret = Internal.param_size_0(__Instance);
                return __ret;
            }

            public clang.ParmVarDecl param_begin()
            {
                var __ret = Internal.param_begin_0(__Instance);
                clang.ParmVarDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.ParmVarDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.ParmVarDecl) clang.ParmVarDecl.NativeToManagedMap[__ret];
                else clang.ParmVarDecl.NativeToManagedMap[__ret] = __result0 = (clang.ParmVarDecl) clang.ParmVarDecl.__CreateInstance(__ret);
                return __result0;
            }

            public clang.ParmVarDecl param_end()
            {
                var __ret = Internal.param_end_0(__Instance);
                clang.ParmVarDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.ParmVarDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.ParmVarDecl) clang.ParmVarDecl.NativeToManagedMap[__ret];
                else clang.ParmVarDecl.NativeToManagedMap[__ret] = __result0 = (clang.ParmVarDecl) clang.ParmVarDecl.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>getNumParams - Return the number of parameters this function must
            /// have based on its FunctionType. This is the length of the ParamInfo array
            /// after it has been created.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getNumParams - Return the number of parameters this function
            /// must have</para>
            /// <para>  /// based on its FunctionType.  This is the length of the
            /// ParamInfo array</para>
            /// <para>  /// after it has been created.</para>
            /// </remarks>
            public uint getNumParams()
            {
                var __ret = Internal.getNumParams_0(__Instance);
                return __ret;
            }

            public clang.ParmVarDecl getParamDecl(uint i)
            {
                var __ret = Internal.getParamDecl_1(__Instance, i);
                clang.ParmVarDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.ParmVarDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.ParmVarDecl) clang.ParmVarDecl.NativeToManagedMap[__ret];
                else clang.ParmVarDecl.NativeToManagedMap[__ret] = __result0 = (clang.ParmVarDecl) clang.ParmVarDecl.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>getMinRequiredArguments - Returns the minimum number of arguments
            /// needed to call this function. This may be fewer than the number of function
            /// parameters, if some of the parameters have default arguments (in
            /// C++).</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getMinRequiredArguments - Returns the minimum number of
            /// arguments</para>
            /// <para>  /// needed to call this function. This may be fewer than the
            /// number of</para>
            /// <para>  /// function parameters, if some of the parameters have
            /// default</para>
            /// <para>  /// arguments (in C++).</para>
            /// </remarks>
            public uint getMinRequiredArguments()
            {
                var __ret = Internal.getMinRequiredArguments_0(__Instance);
                return __ret;
            }

            public clang.QualType getReturnType()
            {
                var __ret = Internal.getReturnType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Attempt to compute an informative source range covering the
            /// function return type. This may omit qualifiers and other information with
            /// limited representation in the AST.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Attempt to compute an informative source range
            /// covering the</para>
            /// <para>  /// function return type. This may omit qualifiers and other
            /// information with</para>
            /// <para>  /// limited representation in the AST.</para>
            /// </remarks>
            public clang.SourceRange getReturnTypeSourceRange()
            {
                var __ret = Internal.getReturnTypeSourceRange_0(__Instance);
                return clang.SourceRange.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Determine the type of an expression that calls this
            /// function.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine the type of an expression that calls this
            /// function.</para>
            /// </remarks>
            public clang.QualType getCallResultType()
            {
                var __ret = Internal.getCallResultType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Returns the storage class as written in the source. For the
            /// computed linkage of symbol, see getLinkage.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Returns the storage class as written in the source.
            /// For the</para>
            /// <para>  /// computed linkage of symbol, see getLinkage.</para>
            /// </remarks>
            public clang.StorageClass getStorageClass()
            {
                var __ret = Internal.getStorageClass_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determine whether the &quot;inline&quot; keyword was specified
            /// for this function.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine whether the &quot;inline&quot; keyword was
            /// specified for this</para>
            /// <para>  /// function.</para>
            /// </remarks>
            public bool isInlineSpecified()
            {
                var __ret = Internal.isInlineSpecified_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Set whether the &quot;inline&quot; keyword was specified for this
            /// function.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Set whether the &quot;inline&quot; keyword was specified for
            /// this function.</para>
            /// </remarks>
            public void setInlineSpecified(bool I)
            {
                Internal.setInlineSpecified_0(__Instance, I);
            }

            /// <summary>
            /// <para>Flag that this function is implicitly inline.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Flag that this function is implicitly inline.</para>
            /// </remarks>
            public void setImplicitlyInline()
            {
                Internal.setImplicitlyInline_0(__Instance);
            }

            /// <summary>
            /// <para>Determine whether this function should be inlined, because it is
            /// either marked &quot;inline&quot; or &quot;constexpr&quot; or is a member
            /// function of a class that was defined in the class body.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine whether this function should be inlined,
            /// because it is</para>
            /// <para>  /// either marked &quot;inline&quot; or &quot;constexpr&quot;
            /// or is a member function of a class</para>
            /// <para>  /// that was defined in the class body.</para>
            /// </remarks>
            public bool isInlined()
            {
                var __ret = Internal.isInlined_0(__Instance);
                return __ret;
            }

            public bool isInlineDefinitionExternallyVisible()
            {
                var __ret = Internal.isInlineDefinitionExternallyVisible_0(__Instance);
                return __ret;
            }

            public bool isMSExternInline()
            {
                var __ret = Internal.isMSExternInline_0(__Instance);
                return __ret;
            }

            public bool doesDeclarationForceExternallyVisibleDefinition()
            {
                var __ret = Internal.doesDeclarationForceExternallyVisibleDefinition_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>isOverloadedOperator - Whether this function declaration
            /// represents an C++ overloaded operator, e.g., &quot;operator+&quot;.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// isOverloadedOperator - Whether this function
            /// declaration</para>
            /// <para>  /// represents an C++ overloaded operator, e.g.,
            /// &quot;operator+&quot;.</para>
            /// </remarks>
            public bool isOverloadedOperator()
            {
                var __ret = Internal.isOverloadedOperator_0(__Instance);
                return __ret;
            }

            public clang.OverloadedOperatorKind getOverloadedOperator()
            {
                var __ret = Internal.getOverloadedOperator_0(__Instance);
                return __ret;
            }

            public clang.IdentifierInfo getLiteralIdentifier()
            {
                var __ret = Internal.getLiteralIdentifier_0(__Instance);
                clang.IdentifierInfo __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.IdentifierInfo.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.IdentifierInfo) clang.IdentifierInfo.NativeToManagedMap[__ret];
                else __result0 = clang.IdentifierInfo.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>If this function is an instantiation of a member function of a
            /// class template specialization, retrieves the function from which it was
            /// instantiated.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief If this function is an instantiation of a member
            /// function</para>
            /// <para>  /// of a class template specialization, retrieves the function
            /// from</para>
            /// <para>  /// which it was instantiated.</para>
            /// <para>  ///</para>
            /// <para>  /// This routine will return non-NULL for (non-templated)
            /// member</para>
            /// <para>  /// functions of class templates and for instantiations of
            /// function</para>
            /// <para>  /// templates. For example, given:</para>
            /// <para>  ///</para>
            /// <para>  /// \code</para>
            /// <para>  /// template&lt;typename T&gt;</para>
            /// <para>  /// struct X {</para>
            /// <para>  ///   void f(T);</para>
            /// <para>  /// };</para>
            /// <para>  /// \endcode</para>
            /// <para>  ///</para>
            /// <para>  /// The declaration for X&lt;int&gt;::f is a (non-templated)
            /// FunctionDecl</para>
            /// <para>  /// whose parent is the class template specialization
            /// X&lt;int&gt;. For</para>
            /// <para>  /// this declaration, getInstantiatedFromFunction() will
            /// return</para>
            /// <para>  /// the FunctionDecl X&lt;T&gt;::A. When a complete definition
            /// of</para>
            /// <para>  /// X&lt;int&gt;::A is required, it will be instantiated from
            /// the</para>
            /// <para>  /// declaration returned by
            /// getInstantiatedFromMemberFunction().</para>
            /// </remarks>
            public clang.FunctionDecl getInstantiatedFromMemberFunction()
            {
                var __ret = Internal.getInstantiatedFromMemberFunction_0(__Instance);
                clang.FunctionDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.FunctionDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.FunctionDecl) clang.FunctionDecl.NativeToManagedMap[__ret];
                else clang.FunctionDecl.NativeToManagedMap[__ret] = __result0 = (clang.FunctionDecl) clang.FunctionDecl.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>What kind of templated function this is.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief What kind of templated function this is.</para>
            /// </remarks>
            public clang.FunctionDecl.TemplatedKind getTemplatedKind()
            {
                var __ret = Internal.getTemplatedKind_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Specify that this record is an instantiation of the member
            /// function FD.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Specify that this record is an instantiation of
            /// the</para>
            /// <para>  /// member function FD.</para>
            /// </remarks>
            public void setInstantiationOfMemberFunction(clang.FunctionDecl FD, clang.TemplateSpecializationKind TSK)
            {
                var arg0 = ReferenceEquals(FD, null) ? global::System.IntPtr.Zero : FD.__Instance;
                var arg1 = TSK;
                Internal.setInstantiationOfMemberFunction_1(__Instance, arg0, arg1);
            }

            /// <summary>
            /// <para>Determine whether this function is a function template
            /// specialization.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine whether this function is a function
            /// template</para>
            /// <para>  /// specialization.</para>
            /// </remarks>
            public bool isFunctionTemplateSpecialization()
            {
                var __ret = Internal.isFunctionTemplateSpecialization_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Retrieve the class scope template pattern that this function
            /// template specialization is instantiated from.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the class scope template pattern that this
            /// function</para>
            /// <para>  ///  template specialization is instantiated from.</para>
            /// </remarks>
            public clang.FunctionDecl getClassScopeSpecializationPattern()
            {
                var __ret = Internal.getClassScopeSpecializationPattern_0(__Instance);
                clang.FunctionDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.FunctionDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.FunctionDecl) clang.FunctionDecl.NativeToManagedMap[__ret];
                else clang.FunctionDecl.NativeToManagedMap[__ret] = __result0 = (clang.FunctionDecl) clang.FunctionDecl.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Determines whether this function is a function template
            /// specialization or a member of a class template specialization that can be
            /// implicitly instantiated.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determines whether this function is a function
            /// template</para>
            /// <para>  /// specialization or a member of a class template
            /// specialization that can</para>
            /// <para>  /// be implicitly instantiated.</para>
            /// </remarks>
            public bool isImplicitlyInstantiable()
            {
                var __ret = Internal.isImplicitlyInstantiable_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determines if the given function was instantiated from a function
            /// template.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determines if the given function was instantiated from
            /// a</para>
            /// <para>  /// function template.</para>
            /// </remarks>
            public bool isTemplateInstantiation()
            {
                var __ret = Internal.isTemplateInstantiation_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Retrieve the function declaration from which this function could
            /// be instantiated, if it is an instantiation (rather than a non-template or a
            /// specialization, for example).</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the function declaration from which this
            /// function could</para>
            /// <para>  /// be instantiated, if it is an instantiation (rather than a
            /// non-template</para>
            /// <para>  /// or a specialization, for example).</para>
            /// </remarks>
            public clang.FunctionDecl getTemplateInstantiationPattern()
            {
                var __ret = Internal.getTemplateInstantiationPattern_0(__Instance);
                clang.FunctionDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.FunctionDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.FunctionDecl) clang.FunctionDecl.NativeToManagedMap[__ret];
                else clang.FunctionDecl.NativeToManagedMap[__ret] = __result0 = (clang.FunctionDecl) clang.FunctionDecl.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Retrieve the template argument list as written in the sources, if
            /// any.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the template argument list as written in the
            /// sources,</para>
            /// <para>  /// if any.</para>
            /// <para>  ///</para>
            /// <para>  /// If this function declaration is not a function template
            /// specialization</para>
            /// <para>  /// or if it had no explicit template argument list, returns
            /// NULL.</para>
            /// <para>  /// Note that it an explicit template argument list may be
            /// written empty,</para>
            /// <para>  /// e.g., template&lt;&gt; void foo&lt;&gt;(char* s);</para>
            /// </remarks>
            public clang.ASTTemplateArgumentListInfo getTemplateSpecializationArgsAsWritten()
            {
                var __ret = Internal.getTemplateSpecializationArgsAsWritten_0(__Instance);
                clang.ASTTemplateArgumentListInfo __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.ASTTemplateArgumentListInfo.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.ASTTemplateArgumentListInfo) clang.ASTTemplateArgumentListInfo.NativeToManagedMap[__ret];
                else __result0 = clang.ASTTemplateArgumentListInfo.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Determine what kind of template instantiation this function
            /// represents.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine what kind of template instantiation this
            /// function</para>
            /// <para>  /// represents.</para>
            /// </remarks>
            public clang.TemplateSpecializationKind getTemplateSpecializationKind()
            {
                var __ret = Internal.getTemplateSpecializationKind_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determine what kind of template instantiation this function
            /// represents.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine what kind of template instantiation this
            /// function</para>
            /// <para>  /// represents.</para>
            /// </remarks>
            public void setTemplateSpecializationKind(clang.TemplateSpecializationKind TSK, clang.SourceLocation PointOfInstantiation)
            {
                var arg0 = TSK;
                var arg1 = ReferenceEquals(PointOfInstantiation, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (PointOfInstantiation.__Instance);
                Internal.setTemplateSpecializationKind_0(__Instance, arg0, arg1);
            }

            /// <summary>
            /// <para>Retrieve the (first) point of instantiation of a function
            /// template specialization or a member of a class template
            /// specialization.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the (first) point of instantiation of a
            /// function template</para>
            /// <para>  /// specialization or a member of a class template
            /// specialization.</para>
            /// <para>  ///</para>
            /// <para>  /// \returns the first point of instantiation, if this function
            /// was</para>
            /// <para>  /// instantiated from a template; otherwise, returns an invalid
            /// source</para>
            /// <para>  /// location.</para>
            /// </remarks>
            public clang.SourceLocation getPointOfInstantiation()
            {
                var __ret = Internal.getPointOfInstantiation_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Determine whether this is or was instantiated from an out-of-line
            /// definition of a member function.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine whether this is or was instantiated from an
            /// out-of-line</para>
            /// <para>  /// definition of a member function.</para>
            /// </remarks>
            public override bool isOutOfLine()
            {
                var __ret = Internal.isOutOfLine_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Identify a memory copying or setting function. If the given
            /// function is a memory copy or setting function, returns the corresponding
            /// Builtin ID. If the function is not a memory function, returns 0.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Identify a memory copying or setting function.</para>
            /// <para>  /// If the given function is a memory copy or setting function,
            /// returns</para>
            /// <para>  /// the corresponding Builtin ID. If the function is not a
            /// memory function,</para>
            /// <para>  /// returns 0.</para>
            /// </remarks>
            public uint getMemoryFunctionKind()
            {
                var __ret = Internal.getMemoryFunctionKind_0(__Instance);
                return __ret;
            }

            public static clang.FunctionDecl Create(clang.ASTContext C, clang.DeclContext DC, clang.SourceLocation StartLoc, clang.SourceLocation NLoc, clang.DeclarationName N, clang.QualType T, clang.TypeSourceInfo TInfo, clang.StorageClass SC, bool isInlineSpecified, bool hasWrittenPrototype, bool isConstexprSpecified)
            {
                var arg0 = ReferenceEquals(C, null) ? global::System.IntPtr.Zero : C.__Instance;
                var arg1 = ReferenceEquals(DC, null) ? global::System.IntPtr.Zero : DC.__Instance;
                var arg2 = ReferenceEquals(StartLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (StartLoc.__Instance);
                var arg3 = ReferenceEquals(NLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (NLoc.__Instance);
                var arg4 = ReferenceEquals(N, null) ? new clang.DeclarationName.Internal() : *(clang.DeclarationName.Internal*) (N.__Instance);
                var arg5 = ReferenceEquals(T, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (T.__Instance);
                var arg6 = ReferenceEquals(TInfo, null) ? global::System.IntPtr.Zero : TInfo.__Instance;
                var arg7 = SC;
                var __ret = Internal.Create_0(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, isInlineSpecified, hasWrittenPrototype, isConstexprSpecified);
                clang.FunctionDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.FunctionDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.FunctionDecl) clang.FunctionDecl.NativeToManagedMap[__ret];
                else clang.FunctionDecl.NativeToManagedMap[__ret] = __result0 = (clang.FunctionDecl) clang.FunctionDecl.__CreateInstance(__ret);
                return __result0;
            }

            public static clang.FunctionDecl Create(clang.ASTContext C, clang.DeclContext DC, clang.SourceLocation StartLoc, clang.DeclarationNameInfo NameInfo, clang.QualType T, clang.TypeSourceInfo TInfo, clang.StorageClass SC, bool isInlineSpecified, bool hasWrittenPrototype, bool isConstexprSpecified)
            {
                var arg0 = ReferenceEquals(C, null) ? global::System.IntPtr.Zero : C.__Instance;
                var arg1 = ReferenceEquals(DC, null) ? global::System.IntPtr.Zero : DC.__Instance;
                var arg2 = ReferenceEquals(StartLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (StartLoc.__Instance);
                var arg3 = ReferenceEquals(NameInfo, null) ? global::System.IntPtr.Zero : NameInfo.__Instance;
                var arg4 = ReferenceEquals(T, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (T.__Instance);
                var arg5 = ReferenceEquals(TInfo, null) ? global::System.IntPtr.Zero : TInfo.__Instance;
                var arg6 = SC;
                var __ret = Internal.Create_1(arg0, arg1, arg2, arg3, arg4, arg5, arg6, isInlineSpecified, hasWrittenPrototype, isConstexprSpecified);
                clang.FunctionDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.FunctionDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.FunctionDecl) clang.FunctionDecl.NativeToManagedMap[__ret];
                else clang.FunctionDecl.NativeToManagedMap[__ret] = __result0 = (clang.FunctionDecl) clang.FunctionDecl.__CreateInstance(__ret);
                return __result0;
            }

            public static clang.FunctionDecl CreateDeserialized(clang.ASTContext C, uint ID)
            {
                var arg0 = ReferenceEquals(C, null) ? global::System.IntPtr.Zero : C.__Instance;
                var __ret = Internal.CreateDeserialized_0(arg0, ID);
                clang.FunctionDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.FunctionDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.FunctionDecl) clang.FunctionDecl.NativeToManagedMap[__ret];
                else clang.FunctionDecl.NativeToManagedMap[__ret] = __result0 = (clang.FunctionDecl) clang.FunctionDecl.__CreateInstance(__ret);
                return __result0;
            }

            public static bool classof(clang.Decl D)
            {
                var arg0 = ReferenceEquals(D, null) ? global::System.IntPtr.Zero : D.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }

            public static bool classofKind(clang.Decl.Kind K)
            {
                var arg0 = K;
                var __ret = Internal.classofKind_0(arg0);
                return __ret;
            }

            public static clang.DeclContext castToDeclContext(clang.FunctionDecl D)
            {
                var arg0 = ReferenceEquals(D, null) ? global::System.IntPtr.Zero : D.__Instance;
                var __ret = Internal.castToDeclContext_0(arg0);
                clang.DeclContext __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.DeclContext.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.DeclContext) clang.DeclContext.NativeToManagedMap[__ret];
                else __result0 = clang.DeclContext.__CreateInstance(__ret);
                return __result0;
            }

            public static clang.FunctionDecl castFromDeclContext(clang.DeclContext DC)
            {
                var arg0 = ReferenceEquals(DC, null) ? global::System.IntPtr.Zero : DC.__Instance;
                var __ret = Internal.castFromDeclContext_0(arg0);
                clang.FunctionDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.FunctionDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.FunctionDecl) clang.FunctionDecl.NativeToManagedMap[__ret];
                else clang.FunctionDecl.NativeToManagedMap[__ret] = __result0 = (clang.FunctionDecl) clang.FunctionDecl.__CreateInstance(__ret);
                return __result0;
            }

            #region Virtual table interop

            // FunctionDecl
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
            private static _dtor_0Delegate _dtor_0DelegateInstance;

            private static void _dtor_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (FunctionDecl) _References[instance].Target;
                __target.DestroyNativeInstance();
            }

            // SourceRange getSourceRange() const override
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate clang.SourceRange.Internal _getSourceRange_0Delegate(global::System.IntPtr instance);
            private static _getSourceRange_0Delegate _getSourceRange_0DelegateInstance;

            private static clang.SourceRange.Internal _getSourceRange_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (FunctionDecl) _References[instance].Target;
                var __ret = __target.getSourceRange();
                return ReferenceEquals(__ret, null) ? new clang.SourceRange.Internal() : *(clang.SourceRange.Internal*) (__ret.__Instance);
            }

            // bool isOutOfLine() const override
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate bool _isOutOfLine_0Delegate(global::System.IntPtr instance);
            private static _isOutOfLine_0Delegate _isOutOfLine_0DelegateInstance;

            private static bool _isOutOfLine_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (FunctionDecl) _References[instance].Target;
                var __ret = __target.isOutOfLine();
                return __ret;
            }

            // FunctionDecl *getCanonicalDecl() override
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getCanonicalDecl_1Delegate(global::System.IntPtr instance);
            private static _getCanonicalDecl_1Delegate _getCanonicalDecl_1DelegateInstance;

            private static global::System.IntPtr _getCanonicalDecl_1DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (FunctionDecl) _References[instance].Target;
                var __ret = __target.getCanonicalDecl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // FunctionDecl *getNextRedeclarationImpl() override
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getNextRedeclarationImpl_0Delegate(global::System.IntPtr instance);
            private static _getNextRedeclarationImpl_0Delegate _getNextRedeclarationImpl_0DelegateInstance;

            private static global::System.IntPtr _getNextRedeclarationImpl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (FunctionDecl) _References[instance].Target;
                var __ret = __target.getNextRedeclarationImpl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // FunctionDecl *getPreviousDeclImpl() override
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getPreviousDeclImpl_0Delegate(global::System.IntPtr instance);
            private static _getPreviousDeclImpl_0Delegate _getPreviousDeclImpl_0DelegateInstance;

            private static global::System.IntPtr _getPreviousDeclImpl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (FunctionDecl) _References[instance].Target;
                var __ret = __target.getPreviousDeclImpl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // FunctionDecl *getMostRecentDeclImpl() override
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getMostRecentDeclImpl_0Delegate(global::System.IntPtr instance);
            private static _getMostRecentDeclImpl_0Delegate _getMostRecentDeclImpl_0DelegateInstance;

            private static global::System.IntPtr _getMostRecentDeclImpl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (FunctionDecl) _References[instance].Target;
                var __ret = __target.getMostRecentDeclImpl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // Stmt *getBody() const override
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getBody_1Delegate(global::System.IntPtr instance);
            private static _getBody_1Delegate _getBody_1DelegateInstance;

            private static global::System.IntPtr _getBody_1DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (FunctionDecl) _References[instance].Target;
                var __ret = __target.getBody();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // bool hasBody() const override
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate bool _hasBody_1Delegate(global::System.IntPtr instance);
            private static _hasBody_1Delegate _hasBody_1DelegateInstance;

            private static bool _hasBody_1DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (FunctionDecl) _References[instance].Target;
                var __ret = __target.hasBody();
                return __ret;
            }

            // void getNameForDiagnostic(raw_ostream &OS, const PrintingPolicy &Policy, bool Qualified) const override
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate void _getNameForDiagnostic_0Delegate(global::System.IntPtr instance, global::System.IntPtr OS, global::System.IntPtr Policy, bool Qualified);
            private static _getNameForDiagnostic_0Delegate _getNameForDiagnostic_0DelegateInstance;

            private static void _getNameForDiagnostic_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr OS, global::System.IntPtr Policy, bool Qualified)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (FunctionDecl) _References[instance].Target;
                llvm.raw_ostream __result0;
                if (OS == IntPtr.Zero) __result0 = null;
                else if (llvm.raw_ostream.NativeToManagedMap.ContainsKey(OS))
                    __result0 = (llvm.raw_ostream) llvm.raw_ostream.NativeToManagedMap[OS];
                else llvm.raw_ostream.NativeToManagedMap[OS] = __result0 = (llvm.raw_ostream) llvm.raw_ostream.__CreateInstance(OS);
                clang.PrintingPolicy __result1;
                if (Policy == IntPtr.Zero) __result1 = null;
                else if (clang.PrintingPolicy.NativeToManagedMap.ContainsKey(Policy))
                    __result1 = (clang.PrintingPolicy) clang.PrintingPolicy.NativeToManagedMap[Policy];
                else __result1 = clang.PrintingPolicy.__CreateInstance(Policy);
                __target.getNameForDiagnostic(__result0, __result1, Qualified);
            }

            // bool isDefined() const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate bool _isDefined_1Delegate(global::System.IntPtr instance);
            private static _isDefined_1Delegate _isDefined_1DelegateInstance;

            private static bool _isDefined_1DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (FunctionDecl) _References[instance].Target;
                var __ret = __target.isDefined();
                return __ret;
            }

            private static void*[] _OldVTables;
            private static void*[] _NewVTables;
            private static void*[] _Thunks;
            private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

            void SetupVTables(global::System.IntPtr instance)
            {
                var native = (Internal*)instance.ToPointer();

                if (_References == null)
                    _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

                if (_References.ContainsKey(instance))
                    return;

                _References[instance] = new WeakReference(this);

                if (_OldVTables == null)
                {
                    _OldVTables = new void*[1];
                    _OldVTables[0] = native->vfptr0.ToPointer();
                }

                if (_Thunks == null)
                {
                    _Thunks = new void*[11];
                    _dtor_0DelegateInstance += _dtor_0DelegateHook;
                    _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                    _getSourceRange_0DelegateInstance += _getSourceRange_0DelegateHook;
                    _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_getSourceRange_0DelegateInstance).ToPointer();
                    _isOutOfLine_0DelegateInstance += _isOutOfLine_0DelegateHook;
                    _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_isOutOfLine_0DelegateInstance).ToPointer();
                    _getCanonicalDecl_1DelegateInstance += _getCanonicalDecl_1DelegateHook;
                    _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_getCanonicalDecl_1DelegateInstance).ToPointer();
                    _getNextRedeclarationImpl_0DelegateInstance += _getNextRedeclarationImpl_0DelegateHook;
                    _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_getNextRedeclarationImpl_0DelegateInstance).ToPointer();
                    _getPreviousDeclImpl_0DelegateInstance += _getPreviousDeclImpl_0DelegateHook;
                    _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_getPreviousDeclImpl_0DelegateInstance).ToPointer();
                    _getMostRecentDeclImpl_0DelegateInstance += _getMostRecentDeclImpl_0DelegateHook;
                    _Thunks[6] = Marshal.GetFunctionPointerForDelegate(_getMostRecentDeclImpl_0DelegateInstance).ToPointer();
                    _getBody_1DelegateInstance += _getBody_1DelegateHook;
                    _Thunks[7] = Marshal.GetFunctionPointerForDelegate(_getBody_1DelegateInstance).ToPointer();
                    _hasBody_1DelegateInstance += _hasBody_1DelegateHook;
                    _Thunks[8] = Marshal.GetFunctionPointerForDelegate(_hasBody_1DelegateInstance).ToPointer();
                    _getNameForDiagnostic_0DelegateInstance += _getNameForDiagnostic_0DelegateHook;
                    _Thunks[9] = Marshal.GetFunctionPointerForDelegate(_getNameForDiagnostic_0DelegateInstance).ToPointer();
                    _isDefined_1DelegateInstance += _isDefined_1DelegateHook;
                    _Thunks[10] = Marshal.GetFunctionPointerForDelegate(_isDefined_1DelegateInstance).ToPointer();
                }

                if (_NewVTables == null)
                {
                    _NewVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(13 * 8);
                    _NewVTables[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + 8) = _Thunks[0];
                    *(void**)(vfptr0 + 16) = _Thunks[1];
                    *(void**)(vfptr0 + 24) = _Thunks[2];
                    *(void**)(vfptr0 + 32) = _Thunks[3];
                    *(void**)(vfptr0 + 40) = _Thunks[4];
                    *(void**)(vfptr0 + 48) = _Thunks[5];
                    *(void**)(vfptr0 + 56) = _Thunks[6];
                    *(void**)(vfptr0 + 64) = _Thunks[7];
                    *(void**)(vfptr0 + 72) = _Thunks[8];
                    *(void**)(vfptr0 + 80) = *(void**)(native->vfptr0 + 80);
                    *(void**)(vfptr0 + 88) = _Thunks[9];
                    *(void**)(vfptr0 + 96) = _Thunks[10];
                    *(void**)(vfptr0 + 104) = *(void**)(native->vfptr0 + 104);
                }

                native->vfptr0 = new IntPtr(_NewVTables[0]);
            }

            #endregion
        }

        /// <summary>
        /// <para>FieldDecl - An instance of this class is created by
        /// Sema::ActOnField to represent a member of a struct/union/class.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// FieldDecl - An instance of this class is created by
        /// Sema::ActOnField to</para>
        /// <para>/// represent a member of a struct/union/class.</para>
        /// </remarks>
        public unsafe partial class FieldDecl : clang.DeclaratorDecl, clang.Mergeable, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 72)]
            public new partial struct Internal
            {
                [FieldOffset(8)]
                internal llvm.PointerIntPair.Internal NextInContextAndBits;

                [FieldOffset(16)]
                internal llvm.PointerUnion.Internal DeclCtx;

                [FieldOffset(24)]
                public clang.SourceLocation.Internal Loc;

                [FieldOffset(28)]
                public uint DeclKind;

                [FieldOffset(29)]
                public uint InvalidDecl;

                [FieldOffset(29)]
                public uint HasAttrs;

                [FieldOffset(29)]
                public uint Implicit;

                [FieldOffset(29)]
                public uint Used;

                [FieldOffset(29)]
                public uint Referenced;

                [FieldOffset(29)]
                public uint Access;

                [FieldOffset(29)]
                public uint FromASTFile;

                [FieldOffset(30)]
                public uint Hidden;

                [FieldOffset(30)]
                public uint IdentifierNamespace;

                [FieldOffset(31)]
                public uint CacheValidAndLinkage;

                [FieldOffset(32)]
                public clang.DeclarationName.Internal Name;

                [FieldOffset(40)]
                public clang.QualType.Internal DeclType;

                [FieldOffset(48)]
                internal llvm.PointerUnion.Internal DeclInfo;

                [FieldOffset(56)]
                public clang.SourceLocation.Internal InnerLocStart;

                [FieldOffset(60)]
                public bool Mutable;

                [FieldOffset(60)]
                public uint CachedFieldIndex;

                [FieldOffset(64)]
                internal llvm.PointerIntPair.Internal InitStorage;

                [FieldOffset(0)]
                public global::System.IntPtr vfptr0;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9FieldDeclC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9FieldDeclD2Ev")]
                internal static extern void dtor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9FieldDecl18CreateDeserializedERNS_10ASTContextEj")]
                internal static extern global::System.IntPtr CreateDeserialized_0(global::System.IntPtr C, uint ID);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9FieldDecl13getFieldIndexEv")]
                internal static extern uint getFieldIndex_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9FieldDecl9isMutableEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isMutable_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9FieldDecl10isBitFieldEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isBitField_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9FieldDecl17isUnnamedBitfieldEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isUnnamedBitfield_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9FieldDecl24isAnonymousStructOrUnionEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isAnonymousStructOrUnion_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9FieldDecl16getBitWidthValueERKNS_10ASTContextE")]
                internal static extern uint getBitWidthValue_0(global::System.IntPtr instance, global::System.IntPtr Ctx);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9FieldDecl14removeBitWidthEv")]
                internal static extern void removeBitWidth_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9FieldDecl19getInClassInitStyleEv")]
                internal static extern clang.InClassInitStyle getInClassInitStyle_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9FieldDecl21hasInClassInitializerEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasInClassInitializer_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9FieldDecl24removeInClassInitializerEv")]
                internal static extern void removeInClassInitializer_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9FieldDecl18hasCapturedVLATypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasCapturedVLAType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9FieldDecl18getCapturedVLATypeEv")]
                internal static extern global::System.IntPtr getCapturedVLAType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9FieldDecl18setCapturedVLATypeEPKNS_17VariableArrayTypeE")]
                internal static extern void setCapturedVLAType_0(global::System.IntPtr instance, global::System.IntPtr VLAType);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9FieldDecl9getParentEv")]
                internal static extern global::System.IntPtr getParent_1(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9FieldDecl14getSourceRangeEv")]
                internal static extern clang.SourceRange.Internal getSourceRange_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9FieldDecl16getCanonicalDeclEv")]
                internal static extern global::System.IntPtr getCanonicalDecl_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9FieldDecl7classofEPKNS_4DeclE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr D);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9FieldDecl11classofKindENS_4Decl4KindE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classofKind_0(clang.Decl.Kind K);
            }

            private readonly bool __ownsNativeInstance;

            public static new FieldDecl __CreateInstance(global::System.IntPtr native)
            {
                return new FieldDecl((FieldDecl.Internal*) native);
            }

            public static FieldDecl __CreateInstance(FieldDecl.Internal native)
            {
                return new FieldDecl(native);
            }

            private static FieldDecl.Internal* __CopyValue(FieldDecl.Internal native)
            {
                var ret = (FieldDecl.Internal*) Marshal.AllocHGlobal(72);
                *ret = native;
                return ret;
            }

            private FieldDecl(FieldDecl.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected FieldDecl(FieldDecl.Internal* native, bool isInternalImpl = false)
                : base((clang.DeclaratorDecl.Internal*) native)
            {
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Decl __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            /// <summary>
            /// <para>getFieldIndex - Returns the index of this field within its
            /// record, as appropriate for passing to
            /// ASTRecordLayout::getFieldOffset.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getFieldIndex - Returns the index of this field within its
            /// record,</para>
            /// <para>  /// as appropriate for passing to
            /// ASTRecordLayout::getFieldOffset.</para>
            /// </remarks>
            public uint getFieldIndex()
            {
                var __ret = Internal.getFieldIndex_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>isMutable - Determines whether this field is mutable (C++
            /// only).</para>
            /// </summary>
            /// <remarks>
            /// <para>/// isMutable - Determines whether this field is mutable (C++
            /// only).</para>
            /// </remarks>
            public bool isMutable()
            {
                var __ret = Internal.isMutable_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determines whether this field is a bitfield.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determines whether this field is a bitfield.</para>
            /// </remarks>
            public bool isBitField()
            {
                var __ret = Internal.isBitField_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determines whether this is an unnamed bitfield.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// @brief Determines whether this is an unnamed bitfield.</para>
            /// </remarks>
            public bool isUnnamedBitfield()
            {
                var __ret = Internal.isUnnamedBitfield_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>isAnonymousStructOrUnion - Determines whether this field is a
            /// representative for an anonymous struct or union. Such fields are unnamed
            /// and are implicitly generated by the implementation to store the data for
            /// the anonymous union or struct.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// isAnonymousStructOrUnion - Determines whether this field is
            /// a</para>
            /// <para>  /// representative for an anonymous struct or union. Such
            /// fields are</para>
            /// <para>  /// unnamed and are implicitly generated by the implementation
            /// to</para>
            /// <para>  /// store the data for the anonymous union or struct.</para>
            /// </remarks>
            public bool isAnonymousStructOrUnion()
            {
                var __ret = Internal.isAnonymousStructOrUnion_0(__Instance);
                return __ret;
            }

            public uint getBitWidthValue(clang.ASTContext Ctx)
            {
                var arg0 = ReferenceEquals(Ctx, null) ? global::System.IntPtr.Zero : Ctx.__Instance;
                var __ret = Internal.getBitWidthValue_0(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>removeBitWidth - Remove the bit-field width from this
            /// member.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// removeBitWidth - Remove the bit-field width from this
            /// member.</para>
            /// </remarks>
            public void removeBitWidth()
            {
                Internal.removeBitWidth_0(__Instance);
            }

            /// <summary>
            /// <para>getInClassInitStyle - Get the kind of (C++11) in-class
            /// initializer which this field has.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getInClassInitStyle - Get the kind of (C++11) in-class
            /// initializer which</para>
            /// <para>  /// this field has.</para>
            /// </remarks>
            public clang.InClassInitStyle getInClassInitStyle()
            {
                var __ret = Internal.getInClassInitStyle_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>hasInClassInitializer - Determine whether this member has a C++11
            /// in-class initializer.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// hasInClassInitializer - Determine whether this member has a
            /// C++11 in-class</para>
            /// <para>  /// initializer.</para>
            /// </remarks>
            public bool hasInClassInitializer()
            {
                var __ret = Internal.hasInClassInitializer_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>removeInClassInitializer - Remove the C++11 in-class initializer
            /// from this member.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// removeInClassInitializer - Remove the C++11 in-class
            /// initializer from this</para>
            /// <para>  /// member.</para>
            /// </remarks>
            public void removeInClassInitializer()
            {
                Internal.removeInClassInitializer_0(__Instance);
            }

            /// <summary>
            /// <para>Determine whether this member captures the variable length array
            /// type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine whether this member captures the variable
            /// length array</para>
            /// <para>  /// type.</para>
            /// </remarks>
            public bool hasCapturedVLAType()
            {
                var __ret = Internal.hasCapturedVLAType_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Get the captured variable length array type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Get the captured variable length array type.</para>
            /// </remarks>
            public clang.VariableArrayType getCapturedVLAType()
            {
                var __ret = Internal.getCapturedVLAType_0(__Instance);
                clang.VariableArrayType __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.VariableArrayType.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.VariableArrayType) clang.VariableArrayType.NativeToManagedMap[__ret];
                else __result0 = clang.VariableArrayType.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Set the captured variable length array type for this
            /// field.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Set the captured variable length array type for this
            /// field.</para>
            /// </remarks>
            public void setCapturedVLAType(clang.VariableArrayType VLAType)
            {
                var arg0 = ReferenceEquals(VLAType, null) ? global::System.IntPtr.Zero : VLAType.__Instance;
                Internal.setCapturedVLAType_0(__Instance, arg0);
            }

            public clang.RecordDecl getParent()
            {
                var __ret = Internal.getParent_1(__Instance);
                clang.RecordDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.RecordDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.RecordDecl) clang.RecordDecl.NativeToManagedMap[__ret];
                else clang.RecordDecl.NativeToManagedMap[__ret] = __result0 = (clang.RecordDecl) clang.RecordDecl.__CreateInstance(__ret);
                return __result0;
            }

            public override clang.SourceRange getSourceRange()
            {
                var __ret = Internal.getSourceRange_0(__Instance);
                return clang.SourceRange.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Retrieves the canonical declaration of this field.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Retrieves the canonical declaration of this field.</para>
            /// </remarks>
            public virtual clang.FieldDecl getCanonicalDecl()
            {
                var __ret = Internal.getCanonicalDecl_0(__Instance);
                clang.FieldDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.FieldDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.FieldDecl) clang.FieldDecl.NativeToManagedMap[__ret];
                else clang.FieldDecl.NativeToManagedMap[__ret] = __result0 = (clang.FieldDecl) clang.FieldDecl.__CreateInstance(__ret);
                return __result0;
            }

            public static clang.FieldDecl CreateDeserialized(clang.ASTContext C, uint ID)
            {
                var arg0 = ReferenceEquals(C, null) ? global::System.IntPtr.Zero : C.__Instance;
                var __ret = Internal.CreateDeserialized_0(arg0, ID);
                clang.FieldDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.FieldDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.FieldDecl) clang.FieldDecl.NativeToManagedMap[__ret];
                else clang.FieldDecl.NativeToManagedMap[__ret] = __result0 = (clang.FieldDecl) clang.FieldDecl.__CreateInstance(__ret);
                return __result0;
            }

            public static bool classof(clang.Decl D)
            {
                var arg0 = ReferenceEquals(D, null) ? global::System.IntPtr.Zero : D.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }

            public static bool classofKind(clang.Decl.Kind K)
            {
                var arg0 = K;
                var __ret = Internal.classofKind_0(arg0);
                return __ret;
            }

            #region Virtual table interop

            // FieldDecl
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
            private static _dtor_0Delegate _dtor_0DelegateInstance;

            private static void _dtor_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (FieldDecl) _References[instance].Target;
                __target.DestroyNativeInstance();
            }

            // SourceRange getSourceRange() const override
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate clang.SourceRange.Internal _getSourceRange_0Delegate(global::System.IntPtr instance);
            private static _getSourceRange_0Delegate _getSourceRange_0DelegateInstance;

            private static clang.SourceRange.Internal _getSourceRange_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (FieldDecl) _References[instance].Target;
                var __ret = __target.getSourceRange();
                return ReferenceEquals(__ret, null) ? new clang.SourceRange.Internal() : *(clang.SourceRange.Internal*) (__ret.__Instance);
            }

            // bool isOutOfLine() const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate bool _isOutOfLine_0Delegate(global::System.IntPtr instance);
            private static _isOutOfLine_0Delegate _isOutOfLine_0DelegateInstance;

            private static bool _isOutOfLine_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (FieldDecl) _References[instance].Target;
                var __ret = __target.isOutOfLine();
                return __ret;
            }

            // FieldDecl *getCanonicalDecl() override
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getCanonicalDecl_0Delegate(global::System.IntPtr instance);
            private static _getCanonicalDecl_0Delegate _getCanonicalDecl_0DelegateInstance;

            private static global::System.IntPtr _getCanonicalDecl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (FieldDecl) _References[instance].Target;
                var __ret = __target.getCanonicalDecl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // Decl *getNextRedeclarationImpl()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getNextRedeclarationImpl_0Delegate(global::System.IntPtr instance);
            private static _getNextRedeclarationImpl_0Delegate _getNextRedeclarationImpl_0DelegateInstance;

            private static global::System.IntPtr _getNextRedeclarationImpl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (FieldDecl) _References[instance].Target;
                var __ret = __target.getNextRedeclarationImpl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // Decl *getPreviousDeclImpl()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getPreviousDeclImpl_0Delegate(global::System.IntPtr instance);
            private static _getPreviousDeclImpl_0Delegate _getPreviousDeclImpl_0DelegateInstance;

            private static global::System.IntPtr _getPreviousDeclImpl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (FieldDecl) _References[instance].Target;
                var __ret = __target.getPreviousDeclImpl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // Decl *getMostRecentDeclImpl()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getMostRecentDeclImpl_0Delegate(global::System.IntPtr instance);
            private static _getMostRecentDeclImpl_0Delegate _getMostRecentDeclImpl_0DelegateInstance;

            private static global::System.IntPtr _getMostRecentDeclImpl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (FieldDecl) _References[instance].Target;
                var __ret = __target.getMostRecentDeclImpl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // Stmt* getBody() const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getBody_0Delegate(global::System.IntPtr instance);
            private static _getBody_0Delegate _getBody_0DelegateInstance;

            private static global::System.IntPtr _getBody_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (FieldDecl) _References[instance].Target;
                var __ret = __target.getBody();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // bool hasBody() const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate bool _hasBody_0Delegate(global::System.IntPtr instance);
            private static _hasBody_0Delegate _hasBody_0DelegateInstance;

            private static bool _hasBody_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (FieldDecl) _References[instance].Target;
                var __ret = __target.hasBody();
                return __ret;
            }

            // void getNameForDiagnostic(raw_ostream &OS, const PrintingPolicy &Policy, bool Qualified) const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate void _getNameForDiagnostic_0Delegate(global::System.IntPtr instance, global::System.IntPtr OS, global::System.IntPtr Policy, bool Qualified);
            private static _getNameForDiagnostic_0Delegate _getNameForDiagnostic_0DelegateInstance;

            private static void _getNameForDiagnostic_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr OS, global::System.IntPtr Policy, bool Qualified)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (FieldDecl) _References[instance].Target;
                llvm.raw_ostream __result0;
                if (OS == IntPtr.Zero) __result0 = null;
                else if (llvm.raw_ostream.NativeToManagedMap.ContainsKey(OS))
                    __result0 = (llvm.raw_ostream) llvm.raw_ostream.NativeToManagedMap[OS];
                else llvm.raw_ostream.NativeToManagedMap[OS] = __result0 = (llvm.raw_ostream) llvm.raw_ostream.__CreateInstance(OS);
                clang.PrintingPolicy __result1;
                if (Policy == IntPtr.Zero) __result1 = null;
                else if (clang.PrintingPolicy.NativeToManagedMap.ContainsKey(Policy))
                    __result1 = (clang.PrintingPolicy) clang.PrintingPolicy.NativeToManagedMap[Policy];
                else __result1 = clang.PrintingPolicy.__CreateInstance(Policy);
                __target.getNameForDiagnostic(__result0, __result1, Qualified);
            }

            private static void*[] _OldVTables;
            private static void*[] _NewVTables;
            private static void*[] _Thunks;
            private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

            void SetupVTables(global::System.IntPtr instance)
            {
                var native = (Internal*)instance.ToPointer();

                if (_References == null)
                    _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

                if (_References.ContainsKey(instance))
                    return;

                _References[instance] = new WeakReference(this);

                if (_OldVTables == null)
                {
                    _OldVTables = new void*[1];
                    _OldVTables[0] = native->vfptr0.ToPointer();
                }

                if (_Thunks == null)
                {
                    _Thunks = new void*[10];
                    _dtor_0DelegateInstance += _dtor_0DelegateHook;
                    _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                    _getSourceRange_0DelegateInstance += _getSourceRange_0DelegateHook;
                    _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_getSourceRange_0DelegateInstance).ToPointer();
                    _isOutOfLine_0DelegateInstance += _isOutOfLine_0DelegateHook;
                    _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_isOutOfLine_0DelegateInstance).ToPointer();
                    _getCanonicalDecl_0DelegateInstance += _getCanonicalDecl_0DelegateHook;
                    _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_getCanonicalDecl_0DelegateInstance).ToPointer();
                    _getNextRedeclarationImpl_0DelegateInstance += _getNextRedeclarationImpl_0DelegateHook;
                    _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_getNextRedeclarationImpl_0DelegateInstance).ToPointer();
                    _getPreviousDeclImpl_0DelegateInstance += _getPreviousDeclImpl_0DelegateHook;
                    _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_getPreviousDeclImpl_0DelegateInstance).ToPointer();
                    _getMostRecentDeclImpl_0DelegateInstance += _getMostRecentDeclImpl_0DelegateHook;
                    _Thunks[6] = Marshal.GetFunctionPointerForDelegate(_getMostRecentDeclImpl_0DelegateInstance).ToPointer();
                    _getBody_0DelegateInstance += _getBody_0DelegateHook;
                    _Thunks[7] = Marshal.GetFunctionPointerForDelegate(_getBody_0DelegateInstance).ToPointer();
                    _hasBody_0DelegateInstance += _hasBody_0DelegateHook;
                    _Thunks[8] = Marshal.GetFunctionPointerForDelegate(_hasBody_0DelegateInstance).ToPointer();
                    _getNameForDiagnostic_0DelegateInstance += _getNameForDiagnostic_0DelegateHook;
                    _Thunks[9] = Marshal.GetFunctionPointerForDelegate(_getNameForDiagnostic_0DelegateInstance).ToPointer();
                }

                if (_NewVTables == null)
                {
                    _NewVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(11 * 8);
                    _NewVTables[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + 8) = _Thunks[0];
                    *(void**)(vfptr0 + 16) = _Thunks[1];
                    *(void**)(vfptr0 + 24) = _Thunks[2];
                    *(void**)(vfptr0 + 32) = _Thunks[3];
                    *(void**)(vfptr0 + 40) = _Thunks[4];
                    *(void**)(vfptr0 + 48) = _Thunks[5];
                    *(void**)(vfptr0 + 56) = _Thunks[6];
                    *(void**)(vfptr0 + 64) = _Thunks[7];
                    *(void**)(vfptr0 + 72) = _Thunks[8];
                    *(void**)(vfptr0 + 80) = *(void**)(native->vfptr0 + 80);
                    *(void**)(vfptr0 + 88) = _Thunks[9];
                }

                native->vfptr0 = new IntPtr(_NewVTables[0]);
            }

            #endregion
        }

        /// <summary>
        /// <para>EnumConstantDecl - An instance of this object exists for each
        /// enum constant that is defined. For example, in &quot;enum X {a,b}&quot;,
        /// each of a/b are EnumConstantDecl's, X is an instance of EnumDecl, and the
        /// type of a/b is a TagType for the X EnumDecl.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// EnumConstantDecl - An instance of this object exists for each
        /// enum constant</para>
        /// <para>/// that is defined.  For example, in &quot;enum X {a,b}&quot;,
        /// each of a/b are</para>
        /// <para>/// EnumConstantDecl's, X is an instance of EnumDecl, and the
        /// type of a/b is a</para>
        /// <para>/// TagType for the X EnumDecl.</para>
        /// </remarks>
        public unsafe partial class EnumConstantDecl : clang.ValueDecl, clang.Mergeable, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 80)]
            public new partial struct Internal
            {
                [FieldOffset(8)]
                internal llvm.PointerIntPair.Internal NextInContextAndBits;

                [FieldOffset(16)]
                internal llvm.PointerUnion.Internal DeclCtx;

                [FieldOffset(24)]
                public clang.SourceLocation.Internal Loc;

                [FieldOffset(28)]
                public uint DeclKind;

                [FieldOffset(29)]
                public uint InvalidDecl;

                [FieldOffset(29)]
                public uint HasAttrs;

                [FieldOffset(29)]
                public uint Implicit;

                [FieldOffset(29)]
                public uint Used;

                [FieldOffset(29)]
                public uint Referenced;

                [FieldOffset(29)]
                public uint Access;

                [FieldOffset(29)]
                public uint FromASTFile;

                [FieldOffset(30)]
                public uint Hidden;

                [FieldOffset(30)]
                public uint IdentifierNamespace;

                [FieldOffset(31)]
                public uint CacheValidAndLinkage;

                [FieldOffset(32)]
                public clang.DeclarationName.Internal Name;

                [FieldOffset(40)]
                public clang.QualType.Internal DeclType;

                [FieldOffset(48)]
                public global::System.IntPtr Init;

                [FieldOffset(56)]
                public llvm.APSInt.Internal Val;

                [FieldOffset(0)]
                public global::System.IntPtr vfptr0;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16EnumConstantDeclC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16EnumConstantDeclD2Ev")]
                internal static extern void dtor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16EnumConstantDecl18CreateDeserializedERNS_10ASTContextEj")]
                internal static extern global::System.IntPtr CreateDeserialized_0(global::System.IntPtr C, uint ID);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang16EnumConstantDecl10getInitValEv")]
                internal static extern global::System.IntPtr getInitVal_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16EnumConstantDecl10setInitValERKN4llvm6APSIntE")]
                internal static extern void setInitVal_0(global::System.IntPtr instance, global::System.IntPtr V);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang16EnumConstantDecl14getSourceRangeEv")]
                internal static extern clang.SourceRange.Internal getSourceRange_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16EnumConstantDecl16getCanonicalDeclEv")]
                internal static extern global::System.IntPtr getCanonicalDecl_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16EnumConstantDecl7classofEPKNS_4DeclE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr D);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16EnumConstantDecl11classofKindENS_4Decl4KindE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classofKind_0(clang.Decl.Kind K);
            }

            private readonly bool __ownsNativeInstance;

            public static new EnumConstantDecl __CreateInstance(global::System.IntPtr native)
            {
                return new EnumConstantDecl((EnumConstantDecl.Internal*) native);
            }

            public static EnumConstantDecl __CreateInstance(EnumConstantDecl.Internal native)
            {
                return new EnumConstantDecl(native);
            }

            private static EnumConstantDecl.Internal* __CopyValue(EnumConstantDecl.Internal native)
            {
                var ret = (EnumConstantDecl.Internal*) Marshal.AllocHGlobal(80);
                *ret = native;
                return ret;
            }

            private EnumConstantDecl(EnumConstantDecl.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected EnumConstantDecl(EnumConstantDecl.Internal* native, bool isInternalImpl = false)
                : base((clang.ValueDecl.Internal*) native)
            {
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Decl __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public llvm.APSInt getInitVal()
            {
                var __ret = Internal.getInitVal_0(__Instance);
                llvm.APSInt __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (llvm.APSInt.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (llvm.APSInt) llvm.APSInt.NativeToManagedMap[__ret];
                else __result0 = llvm.APSInt.__CreateInstance(__ret);
                return __result0;
            }

            public void setInitVal(llvm.APSInt V)
            {
                var arg0 = ReferenceEquals(V, null) ? global::System.IntPtr.Zero : V.__Instance;
                Internal.setInitVal_0(__Instance, arg0);
            }

            public override clang.SourceRange getSourceRange()
            {
                var __ret = Internal.getSourceRange_0(__Instance);
                return clang.SourceRange.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Retrieves the canonical declaration of this enumerator.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Retrieves the canonical declaration of this
            /// enumerator.</para>
            /// </remarks>
            public virtual clang.EnumConstantDecl getCanonicalDecl()
            {
                var __ret = Internal.getCanonicalDecl_0(__Instance);
                clang.EnumConstantDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.EnumConstantDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.EnumConstantDecl) clang.EnumConstantDecl.NativeToManagedMap[__ret];
                else clang.EnumConstantDecl.NativeToManagedMap[__ret] = __result0 = (clang.EnumConstantDecl) clang.EnumConstantDecl.__CreateInstance(__ret);
                return __result0;
            }

            public static clang.EnumConstantDecl CreateDeserialized(clang.ASTContext C, uint ID)
            {
                var arg0 = ReferenceEquals(C, null) ? global::System.IntPtr.Zero : C.__Instance;
                var __ret = Internal.CreateDeserialized_0(arg0, ID);
                clang.EnumConstantDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.EnumConstantDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.EnumConstantDecl) clang.EnumConstantDecl.NativeToManagedMap[__ret];
                else clang.EnumConstantDecl.NativeToManagedMap[__ret] = __result0 = (clang.EnumConstantDecl) clang.EnumConstantDecl.__CreateInstance(__ret);
                return __result0;
            }

            public static bool classof(clang.Decl D)
            {
                var arg0 = ReferenceEquals(D, null) ? global::System.IntPtr.Zero : D.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }

            public static bool classofKind(clang.Decl.Kind K)
            {
                var arg0 = K;
                var __ret = Internal.classofKind_0(arg0);
                return __ret;
            }

            #region Virtual table interop

            // EnumConstantDecl
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
            private static _dtor_0Delegate _dtor_0DelegateInstance;

            private static void _dtor_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (EnumConstantDecl) _References[instance].Target;
                __target.DestroyNativeInstance();
            }

            // SourceRange getSourceRange() const override
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate clang.SourceRange.Internal _getSourceRange_0Delegate(global::System.IntPtr instance);
            private static _getSourceRange_0Delegate _getSourceRange_0DelegateInstance;

            private static clang.SourceRange.Internal _getSourceRange_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (EnumConstantDecl) _References[instance].Target;
                var __ret = __target.getSourceRange();
                return ReferenceEquals(__ret, null) ? new clang.SourceRange.Internal() : *(clang.SourceRange.Internal*) (__ret.__Instance);
            }

            // bool isOutOfLine() const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate bool _isOutOfLine_0Delegate(global::System.IntPtr instance);
            private static _isOutOfLine_0Delegate _isOutOfLine_0DelegateInstance;

            private static bool _isOutOfLine_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (EnumConstantDecl) _References[instance].Target;
                var __ret = __target.isOutOfLine();
                return __ret;
            }

            // EnumConstantDecl *getCanonicalDecl() override
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getCanonicalDecl_0Delegate(global::System.IntPtr instance);
            private static _getCanonicalDecl_0Delegate _getCanonicalDecl_0DelegateInstance;

            private static global::System.IntPtr _getCanonicalDecl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (EnumConstantDecl) _References[instance].Target;
                var __ret = __target.getCanonicalDecl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // Decl *getNextRedeclarationImpl()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getNextRedeclarationImpl_0Delegate(global::System.IntPtr instance);
            private static _getNextRedeclarationImpl_0Delegate _getNextRedeclarationImpl_0DelegateInstance;

            private static global::System.IntPtr _getNextRedeclarationImpl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (EnumConstantDecl) _References[instance].Target;
                var __ret = __target.getNextRedeclarationImpl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // Decl *getPreviousDeclImpl()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getPreviousDeclImpl_0Delegate(global::System.IntPtr instance);
            private static _getPreviousDeclImpl_0Delegate _getPreviousDeclImpl_0DelegateInstance;

            private static global::System.IntPtr _getPreviousDeclImpl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (EnumConstantDecl) _References[instance].Target;
                var __ret = __target.getPreviousDeclImpl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // Decl *getMostRecentDeclImpl()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getMostRecentDeclImpl_0Delegate(global::System.IntPtr instance);
            private static _getMostRecentDeclImpl_0Delegate _getMostRecentDeclImpl_0DelegateInstance;

            private static global::System.IntPtr _getMostRecentDeclImpl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (EnumConstantDecl) _References[instance].Target;
                var __ret = __target.getMostRecentDeclImpl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // Stmt* getBody() const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getBody_0Delegate(global::System.IntPtr instance);
            private static _getBody_0Delegate _getBody_0DelegateInstance;

            private static global::System.IntPtr _getBody_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (EnumConstantDecl) _References[instance].Target;
                var __ret = __target.getBody();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // bool hasBody() const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate bool _hasBody_0Delegate(global::System.IntPtr instance);
            private static _hasBody_0Delegate _hasBody_0DelegateInstance;

            private static bool _hasBody_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (EnumConstantDecl) _References[instance].Target;
                var __ret = __target.hasBody();
                return __ret;
            }

            // void getNameForDiagnostic(raw_ostream &OS, const PrintingPolicy &Policy, bool Qualified) const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate void _getNameForDiagnostic_0Delegate(global::System.IntPtr instance, global::System.IntPtr OS, global::System.IntPtr Policy, bool Qualified);
            private static _getNameForDiagnostic_0Delegate _getNameForDiagnostic_0DelegateInstance;

            private static void _getNameForDiagnostic_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr OS, global::System.IntPtr Policy, bool Qualified)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (EnumConstantDecl) _References[instance].Target;
                llvm.raw_ostream __result0;
                if (OS == IntPtr.Zero) __result0 = null;
                else if (llvm.raw_ostream.NativeToManagedMap.ContainsKey(OS))
                    __result0 = (llvm.raw_ostream) llvm.raw_ostream.NativeToManagedMap[OS];
                else llvm.raw_ostream.NativeToManagedMap[OS] = __result0 = (llvm.raw_ostream) llvm.raw_ostream.__CreateInstance(OS);
                clang.PrintingPolicy __result1;
                if (Policy == IntPtr.Zero) __result1 = null;
                else if (clang.PrintingPolicy.NativeToManagedMap.ContainsKey(Policy))
                    __result1 = (clang.PrintingPolicy) clang.PrintingPolicy.NativeToManagedMap[Policy];
                else __result1 = clang.PrintingPolicy.__CreateInstance(Policy);
                __target.getNameForDiagnostic(__result0, __result1, Qualified);
            }

            private static void*[] _OldVTables;
            private static void*[] _NewVTables;
            private static void*[] _Thunks;
            private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

            void SetupVTables(global::System.IntPtr instance)
            {
                var native = (Internal*)instance.ToPointer();

                if (_References == null)
                    _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

                if (_References.ContainsKey(instance))
                    return;

                _References[instance] = new WeakReference(this);

                if (_OldVTables == null)
                {
                    _OldVTables = new void*[1];
                    _OldVTables[0] = native->vfptr0.ToPointer();
                }

                if (_Thunks == null)
                {
                    _Thunks = new void*[10];
                    _dtor_0DelegateInstance += _dtor_0DelegateHook;
                    _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                    _getSourceRange_0DelegateInstance += _getSourceRange_0DelegateHook;
                    _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_getSourceRange_0DelegateInstance).ToPointer();
                    _isOutOfLine_0DelegateInstance += _isOutOfLine_0DelegateHook;
                    _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_isOutOfLine_0DelegateInstance).ToPointer();
                    _getCanonicalDecl_0DelegateInstance += _getCanonicalDecl_0DelegateHook;
                    _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_getCanonicalDecl_0DelegateInstance).ToPointer();
                    _getNextRedeclarationImpl_0DelegateInstance += _getNextRedeclarationImpl_0DelegateHook;
                    _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_getNextRedeclarationImpl_0DelegateInstance).ToPointer();
                    _getPreviousDeclImpl_0DelegateInstance += _getPreviousDeclImpl_0DelegateHook;
                    _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_getPreviousDeclImpl_0DelegateInstance).ToPointer();
                    _getMostRecentDeclImpl_0DelegateInstance += _getMostRecentDeclImpl_0DelegateHook;
                    _Thunks[6] = Marshal.GetFunctionPointerForDelegate(_getMostRecentDeclImpl_0DelegateInstance).ToPointer();
                    _getBody_0DelegateInstance += _getBody_0DelegateHook;
                    _Thunks[7] = Marshal.GetFunctionPointerForDelegate(_getBody_0DelegateInstance).ToPointer();
                    _hasBody_0DelegateInstance += _hasBody_0DelegateHook;
                    _Thunks[8] = Marshal.GetFunctionPointerForDelegate(_hasBody_0DelegateInstance).ToPointer();
                    _getNameForDiagnostic_0DelegateInstance += _getNameForDiagnostic_0DelegateHook;
                    _Thunks[9] = Marshal.GetFunctionPointerForDelegate(_getNameForDiagnostic_0DelegateInstance).ToPointer();
                }

                if (_NewVTables == null)
                {
                    _NewVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(11 * 8);
                    _NewVTables[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + 8) = _Thunks[0];
                    *(void**)(vfptr0 + 16) = _Thunks[1];
                    *(void**)(vfptr0 + 24) = _Thunks[2];
                    *(void**)(vfptr0 + 32) = _Thunks[3];
                    *(void**)(vfptr0 + 40) = _Thunks[4];
                    *(void**)(vfptr0 + 48) = _Thunks[5];
                    *(void**)(vfptr0 + 56) = _Thunks[6];
                    *(void**)(vfptr0 + 64) = _Thunks[7];
                    *(void**)(vfptr0 + 72) = _Thunks[8];
                    *(void**)(vfptr0 + 80) = *(void**)(native->vfptr0 + 80);
                    *(void**)(vfptr0 + 88) = _Thunks[9];
                }

                native->vfptr0 = new IntPtr(_NewVTables[0]);
            }

            #endregion
        }

        /// <summary>
        /// <para>IndirectFieldDecl - An instance of this class is created to
        /// represent a field injected from an anonymous union/struct into the parent
        /// scope. IndirectFieldDecl are always implicit.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// IndirectFieldDecl - An instance of this class is created to
        /// represent a</para>
        /// <para>/// field injected from an anonymous union/struct into the parent
        /// scope.</para>
        /// <para>/// IndirectFieldDecl are always implicit.</para>
        /// </remarks>
        public unsafe partial class IndirectFieldDecl : clang.ValueDecl, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 64)]
            public new partial struct Internal
            {
                [FieldOffset(8)]
                internal llvm.PointerIntPair.Internal NextInContextAndBits;

                [FieldOffset(16)]
                internal llvm.PointerUnion.Internal DeclCtx;

                [FieldOffset(24)]
                public clang.SourceLocation.Internal Loc;

                [FieldOffset(28)]
                public uint DeclKind;

                [FieldOffset(29)]
                public uint InvalidDecl;

                [FieldOffset(29)]
                public uint HasAttrs;

                [FieldOffset(29)]
                public uint Implicit;

                [FieldOffset(29)]
                public uint Used;

                [FieldOffset(29)]
                public uint Referenced;

                [FieldOffset(29)]
                public uint Access;

                [FieldOffset(29)]
                public uint FromASTFile;

                [FieldOffset(30)]
                public uint Hidden;

                [FieldOffset(30)]
                public uint IdentifierNamespace;

                [FieldOffset(31)]
                public uint CacheValidAndLinkage;

                [FieldOffset(32)]
                public clang.DeclarationName.Internal Name;

                [FieldOffset(40)]
                public clang.QualType.Internal DeclType;

                [FieldOffset(48)]
                public global::System.IntPtr Chaining;

                [FieldOffset(56)]
                public uint ChainingSize;

                [FieldOffset(0)]
                public global::System.IntPtr vfptr0;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17IndirectFieldDeclC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17IndirectFieldDeclD2Ev")]
                internal static extern void dtor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17IndirectFieldDecl6CreateERNS_10ASTContextEPNS_11DeclContextENS_14SourceLocationEPNS_14IdentifierInfoENS_8QualTypeEPPNS_9NamedDeclEj")]
                internal static extern global::System.IntPtr Create_0(global::System.IntPtr C, global::System.IntPtr DC, clang.SourceLocation.Internal L, global::System.IntPtr Id, clang.QualType.Internal T, global::System.IntPtr CH, uint CHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17IndirectFieldDecl18CreateDeserializedERNS_10ASTContextEj")]
                internal static extern global::System.IntPtr CreateDeserialized_0(global::System.IntPtr C, uint ID);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17IndirectFieldDecl11chain_beginEv")]
                internal static extern global::System.IntPtr chain_begin_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17IndirectFieldDecl9chain_endEv")]
                internal static extern global::System.IntPtr chain_end_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17IndirectFieldDecl15getChainingSizeEv")]
                internal static extern uint getChainingSize_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17IndirectFieldDecl12getAnonFieldEv")]
                internal static extern global::System.IntPtr getAnonField_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang17IndirectFieldDecl10getVarDeclEv")]
                internal static extern global::System.IntPtr getVarDecl_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17IndirectFieldDecl7classofEPKNS_4DeclE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr D);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang17IndirectFieldDecl11classofKindENS_4Decl4KindE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classofKind_0(clang.Decl.Kind K);
            }

            private readonly bool __ownsNativeInstance;

            public static new IndirectFieldDecl __CreateInstance(global::System.IntPtr native)
            {
                return new IndirectFieldDecl((IndirectFieldDecl.Internal*) native);
            }

            public static IndirectFieldDecl __CreateInstance(IndirectFieldDecl.Internal native)
            {
                return new IndirectFieldDecl(native);
            }

            private static IndirectFieldDecl.Internal* __CopyValue(IndirectFieldDecl.Internal native)
            {
                var ret = (IndirectFieldDecl.Internal*) Marshal.AllocHGlobal(64);
                *ret = native;
                return ret;
            }

            private IndirectFieldDecl(IndirectFieldDecl.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected IndirectFieldDecl(IndirectFieldDecl.Internal* native, bool isInternalImpl = false)
                : base((clang.ValueDecl.Internal*) native)
            {
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Decl __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.NamedDecl chain_begin()
            {
                var __ret = Internal.chain_begin_0(__Instance);
                clang.NamedDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.NamedDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.NamedDecl) clang.NamedDecl.NativeToManagedMap[__ret];
                else clang.NamedDecl.NativeToManagedMap[__ret] = __result0 = (clang.NamedDecl) clang.NamedDecl.__CreateInstance(__ret);
                return __result0;
            }

            public clang.NamedDecl chain_end()
            {
                var __ret = Internal.chain_end_0(__Instance);
                clang.NamedDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.NamedDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.NamedDecl) clang.NamedDecl.NativeToManagedMap[__ret];
                else clang.NamedDecl.NativeToManagedMap[__ret] = __result0 = (clang.NamedDecl) clang.NamedDecl.__CreateInstance(__ret);
                return __result0;
            }

            public uint getChainingSize()
            {
                var __ret = Internal.getChainingSize_0(__Instance);
                return __ret;
            }

            public clang.FieldDecl getAnonField()
            {
                var __ret = Internal.getAnonField_0(__Instance);
                clang.FieldDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.FieldDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.FieldDecl) clang.FieldDecl.NativeToManagedMap[__ret];
                else clang.FieldDecl.NativeToManagedMap[__ret] = __result0 = (clang.FieldDecl) clang.FieldDecl.__CreateInstance(__ret);
                return __result0;
            }

            public clang.VarDecl getVarDecl()
            {
                var __ret = Internal.getVarDecl_0(__Instance);
                clang.VarDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.VarDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.VarDecl) clang.VarDecl.NativeToManagedMap[__ret];
                else clang.VarDecl.NativeToManagedMap[__ret] = __result0 = (clang.VarDecl) clang.VarDecl.__CreateInstance(__ret);
                return __result0;
            }

            public static clang.IndirectFieldDecl Create(clang.ASTContext C, clang.DeclContext DC, clang.SourceLocation L, clang.IdentifierInfo Id, clang.QualType T, clang.NamedDecl CH, uint CHS)
            {
                var arg0 = ReferenceEquals(C, null) ? global::System.IntPtr.Zero : C.__Instance;
                var arg1 = ReferenceEquals(DC, null) ? global::System.IntPtr.Zero : DC.__Instance;
                var arg2 = ReferenceEquals(L, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (L.__Instance);
                var arg3 = ReferenceEquals(Id, null) ? global::System.IntPtr.Zero : Id.__Instance;
                var arg4 = ReferenceEquals(T, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (T.__Instance);
                var arg5 = ReferenceEquals(CH, null) ? global::System.IntPtr.Zero : CH.__Instance;
                var __ret = Internal.Create_0(arg0, arg1, arg2, arg3, arg4, arg5, CHS);
                clang.IndirectFieldDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.IndirectFieldDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.IndirectFieldDecl) clang.IndirectFieldDecl.NativeToManagedMap[__ret];
                else clang.IndirectFieldDecl.NativeToManagedMap[__ret] = __result0 = (clang.IndirectFieldDecl) clang.IndirectFieldDecl.__CreateInstance(__ret);
                return __result0;
            }

            public static clang.IndirectFieldDecl CreateDeserialized(clang.ASTContext C, uint ID)
            {
                var arg0 = ReferenceEquals(C, null) ? global::System.IntPtr.Zero : C.__Instance;
                var __ret = Internal.CreateDeserialized_0(arg0, ID);
                clang.IndirectFieldDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.IndirectFieldDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.IndirectFieldDecl) clang.IndirectFieldDecl.NativeToManagedMap[__ret];
                else clang.IndirectFieldDecl.NativeToManagedMap[__ret] = __result0 = (clang.IndirectFieldDecl) clang.IndirectFieldDecl.__CreateInstance(__ret);
                return __result0;
            }

            public static bool classof(clang.Decl D)
            {
                var arg0 = ReferenceEquals(D, null) ? global::System.IntPtr.Zero : D.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }

            public static bool classofKind(clang.Decl.Kind K)
            {
                var arg0 = K;
                var __ret = Internal.classofKind_0(arg0);
                return __ret;
            }

            #region Virtual table interop

            // IndirectFieldDecl
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
            private static _dtor_0Delegate _dtor_0DelegateInstance;

            private static void _dtor_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (IndirectFieldDecl) _References[instance].Target;
                __target.DestroyNativeInstance();
            }

            // SourceRange getSourceRange() const LLVM_READONLY
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate clang.SourceRange.Internal _getSourceRange_0Delegate(global::System.IntPtr instance);
            private static _getSourceRange_0Delegate _getSourceRange_0DelegateInstance;

            private static clang.SourceRange.Internal _getSourceRange_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (IndirectFieldDecl) _References[instance].Target;
                var __ret = __target.getSourceRange();
                return ReferenceEquals(__ret, null) ? new clang.SourceRange.Internal() : *(clang.SourceRange.Internal*) (__ret.__Instance);
            }

            // bool isOutOfLine() const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate bool _isOutOfLine_0Delegate(global::System.IntPtr instance);
            private static _isOutOfLine_0Delegate _isOutOfLine_0DelegateInstance;

            private static bool _isOutOfLine_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (IndirectFieldDecl) _References[instance].Target;
                var __ret = __target.isOutOfLine();
                return __ret;
            }

            // Decl *getCanonicalDecl()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getCanonicalDecl_0Delegate(global::System.IntPtr instance);
            private static _getCanonicalDecl_0Delegate _getCanonicalDecl_0DelegateInstance;

            private static global::System.IntPtr _getCanonicalDecl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (IndirectFieldDecl) _References[instance].Target;
                var __ret = __target.getCanonicalDecl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // Decl *getNextRedeclarationImpl()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getNextRedeclarationImpl_0Delegate(global::System.IntPtr instance);
            private static _getNextRedeclarationImpl_0Delegate _getNextRedeclarationImpl_0DelegateInstance;

            private static global::System.IntPtr _getNextRedeclarationImpl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (IndirectFieldDecl) _References[instance].Target;
                var __ret = __target.getNextRedeclarationImpl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // Decl *getPreviousDeclImpl()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getPreviousDeclImpl_0Delegate(global::System.IntPtr instance);
            private static _getPreviousDeclImpl_0Delegate _getPreviousDeclImpl_0DelegateInstance;

            private static global::System.IntPtr _getPreviousDeclImpl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (IndirectFieldDecl) _References[instance].Target;
                var __ret = __target.getPreviousDeclImpl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // Decl *getMostRecentDeclImpl()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getMostRecentDeclImpl_0Delegate(global::System.IntPtr instance);
            private static _getMostRecentDeclImpl_0Delegate _getMostRecentDeclImpl_0DelegateInstance;

            private static global::System.IntPtr _getMostRecentDeclImpl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (IndirectFieldDecl) _References[instance].Target;
                var __ret = __target.getMostRecentDeclImpl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // Stmt* getBody() const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getBody_0Delegate(global::System.IntPtr instance);
            private static _getBody_0Delegate _getBody_0DelegateInstance;

            private static global::System.IntPtr _getBody_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (IndirectFieldDecl) _References[instance].Target;
                var __ret = __target.getBody();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // bool hasBody() const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate bool _hasBody_0Delegate(global::System.IntPtr instance);
            private static _hasBody_0Delegate _hasBody_0DelegateInstance;

            private static bool _hasBody_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (IndirectFieldDecl) _References[instance].Target;
                var __ret = __target.hasBody();
                return __ret;
            }

            // void getNameForDiagnostic(raw_ostream &OS, const PrintingPolicy &Policy, bool Qualified) const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate void _getNameForDiagnostic_0Delegate(global::System.IntPtr instance, global::System.IntPtr OS, global::System.IntPtr Policy, bool Qualified);
            private static _getNameForDiagnostic_0Delegate _getNameForDiagnostic_0DelegateInstance;

            private static void _getNameForDiagnostic_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr OS, global::System.IntPtr Policy, bool Qualified)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (IndirectFieldDecl) _References[instance].Target;
                llvm.raw_ostream __result0;
                if (OS == IntPtr.Zero) __result0 = null;
                else if (llvm.raw_ostream.NativeToManagedMap.ContainsKey(OS))
                    __result0 = (llvm.raw_ostream) llvm.raw_ostream.NativeToManagedMap[OS];
                else llvm.raw_ostream.NativeToManagedMap[OS] = __result0 = (llvm.raw_ostream) llvm.raw_ostream.__CreateInstance(OS);
                clang.PrintingPolicy __result1;
                if (Policy == IntPtr.Zero) __result1 = null;
                else if (clang.PrintingPolicy.NativeToManagedMap.ContainsKey(Policy))
                    __result1 = (clang.PrintingPolicy) clang.PrintingPolicy.NativeToManagedMap[Policy];
                else __result1 = clang.PrintingPolicy.__CreateInstance(Policy);
                __target.getNameForDiagnostic(__result0, __result1, Qualified);
            }

            private static void*[] _OldVTables;
            private static void*[] _NewVTables;
            private static void*[] _Thunks;
            private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

            void SetupVTables(global::System.IntPtr instance)
            {
                var native = (Internal*)instance.ToPointer();

                if (_References == null)
                    _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

                if (_References.ContainsKey(instance))
                    return;

                _References[instance] = new WeakReference(this);

                if (_OldVTables == null)
                {
                    _OldVTables = new void*[1];
                    _OldVTables[0] = native->vfptr0.ToPointer();
                }

                if (_Thunks == null)
                {
                    _Thunks = new void*[10];
                    _dtor_0DelegateInstance += _dtor_0DelegateHook;
                    _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                    _getSourceRange_0DelegateInstance += _getSourceRange_0DelegateHook;
                    _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_getSourceRange_0DelegateInstance).ToPointer();
                    _isOutOfLine_0DelegateInstance += _isOutOfLine_0DelegateHook;
                    _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_isOutOfLine_0DelegateInstance).ToPointer();
                    _getCanonicalDecl_0DelegateInstance += _getCanonicalDecl_0DelegateHook;
                    _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_getCanonicalDecl_0DelegateInstance).ToPointer();
                    _getNextRedeclarationImpl_0DelegateInstance += _getNextRedeclarationImpl_0DelegateHook;
                    _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_getNextRedeclarationImpl_0DelegateInstance).ToPointer();
                    _getPreviousDeclImpl_0DelegateInstance += _getPreviousDeclImpl_0DelegateHook;
                    _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_getPreviousDeclImpl_0DelegateInstance).ToPointer();
                    _getMostRecentDeclImpl_0DelegateInstance += _getMostRecentDeclImpl_0DelegateHook;
                    _Thunks[6] = Marshal.GetFunctionPointerForDelegate(_getMostRecentDeclImpl_0DelegateInstance).ToPointer();
                    _getBody_0DelegateInstance += _getBody_0DelegateHook;
                    _Thunks[7] = Marshal.GetFunctionPointerForDelegate(_getBody_0DelegateInstance).ToPointer();
                    _hasBody_0DelegateInstance += _hasBody_0DelegateHook;
                    _Thunks[8] = Marshal.GetFunctionPointerForDelegate(_hasBody_0DelegateInstance).ToPointer();
                    _getNameForDiagnostic_0DelegateInstance += _getNameForDiagnostic_0DelegateHook;
                    _Thunks[9] = Marshal.GetFunctionPointerForDelegate(_getNameForDiagnostic_0DelegateInstance).ToPointer();
                }

                if (_NewVTables == null)
                {
                    _NewVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(11 * 8);
                    _NewVTables[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + 8) = _Thunks[0];
                    *(void**)(vfptr0 + 16) = _Thunks[1];
                    *(void**)(vfptr0 + 24) = _Thunks[2];
                    *(void**)(vfptr0 + 32) = _Thunks[3];
                    *(void**)(vfptr0 + 40) = _Thunks[4];
                    *(void**)(vfptr0 + 48) = _Thunks[5];
                    *(void**)(vfptr0 + 56) = _Thunks[6];
                    *(void**)(vfptr0 + 64) = _Thunks[7];
                    *(void**)(vfptr0 + 72) = _Thunks[8];
                    *(void**)(vfptr0 + 80) = *(void**)(native->vfptr0 + 80);
                    *(void**)(vfptr0 + 88) = _Thunks[9];
                }

                native->vfptr0 = new IntPtr(_NewVTables[0]);
            }

            #endregion
        }

        /// <summary>
        /// <para>TypeDecl - Represents a declaration of a type.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// TypeDecl - Represents a declaration of a type.</para>
        /// <para>///</para>
        /// </remarks>
        public unsafe partial class TypeDecl : clang.NamedDecl, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 56)]
            public new partial struct Internal
            {
                [FieldOffset(8)]
                internal llvm.PointerIntPair.Internal NextInContextAndBits;

                [FieldOffset(16)]
                internal llvm.PointerUnion.Internal DeclCtx;

                [FieldOffset(24)]
                public clang.SourceLocation.Internal Loc;

                [FieldOffset(28)]
                public uint DeclKind;

                [FieldOffset(29)]
                public uint InvalidDecl;

                [FieldOffset(29)]
                public uint HasAttrs;

                [FieldOffset(29)]
                public uint Implicit;

                [FieldOffset(29)]
                public uint Used;

                [FieldOffset(29)]
                public uint Referenced;

                [FieldOffset(29)]
                public uint Access;

                [FieldOffset(29)]
                public uint FromASTFile;

                [FieldOffset(30)]
                public uint Hidden;

                [FieldOffset(30)]
                public uint IdentifierNamespace;

                [FieldOffset(31)]
                public uint CacheValidAndLinkage;

                [FieldOffset(32)]
                public clang.DeclarationName.Internal Name;

                [FieldOffset(40)]
                public global::System.IntPtr TypeForDecl;

                [FieldOffset(48)]
                public clang.SourceLocation.Internal LocStart;

                [FieldOffset(0)]
                public global::System.IntPtr vfptr0;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8TypeDeclC2ENS_4Decl4KindEPNS_11DeclContextENS_14SourceLocationEPNS_14IdentifierInfoES5_")]
                internal static extern void ctor_0(global::System.IntPtr instance, clang.Decl.Kind DK, global::System.IntPtr DC, clang.SourceLocation.Internal L, global::System.IntPtr Id, clang.SourceLocation.Internal StartL);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8TypeDeclC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8TypeDeclD2Ev")]
                internal static extern void dtor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8TypeDecl14getTypeForDeclEv")]
                internal static extern global::System.IntPtr getTypeForDecl_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8TypeDecl14setTypeForDeclEPKNS_4TypeE")]
                internal static extern void setTypeForDecl_0(global::System.IntPtr instance, global::System.IntPtr TD);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8TypeDecl11getLocStartEv")]
                internal static extern clang.SourceLocation.Internal getLocStart_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8TypeDecl11setLocStartENS_14SourceLocationE")]
                internal static extern void setLocStart_0(global::System.IntPtr instance, clang.SourceLocation.Internal L);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8TypeDecl14getSourceRangeEv")]
                internal static extern clang.SourceRange.Internal getSourceRange_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8TypeDecl7classofEPKNS_4DeclE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr D);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8TypeDecl11classofKindENS_4Decl4KindE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classofKind_0(clang.Decl.Kind K);
            }

            private readonly bool __ownsNativeInstance;

            public static new TypeDecl __CreateInstance(global::System.IntPtr native)
            {
                return new TypeDecl((TypeDecl.Internal*) native);
            }

            public static TypeDecl __CreateInstance(TypeDecl.Internal native)
            {
                return new TypeDecl(native);
            }

            private static TypeDecl.Internal* __CopyValue(TypeDecl.Internal native)
            {
                var ret = (TypeDecl.Internal*) Marshal.AllocHGlobal(56);
                *ret = native;
                return ret;
            }

            private TypeDecl(TypeDecl.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected TypeDecl(TypeDecl.Internal* native, bool isInternalImpl = false)
                : base((clang.NamedDecl.Internal*) native)
            {
            }

            protected TypeDecl(clang.Decl.Kind DK, clang.DeclContext DC, clang.SourceLocation L, clang.IdentifierInfo Id, clang.SourceLocation StartL)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(56);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = DK;
                var arg1 = ReferenceEquals(DC, null) ? global::System.IntPtr.Zero : DC.__Instance;
                var arg2 = ReferenceEquals(L, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (L.__Instance);
                var arg3 = ReferenceEquals(Id, null) ? global::System.IntPtr.Zero : Id.__Instance;
                var arg4 = ReferenceEquals(StartL, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (StartL.__Instance);
                Internal.ctor_0(__Instance, arg0, arg1, arg2, arg3, arg4);
                SetupVTables(__Instance);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Decl __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.Type getTypeForDecl()
            {
                var __ret = Internal.getTypeForDecl_0(__Instance);
                clang.Type __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Type.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Type) clang.Type.NativeToManagedMap[__ret];
                else __result0 = clang.Type.__CreateInstance(__ret);
                return __result0;
            }

            public void setTypeForDecl(clang.Type TD)
            {
                var arg0 = ReferenceEquals(TD, null) ? global::System.IntPtr.Zero : TD.__Instance;
                Internal.setTypeForDecl_0(__Instance, arg0);
            }

            public clang.SourceLocation getLocStart()
            {
                var __ret = Internal.getLocStart_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setLocStart(clang.SourceLocation L)
            {
                var arg0 = ReferenceEquals(L, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (L.__Instance);
                Internal.setLocStart_0(__Instance, arg0);
            }

            public override clang.SourceRange getSourceRange()
            {
                var __ret = Internal.getSourceRange_0(__Instance);
                return clang.SourceRange.__CreateInstance(__ret);
            }

            public static bool classof(clang.Decl D)
            {
                var arg0 = ReferenceEquals(D, null) ? global::System.IntPtr.Zero : D.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }

            public static bool classofKind(clang.Decl.Kind K)
            {
                var arg0 = K;
                var __ret = Internal.classofKind_0(arg0);
                return __ret;
            }

            #region Virtual table interop

            // TypeDecl
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
            private static _dtor_0Delegate _dtor_0DelegateInstance;

            private static void _dtor_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (TypeDecl) _References[instance].Target;
                __target.DestroyNativeInstance();
            }

            // SourceRange getSourceRange() const override
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate clang.SourceRange.Internal _getSourceRange_0Delegate(global::System.IntPtr instance);
            private static _getSourceRange_0Delegate _getSourceRange_0DelegateInstance;

            private static clang.SourceRange.Internal _getSourceRange_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (TypeDecl) _References[instance].Target;
                var __ret = __target.getSourceRange();
                return ReferenceEquals(__ret, null) ? new clang.SourceRange.Internal() : *(clang.SourceRange.Internal*) (__ret.__Instance);
            }

            // bool isOutOfLine() const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate bool _isOutOfLine_0Delegate(global::System.IntPtr instance);
            private static _isOutOfLine_0Delegate _isOutOfLine_0DelegateInstance;

            private static bool _isOutOfLine_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (TypeDecl) _References[instance].Target;
                var __ret = __target.isOutOfLine();
                return __ret;
            }

            // Decl *getCanonicalDecl()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getCanonicalDecl_0Delegate(global::System.IntPtr instance);
            private static _getCanonicalDecl_0Delegate _getCanonicalDecl_0DelegateInstance;

            private static global::System.IntPtr _getCanonicalDecl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (TypeDecl) _References[instance].Target;
                var __ret = __target.getCanonicalDecl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // Decl *getNextRedeclarationImpl()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getNextRedeclarationImpl_0Delegate(global::System.IntPtr instance);
            private static _getNextRedeclarationImpl_0Delegate _getNextRedeclarationImpl_0DelegateInstance;

            private static global::System.IntPtr _getNextRedeclarationImpl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (TypeDecl) _References[instance].Target;
                var __ret = __target.getNextRedeclarationImpl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // Decl *getPreviousDeclImpl()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getPreviousDeclImpl_0Delegate(global::System.IntPtr instance);
            private static _getPreviousDeclImpl_0Delegate _getPreviousDeclImpl_0DelegateInstance;

            private static global::System.IntPtr _getPreviousDeclImpl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (TypeDecl) _References[instance].Target;
                var __ret = __target.getPreviousDeclImpl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // Decl *getMostRecentDeclImpl()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getMostRecentDeclImpl_0Delegate(global::System.IntPtr instance);
            private static _getMostRecentDeclImpl_0Delegate _getMostRecentDeclImpl_0DelegateInstance;

            private static global::System.IntPtr _getMostRecentDeclImpl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (TypeDecl) _References[instance].Target;
                var __ret = __target.getMostRecentDeclImpl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // Stmt* getBody() const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getBody_0Delegate(global::System.IntPtr instance);
            private static _getBody_0Delegate _getBody_0DelegateInstance;

            private static global::System.IntPtr _getBody_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (TypeDecl) _References[instance].Target;
                var __ret = __target.getBody();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // bool hasBody() const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate bool _hasBody_0Delegate(global::System.IntPtr instance);
            private static _hasBody_0Delegate _hasBody_0DelegateInstance;

            private static bool _hasBody_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (TypeDecl) _References[instance].Target;
                var __ret = __target.hasBody();
                return __ret;
            }

            // void getNameForDiagnostic(raw_ostream &OS, const PrintingPolicy &Policy, bool Qualified) const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate void _getNameForDiagnostic_0Delegate(global::System.IntPtr instance, global::System.IntPtr OS, global::System.IntPtr Policy, bool Qualified);
            private static _getNameForDiagnostic_0Delegate _getNameForDiagnostic_0DelegateInstance;

            private static void _getNameForDiagnostic_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr OS, global::System.IntPtr Policy, bool Qualified)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (TypeDecl) _References[instance].Target;
                llvm.raw_ostream __result0;
                if (OS == IntPtr.Zero) __result0 = null;
                else if (llvm.raw_ostream.NativeToManagedMap.ContainsKey(OS))
                    __result0 = (llvm.raw_ostream) llvm.raw_ostream.NativeToManagedMap[OS];
                else llvm.raw_ostream.NativeToManagedMap[OS] = __result0 = (llvm.raw_ostream) llvm.raw_ostream.__CreateInstance(OS);
                clang.PrintingPolicy __result1;
                if (Policy == IntPtr.Zero) __result1 = null;
                else if (clang.PrintingPolicy.NativeToManagedMap.ContainsKey(Policy))
                    __result1 = (clang.PrintingPolicy) clang.PrintingPolicy.NativeToManagedMap[Policy];
                else __result1 = clang.PrintingPolicy.__CreateInstance(Policy);
                __target.getNameForDiagnostic(__result0, __result1, Qualified);
            }

            private static void*[] _OldVTables;
            private static void*[] _NewVTables;
            private static void*[] _Thunks;
            private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

            void SetupVTables(global::System.IntPtr instance)
            {
                var native = (Internal*)instance.ToPointer();

                if (_References == null)
                    _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

                if (_References.ContainsKey(instance))
                    return;

                _References[instance] = new WeakReference(this);

                if (_OldVTables == null)
                {
                    _OldVTables = new void*[1];
                    _OldVTables[0] = native->vfptr0.ToPointer();
                }

                if (_Thunks == null)
                {
                    _Thunks = new void*[10];
                    _dtor_0DelegateInstance += _dtor_0DelegateHook;
                    _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                    _getSourceRange_0DelegateInstance += _getSourceRange_0DelegateHook;
                    _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_getSourceRange_0DelegateInstance).ToPointer();
                    _isOutOfLine_0DelegateInstance += _isOutOfLine_0DelegateHook;
                    _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_isOutOfLine_0DelegateInstance).ToPointer();
                    _getCanonicalDecl_0DelegateInstance += _getCanonicalDecl_0DelegateHook;
                    _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_getCanonicalDecl_0DelegateInstance).ToPointer();
                    _getNextRedeclarationImpl_0DelegateInstance += _getNextRedeclarationImpl_0DelegateHook;
                    _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_getNextRedeclarationImpl_0DelegateInstance).ToPointer();
                    _getPreviousDeclImpl_0DelegateInstance += _getPreviousDeclImpl_0DelegateHook;
                    _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_getPreviousDeclImpl_0DelegateInstance).ToPointer();
                    _getMostRecentDeclImpl_0DelegateInstance += _getMostRecentDeclImpl_0DelegateHook;
                    _Thunks[6] = Marshal.GetFunctionPointerForDelegate(_getMostRecentDeclImpl_0DelegateInstance).ToPointer();
                    _getBody_0DelegateInstance += _getBody_0DelegateHook;
                    _Thunks[7] = Marshal.GetFunctionPointerForDelegate(_getBody_0DelegateInstance).ToPointer();
                    _hasBody_0DelegateInstance += _hasBody_0DelegateHook;
                    _Thunks[8] = Marshal.GetFunctionPointerForDelegate(_hasBody_0DelegateInstance).ToPointer();
                    _getNameForDiagnostic_0DelegateInstance += _getNameForDiagnostic_0DelegateHook;
                    _Thunks[9] = Marshal.GetFunctionPointerForDelegate(_getNameForDiagnostic_0DelegateInstance).ToPointer();
                }

                if (_NewVTables == null)
                {
                    _NewVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(11 * 8);
                    _NewVTables[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + 8) = _Thunks[0];
                    *(void**)(vfptr0 + 16) = _Thunks[1];
                    *(void**)(vfptr0 + 24) = _Thunks[2];
                    *(void**)(vfptr0 + 32) = _Thunks[3];
                    *(void**)(vfptr0 + 40) = _Thunks[4];
                    *(void**)(vfptr0 + 48) = _Thunks[5];
                    *(void**)(vfptr0 + 56) = _Thunks[6];
                    *(void**)(vfptr0 + 64) = _Thunks[7];
                    *(void**)(vfptr0 + 72) = _Thunks[8];
                    *(void**)(vfptr0 + 80) = *(void**)(native->vfptr0 + 80);
                    *(void**)(vfptr0 + 88) = _Thunks[9];
                }

                native->vfptr0 = new IntPtr(_NewVTables[0]);
            }

            #endregion
        }

        /// <summary>
        /// <para>Base class for declarations which introduce a
        /// typedef-name.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// Base class for declarations which introduce a
        /// typedef-name.</para>
        /// </remarks>
        public unsafe partial class TypedefNameDecl : clang.TypeDecl, clang.Redeclarable, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 72)]
            public new partial struct Internal
            {
                [FieldOffset(8)]
                internal llvm.PointerIntPair.Internal NextInContextAndBits;

                [FieldOffset(16)]
                internal llvm.PointerUnion.Internal DeclCtx;

                [FieldOffset(24)]
                public clang.SourceLocation.Internal Loc;

                [FieldOffset(28)]
                public uint DeclKind;

                [FieldOffset(29)]
                public uint InvalidDecl;

                [FieldOffset(29)]
                public uint HasAttrs;

                [FieldOffset(29)]
                public uint Implicit;

                [FieldOffset(29)]
                public uint Used;

                [FieldOffset(29)]
                public uint Referenced;

                [FieldOffset(29)]
                public uint Access;

                [FieldOffset(29)]
                public uint FromASTFile;

                [FieldOffset(30)]
                public uint Hidden;

                [FieldOffset(30)]
                public uint IdentifierNamespace;

                [FieldOffset(31)]
                public uint CacheValidAndLinkage;

                [FieldOffset(32)]
                public clang.DeclarationName.Internal Name;

                [FieldOffset(40)]
                public global::System.IntPtr TypeForDecl;

                [FieldOffset(48)]
                public clang.SourceLocation.Internal LocStart;

                [FieldOffset(64)]
                internal llvm.PointerUnion.Internal MaybeModedTInfo;

                [FieldOffset(0)]
                public global::System.IntPtr vfptr0;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang15TypedefNameDeclC2ENS_4Decl4KindERNS_10ASTContextEPNS_11DeclContextENS_14SourceLocationES7_PNS_14IdentifierInfoEPNS_14TypeSourceInfoE")]
                internal static extern void ctor_0(global::System.IntPtr instance, clang.Decl.Kind DK, global::System.IntPtr C, global::System.IntPtr DC, clang.SourceLocation.Internal StartLoc, clang.SourceLocation.Internal IdLoc, global::System.IntPtr Id, global::System.IntPtr TInfo);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang15TypedefNameDeclC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang15TypedefNameDeclD2Ev")]
                internal static extern void dtor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang15TypedefNameDecl24getNextRedeclarationImplEv")]
                internal static extern global::System.IntPtr getNextRedeclarationImpl_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang15TypedefNameDecl19getPreviousDeclImplEv")]
                internal static extern global::System.IntPtr getPreviousDeclImpl_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang15TypedefNameDecl21getMostRecentDeclImplEv")]
                internal static extern global::System.IntPtr getMostRecentDeclImpl_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang15TypedefNameDecl7isModedEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isModed_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang15TypedefNameDecl17getTypeSourceInfoEv")]
                internal static extern global::System.IntPtr getTypeSourceInfo_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang15TypedefNameDecl17getUnderlyingTypeEv")]
                internal static extern clang.QualType.Internal getUnderlyingType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang15TypedefNameDecl17setTypeSourceInfoEPNS_14TypeSourceInfoE")]
                internal static extern void setTypeSourceInfo_0(global::System.IntPtr instance, global::System.IntPtr newType);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang15TypedefNameDecl22setModedTypeSourceInfoEPNS_14TypeSourceInfoENS_8QualTypeE")]
                internal static extern void setModedTypeSourceInfo_0(global::System.IntPtr instance, global::System.IntPtr unmodedTSI, clang.QualType.Internal modedTy);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang15TypedefNameDecl16getCanonicalDeclEv")]
                internal static extern global::System.IntPtr getCanonicalDecl_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang15TypedefNameDecl7classofEPKNS_4DeclE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr D);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang15TypedefNameDecl11classofKindENS_4Decl4KindE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classofKind_0(clang.Decl.Kind K);
            }

            private readonly bool __ownsNativeInstance;

            public static new TypedefNameDecl __CreateInstance(global::System.IntPtr native)
            {
                return new TypedefNameDecl((TypedefNameDecl.Internal*) native);
            }

            public static TypedefNameDecl __CreateInstance(TypedefNameDecl.Internal native)
            {
                return new TypedefNameDecl(native);
            }

            private static TypedefNameDecl.Internal* __CopyValue(TypedefNameDecl.Internal native)
            {
                var ret = (TypedefNameDecl.Internal*) Marshal.AllocHGlobal(72);
                *ret = native;
                return ret;
            }

            private TypedefNameDecl(TypedefNameDecl.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected TypedefNameDecl(TypedefNameDecl.Internal* native, bool isInternalImpl = false)
                : base((clang.TypeDecl.Internal*) native)
            {
            }

            protected TypedefNameDecl(clang.Decl.Kind DK, clang.ASTContext C, clang.DeclContext DC, clang.SourceLocation StartLoc, clang.SourceLocation IdLoc, clang.IdentifierInfo Id, clang.TypeSourceInfo TInfo)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(72);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = DK;
                var arg1 = ReferenceEquals(C, null) ? global::System.IntPtr.Zero : C.__Instance;
                var arg2 = ReferenceEquals(DC, null) ? global::System.IntPtr.Zero : DC.__Instance;
                var arg3 = ReferenceEquals(StartLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (StartLoc.__Instance);
                var arg4 = ReferenceEquals(IdLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (IdLoc.__Instance);
                var arg5 = ReferenceEquals(Id, null) ? global::System.IntPtr.Zero : Id.__Instance;
                var arg6 = ReferenceEquals(TInfo, null) ? global::System.IntPtr.Zero : TInfo.__Instance;
                Internal.ctor_0(__Instance, arg0, arg1, arg2, arg3, arg4, arg5, arg6);
                SetupVTables(__Instance);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Decl __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            protected virtual clang.TypedefNameDecl getNextRedeclarationImpl()
            {
                var __ret = Internal.getNextRedeclarationImpl_0(__Instance);
                clang.TypedefNameDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.TypedefNameDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.TypedefNameDecl) clang.TypedefNameDecl.NativeToManagedMap[__ret];
                else clang.TypedefNameDecl.NativeToManagedMap[__ret] = __result0 = (clang.TypedefNameDecl) clang.TypedefNameDecl.__CreateInstance(__ret);
                return __result0;
            }

            protected virtual clang.TypedefNameDecl getPreviousDeclImpl()
            {
                var __ret = Internal.getPreviousDeclImpl_0(__Instance);
                clang.TypedefNameDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.TypedefNameDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.TypedefNameDecl) clang.TypedefNameDecl.NativeToManagedMap[__ret];
                else clang.TypedefNameDecl.NativeToManagedMap[__ret] = __result0 = (clang.TypedefNameDecl) clang.TypedefNameDecl.__CreateInstance(__ret);
                return __result0;
            }

            protected virtual clang.TypedefNameDecl getMostRecentDeclImpl()
            {
                var __ret = Internal.getMostRecentDeclImpl_0(__Instance);
                clang.TypedefNameDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.TypedefNameDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.TypedefNameDecl) clang.TypedefNameDecl.NativeToManagedMap[__ret];
                else clang.TypedefNameDecl.NativeToManagedMap[__ret] = __result0 = (clang.TypedefNameDecl) clang.TypedefNameDecl.__CreateInstance(__ret);
                return __result0;
            }

            public bool isModed()
            {
                var __ret = Internal.isModed_0(__Instance);
                return __ret;
            }

            public clang.TypeSourceInfo getTypeSourceInfo()
            {
                var __ret = Internal.getTypeSourceInfo_0(__Instance);
                clang.TypeSourceInfo __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.TypeSourceInfo.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.TypeSourceInfo) clang.TypeSourceInfo.NativeToManagedMap[__ret];
                else __result0 = clang.TypeSourceInfo.__CreateInstance(__ret);
                return __result0;
            }

            public clang.QualType getUnderlyingType()
            {
                var __ret = Internal.getUnderlyingType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            public void setTypeSourceInfo(clang.TypeSourceInfo newType)
            {
                var arg0 = ReferenceEquals(newType, null) ? global::System.IntPtr.Zero : newType.__Instance;
                Internal.setTypeSourceInfo_0(__Instance, arg0);
            }

            public void setModedTypeSourceInfo(clang.TypeSourceInfo unmodedTSI, clang.QualType modedTy)
            {
                var arg0 = ReferenceEquals(unmodedTSI, null) ? global::System.IntPtr.Zero : unmodedTSI.__Instance;
                var arg1 = ReferenceEquals(modedTy, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (modedTy.__Instance);
                Internal.setModedTypeSourceInfo_0(__Instance, arg0, arg1);
            }

            /// <summary>
            /// <para>Retrieves the canonical declaration of this typedef-name.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Retrieves the canonical declaration of this
            /// typedef-name.</para>
            /// </remarks>
            public virtual clang.TypedefNameDecl getCanonicalDecl()
            {
                var __ret = Internal.getCanonicalDecl_0(__Instance);
                clang.TypedefNameDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.TypedefNameDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.TypedefNameDecl) clang.TypedefNameDecl.NativeToManagedMap[__ret];
                else clang.TypedefNameDecl.NativeToManagedMap[__ret] = __result0 = (clang.TypedefNameDecl) clang.TypedefNameDecl.__CreateInstance(__ret);
                return __result0;
            }

            public static bool classof(clang.Decl D)
            {
                var arg0 = ReferenceEquals(D, null) ? global::System.IntPtr.Zero : D.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }

            public static bool classofKind(clang.Decl.Kind K)
            {
                var arg0 = K;
                var __ret = Internal.classofKind_0(arg0);
                return __ret;
            }

            #region Virtual table interop

            // TypedefNameDecl
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
            private static _dtor_0Delegate _dtor_0DelegateInstance;

            private static void _dtor_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (TypedefNameDecl) _References[instance].Target;
                __target.DestroyNativeInstance();
            }

            // SourceRange getSourceRange() const override
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate clang.SourceRange.Internal _getSourceRange_0Delegate(global::System.IntPtr instance);
            private static _getSourceRange_0Delegate _getSourceRange_0DelegateInstance;

            private static clang.SourceRange.Internal _getSourceRange_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (TypedefNameDecl) _References[instance].Target;
                var __ret = __target.getSourceRange();
                return ReferenceEquals(__ret, null) ? new clang.SourceRange.Internal() : *(clang.SourceRange.Internal*) (__ret.__Instance);
            }

            // bool isOutOfLine() const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate bool _isOutOfLine_0Delegate(global::System.IntPtr instance);
            private static _isOutOfLine_0Delegate _isOutOfLine_0DelegateInstance;

            private static bool _isOutOfLine_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (TypedefNameDecl) _References[instance].Target;
                var __ret = __target.isOutOfLine();
                return __ret;
            }

            // TypedefNameDecl *getCanonicalDecl() override
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getCanonicalDecl_0Delegate(global::System.IntPtr instance);
            private static _getCanonicalDecl_0Delegate _getCanonicalDecl_0DelegateInstance;

            private static global::System.IntPtr _getCanonicalDecl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (TypedefNameDecl) _References[instance].Target;
                var __ret = __target.getCanonicalDecl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // TypedefNameDecl *getNextRedeclarationImpl() override
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getNextRedeclarationImpl_0Delegate(global::System.IntPtr instance);
            private static _getNextRedeclarationImpl_0Delegate _getNextRedeclarationImpl_0DelegateInstance;

            private static global::System.IntPtr _getNextRedeclarationImpl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (TypedefNameDecl) _References[instance].Target;
                var __ret = __target.getNextRedeclarationImpl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // TypedefNameDecl *getPreviousDeclImpl() override
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getPreviousDeclImpl_0Delegate(global::System.IntPtr instance);
            private static _getPreviousDeclImpl_0Delegate _getPreviousDeclImpl_0DelegateInstance;

            private static global::System.IntPtr _getPreviousDeclImpl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (TypedefNameDecl) _References[instance].Target;
                var __ret = __target.getPreviousDeclImpl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // TypedefNameDecl *getMostRecentDeclImpl() override
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getMostRecentDeclImpl_0Delegate(global::System.IntPtr instance);
            private static _getMostRecentDeclImpl_0Delegate _getMostRecentDeclImpl_0DelegateInstance;

            private static global::System.IntPtr _getMostRecentDeclImpl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (TypedefNameDecl) _References[instance].Target;
                var __ret = __target.getMostRecentDeclImpl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // Stmt* getBody() const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getBody_0Delegate(global::System.IntPtr instance);
            private static _getBody_0Delegate _getBody_0DelegateInstance;

            private static global::System.IntPtr _getBody_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (TypedefNameDecl) _References[instance].Target;
                var __ret = __target.getBody();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // bool hasBody() const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate bool _hasBody_0Delegate(global::System.IntPtr instance);
            private static _hasBody_0Delegate _hasBody_0DelegateInstance;

            private static bool _hasBody_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (TypedefNameDecl) _References[instance].Target;
                var __ret = __target.hasBody();
                return __ret;
            }

            // void getNameForDiagnostic(raw_ostream &OS, const PrintingPolicy &Policy, bool Qualified) const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate void _getNameForDiagnostic_0Delegate(global::System.IntPtr instance, global::System.IntPtr OS, global::System.IntPtr Policy, bool Qualified);
            private static _getNameForDiagnostic_0Delegate _getNameForDiagnostic_0DelegateInstance;

            private static void _getNameForDiagnostic_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr OS, global::System.IntPtr Policy, bool Qualified)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (TypedefNameDecl) _References[instance].Target;
                llvm.raw_ostream __result0;
                if (OS == IntPtr.Zero) __result0 = null;
                else if (llvm.raw_ostream.NativeToManagedMap.ContainsKey(OS))
                    __result0 = (llvm.raw_ostream) llvm.raw_ostream.NativeToManagedMap[OS];
                else llvm.raw_ostream.NativeToManagedMap[OS] = __result0 = (llvm.raw_ostream) llvm.raw_ostream.__CreateInstance(OS);
                clang.PrintingPolicy __result1;
                if (Policy == IntPtr.Zero) __result1 = null;
                else if (clang.PrintingPolicy.NativeToManagedMap.ContainsKey(Policy))
                    __result1 = (clang.PrintingPolicy) clang.PrintingPolicy.NativeToManagedMap[Policy];
                else __result1 = clang.PrintingPolicy.__CreateInstance(Policy);
                __target.getNameForDiagnostic(__result0, __result1, Qualified);
            }

            private static void*[] _OldVTables;
            private static void*[] _NewVTables;
            private static void*[] _Thunks;
            private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

            void SetupVTables(global::System.IntPtr instance)
            {
                var native = (Internal*)instance.ToPointer();

                if (_References == null)
                    _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

                if (_References.ContainsKey(instance))
                    return;

                _References[instance] = new WeakReference(this);

                if (_OldVTables == null)
                {
                    _OldVTables = new void*[1];
                    _OldVTables[0] = native->vfptr0.ToPointer();
                }

                if (_Thunks == null)
                {
                    _Thunks = new void*[10];
                    _dtor_0DelegateInstance += _dtor_0DelegateHook;
                    _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                    _getSourceRange_0DelegateInstance += _getSourceRange_0DelegateHook;
                    _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_getSourceRange_0DelegateInstance).ToPointer();
                    _isOutOfLine_0DelegateInstance += _isOutOfLine_0DelegateHook;
                    _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_isOutOfLine_0DelegateInstance).ToPointer();
                    _getCanonicalDecl_0DelegateInstance += _getCanonicalDecl_0DelegateHook;
                    _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_getCanonicalDecl_0DelegateInstance).ToPointer();
                    _getNextRedeclarationImpl_0DelegateInstance += _getNextRedeclarationImpl_0DelegateHook;
                    _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_getNextRedeclarationImpl_0DelegateInstance).ToPointer();
                    _getPreviousDeclImpl_0DelegateInstance += _getPreviousDeclImpl_0DelegateHook;
                    _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_getPreviousDeclImpl_0DelegateInstance).ToPointer();
                    _getMostRecentDeclImpl_0DelegateInstance += _getMostRecentDeclImpl_0DelegateHook;
                    _Thunks[6] = Marshal.GetFunctionPointerForDelegate(_getMostRecentDeclImpl_0DelegateInstance).ToPointer();
                    _getBody_0DelegateInstance += _getBody_0DelegateHook;
                    _Thunks[7] = Marshal.GetFunctionPointerForDelegate(_getBody_0DelegateInstance).ToPointer();
                    _hasBody_0DelegateInstance += _hasBody_0DelegateHook;
                    _Thunks[8] = Marshal.GetFunctionPointerForDelegate(_hasBody_0DelegateInstance).ToPointer();
                    _getNameForDiagnostic_0DelegateInstance += _getNameForDiagnostic_0DelegateHook;
                    _Thunks[9] = Marshal.GetFunctionPointerForDelegate(_getNameForDiagnostic_0DelegateInstance).ToPointer();
                }

                if (_NewVTables == null)
                {
                    _NewVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(11 * 8);
                    _NewVTables[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + 8) = _Thunks[0];
                    *(void**)(vfptr0 + 16) = _Thunks[1];
                    *(void**)(vfptr0 + 24) = _Thunks[2];
                    *(void**)(vfptr0 + 32) = _Thunks[3];
                    *(void**)(vfptr0 + 40) = _Thunks[4];
                    *(void**)(vfptr0 + 48) = _Thunks[5];
                    *(void**)(vfptr0 + 56) = _Thunks[6];
                    *(void**)(vfptr0 + 64) = _Thunks[7];
                    *(void**)(vfptr0 + 72) = _Thunks[8];
                    *(void**)(vfptr0 + 80) = *(void**)(native->vfptr0 + 80);
                    *(void**)(vfptr0 + 88) = _Thunks[9];
                }

                native->vfptr0 = new IntPtr(_NewVTables[0]);
            }

            #endregion
        }

        /// <summary>
        /// <para>TypedefDecl - Represents the declaration of a typedef-name via
        /// the 'typedef' type specifier.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// TypedefDecl - Represents the declaration of a typedef-name
        /// via the 'typedef'</para>
        /// <para>/// type specifier.</para>
        /// </remarks>
        public unsafe partial class TypedefDecl : clang.TypedefNameDecl, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 72)]
            public new partial struct Internal
            {
                [FieldOffset(8)]
                internal llvm.PointerIntPair.Internal NextInContextAndBits;

                [FieldOffset(16)]
                internal llvm.PointerUnion.Internal DeclCtx;

                [FieldOffset(24)]
                public clang.SourceLocation.Internal Loc;

                [FieldOffset(28)]
                public uint DeclKind;

                [FieldOffset(29)]
                public uint InvalidDecl;

                [FieldOffset(29)]
                public uint HasAttrs;

                [FieldOffset(29)]
                public uint Implicit;

                [FieldOffset(29)]
                public uint Used;

                [FieldOffset(29)]
                public uint Referenced;

                [FieldOffset(29)]
                public uint Access;

                [FieldOffset(29)]
                public uint FromASTFile;

                [FieldOffset(30)]
                public uint Hidden;

                [FieldOffset(30)]
                public uint IdentifierNamespace;

                [FieldOffset(31)]
                public uint CacheValidAndLinkage;

                [FieldOffset(32)]
                public clang.DeclarationName.Internal Name;

                [FieldOffset(40)]
                public global::System.IntPtr TypeForDecl;

                [FieldOffset(48)]
                public clang.SourceLocation.Internal LocStart;

                [FieldOffset(64)]
                internal llvm.PointerUnion.Internal MaybeModedTInfo;

                [FieldOffset(0)]
                public global::System.IntPtr vfptr0;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11TypedefDeclC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11TypedefDeclD2Ev")]
                internal static extern void dtor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11TypedefDecl6CreateERNS_10ASTContextEPNS_11DeclContextENS_14SourceLocationES5_PNS_14IdentifierInfoEPNS_14TypeSourceInfoE")]
                internal static extern global::System.IntPtr Create_0(global::System.IntPtr C, global::System.IntPtr DC, clang.SourceLocation.Internal StartLoc, clang.SourceLocation.Internal IdLoc, global::System.IntPtr Id, global::System.IntPtr TInfo);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11TypedefDecl18CreateDeserializedERNS_10ASTContextEj")]
                internal static extern global::System.IntPtr CreateDeserialized_0(global::System.IntPtr C, uint ID);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11TypedefDecl14getSourceRangeEv")]
                internal static extern clang.SourceRange.Internal getSourceRange_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11TypedefDecl7classofEPKNS_4DeclE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr D);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11TypedefDecl11classofKindENS_4Decl4KindE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classofKind_0(clang.Decl.Kind K);
            }

            private readonly bool __ownsNativeInstance;

            public static new TypedefDecl __CreateInstance(global::System.IntPtr native)
            {
                return new TypedefDecl((TypedefDecl.Internal*) native);
            }

            public static TypedefDecl __CreateInstance(TypedefDecl.Internal native)
            {
                return new TypedefDecl(native);
            }

            private static TypedefDecl.Internal* __CopyValue(TypedefDecl.Internal native)
            {
                var ret = (TypedefDecl.Internal*) Marshal.AllocHGlobal(72);
                *ret = native;
                return ret;
            }

            private TypedefDecl(TypedefDecl.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected TypedefDecl(TypedefDecl.Internal* native, bool isInternalImpl = false)
                : base((clang.TypedefNameDecl.Internal*) native)
            {
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Decl __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public override clang.SourceRange getSourceRange()
            {
                var __ret = Internal.getSourceRange_0(__Instance);
                return clang.SourceRange.__CreateInstance(__ret);
            }

            public static clang.TypedefDecl Create(clang.ASTContext C, clang.DeclContext DC, clang.SourceLocation StartLoc, clang.SourceLocation IdLoc, clang.IdentifierInfo Id, clang.TypeSourceInfo TInfo)
            {
                var arg0 = ReferenceEquals(C, null) ? global::System.IntPtr.Zero : C.__Instance;
                var arg1 = ReferenceEquals(DC, null) ? global::System.IntPtr.Zero : DC.__Instance;
                var arg2 = ReferenceEquals(StartLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (StartLoc.__Instance);
                var arg3 = ReferenceEquals(IdLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (IdLoc.__Instance);
                var arg4 = ReferenceEquals(Id, null) ? global::System.IntPtr.Zero : Id.__Instance;
                var arg5 = ReferenceEquals(TInfo, null) ? global::System.IntPtr.Zero : TInfo.__Instance;
                var __ret = Internal.Create_0(arg0, arg1, arg2, arg3, arg4, arg5);
                clang.TypedefDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.TypedefDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.TypedefDecl) clang.TypedefDecl.NativeToManagedMap[__ret];
                else clang.TypedefDecl.NativeToManagedMap[__ret] = __result0 = (clang.TypedefDecl) clang.TypedefDecl.__CreateInstance(__ret);
                return __result0;
            }

            public static clang.TypedefDecl CreateDeserialized(clang.ASTContext C, uint ID)
            {
                var arg0 = ReferenceEquals(C, null) ? global::System.IntPtr.Zero : C.__Instance;
                var __ret = Internal.CreateDeserialized_0(arg0, ID);
                clang.TypedefDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.TypedefDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.TypedefDecl) clang.TypedefDecl.NativeToManagedMap[__ret];
                else clang.TypedefDecl.NativeToManagedMap[__ret] = __result0 = (clang.TypedefDecl) clang.TypedefDecl.__CreateInstance(__ret);
                return __result0;
            }

            public static bool classof(clang.Decl D)
            {
                var arg0 = ReferenceEquals(D, null) ? global::System.IntPtr.Zero : D.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }

            public static bool classofKind(clang.Decl.Kind K)
            {
                var arg0 = K;
                var __ret = Internal.classofKind_0(arg0);
                return __ret;
            }

            #region Virtual table interop

            // TypedefDecl
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
            private static _dtor_0Delegate _dtor_0DelegateInstance;

            private static void _dtor_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (TypedefDecl) _References[instance].Target;
                __target.DestroyNativeInstance();
            }

            // SourceRange getSourceRange() const override
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate clang.SourceRange.Internal _getSourceRange_0Delegate(global::System.IntPtr instance);
            private static _getSourceRange_0Delegate _getSourceRange_0DelegateInstance;

            private static clang.SourceRange.Internal _getSourceRange_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (TypedefDecl) _References[instance].Target;
                var __ret = __target.getSourceRange();
                return ReferenceEquals(__ret, null) ? new clang.SourceRange.Internal() : *(clang.SourceRange.Internal*) (__ret.__Instance);
            }

            // bool isOutOfLine() const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate bool _isOutOfLine_0Delegate(global::System.IntPtr instance);
            private static _isOutOfLine_0Delegate _isOutOfLine_0DelegateInstance;

            private static bool _isOutOfLine_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (TypedefDecl) _References[instance].Target;
                var __ret = __target.isOutOfLine();
                return __ret;
            }

            // TypedefNameDecl *getCanonicalDecl() override
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getCanonicalDecl_0Delegate(global::System.IntPtr instance);
            private static _getCanonicalDecl_0Delegate _getCanonicalDecl_0DelegateInstance;

            private static global::System.IntPtr _getCanonicalDecl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (TypedefDecl) _References[instance].Target;
                var __ret = __target.getCanonicalDecl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // TypedefNameDecl *getNextRedeclarationImpl() override
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getNextRedeclarationImpl_0Delegate(global::System.IntPtr instance);
            private static _getNextRedeclarationImpl_0Delegate _getNextRedeclarationImpl_0DelegateInstance;

            private static global::System.IntPtr _getNextRedeclarationImpl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (TypedefDecl) _References[instance].Target;
                var __ret = __target.getNextRedeclarationImpl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // TypedefNameDecl *getPreviousDeclImpl() override
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getPreviousDeclImpl_0Delegate(global::System.IntPtr instance);
            private static _getPreviousDeclImpl_0Delegate _getPreviousDeclImpl_0DelegateInstance;

            private static global::System.IntPtr _getPreviousDeclImpl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (TypedefDecl) _References[instance].Target;
                var __ret = __target.getPreviousDeclImpl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // TypedefNameDecl *getMostRecentDeclImpl() override
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getMostRecentDeclImpl_0Delegate(global::System.IntPtr instance);
            private static _getMostRecentDeclImpl_0Delegate _getMostRecentDeclImpl_0DelegateInstance;

            private static global::System.IntPtr _getMostRecentDeclImpl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (TypedefDecl) _References[instance].Target;
                var __ret = __target.getMostRecentDeclImpl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // Stmt* getBody() const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getBody_0Delegate(global::System.IntPtr instance);
            private static _getBody_0Delegate _getBody_0DelegateInstance;

            private static global::System.IntPtr _getBody_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (TypedefDecl) _References[instance].Target;
                var __ret = __target.getBody();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // bool hasBody() const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate bool _hasBody_0Delegate(global::System.IntPtr instance);
            private static _hasBody_0Delegate _hasBody_0DelegateInstance;

            private static bool _hasBody_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (TypedefDecl) _References[instance].Target;
                var __ret = __target.hasBody();
                return __ret;
            }

            // void getNameForDiagnostic(raw_ostream &OS, const PrintingPolicy &Policy, bool Qualified) const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate void _getNameForDiagnostic_0Delegate(global::System.IntPtr instance, global::System.IntPtr OS, global::System.IntPtr Policy, bool Qualified);
            private static _getNameForDiagnostic_0Delegate _getNameForDiagnostic_0DelegateInstance;

            private static void _getNameForDiagnostic_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr OS, global::System.IntPtr Policy, bool Qualified)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (TypedefDecl) _References[instance].Target;
                llvm.raw_ostream __result0;
                if (OS == IntPtr.Zero) __result0 = null;
                else if (llvm.raw_ostream.NativeToManagedMap.ContainsKey(OS))
                    __result0 = (llvm.raw_ostream) llvm.raw_ostream.NativeToManagedMap[OS];
                else llvm.raw_ostream.NativeToManagedMap[OS] = __result0 = (llvm.raw_ostream) llvm.raw_ostream.__CreateInstance(OS);
                clang.PrintingPolicy __result1;
                if (Policy == IntPtr.Zero) __result1 = null;
                else if (clang.PrintingPolicy.NativeToManagedMap.ContainsKey(Policy))
                    __result1 = (clang.PrintingPolicy) clang.PrintingPolicy.NativeToManagedMap[Policy];
                else __result1 = clang.PrintingPolicy.__CreateInstance(Policy);
                __target.getNameForDiagnostic(__result0, __result1, Qualified);
            }

            private static void*[] _OldVTables;
            private static void*[] _NewVTables;
            private static void*[] _Thunks;
            private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

            void SetupVTables(global::System.IntPtr instance)
            {
                var native = (Internal*)instance.ToPointer();

                if (_References == null)
                    _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

                if (_References.ContainsKey(instance))
                    return;

                _References[instance] = new WeakReference(this);

                if (_OldVTables == null)
                {
                    _OldVTables = new void*[1];
                    _OldVTables[0] = native->vfptr0.ToPointer();
                }

                if (_Thunks == null)
                {
                    _Thunks = new void*[10];
                    _dtor_0DelegateInstance += _dtor_0DelegateHook;
                    _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                    _getSourceRange_0DelegateInstance += _getSourceRange_0DelegateHook;
                    _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_getSourceRange_0DelegateInstance).ToPointer();
                    _isOutOfLine_0DelegateInstance += _isOutOfLine_0DelegateHook;
                    _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_isOutOfLine_0DelegateInstance).ToPointer();
                    _getCanonicalDecl_0DelegateInstance += _getCanonicalDecl_0DelegateHook;
                    _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_getCanonicalDecl_0DelegateInstance).ToPointer();
                    _getNextRedeclarationImpl_0DelegateInstance += _getNextRedeclarationImpl_0DelegateHook;
                    _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_getNextRedeclarationImpl_0DelegateInstance).ToPointer();
                    _getPreviousDeclImpl_0DelegateInstance += _getPreviousDeclImpl_0DelegateHook;
                    _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_getPreviousDeclImpl_0DelegateInstance).ToPointer();
                    _getMostRecentDeclImpl_0DelegateInstance += _getMostRecentDeclImpl_0DelegateHook;
                    _Thunks[6] = Marshal.GetFunctionPointerForDelegate(_getMostRecentDeclImpl_0DelegateInstance).ToPointer();
                    _getBody_0DelegateInstance += _getBody_0DelegateHook;
                    _Thunks[7] = Marshal.GetFunctionPointerForDelegate(_getBody_0DelegateInstance).ToPointer();
                    _hasBody_0DelegateInstance += _hasBody_0DelegateHook;
                    _Thunks[8] = Marshal.GetFunctionPointerForDelegate(_hasBody_0DelegateInstance).ToPointer();
                    _getNameForDiagnostic_0DelegateInstance += _getNameForDiagnostic_0DelegateHook;
                    _Thunks[9] = Marshal.GetFunctionPointerForDelegate(_getNameForDiagnostic_0DelegateInstance).ToPointer();
                }

                if (_NewVTables == null)
                {
                    _NewVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(11 * 8);
                    _NewVTables[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + 8) = _Thunks[0];
                    *(void**)(vfptr0 + 16) = _Thunks[1];
                    *(void**)(vfptr0 + 24) = _Thunks[2];
                    *(void**)(vfptr0 + 32) = _Thunks[3];
                    *(void**)(vfptr0 + 40) = _Thunks[4];
                    *(void**)(vfptr0 + 48) = _Thunks[5];
                    *(void**)(vfptr0 + 56) = _Thunks[6];
                    *(void**)(vfptr0 + 64) = _Thunks[7];
                    *(void**)(vfptr0 + 72) = _Thunks[8];
                    *(void**)(vfptr0 + 80) = *(void**)(native->vfptr0 + 80);
                    *(void**)(vfptr0 + 88) = _Thunks[9];
                }

                native->vfptr0 = new IntPtr(_NewVTables[0]);
            }

            #endregion
        }

        /// <summary>
        /// <para>TypeAliasDecl - Represents the declaration of a typedef-name via
        /// a C++0x alias-declaration.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// TypeAliasDecl - Represents the declaration of a typedef-name
        /// via a C++0x</para>
        /// <para>/// alias-declaration.</para>
        /// </remarks>
        public unsafe partial class TypeAliasDecl : clang.TypedefNameDecl, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 80)]
            public new partial struct Internal
            {
                [FieldOffset(8)]
                internal llvm.PointerIntPair.Internal NextInContextAndBits;

                [FieldOffset(16)]
                internal llvm.PointerUnion.Internal DeclCtx;

                [FieldOffset(24)]
                public clang.SourceLocation.Internal Loc;

                [FieldOffset(28)]
                public uint DeclKind;

                [FieldOffset(29)]
                public uint InvalidDecl;

                [FieldOffset(29)]
                public uint HasAttrs;

                [FieldOffset(29)]
                public uint Implicit;

                [FieldOffset(29)]
                public uint Used;

                [FieldOffset(29)]
                public uint Referenced;

                [FieldOffset(29)]
                public uint Access;

                [FieldOffset(29)]
                public uint FromASTFile;

                [FieldOffset(30)]
                public uint Hidden;

                [FieldOffset(30)]
                public uint IdentifierNamespace;

                [FieldOffset(31)]
                public uint CacheValidAndLinkage;

                [FieldOffset(32)]
                public clang.DeclarationName.Internal Name;

                [FieldOffset(40)]
                public global::System.IntPtr TypeForDecl;

                [FieldOffset(48)]
                public clang.SourceLocation.Internal LocStart;

                [FieldOffset(64)]
                internal llvm.PointerUnion.Internal MaybeModedTInfo;

                [FieldOffset(72)]
                public global::System.IntPtr Template;

                [FieldOffset(0)]
                public global::System.IntPtr vfptr0;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13TypeAliasDeclC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13TypeAliasDeclD2Ev")]
                internal static extern void dtor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13TypeAliasDecl6CreateERNS_10ASTContextEPNS_11DeclContextENS_14SourceLocationES5_PNS_14IdentifierInfoEPNS_14TypeSourceInfoE")]
                internal static extern global::System.IntPtr Create_0(global::System.IntPtr C, global::System.IntPtr DC, clang.SourceLocation.Internal StartLoc, clang.SourceLocation.Internal IdLoc, global::System.IntPtr Id, global::System.IntPtr TInfo);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13TypeAliasDecl18CreateDeserializedERNS_10ASTContextEj")]
                internal static extern global::System.IntPtr CreateDeserialized_0(global::System.IntPtr C, uint ID);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13TypeAliasDecl14getSourceRangeEv")]
                internal static extern clang.SourceRange.Internal getSourceRange_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13TypeAliasDecl7classofEPKNS_4DeclE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr D);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13TypeAliasDecl11classofKindENS_4Decl4KindE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classofKind_0(clang.Decl.Kind K);
            }

            private readonly bool __ownsNativeInstance;

            public static new TypeAliasDecl __CreateInstance(global::System.IntPtr native)
            {
                return new TypeAliasDecl((TypeAliasDecl.Internal*) native);
            }

            public static TypeAliasDecl __CreateInstance(TypeAliasDecl.Internal native)
            {
                return new TypeAliasDecl(native);
            }

            private static TypeAliasDecl.Internal* __CopyValue(TypeAliasDecl.Internal native)
            {
                var ret = (TypeAliasDecl.Internal*) Marshal.AllocHGlobal(80);
                *ret = native;
                return ret;
            }

            private TypeAliasDecl(TypeAliasDecl.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected TypeAliasDecl(TypeAliasDecl.Internal* native, bool isInternalImpl = false)
                : base((clang.TypedefNameDecl.Internal*) native)
            {
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Decl __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public override clang.SourceRange getSourceRange()
            {
                var __ret = Internal.getSourceRange_0(__Instance);
                return clang.SourceRange.__CreateInstance(__ret);
            }

            public static clang.TypeAliasDecl Create(clang.ASTContext C, clang.DeclContext DC, clang.SourceLocation StartLoc, clang.SourceLocation IdLoc, clang.IdentifierInfo Id, clang.TypeSourceInfo TInfo)
            {
                var arg0 = ReferenceEquals(C, null) ? global::System.IntPtr.Zero : C.__Instance;
                var arg1 = ReferenceEquals(DC, null) ? global::System.IntPtr.Zero : DC.__Instance;
                var arg2 = ReferenceEquals(StartLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (StartLoc.__Instance);
                var arg3 = ReferenceEquals(IdLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (IdLoc.__Instance);
                var arg4 = ReferenceEquals(Id, null) ? global::System.IntPtr.Zero : Id.__Instance;
                var arg5 = ReferenceEquals(TInfo, null) ? global::System.IntPtr.Zero : TInfo.__Instance;
                var __ret = Internal.Create_0(arg0, arg1, arg2, arg3, arg4, arg5);
                clang.TypeAliasDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.TypeAliasDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.TypeAliasDecl) clang.TypeAliasDecl.NativeToManagedMap[__ret];
                else clang.TypeAliasDecl.NativeToManagedMap[__ret] = __result0 = (clang.TypeAliasDecl) clang.TypeAliasDecl.__CreateInstance(__ret);
                return __result0;
            }

            public static clang.TypeAliasDecl CreateDeserialized(clang.ASTContext C, uint ID)
            {
                var arg0 = ReferenceEquals(C, null) ? global::System.IntPtr.Zero : C.__Instance;
                var __ret = Internal.CreateDeserialized_0(arg0, ID);
                clang.TypeAliasDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.TypeAliasDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.TypeAliasDecl) clang.TypeAliasDecl.NativeToManagedMap[__ret];
                else clang.TypeAliasDecl.NativeToManagedMap[__ret] = __result0 = (clang.TypeAliasDecl) clang.TypeAliasDecl.__CreateInstance(__ret);
                return __result0;
            }

            public static bool classof(clang.Decl D)
            {
                var arg0 = ReferenceEquals(D, null) ? global::System.IntPtr.Zero : D.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }

            public static bool classofKind(clang.Decl.Kind K)
            {
                var arg0 = K;
                var __ret = Internal.classofKind_0(arg0);
                return __ret;
            }

            #region Virtual table interop

            // TypeAliasDecl
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
            private static _dtor_0Delegate _dtor_0DelegateInstance;

            private static void _dtor_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (TypeAliasDecl) _References[instance].Target;
                __target.DestroyNativeInstance();
            }

            // SourceRange getSourceRange() const override
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate clang.SourceRange.Internal _getSourceRange_0Delegate(global::System.IntPtr instance);
            private static _getSourceRange_0Delegate _getSourceRange_0DelegateInstance;

            private static clang.SourceRange.Internal _getSourceRange_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (TypeAliasDecl) _References[instance].Target;
                var __ret = __target.getSourceRange();
                return ReferenceEquals(__ret, null) ? new clang.SourceRange.Internal() : *(clang.SourceRange.Internal*) (__ret.__Instance);
            }

            // bool isOutOfLine() const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate bool _isOutOfLine_0Delegate(global::System.IntPtr instance);
            private static _isOutOfLine_0Delegate _isOutOfLine_0DelegateInstance;

            private static bool _isOutOfLine_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (TypeAliasDecl) _References[instance].Target;
                var __ret = __target.isOutOfLine();
                return __ret;
            }

            // TypedefNameDecl *getCanonicalDecl() override
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getCanonicalDecl_0Delegate(global::System.IntPtr instance);
            private static _getCanonicalDecl_0Delegate _getCanonicalDecl_0DelegateInstance;

            private static global::System.IntPtr _getCanonicalDecl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (TypeAliasDecl) _References[instance].Target;
                var __ret = __target.getCanonicalDecl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // TypedefNameDecl *getNextRedeclarationImpl() override
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getNextRedeclarationImpl_0Delegate(global::System.IntPtr instance);
            private static _getNextRedeclarationImpl_0Delegate _getNextRedeclarationImpl_0DelegateInstance;

            private static global::System.IntPtr _getNextRedeclarationImpl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (TypeAliasDecl) _References[instance].Target;
                var __ret = __target.getNextRedeclarationImpl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // TypedefNameDecl *getPreviousDeclImpl() override
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getPreviousDeclImpl_0Delegate(global::System.IntPtr instance);
            private static _getPreviousDeclImpl_0Delegate _getPreviousDeclImpl_0DelegateInstance;

            private static global::System.IntPtr _getPreviousDeclImpl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (TypeAliasDecl) _References[instance].Target;
                var __ret = __target.getPreviousDeclImpl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // TypedefNameDecl *getMostRecentDeclImpl() override
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getMostRecentDeclImpl_0Delegate(global::System.IntPtr instance);
            private static _getMostRecentDeclImpl_0Delegate _getMostRecentDeclImpl_0DelegateInstance;

            private static global::System.IntPtr _getMostRecentDeclImpl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (TypeAliasDecl) _References[instance].Target;
                var __ret = __target.getMostRecentDeclImpl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // Stmt* getBody() const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getBody_0Delegate(global::System.IntPtr instance);
            private static _getBody_0Delegate _getBody_0DelegateInstance;

            private static global::System.IntPtr _getBody_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (TypeAliasDecl) _References[instance].Target;
                var __ret = __target.getBody();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // bool hasBody() const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate bool _hasBody_0Delegate(global::System.IntPtr instance);
            private static _hasBody_0Delegate _hasBody_0DelegateInstance;

            private static bool _hasBody_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (TypeAliasDecl) _References[instance].Target;
                var __ret = __target.hasBody();
                return __ret;
            }

            // void getNameForDiagnostic(raw_ostream &OS, const PrintingPolicy &Policy, bool Qualified) const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate void _getNameForDiagnostic_0Delegate(global::System.IntPtr instance, global::System.IntPtr OS, global::System.IntPtr Policy, bool Qualified);
            private static _getNameForDiagnostic_0Delegate _getNameForDiagnostic_0DelegateInstance;

            private static void _getNameForDiagnostic_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr OS, global::System.IntPtr Policy, bool Qualified)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (TypeAliasDecl) _References[instance].Target;
                llvm.raw_ostream __result0;
                if (OS == IntPtr.Zero) __result0 = null;
                else if (llvm.raw_ostream.NativeToManagedMap.ContainsKey(OS))
                    __result0 = (llvm.raw_ostream) llvm.raw_ostream.NativeToManagedMap[OS];
                else llvm.raw_ostream.NativeToManagedMap[OS] = __result0 = (llvm.raw_ostream) llvm.raw_ostream.__CreateInstance(OS);
                clang.PrintingPolicy __result1;
                if (Policy == IntPtr.Zero) __result1 = null;
                else if (clang.PrintingPolicy.NativeToManagedMap.ContainsKey(Policy))
                    __result1 = (clang.PrintingPolicy) clang.PrintingPolicy.NativeToManagedMap[Policy];
                else __result1 = clang.PrintingPolicy.__CreateInstance(Policy);
                __target.getNameForDiagnostic(__result0, __result1, Qualified);
            }

            private static void*[] _OldVTables;
            private static void*[] _NewVTables;
            private static void*[] _Thunks;
            private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

            void SetupVTables(global::System.IntPtr instance)
            {
                var native = (Internal*)instance.ToPointer();

                if (_References == null)
                    _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

                if (_References.ContainsKey(instance))
                    return;

                _References[instance] = new WeakReference(this);

                if (_OldVTables == null)
                {
                    _OldVTables = new void*[1];
                    _OldVTables[0] = native->vfptr0.ToPointer();
                }

                if (_Thunks == null)
                {
                    _Thunks = new void*[10];
                    _dtor_0DelegateInstance += _dtor_0DelegateHook;
                    _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                    _getSourceRange_0DelegateInstance += _getSourceRange_0DelegateHook;
                    _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_getSourceRange_0DelegateInstance).ToPointer();
                    _isOutOfLine_0DelegateInstance += _isOutOfLine_0DelegateHook;
                    _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_isOutOfLine_0DelegateInstance).ToPointer();
                    _getCanonicalDecl_0DelegateInstance += _getCanonicalDecl_0DelegateHook;
                    _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_getCanonicalDecl_0DelegateInstance).ToPointer();
                    _getNextRedeclarationImpl_0DelegateInstance += _getNextRedeclarationImpl_0DelegateHook;
                    _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_getNextRedeclarationImpl_0DelegateInstance).ToPointer();
                    _getPreviousDeclImpl_0DelegateInstance += _getPreviousDeclImpl_0DelegateHook;
                    _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_getPreviousDeclImpl_0DelegateInstance).ToPointer();
                    _getMostRecentDeclImpl_0DelegateInstance += _getMostRecentDeclImpl_0DelegateHook;
                    _Thunks[6] = Marshal.GetFunctionPointerForDelegate(_getMostRecentDeclImpl_0DelegateInstance).ToPointer();
                    _getBody_0DelegateInstance += _getBody_0DelegateHook;
                    _Thunks[7] = Marshal.GetFunctionPointerForDelegate(_getBody_0DelegateInstance).ToPointer();
                    _hasBody_0DelegateInstance += _hasBody_0DelegateHook;
                    _Thunks[8] = Marshal.GetFunctionPointerForDelegate(_hasBody_0DelegateInstance).ToPointer();
                    _getNameForDiagnostic_0DelegateInstance += _getNameForDiagnostic_0DelegateHook;
                    _Thunks[9] = Marshal.GetFunctionPointerForDelegate(_getNameForDiagnostic_0DelegateInstance).ToPointer();
                }

                if (_NewVTables == null)
                {
                    _NewVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(11 * 8);
                    _NewVTables[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + 8) = _Thunks[0];
                    *(void**)(vfptr0 + 16) = _Thunks[1];
                    *(void**)(vfptr0 + 24) = _Thunks[2];
                    *(void**)(vfptr0 + 32) = _Thunks[3];
                    *(void**)(vfptr0 + 40) = _Thunks[4];
                    *(void**)(vfptr0 + 48) = _Thunks[5];
                    *(void**)(vfptr0 + 56) = _Thunks[6];
                    *(void**)(vfptr0 + 64) = _Thunks[7];
                    *(void**)(vfptr0 + 72) = _Thunks[8];
                    *(void**)(vfptr0 + 80) = *(void**)(native->vfptr0 + 80);
                    *(void**)(vfptr0 + 88) = _Thunks[9];
                }

                native->vfptr0 = new IntPtr(_NewVTables[0]);
            }

            #endregion
        }

        /// <summary>
        /// <para>TagDecl - Represents the declaration of a
        /// struct/union/class/enum.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// TagDecl - Represents the declaration of a
        /// struct/union/class/enum.</para>
        /// </remarks>
        public unsafe partial class TagDecl : clang.TypeDecl, clang.DeclContext, clang.Redeclarable, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 112)]
            public new partial struct Internal
            {
                [FieldOffset(8)]
                internal llvm.PointerIntPair.Internal NextInContextAndBits;

                [FieldOffset(16)]
                internal llvm.PointerUnion.Internal DeclCtx;

                [FieldOffset(24)]
                public clang.SourceLocation.Internal Loc;

                [FieldOffset(28)]
                public uint DeclKind;

                [FieldOffset(29)]
                public uint InvalidDecl;

                [FieldOffset(29)]
                public uint HasAttrs;

                [FieldOffset(29)]
                public uint Implicit;

                [FieldOffset(29)]
                public uint Used;

                [FieldOffset(29)]
                public uint Referenced;

                [FieldOffset(29)]
                public uint Access;

                [FieldOffset(29)]
                public uint FromASTFile;

                [FieldOffset(30)]
                public uint Hidden;

                [FieldOffset(30)]
                public uint IdentifierNamespace;

                [FieldOffset(31)]
                public uint CacheValidAndLinkage;

                [FieldOffset(32)]
                public clang.DeclarationName.Internal Name;

                [FieldOffset(40)]
                public global::System.IntPtr TypeForDecl;

                [FieldOffset(48)]
                public clang.SourceLocation.Internal LocStart;

                [FieldOffset(0)]
                public uint DeclKind;

                [FieldOffset(1)]
                public bool ExternalLexicalStorage;

                [FieldOffset(1)]
                public bool ExternalVisibleStorage;

                [FieldOffset(1)]
                public bool NeedToReconcileExternalVisibleStorage;

                [FieldOffset(8)]
                internal llvm.PointerIntPair.Internal LookupPtr;

                [FieldOffset(16)]
                public global::System.IntPtr FirstDecl;

                [FieldOffset(24)]
                public global::System.IntPtr LastDecl;

                [FieldOffset(96)]
                public uint TagDeclKind;

                [FieldOffset(96)]
                public bool IsCompleteDefinition;

                [FieldOffset(96)]
                public bool IsBeingDefined;

                [FieldOffset(96)]
                public bool IsEmbeddedInDeclarator;

                [FieldOffset(96)]
                public bool IsFreeStanding;

                [FieldOffset(96)]
                public uint NumPositiveBits;

                [FieldOffset(97)]
                public uint NumNegativeBits;

                [FieldOffset(98)]
                public bool IsScoped;

                [FieldOffset(99)]
                public bool IsScopedUsingClassTag;

                [FieldOffset(99)]
                public bool IsFixed;

                [FieldOffset(99)]
                public bool MayHaveOutOfDateDef;

                [FieldOffset(99)]
                public bool IsCompleteDefinitionRequired;

                [FieldOffset(100)]
                public clang.SourceLocation.Internal RBraceLoc;

                [FieldOffset(104)]
                internal llvm.PointerUnion.Internal NamedDeclOrQualifier;

                [FieldOffset(0)]
                public global::System.IntPtr vfptr0;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang7TagDeclC2ENS_4Decl4KindENS_11TagTypeKindERKNS_10ASTContextEPNS_11DeclContextENS_14SourceLocationEPNS_14IdentifierInfoEPS0_S9_")]
                internal static extern void ctor_0(global::System.IntPtr instance, clang.Decl.Kind DK, clang.TagTypeKind TK, global::System.IntPtr C, global::System.IntPtr DC, clang.SourceLocation.Internal L, global::System.IntPtr Id, global::System.IntPtr PrevDecl, clang.SourceLocation.Internal StartL);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang7TagDeclC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang7TagDeclD2Ev")]
                internal static extern void dtor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang7TagDecl24getNextRedeclarationImplEv")]
                internal static extern global::System.IntPtr getNextRedeclarationImpl_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang7TagDecl19getPreviousDeclImplEv")]
                internal static extern global::System.IntPtr getPreviousDeclImpl_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang7TagDecl21getMostRecentDeclImplEv")]
                internal static extern global::System.IntPtr getMostRecentDeclImpl_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang7TagDecl18completeDefinitionEv")]
                internal static extern void completeDefinition_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7TagDecl12getRBraceLocEv")]
                internal static extern clang.SourceLocation.Internal getRBraceLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang7TagDecl12setRBraceLocENS_14SourceLocationE")]
                internal static extern void setRBraceLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal L);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7TagDecl16getInnerLocStartEv")]
                internal static extern clang.SourceLocation.Internal getInnerLocStart_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7TagDecl16getOuterLocStartEv")]
                internal static extern clang.SourceLocation.Internal getOuterLocStart_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7TagDecl14getSourceRangeEv")]
                internal static extern clang.SourceRange.Internal getSourceRange_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang7TagDecl16getCanonicalDeclEv")]
                internal static extern global::System.IntPtr getCanonicalDecl_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7TagDecl28isThisDeclarationADefinitionEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isThisDeclarationADefinition_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7TagDecl20isCompleteDefinitionEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isCompleteDefinition_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7TagDecl28isCompleteDefinitionRequiredEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isCompleteDefinitionRequired_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7TagDecl14isBeingDefinedEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isBeingDefined_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7TagDecl22isEmbeddedInDeclaratorEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isEmbeddedInDeclarator_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang7TagDecl23setEmbeddedInDeclaratorEb")]
                internal static extern void setEmbeddedInDeclarator_0(global::System.IntPtr instance, bool isInDeclarator);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7TagDecl14isFreeStandingEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isFreeStanding_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang7TagDecl15setFreeStandingEb")]
                internal static extern void setFreeStanding_0(global::System.IntPtr instance, bool isFreeStanding);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7TagDecl15isDependentTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isDependentType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang7TagDecl15startDefinitionEv")]
                internal static extern void startDefinition_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7TagDecl13getDefinitionEv")]
                internal static extern global::System.IntPtr getDefinition_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang7TagDecl21setCompleteDefinitionEb")]
                internal static extern void setCompleteDefinition_0(global::System.IntPtr instance, bool V);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang7TagDecl29setCompleteDefinitionRequiredEb")]
                internal static extern void setCompleteDefinitionRequired_0(global::System.IntPtr instance, bool V);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7TagDecl11getKindNameEv")]
                internal static extern llvm.StringRef.Internal getKindName_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7TagDecl10getTagKindEv")]
                internal static extern clang.TagTypeKind getTagKind_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang7TagDecl10setTagKindENS_11TagTypeKindE")]
                internal static extern void setTagKind_0(global::System.IntPtr instance, clang.TagTypeKind TK);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7TagDecl8isStructEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isStruct_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7TagDecl11isInterfaceEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isInterface_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7TagDecl7isClassEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isClass_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7TagDecl7isUnionEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isUnion_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7TagDecl6isEnumEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isEnum_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7TagDecl17hasNameForLinkageEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasNameForLinkage_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7TagDecl24hasDeclaratorForAnonDeclEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasDeclaratorForAnonDecl_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7TagDecl24getDeclaratorForAnonDeclEv")]
                internal static extern global::System.IntPtr getDeclaratorForAnonDecl_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7TagDecl25getTypedefNameForAnonDeclEv")]
                internal static extern global::System.IntPtr getTypedefNameForAnonDecl_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang7TagDecl24setDeclaratorForAnonDeclEPNS_14DeclaratorDeclE")]
                internal static extern void setDeclaratorForAnonDecl_0(global::System.IntPtr instance, global::System.IntPtr DD);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang7TagDecl25setTypedefNameForAnonDeclEPNS_15TypedefNameDeclE")]
                internal static extern void setTypedefNameForAnonDecl_0(global::System.IntPtr instance, global::System.IntPtr TDD);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7TagDecl12getQualifierEv")]
                internal static extern global::System.IntPtr getQualifier_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7TagDecl15getQualifierLocEv")]
                internal static extern clang.NestedNameSpecifierLoc.Internal getQualifierLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang7TagDecl16setQualifierInfoENS_22NestedNameSpecifierLocE")]
                internal static extern void setQualifierInfo_0(global::System.IntPtr instance, clang.NestedNameSpecifierLoc.Internal QualifierLoc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang7TagDecl28getNumTemplateParameterListsEv")]
                internal static extern uint getNumTemplateParameterLists_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang7TagDecl7classofEPKNS_4DeclE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr D);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang7TagDecl11classofKindENS_4Decl4KindE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classofKind_0(clang.Decl.Kind K);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang7TagDecl17castToDeclContextEPKS0_")]
                internal static extern global::System.IntPtr castToDeclContext_0(global::System.IntPtr D);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang7TagDecl19castFromDeclContextEPKNS_11DeclContextE")]
                internal static extern global::System.IntPtr castFromDeclContext_0(global::System.IntPtr DC);
            }

            private readonly bool __ownsNativeInstance;

            public static new TagDecl __CreateInstance(global::System.IntPtr native)
            {
                return new TagDecl((TagDecl.Internal*) native);
            }

            public static TagDecl __CreateInstance(TagDecl.Internal native)
            {
                return new TagDecl(native);
            }

            private static TagDecl.Internal* __CopyValue(TagDecl.Internal native)
            {
                var ret = (TagDecl.Internal*) Marshal.AllocHGlobal(112);
                *ret = native;
                return ret;
            }

            private TagDecl(TagDecl.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected TagDecl(TagDecl.Internal* native, bool isInternalImpl = false)
                : base((clang.TypeDecl.Internal*) native)
            {
            }

            protected TagDecl(clang.Decl.Kind DK, clang.TagTypeKind TK, clang.ASTContext C, clang.DeclContext DC, clang.SourceLocation L, clang.IdentifierInfo Id, clang.TagDecl PrevDecl, clang.SourceLocation StartL)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(112);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = DK;
                var arg1 = TK;
                var arg2 = ReferenceEquals(C, null) ? global::System.IntPtr.Zero : C.__Instance;
                var arg3 = ReferenceEquals(DC, null) ? global::System.IntPtr.Zero : DC.__Instance;
                var arg4 = ReferenceEquals(L, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (L.__Instance);
                var arg5 = ReferenceEquals(Id, null) ? global::System.IntPtr.Zero : Id.__Instance;
                var arg6 = ReferenceEquals(PrevDecl, null) ? global::System.IntPtr.Zero : PrevDecl.__Instance;
                var arg7 = ReferenceEquals(StartL, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (StartL.__Instance);
                Internal.ctor_0(__Instance, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
                SetupVTables(__Instance);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Decl __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            protected virtual clang.TagDecl getNextRedeclarationImpl()
            {
                var __ret = Internal.getNextRedeclarationImpl_0(__Instance);
                clang.TagDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.TagDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.TagDecl) clang.TagDecl.NativeToManagedMap[__ret];
                else clang.TagDecl.NativeToManagedMap[__ret] = __result0 = (clang.TagDecl) clang.TagDecl.__CreateInstance(__ret);
                return __result0;
            }

            protected virtual clang.TagDecl getPreviousDeclImpl()
            {
                var __ret = Internal.getPreviousDeclImpl_0(__Instance);
                clang.TagDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.TagDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.TagDecl) clang.TagDecl.NativeToManagedMap[__ret];
                else clang.TagDecl.NativeToManagedMap[__ret] = __result0 = (clang.TagDecl) clang.TagDecl.__CreateInstance(__ret);
                return __result0;
            }

            protected virtual clang.TagDecl getMostRecentDeclImpl()
            {
                var __ret = Internal.getMostRecentDeclImpl_0(__Instance);
                clang.TagDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.TagDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.TagDecl) clang.TagDecl.NativeToManagedMap[__ret];
                else clang.TagDecl.NativeToManagedMap[__ret] = __result0 = (clang.TagDecl) clang.TagDecl.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Completes the definition of this tag declaration.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// @brief Completes the definition of this tag
            /// declaration.</para>
            /// <para>  ///</para>
            /// <para>  /// This is a helper function for derived classes.</para>
            /// </remarks>
            protected void completeDefinition()
            {
                Internal.completeDefinition_0(__Instance);
            }

            public clang.SourceLocation getRBraceLoc()
            {
                var __ret = Internal.getRBraceLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setRBraceLoc(clang.SourceLocation L)
            {
                var arg0 = ReferenceEquals(L, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (L.__Instance);
                Internal.setRBraceLoc_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>getInnerLocStart - Return SourceLocation representing start of
            /// source range ignoring outer template declarations.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getInnerLocStart - Return SourceLocation representing start
            /// of source</para>
            /// <para>  /// range ignoring outer template declarations.</para>
            /// </remarks>
            public clang.SourceLocation getInnerLocStart()
            {
                var __ret = Internal.getInnerLocStart_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>getOuterLocStart - Return SourceLocation representing start of
            /// source range taking into account any outer template declarations.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getOuterLocStart - Return SourceLocation representing start
            /// of source</para>
            /// <para>  /// range taking into account any outer template
            /// declarations.</para>
            /// </remarks>
            public clang.SourceLocation getOuterLocStart()
            {
                var __ret = Internal.getOuterLocStart_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public override clang.SourceRange getSourceRange()
            {
                var __ret = Internal.getSourceRange_0(__Instance);
                return clang.SourceRange.__CreateInstance(__ret);
            }

            public virtual clang.TagDecl getCanonicalDecl()
            {
                var __ret = Internal.getCanonicalDecl_0(__Instance);
                clang.TagDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.TagDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.TagDecl) clang.TagDecl.NativeToManagedMap[__ret];
                else clang.TagDecl.NativeToManagedMap[__ret] = __result0 = (clang.TagDecl) clang.TagDecl.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>isThisDeclarationADefinition() - Return true if this declaration
            /// is a completion definition of the type. Provided for consistency.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// isThisDeclarationADefinition() - Return true if this
            /// declaration</para>
            /// <para>  /// is a completion definition of the type.  Provided for
            /// consistency.</para>
            /// </remarks>
            public bool isThisDeclarationADefinition()
            {
                var __ret = Internal.isThisDeclarationADefinition_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>isCompleteDefinition - Return true if this decl has its body
            /// fully specified.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// isCompleteDefinition - Return true if this decl has its
            /// body</para>
            /// <para>  /// fully specified.</para>
            /// </remarks>
            public bool isCompleteDefinition()
            {
                var __ret = Internal.isCompleteDefinition_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Return true if this complete decl is required to be complete for
            /// some existing use.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return true if this complete decl is</para>
            /// <para>  /// required to be complete for some existing use.</para>
            /// </remarks>
            public bool isCompleteDefinitionRequired()
            {
                var __ret = Internal.isCompleteDefinitionRequired_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>isBeingDefined - Return true if this decl is currently being
            /// defined.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// isBeingDefined - Return true if this decl is currently being
            /// defined.</para>
            /// </remarks>
            public bool isBeingDefined()
            {
                var __ret = Internal.isBeingDefined_0(__Instance);
                return __ret;
            }

            public bool isEmbeddedInDeclarator()
            {
                var __ret = Internal.isEmbeddedInDeclarator_0(__Instance);
                return __ret;
            }

            public void setEmbeddedInDeclarator(bool isInDeclarator)
            {
                Internal.setEmbeddedInDeclarator_0(__Instance, isInDeclarator);
            }

            public bool isFreeStanding()
            {
                var __ret = Internal.isFreeStanding_0(__Instance);
                return __ret;
            }

            public void setFreeStanding(bool isFreeStanding)
            {
                Internal.setFreeStanding_0(__Instance, isFreeStanding);
            }

            /// <summary>
            /// <para>Whether this declaration declares a type that is dependent, i.e.,
            /// a type that somehow depends on template parameters.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Whether this declaration declares a type that
            /// is</para>
            /// <para>  /// dependent, i.e., a type that somehow depends on
            /// template</para>
            /// <para>  /// parameters.</para>
            /// </remarks>
            public bool isDependentType()
            {
                var __ret = Internal.isDependentType_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Starts the definition of this tag declaration.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// @brief Starts the definition of this tag declaration.</para>
            /// <para>  ///</para>
            /// <para>  /// This method should be invoked at the beginning of the
            /// definition</para>
            /// <para>  /// of this tag declaration. It will set the tag type into a
            /// state</para>
            /// <para>  /// where it is in the process of being defined.</para>
            /// </remarks>
            public void startDefinition()
            {
                Internal.startDefinition_0(__Instance);
            }

            /// <summary>
            /// <para>getDefinition - Returns the TagDecl that actually defines this
            /// struct/union/class/enum. When determining whether or not a
            /// struct/union/class/enum has a definition, one should use this method as
            /// opposed to 'isDefinition'. 'isDefinition' indicates whether or not a
            /// specific TagDecl is defining declaration, not whether or not the
            /// struct/union/class/enum type is defined. This method returns NULL if there
            /// is no TagDecl that defines the struct/union/class/enum.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getDefinition - Returns the TagDecl that actually defines
            /// this</para>
            /// <para>  ///  struct/union/class/enum.  When determining whether or not
            /// a</para>
            /// <para>  ///  struct/union/class/enum has a definition, one should use
            /// this</para>
            /// <para>  ///  method as opposed to 'isDefinition'.  'isDefinition'
            /// indicates</para>
            /// <para>  ///  whether or not a specific TagDecl is defining declaration,
            /// not</para>
            /// <para>  ///  whether or not the struct/union/class/enum type is
            /// defined.</para>
            /// <para>  ///  This method returns NULL if there is no TagDecl that
            /// defines</para>
            /// <para>  ///  the struct/union/class/enum.</para>
            /// </remarks>
            public clang.TagDecl getDefinition()
            {
                var __ret = Internal.getDefinition_0(__Instance);
                clang.TagDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.TagDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.TagDecl) clang.TagDecl.NativeToManagedMap[__ret];
                else clang.TagDecl.NativeToManagedMap[__ret] = __result0 = (clang.TagDecl) clang.TagDecl.__CreateInstance(__ret);
                return __result0;
            }

            public void setCompleteDefinition(bool V)
            {
                Internal.setCompleteDefinition_0(__Instance, V);
            }

            public void setCompleteDefinitionRequired(bool V)
            {
                Internal.setCompleteDefinitionRequired_0(__Instance, V);
            }

            public llvm.StringRef getKindName()
            {
                var __ret = Internal.getKindName_0(__Instance);
                return llvm.StringRef.__CreateInstance(__ret);
            }

            public clang.TagTypeKind getTagKind()
            {
                var __ret = Internal.getTagKind_0(__Instance);
                return __ret;
            }

            public void setTagKind(clang.TagTypeKind TK)
            {
                var arg0 = TK;
                Internal.setTagKind_0(__Instance, arg0);
            }

            public bool isStruct()
            {
                var __ret = Internal.isStruct_0(__Instance);
                return __ret;
            }

            public bool isInterface()
            {
                var __ret = Internal.isInterface_0(__Instance);
                return __ret;
            }

            public bool isClass()
            {
                var __ret = Internal.isClass_0(__Instance);
                return __ret;
            }

            public bool isUnion()
            {
                var __ret = Internal.isUnion_0(__Instance);
                return __ret;
            }

            public bool isEnum()
            {
                var __ret = Internal.isEnum_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Is this tag type named, either directly or via being defined in a
            /// typedef of this type?</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Is this tag type named, either directly or via being defined
            /// in</para>
            /// <para>  /// a typedef of this type?</para>
            /// <para>  ///</para>
            /// <para>  /// C++11 [basic.link]p8:</para>
            /// <para>  ///   A type is said to have linkage if and only if:</para>
            /// <para>  ///     - it is a class or enumeration type that is named (or
            /// has a</para>
            /// <para>  ///       name for linkage purposes) and the name has linkage;
            /// ...</para>
            /// <para>  /// C++11 [dcl.typedef]p9:</para>
            /// <para>  ///   If the typedef declaration defines an unnamed class (or
            /// enum),</para>
            /// <para>  ///   the first typedef-name declared by the declaration to be
            /// that</para>
            /// <para>  ///   class type (or enum type) is used to denote the class
            /// type (or</para>
            /// <para>  ///   enum type) for linkage purposes only.</para>
            /// <para>  ///</para>
            /// <para>  /// C does not have an analogous rule, but the same concept
            /// is</para>
            /// <para>  /// nonetheless useful in some places.</para>
            /// </remarks>
            public bool hasNameForLinkage()
            {
                var __ret = Internal.hasNameForLinkage_0(__Instance);
                return __ret;
            }

            public bool hasDeclaratorForAnonDecl()
            {
                var __ret = Internal.hasDeclaratorForAnonDecl_0(__Instance);
                return __ret;
            }

            public clang.DeclaratorDecl getDeclaratorForAnonDecl()
            {
                var __ret = Internal.getDeclaratorForAnonDecl_0(__Instance);
                clang.DeclaratorDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.DeclaratorDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.DeclaratorDecl) clang.DeclaratorDecl.NativeToManagedMap[__ret];
                else clang.DeclaratorDecl.NativeToManagedMap[__ret] = __result0 = (clang.DeclaratorDecl) clang.DeclaratorDecl.__CreateInstance(__ret);
                return __result0;
            }

            public clang.TypedefNameDecl getTypedefNameForAnonDecl()
            {
                var __ret = Internal.getTypedefNameForAnonDecl_0(__Instance);
                clang.TypedefNameDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.TypedefNameDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.TypedefNameDecl) clang.TypedefNameDecl.NativeToManagedMap[__ret];
                else clang.TypedefNameDecl.NativeToManagedMap[__ret] = __result0 = (clang.TypedefNameDecl) clang.TypedefNameDecl.__CreateInstance(__ret);
                return __result0;
            }

            public void setDeclaratorForAnonDecl(clang.DeclaratorDecl DD)
            {
                var arg0 = ReferenceEquals(DD, null) ? global::System.IntPtr.Zero : DD.__Instance;
                Internal.setDeclaratorForAnonDecl_0(__Instance, arg0);
            }

            public void setTypedefNameForAnonDecl(clang.TypedefNameDecl TDD)
            {
                var arg0 = ReferenceEquals(TDD, null) ? global::System.IntPtr.Zero : TDD.__Instance;
                Internal.setTypedefNameForAnonDecl_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>Retrieve the nested-name-specifier that qualifies the name of
            /// this declaration, if it was present in the source.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the nested-name-specifier that qualifies the
            /// name of this</para>
            /// <para>  /// declaration, if it was present in the source.</para>
            /// </remarks>
            public clang.NestedNameSpecifier getQualifier()
            {
                var __ret = Internal.getQualifier_0(__Instance);
                clang.NestedNameSpecifier __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.NestedNameSpecifier.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.NestedNameSpecifier) clang.NestedNameSpecifier.NativeToManagedMap[__ret];
                else __result0 = clang.NestedNameSpecifier.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Retrieve the nested-name-specifier (with source-location
            /// information) that qualifies the name of this declaration, if it was present
            /// in the source.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the nested-name-specifier (with
            /// source-location</para>
            /// <para>  /// information) that qualifies the name of this declaration,
            /// if it was</para>
            /// <para>  /// present in the source.</para>
            /// </remarks>
            public clang.NestedNameSpecifierLoc getQualifierLoc()
            {
                var __ret = Internal.getQualifierLoc_0(__Instance);
                return clang.NestedNameSpecifierLoc.__CreateInstance(__ret);
            }

            public void setQualifierInfo(clang.NestedNameSpecifierLoc QualifierLoc)
            {
                var arg0 = ReferenceEquals(QualifierLoc, null) ? new clang.NestedNameSpecifierLoc.Internal() : *(clang.NestedNameSpecifierLoc.Internal*) (QualifierLoc.__Instance);
                Internal.setQualifierInfo_0(__Instance, arg0);
            }

            public uint getNumTemplateParameterLists()
            {
                var __ret = Internal.getNumTemplateParameterLists_0(__Instance);
                return __ret;
            }

            public static bool classof(clang.Decl D)
            {
                var arg0 = ReferenceEquals(D, null) ? global::System.IntPtr.Zero : D.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }

            public static bool classofKind(clang.Decl.Kind K)
            {
                var arg0 = K;
                var __ret = Internal.classofKind_0(arg0);
                return __ret;
            }

            public static clang.DeclContext castToDeclContext(clang.TagDecl D)
            {
                var arg0 = ReferenceEquals(D, null) ? global::System.IntPtr.Zero : D.__Instance;
                var __ret = Internal.castToDeclContext_0(arg0);
                clang.DeclContext __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.DeclContext.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.DeclContext) clang.DeclContext.NativeToManagedMap[__ret];
                else __result0 = clang.DeclContext.__CreateInstance(__ret);
                return __result0;
            }

            public static clang.TagDecl castFromDeclContext(clang.DeclContext DC)
            {
                var arg0 = ReferenceEquals(DC, null) ? global::System.IntPtr.Zero : DC.__Instance;
                var __ret = Internal.castFromDeclContext_0(arg0);
                clang.TagDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.TagDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.TagDecl) clang.TagDecl.NativeToManagedMap[__ret];
                else clang.TagDecl.NativeToManagedMap[__ret] = __result0 = (clang.TagDecl) clang.TagDecl.__CreateInstance(__ret);
                return __result0;
            }

            protected bool IsBeingDefined
            {
                get
                {
                    return ((Internal*) __Instance)->IsBeingDefined;
                }

                set
                {
                    ((Internal*) __Instance)->IsBeingDefined = value;
                }
            }

            protected uint NumPositiveBits
            {
                get
                {
                    return ((Internal*) __Instance)->NumPositiveBits;
                }

                set
                {
                    ((Internal*) __Instance)->NumPositiveBits = value;
                }
            }

            protected uint NumNegativeBits
            {
                get
                {
                    return ((Internal*) __Instance)->NumNegativeBits;
                }

                set
                {
                    ((Internal*) __Instance)->NumNegativeBits = value;
                }
            }

            protected bool IsScoped
            {
                get
                {
                    return ((Internal*) __Instance)->IsScoped;
                }

                set
                {
                    ((Internal*) __Instance)->IsScoped = value;
                }
            }

            protected bool IsScopedUsingClassTag
            {
                get
                {
                    return ((Internal*) __Instance)->IsScopedUsingClassTag;
                }

                set
                {
                    ((Internal*) __Instance)->IsScopedUsingClassTag = value;
                }
            }

            protected bool IsFixed
            {
                get
                {
                    return ((Internal*) __Instance)->IsFixed;
                }

                set
                {
                    ((Internal*) __Instance)->IsFixed = value;
                }
            }

            protected bool MayHaveOutOfDateDef
            {
                get
                {
                    return ((Internal*) __Instance)->MayHaveOutOfDateDef;
                }

                set
                {
                    ((Internal*) __Instance)->MayHaveOutOfDateDef = value;
                }
            }

            protected bool IsCompleteDefinitionRequired
            {
                get
                {
                    return ((Internal*) __Instance)->IsCompleteDefinitionRequired;
                }

                set
                {
                    ((Internal*) __Instance)->IsCompleteDefinitionRequired = value;
                }
            }

            #region Virtual table interop

            // TagDecl
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
            private static _dtor_0Delegate _dtor_0DelegateInstance;

            private static void _dtor_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (TagDecl) _References[instance].Target;
                __target.DestroyNativeInstance();
            }

            // SourceRange getSourceRange() const override
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate clang.SourceRange.Internal _getSourceRange_0Delegate(global::System.IntPtr instance);
            private static _getSourceRange_0Delegate _getSourceRange_0DelegateInstance;

            private static clang.SourceRange.Internal _getSourceRange_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (TagDecl) _References[instance].Target;
                var __ret = __target.getSourceRange();
                return ReferenceEquals(__ret, null) ? new clang.SourceRange.Internal() : *(clang.SourceRange.Internal*) (__ret.__Instance);
            }

            // bool isOutOfLine() const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate bool _isOutOfLine_0Delegate(global::System.IntPtr instance);
            private static _isOutOfLine_0Delegate _isOutOfLine_0DelegateInstance;

            private static bool _isOutOfLine_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (TagDecl) _References[instance].Target;
                var __ret = __target.isOutOfLine();
                return __ret;
            }

            // TagDecl *getCanonicalDecl() override
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getCanonicalDecl_0Delegate(global::System.IntPtr instance);
            private static _getCanonicalDecl_0Delegate _getCanonicalDecl_0DelegateInstance;

            private static global::System.IntPtr _getCanonicalDecl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (TagDecl) _References[instance].Target;
                var __ret = __target.getCanonicalDecl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // TagDecl *getNextRedeclarationImpl() override
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getNextRedeclarationImpl_0Delegate(global::System.IntPtr instance);
            private static _getNextRedeclarationImpl_0Delegate _getNextRedeclarationImpl_0DelegateInstance;

            private static global::System.IntPtr _getNextRedeclarationImpl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (TagDecl) _References[instance].Target;
                var __ret = __target.getNextRedeclarationImpl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // TagDecl *getPreviousDeclImpl() override
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getPreviousDeclImpl_0Delegate(global::System.IntPtr instance);
            private static _getPreviousDeclImpl_0Delegate _getPreviousDeclImpl_0DelegateInstance;

            private static global::System.IntPtr _getPreviousDeclImpl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (TagDecl) _References[instance].Target;
                var __ret = __target.getPreviousDeclImpl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // TagDecl *getMostRecentDeclImpl() override
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getMostRecentDeclImpl_0Delegate(global::System.IntPtr instance);
            private static _getMostRecentDeclImpl_0Delegate _getMostRecentDeclImpl_0DelegateInstance;

            private static global::System.IntPtr _getMostRecentDeclImpl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (TagDecl) _References[instance].Target;
                var __ret = __target.getMostRecentDeclImpl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // Stmt* getBody() const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getBody_0Delegate(global::System.IntPtr instance);
            private static _getBody_0Delegate _getBody_0DelegateInstance;

            private static global::System.IntPtr _getBody_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (TagDecl) _References[instance].Target;
                var __ret = __target.getBody();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // bool hasBody() const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate bool _hasBody_0Delegate(global::System.IntPtr instance);
            private static _hasBody_0Delegate _hasBody_0DelegateInstance;

            private static bool _hasBody_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (TagDecl) _References[instance].Target;
                var __ret = __target.hasBody();
                return __ret;
            }

            // void getNameForDiagnostic(raw_ostream &OS, const PrintingPolicy &Policy, bool Qualified) const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate void _getNameForDiagnostic_0Delegate(global::System.IntPtr instance, global::System.IntPtr OS, global::System.IntPtr Policy, bool Qualified);
            private static _getNameForDiagnostic_0Delegate _getNameForDiagnostic_0DelegateInstance;

            private static void _getNameForDiagnostic_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr OS, global::System.IntPtr Policy, bool Qualified)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (TagDecl) _References[instance].Target;
                llvm.raw_ostream __result0;
                if (OS == IntPtr.Zero) __result0 = null;
                else if (llvm.raw_ostream.NativeToManagedMap.ContainsKey(OS))
                    __result0 = (llvm.raw_ostream) llvm.raw_ostream.NativeToManagedMap[OS];
                else llvm.raw_ostream.NativeToManagedMap[OS] = __result0 = (llvm.raw_ostream) llvm.raw_ostream.__CreateInstance(OS);
                clang.PrintingPolicy __result1;
                if (Policy == IntPtr.Zero) __result1 = null;
                else if (clang.PrintingPolicy.NativeToManagedMap.ContainsKey(Policy))
                    __result1 = (clang.PrintingPolicy) clang.PrintingPolicy.NativeToManagedMap[Policy];
                else __result1 = clang.PrintingPolicy.__CreateInstance(Policy);
                __target.getNameForDiagnostic(__result0, __result1, Qualified);
            }

            private static void*[] _OldVTables;
            private static void*[] _NewVTables;
            private static void*[] _Thunks;
            private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

            void SetupVTables(global::System.IntPtr instance)
            {
                var native = (Internal*)instance.ToPointer();

                if (_References == null)
                    _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

                if (_References.ContainsKey(instance))
                    return;

                _References[instance] = new WeakReference(this);

                if (_OldVTables == null)
                {
                    _OldVTables = new void*[1];
                    _OldVTables[0] = native->vfptr0.ToPointer();
                }

                if (_Thunks == null)
                {
                    _Thunks = new void*[10];
                    _dtor_0DelegateInstance += _dtor_0DelegateHook;
                    _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                    _getSourceRange_0DelegateInstance += _getSourceRange_0DelegateHook;
                    _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_getSourceRange_0DelegateInstance).ToPointer();
                    _isOutOfLine_0DelegateInstance += _isOutOfLine_0DelegateHook;
                    _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_isOutOfLine_0DelegateInstance).ToPointer();
                    _getCanonicalDecl_0DelegateInstance += _getCanonicalDecl_0DelegateHook;
                    _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_getCanonicalDecl_0DelegateInstance).ToPointer();
                    _getNextRedeclarationImpl_0DelegateInstance += _getNextRedeclarationImpl_0DelegateHook;
                    _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_getNextRedeclarationImpl_0DelegateInstance).ToPointer();
                    _getPreviousDeclImpl_0DelegateInstance += _getPreviousDeclImpl_0DelegateHook;
                    _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_getPreviousDeclImpl_0DelegateInstance).ToPointer();
                    _getMostRecentDeclImpl_0DelegateInstance += _getMostRecentDeclImpl_0DelegateHook;
                    _Thunks[6] = Marshal.GetFunctionPointerForDelegate(_getMostRecentDeclImpl_0DelegateInstance).ToPointer();
                    _getBody_0DelegateInstance += _getBody_0DelegateHook;
                    _Thunks[7] = Marshal.GetFunctionPointerForDelegate(_getBody_0DelegateInstance).ToPointer();
                    _hasBody_0DelegateInstance += _hasBody_0DelegateHook;
                    _Thunks[8] = Marshal.GetFunctionPointerForDelegate(_hasBody_0DelegateInstance).ToPointer();
                    _getNameForDiagnostic_0DelegateInstance += _getNameForDiagnostic_0DelegateHook;
                    _Thunks[9] = Marshal.GetFunctionPointerForDelegate(_getNameForDiagnostic_0DelegateInstance).ToPointer();
                }

                if (_NewVTables == null)
                {
                    _NewVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(11 * 8);
                    _NewVTables[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + 8) = _Thunks[0];
                    *(void**)(vfptr0 + 16) = _Thunks[1];
                    *(void**)(vfptr0 + 24) = _Thunks[2];
                    *(void**)(vfptr0 + 32) = _Thunks[3];
                    *(void**)(vfptr0 + 40) = _Thunks[4];
                    *(void**)(vfptr0 + 48) = _Thunks[5];
                    *(void**)(vfptr0 + 56) = _Thunks[6];
                    *(void**)(vfptr0 + 64) = _Thunks[7];
                    *(void**)(vfptr0 + 72) = _Thunks[8];
                    *(void**)(vfptr0 + 80) = *(void**)(native->vfptr0 + 80);
                    *(void**)(vfptr0 + 88) = _Thunks[9];
                }

                native->vfptr0 = new IntPtr(_NewVTables[0]);
            }

            #endregion
        }

        /// <summary>
        /// <para>EnumDecl - Represents an enum. In C++11, enums can be
        /// forward-declared with a fixed underlying type, and in C we allow them to be
        /// forward-declared with no underlying type as an extension.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// EnumDecl - Represents an enum.  In C++11, enums can be
        /// forward-declared</para>
        /// <para>/// with a fixed underlying type, and in C we allow them to be
        /// forward-declared</para>
        /// <para>/// with no underlying type as an extension.</para>
        /// </remarks>
        public unsafe partial class EnumDecl : clang.TagDecl, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 136)]
            public new partial struct Internal
            {
                [FieldOffset(8)]
                internal llvm.PointerIntPair.Internal NextInContextAndBits;

                [FieldOffset(16)]
                internal llvm.PointerUnion.Internal DeclCtx;

                [FieldOffset(24)]
                public clang.SourceLocation.Internal Loc;

                [FieldOffset(28)]
                public uint DeclKind;

                [FieldOffset(29)]
                public uint InvalidDecl;

                [FieldOffset(29)]
                public uint HasAttrs;

                [FieldOffset(29)]
                public uint Implicit;

                [FieldOffset(29)]
                public uint Used;

                [FieldOffset(29)]
                public uint Referenced;

                [FieldOffset(29)]
                public uint Access;

                [FieldOffset(29)]
                public uint FromASTFile;

                [FieldOffset(30)]
                public uint Hidden;

                [FieldOffset(30)]
                public uint IdentifierNamespace;

                [FieldOffset(31)]
                public uint CacheValidAndLinkage;

                [FieldOffset(32)]
                public clang.DeclarationName.Internal Name;

                [FieldOffset(40)]
                public global::System.IntPtr TypeForDecl;

                [FieldOffset(48)]
                public clang.SourceLocation.Internal LocStart;

                [FieldOffset(0)]
                public uint DeclKind;

                [FieldOffset(1)]
                public bool ExternalLexicalStorage;

                [FieldOffset(1)]
                public bool ExternalVisibleStorage;

                [FieldOffset(1)]
                public bool NeedToReconcileExternalVisibleStorage;

                [FieldOffset(8)]
                internal llvm.PointerIntPair.Internal LookupPtr;

                [FieldOffset(16)]
                public global::System.IntPtr FirstDecl;

                [FieldOffset(24)]
                public global::System.IntPtr LastDecl;

                [FieldOffset(96)]
                public uint TagDeclKind;

                [FieldOffset(96)]
                public bool IsCompleteDefinition;

                [FieldOffset(96)]
                public bool IsBeingDefined;

                [FieldOffset(96)]
                public bool IsEmbeddedInDeclarator;

                [FieldOffset(96)]
                public bool IsFreeStanding;

                [FieldOffset(96)]
                public uint NumPositiveBits;

                [FieldOffset(97)]
                public uint NumNegativeBits;

                [FieldOffset(98)]
                public bool IsScoped;

                [FieldOffset(99)]
                public bool IsScopedUsingClassTag;

                [FieldOffset(99)]
                public bool IsFixed;

                [FieldOffset(99)]
                public bool MayHaveOutOfDateDef;

                [FieldOffset(99)]
                public bool IsCompleteDefinitionRequired;

                [FieldOffset(100)]
                public clang.SourceLocation.Internal RBraceLoc;

                [FieldOffset(104)]
                internal llvm.PointerUnion.Internal NamedDeclOrQualifier;

                [FieldOffset(112)]
                internal llvm.PointerUnion.Internal IntegerType;

                [FieldOffset(120)]
                public clang.QualType.Internal PromotionType;

                [FieldOffset(128)]
                public global::System.IntPtr SpecializationInfo;

                [FieldOffset(0)]
                public global::System.IntPtr vfptr0;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8EnumDeclC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8EnumDeclD2Ev")]
                internal static extern void dtor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8EnumDecl16getCanonicalDeclEv")]
                internal static extern global::System.IntPtr getCanonicalDecl_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8EnumDecl15getPreviousDeclEv")]
                internal static extern global::System.IntPtr getPreviousDecl_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8EnumDecl17getMostRecentDeclEv")]
                internal static extern global::System.IntPtr getMostRecentDecl_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8EnumDecl13getDefinitionEv")]
                internal static extern global::System.IntPtr getDefinition_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8EnumDecl6CreateERNS_10ASTContextEPNS_11DeclContextENS_14SourceLocationES5_PNS_14IdentifierInfoEPS0_bbb")]
                internal static extern global::System.IntPtr Create_0(global::System.IntPtr C, global::System.IntPtr DC, clang.SourceLocation.Internal StartLoc, clang.SourceLocation.Internal IdLoc, global::System.IntPtr Id, global::System.IntPtr PrevDecl, bool IsScoped, bool IsScopedUsingClassTag, bool IsFixed);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8EnumDecl18CreateDeserializedERNS_10ASTContextEj")]
                internal static extern global::System.IntPtr CreateDeserialized_0(global::System.IntPtr C, uint ID);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8EnumDecl18completeDefinitionENS_8QualTypeES1_jj")]
                internal static extern void completeDefinition_0(global::System.IntPtr instance, clang.QualType.Internal NewType, clang.QualType.Internal PromotionType, uint NumPositiveBits, uint NumNegativeBits);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8EnumDecl16getPromotionTypeEv")]
                internal static extern clang.QualType.Internal getPromotionType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8EnumDecl16setPromotionTypeENS_8QualTypeE")]
                internal static extern void setPromotionType_0(global::System.IntPtr instance, clang.QualType.Internal T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8EnumDecl14getIntegerTypeEv")]
                internal static extern clang.QualType.Internal getIntegerType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8EnumDecl14setIntegerTypeENS_8QualTypeE")]
                internal static extern void setIntegerType_0(global::System.IntPtr instance, clang.QualType.Internal T);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8EnumDecl24setIntegerTypeSourceInfoEPNS_14TypeSourceInfoE")]
                internal static extern void setIntegerTypeSourceInfo_0(global::System.IntPtr instance, global::System.IntPtr TInfo);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8EnumDecl24getIntegerTypeSourceInfoEv")]
                internal static extern global::System.IntPtr getIntegerTypeSourceInfo_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8EnumDecl19getIntegerTypeRangeEv")]
                internal static extern clang.SourceRange.Internal getIntegerTypeRange_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8EnumDecl18getNumPositiveBitsEv")]
                internal static extern uint getNumPositiveBits_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8EnumDecl18setNumPositiveBitsEj")]
                internal static extern void setNumPositiveBits_0(global::System.IntPtr instance, uint Num);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8EnumDecl18getNumNegativeBitsEv")]
                internal static extern uint getNumNegativeBits_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8EnumDecl18setNumNegativeBitsEj")]
                internal static extern void setNumNegativeBits_0(global::System.IntPtr instance, uint Num);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8EnumDecl8isScopedEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isScoped_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8EnumDecl21isScopedUsingClassTagEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isScopedUsingClassTag_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8EnumDecl7isFixedEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isFixed_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8EnumDecl10isCompleteEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isComplete_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8EnumDecl29getInstantiatedFromMemberEnumEv")]
                internal static extern global::System.IntPtr getInstantiatedFromMemberEnum_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang8EnumDecl29getTemplateSpecializationKindEv")]
                internal static extern clang.TemplateSpecializationKind getTemplateSpecializationKind_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8EnumDecl29setTemplateSpecializationKindENS_26TemplateSpecializationKindENS_14SourceLocationE")]
                internal static extern void setTemplateSpecializationKind_0(global::System.IntPtr instance, clang.TemplateSpecializationKind TSK, clang.SourceLocation.Internal PointOfInstantiation);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8EnumDecl28setInstantiationOfMemberEnumEPS0_NS_26TemplateSpecializationKindE")]
                internal static extern void setInstantiationOfMemberEnum_1(global::System.IntPtr instance, global::System.IntPtr ED, clang.TemplateSpecializationKind TSK);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8EnumDecl7classofEPKNS_4DeclE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr D);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang8EnumDecl11classofKindENS_4Decl4KindE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classofKind_0(clang.Decl.Kind K);
            }

            private readonly bool __ownsNativeInstance;

            public static new EnumDecl __CreateInstance(global::System.IntPtr native)
            {
                return new EnumDecl((EnumDecl.Internal*) native);
            }

            public static EnumDecl __CreateInstance(EnumDecl.Internal native)
            {
                return new EnumDecl(native);
            }

            private static EnumDecl.Internal* __CopyValue(EnumDecl.Internal native)
            {
                var ret = (EnumDecl.Internal*) Marshal.AllocHGlobal(136);
                *ret = native;
                return ret;
            }

            private EnumDecl(EnumDecl.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected EnumDecl(EnumDecl.Internal* native, bool isInternalImpl = false)
                : base((clang.TagDecl.Internal*) native)
            {
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Decl __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public virtual clang.EnumDecl getCanonicalDecl()
            {
                var __ret = Internal.getCanonicalDecl_0(__Instance);
                clang.EnumDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.EnumDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.EnumDecl) clang.EnumDecl.NativeToManagedMap[__ret];
                else clang.EnumDecl.NativeToManagedMap[__ret] = __result0 = (clang.EnumDecl) clang.EnumDecl.__CreateInstance(__ret);
                return __result0;
            }

            public clang.EnumDecl getPreviousDecl()
            {
                var __ret = Internal.getPreviousDecl_0(__Instance);
                clang.EnumDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.EnumDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.EnumDecl) clang.EnumDecl.NativeToManagedMap[__ret];
                else clang.EnumDecl.NativeToManagedMap[__ret] = __result0 = (clang.EnumDecl) clang.EnumDecl.__CreateInstance(__ret);
                return __result0;
            }

            public clang.EnumDecl getMostRecentDecl()
            {
                var __ret = Internal.getMostRecentDecl_0(__Instance);
                clang.EnumDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.EnumDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.EnumDecl) clang.EnumDecl.NativeToManagedMap[__ret];
                else clang.EnumDecl.NativeToManagedMap[__ret] = __result0 = (clang.EnumDecl) clang.EnumDecl.__CreateInstance(__ret);
                return __result0;
            }

            public clang.EnumDecl getDefinition()
            {
                var __ret = Internal.getDefinition_0(__Instance);
                clang.EnumDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.EnumDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.EnumDecl) clang.EnumDecl.NativeToManagedMap[__ret];
                else clang.EnumDecl.NativeToManagedMap[__ret] = __result0 = (clang.EnumDecl) clang.EnumDecl.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>completeDefinition - When created, the EnumDecl corresponds to a
            /// forward-declared enum. This method is used to mark the declaration as being
            /// defined; it's enumerators have already been added (via
            /// DeclContext::addDecl). NewType is the new underlying type of the
            /// enumeration type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// completeDefinition - When created, the EnumDecl corresponds
            /// to a</para>
            /// <para>  /// forward-declared enum. This method is used to mark
            /// the</para>
            /// <para>  /// declaration as being defined; it's enumerators have already
            /// been</para>
            /// <para>  /// added (via DeclContext::addDecl). NewType is the new
            /// underlying</para>
            /// <para>  /// type of the enumeration type.</para>
            /// </remarks>
            public void completeDefinition(clang.QualType NewType, clang.QualType PromotionType, uint NumPositiveBits, uint NumNegativeBits)
            {
                var arg0 = ReferenceEquals(NewType, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (NewType.__Instance);
                var arg1 = ReferenceEquals(PromotionType, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (PromotionType.__Instance);
                Internal.completeDefinition_0(__Instance, arg0, arg1, NumPositiveBits, NumNegativeBits);
            }

            /// <summary>
            /// <para>getPromotionType - Return the integer type that enumerators
            /// should promote to.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getPromotionType - Return the integer type that
            /// enumerators</para>
            /// <para>  /// should promote to.</para>
            /// </remarks>
            public clang.QualType getPromotionType()
            {
                var __ret = Internal.getPromotionType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Set the promotion type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Set the promotion type.</para>
            /// </remarks>
            public void setPromotionType(clang.QualType T)
            {
                var arg0 = ReferenceEquals(T, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (T.__Instance);
                Internal.setPromotionType_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>getIntegerType - Return the integer type this enum decl
            /// corresponds to. This returns a null QualType for an enum forward definition
            /// with no fixed underlying type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getIntegerType - Return the integer type this enum decl
            /// corresponds to.</para>
            /// <para>  /// This returns a null QualType for an enum forward definition
            /// with no fixed</para>
            /// <para>  /// underlying type.</para>
            /// </remarks>
            public clang.QualType getIntegerType()
            {
                var __ret = Internal.getIntegerType_0(__Instance);
                return clang.QualType.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Set the underlying integer type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Set the underlying integer type.</para>
            /// </remarks>
            public void setIntegerType(clang.QualType T)
            {
                var arg0 = ReferenceEquals(T, null) ? new clang.QualType.Internal() : *(clang.QualType.Internal*) (T.__Instance);
                Internal.setIntegerType_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>Set the underlying integer type source info.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Set the underlying integer type source info.</para>
            /// </remarks>
            public void setIntegerTypeSourceInfo(clang.TypeSourceInfo TInfo)
            {
                var arg0 = ReferenceEquals(TInfo, null) ? global::System.IntPtr.Zero : TInfo.__Instance;
                Internal.setIntegerTypeSourceInfo_0(__Instance, arg0);
            }

            /// <summary>
            /// <para>Return the type source info for the underlying integer type, if
            /// no type source info exists, return 0.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the type source info for the underlying integer
            /// type,</para>
            /// <para>  /// if no type source info exists, return 0.</para>
            /// </remarks>
            public clang.TypeSourceInfo getIntegerTypeSourceInfo()
            {
                var __ret = Internal.getIntegerTypeSourceInfo_0(__Instance);
                clang.TypeSourceInfo __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.TypeSourceInfo.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.TypeSourceInfo) clang.TypeSourceInfo.NativeToManagedMap[__ret];
                else __result0 = clang.TypeSourceInfo.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Retrieve the source range that covers the underlying type if
            /// specified.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the source range that covers the underlying
            /// type if</para>
            /// <para>  /// specified.</para>
            /// </remarks>
            public clang.SourceRange getIntegerTypeRange()
            {
                var __ret = Internal.getIntegerTypeRange_0(__Instance);
                return clang.SourceRange.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Returns the width in bits required to store all the non-negative
            /// enumerators of this enum.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Returns the width in bits required to store all
            /// the</para>
            /// <para>  /// non-negative enumerators of this enum.</para>
            /// </remarks>
            public uint getNumPositiveBits()
            {
                var __ret = Internal.getNumPositiveBits_0(__Instance);
                return __ret;
            }

            public void setNumPositiveBits(uint Num)
            {
                Internal.setNumPositiveBits_0(__Instance, Num);
            }

            /// <summary>
            /// <para>Returns the width in bits required to store all the negative
            /// enumerators of this enum. These widths include the rightmost leading 1;
            /// that is:</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Returns the width in bits required to store all
            /// the</para>
            /// <para>  /// negative enumerators of this enum.  These widths
            /// include</para>
            /// <para>  /// the rightmost leading 1;  that is:</para>
            /// <para>  ///</para>
            /// <para>  /// MOST NEGATIVE ENUMERATOR     PATTERN     NUM NEGATIVE
            /// BITS</para>
            /// <para>  /// ------------------------     -------
            /// -----------------</para>
            /// <para>  ///                       -1     1111111
            /// 1</para>
            /// <para>  ///                      -10     1110110
            /// 5</para>
            /// <para>  ///                     -101     1001011
            /// 8</para>
            /// </remarks>
            public uint getNumNegativeBits()
            {
                var __ret = Internal.getNumNegativeBits_0(__Instance);
                return __ret;
            }

            public void setNumNegativeBits(uint Num)
            {
                Internal.setNumNegativeBits_0(__Instance, Num);
            }

            /// <summary>
            /// <para>Returns true if this is a C++11 scoped enumeration.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Returns true if this is a C++11 scoped
            /// enumeration.</para>
            /// </remarks>
            public bool isScoped()
            {
                var __ret = Internal.isScoped_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Returns true if this is a C++11 scoped enumeration.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Returns true if this is a C++11 scoped
            /// enumeration.</para>
            /// </remarks>
            public bool isScopedUsingClassTag()
            {
                var __ret = Internal.isScopedUsingClassTag_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Returns true if this is an Objective-C, C++11, or Microsoft-style
            /// enumeration with a fixed underlying type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Returns true if this is an Objective-C, C++11,
            /// or</para>
            /// <para>  /// Microsoft-style enumeration with a fixed underlying
            /// type.</para>
            /// </remarks>
            public bool isFixed()
            {
                var __ret = Internal.isFixed_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Returns true if this can be considered a complete type.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Returns true if this can be considered a complete
            /// type.</para>
            /// </remarks>
            public bool isComplete()
            {
                var __ret = Internal.isComplete_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Returns the enumeration (declared within the template) from which
            /// this enumeration type was instantiated, or NULL if this enumeration was not
            /// instantiated from any template.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Returns the enumeration (declared within the
            /// template)</para>
            /// <para>  /// from which this enumeration type was instantiated, or NULL
            /// if</para>
            /// <para>  /// this enumeration was not instantiated from any
            /// template.</para>
            /// </remarks>
            public clang.EnumDecl getInstantiatedFromMemberEnum()
            {
                var __ret = Internal.getInstantiatedFromMemberEnum_0(__Instance);
                clang.EnumDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.EnumDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.EnumDecl) clang.EnumDecl.NativeToManagedMap[__ret];
                else clang.EnumDecl.NativeToManagedMap[__ret] = __result0 = (clang.EnumDecl) clang.EnumDecl.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>If this enumeration is a member of a specialization of a
            /// templated class, determine what kind of template specialization or
            /// instantiation this is.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief If this enumeration is a member of a specialization of
            /// a</para>
            /// <para>  /// templated class, determine what kind of template
            /// specialization</para>
            /// <para>  /// or instantiation this is.</para>
            /// </remarks>
            public clang.TemplateSpecializationKind getTemplateSpecializationKind()
            {
                var __ret = Internal.getTemplateSpecializationKind_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>For an enumeration member that was instantiated from a member
            /// enumeration of a templated class, set the template specialiation
            /// kind.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief For an enumeration member that was instantiated from a
            /// member</para>
            /// <para>  /// enumeration of a templated class, set the template
            /// specialiation kind.</para>
            /// </remarks>
            public void setTemplateSpecializationKind(clang.TemplateSpecializationKind TSK, clang.SourceLocation PointOfInstantiation)
            {
                var arg0 = TSK;
                var arg1 = ReferenceEquals(PointOfInstantiation, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (PointOfInstantiation.__Instance);
                Internal.setTemplateSpecializationKind_0(__Instance, arg0, arg1);
            }

            /// <summary>
            /// <para>Specify that this enumeration is an instantiation of the member
            /// enumeration ED.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Specify that this enumeration is an instantiation of
            /// the</para>
            /// <para>  /// member enumeration ED.</para>
            /// </remarks>
            public void setInstantiationOfMemberEnum(clang.EnumDecl ED, clang.TemplateSpecializationKind TSK)
            {
                var arg0 = ReferenceEquals(ED, null) ? global::System.IntPtr.Zero : ED.__Instance;
                var arg1 = TSK;
                Internal.setInstantiationOfMemberEnum_1(__Instance, arg0, arg1);
            }

            public static clang.EnumDecl Create(clang.ASTContext C, clang.DeclContext DC, clang.SourceLocation StartLoc, clang.SourceLocation IdLoc, clang.IdentifierInfo Id, clang.EnumDecl PrevDecl, bool IsScoped, bool IsScopedUsingClassTag, bool IsFixed)
            {
                var arg0 = ReferenceEquals(C, null) ? global::System.IntPtr.Zero : C.__Instance;
                var arg1 = ReferenceEquals(DC, null) ? global::System.IntPtr.Zero : DC.__Instance;
                var arg2 = ReferenceEquals(StartLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (StartLoc.__Instance);
                var arg3 = ReferenceEquals(IdLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (IdLoc.__Instance);
                var arg4 = ReferenceEquals(Id, null) ? global::System.IntPtr.Zero : Id.__Instance;
                var arg5 = ReferenceEquals(PrevDecl, null) ? global::System.IntPtr.Zero : PrevDecl.__Instance;
                var __ret = Internal.Create_0(arg0, arg1, arg2, arg3, arg4, arg5, IsScoped, IsScopedUsingClassTag, IsFixed);
                clang.EnumDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.EnumDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.EnumDecl) clang.EnumDecl.NativeToManagedMap[__ret];
                else clang.EnumDecl.NativeToManagedMap[__ret] = __result0 = (clang.EnumDecl) clang.EnumDecl.__CreateInstance(__ret);
                return __result0;
            }

            public static clang.EnumDecl CreateDeserialized(clang.ASTContext C, uint ID)
            {
                var arg0 = ReferenceEquals(C, null) ? global::System.IntPtr.Zero : C.__Instance;
                var __ret = Internal.CreateDeserialized_0(arg0, ID);
                clang.EnumDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.EnumDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.EnumDecl) clang.EnumDecl.NativeToManagedMap[__ret];
                else clang.EnumDecl.NativeToManagedMap[__ret] = __result0 = (clang.EnumDecl) clang.EnumDecl.__CreateInstance(__ret);
                return __result0;
            }

            public static bool classof(clang.Decl D)
            {
                var arg0 = ReferenceEquals(D, null) ? global::System.IntPtr.Zero : D.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }

            public static bool classofKind(clang.Decl.Kind K)
            {
                var arg0 = K;
                var __ret = Internal.classofKind_0(arg0);
                return __ret;
            }

            #region Virtual table interop

            // EnumDecl
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
            private static _dtor_0Delegate _dtor_0DelegateInstance;

            private static void _dtor_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (EnumDecl) _References[instance].Target;
                __target.DestroyNativeInstance();
            }

            // SourceRange getSourceRange() const override
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate clang.SourceRange.Internal _getSourceRange_0Delegate(global::System.IntPtr instance);
            private static _getSourceRange_0Delegate _getSourceRange_0DelegateInstance;

            private static clang.SourceRange.Internal _getSourceRange_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (EnumDecl) _References[instance].Target;
                var __ret = __target.getSourceRange();
                return ReferenceEquals(__ret, null) ? new clang.SourceRange.Internal() : *(clang.SourceRange.Internal*) (__ret.__Instance);
            }

            // bool isOutOfLine() const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate bool _isOutOfLine_0Delegate(global::System.IntPtr instance);
            private static _isOutOfLine_0Delegate _isOutOfLine_0DelegateInstance;

            private static bool _isOutOfLine_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (EnumDecl) _References[instance].Target;
                var __ret = __target.isOutOfLine();
                return __ret;
            }

            // EnumDecl *getCanonicalDecl() override
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getCanonicalDecl_0Delegate(global::System.IntPtr instance);
            private static _getCanonicalDecl_0Delegate _getCanonicalDecl_0DelegateInstance;

            private static global::System.IntPtr _getCanonicalDecl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (EnumDecl) _References[instance].Target;
                var __ret = __target.getCanonicalDecl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // TagDecl *getNextRedeclarationImpl() override
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getNextRedeclarationImpl_0Delegate(global::System.IntPtr instance);
            private static _getNextRedeclarationImpl_0Delegate _getNextRedeclarationImpl_0DelegateInstance;

            private static global::System.IntPtr _getNextRedeclarationImpl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (EnumDecl) _References[instance].Target;
                var __ret = __target.getNextRedeclarationImpl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // TagDecl *getPreviousDeclImpl() override
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getPreviousDeclImpl_0Delegate(global::System.IntPtr instance);
            private static _getPreviousDeclImpl_0Delegate _getPreviousDeclImpl_0DelegateInstance;

            private static global::System.IntPtr _getPreviousDeclImpl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (EnumDecl) _References[instance].Target;
                var __ret = __target.getPreviousDeclImpl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // TagDecl *getMostRecentDeclImpl() override
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getMostRecentDeclImpl_0Delegate(global::System.IntPtr instance);
            private static _getMostRecentDeclImpl_0Delegate _getMostRecentDeclImpl_0DelegateInstance;

            private static global::System.IntPtr _getMostRecentDeclImpl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (EnumDecl) _References[instance].Target;
                var __ret = __target.getMostRecentDeclImpl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // Stmt* getBody() const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getBody_0Delegate(global::System.IntPtr instance);
            private static _getBody_0Delegate _getBody_0DelegateInstance;

            private static global::System.IntPtr _getBody_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (EnumDecl) _References[instance].Target;
                var __ret = __target.getBody();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // bool hasBody() const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate bool _hasBody_0Delegate(global::System.IntPtr instance);
            private static _hasBody_0Delegate _hasBody_0DelegateInstance;

            private static bool _hasBody_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (EnumDecl) _References[instance].Target;
                var __ret = __target.hasBody();
                return __ret;
            }

            // void getNameForDiagnostic(raw_ostream &OS, const PrintingPolicy &Policy, bool Qualified) const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate void _getNameForDiagnostic_0Delegate(global::System.IntPtr instance, global::System.IntPtr OS, global::System.IntPtr Policy, bool Qualified);
            private static _getNameForDiagnostic_0Delegate _getNameForDiagnostic_0DelegateInstance;

            private static void _getNameForDiagnostic_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr OS, global::System.IntPtr Policy, bool Qualified)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (EnumDecl) _References[instance].Target;
                llvm.raw_ostream __result0;
                if (OS == IntPtr.Zero) __result0 = null;
                else if (llvm.raw_ostream.NativeToManagedMap.ContainsKey(OS))
                    __result0 = (llvm.raw_ostream) llvm.raw_ostream.NativeToManagedMap[OS];
                else llvm.raw_ostream.NativeToManagedMap[OS] = __result0 = (llvm.raw_ostream) llvm.raw_ostream.__CreateInstance(OS);
                clang.PrintingPolicy __result1;
                if (Policy == IntPtr.Zero) __result1 = null;
                else if (clang.PrintingPolicy.NativeToManagedMap.ContainsKey(Policy))
                    __result1 = (clang.PrintingPolicy) clang.PrintingPolicy.NativeToManagedMap[Policy];
                else __result1 = clang.PrintingPolicy.__CreateInstance(Policy);
                __target.getNameForDiagnostic(__result0, __result1, Qualified);
            }

            private static void*[] _OldVTables;
            private static void*[] _NewVTables;
            private static void*[] _Thunks;
            private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

            void SetupVTables(global::System.IntPtr instance)
            {
                var native = (Internal*)instance.ToPointer();

                if (_References == null)
                    _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

                if (_References.ContainsKey(instance))
                    return;

                _References[instance] = new WeakReference(this);

                if (_OldVTables == null)
                {
                    _OldVTables = new void*[1];
                    _OldVTables[0] = native->vfptr0.ToPointer();
                }

                if (_Thunks == null)
                {
                    _Thunks = new void*[10];
                    _dtor_0DelegateInstance += _dtor_0DelegateHook;
                    _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                    _getSourceRange_0DelegateInstance += _getSourceRange_0DelegateHook;
                    _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_getSourceRange_0DelegateInstance).ToPointer();
                    _isOutOfLine_0DelegateInstance += _isOutOfLine_0DelegateHook;
                    _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_isOutOfLine_0DelegateInstance).ToPointer();
                    _getCanonicalDecl_0DelegateInstance += _getCanonicalDecl_0DelegateHook;
                    _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_getCanonicalDecl_0DelegateInstance).ToPointer();
                    _getNextRedeclarationImpl_0DelegateInstance += _getNextRedeclarationImpl_0DelegateHook;
                    _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_getNextRedeclarationImpl_0DelegateInstance).ToPointer();
                    _getPreviousDeclImpl_0DelegateInstance += _getPreviousDeclImpl_0DelegateHook;
                    _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_getPreviousDeclImpl_0DelegateInstance).ToPointer();
                    _getMostRecentDeclImpl_0DelegateInstance += _getMostRecentDeclImpl_0DelegateHook;
                    _Thunks[6] = Marshal.GetFunctionPointerForDelegate(_getMostRecentDeclImpl_0DelegateInstance).ToPointer();
                    _getBody_0DelegateInstance += _getBody_0DelegateHook;
                    _Thunks[7] = Marshal.GetFunctionPointerForDelegate(_getBody_0DelegateInstance).ToPointer();
                    _hasBody_0DelegateInstance += _hasBody_0DelegateHook;
                    _Thunks[8] = Marshal.GetFunctionPointerForDelegate(_hasBody_0DelegateInstance).ToPointer();
                    _getNameForDiagnostic_0DelegateInstance += _getNameForDiagnostic_0DelegateHook;
                    _Thunks[9] = Marshal.GetFunctionPointerForDelegate(_getNameForDiagnostic_0DelegateInstance).ToPointer();
                }

                if (_NewVTables == null)
                {
                    _NewVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(11 * 8);
                    _NewVTables[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + 8) = _Thunks[0];
                    *(void**)(vfptr0 + 16) = _Thunks[1];
                    *(void**)(vfptr0 + 24) = _Thunks[2];
                    *(void**)(vfptr0 + 32) = _Thunks[3];
                    *(void**)(vfptr0 + 40) = _Thunks[4];
                    *(void**)(vfptr0 + 48) = _Thunks[5];
                    *(void**)(vfptr0 + 56) = _Thunks[6];
                    *(void**)(vfptr0 + 64) = _Thunks[7];
                    *(void**)(vfptr0 + 72) = _Thunks[8];
                    *(void**)(vfptr0 + 80) = *(void**)(native->vfptr0 + 80);
                    *(void**)(vfptr0 + 88) = _Thunks[9];
                }

                native->vfptr0 = new IntPtr(_NewVTables[0]);
            }

            #endregion
        }

        /// <summary>
        /// <para>RecordDecl - Represents a struct/union/class. For example: struct
        /// X; // Forward declaration, no &quot;body&quot;. union Y { int A, B; }; //
        /// Has body with members A and B (FieldDecls). This decl will be marked
        /// invalid if *any* members are invalid.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// RecordDecl - Represents a struct/union/class.  For
        /// example:</para>
        /// <para>///   struct X;                  // Forward declaration, no
        /// &quot;body&quot;.</para>
        /// <para>///   union Y { int A, B; };     // Has body with members A and B
        /// (FieldDecls).</para>
        /// <para>/// This decl will be marked invalid if *any* members are
        /// invalid.</para>
        /// <para>///</para>
        /// </remarks>
        public unsafe partial class RecordDecl : clang.TagDecl, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 120)]
            public new partial struct Internal
            {
                [FieldOffset(8)]
                internal llvm.PointerIntPair.Internal NextInContextAndBits;

                [FieldOffset(16)]
                internal llvm.PointerUnion.Internal DeclCtx;

                [FieldOffset(24)]
                public clang.SourceLocation.Internal Loc;

                [FieldOffset(28)]
                public uint DeclKind;

                [FieldOffset(29)]
                public uint InvalidDecl;

                [FieldOffset(29)]
                public uint HasAttrs;

                [FieldOffset(29)]
                public uint Implicit;

                [FieldOffset(29)]
                public uint Used;

                [FieldOffset(29)]
                public uint Referenced;

                [FieldOffset(29)]
                public uint Access;

                [FieldOffset(29)]
                public uint FromASTFile;

                [FieldOffset(30)]
                public uint Hidden;

                [FieldOffset(30)]
                public uint IdentifierNamespace;

                [FieldOffset(31)]
                public uint CacheValidAndLinkage;

                [FieldOffset(32)]
                public clang.DeclarationName.Internal Name;

                [FieldOffset(40)]
                public global::System.IntPtr TypeForDecl;

                [FieldOffset(48)]
                public clang.SourceLocation.Internal LocStart;

                [FieldOffset(0)]
                public uint DeclKind;

                [FieldOffset(1)]
                public bool ExternalLexicalStorage;

                [FieldOffset(1)]
                public bool ExternalVisibleStorage;

                [FieldOffset(1)]
                public bool NeedToReconcileExternalVisibleStorage;

                [FieldOffset(8)]
                internal llvm.PointerIntPair.Internal LookupPtr;

                [FieldOffset(16)]
                public global::System.IntPtr FirstDecl;

                [FieldOffset(24)]
                public global::System.IntPtr LastDecl;

                [FieldOffset(96)]
                public uint TagDeclKind;

                [FieldOffset(96)]
                public bool IsCompleteDefinition;

                [FieldOffset(96)]
                public bool IsBeingDefined;

                [FieldOffset(96)]
                public bool IsEmbeddedInDeclarator;

                [FieldOffset(96)]
                public bool IsFreeStanding;

                [FieldOffset(96)]
                public uint NumPositiveBits;

                [FieldOffset(97)]
                public uint NumNegativeBits;

                [FieldOffset(98)]
                public bool IsScoped;

                [FieldOffset(99)]
                public bool IsScopedUsingClassTag;

                [FieldOffset(99)]
                public bool IsFixed;

                [FieldOffset(99)]
                public bool MayHaveOutOfDateDef;

                [FieldOffset(99)]
                public bool IsCompleteDefinitionRequired;

                [FieldOffset(100)]
                public clang.SourceLocation.Internal RBraceLoc;

                [FieldOffset(104)]
                internal llvm.PointerUnion.Internal NamedDeclOrQualifier;

                [FieldOffset(112)]
                public bool HasFlexibleArrayMember;

                [FieldOffset(112)]
                public bool AnonymousStructOrUnion;

                [FieldOffset(112)]
                public bool HasObjectMember;

                [FieldOffset(112)]
                public bool HasVolatileMember;

                [FieldOffset(112)]
                public bool LoadedFieldsFromExternalStorage;

                [FieldOffset(0)]
                public global::System.IntPtr vfptr0;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10RecordDeclC2ENS_4Decl4KindENS_11TagTypeKindERKNS_10ASTContextEPNS_11DeclContextENS_14SourceLocationES9_PNS_14IdentifierInfoEPS0_")]
                internal static extern void ctor_0(global::System.IntPtr instance, clang.Decl.Kind DK, clang.TagTypeKind TK, global::System.IntPtr C, global::System.IntPtr DC, clang.SourceLocation.Internal StartLoc, clang.SourceLocation.Internal IdLoc, global::System.IntPtr Id, global::System.IntPtr PrevDecl);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10RecordDeclC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10RecordDeclD2Ev")]
                internal static extern void dtor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10RecordDecl6CreateERKNS_10ASTContextENS_11TagTypeKindEPNS_11DeclContextENS_14SourceLocationES7_PNS_14IdentifierInfoEPS0_")]
                internal static extern global::System.IntPtr Create_0(global::System.IntPtr C, clang.TagTypeKind TK, global::System.IntPtr DC, clang.SourceLocation.Internal StartLoc, clang.SourceLocation.Internal IdLoc, global::System.IntPtr Id, global::System.IntPtr PrevDecl);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10RecordDecl18CreateDeserializedERKNS_10ASTContextEj")]
                internal static extern global::System.IntPtr CreateDeserialized_0(global::System.IntPtr C, uint ID);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10RecordDecl15getPreviousDeclEv")]
                internal static extern global::System.IntPtr getPreviousDecl_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10RecordDecl17getMostRecentDeclEv")]
                internal static extern global::System.IntPtr getMostRecentDecl_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10RecordDecl22hasFlexibleArrayMemberEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasFlexibleArrayMember_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10RecordDecl25setHasFlexibleArrayMemberEb")]
                internal static extern void setHasFlexibleArrayMember_0(global::System.IntPtr instance, bool V);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10RecordDecl24isAnonymousStructOrUnionEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isAnonymousStructOrUnion_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10RecordDecl25setAnonymousStructOrUnionEb")]
                internal static extern void setAnonymousStructOrUnion_0(global::System.IntPtr instance, bool Anon);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10RecordDecl15hasObjectMemberEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasObjectMember_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10RecordDecl18setHasObjectMemberEb")]
                internal static extern void setHasObjectMember_0(global::System.IntPtr instance, bool val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10RecordDecl17hasVolatileMemberEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasVolatileMember_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10RecordDecl20setHasVolatileMemberEb")]
                internal static extern void setHasVolatileMember_0(global::System.IntPtr instance, bool val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10RecordDecl19isInjectedClassNameEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isInjectedClassName_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10RecordDecl8isLambdaEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isLambda_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10RecordDecl16isCapturedRecordEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isCapturedRecord_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10RecordDecl17setCapturedRecordEv")]
                internal static extern void setCapturedRecord_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10RecordDecl13getDefinitionEv")]
                internal static extern global::System.IntPtr getDefinition_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10RecordDecl11field_emptyEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool field_empty_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10RecordDecl18completeDefinitionEv")]
                internal static extern void completeDefinition_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10RecordDecl7classofEPKNS_4DeclE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr D);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10RecordDecl11classofKindENS_4Decl4KindE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classofKind_0(clang.Decl.Kind K);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10RecordDecl10isMsStructERKNS_10ASTContextE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isMsStruct_0(global::System.IntPtr instance, global::System.IntPtr C);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10RecordDecl21mayInsertExtraPaddingEb")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool mayInsertExtraPadding_0(global::System.IntPtr instance, bool EmitRemark);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10RecordDecl24findFirstNamedDataMemberEv")]
                internal static extern global::System.IntPtr findFirstNamedDataMember_0(global::System.IntPtr instance);
            }

            private readonly bool __ownsNativeInstance;

            public static new RecordDecl __CreateInstance(global::System.IntPtr native)
            {
                return new RecordDecl((RecordDecl.Internal*) native);
            }

            public static RecordDecl __CreateInstance(RecordDecl.Internal native)
            {
                return new RecordDecl(native);
            }

            private static RecordDecl.Internal* __CopyValue(RecordDecl.Internal native)
            {
                var ret = (RecordDecl.Internal*) Marshal.AllocHGlobal(120);
                *ret = native;
                return ret;
            }

            private RecordDecl(RecordDecl.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected RecordDecl(RecordDecl.Internal* native, bool isInternalImpl = false)
                : base((clang.TagDecl.Internal*) native)
            {
            }

            protected RecordDecl(clang.Decl.Kind DK, clang.TagTypeKind TK, clang.ASTContext C, clang.DeclContext DC, clang.SourceLocation StartLoc, clang.SourceLocation IdLoc, clang.IdentifierInfo Id, clang.RecordDecl PrevDecl)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(120);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = DK;
                var arg1 = TK;
                var arg2 = ReferenceEquals(C, null) ? global::System.IntPtr.Zero : C.__Instance;
                var arg3 = ReferenceEquals(DC, null) ? global::System.IntPtr.Zero : DC.__Instance;
                var arg4 = ReferenceEquals(StartLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (StartLoc.__Instance);
                var arg5 = ReferenceEquals(IdLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (IdLoc.__Instance);
                var arg6 = ReferenceEquals(Id, null) ? global::System.IntPtr.Zero : Id.__Instance;
                var arg7 = ReferenceEquals(PrevDecl, null) ? global::System.IntPtr.Zero : PrevDecl.__Instance;
                Internal.ctor_0(__Instance, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
                SetupVTables(__Instance);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Decl __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.RecordDecl getPreviousDecl()
            {
                var __ret = Internal.getPreviousDecl_0(__Instance);
                clang.RecordDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.RecordDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.RecordDecl) clang.RecordDecl.NativeToManagedMap[__ret];
                else clang.RecordDecl.NativeToManagedMap[__ret] = __result0 = (clang.RecordDecl) clang.RecordDecl.__CreateInstance(__ret);
                return __result0;
            }

            public clang.RecordDecl getMostRecentDecl()
            {
                var __ret = Internal.getMostRecentDecl_0(__Instance);
                clang.RecordDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.RecordDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.RecordDecl) clang.RecordDecl.NativeToManagedMap[__ret];
                else clang.RecordDecl.NativeToManagedMap[__ret] = __result0 = (clang.RecordDecl) clang.RecordDecl.__CreateInstance(__ret);
                return __result0;
            }

            public bool hasFlexibleArrayMember()
            {
                var __ret = Internal.hasFlexibleArrayMember_0(__Instance);
                return __ret;
            }

            public void setHasFlexibleArrayMember(bool V)
            {
                Internal.setHasFlexibleArrayMember_0(__Instance, V);
            }

            /// <summary>
            /// <para>isAnonymousStructOrUnion - Whether this is an anonymous struct or
            /// union. To be an anonymous struct or union, it must have been declared
            /// without a name and there must be no objects of this type declared, e.g., is
            /// an anonymous union but neither of the following are:</para>
            /// </summary>
            /// <remarks>
            /// <para>/// isAnonymousStructOrUnion - Whether this is an anonymous
            /// struct</para>
            /// <para>  /// or union. To be an anonymous struct or union, it must have
            /// been</para>
            /// <para>  /// declared without a name and there must be no objects of
            /// this</para>
            /// <para>  /// type declared, e.g.,</para>
            /// <para>  /// @code</para>
            /// <para>  ///   union { int i; float f; };</para>
            /// <para>  /// @endcode</para>
            /// <para>  /// is an anonymous union but neither of the following
            /// are:</para>
            /// <para>  /// @code</para>
            /// <para>  ///  union X { int i; float f; };</para>
            /// <para>  ///  union { int i; float f; } obj;</para>
            /// <para>  /// @endcode</para>
            /// </remarks>
            public bool isAnonymousStructOrUnion()
            {
                var __ret = Internal.isAnonymousStructOrUnion_0(__Instance);
                return __ret;
            }

            public void setAnonymousStructOrUnion(bool Anon)
            {
                Internal.setAnonymousStructOrUnion_0(__Instance, Anon);
            }

            public bool hasObjectMember()
            {
                var __ret = Internal.hasObjectMember_0(__Instance);
                return __ret;
            }

            public void setHasObjectMember(bool val)
            {
                Internal.setHasObjectMember_0(__Instance, val);
            }

            public bool hasVolatileMember()
            {
                var __ret = Internal.hasVolatileMember_0(__Instance);
                return __ret;
            }

            public void setHasVolatileMember(bool val)
            {
                Internal.setHasVolatileMember_0(__Instance, val);
            }

            /// <summary>
            /// <para>Determines whether this declaration represents the injected class
            /// name.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determines whether this declaration represents
            /// the</para>
            /// <para>  /// injected class name.</para>
            /// <para>  ///</para>
            /// <para>  /// The injected class name in C++ is the name of the class
            /// that</para>
            /// <para>  /// appears inside the class itself. For example:</para>
            /// <para>  ///</para>
            /// <para>  /// \code</para>
            /// <para>  /// struct C {</para>
            /// <para>  ///   // C is implicitly declared here as a synonym for the
            /// class name.</para>
            /// <para>  /// };</para>
            /// <para>  ///</para>
            /// <para>  /// C::C c; // same as &quot;C c;&quot;</para>
            /// <para>  /// \endcode</para>
            /// </remarks>
            public bool isInjectedClassName()
            {
                var __ret = Internal.isInjectedClassName_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determine whether this record is a class describing a lambda
            /// function object.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine whether this record is a class describing a
            /// lambda</para>
            /// <para>  /// function object.</para>
            /// </remarks>
            public bool isLambda()
            {
                var __ret = Internal.isLambda_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determine whether this record is a record for captured variables
            /// in CapturedStmt construct.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determine whether this record is a record for captured
            /// variables in</para>
            /// <para>  /// CapturedStmt construct.</para>
            /// </remarks>
            public bool isCapturedRecord()
            {
                var __ret = Internal.isCapturedRecord_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Mark the record as a record for captured variables in
            /// CapturedStmt construct.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Mark the record as a record for captured variables in
            /// CapturedStmt</para>
            /// <para>  /// construct.</para>
            /// </remarks>
            public void setCapturedRecord()
            {
                Internal.setCapturedRecord_0(__Instance);
            }

            /// <summary>
            /// <para>getDefinition - Returns the RecordDecl that actually defines this
            /// struct/union/class. When determining whether or not a struct/union/class is
            /// completely defined, one should use this method as opposed to
            /// 'isCompleteDefinition'. 'isCompleteDefinition' indicates whether or not a
            /// specific RecordDecl is a completed definition, not whether or not the
            /// record type is defined. This method returns NULL if there is no RecordDecl
            /// that defines the struct/union/tag.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getDefinition - Returns the RecordDecl that actually
            /// defines</para>
            /// <para>  ///  this struct/union/class.  When determining whether or not
            /// a</para>
            /// <para>  ///  struct/union/class is completely defined, one should use
            /// this</para>
            /// <para>  ///  method as opposed to 'isCompleteDefinition'.</para>
            /// <para>  ///  'isCompleteDefinition' indicates whether or not a
            /// specific</para>
            /// <para>  ///  RecordDecl is a completed definition, not whether or not
            /// the</para>
            /// <para>  ///  record type is defined.  This method returns NULL if there
            /// is</para>
            /// <para>  ///  no RecordDecl that defines the struct/union/tag.</para>
            /// </remarks>
            public clang.RecordDecl getDefinition()
            {
                var __ret = Internal.getDefinition_0(__Instance);
                clang.RecordDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.RecordDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.RecordDecl) clang.RecordDecl.NativeToManagedMap[__ret];
                else clang.RecordDecl.NativeToManagedMap[__ret] = __result0 = (clang.RecordDecl) clang.RecordDecl.__CreateInstance(__ret);
                return __result0;
            }

            public bool field_empty()
            {
                var __ret = Internal.field_empty_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>completeDefinition - Notes that the definition of this type is
            /// now complete.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// completeDefinition - Notes that the definition of this type
            /// is</para>
            /// <para>  /// now complete.</para>
            /// </remarks>
            public virtual void completeDefinition()
            {
                Internal.completeDefinition_0(__Instance);
            }

            /// <summary>
            /// <para>isMsStrust - Get whether or not this is an ms_struct which can be
            /// turned on with an attribute, pragma, or -mms-bitfields commandline
            /// option.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// isMsStrust - Get whether or not this is an ms_struct which
            /// can</para>
            /// <para>  /// be turned on with an attribute, pragma, or
            /// -mms-bitfields</para>
            /// <para>  /// commandline option.</para>
            /// </remarks>
            public bool isMsStruct(clang.ASTContext C)
            {
                var arg0 = ReferenceEquals(C, null) ? global::System.IntPtr.Zero : C.__Instance;
                var __ret = Internal.isMsStruct_0(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Whether we are allowed to insert extra padding between fields.
            /// These padding are added to help AddressSanitizer detect
            /// intra-object-overflow bugs.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Whether we are allowed to insert extra padding between
            /// fields.</para>
            /// <para>  /// These padding are added to help AddressSanitizer
            /// detect</para>
            /// <para>  /// intra-object-overflow bugs.</para>
            /// </remarks>
            public bool mayInsertExtraPadding(bool EmitRemark)
            {
                var __ret = Internal.mayInsertExtraPadding_0(__Instance, EmitRemark);
                return __ret;
            }

            /// <summary>
            /// <para>Finds the first data member which has a name. nullptr is returned
            /// if no named data member exists.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// Finds the first data member which has a name.</para>
            /// <para>  /// nullptr is returned if no named data member exists.</para>
            /// </remarks>
            public clang.FieldDecl findFirstNamedDataMember()
            {
                var __ret = Internal.findFirstNamedDataMember_0(__Instance);
                clang.FieldDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.FieldDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.FieldDecl) clang.FieldDecl.NativeToManagedMap[__ret];
                else clang.FieldDecl.NativeToManagedMap[__ret] = __result0 = (clang.FieldDecl) clang.FieldDecl.__CreateInstance(__ret);
                return __result0;
            }

            public static clang.RecordDecl Create(clang.ASTContext C, clang.TagTypeKind TK, clang.DeclContext DC, clang.SourceLocation StartLoc, clang.SourceLocation IdLoc, clang.IdentifierInfo Id, clang.RecordDecl PrevDecl)
            {
                var arg0 = ReferenceEquals(C, null) ? global::System.IntPtr.Zero : C.__Instance;
                var arg1 = TK;
                var arg2 = ReferenceEquals(DC, null) ? global::System.IntPtr.Zero : DC.__Instance;
                var arg3 = ReferenceEquals(StartLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (StartLoc.__Instance);
                var arg4 = ReferenceEquals(IdLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (IdLoc.__Instance);
                var arg5 = ReferenceEquals(Id, null) ? global::System.IntPtr.Zero : Id.__Instance;
                var arg6 = ReferenceEquals(PrevDecl, null) ? global::System.IntPtr.Zero : PrevDecl.__Instance;
                var __ret = Internal.Create_0(arg0, arg1, arg2, arg3, arg4, arg5, arg6);
                clang.RecordDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.RecordDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.RecordDecl) clang.RecordDecl.NativeToManagedMap[__ret];
                else clang.RecordDecl.NativeToManagedMap[__ret] = __result0 = (clang.RecordDecl) clang.RecordDecl.__CreateInstance(__ret);
                return __result0;
            }

            public static clang.RecordDecl CreateDeserialized(clang.ASTContext C, uint ID)
            {
                var arg0 = ReferenceEquals(C, null) ? global::System.IntPtr.Zero : C.__Instance;
                var __ret = Internal.CreateDeserialized_0(arg0, ID);
                clang.RecordDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.RecordDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.RecordDecl) clang.RecordDecl.NativeToManagedMap[__ret];
                else clang.RecordDecl.NativeToManagedMap[__ret] = __result0 = (clang.RecordDecl) clang.RecordDecl.__CreateInstance(__ret);
                return __result0;
            }

            public static bool classof(clang.Decl D)
            {
                var arg0 = ReferenceEquals(D, null) ? global::System.IntPtr.Zero : D.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }

            public static bool classofKind(clang.Decl.Kind K)
            {
                var arg0 = K;
                var __ret = Internal.classofKind_0(arg0);
                return __ret;
            }

            #region Virtual table interop

            // RecordDecl
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
            private static _dtor_0Delegate _dtor_0DelegateInstance;

            private static void _dtor_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (RecordDecl) _References[instance].Target;
                __target.DestroyNativeInstance();
            }

            // SourceRange getSourceRange() const override
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate clang.SourceRange.Internal _getSourceRange_0Delegate(global::System.IntPtr instance);
            private static _getSourceRange_0Delegate _getSourceRange_0DelegateInstance;

            private static clang.SourceRange.Internal _getSourceRange_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (RecordDecl) _References[instance].Target;
                var __ret = __target.getSourceRange();
                return ReferenceEquals(__ret, null) ? new clang.SourceRange.Internal() : *(clang.SourceRange.Internal*) (__ret.__Instance);
            }

            // bool isOutOfLine() const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate bool _isOutOfLine_0Delegate(global::System.IntPtr instance);
            private static _isOutOfLine_0Delegate _isOutOfLine_0DelegateInstance;

            private static bool _isOutOfLine_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (RecordDecl) _References[instance].Target;
                var __ret = __target.isOutOfLine();
                return __ret;
            }

            // TagDecl *getCanonicalDecl() override
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getCanonicalDecl_0Delegate(global::System.IntPtr instance);
            private static _getCanonicalDecl_0Delegate _getCanonicalDecl_0DelegateInstance;

            private static global::System.IntPtr _getCanonicalDecl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (RecordDecl) _References[instance].Target;
                var __ret = __target.getCanonicalDecl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // TagDecl *getNextRedeclarationImpl() override
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getNextRedeclarationImpl_0Delegate(global::System.IntPtr instance);
            private static _getNextRedeclarationImpl_0Delegate _getNextRedeclarationImpl_0DelegateInstance;

            private static global::System.IntPtr _getNextRedeclarationImpl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (RecordDecl) _References[instance].Target;
                var __ret = __target.getNextRedeclarationImpl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // TagDecl *getPreviousDeclImpl() override
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getPreviousDeclImpl_0Delegate(global::System.IntPtr instance);
            private static _getPreviousDeclImpl_0Delegate _getPreviousDeclImpl_0DelegateInstance;

            private static global::System.IntPtr _getPreviousDeclImpl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (RecordDecl) _References[instance].Target;
                var __ret = __target.getPreviousDeclImpl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // TagDecl *getMostRecentDeclImpl() override
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getMostRecentDeclImpl_0Delegate(global::System.IntPtr instance);
            private static _getMostRecentDeclImpl_0Delegate _getMostRecentDeclImpl_0DelegateInstance;

            private static global::System.IntPtr _getMostRecentDeclImpl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (RecordDecl) _References[instance].Target;
                var __ret = __target.getMostRecentDeclImpl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // Stmt* getBody() const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getBody_0Delegate(global::System.IntPtr instance);
            private static _getBody_0Delegate _getBody_0DelegateInstance;

            private static global::System.IntPtr _getBody_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (RecordDecl) _References[instance].Target;
                var __ret = __target.getBody();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // bool hasBody() const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate bool _hasBody_0Delegate(global::System.IntPtr instance);
            private static _hasBody_0Delegate _hasBody_0DelegateInstance;

            private static bool _hasBody_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (RecordDecl) _References[instance].Target;
                var __ret = __target.hasBody();
                return __ret;
            }

            // void getNameForDiagnostic(raw_ostream &OS, const PrintingPolicy &Policy, bool Qualified) const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate void _getNameForDiagnostic_0Delegate(global::System.IntPtr instance, global::System.IntPtr OS, global::System.IntPtr Policy, bool Qualified);
            private static _getNameForDiagnostic_0Delegate _getNameForDiagnostic_0DelegateInstance;

            private static void _getNameForDiagnostic_0DelegateHook(global::System.IntPtr instance, global::System.IntPtr OS, global::System.IntPtr Policy, bool Qualified)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (RecordDecl) _References[instance].Target;
                llvm.raw_ostream __result0;
                if (OS == IntPtr.Zero) __result0 = null;
                else if (llvm.raw_ostream.NativeToManagedMap.ContainsKey(OS))
                    __result0 = (llvm.raw_ostream) llvm.raw_ostream.NativeToManagedMap[OS];
                else llvm.raw_ostream.NativeToManagedMap[OS] = __result0 = (llvm.raw_ostream) llvm.raw_ostream.__CreateInstance(OS);
                clang.PrintingPolicy __result1;
                if (Policy == IntPtr.Zero) __result1 = null;
                else if (clang.PrintingPolicy.NativeToManagedMap.ContainsKey(Policy))
                    __result1 = (clang.PrintingPolicy) clang.PrintingPolicy.NativeToManagedMap[Policy];
                else __result1 = clang.PrintingPolicy.__CreateInstance(Policy);
                __target.getNameForDiagnostic(__result0, __result1, Qualified);
            }

            // void completeDefinition()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate void _completeDefinition_0Delegate(global::System.IntPtr instance);
            private static _completeDefinition_0Delegate _completeDefinition_0DelegateInstance;

            private static void _completeDefinition_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (RecordDecl) _References[instance].Target;
                __target.completeDefinition();
            }

            private static void*[] _OldVTables;
            private static void*[] _NewVTables;
            private static void*[] _Thunks;
            private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

            void SetupVTables(global::System.IntPtr instance)
            {
                var native = (Internal*)instance.ToPointer();

                if (_References == null)
                    _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

                if (_References.ContainsKey(instance))
                    return;

                _References[instance] = new WeakReference(this);

                if (_OldVTables == null)
                {
                    _OldVTables = new void*[1];
                    _OldVTables[0] = native->vfptr0.ToPointer();
                }

                if (_Thunks == null)
                {
                    _Thunks = new void*[11];
                    _dtor_0DelegateInstance += _dtor_0DelegateHook;
                    _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                    _getSourceRange_0DelegateInstance += _getSourceRange_0DelegateHook;
                    _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_getSourceRange_0DelegateInstance).ToPointer();
                    _isOutOfLine_0DelegateInstance += _isOutOfLine_0DelegateHook;
                    _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_isOutOfLine_0DelegateInstance).ToPointer();
                    _getCanonicalDecl_0DelegateInstance += _getCanonicalDecl_0DelegateHook;
                    _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_getCanonicalDecl_0DelegateInstance).ToPointer();
                    _getNextRedeclarationImpl_0DelegateInstance += _getNextRedeclarationImpl_0DelegateHook;
                    _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_getNextRedeclarationImpl_0DelegateInstance).ToPointer();
                    _getPreviousDeclImpl_0DelegateInstance += _getPreviousDeclImpl_0DelegateHook;
                    _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_getPreviousDeclImpl_0DelegateInstance).ToPointer();
                    _getMostRecentDeclImpl_0DelegateInstance += _getMostRecentDeclImpl_0DelegateHook;
                    _Thunks[6] = Marshal.GetFunctionPointerForDelegate(_getMostRecentDeclImpl_0DelegateInstance).ToPointer();
                    _getBody_0DelegateInstance += _getBody_0DelegateHook;
                    _Thunks[7] = Marshal.GetFunctionPointerForDelegate(_getBody_0DelegateInstance).ToPointer();
                    _hasBody_0DelegateInstance += _hasBody_0DelegateHook;
                    _Thunks[8] = Marshal.GetFunctionPointerForDelegate(_hasBody_0DelegateInstance).ToPointer();
                    _getNameForDiagnostic_0DelegateInstance += _getNameForDiagnostic_0DelegateHook;
                    _Thunks[9] = Marshal.GetFunctionPointerForDelegate(_getNameForDiagnostic_0DelegateInstance).ToPointer();
                    _completeDefinition_0DelegateInstance += _completeDefinition_0DelegateHook;
                    _Thunks[10] = Marshal.GetFunctionPointerForDelegate(_completeDefinition_0DelegateInstance).ToPointer();
                }

                if (_NewVTables == null)
                {
                    _NewVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(12 * 8);
                    _NewVTables[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + 8) = _Thunks[0];
                    *(void**)(vfptr0 + 16) = _Thunks[1];
                    *(void**)(vfptr0 + 24) = _Thunks[2];
                    *(void**)(vfptr0 + 32) = _Thunks[3];
                    *(void**)(vfptr0 + 40) = _Thunks[4];
                    *(void**)(vfptr0 + 48) = _Thunks[5];
                    *(void**)(vfptr0 + 56) = _Thunks[6];
                    *(void**)(vfptr0 + 64) = _Thunks[7];
                    *(void**)(vfptr0 + 72) = _Thunks[8];
                    *(void**)(vfptr0 + 80) = *(void**)(native->vfptr0 + 80);
                    *(void**)(vfptr0 + 88) = _Thunks[9];
                    *(void**)(vfptr0 + 96) = _Thunks[10];
                }

                native->vfptr0 = new IntPtr(_NewVTables[0]);
            }

            #endregion
        }

        public unsafe partial class FileScopeAsmDecl : clang.Decl, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 48)]
            public new partial struct Internal
            {
                [FieldOffset(8)]
                internal llvm.PointerIntPair.Internal NextInContextAndBits;

                [FieldOffset(16)]
                internal llvm.PointerUnion.Internal DeclCtx;

                [FieldOffset(24)]
                public clang.SourceLocation.Internal Loc;

                [FieldOffset(28)]
                public uint DeclKind;

                [FieldOffset(29)]
                public uint InvalidDecl;

                [FieldOffset(29)]
                public uint HasAttrs;

                [FieldOffset(29)]
                public uint Implicit;

                [FieldOffset(29)]
                public uint Used;

                [FieldOffset(29)]
                public uint Referenced;

                [FieldOffset(29)]
                public uint Access;

                [FieldOffset(29)]
                public uint FromASTFile;

                [FieldOffset(30)]
                public uint Hidden;

                [FieldOffset(30)]
                public uint IdentifierNamespace;

                [FieldOffset(31)]
                public uint CacheValidAndLinkage;

                [FieldOffset(32)]
                public global::System.IntPtr AsmString;

                [FieldOffset(40)]
                public clang.SourceLocation.Internal RParenLoc;

                [FieldOffset(0)]
                public global::System.IntPtr vfptr0;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16FileScopeAsmDeclC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16FileScopeAsmDeclD2Ev")]
                internal static extern void dtor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16FileScopeAsmDecl18CreateDeserializedERNS_10ASTContextEj")]
                internal static extern global::System.IntPtr CreateDeserialized_0(global::System.IntPtr C, uint ID);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang16FileScopeAsmDecl9getAsmLocEv")]
                internal static extern clang.SourceLocation.Internal getAsmLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang16FileScopeAsmDecl12getRParenLocEv")]
                internal static extern clang.SourceLocation.Internal getRParenLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16FileScopeAsmDecl12setRParenLocENS_14SourceLocationE")]
                internal static extern void setRParenLoc_0(global::System.IntPtr instance, clang.SourceLocation.Internal L);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang16FileScopeAsmDecl14getSourceRangeEv")]
                internal static extern clang.SourceRange.Internal getSourceRange_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16FileScopeAsmDecl7classofEPKNS_4DeclE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr D);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang16FileScopeAsmDecl11classofKindENS_4Decl4KindE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classofKind_0(clang.Decl.Kind K);
            }

            private readonly bool __ownsNativeInstance;

            public static new FileScopeAsmDecl __CreateInstance(global::System.IntPtr native)
            {
                return new FileScopeAsmDecl((FileScopeAsmDecl.Internal*) native);
            }

            public static FileScopeAsmDecl __CreateInstance(FileScopeAsmDecl.Internal native)
            {
                return new FileScopeAsmDecl(native);
            }

            private static FileScopeAsmDecl.Internal* __CopyValue(FileScopeAsmDecl.Internal native)
            {
                var ret = (FileScopeAsmDecl.Internal*) Marshal.AllocHGlobal(48);
                *ret = native;
                return ret;
            }

            private FileScopeAsmDecl(FileScopeAsmDecl.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected FileScopeAsmDecl(FileScopeAsmDecl.Internal* native, bool isInternalImpl = false)
                : base((clang.Decl.Internal*) native)
            {
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Decl __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.SourceLocation getAsmLoc()
            {
                var __ret = Internal.getAsmLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getRParenLoc()
            {
                var __ret = Internal.getRParenLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setRParenLoc(clang.SourceLocation L)
            {
                var arg0 = ReferenceEquals(L, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (L.__Instance);
                Internal.setRParenLoc_0(__Instance, arg0);
            }

            public override clang.SourceRange getSourceRange()
            {
                var __ret = Internal.getSourceRange_0(__Instance);
                return clang.SourceRange.__CreateInstance(__ret);
            }

            public static clang.FileScopeAsmDecl CreateDeserialized(clang.ASTContext C, uint ID)
            {
                var arg0 = ReferenceEquals(C, null) ? global::System.IntPtr.Zero : C.__Instance;
                var __ret = Internal.CreateDeserialized_0(arg0, ID);
                clang.FileScopeAsmDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.FileScopeAsmDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.FileScopeAsmDecl) clang.FileScopeAsmDecl.NativeToManagedMap[__ret];
                else clang.FileScopeAsmDecl.NativeToManagedMap[__ret] = __result0 = (clang.FileScopeAsmDecl) clang.FileScopeAsmDecl.__CreateInstance(__ret);
                return __result0;
            }

            public static bool classof(clang.Decl D)
            {
                var arg0 = ReferenceEquals(D, null) ? global::System.IntPtr.Zero : D.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }

            public static bool classofKind(clang.Decl.Kind K)
            {
                var arg0 = K;
                var __ret = Internal.classofKind_0(arg0);
                return __ret;
            }

            #region Virtual table interop

            // FileScopeAsmDecl
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
            private static _dtor_0Delegate _dtor_0DelegateInstance;

            private static void _dtor_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (FileScopeAsmDecl) _References[instance].Target;
                __target.DestroyNativeInstance();
            }

            // SourceRange getSourceRange() const override
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate clang.SourceRange.Internal _getSourceRange_0Delegate(global::System.IntPtr instance);
            private static _getSourceRange_0Delegate _getSourceRange_0DelegateInstance;

            private static clang.SourceRange.Internal _getSourceRange_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (FileScopeAsmDecl) _References[instance].Target;
                var __ret = __target.getSourceRange();
                return ReferenceEquals(__ret, null) ? new clang.SourceRange.Internal() : *(clang.SourceRange.Internal*) (__ret.__Instance);
            }

            // bool isOutOfLine() const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate bool _isOutOfLine_0Delegate(global::System.IntPtr instance);
            private static _isOutOfLine_0Delegate _isOutOfLine_0DelegateInstance;

            private static bool _isOutOfLine_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (FileScopeAsmDecl) _References[instance].Target;
                var __ret = __target.isOutOfLine();
                return __ret;
            }

            // Decl *getCanonicalDecl()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getCanonicalDecl_0Delegate(global::System.IntPtr instance);
            private static _getCanonicalDecl_0Delegate _getCanonicalDecl_0DelegateInstance;

            private static global::System.IntPtr _getCanonicalDecl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (FileScopeAsmDecl) _References[instance].Target;
                var __ret = __target.getCanonicalDecl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // Decl *getNextRedeclarationImpl()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getNextRedeclarationImpl_0Delegate(global::System.IntPtr instance);
            private static _getNextRedeclarationImpl_0Delegate _getNextRedeclarationImpl_0DelegateInstance;

            private static global::System.IntPtr _getNextRedeclarationImpl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (FileScopeAsmDecl) _References[instance].Target;
                var __ret = __target.getNextRedeclarationImpl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // Decl *getPreviousDeclImpl()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getPreviousDeclImpl_0Delegate(global::System.IntPtr instance);
            private static _getPreviousDeclImpl_0Delegate _getPreviousDeclImpl_0DelegateInstance;

            private static global::System.IntPtr _getPreviousDeclImpl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (FileScopeAsmDecl) _References[instance].Target;
                var __ret = __target.getPreviousDeclImpl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // Decl *getMostRecentDeclImpl()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getMostRecentDeclImpl_0Delegate(global::System.IntPtr instance);
            private static _getMostRecentDeclImpl_0Delegate _getMostRecentDeclImpl_0DelegateInstance;

            private static global::System.IntPtr _getMostRecentDeclImpl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (FileScopeAsmDecl) _References[instance].Target;
                var __ret = __target.getMostRecentDeclImpl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // Stmt* getBody() const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getBody_0Delegate(global::System.IntPtr instance);
            private static _getBody_0Delegate _getBody_0DelegateInstance;

            private static global::System.IntPtr _getBody_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (FileScopeAsmDecl) _References[instance].Target;
                var __ret = __target.getBody();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // bool hasBody() const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate bool _hasBody_0Delegate(global::System.IntPtr instance);
            private static _hasBody_0Delegate _hasBody_0DelegateInstance;

            private static bool _hasBody_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (FileScopeAsmDecl) _References[instance].Target;
                var __ret = __target.hasBody();
                return __ret;
            }

            private static void*[] _OldVTables;
            private static void*[] _NewVTables;
            private static void*[] _Thunks;
            private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

            void SetupVTables(global::System.IntPtr instance)
            {
                var native = (Internal*)instance.ToPointer();

                if (_References == null)
                    _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

                if (_References.ContainsKey(instance))
                    return;

                _References[instance] = new WeakReference(this);

                if (_OldVTables == null)
                {
                    _OldVTables = new void*[1];
                    _OldVTables[0] = native->vfptr0.ToPointer();
                }

                if (_Thunks == null)
                {
                    _Thunks = new void*[9];
                    _dtor_0DelegateInstance += _dtor_0DelegateHook;
                    _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                    _getSourceRange_0DelegateInstance += _getSourceRange_0DelegateHook;
                    _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_getSourceRange_0DelegateInstance).ToPointer();
                    _isOutOfLine_0DelegateInstance += _isOutOfLine_0DelegateHook;
                    _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_isOutOfLine_0DelegateInstance).ToPointer();
                    _getCanonicalDecl_0DelegateInstance += _getCanonicalDecl_0DelegateHook;
                    _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_getCanonicalDecl_0DelegateInstance).ToPointer();
                    _getNextRedeclarationImpl_0DelegateInstance += _getNextRedeclarationImpl_0DelegateHook;
                    _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_getNextRedeclarationImpl_0DelegateInstance).ToPointer();
                    _getPreviousDeclImpl_0DelegateInstance += _getPreviousDeclImpl_0DelegateHook;
                    _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_getPreviousDeclImpl_0DelegateInstance).ToPointer();
                    _getMostRecentDeclImpl_0DelegateInstance += _getMostRecentDeclImpl_0DelegateHook;
                    _Thunks[6] = Marshal.GetFunctionPointerForDelegate(_getMostRecentDeclImpl_0DelegateInstance).ToPointer();
                    _getBody_0DelegateInstance += _getBody_0DelegateHook;
                    _Thunks[7] = Marshal.GetFunctionPointerForDelegate(_getBody_0DelegateInstance).ToPointer();
                    _hasBody_0DelegateInstance += _hasBody_0DelegateHook;
                    _Thunks[8] = Marshal.GetFunctionPointerForDelegate(_hasBody_0DelegateInstance).ToPointer();
                }

                if (_NewVTables == null)
                {
                    _NewVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(10 * 8);
                    _NewVTables[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + 8) = _Thunks[0];
                    *(void**)(vfptr0 + 16) = _Thunks[1];
                    *(void**)(vfptr0 + 24) = _Thunks[2];
                    *(void**)(vfptr0 + 32) = _Thunks[3];
                    *(void**)(vfptr0 + 40) = _Thunks[4];
                    *(void**)(vfptr0 + 48) = _Thunks[5];
                    *(void**)(vfptr0 + 56) = _Thunks[6];
                    *(void**)(vfptr0 + 64) = _Thunks[7];
                    *(void**)(vfptr0 + 72) = _Thunks[8];
                    *(void**)(vfptr0 + 80) = *(void**)(native->vfptr0 + 80);
                }

                native->vfptr0 = new IntPtr(_NewVTables[0]);
            }

            #endregion
        }

        /// <summary>
        /// <para>BlockDecl - This represents a block literal declaration, which is
        /// like an unnamed FunctionDecl. For example: ^{ statement-body } or ^(int
        /// arg1, float arg2){ statement-body }</para>
        /// </summary>
        /// <remarks>
        /// <para>/// BlockDecl - This represents a block literal declaration,
        /// which is like an</para>
        /// <para>/// unnamed FunctionDecl.  For example:</para>
        /// <para>/// ^{ statement-body }   or   ^(int arg1, float arg2){
        /// statement-body }</para>
        /// <para>///</para>
        /// </remarks>
        public unsafe partial class BlockDecl : clang.Decl, clang.DeclContext, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 128)]
            public new partial struct Internal
            {
                [FieldOffset(8)]
                internal llvm.PointerIntPair.Internal NextInContextAndBits;

                [FieldOffset(16)]
                internal llvm.PointerUnion.Internal DeclCtx;

                [FieldOffset(24)]
                public clang.SourceLocation.Internal Loc;

                [FieldOffset(28)]
                public uint DeclKind;

                [FieldOffset(29)]
                public uint InvalidDecl;

                [FieldOffset(29)]
                public uint HasAttrs;

                [FieldOffset(29)]
                public uint Implicit;

                [FieldOffset(29)]
                public uint Used;

                [FieldOffset(29)]
                public uint Referenced;

                [FieldOffset(29)]
                public uint Access;

                [FieldOffset(29)]
                public uint FromASTFile;

                [FieldOffset(30)]
                public uint Hidden;

                [FieldOffset(30)]
                public uint IdentifierNamespace;

                [FieldOffset(31)]
                public uint CacheValidAndLinkage;

                [FieldOffset(0)]
                public uint DeclKind;

                [FieldOffset(1)]
                public bool ExternalLexicalStorage;

                [FieldOffset(1)]
                public bool ExternalVisibleStorage;

                [FieldOffset(1)]
                public bool NeedToReconcileExternalVisibleStorage;

                [FieldOffset(8)]
                internal llvm.PointerIntPair.Internal LookupPtr;

                [FieldOffset(16)]
                public global::System.IntPtr FirstDecl;

                [FieldOffset(24)]
                public global::System.IntPtr LastDecl;

                [FieldOffset(64)]
                public bool IsVariadic;

                [FieldOffset(64)]
                public bool CapturesCXXThis;

                [FieldOffset(64)]
                public bool BlockMissingReturnType;

                [FieldOffset(64)]
                public bool IsConversionFromLambda;

                [FieldOffset(72)]
                public global::System.IntPtr ParamInfo;

                [FieldOffset(80)]
                public uint NumParams;

                [FieldOffset(88)]
                public global::System.IntPtr Body;

                [FieldOffset(96)]
                public global::System.IntPtr SignatureAsWritten;

                [FieldOffset(104)]
                public global::System.IntPtr Captures;

                [FieldOffset(112)]
                public uint NumCaptures;

                [FieldOffset(116)]
                public uint ManglingNumber;

                [FieldOffset(120)]
                public global::System.IntPtr ManglingContextDecl;

                [FieldOffset(0)]
                public global::System.IntPtr vfptr0;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9BlockDeclC2EPNS_11DeclContextENS_14SourceLocationE")]
                internal static extern void ctor_0(global::System.IntPtr instance, global::System.IntPtr DC, clang.SourceLocation.Internal CaretLoc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9BlockDeclC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9BlockDeclD2Ev")]
                internal static extern void dtor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9BlockDecl6CreateERNS_10ASTContextEPNS_11DeclContextENS_14SourceLocationE")]
                internal static extern global::System.IntPtr Create_0(global::System.IntPtr C, global::System.IntPtr DC, clang.SourceLocation.Internal L);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9BlockDecl18CreateDeserializedERNS_10ASTContextEj")]
                internal static extern global::System.IntPtr CreateDeserialized_0(global::System.IntPtr C, uint ID);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9BlockDecl16getCaretLocationEv")]
                internal static extern clang.SourceLocation.Internal getCaretLocation_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9BlockDecl10isVariadicEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isVariadic_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9BlockDecl13setIsVariadicEb")]
                internal static extern void setIsVariadic_0(global::System.IntPtr instance, bool value);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9BlockDecl15getCompoundBodyEv")]
                internal static extern global::System.IntPtr getCompoundBody_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9BlockDecl7getBodyEv")]
                internal static extern global::System.IntPtr getBody_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9BlockDecl7setBodyEPNS_12CompoundStmtE")]
                internal static extern void setBody_0(global::System.IntPtr instance, global::System.IntPtr B);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9BlockDecl21setSignatureAsWrittenEPNS_14TypeSourceInfoE")]
                internal static extern void setSignatureAsWritten_0(global::System.IntPtr instance, global::System.IntPtr Sig);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9BlockDecl21getSignatureAsWrittenEv")]
                internal static extern global::System.IntPtr getSignatureAsWritten_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9BlockDecl10param_sizeEv")]
                internal static extern uint param_size_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9BlockDecl11param_emptyEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool param_empty_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9BlockDecl11param_beginEv")]
                internal static extern global::System.IntPtr param_begin_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9BlockDecl9param_endEv")]
                internal static extern global::System.IntPtr param_end_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9BlockDecl12getNumParamsEv")]
                internal static extern uint getNumParams_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9BlockDecl12getParamDeclEj")]
                internal static extern global::System.IntPtr getParamDecl_1(global::System.IntPtr instance, uint i);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9BlockDecl11hasCapturesEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool hasCaptures_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9BlockDecl14getNumCapturesEv")]
                internal static extern uint getNumCaptures_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9BlockDecl13capture_beginEv")]
                internal static extern global::System.IntPtr capture_begin_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9BlockDecl11capture_endEv")]
                internal static extern global::System.IntPtr capture_end_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9BlockDecl15capturesCXXThisEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool capturesCXXThis_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9BlockDecl22blockMissingReturnTypeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool blockMissingReturnType_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9BlockDecl25setBlockMissingReturnTypeEb")]
                internal static extern void setBlockMissingReturnType_0(global::System.IntPtr instance, bool val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9BlockDecl22isConversionFromLambdaEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isConversionFromLambda_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9BlockDecl25setIsConversionFromLambdaEb")]
                internal static extern void setIsConversionFromLambda_0(global::System.IntPtr instance, bool val);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9BlockDecl16capturesVariableEPKNS_7VarDeclE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool capturesVariable_0(global::System.IntPtr instance, global::System.IntPtr var);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9BlockDecl11setCapturesERNS_10ASTContextEPKNS0_7CaptureES5_b")]
                internal static extern void setCaptures_0(global::System.IntPtr instance, global::System.IntPtr Context, global::System.IntPtr begin, global::System.IntPtr end, bool capturesCXXThis);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9BlockDecl22getBlockManglingNumberEv")]
                internal static extern uint getBlockManglingNumber_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9BlockDecl27getBlockManglingContextDeclEv")]
                internal static extern global::System.IntPtr getBlockManglingContextDecl_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9BlockDecl16setBlockManglingEjPNS_4DeclE")]
                internal static extern void setBlockMangling_0(global::System.IntPtr instance, uint Number, global::System.IntPtr Ctx);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang9BlockDecl14getSourceRangeEv")]
                internal static extern clang.SourceRange.Internal getSourceRange_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9BlockDecl7classofEPKNS_4DeclE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr D);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9BlockDecl11classofKindENS_4Decl4KindE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classofKind_0(clang.Decl.Kind K);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9BlockDecl17castToDeclContextEPKS0_")]
                internal static extern global::System.IntPtr castToDeclContext_0(global::System.IntPtr D);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9BlockDecl19castFromDeclContextEPKNS_11DeclContextE")]
                internal static extern global::System.IntPtr castFromDeclContext_0(global::System.IntPtr DC);
            }

            public class capture_iterator { }

            public class capture_const_iterator { }

            /// <summary>
            /// <para>A class which contains all the information about a particular
            /// captured value.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// A class which contains all the information about a
            /// particular</para>
            /// <para>  /// captured value.</para>
            /// </remarks>
            public unsafe partial class Capture : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 16)]
                public partial struct Internal
                {
                    [FieldOffset(0)]
                    internal llvm.PointerIntPair.Internal VariableAndFlags;

                    [FieldOffset(8)]
                    public global::System.IntPtr CopyExpr;

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang9BlockDecl7CaptureC2ERKS1_")]
                    internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang9BlockDecl7Capture11getVariableEv")]
                    internal static extern global::System.IntPtr getVariable_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang9BlockDecl7Capture7isByRefEv")]
                    [return: MarshalAsAttribute(UnmanagedType.I1)]
                    internal static extern bool isByRef_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang9BlockDecl7Capture8isNestedEv")]
                    [return: MarshalAsAttribute(UnmanagedType.I1)]
                    internal static extern bool isNested_0(global::System.IntPtr instance);

                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZNK5clang9BlockDecl7Capture11hasCopyExprEv")]
                    [return: MarshalAsAttribute(UnmanagedType.I1)]
                    internal static extern bool hasCopyExpr_0(global::System.IntPtr instance);
                }

                public global::System.IntPtr __Instance { get; protected set; }
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, Capture> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, Capture>();

                private readonly bool __ownsNativeInstance;

                public static Capture __CreateInstance(global::System.IntPtr native)
                {
                    return new Capture((Capture.Internal*) native);
                }

                public static Capture __CreateInstance(Capture.Internal native)
                {
                    return new Capture(native);
                }

                private static Capture.Internal* __CopyValue(Capture.Internal native)
                {
                    var ret = (Capture.Internal*) Marshal.AllocHGlobal(16);
                    *ret = native;
                    return ret;
                }

                private Capture(Capture.Internal native)
                    : this(__CopyValue(native))
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected Capture(Capture.Internal* native, bool isInternalImpl = false)
                {
                    __Instance = new global::System.IntPtr(native);
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    DestroyNativeInstance(false);
                }

                public virtual void DestroyNativeInstance()
                {
                    DestroyNativeInstance(true);
                }

                private void DestroyNativeInstance(bool force)
                {
                    clang.BlockDecl.Capture __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }

                /// <summary>
                /// <para>The variable being captured.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// The variable being captured.</para>
                /// </remarks>
                public clang.VarDecl getVariable()
                {
                    var __ret = Internal.getVariable_0(__Instance);
                    clang.VarDecl __result0;
                    if (__ret == IntPtr.Zero) __result0 = null;
                    else if (clang.VarDecl.NativeToManagedMap.ContainsKey(__ret))
                        __result0 = (clang.VarDecl) clang.VarDecl.NativeToManagedMap[__ret];
                    else clang.VarDecl.NativeToManagedMap[__ret] = __result0 = (clang.VarDecl) clang.VarDecl.__CreateInstance(__ret);
                    return __result0;
                }

                /// <summary>
                /// <para>Whether this is a &quot;by ref&quot; capture, i.e. a capture of a
                /// __block variable.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// Whether this is a &quot;by ref&quot; capture, i.e. a capture
                /// of a __block</para>
                /// <para>    /// variable.</para>
                /// </remarks>
                public bool isByRef()
                {
                    var __ret = Internal.isByRef_0(__Instance);
                    return __ret;
                }

                /// <summary>
                /// <para>Whether this is a nested capture, i.e. the variable captured is
                /// not from outside the immediately enclosing function/block.</para>
                /// </summary>
                /// <remarks>
                /// <para>/// Whether this is a nested capture, i.e. the variable
                /// captured</para>
                /// <para>    /// is not from outside the immediately enclosing
                /// function/block.</para>
                /// </remarks>
                public bool isNested()
                {
                    var __ret = Internal.isNested_0(__Instance);
                    return __ret;
                }

                public bool hasCopyExpr()
                {
                    var __ret = Internal.hasCopyExpr_0(__Instance);
                    return __ret;
                }
            }

            private readonly bool __ownsNativeInstance;

            public static new BlockDecl __CreateInstance(global::System.IntPtr native)
            {
                return new BlockDecl((BlockDecl.Internal*) native);
            }

            public static BlockDecl __CreateInstance(BlockDecl.Internal native)
            {
                return new BlockDecl(native);
            }

            private static BlockDecl.Internal* __CopyValue(BlockDecl.Internal native)
            {
                var ret = (BlockDecl.Internal*) Marshal.AllocHGlobal(128);
                *ret = native;
                return ret;
            }

            private BlockDecl(BlockDecl.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected BlockDecl(BlockDecl.Internal* native, bool isInternalImpl = false)
                : base((clang.Decl.Internal*) native)
            {
            }

            protected BlockDecl(clang.DeclContext DC, clang.SourceLocation CaretLoc)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(128);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(DC, null) ? global::System.IntPtr.Zero : DC.__Instance;
                var arg1 = ReferenceEquals(CaretLoc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (CaretLoc.__Instance);
                Internal.ctor_0(__Instance, arg0, arg1);
                SetupVTables(__Instance);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Decl __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.SourceLocation getCaretLocation()
            {
                var __ret = Internal.getCaretLocation_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public bool isVariadic()
            {
                var __ret = Internal.isVariadic_0(__Instance);
                return __ret;
            }

            public void setIsVariadic(bool value)
            {
                Internal.setIsVariadic_0(__Instance, value);
            }

            public clang.CompoundStmt getCompoundBody()
            {
                var __ret = Internal.getCompoundBody_0(__Instance);
                clang.CompoundStmt __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.CompoundStmt.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.CompoundStmt) clang.CompoundStmt.NativeToManagedMap[__ret];
                else __result0 = clang.CompoundStmt.__CreateInstance(__ret);
                return __result0;
            }

            public override clang.Stmt getBody()
            {
                var __ret = Internal.getBody_0(__Instance);
                clang.Stmt __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Stmt.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Stmt) clang.Stmt.NativeToManagedMap[__ret];
                else __result0 = clang.Stmt.__CreateInstance(__ret);
                return __result0;
            }

            public void setBody(clang.CompoundStmt B)
            {
                var arg0 = ReferenceEquals(B, null) ? global::System.IntPtr.Zero : B.__Instance;
                Internal.setBody_0(__Instance, arg0);
            }

            public void setSignatureAsWritten(clang.TypeSourceInfo Sig)
            {
                var arg0 = ReferenceEquals(Sig, null) ? global::System.IntPtr.Zero : Sig.__Instance;
                Internal.setSignatureAsWritten_0(__Instance, arg0);
            }

            public clang.TypeSourceInfo getSignatureAsWritten()
            {
                var __ret = Internal.getSignatureAsWritten_0(__Instance);
                clang.TypeSourceInfo __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.TypeSourceInfo.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.TypeSourceInfo) clang.TypeSourceInfo.NativeToManagedMap[__ret];
                else __result0 = clang.TypeSourceInfo.__CreateInstance(__ret);
                return __result0;
            }

            public uint param_size()
            {
                var __ret = Internal.param_size_0(__Instance);
                return __ret;
            }

            public bool param_empty()
            {
                var __ret = Internal.param_empty_0(__Instance);
                return __ret;
            }

            public clang.ParmVarDecl param_begin()
            {
                var __ret = Internal.param_begin_0(__Instance);
                clang.ParmVarDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.ParmVarDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.ParmVarDecl) clang.ParmVarDecl.NativeToManagedMap[__ret];
                else clang.ParmVarDecl.NativeToManagedMap[__ret] = __result0 = (clang.ParmVarDecl) clang.ParmVarDecl.__CreateInstance(__ret);
                return __result0;
            }

            public clang.ParmVarDecl param_end()
            {
                var __ret = Internal.param_end_0(__Instance);
                clang.ParmVarDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.ParmVarDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.ParmVarDecl) clang.ParmVarDecl.NativeToManagedMap[__ret];
                else clang.ParmVarDecl.NativeToManagedMap[__ret] = __result0 = (clang.ParmVarDecl) clang.ParmVarDecl.__CreateInstance(__ret);
                return __result0;
            }

            public uint getNumParams()
            {
                var __ret = Internal.getNumParams_0(__Instance);
                return __ret;
            }

            public clang.ParmVarDecl getParamDecl(uint i)
            {
                var __ret = Internal.getParamDecl_1(__Instance, i);
                clang.ParmVarDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.ParmVarDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.ParmVarDecl) clang.ParmVarDecl.NativeToManagedMap[__ret];
                else clang.ParmVarDecl.NativeToManagedMap[__ret] = __result0 = (clang.ParmVarDecl) clang.ParmVarDecl.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>hasCaptures - True if this block (or its nested blocks) captures
            /// anything of local storage from its enclosing scopes.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// hasCaptures - True if this block (or its nested blocks)
            /// captures</para>
            /// <para>  /// anything of local storage from its enclosing scopes.</para>
            /// </remarks>
            public bool hasCaptures()
            {
                var __ret = Internal.hasCaptures_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>getNumCaptures - Returns the number of captured variables. Does
            /// not include an entry for 'this'.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// getNumCaptures - Returns the number of captured
            /// variables.</para>
            /// <para>  /// Does not include an entry for 'this'.</para>
            /// </remarks>
            public uint getNumCaptures()
            {
                var __ret = Internal.getNumCaptures_0(__Instance);
                return __ret;
            }

            public clang.BlockDecl.Capture capture_begin()
            {
                var __ret = Internal.capture_begin_0(__Instance);
                clang.BlockDecl.Capture __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.BlockDecl.Capture.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.BlockDecl.Capture) clang.BlockDecl.Capture.NativeToManagedMap[__ret];
                else __result0 = clang.BlockDecl.Capture.__CreateInstance(__ret);
                return __result0;
            }

            public clang.BlockDecl.Capture capture_end()
            {
                var __ret = Internal.capture_end_0(__Instance);
                clang.BlockDecl.Capture __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.BlockDecl.Capture.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.BlockDecl.Capture) clang.BlockDecl.Capture.NativeToManagedMap[__ret];
                else __result0 = clang.BlockDecl.Capture.__CreateInstance(__ret);
                return __result0;
            }

            public bool capturesCXXThis()
            {
                var __ret = Internal.capturesCXXThis_0(__Instance);
                return __ret;
            }

            public bool blockMissingReturnType()
            {
                var __ret = Internal.blockMissingReturnType_0(__Instance);
                return __ret;
            }

            public void setBlockMissingReturnType(bool val)
            {
                Internal.setBlockMissingReturnType_0(__Instance, val);
            }

            public bool isConversionFromLambda()
            {
                var __ret = Internal.isConversionFromLambda_0(__Instance);
                return __ret;
            }

            public void setIsConversionFromLambda(bool val)
            {
                Internal.setIsConversionFromLambda_0(__Instance, val);
            }

            public bool capturesVariable(clang.VarDecl var)
            {
                var arg0 = ReferenceEquals(var, null) ? global::System.IntPtr.Zero : var.__Instance;
                var __ret = Internal.capturesVariable_0(__Instance, arg0);
                return __ret;
            }

            public void setCaptures(clang.ASTContext Context, clang.BlockDecl.Capture begin, clang.BlockDecl.Capture end, bool capturesCXXThis)
            {
                var arg0 = ReferenceEquals(Context, null) ? global::System.IntPtr.Zero : Context.__Instance;
                var arg1 = ReferenceEquals(begin, null) ? global::System.IntPtr.Zero : begin.__Instance;
                var arg2 = ReferenceEquals(end, null) ? global::System.IntPtr.Zero : end.__Instance;
                Internal.setCaptures_0(__Instance, arg0, arg1, arg2, capturesCXXThis);
            }

            public uint getBlockManglingNumber()
            {
                var __ret = Internal.getBlockManglingNumber_0(__Instance);
                return __ret;
            }

            public clang.Decl getBlockManglingContextDecl()
            {
                var __ret = Internal.getBlockManglingContextDecl_0(__Instance);
                clang.Decl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Decl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Decl) clang.Decl.NativeToManagedMap[__ret];
                else clang.Decl.NativeToManagedMap[__ret] = __result0 = (clang.Decl) clang.Decl.__CreateInstance(__ret);
                return __result0;
            }

            public void setBlockMangling(uint Number, clang.Decl Ctx)
            {
                var arg1 = ReferenceEquals(Ctx, null) ? global::System.IntPtr.Zero : Ctx.__Instance;
                Internal.setBlockMangling_0(__Instance, Number, arg1);
            }

            public override clang.SourceRange getSourceRange()
            {
                var __ret = Internal.getSourceRange_0(__Instance);
                return clang.SourceRange.__CreateInstance(__ret);
            }

            public static clang.BlockDecl Create(clang.ASTContext C, clang.DeclContext DC, clang.SourceLocation L)
            {
                var arg0 = ReferenceEquals(C, null) ? global::System.IntPtr.Zero : C.__Instance;
                var arg1 = ReferenceEquals(DC, null) ? global::System.IntPtr.Zero : DC.__Instance;
                var arg2 = ReferenceEquals(L, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (L.__Instance);
                var __ret = Internal.Create_0(arg0, arg1, arg2);
                clang.BlockDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.BlockDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.BlockDecl) clang.BlockDecl.NativeToManagedMap[__ret];
                else clang.BlockDecl.NativeToManagedMap[__ret] = __result0 = (clang.BlockDecl) clang.BlockDecl.__CreateInstance(__ret);
                return __result0;
            }

            public static clang.BlockDecl CreateDeserialized(clang.ASTContext C, uint ID)
            {
                var arg0 = ReferenceEquals(C, null) ? global::System.IntPtr.Zero : C.__Instance;
                var __ret = Internal.CreateDeserialized_0(arg0, ID);
                clang.BlockDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.BlockDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.BlockDecl) clang.BlockDecl.NativeToManagedMap[__ret];
                else clang.BlockDecl.NativeToManagedMap[__ret] = __result0 = (clang.BlockDecl) clang.BlockDecl.__CreateInstance(__ret);
                return __result0;
            }

            public static bool classof(clang.Decl D)
            {
                var arg0 = ReferenceEquals(D, null) ? global::System.IntPtr.Zero : D.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }

            public static bool classofKind(clang.Decl.Kind K)
            {
                var arg0 = K;
                var __ret = Internal.classofKind_0(arg0);
                return __ret;
            }

            public static clang.DeclContext castToDeclContext(clang.BlockDecl D)
            {
                var arg0 = ReferenceEquals(D, null) ? global::System.IntPtr.Zero : D.__Instance;
                var __ret = Internal.castToDeclContext_0(arg0);
                clang.DeclContext __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.DeclContext.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.DeclContext) clang.DeclContext.NativeToManagedMap[__ret];
                else __result0 = clang.DeclContext.__CreateInstance(__ret);
                return __result0;
            }

            public static clang.BlockDecl castFromDeclContext(clang.DeclContext DC)
            {
                var arg0 = ReferenceEquals(DC, null) ? global::System.IntPtr.Zero : DC.__Instance;
                var __ret = Internal.castFromDeclContext_0(arg0);
                clang.BlockDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.BlockDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.BlockDecl) clang.BlockDecl.NativeToManagedMap[__ret];
                else clang.BlockDecl.NativeToManagedMap[__ret] = __result0 = (clang.BlockDecl) clang.BlockDecl.__CreateInstance(__ret);
                return __result0;
            }

            #region Virtual table interop

            // BlockDecl
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
            private static _dtor_0Delegate _dtor_0DelegateInstance;

            private static void _dtor_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (BlockDecl) _References[instance].Target;
                __target.DestroyNativeInstance();
            }

            // SourceRange getSourceRange() const override
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate clang.SourceRange.Internal _getSourceRange_0Delegate(global::System.IntPtr instance);
            private static _getSourceRange_0Delegate _getSourceRange_0DelegateInstance;

            private static clang.SourceRange.Internal _getSourceRange_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (BlockDecl) _References[instance].Target;
                var __ret = __target.getSourceRange();
                return ReferenceEquals(__ret, null) ? new clang.SourceRange.Internal() : *(clang.SourceRange.Internal*) (__ret.__Instance);
            }

            // bool isOutOfLine() const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate bool _isOutOfLine_0Delegate(global::System.IntPtr instance);
            private static _isOutOfLine_0Delegate _isOutOfLine_0DelegateInstance;

            private static bool _isOutOfLine_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (BlockDecl) _References[instance].Target;
                var __ret = __target.isOutOfLine();
                return __ret;
            }

            // Decl *getCanonicalDecl()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getCanonicalDecl_0Delegate(global::System.IntPtr instance);
            private static _getCanonicalDecl_0Delegate _getCanonicalDecl_0DelegateInstance;

            private static global::System.IntPtr _getCanonicalDecl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (BlockDecl) _References[instance].Target;
                var __ret = __target.getCanonicalDecl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // Decl *getNextRedeclarationImpl()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getNextRedeclarationImpl_0Delegate(global::System.IntPtr instance);
            private static _getNextRedeclarationImpl_0Delegate _getNextRedeclarationImpl_0DelegateInstance;

            private static global::System.IntPtr _getNextRedeclarationImpl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (BlockDecl) _References[instance].Target;
                var __ret = __target.getNextRedeclarationImpl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // Decl *getPreviousDeclImpl()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getPreviousDeclImpl_0Delegate(global::System.IntPtr instance);
            private static _getPreviousDeclImpl_0Delegate _getPreviousDeclImpl_0DelegateInstance;

            private static global::System.IntPtr _getPreviousDeclImpl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (BlockDecl) _References[instance].Target;
                var __ret = __target.getPreviousDeclImpl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // Decl *getMostRecentDeclImpl()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getMostRecentDeclImpl_0Delegate(global::System.IntPtr instance);
            private static _getMostRecentDeclImpl_0Delegate _getMostRecentDeclImpl_0DelegateInstance;

            private static global::System.IntPtr _getMostRecentDeclImpl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (BlockDecl) _References[instance].Target;
                var __ret = __target.getMostRecentDeclImpl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // Stmt *getBody() const override
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getBody_0Delegate(global::System.IntPtr instance);
            private static _getBody_0Delegate _getBody_0DelegateInstance;

            private static global::System.IntPtr _getBody_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (BlockDecl) _References[instance].Target;
                var __ret = __target.getBody();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // bool hasBody() const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate bool _hasBody_0Delegate(global::System.IntPtr instance);
            private static _hasBody_0Delegate _hasBody_0DelegateInstance;

            private static bool _hasBody_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (BlockDecl) _References[instance].Target;
                var __ret = __target.hasBody();
                return __ret;
            }

            private static void*[] _OldVTables;
            private static void*[] _NewVTables;
            private static void*[] _Thunks;
            private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

            void SetupVTables(global::System.IntPtr instance)
            {
                var native = (Internal*)instance.ToPointer();

                if (_References == null)
                    _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

                if (_References.ContainsKey(instance))
                    return;

                _References[instance] = new WeakReference(this);

                if (_OldVTables == null)
                {
                    _OldVTables = new void*[1];
                    _OldVTables[0] = native->vfptr0.ToPointer();
                }

                if (_Thunks == null)
                {
                    _Thunks = new void*[9];
                    _dtor_0DelegateInstance += _dtor_0DelegateHook;
                    _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                    _getSourceRange_0DelegateInstance += _getSourceRange_0DelegateHook;
                    _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_getSourceRange_0DelegateInstance).ToPointer();
                    _isOutOfLine_0DelegateInstance += _isOutOfLine_0DelegateHook;
                    _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_isOutOfLine_0DelegateInstance).ToPointer();
                    _getCanonicalDecl_0DelegateInstance += _getCanonicalDecl_0DelegateHook;
                    _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_getCanonicalDecl_0DelegateInstance).ToPointer();
                    _getNextRedeclarationImpl_0DelegateInstance += _getNextRedeclarationImpl_0DelegateHook;
                    _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_getNextRedeclarationImpl_0DelegateInstance).ToPointer();
                    _getPreviousDeclImpl_0DelegateInstance += _getPreviousDeclImpl_0DelegateHook;
                    _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_getPreviousDeclImpl_0DelegateInstance).ToPointer();
                    _getMostRecentDeclImpl_0DelegateInstance += _getMostRecentDeclImpl_0DelegateHook;
                    _Thunks[6] = Marshal.GetFunctionPointerForDelegate(_getMostRecentDeclImpl_0DelegateInstance).ToPointer();
                    _getBody_0DelegateInstance += _getBody_0DelegateHook;
                    _Thunks[7] = Marshal.GetFunctionPointerForDelegate(_getBody_0DelegateInstance).ToPointer();
                    _hasBody_0DelegateInstance += _hasBody_0DelegateHook;
                    _Thunks[8] = Marshal.GetFunctionPointerForDelegate(_hasBody_0DelegateInstance).ToPointer();
                }

                if (_NewVTables == null)
                {
                    _NewVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(9 * 8);
                    _NewVTables[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + 8) = _Thunks[0];
                    *(void**)(vfptr0 + 16) = _Thunks[1];
                    *(void**)(vfptr0 + 24) = _Thunks[2];
                    *(void**)(vfptr0 + 32) = _Thunks[3];
                    *(void**)(vfptr0 + 40) = _Thunks[4];
                    *(void**)(vfptr0 + 48) = _Thunks[5];
                    *(void**)(vfptr0 + 56) = _Thunks[6];
                    *(void**)(vfptr0 + 64) = _Thunks[7];
                    *(void**)(vfptr0 + 72) = _Thunks[8];
                }

                native->vfptr0 = new IntPtr(_NewVTables[0]);
            }

            #endregion
        }

        /// <summary>
        /// <para>This represents the body of a CapturedStmt, and serves as its
        /// DeclContext.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief This represents the body of a CapturedStmt, and serves
        /// as its</para>
        /// <para>/// DeclContext.</para>
        /// </remarks>
        public unsafe partial class CapturedDecl : clang.Decl, clang.DeclContext, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 80)]
            public new partial struct Internal
            {
                [FieldOffset(8)]
                internal llvm.PointerIntPair.Internal NextInContextAndBits;

                [FieldOffset(16)]
                internal llvm.PointerUnion.Internal DeclCtx;

                [FieldOffset(24)]
                public clang.SourceLocation.Internal Loc;

                [FieldOffset(28)]
                public uint DeclKind;

                [FieldOffset(29)]
                public uint InvalidDecl;

                [FieldOffset(29)]
                public uint HasAttrs;

                [FieldOffset(29)]
                public uint Implicit;

                [FieldOffset(29)]
                public uint Used;

                [FieldOffset(29)]
                public uint Referenced;

                [FieldOffset(29)]
                public uint Access;

                [FieldOffset(29)]
                public uint FromASTFile;

                [FieldOffset(30)]
                public uint Hidden;

                [FieldOffset(30)]
                public uint IdentifierNamespace;

                [FieldOffset(31)]
                public uint CacheValidAndLinkage;

                [FieldOffset(0)]
                public uint DeclKind;

                [FieldOffset(1)]
                public bool ExternalLexicalStorage;

                [FieldOffset(1)]
                public bool ExternalVisibleStorage;

                [FieldOffset(1)]
                public bool NeedToReconcileExternalVisibleStorage;

                [FieldOffset(8)]
                internal llvm.PointerIntPair.Internal LookupPtr;

                [FieldOffset(16)]
                public global::System.IntPtr FirstDecl;

                [FieldOffset(24)]
                public global::System.IntPtr LastDecl;

                [FieldOffset(64)]
                public uint NumParams;

                [FieldOffset(68)]
                public uint ContextParam;

                [FieldOffset(72)]
                internal llvm.PointerIntPair.Internal BodyAndNothrow;

                [FieldOffset(0)]
                public global::System.IntPtr vfptr0;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12CapturedDeclC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12CapturedDeclD2Ev")]
                internal static extern void dtor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12CapturedDecl6CreateERNS_10ASTContextEPNS_11DeclContextEj")]
                internal static extern global::System.IntPtr Create_0(global::System.IntPtr C, global::System.IntPtr DC, uint NumParams);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12CapturedDecl18CreateDeserializedERNS_10ASTContextEjj")]
                internal static extern global::System.IntPtr CreateDeserialized_0(global::System.IntPtr C, uint ID, uint NumParams);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12CapturedDecl7getBodyEv")]
                internal static extern global::System.IntPtr getBody_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12CapturedDecl7setBodyEPNS_4StmtE")]
                internal static extern void setBody_0(global::System.IntPtr instance, global::System.IntPtr B);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12CapturedDecl9isNothrowEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isNothrow_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12CapturedDecl10setNothrowEb")]
                internal static extern void setNothrow_0(global::System.IntPtr instance, bool Nothrow);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12CapturedDecl12getNumParamsEv")]
                internal static extern uint getNumParams_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12CapturedDecl8getParamEj")]
                internal static extern global::System.IntPtr getParam_0(global::System.IntPtr instance, uint i);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12CapturedDecl8setParamEjPNS_17ImplicitParamDeclE")]
                internal static extern void setParam_0(global::System.IntPtr instance, uint i, global::System.IntPtr P);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12CapturedDecl15getContextParamEv")]
                internal static extern global::System.IntPtr getContextParam_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12CapturedDecl15setContextParamEjPNS_17ImplicitParamDeclE")]
                internal static extern void setContextParam_0(global::System.IntPtr instance, uint i, global::System.IntPtr P);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12CapturedDecl23getContextParamPositionEv")]
                internal static extern uint getContextParamPosition_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12CapturedDecl11param_beginEv")]
                internal static extern global::System.IntPtr param_begin_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang12CapturedDecl9param_endEv")]
                internal static extern global::System.IntPtr param_end_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12CapturedDecl7classofEPKNS_4DeclE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr D);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12CapturedDecl11classofKindENS_4Decl4KindE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classofKind_0(clang.Decl.Kind K);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12CapturedDecl17castToDeclContextEPKS0_")]
                internal static extern global::System.IntPtr castToDeclContext_0(global::System.IntPtr D);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang12CapturedDecl19castFromDeclContextEPKNS_11DeclContextE")]
                internal static extern global::System.IntPtr castFromDeclContext_0(global::System.IntPtr DC);
            }

            private readonly bool __ownsNativeInstance;

            public static new CapturedDecl __CreateInstance(global::System.IntPtr native)
            {
                return new CapturedDecl((CapturedDecl.Internal*) native);
            }

            public static CapturedDecl __CreateInstance(CapturedDecl.Internal native)
            {
                return new CapturedDecl(native);
            }

            private static CapturedDecl.Internal* __CopyValue(CapturedDecl.Internal native)
            {
                var ret = (CapturedDecl.Internal*) Marshal.AllocHGlobal(80);
                *ret = native;
                return ret;
            }

            private CapturedDecl(CapturedDecl.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected CapturedDecl(CapturedDecl.Internal* native, bool isInternalImpl = false)
                : base((clang.Decl.Internal*) native)
            {
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Decl __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public override clang.Stmt getBody()
            {
                var __ret = Internal.getBody_0(__Instance);
                clang.Stmt __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.Stmt.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.Stmt) clang.Stmt.NativeToManagedMap[__ret];
                else __result0 = clang.Stmt.__CreateInstance(__ret);
                return __result0;
            }

            public void setBody(clang.Stmt B)
            {
                var arg0 = ReferenceEquals(B, null) ? global::System.IntPtr.Zero : B.__Instance;
                Internal.setBody_0(__Instance, arg0);
            }

            public bool isNothrow()
            {
                var __ret = Internal.isNothrow_0(__Instance);
                return __ret;
            }

            public void setNothrow(bool Nothrow)
            {
                Internal.setNothrow_0(__Instance, Nothrow);
            }

            public uint getNumParams()
            {
                var __ret = Internal.getNumParams_0(__Instance);
                return __ret;
            }

            public clang.ImplicitParamDecl getParam(uint i)
            {
                var __ret = Internal.getParam_0(__Instance, i);
                clang.ImplicitParamDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.ImplicitParamDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.ImplicitParamDecl) clang.ImplicitParamDecl.NativeToManagedMap[__ret];
                else clang.ImplicitParamDecl.NativeToManagedMap[__ret] = __result0 = (clang.ImplicitParamDecl) clang.ImplicitParamDecl.__CreateInstance(__ret);
                return __result0;
            }

            public void setParam(uint i, clang.ImplicitParamDecl P)
            {
                var arg1 = ReferenceEquals(P, null) ? global::System.IntPtr.Zero : P.__Instance;
                Internal.setParam_0(__Instance, i, arg1);
            }

            /// <summary>
            /// <para>Retrieve the parameter containing captured variables.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve the parameter containing captured
            /// variables.</para>
            /// </remarks>
            public clang.ImplicitParamDecl getContextParam()
            {
                var __ret = Internal.getContextParam_0(__Instance);
                clang.ImplicitParamDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.ImplicitParamDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.ImplicitParamDecl) clang.ImplicitParamDecl.NativeToManagedMap[__ret];
                else clang.ImplicitParamDecl.NativeToManagedMap[__ret] = __result0 = (clang.ImplicitParamDecl) clang.ImplicitParamDecl.__CreateInstance(__ret);
                return __result0;
            }

            public void setContextParam(uint i, clang.ImplicitParamDecl P)
            {
                var arg1 = ReferenceEquals(P, null) ? global::System.IntPtr.Zero : P.__Instance;
                Internal.setContextParam_0(__Instance, i, arg1);
            }

            public uint getContextParamPosition()
            {
                var __ret = Internal.getContextParamPosition_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Retrieve an iterator pointing to the first parameter decl.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve an iterator pointing to the first parameter
            /// decl.</para>
            /// </remarks>
            public clang.ImplicitParamDecl param_begin()
            {
                var __ret = Internal.param_begin_0(__Instance);
                clang.ImplicitParamDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.ImplicitParamDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.ImplicitParamDecl) clang.ImplicitParamDecl.NativeToManagedMap[__ret];
                else clang.ImplicitParamDecl.NativeToManagedMap[__ret] = __result0 = (clang.ImplicitParamDecl) clang.ImplicitParamDecl.__CreateInstance(__ret);
                return __result0;
            }

            /// <summary>
            /// <para>Retrieve an iterator one past the last parameter decl.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Retrieve an iterator one past the last parameter
            /// decl.</para>
            /// </remarks>
            public clang.ImplicitParamDecl param_end()
            {
                var __ret = Internal.param_end_0(__Instance);
                clang.ImplicitParamDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.ImplicitParamDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.ImplicitParamDecl) clang.ImplicitParamDecl.NativeToManagedMap[__ret];
                else clang.ImplicitParamDecl.NativeToManagedMap[__ret] = __result0 = (clang.ImplicitParamDecl) clang.ImplicitParamDecl.__CreateInstance(__ret);
                return __result0;
            }

            public static clang.CapturedDecl Create(clang.ASTContext C, clang.DeclContext DC, uint NumParams)
            {
                var arg0 = ReferenceEquals(C, null) ? global::System.IntPtr.Zero : C.__Instance;
                var arg1 = ReferenceEquals(DC, null) ? global::System.IntPtr.Zero : DC.__Instance;
                var __ret = Internal.Create_0(arg0, arg1, NumParams);
                clang.CapturedDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.CapturedDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.CapturedDecl) clang.CapturedDecl.NativeToManagedMap[__ret];
                else clang.CapturedDecl.NativeToManagedMap[__ret] = __result0 = (clang.CapturedDecl) clang.CapturedDecl.__CreateInstance(__ret);
                return __result0;
            }

            public static clang.CapturedDecl CreateDeserialized(clang.ASTContext C, uint ID, uint NumParams)
            {
                var arg0 = ReferenceEquals(C, null) ? global::System.IntPtr.Zero : C.__Instance;
                var __ret = Internal.CreateDeserialized_0(arg0, ID, NumParams);
                clang.CapturedDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.CapturedDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.CapturedDecl) clang.CapturedDecl.NativeToManagedMap[__ret];
                else clang.CapturedDecl.NativeToManagedMap[__ret] = __result0 = (clang.CapturedDecl) clang.CapturedDecl.__CreateInstance(__ret);
                return __result0;
            }

            public static bool classof(clang.Decl D)
            {
                var arg0 = ReferenceEquals(D, null) ? global::System.IntPtr.Zero : D.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }

            public static bool classofKind(clang.Decl.Kind K)
            {
                var arg0 = K;
                var __ret = Internal.classofKind_0(arg0);
                return __ret;
            }

            public static clang.DeclContext castToDeclContext(clang.CapturedDecl D)
            {
                var arg0 = ReferenceEquals(D, null) ? global::System.IntPtr.Zero : D.__Instance;
                var __ret = Internal.castToDeclContext_0(arg0);
                clang.DeclContext __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.DeclContext.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.DeclContext) clang.DeclContext.NativeToManagedMap[__ret];
                else __result0 = clang.DeclContext.__CreateInstance(__ret);
                return __result0;
            }

            public static clang.CapturedDecl castFromDeclContext(clang.DeclContext DC)
            {
                var arg0 = ReferenceEquals(DC, null) ? global::System.IntPtr.Zero : DC.__Instance;
                var __ret = Internal.castFromDeclContext_0(arg0);
                clang.CapturedDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.CapturedDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.CapturedDecl) clang.CapturedDecl.NativeToManagedMap[__ret];
                else clang.CapturedDecl.NativeToManagedMap[__ret] = __result0 = (clang.CapturedDecl) clang.CapturedDecl.__CreateInstance(__ret);
                return __result0;
            }

            #region Virtual table interop

            // CapturedDecl
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
            private static _dtor_0Delegate _dtor_0DelegateInstance;

            private static void _dtor_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (CapturedDecl) _References[instance].Target;
                __target.DestroyNativeInstance();
            }

            // SourceRange getSourceRange() const LLVM_READONLY
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate clang.SourceRange.Internal _getSourceRange_0Delegate(global::System.IntPtr instance);
            private static _getSourceRange_0Delegate _getSourceRange_0DelegateInstance;

            private static clang.SourceRange.Internal _getSourceRange_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (CapturedDecl) _References[instance].Target;
                var __ret = __target.getSourceRange();
                return ReferenceEquals(__ret, null) ? new clang.SourceRange.Internal() : *(clang.SourceRange.Internal*) (__ret.__Instance);
            }

            // bool isOutOfLine() const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate bool _isOutOfLine_0Delegate(global::System.IntPtr instance);
            private static _isOutOfLine_0Delegate _isOutOfLine_0DelegateInstance;

            private static bool _isOutOfLine_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (CapturedDecl) _References[instance].Target;
                var __ret = __target.isOutOfLine();
                return __ret;
            }

            // Decl *getCanonicalDecl()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getCanonicalDecl_0Delegate(global::System.IntPtr instance);
            private static _getCanonicalDecl_0Delegate _getCanonicalDecl_0DelegateInstance;

            private static global::System.IntPtr _getCanonicalDecl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (CapturedDecl) _References[instance].Target;
                var __ret = __target.getCanonicalDecl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // Decl *getNextRedeclarationImpl()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getNextRedeclarationImpl_0Delegate(global::System.IntPtr instance);
            private static _getNextRedeclarationImpl_0Delegate _getNextRedeclarationImpl_0DelegateInstance;

            private static global::System.IntPtr _getNextRedeclarationImpl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (CapturedDecl) _References[instance].Target;
                var __ret = __target.getNextRedeclarationImpl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // Decl *getPreviousDeclImpl()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getPreviousDeclImpl_0Delegate(global::System.IntPtr instance);
            private static _getPreviousDeclImpl_0Delegate _getPreviousDeclImpl_0DelegateInstance;

            private static global::System.IntPtr _getPreviousDeclImpl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (CapturedDecl) _References[instance].Target;
                var __ret = __target.getPreviousDeclImpl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // Decl *getMostRecentDeclImpl()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getMostRecentDeclImpl_0Delegate(global::System.IntPtr instance);
            private static _getMostRecentDeclImpl_0Delegate _getMostRecentDeclImpl_0DelegateInstance;

            private static global::System.IntPtr _getMostRecentDeclImpl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (CapturedDecl) _References[instance].Target;
                var __ret = __target.getMostRecentDeclImpl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // Stmt *getBody() const override
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getBody_0Delegate(global::System.IntPtr instance);
            private static _getBody_0Delegate _getBody_0DelegateInstance;

            private static global::System.IntPtr _getBody_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (CapturedDecl) _References[instance].Target;
                var __ret = __target.getBody();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // bool hasBody() const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate bool _hasBody_0Delegate(global::System.IntPtr instance);
            private static _hasBody_0Delegate _hasBody_0DelegateInstance;

            private static bool _hasBody_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (CapturedDecl) _References[instance].Target;
                var __ret = __target.hasBody();
                return __ret;
            }

            private static void*[] _OldVTables;
            private static void*[] _NewVTables;
            private static void*[] _Thunks;
            private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

            void SetupVTables(global::System.IntPtr instance)
            {
                var native = (Internal*)instance.ToPointer();

                if (_References == null)
                    _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

                if (_References.ContainsKey(instance))
                    return;

                _References[instance] = new WeakReference(this);

                if (_OldVTables == null)
                {
                    _OldVTables = new void*[1];
                    _OldVTables[0] = native->vfptr0.ToPointer();
                }

                if (_Thunks == null)
                {
                    _Thunks = new void*[9];
                    _dtor_0DelegateInstance += _dtor_0DelegateHook;
                    _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                    _getSourceRange_0DelegateInstance += _getSourceRange_0DelegateHook;
                    _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_getSourceRange_0DelegateInstance).ToPointer();
                    _isOutOfLine_0DelegateInstance += _isOutOfLine_0DelegateHook;
                    _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_isOutOfLine_0DelegateInstance).ToPointer();
                    _getCanonicalDecl_0DelegateInstance += _getCanonicalDecl_0DelegateHook;
                    _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_getCanonicalDecl_0DelegateInstance).ToPointer();
                    _getNextRedeclarationImpl_0DelegateInstance += _getNextRedeclarationImpl_0DelegateHook;
                    _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_getNextRedeclarationImpl_0DelegateInstance).ToPointer();
                    _getPreviousDeclImpl_0DelegateInstance += _getPreviousDeclImpl_0DelegateHook;
                    _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_getPreviousDeclImpl_0DelegateInstance).ToPointer();
                    _getMostRecentDeclImpl_0DelegateInstance += _getMostRecentDeclImpl_0DelegateHook;
                    _Thunks[6] = Marshal.GetFunctionPointerForDelegate(_getMostRecentDeclImpl_0DelegateInstance).ToPointer();
                    _getBody_0DelegateInstance += _getBody_0DelegateHook;
                    _Thunks[7] = Marshal.GetFunctionPointerForDelegate(_getBody_0DelegateInstance).ToPointer();
                    _hasBody_0DelegateInstance += _hasBody_0DelegateHook;
                    _Thunks[8] = Marshal.GetFunctionPointerForDelegate(_hasBody_0DelegateInstance).ToPointer();
                }

                if (_NewVTables == null)
                {
                    _NewVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(9 * 8);
                    _NewVTables[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + 8) = _Thunks[0];
                    *(void**)(vfptr0 + 16) = _Thunks[1];
                    *(void**)(vfptr0 + 24) = _Thunks[2];
                    *(void**)(vfptr0 + 32) = _Thunks[3];
                    *(void**)(vfptr0 + 40) = _Thunks[4];
                    *(void**)(vfptr0 + 48) = _Thunks[5];
                    *(void**)(vfptr0 + 56) = _Thunks[6];
                    *(void**)(vfptr0 + 64) = _Thunks[7];
                    *(void**)(vfptr0 + 72) = _Thunks[8];
                }

                native->vfptr0 = new IntPtr(_NewVTables[0]);
            }

            #endregion
        }

        /// <summary>
        /// <para>Describes a module import declaration, which makes the contents
        /// of the named module visible in the current translation unit.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief Describes a module import declaration, which makes the
        /// contents</para>
        /// <para>/// of the named module visible in the current translation
        /// unit.</para>
        /// <para>///</para>
        /// <para>/// An import declaration imports the named module (or
        /// submodule). For example:</para>
        /// <para>/// \code</para>
        /// <para>///   @import std.vector;</para>
        /// <para>/// \endcode</para>
        /// <para>///</para>
        /// <para>/// Import declarations can also be implicitly generated
        /// from</para>
        /// <para>/// \#include/\#import directives.</para>
        /// </remarks>
        public unsafe partial class ImportDecl : clang.Decl, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 48)]
            public new partial struct Internal
            {
                [FieldOffset(8)]
                internal llvm.PointerIntPair.Internal NextInContextAndBits;

                [FieldOffset(16)]
                internal llvm.PointerUnion.Internal DeclCtx;

                [FieldOffset(24)]
                public clang.SourceLocation.Internal Loc;

                [FieldOffset(28)]
                public uint DeclKind;

                [FieldOffset(29)]
                public uint InvalidDecl;

                [FieldOffset(29)]
                public uint HasAttrs;

                [FieldOffset(29)]
                public uint Implicit;

                [FieldOffset(29)]
                public uint Used;

                [FieldOffset(29)]
                public uint Referenced;

                [FieldOffset(29)]
                public uint Access;

                [FieldOffset(29)]
                public uint FromASTFile;

                [FieldOffset(30)]
                public uint Hidden;

                [FieldOffset(30)]
                public uint IdentifierNamespace;

                [FieldOffset(31)]
                public uint CacheValidAndLinkage;

                [FieldOffset(32)]
                internal llvm.PointerIntPair.Internal ImportedAndComplete;

                [FieldOffset(40)]
                public global::System.IntPtr NextLocalImport;

                [FieldOffset(0)]
                public global::System.IntPtr vfptr0;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ImportDeclC2ERKS0_")]
                internal static extern void cctor_3(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ImportDeclD2Ev")]
                internal static extern void dtor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ImportDecl18CreateDeserializedERNS_10ASTContextEjj")]
                internal static extern global::System.IntPtr CreateDeserialized_0(global::System.IntPtr C, uint ID, uint NumLocations);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang10ImportDecl14getSourceRangeEv")]
                internal static extern clang.SourceRange.Internal getSourceRange_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ImportDecl7classofEPKNS_4DeclE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr D);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang10ImportDecl11classofKindENS_4Decl4KindE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classofKind_0(clang.Decl.Kind K);
            }

            private readonly bool __ownsNativeInstance;

            public static new ImportDecl __CreateInstance(global::System.IntPtr native)
            {
                return new ImportDecl((ImportDecl.Internal*) native);
            }

            public static ImportDecl __CreateInstance(ImportDecl.Internal native)
            {
                return new ImportDecl(native);
            }

            private static ImportDecl.Internal* __CopyValue(ImportDecl.Internal native)
            {
                var ret = (ImportDecl.Internal*) Marshal.AllocHGlobal(48);
                *ret = native;
                return ret;
            }

            private ImportDecl(ImportDecl.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected ImportDecl(ImportDecl.Internal* native, bool isInternalImpl = false)
                : base((clang.Decl.Internal*) native)
            {
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Decl __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public override clang.SourceRange getSourceRange()
            {
                var __ret = Internal.getSourceRange_0(__Instance);
                return clang.SourceRange.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Create a new, deserialized module import declaration.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Create a new, deserialized module import
            /// declaration.</para>
            /// </remarks>
            public static clang.ImportDecl CreateDeserialized(clang.ASTContext C, uint ID, uint NumLocations)
            {
                var arg0 = ReferenceEquals(C, null) ? global::System.IntPtr.Zero : C.__Instance;
                var __ret = Internal.CreateDeserialized_0(arg0, ID, NumLocations);
                clang.ImportDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.ImportDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.ImportDecl) clang.ImportDecl.NativeToManagedMap[__ret];
                else clang.ImportDecl.NativeToManagedMap[__ret] = __result0 = (clang.ImportDecl) clang.ImportDecl.__CreateInstance(__ret);
                return __result0;
            }

            public static bool classof(clang.Decl D)
            {
                var arg0 = ReferenceEquals(D, null) ? global::System.IntPtr.Zero : D.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }

            public static bool classofKind(clang.Decl.Kind K)
            {
                var arg0 = K;
                var __ret = Internal.classofKind_0(arg0);
                return __ret;
            }

            #region Virtual table interop

            // ImportDecl
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
            private static _dtor_0Delegate _dtor_0DelegateInstance;

            private static void _dtor_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (ImportDecl) _References[instance].Target;
                __target.DestroyNativeInstance();
            }

            // SourceRange getSourceRange() const override
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate clang.SourceRange.Internal _getSourceRange_0Delegate(global::System.IntPtr instance);
            private static _getSourceRange_0Delegate _getSourceRange_0DelegateInstance;

            private static clang.SourceRange.Internal _getSourceRange_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (ImportDecl) _References[instance].Target;
                var __ret = __target.getSourceRange();
                return ReferenceEquals(__ret, null) ? new clang.SourceRange.Internal() : *(clang.SourceRange.Internal*) (__ret.__Instance);
            }

            // bool isOutOfLine() const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate bool _isOutOfLine_0Delegate(global::System.IntPtr instance);
            private static _isOutOfLine_0Delegate _isOutOfLine_0DelegateInstance;

            private static bool _isOutOfLine_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (ImportDecl) _References[instance].Target;
                var __ret = __target.isOutOfLine();
                return __ret;
            }

            // Decl *getCanonicalDecl()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getCanonicalDecl_0Delegate(global::System.IntPtr instance);
            private static _getCanonicalDecl_0Delegate _getCanonicalDecl_0DelegateInstance;

            private static global::System.IntPtr _getCanonicalDecl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (ImportDecl) _References[instance].Target;
                var __ret = __target.getCanonicalDecl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // Decl *getNextRedeclarationImpl()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getNextRedeclarationImpl_0Delegate(global::System.IntPtr instance);
            private static _getNextRedeclarationImpl_0Delegate _getNextRedeclarationImpl_0DelegateInstance;

            private static global::System.IntPtr _getNextRedeclarationImpl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (ImportDecl) _References[instance].Target;
                var __ret = __target.getNextRedeclarationImpl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // Decl *getPreviousDeclImpl()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getPreviousDeclImpl_0Delegate(global::System.IntPtr instance);
            private static _getPreviousDeclImpl_0Delegate _getPreviousDeclImpl_0DelegateInstance;

            private static global::System.IntPtr _getPreviousDeclImpl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (ImportDecl) _References[instance].Target;
                var __ret = __target.getPreviousDeclImpl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // Decl *getMostRecentDeclImpl()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getMostRecentDeclImpl_0Delegate(global::System.IntPtr instance);
            private static _getMostRecentDeclImpl_0Delegate _getMostRecentDeclImpl_0DelegateInstance;

            private static global::System.IntPtr _getMostRecentDeclImpl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (ImportDecl) _References[instance].Target;
                var __ret = __target.getMostRecentDeclImpl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // Stmt* getBody() const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getBody_0Delegate(global::System.IntPtr instance);
            private static _getBody_0Delegate _getBody_0DelegateInstance;

            private static global::System.IntPtr _getBody_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (ImportDecl) _References[instance].Target;
                var __ret = __target.getBody();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // bool hasBody() const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate bool _hasBody_0Delegate(global::System.IntPtr instance);
            private static _hasBody_0Delegate _hasBody_0DelegateInstance;

            private static bool _hasBody_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (ImportDecl) _References[instance].Target;
                var __ret = __target.hasBody();
                return __ret;
            }

            private static void*[] _OldVTables;
            private static void*[] _NewVTables;
            private static void*[] _Thunks;
            private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

            void SetupVTables(global::System.IntPtr instance)
            {
                var native = (Internal*)instance.ToPointer();

                if (_References == null)
                    _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

                if (_References.ContainsKey(instance))
                    return;

                _References[instance] = new WeakReference(this);

                if (_OldVTables == null)
                {
                    _OldVTables = new void*[1];
                    _OldVTables[0] = native->vfptr0.ToPointer();
                }

                if (_Thunks == null)
                {
                    _Thunks = new void*[9];
                    _dtor_0DelegateInstance += _dtor_0DelegateHook;
                    _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                    _getSourceRange_0DelegateInstance += _getSourceRange_0DelegateHook;
                    _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_getSourceRange_0DelegateInstance).ToPointer();
                    _isOutOfLine_0DelegateInstance += _isOutOfLine_0DelegateHook;
                    _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_isOutOfLine_0DelegateInstance).ToPointer();
                    _getCanonicalDecl_0DelegateInstance += _getCanonicalDecl_0DelegateHook;
                    _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_getCanonicalDecl_0DelegateInstance).ToPointer();
                    _getNextRedeclarationImpl_0DelegateInstance += _getNextRedeclarationImpl_0DelegateHook;
                    _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_getNextRedeclarationImpl_0DelegateInstance).ToPointer();
                    _getPreviousDeclImpl_0DelegateInstance += _getPreviousDeclImpl_0DelegateHook;
                    _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_getPreviousDeclImpl_0DelegateInstance).ToPointer();
                    _getMostRecentDeclImpl_0DelegateInstance += _getMostRecentDeclImpl_0DelegateHook;
                    _Thunks[6] = Marshal.GetFunctionPointerForDelegate(_getMostRecentDeclImpl_0DelegateInstance).ToPointer();
                    _getBody_0DelegateInstance += _getBody_0DelegateHook;
                    _Thunks[7] = Marshal.GetFunctionPointerForDelegate(_getBody_0DelegateInstance).ToPointer();
                    _hasBody_0DelegateInstance += _hasBody_0DelegateHook;
                    _Thunks[8] = Marshal.GetFunctionPointerForDelegate(_hasBody_0DelegateInstance).ToPointer();
                }

                if (_NewVTables == null)
                {
                    _NewVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(9 * 8);
                    _NewVTables[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + 8) = _Thunks[0];
                    *(void**)(vfptr0 + 16) = _Thunks[1];
                    *(void**)(vfptr0 + 24) = _Thunks[2];
                    *(void**)(vfptr0 + 32) = _Thunks[3];
                    *(void**)(vfptr0 + 40) = _Thunks[4];
                    *(void**)(vfptr0 + 48) = _Thunks[5];
                    *(void**)(vfptr0 + 56) = _Thunks[6];
                    *(void**)(vfptr0 + 64) = _Thunks[7];
                    *(void**)(vfptr0 + 72) = _Thunks[8];
                }

                native->vfptr0 = new IntPtr(_NewVTables[0]);
            }

            #endregion
        }

        /// <summary>
        /// <para>Represents an empty-declaration.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief Represents an empty-declaration.</para>
        /// </remarks>
        public unsafe partial class EmptyDecl : clang.Decl, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 32)]
            public new partial struct Internal
            {
                [FieldOffset(8)]
                internal llvm.PointerIntPair.Internal NextInContextAndBits;

                [FieldOffset(16)]
                internal llvm.PointerUnion.Internal DeclCtx;

                [FieldOffset(24)]
                public clang.SourceLocation.Internal Loc;

                [FieldOffset(28)]
                public uint DeclKind;

                [FieldOffset(29)]
                public uint InvalidDecl;

                [FieldOffset(29)]
                public uint HasAttrs;

                [FieldOffset(29)]
                public uint Implicit;

                [FieldOffset(29)]
                public uint Used;

                [FieldOffset(29)]
                public uint Referenced;

                [FieldOffset(29)]
                public uint Access;

                [FieldOffset(29)]
                public uint FromASTFile;

                [FieldOffset(30)]
                public uint Hidden;

                [FieldOffset(30)]
                public uint IdentifierNamespace;

                [FieldOffset(31)]
                public uint CacheValidAndLinkage;

                [FieldOffset(0)]
                public global::System.IntPtr vfptr0;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9EmptyDeclC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9EmptyDeclD2Ev")]
                internal static extern void dtor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9EmptyDecl6CreateERNS_10ASTContextEPNS_11DeclContextENS_14SourceLocationE")]
                internal static extern global::System.IntPtr Create_0(global::System.IntPtr C, global::System.IntPtr DC, clang.SourceLocation.Internal L);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9EmptyDecl18CreateDeserializedERNS_10ASTContextEj")]
                internal static extern global::System.IntPtr CreateDeserialized_0(global::System.IntPtr C, uint ID);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9EmptyDecl7classofEPKNS_4DeclE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classof_0(global::System.IntPtr D);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang9EmptyDecl11classofKindENS_4Decl4KindE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool classofKind_0(clang.Decl.Kind K);
            }

            private readonly bool __ownsNativeInstance;

            public static new EmptyDecl __CreateInstance(global::System.IntPtr native)
            {
                return new EmptyDecl((EmptyDecl.Internal*) native);
            }

            public static EmptyDecl __CreateInstance(EmptyDecl.Internal native)
            {
                return new EmptyDecl(native);
            }

            private static EmptyDecl.Internal* __CopyValue(EmptyDecl.Internal native)
            {
                var ret = (EmptyDecl.Internal*) Marshal.AllocHGlobal(32);
                *ret = native;
                return ret;
            }

            private EmptyDecl(EmptyDecl.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected EmptyDecl(EmptyDecl.Internal* native, bool isInternalImpl = false)
                : base((clang.Decl.Internal*) native)
            {
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.Decl __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public static clang.EmptyDecl Create(clang.ASTContext C, clang.DeclContext DC, clang.SourceLocation L)
            {
                var arg0 = ReferenceEquals(C, null) ? global::System.IntPtr.Zero : C.__Instance;
                var arg1 = ReferenceEquals(DC, null) ? global::System.IntPtr.Zero : DC.__Instance;
                var arg2 = ReferenceEquals(L, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (L.__Instance);
                var __ret = Internal.Create_0(arg0, arg1, arg2);
                clang.EmptyDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.EmptyDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.EmptyDecl) clang.EmptyDecl.NativeToManagedMap[__ret];
                else clang.EmptyDecl.NativeToManagedMap[__ret] = __result0 = (clang.EmptyDecl) clang.EmptyDecl.__CreateInstance(__ret);
                return __result0;
            }

            public static clang.EmptyDecl CreateDeserialized(clang.ASTContext C, uint ID)
            {
                var arg0 = ReferenceEquals(C, null) ? global::System.IntPtr.Zero : C.__Instance;
                var __ret = Internal.CreateDeserialized_0(arg0, ID);
                clang.EmptyDecl __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.EmptyDecl.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.EmptyDecl) clang.EmptyDecl.NativeToManagedMap[__ret];
                else clang.EmptyDecl.NativeToManagedMap[__ret] = __result0 = (clang.EmptyDecl) clang.EmptyDecl.__CreateInstance(__ret);
                return __result0;
            }

            public static bool classof(clang.Decl D)
            {
                var arg0 = ReferenceEquals(D, null) ? global::System.IntPtr.Zero : D.__Instance;
                var __ret = Internal.classof_0(arg0);
                return __ret;
            }

            public static bool classofKind(clang.Decl.Kind K)
            {
                var arg0 = K;
                var __ret = Internal.classofKind_0(arg0);
                return __ret;
            }

            #region Virtual table interop

            // EmptyDecl
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate void _dtor_0Delegate(global::System.IntPtr instance);
            private static _dtor_0Delegate _dtor_0DelegateInstance;

            private static void _dtor_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (EmptyDecl) _References[instance].Target;
                __target.DestroyNativeInstance();
            }

            // SourceRange getSourceRange() const LLVM_READONLY
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate clang.SourceRange.Internal _getSourceRange_0Delegate(global::System.IntPtr instance);
            private static _getSourceRange_0Delegate _getSourceRange_0DelegateInstance;

            private static clang.SourceRange.Internal _getSourceRange_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (EmptyDecl) _References[instance].Target;
                var __ret = __target.getSourceRange();
                return ReferenceEquals(__ret, null) ? new clang.SourceRange.Internal() : *(clang.SourceRange.Internal*) (__ret.__Instance);
            }

            // bool isOutOfLine() const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate bool _isOutOfLine_0Delegate(global::System.IntPtr instance);
            private static _isOutOfLine_0Delegate _isOutOfLine_0DelegateInstance;

            private static bool _isOutOfLine_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (EmptyDecl) _References[instance].Target;
                var __ret = __target.isOutOfLine();
                return __ret;
            }

            // Decl *getCanonicalDecl()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getCanonicalDecl_0Delegate(global::System.IntPtr instance);
            private static _getCanonicalDecl_0Delegate _getCanonicalDecl_0DelegateInstance;

            private static global::System.IntPtr _getCanonicalDecl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (EmptyDecl) _References[instance].Target;
                var __ret = __target.getCanonicalDecl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // Decl *getNextRedeclarationImpl()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getNextRedeclarationImpl_0Delegate(global::System.IntPtr instance);
            private static _getNextRedeclarationImpl_0Delegate _getNextRedeclarationImpl_0DelegateInstance;

            private static global::System.IntPtr _getNextRedeclarationImpl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (EmptyDecl) _References[instance].Target;
                var __ret = __target.getNextRedeclarationImpl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // Decl *getPreviousDeclImpl()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getPreviousDeclImpl_0Delegate(global::System.IntPtr instance);
            private static _getPreviousDeclImpl_0Delegate _getPreviousDeclImpl_0DelegateInstance;

            private static global::System.IntPtr _getPreviousDeclImpl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (EmptyDecl) _References[instance].Target;
                var __ret = __target.getPreviousDeclImpl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // Decl *getMostRecentDeclImpl()
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getMostRecentDeclImpl_0Delegate(global::System.IntPtr instance);
            private static _getMostRecentDeclImpl_0Delegate _getMostRecentDeclImpl_0DelegateInstance;

            private static global::System.IntPtr _getMostRecentDeclImpl_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (EmptyDecl) _References[instance].Target;
                var __ret = __target.getMostRecentDeclImpl();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // Stmt* getBody() const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate global::System.IntPtr _getBody_0Delegate(global::System.IntPtr instance);
            private static _getBody_0Delegate _getBody_0DelegateInstance;

            private static global::System.IntPtr _getBody_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (EmptyDecl) _References[instance].Target;
                var __ret = __target.getBody();
                return ReferenceEquals(__ret, null) ? global::System.IntPtr.Zero : __ret.__Instance;
            }

            // bool hasBody() const
            [SuppressUnmanagedCodeSecurity]
            [UnmanagedFunctionPointerAttribute(global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
            internal delegate bool _hasBody_0Delegate(global::System.IntPtr instance);
            private static _hasBody_0Delegate _hasBody_0DelegateInstance;

            private static bool _hasBody_0DelegateHook(global::System.IntPtr instance)
            {
                if (!_References.ContainsKey(instance))
                    throw new global::System.Exception("No managed instance was found");

                var __target = (EmptyDecl) _References[instance].Target;
                var __ret = __target.hasBody();
                return __ret;
            }

            private static void*[] _OldVTables;
            private static void*[] _NewVTables;
            private static void*[] _Thunks;
            private static System.Collections.Generic.Dictionary<IntPtr, WeakReference> _References;

            void SetupVTables(global::System.IntPtr instance)
            {
                var native = (Internal*)instance.ToPointer();

                if (_References == null)
                    _References = new System.Collections.Generic.Dictionary<IntPtr, WeakReference>();

                if (_References.ContainsKey(instance))
                    return;

                _References[instance] = new WeakReference(this);

                if (_OldVTables == null)
                {
                    _OldVTables = new void*[1];
                    _OldVTables[0] = native->vfptr0.ToPointer();
                }

                if (_Thunks == null)
                {
                    _Thunks = new void*[9];
                    _dtor_0DelegateInstance += _dtor_0DelegateHook;
                    _Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtor_0DelegateInstance).ToPointer();
                    _getSourceRange_0DelegateInstance += _getSourceRange_0DelegateHook;
                    _Thunks[1] = Marshal.GetFunctionPointerForDelegate(_getSourceRange_0DelegateInstance).ToPointer();
                    _isOutOfLine_0DelegateInstance += _isOutOfLine_0DelegateHook;
                    _Thunks[2] = Marshal.GetFunctionPointerForDelegate(_isOutOfLine_0DelegateInstance).ToPointer();
                    _getCanonicalDecl_0DelegateInstance += _getCanonicalDecl_0DelegateHook;
                    _Thunks[3] = Marshal.GetFunctionPointerForDelegate(_getCanonicalDecl_0DelegateInstance).ToPointer();
                    _getNextRedeclarationImpl_0DelegateInstance += _getNextRedeclarationImpl_0DelegateHook;
                    _Thunks[4] = Marshal.GetFunctionPointerForDelegate(_getNextRedeclarationImpl_0DelegateInstance).ToPointer();
                    _getPreviousDeclImpl_0DelegateInstance += _getPreviousDeclImpl_0DelegateHook;
                    _Thunks[5] = Marshal.GetFunctionPointerForDelegate(_getPreviousDeclImpl_0DelegateInstance).ToPointer();
                    _getMostRecentDeclImpl_0DelegateInstance += _getMostRecentDeclImpl_0DelegateHook;
                    _Thunks[6] = Marshal.GetFunctionPointerForDelegate(_getMostRecentDeclImpl_0DelegateInstance).ToPointer();
                    _getBody_0DelegateInstance += _getBody_0DelegateHook;
                    _Thunks[7] = Marshal.GetFunctionPointerForDelegate(_getBody_0DelegateInstance).ToPointer();
                    _hasBody_0DelegateInstance += _hasBody_0DelegateHook;
                    _Thunks[8] = Marshal.GetFunctionPointerForDelegate(_hasBody_0DelegateInstance).ToPointer();
                }

                if (_NewVTables == null)
                {
                    _NewVTables = new void*[1];
                    var vfptr0 = Marshal.AllocHGlobal(10 * 8);
                    _NewVTables[0] = vfptr0.ToPointer();
                    *(void**)(vfptr0 + 8) = _Thunks[0];
                    *(void**)(vfptr0 + 16) = _Thunks[1];
                    *(void**)(vfptr0 + 24) = _Thunks[2];
                    *(void**)(vfptr0 + 32) = _Thunks[3];
                    *(void**)(vfptr0 + 40) = _Thunks[4];
                    *(void**)(vfptr0 + 48) = _Thunks[5];
                    *(void**)(vfptr0 + 56) = _Thunks[6];
                    *(void**)(vfptr0 + 64) = _Thunks[7];
                    *(void**)(vfptr0 + 72) = _Thunks[8];
                    *(void**)(vfptr0 + 80) = *(void**)(native->vfptr0 + 80);
                }

                native->vfptr0 = new IntPtr(_NewVTables[0]);
            }

            #endregion
        }
    }
}
