//----------------------------------------------------------------------------
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
//----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace CppSharp
{
    /// <summary>
    /// <para>@{</para>
    /// </summary>
    /// <remarks>
    /// <para>/**</para>
    /// <para> * @defgroup LLVMCSupportTypes Types and Enumerations</para>
    /// <para> *</para>
    /// <para> * @{</para>
    /// <para> */</para>
    /// </remarks>
    public unsafe partial class Support
    {
        public partial struct Internal
        {
            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="LLVMLoadLibraryPermanently")]
            internal static extern int LLVMLoadLibraryPermanently_0(global::System.IntPtr Filename);

            [SuppressUnmanagedCodeSecurity]
            [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                EntryPoint="LLVMParseCommandLineOptions")]
            internal static extern void LLVMParseCommandLineOptions_0(int argc, sbyte** argv, global::System.IntPtr Overview);
        }

        /// <summary>
        /// <para>This function permanently loads the dynamic library at the given
        /// path. It is safe to call this function multiple times for the same
        /// library.</para>
        /// </summary>
        /// <remarks>
        /// <para>/**</para>
        /// <para> * This function permanently loads the dynamic library at the
        /// given path.</para>
        /// <para> * It is safe to call this function multiple times for the same
        /// library.</para>
        /// <para> *</para>
        /// <para> * @see sys::DynamicLibrary::LoadLibraryPermanently()</para>
        /// <para>  */</para>
        /// </remarks>
        public static int LLVMLoadLibraryPermanently(string Filename)
        {
            var arg0 = Marshal.StringToHGlobalAnsi(Filename);
            var __ret = Internal.LLVMLoadLibraryPermanently_0(arg0);
            Marshal.FreeHGlobal(arg0);
            return __ret;
        }

        /// <summary>
        /// <para>This function parses the given arguments using the LLVM command
        /// line parser. Note that the only stable thing about this function is its
        /// signature; you cannot rely on any particular set of command line arguments
        /// being interpreted the same way across LLVM versions.</para>
        /// </summary>
        /// <remarks>
        /// <para>/**</para>
        /// <para> * This function parses the given arguments using the LLVM
        /// command line parser.</para>
        /// <para> * Note that the only stable thing about this function is its
        /// signature; you</para>
        /// <para> * cannot rely on any particular set of command line arguments
        /// being interpreted</para>
        /// <para> * the same way across LLVM versions.</para>
        /// <para> *</para>
        /// <para> * @see llvm::cl::ParseCommandLineOptions()</para>
        /// <para> */</para>
        /// </remarks>
        public static void LLVMParseCommandLineOptions(int argc, sbyte** argv, string Overview)
        {
            var arg1 = argv;
            var arg2 = Marshal.StringToHGlobalAnsi(Overview);
            Internal.LLVMParseCommandLineOptions_0(argc, arg1, arg2);
            Marshal.FreeHGlobal(arg2);
        }
    }
}
