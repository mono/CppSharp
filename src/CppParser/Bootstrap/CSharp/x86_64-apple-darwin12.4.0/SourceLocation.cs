//----------------------------------------------------------------------------
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
//----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;

namespace CppSharp
{
    namespace clang
    {
        /// <summary>
        /// <para>An opaque identifier used by SourceManager which refers to a
        /// source file (MemoryBuffer) along with its #include path and #line
        /// data.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief An opaque identifier used by SourceManager which
        /// refers to a</para>
        /// <para>/// source file (MemoryBuffer) along with its \#include path and
        /// \#line data.</para>
        /// <para>///</para>
        /// </remarks>
        public unsafe partial class FileID : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 4)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public int ID;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang6FileIDC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang6FileIDC2ERKS0_")]
                internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang6FileID9isInvalidEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isInvalid_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang6FileIDeqERKS0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorEqualEqual_0(global::System.IntPtr instance, global::System.IntPtr RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang6FileIDltERKS0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorLess_0(global::System.IntPtr instance, global::System.IntPtr RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang6FileIDleERKS0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorLessEqual_0(global::System.IntPtr instance, global::System.IntPtr RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang6FileIDneERKS0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorExclaimEqual_0(global::System.IntPtr instance, global::System.IntPtr RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang6FileIDgtERKS0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorGreater_0(global::System.IntPtr instance, global::System.IntPtr RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang6FileIDgeERKS0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorGreaterEqual_0(global::System.IntPtr instance, global::System.IntPtr RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang6FileID11getSentinelEv")]
                internal static extern clang.FileID.Internal getSentinel_0();

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang6FileID12getHashValueEv")]
                internal static extern uint getHashValue_0(global::System.IntPtr instance);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, FileID> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, FileID>();

            private readonly bool __ownsNativeInstance;

            public static FileID __CreateInstance(global::System.IntPtr native)
            {
                return new FileID((FileID.Internal*) native);
            }

            public static FileID __CreateInstance(FileID.Internal native)
            {
                return new FileID(native);
            }

            private static FileID.Internal* __CopyValue(FileID.Internal native)
            {
                var ret = (FileID.Internal*) Marshal.AllocHGlobal(4);
                *ret = native;
                return ret;
            }

            private FileID(FileID.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected FileID(FileID.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public FileID()
            {
                __Instance = Marshal.AllocHGlobal(4);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.FileID __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public bool isInvalid()
            {
                var __ret = Internal.isInvalid_0(__Instance);
                return __ret;
            }

            public static bool operator ==(clang.FileID __op, clang.FileID RHS)
            {
                bool __opNull = ReferenceEquals(__op, null);
                bool RHSNull = ReferenceEquals(RHS, null);
                if (__opNull || RHSNull)
                    return __opNull && RHSNull;
                var arg0 = __op.__Instance;
                var arg1 = RHS.__Instance;
                var __ret = Internal.OperatorEqualEqual_0(arg0, arg1);
                return __ret;
            }

            public override bool Equals(object obj)
            {
                return this == obj as FileID;
            }

            public static bool operator <(clang.FileID __op, clang.FileID RHS)
            {
                var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
                var arg1 = ReferenceEquals(RHS, null) ? global::System.IntPtr.Zero : RHS.__Instance;
                var __ret = Internal.OperatorLess_0(arg0, arg1);
                return __ret;
            }

            public static bool operator <=(clang.FileID __op, clang.FileID RHS)
            {
                var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
                var arg1 = ReferenceEquals(RHS, null) ? global::System.IntPtr.Zero : RHS.__Instance;
                var __ret = Internal.OperatorLessEqual_0(arg0, arg1);
                return __ret;
            }

            public static bool operator !=(clang.FileID __op, clang.FileID RHS)
            {
                var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
                var arg1 = ReferenceEquals(RHS, null) ? global::System.IntPtr.Zero : RHS.__Instance;
                var __ret = Internal.OperatorExclaimEqual_0(arg0, arg1);
                return __ret;
            }

            public static bool operator >(clang.FileID __op, clang.FileID RHS)
            {
                var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
                var arg1 = ReferenceEquals(RHS, null) ? global::System.IntPtr.Zero : RHS.__Instance;
                var __ret = Internal.OperatorGreater_0(arg0, arg1);
                return __ret;
            }

            public static bool operator >=(clang.FileID __op, clang.FileID RHS)
            {
                var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
                var arg1 = ReferenceEquals(RHS, null) ? global::System.IntPtr.Zero : RHS.__Instance;
                var __ret = Internal.OperatorGreaterEqual_0(arg0, arg1);
                return __ret;
            }

            public uint getHashValue()
            {
                var __ret = Internal.getHashValue_0(__Instance);
                return __ret;
            }

            public static clang.FileID getSentinel()
            {
                var __ret = Internal.getSentinel_0();
                return clang.FileID.__CreateInstance(__ret);
            }
        }

        /// <summary>
        /// <para>Encodes a location in the source. The SourceManager can decode
        /// this to get at the full include stack, line and column information.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief Encodes a location in the source. The SourceManager
        /// can decode this</para>
        /// <para>/// to get at the full include stack, line and column
        /// information.</para>
        /// <para>///</para>
        /// <para>/// Technically, a source location is simply an offset into the
        /// manager's view</para>
        /// <para>/// of the input source, which is all input buffers (including
        /// macro</para>
        /// <para>/// expansions) concatenated in an effectively arbitrary order.
        /// The manager</para>
        /// <para>/// actually maintains two blocks of input buffers. One, starting
        /// at offset</para>
        /// <para>/// 0 and growing upwards, contains all buffers from this module.
        /// The other,</para>
        /// <para>/// starting at the highest possible offset and growing
        /// downwards, contains</para>
        /// <para>/// buffers of loaded modules.</para>
        /// <para>///</para>
        /// <para>/// In addition, one bit of SourceLocation is used for quick
        /// access to the</para>
        /// <para>/// information whether the location is in a file or a macro
        /// expansion.</para>
        /// <para>///</para>
        /// <para>/// It is important that this type remains small. It is currently
        /// 32 bits wide.</para>
        /// </remarks>
        public unsafe partial class SourceLocation : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 4)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public uint ID;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14SourceLocationC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14SourceLocationC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14SourceLocation8isFileIDEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isFileID_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14SourceLocation9isMacroIDEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isMacroID_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14SourceLocation7isValidEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isValid_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14SourceLocation9isInvalidEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isInvalid_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14SourceLocation16getLocWithOffsetEi")]
                internal static extern clang.SourceLocation.Internal getLocWithOffset_0(global::System.IntPtr instance, int Offset);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14SourceLocation14getRawEncodingEv")]
                internal static extern uint getRawEncoding_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14SourceLocation18getFromRawEncodingEj")]
                internal static extern clang.SourceLocation.Internal getFromRawEncoding_0(uint Encoding);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14SourceLocation14getPtrEncodingEv")]
                internal static extern global::System.IntPtr getPtrEncoding_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang14SourceLocation18getFromPtrEncodingEPKv")]
                internal static extern clang.SourceLocation.Internal getFromPtrEncoding_0(global::System.IntPtr Encoding);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14SourceLocation5printERN4llvm11raw_ostreamERKNS_13SourceManagerE")]
                internal static extern void print_0(global::System.IntPtr instance, global::System.IntPtr OS, global::System.IntPtr SM);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang14SourceLocation4dumpERKNS_13SourceManagerE")]
                internal static extern void dump_0(global::System.IntPtr instance, global::System.IntPtr SM);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clangeqERKNS_14SourceLocationES2_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorEqualEqual_0(global::System.IntPtr LHS, global::System.IntPtr RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clangneERKNS_14SourceLocationES2_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorExclaimEqual_0(global::System.IntPtr LHS, global::System.IntPtr RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clangltERKNS_14SourceLocationES2_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorLess_0(global::System.IntPtr LHS, global::System.IntPtr RHS);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, SourceLocation> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, SourceLocation>();

            private readonly bool __ownsNativeInstance;

            public static SourceLocation __CreateInstance(global::System.IntPtr native)
            {
                return new SourceLocation((SourceLocation.Internal*) native);
            }

            public static SourceLocation __CreateInstance(SourceLocation.Internal native)
            {
                return new SourceLocation(native);
            }

            private static SourceLocation.Internal* __CopyValue(SourceLocation.Internal native)
            {
                var ret = (SourceLocation.Internal*) Marshal.AllocHGlobal(4);
                *ret = native;
                return ret;
            }

            private SourceLocation(SourceLocation.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected SourceLocation(SourceLocation.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public SourceLocation()
            {
                __Instance = Marshal.AllocHGlobal(4);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.SourceLocation __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public bool isFileID()
            {
                var __ret = Internal.isFileID_0(__Instance);
                return __ret;
            }

            public bool isMacroID()
            {
                var __ret = Internal.isMacroID_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Return true if this is a valid SourceLocation object.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return true if this is a valid SourceLocation
            /// object.</para>
            /// <para>  ///</para>
            /// <para>  /// Invalid SourceLocations are often used when events have no
            /// corresponding</para>
            /// <para>  /// location in the source (e.g. a diagnostic is required for a
            /// command line</para>
            /// <para>  /// option).</para>
            /// </remarks>
            public bool isValid()
            {
                var __ret = Internal.isValid_0(__Instance);
                return __ret;
            }

            public bool isInvalid()
            {
                var __ret = Internal.isInvalid_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Return a source location with the specified offset from this
            /// SourceLocation.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return a source location with the specified offset
            /// from this</para>
            /// <para>  /// SourceLocation.</para>
            /// </remarks>
            public clang.SourceLocation getLocWithOffset(int Offset)
            {
                var __ret = Internal.getLocWithOffset_0(__Instance, Offset);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>When a SourceLocation itself cannot be used, this returns an
            /// (opaque) 32-bit integer encoding for it.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief When a SourceLocation itself cannot be used, this
            /// returns</para>
            /// <para>  /// an (opaque) 32-bit integer encoding for it.</para>
            /// <para>  ///</para>
            /// <para>  /// This should only be passed to
            /// SourceLocation::getFromRawEncoding, it</para>
            /// <para>  /// should not be inspected directly.</para>
            /// </remarks>
            public uint getRawEncoding()
            {
                var __ret = Internal.getRawEncoding_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>When a SourceLocation itself cannot be used, this returns an
            /// (opaque) pointer encoding for it.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief When a SourceLocation itself cannot be used, this
            /// returns</para>
            /// <para>  /// an (opaque) pointer encoding for it.</para>
            /// <para>  ///</para>
            /// <para>  /// This should only be passed to
            /// SourceLocation::getFromPtrEncoding, it</para>
            /// <para>  /// should not be inspected directly.</para>
            /// </remarks>
            public global::System.IntPtr getPtrEncoding()
            {
                var __ret = Internal.getPtrEncoding_0(__Instance);
                return __ret;
            }

            public void print(llvm.raw_ostream OS, clang.SourceManager SM)
            {
                var arg0 = ReferenceEquals(OS, null) ? global::System.IntPtr.Zero : OS.__Instance;
                var arg1 = ReferenceEquals(SM, null) ? global::System.IntPtr.Zero : SM.__Instance;
                Internal.print_0(__Instance, arg0, arg1);
            }

            public void dump(clang.SourceManager SM)
            {
                var arg0 = ReferenceEquals(SM, null) ? global::System.IntPtr.Zero : SM.__Instance;
                Internal.dump_0(__Instance, arg0);
            }

            public static bool operator >(clang.SourceLocation LHS, clang.SourceLocation RHS)
            {
                return !(LHS < RHS);
            }

            /// <summary>
            /// <para>Turn a raw encoding of a SourceLocation object into a real
            /// SourceLocation.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Turn a raw encoding of a SourceLocation object
            /// into</para>
            /// <para>  /// a real SourceLocation.</para>
            /// <para>  ///</para>
            /// <para>  /// \see getRawEncoding.</para>
            /// </remarks>
            public static clang.SourceLocation getFromRawEncoding(uint Encoding)
            {
                var __ret = Internal.getFromRawEncoding_0(Encoding);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Turn a pointer encoding of a SourceLocation object back into a
            /// real SourceLocation.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Turn a pointer encoding of a SourceLocation object
            /// back</para>
            /// <para>  /// into a real SourceLocation.</para>
            /// </remarks>
            public static clang.SourceLocation getFromPtrEncoding(global::System.IntPtr Encoding)
            {
                var arg0 = Encoding;
                var __ret = Internal.getFromPtrEncoding_0(arg0);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public static bool operator ==(clang.SourceLocation LHS, clang.SourceLocation RHS)
            {
                bool LHSNull = ReferenceEquals(LHS, null);
                bool RHSNull = ReferenceEquals(RHS, null);
                if (LHSNull || RHSNull)
                    return LHSNull && RHSNull;
                var arg0 = LHS.__Instance;
                var arg1 = RHS.__Instance;
                var __ret = Internal.OperatorEqualEqual_0(arg0, arg1);
                return __ret;
            }

            public override bool Equals(object obj)
            {
                return this == obj as SourceLocation;
            }

            public static bool operator !=(clang.SourceLocation LHS, clang.SourceLocation RHS)
            {
                var arg0 = ReferenceEquals(LHS, null) ? global::System.IntPtr.Zero : LHS.__Instance;
                var arg1 = ReferenceEquals(RHS, null) ? global::System.IntPtr.Zero : RHS.__Instance;
                var __ret = Internal.OperatorExclaimEqual_0(arg0, arg1);
                return __ret;
            }

            public static bool operator <(clang.SourceLocation LHS, clang.SourceLocation RHS)
            {
                var arg0 = ReferenceEquals(LHS, null) ? global::System.IntPtr.Zero : LHS.__Instance;
                var arg1 = ReferenceEquals(RHS, null) ? global::System.IntPtr.Zero : RHS.__Instance;
                var __ret = Internal.OperatorLess_0(arg0, arg1);
                return __ret;
            }
        }

        /// <summary>
        /// <para>A trivial tuple used to represent a source range.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief A trivial tuple used to represent a source
        /// range.</para>
        /// </remarks>
        public unsafe partial class SourceRange : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 8)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public clang.SourceLocation.Internal B;

                [FieldOffset(4)]
                public clang.SourceLocation.Internal E;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11SourceRangeC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11SourceRangeC2ENS_14SourceLocationE")]
                internal static extern void ctor_1(global::System.IntPtr instance, clang.SourceLocation.Internal loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11SourceRangeC2ENS_14SourceLocationES1_")]
                internal static extern void ctor_2(global::System.IntPtr instance, clang.SourceLocation.Internal begin, clang.SourceLocation.Internal end);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11SourceRangeC2ERKS0_")]
                internal static extern void cctor_3(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11SourceRange8getBeginEv")]
                internal static extern clang.SourceLocation.Internal getBegin_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11SourceRange6getEndEv")]
                internal static extern clang.SourceLocation.Internal getEnd_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11SourceRange8setBeginENS_14SourceLocationE")]
                internal static extern void setBegin_0(global::System.IntPtr instance, clang.SourceLocation.Internal b);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11SourceRange6setEndENS_14SourceLocationE")]
                internal static extern void setEnd_0(global::System.IntPtr instance, clang.SourceLocation.Internal e);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11SourceRange7isValidEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isValid_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11SourceRange9isInvalidEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isInvalid_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11SourceRangeeqERKS0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorEqualEqual_0(global::System.IntPtr instance, global::System.IntPtr X);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11SourceRangeneERKS0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorExclaimEqual_0(global::System.IntPtr instance, global::System.IntPtr X);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, SourceRange> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, SourceRange>();

            private readonly bool __ownsNativeInstance;

            public static SourceRange __CreateInstance(global::System.IntPtr native)
            {
                return new SourceRange((SourceRange.Internal*) native);
            }

            public static SourceRange __CreateInstance(SourceRange.Internal native)
            {
                return new SourceRange(native);
            }

            private static SourceRange.Internal* __CopyValue(SourceRange.Internal native)
            {
                var ret = (SourceRange.Internal*) Marshal.AllocHGlobal(8);
                *ret = native;
                return ret;
            }

            private SourceRange(SourceRange.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected SourceRange(SourceRange.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public SourceRange()
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public SourceRange(clang.SourceLocation loc)
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (loc.__Instance);
                Internal.ctor_1(__Instance, arg0);
            }

            public SourceRange(clang.SourceLocation begin, clang.SourceLocation end)
            {
                __Instance = Marshal.AllocHGlobal(8);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(begin, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (begin.__Instance);
                var arg1 = ReferenceEquals(end, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (end.__Instance);
                Internal.ctor_2(__Instance, arg0, arg1);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.SourceRange __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.SourceLocation getBegin()
            {
                var __ret = Internal.getBegin_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getEnd()
            {
                var __ret = Internal.getEnd_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public void setBegin(clang.SourceLocation b)
            {
                var arg0 = ReferenceEquals(b, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (b.__Instance);
                Internal.setBegin_0(__Instance, arg0);
            }

            public void setEnd(clang.SourceLocation e)
            {
                var arg0 = ReferenceEquals(e, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (e.__Instance);
                Internal.setEnd_0(__Instance, arg0);
            }

            public bool isValid()
            {
                var __ret = Internal.isValid_0(__Instance);
                return __ret;
            }

            public bool isInvalid()
            {
                var __ret = Internal.isInvalid_0(__Instance);
                return __ret;
            }

            public static bool operator ==(clang.SourceRange __op, clang.SourceRange X)
            {
                bool __opNull = ReferenceEquals(__op, null);
                bool XNull = ReferenceEquals(X, null);
                if (__opNull || XNull)
                    return __opNull && XNull;
                var arg0 = __op.__Instance;
                var arg1 = X.__Instance;
                var __ret = Internal.OperatorEqualEqual_0(arg0, arg1);
                return __ret;
            }

            public override bool Equals(object obj)
            {
                return this == obj as SourceRange;
            }

            public static bool operator !=(clang.SourceRange __op, clang.SourceRange X)
            {
                var arg0 = ReferenceEquals(__op, null) ? global::System.IntPtr.Zero : __op.__Instance;
                var arg1 = ReferenceEquals(X, null) ? global::System.IntPtr.Zero : X.__Instance;
                var __ret = Internal.OperatorExclaimEqual_0(arg0, arg1);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Represents a character-granular source range.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief Represents a character-granular source range.</para>
        /// <para>///</para>
        /// <para>/// The underlying SourceRange can either specify the
        /// starting/ending character</para>
        /// <para>/// of the range, or it can specify the start of the range and
        /// the start of the</para>
        /// <para>/// last token of the range (a &quot;token range&quot;).  In the
        /// token range case, the</para>
        /// <para>/// size of the last token must be measured to determine the
        /// actual end of the</para>
        /// <para>/// range.</para>
        /// </remarks>
        public unsafe partial class CharSourceRange : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 12)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public clang.SourceRange.Internal Range;

                [FieldOffset(8)]
                public bool IsTokenRange;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang15CharSourceRangeC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang15CharSourceRangeC2ENS_11SourceRangeEb")]
                internal static extern void ctor_1(global::System.IntPtr instance, clang.SourceRange.Internal R, bool ITR);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang15CharSourceRangeC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang15CharSourceRange13getTokenRangeENS_11SourceRangeE")]
                internal static extern clang.CharSourceRange.Internal getTokenRange_0(clang.SourceRange.Internal R);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang15CharSourceRange12getCharRangeENS_11SourceRangeE")]
                internal static extern clang.CharSourceRange.Internal getCharRange_0(clang.SourceRange.Internal R);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang15CharSourceRange13getTokenRangeENS_14SourceLocationES1_")]
                internal static extern clang.CharSourceRange.Internal getTokenRange_1(clang.SourceLocation.Internal B, clang.SourceLocation.Internal E);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang15CharSourceRange12getCharRangeENS_14SourceLocationES1_")]
                internal static extern clang.CharSourceRange.Internal getCharRange_1(clang.SourceLocation.Internal B, clang.SourceLocation.Internal E);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang15CharSourceRange12isTokenRangeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isTokenRange_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang15CharSourceRange11isCharRangeEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isCharRange_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang15CharSourceRange8getBeginEv")]
                internal static extern clang.SourceLocation.Internal getBegin_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang15CharSourceRange6getEndEv")]
                internal static extern clang.SourceLocation.Internal getEnd_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang15CharSourceRange10getAsRangeEv")]
                internal static extern global::System.IntPtr getAsRange_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang15CharSourceRange8setBeginENS_14SourceLocationE")]
                internal static extern void setBegin_0(global::System.IntPtr instance, clang.SourceLocation.Internal b);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang15CharSourceRange6setEndENS_14SourceLocationE")]
                internal static extern void setEnd_0(global::System.IntPtr instance, clang.SourceLocation.Internal e);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang15CharSourceRange7isValidEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isValid_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang15CharSourceRange9isInvalidEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isInvalid_0(global::System.IntPtr instance);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, CharSourceRange> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, CharSourceRange>();

            private readonly bool __ownsNativeInstance;

            public static CharSourceRange __CreateInstance(global::System.IntPtr native)
            {
                return new CharSourceRange((CharSourceRange.Internal*) native);
            }

            public static CharSourceRange __CreateInstance(CharSourceRange.Internal native)
            {
                return new CharSourceRange(native);
            }

            private static CharSourceRange.Internal* __CopyValue(CharSourceRange.Internal native)
            {
                var ret = (CharSourceRange.Internal*) Marshal.AllocHGlobal(12);
                *ret = native;
                return ret;
            }

            private CharSourceRange(CharSourceRange.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected CharSourceRange(CharSourceRange.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public CharSourceRange()
            {
                __Instance = Marshal.AllocHGlobal(12);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public CharSourceRange(clang.SourceRange R, bool ITR)
            {
                __Instance = Marshal.AllocHGlobal(12);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(R, null) ? new clang.SourceRange.Internal() : *(clang.SourceRange.Internal*) (R.__Instance);
                Internal.ctor_1(__Instance, arg0, ITR);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.CharSourceRange __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            /// <summary>
            /// <para>Return true if the end of this range specifies the start of the
            /// last token. Return false if the end of this range specifies the last
            /// character in the range.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return true if the end of this range specifies the
            /// start of</para>
            /// <para>  /// the last token.  Return false if the end of this range
            /// specifies the last</para>
            /// <para>  /// character in the range.</para>
            /// </remarks>
            public bool isTokenRange()
            {
                var __ret = Internal.isTokenRange_0(__Instance);
                return __ret;
            }

            public bool isCharRange()
            {
                var __ret = Internal.isCharRange_0(__Instance);
                return __ret;
            }

            public clang.SourceLocation getBegin()
            {
                var __ret = Internal.getBegin_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceLocation getEnd()
            {
                var __ret = Internal.getEnd_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }

            public clang.SourceRange getAsRange()
            {
                var __ret = Internal.getAsRange_0(__Instance);
                clang.SourceRange __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.SourceRange.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.SourceRange) clang.SourceRange.NativeToManagedMap[__ret];
                else __result0 = clang.SourceRange.__CreateInstance(__ret);
                return __result0;
            }

            public void setBegin(clang.SourceLocation b)
            {
                var arg0 = ReferenceEquals(b, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (b.__Instance);
                Internal.setBegin_0(__Instance, arg0);
            }

            public void setEnd(clang.SourceLocation e)
            {
                var arg0 = ReferenceEquals(e, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (e.__Instance);
                Internal.setEnd_0(__Instance, arg0);
            }

            public bool isValid()
            {
                var __ret = Internal.isValid_0(__Instance);
                return __ret;
            }

            public bool isInvalid()
            {
                var __ret = Internal.isInvalid_0(__Instance);
                return __ret;
            }

            public static clang.CharSourceRange getTokenRange(clang.SourceRange R)
            {
                var arg0 = ReferenceEquals(R, null) ? new clang.SourceRange.Internal() : *(clang.SourceRange.Internal*) (R.__Instance);
                var __ret = Internal.getTokenRange_0(arg0);
                return clang.CharSourceRange.__CreateInstance(__ret);
            }

            public static clang.CharSourceRange getCharRange(clang.SourceRange R)
            {
                var arg0 = ReferenceEquals(R, null) ? new clang.SourceRange.Internal() : *(clang.SourceRange.Internal*) (R.__Instance);
                var __ret = Internal.getCharRange_0(arg0);
                return clang.CharSourceRange.__CreateInstance(__ret);
            }

            public static clang.CharSourceRange getTokenRange(clang.SourceLocation B, clang.SourceLocation E)
            {
                var arg0 = ReferenceEquals(B, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (B.__Instance);
                var arg1 = ReferenceEquals(E, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (E.__Instance);
                var __ret = Internal.getTokenRange_1(arg0, arg1);
                return clang.CharSourceRange.__CreateInstance(__ret);
            }

            public static clang.CharSourceRange getCharRange(clang.SourceLocation B, clang.SourceLocation E)
            {
                var arg0 = ReferenceEquals(B, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (B.__Instance);
                var arg1 = ReferenceEquals(E, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (E.__Instance);
                var __ret = Internal.getCharRange_1(arg0, arg1);
                return clang.CharSourceRange.__CreateInstance(__ret);
            }
        }

        /// <summary>
        /// <para>A SourceLocation and its associated SourceManager.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief A SourceLocation and its associated
        /// SourceManager.</para>
        /// <para>///</para>
        /// <para>/// This is useful for argument passing to functions that expect
        /// both objects.</para>
        /// </remarks>
        public unsafe partial class FullSourceLoc : clang.SourceLocation, IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 16)]
            public new partial struct Internal
            {
                [FieldOffset(0)]
                public uint ID;

                [FieldOffset(8)]
                public global::System.IntPtr SrcMgr;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13FullSourceLocC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13FullSourceLocC2ENS_14SourceLocationERKNS_13SourceManagerE")]
                internal static extern void ctor_1(global::System.IntPtr instance, clang.SourceLocation.Internal Loc, global::System.IntPtr SM);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang13FullSourceLocC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13FullSourceLoc10getManagerEv")]
                internal static extern global::System.IntPtr getManager_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13FullSourceLoc9getFileIDEv")]
                internal static extern clang.FileID.Internal getFileID_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13FullSourceLoc15getExpansionLocEv")]
                internal static extern clang.FullSourceLoc.Internal getExpansionLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13FullSourceLoc14getSpellingLocEv")]
                internal static extern clang.FullSourceLoc.Internal getSpellingLoc_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13FullSourceLoc22getExpansionLineNumberEPb")]
                internal static extern uint getExpansionLineNumber_0(global::System.IntPtr instance, bool* Invalid);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13FullSourceLoc24getExpansionColumnNumberEPb")]
                internal static extern uint getExpansionColumnNumber_0(global::System.IntPtr instance, bool* Invalid);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13FullSourceLoc21getSpellingLineNumberEPb")]
                internal static extern uint getSpellingLineNumber_0(global::System.IntPtr instance, bool* Invalid);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13FullSourceLoc23getSpellingColumnNumberEPb")]
                internal static extern uint getSpellingColumnNumber_0(global::System.IntPtr instance, bool* Invalid);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13FullSourceLoc16getCharacterDataEPb")]
                internal static extern global::System.IntPtr getCharacterData_0(global::System.IntPtr instance, bool* Invalid);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13FullSourceLoc13getBufferDataEPb")]
                internal static extern llvm.StringRef.Internal getBufferData_0(global::System.IntPtr instance, bool* Invalid);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13FullSourceLoc16isInSystemHeaderEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isInSystemHeader_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13FullSourceLoc29isBeforeInTranslationUnitThanENS_14SourceLocationE")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isBeforeInTranslationUnitThan_0(global::System.IntPtr instance, clang.SourceLocation.Internal Loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13FullSourceLoc29isBeforeInTranslationUnitThanES0_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isBeforeInTranslationUnitThan_1(global::System.IntPtr instance, clang.FullSourceLoc.Internal Loc);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang13FullSourceLoc4dumpEv")]
                internal static extern void dump_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clangeqERKNS_13FullSourceLocES2_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorEqualEqual_0(global::System.IntPtr LHS, global::System.IntPtr RHS);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clangneERKNS_13FullSourceLocES2_")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool OperatorExclaimEqual_0(global::System.IntPtr LHS, global::System.IntPtr RHS);
            }

            /// <summary>
            /// <para>Comparison function class, useful for sorting
            /// FullSourceLocs.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Comparison function class, useful for sorting
            /// FullSourceLocs.</para>
            /// </remarks>
            public unsafe partial class BeforeThanCompare : IDisposable
            {
                [StructLayout(LayoutKind.Explicit, Size = 0)]
                public partial struct Internal
                {
                    [SuppressUnmanagedCodeSecurity]
                    [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                        EntryPoint="_ZN5clang13FullSourceLoc17BeforeThanCompareC2ERKS1_")]
                    internal static extern void cctor_1(global::System.IntPtr instance, global::System.IntPtr _0);
                }

                public global::System.IntPtr __Instance { get; protected set; }
                public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, BeforeThanCompare> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, BeforeThanCompare>();

                private readonly bool __ownsNativeInstance;

                public static BeforeThanCompare __CreateInstance(global::System.IntPtr native)
                {
                    return new BeforeThanCompare((BeforeThanCompare.Internal*) native);
                }

                public static BeforeThanCompare __CreateInstance(BeforeThanCompare.Internal native)
                {
                    return new BeforeThanCompare(native);
                }

                private static BeforeThanCompare.Internal* __CopyValue(BeforeThanCompare.Internal native)
                {
                    var ret = (BeforeThanCompare.Internal*) Marshal.AllocHGlobal(0);
                    *ret = native;
                    return ret;
                }

                private BeforeThanCompare(BeforeThanCompare.Internal native)
                    : this(__CopyValue(native))
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected BeforeThanCompare(BeforeThanCompare.Internal* native, bool isInternalImpl = false)
                {
                    __Instance = new global::System.IntPtr(native);
                }

                public BeforeThanCompare()
                {
                    __Instance = Marshal.AllocHGlobal(0);
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public void Dispose()
                {
                    Dispose(disposing: true);
                }

                protected virtual void Dispose(bool disposing)
                {
                    DestroyNativeInstance(false);
                }

                public virtual void DestroyNativeInstance()
                {
                    DestroyNativeInstance(true);
                }

                private void DestroyNativeInstance(bool force)
                {
                    clang.FullSourceLoc.BeforeThanCompare __dummy;
                    NativeToManagedMap.TryRemove(__Instance, out __dummy);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                }
            }

            private readonly bool __ownsNativeInstance;

            public static new FullSourceLoc __CreateInstance(global::System.IntPtr native)
            {
                return new FullSourceLoc((FullSourceLoc.Internal*) native);
            }

            public static FullSourceLoc __CreateInstance(FullSourceLoc.Internal native)
            {
                return new FullSourceLoc(native);
            }

            private static FullSourceLoc.Internal* __CopyValue(FullSourceLoc.Internal native)
            {
                var ret = (FullSourceLoc.Internal*) Marshal.AllocHGlobal(16);
                *ret = native;
                return ret;
            }

            private FullSourceLoc(FullSourceLoc.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected FullSourceLoc(FullSourceLoc.Internal* native, bool isInternalImpl = false)
                : base((clang.SourceLocation.Internal*) native)
            {
            }

            /// <summary>
            /// <para>Creates a FullSourceLoc where isValid() returns false.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Creates a FullSourceLoc where isValid() returns \c
            /// false.</para>
            /// </remarks>
            public FullSourceLoc()
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(16);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public FullSourceLoc(clang.SourceLocation Loc, clang.SourceManager SM)
                : this((Internal*) null)
            {
                __Instance = Marshal.AllocHGlobal(16);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                var arg1 = ReferenceEquals(SM, null) ? global::System.IntPtr.Zero : SM.__Instance;
                Internal.ctor_1(__Instance, arg0, arg1);
            }

            protected override void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
                base.Dispose(disposing);
            }

            public override void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.SourceLocation __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            public clang.SourceManager getManager()
            {
                var __ret = Internal.getManager_0(__Instance);
                clang.SourceManager __result0;
                if (__ret == IntPtr.Zero) __result0 = null;
                else if (clang.SourceManager.NativeToManagedMap.ContainsKey(__ret))
                    __result0 = (clang.SourceManager) clang.SourceManager.NativeToManagedMap[__ret];
                else __result0 = clang.SourceManager.__CreateInstance(__ret);
                return __result0;
            }

            public clang.FileID getFileID()
            {
                var __ret = Internal.getFileID_0(__Instance);
                return clang.FileID.__CreateInstance(__ret);
            }

            public clang.FullSourceLoc getExpansionLoc()
            {
                var __ret = Internal.getExpansionLoc_0(__Instance);
                return clang.FullSourceLoc.__CreateInstance(__ret);
            }

            public clang.FullSourceLoc getSpellingLoc()
            {
                var __ret = Internal.getSpellingLoc_0(__Instance);
                return clang.FullSourceLoc.__CreateInstance(__ret);
            }

            public uint getExpansionLineNumber(ref bool Invalid)
            {
                fixed (bool* arg0 = &Invalid)
                {
                    var __ret = Internal.getExpansionLineNumber_0(__Instance, arg0);
                    return __ret;
                }
            }

            public uint getExpansionColumnNumber(ref bool Invalid)
            {
                fixed (bool* arg0 = &Invalid)
                {
                    var __ret = Internal.getExpansionColumnNumber_0(__Instance, arg0);
                    return __ret;
                }
            }

            public uint getSpellingLineNumber(ref bool Invalid)
            {
                fixed (bool* arg0 = &Invalid)
                {
                    var __ret = Internal.getSpellingLineNumber_0(__Instance, arg0);
                    return __ret;
                }
            }

            public uint getSpellingColumnNumber(ref bool Invalid)
            {
                fixed (bool* arg0 = &Invalid)
                {
                    var __ret = Internal.getSpellingColumnNumber_0(__Instance, arg0);
                    return __ret;
                }
            }

            public string getCharacterData(ref bool Invalid)
            {
                fixed (bool* arg0 = &Invalid)
                {
                    var __ret = Internal.getCharacterData_0(__Instance, arg0);
                    return Marshal.PtrToStringAnsi(__ret);
                }
            }

            /// <summary>
            /// <para>Return a StringRef to the source buffer data for the specified
            /// FileID.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return a StringRef to the source buffer data for
            /// the</para>
            /// <para>  /// specified FileID.</para>
            /// </remarks>
            public llvm.StringRef getBufferData(ref bool Invalid)
            {
                fixed (bool* arg0 = &Invalid)
                {
                    var __ret = Internal.getBufferData_0(__Instance, arg0);
                    return llvm.StringRef.__CreateInstance(__ret);
                }
            }

            public bool isInSystemHeader()
            {
                var __ret = Internal.isInSystemHeader_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Determines the order of 2 source locations in the translation
            /// unit.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determines the order of 2 source locations in the
            /// translation unit.</para>
            /// <para>  ///</para>
            /// <para>  /// \returns true if this source location comes before 'Loc',
            /// false otherwise.</para>
            /// </remarks>
            public bool isBeforeInTranslationUnitThan(clang.SourceLocation Loc)
            {
                var arg0 = ReferenceEquals(Loc, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (Loc.__Instance);
                var __ret = Internal.isBeforeInTranslationUnitThan_0(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Determines the order of 2 source locations in the translation
            /// unit.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Determines the order of 2 source locations in the
            /// translation unit.</para>
            /// <para>  ///</para>
            /// <para>  /// \returns true if this source location comes before 'Loc',
            /// false otherwise.</para>
            /// </remarks>
            public bool isBeforeInTranslationUnitThan(clang.FullSourceLoc Loc)
            {
                var arg0 = ReferenceEquals(Loc, null) ? new clang.FullSourceLoc.Internal() : *(clang.FullSourceLoc.Internal*) (Loc.__Instance);
                var __ret = Internal.isBeforeInTranslationUnitThan_1(__Instance, arg0);
                return __ret;
            }

            /// <summary>
            /// <para>Prints information about this FullSourceLoc to stderr.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Prints information about this FullSourceLoc to
            /// stderr.</para>
            /// <para>  ///</para>
            /// <para>  /// This is useful for debugging.</para>
            /// </remarks>
            public void dump()
            {
                Internal.dump_0(__Instance);
            }

            public static bool operator ==(clang.FullSourceLoc LHS, clang.FullSourceLoc RHS)
            {
                bool LHSNull = ReferenceEquals(LHS, null);
                bool RHSNull = ReferenceEquals(RHS, null);
                if (LHSNull || RHSNull)
                    return LHSNull && RHSNull;
                var arg0 = LHS.__Instance;
                var arg1 = RHS.__Instance;
                var __ret = Internal.OperatorEqualEqual_0(arg0, arg1);
                return __ret;
            }

            public override bool Equals(object obj)
            {
                return this == obj as FullSourceLoc;
            }

            public static bool operator !=(clang.FullSourceLoc LHS, clang.FullSourceLoc RHS)
            {
                var arg0 = ReferenceEquals(LHS, null) ? global::System.IntPtr.Zero : LHS.__Instance;
                var arg1 = ReferenceEquals(RHS, null) ? global::System.IntPtr.Zero : RHS.__Instance;
                var __ret = Internal.OperatorExclaimEqual_0(arg0, arg1);
                return __ret;
            }
        }

        /// <summary>
        /// <para>Represents an unpacked &quot;presumed&quot; location which can be
        /// presented to the user.</para>
        /// </summary>
        /// <remarks>
        /// <para>/// \brief Represents an unpacked &quot;presumed&quot; location
        /// which can be presented</para>
        /// <para>/// to the user.</para>
        /// <para>///</para>
        /// <para>/// A 'presumed' location can be modified by \#line and GNU line
        /// marker</para>
        /// <para>/// directives and is always the expansion point of a normal
        /// location.</para>
        /// <para>///</para>
        /// <para>/// You can get a PresumedLoc from a SourceLocation with
        /// SourceManager.</para>
        /// </remarks>
        public unsafe partial class PresumedLoc : IDisposable
        {
            [StructLayout(LayoutKind.Explicit, Size = 24)]
            public partial struct Internal
            {
                [FieldOffset(0)]
                public global::System.IntPtr Filename;

                [FieldOffset(8)]
                public uint Line;

                [FieldOffset(12)]
                public uint Col;

                [FieldOffset(16)]
                public clang.SourceLocation.Internal IncludeLoc;

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11PresumedLocC2Ev")]
                internal static extern void ctor_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11PresumedLocC2EPKcjjNS_14SourceLocationE")]
                internal static extern void ctor_1(global::System.IntPtr instance, global::System.IntPtr FN, uint Ln, uint Co, clang.SourceLocation.Internal IL);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZN5clang11PresumedLocC2ERKS0_")]
                internal static extern void cctor_2(global::System.IntPtr instance, global::System.IntPtr _0);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11PresumedLoc9isInvalidEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isInvalid_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11PresumedLoc7isValidEv")]
                [return: MarshalAsAttribute(UnmanagedType.I1)]
                internal static extern bool isValid_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11PresumedLoc11getFilenameEv")]
                internal static extern global::System.IntPtr getFilename_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11PresumedLoc7getLineEv")]
                internal static extern uint getLine_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11PresumedLoc9getColumnEv")]
                internal static extern uint getColumn_0(global::System.IntPtr instance);

                [SuppressUnmanagedCodeSecurity]
                [DllImport("CppSharp", CallingConvention = global::System.Runtime.InteropServices.CallingConvention.Cdecl,
                    EntryPoint="_ZNK5clang11PresumedLoc13getIncludeLocEv")]
                internal static extern clang.SourceLocation.Internal getIncludeLoc_0(global::System.IntPtr instance);
            }

            public global::System.IntPtr __Instance { get; protected set; }
            public static readonly System.Collections.Concurrent.ConcurrentDictionary<IntPtr, PresumedLoc> NativeToManagedMap = new System.Collections.Concurrent.ConcurrentDictionary<IntPtr, PresumedLoc>();

            private readonly bool __ownsNativeInstance;

            public static PresumedLoc __CreateInstance(global::System.IntPtr native)
            {
                return new PresumedLoc((PresumedLoc.Internal*) native);
            }

            public static PresumedLoc __CreateInstance(PresumedLoc.Internal native)
            {
                return new PresumedLoc(native);
            }

            private static PresumedLoc.Internal* __CopyValue(PresumedLoc.Internal native)
            {
                var ret = (PresumedLoc.Internal*) Marshal.AllocHGlobal(24);
                *ret = native;
                return ret;
            }

            private PresumedLoc(PresumedLoc.Internal native)
                : this(__CopyValue(native))
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected PresumedLoc(PresumedLoc.Internal* native, bool isInternalImpl = false)
            {
                __Instance = new global::System.IntPtr(native);
            }

            public PresumedLoc()
            {
                __Instance = Marshal.AllocHGlobal(24);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                Internal.ctor_0(__Instance);
            }

            public PresumedLoc(string FN, uint Ln, uint Co, clang.SourceLocation IL)
            {
                __Instance = Marshal.AllocHGlobal(24);
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                var arg0 = Marshal.StringToHGlobalAnsi(FN);
                var arg3 = ReferenceEquals(IL, null) ? new clang.SourceLocation.Internal() : *(clang.SourceLocation.Internal*) (IL.__Instance);
                Internal.ctor_1(__Instance, arg0, Ln, Co, arg3);
                Marshal.FreeHGlobal(arg0);
            }

            public void Dispose()
            {
                Dispose(disposing: true);
            }

            protected virtual void Dispose(bool disposing)
            {
                DestroyNativeInstance(false);
            }

            public virtual void DestroyNativeInstance()
            {
                DestroyNativeInstance(true);
            }

            private void DestroyNativeInstance(bool force)
            {
                clang.PresumedLoc __dummy;
                NativeToManagedMap.TryRemove(__Instance, out __dummy);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
            }

            /// <summary>
            /// <para>Return true if this object is invalid or uninitialized.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return true if this object is invalid or
            /// uninitialized.</para>
            /// <para>  ///</para>
            /// <para>  /// This occurs when created with invalid source locations or
            /// when walking</para>
            /// <para>  /// off the top of a \#include stack.</para>
            /// </remarks>
            public bool isInvalid()
            {
                var __ret = Internal.isInvalid_0(__Instance);
                return __ret;
            }

            public bool isValid()
            {
                var __ret = Internal.isValid_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Return the presumed filename of this location.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the presumed filename of this location.</para>
            /// <para>  ///</para>
            /// <para>  /// This can be affected by \#line etc.</para>
            /// </remarks>
            public string getFilename()
            {
                var __ret = Internal.getFilename_0(__Instance);
                return Marshal.PtrToStringAnsi(__ret);
            }

            /// <summary>
            /// <para>Return the presumed line number of this location.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the presumed line number of this
            /// location.</para>
            /// <para>  ///</para>
            /// <para>  /// This can be affected by \#line etc.</para>
            /// </remarks>
            public uint getLine()
            {
                var __ret = Internal.getLine_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Return the presumed column number of this location.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the presumed column number of this
            /// location.</para>
            /// <para>  ///</para>
            /// <para>  /// This cannot be affected by \#line, but is packaged here for
            /// convenience.</para>
            /// </remarks>
            public uint getColumn()
            {
                var __ret = Internal.getColumn_0(__Instance);
                return __ret;
            }

            /// <summary>
            /// <para>Return the presumed include location of this location.</para>
            /// </summary>
            /// <remarks>
            /// <para>/// \brief Return the presumed include location of this
            /// location.</para>
            /// <para>  ///</para>
            /// <para>  /// This can be affected by GNU linemarker directives.</para>
            /// </remarks>
            public clang.SourceLocation getIncludeLoc()
            {
                var __ret = Internal.getIncludeLoc_0(__Instance);
                return clang.SourceLocation.__CreateInstance(__ret);
            }
        }
    }

    namespace llvm
    {
    }
}
